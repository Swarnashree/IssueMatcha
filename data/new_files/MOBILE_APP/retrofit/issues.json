[{"title":"JDK test tasks do not have dependencies set up correctly","body":"Re-running a test task will not recompile main sources, for example. Probably need to abandon copying the regular test task inputs and set things up ourselves.","comments":[],"labels":["PR welcome"],"number":4072},{"title":"R8 full mode and @Streaming giving runtime error with minifyEnabled","body":"Using Retrofit 2.9.0 and AGP 8.0.1 with fixes from https:\/\/github.com\/square\/retrofit\/issues\/3751 I still get one more error with R8 in full mode:\r\n\r\n```\r\nE  java.lang.IllegalArgumentException: Response must include generic type (e.g., Response<String>)\r\n     for method ContentApi.getRawFile\r\n        at retrofit2.Utils.methodError(SourceFile:54)\r\n        at retrofit2.Utils.methodError(SourceFile:43)\r\n        at retrofit2.HttpServiceMethod.parseAnnotations(SourceFile:77)\r\n        at retrofit2.ServiceMethod.parseAnnotations(SourceFile:39)\r\n        at retrofit2.Retrofit.loadServiceMethod(SourceFile:202)\r\n        at retrofit2.Retrofit$1.invoke(SourceFile:160)\r\n        at java.lang.reflect.Proxy.invoke(Proxy.java:1006)\r\n        at $Proxy23.getRawFile(Unknown Source)\r\n        at com.kivra.android.repository.ContentFileDownloader.downloadFile(SourceFile:40)\r\n        at com.kivra.android.repository.ContentPartFileTransform.fetchContentFiles(SourceFile:56)\r\n        at com.kivra.android.repository.ContentPartFileTransform.access$fetchContentFiles(SourceFile:28)\r\n        at com.kivra.android.repository.ContentPartFileTransform$transformData$2.invokeSuspend(SourceFile:42)\r\n        at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(SourceFile:33)\r\n        at kotlinx.coroutines.DispatchedTask.run(SourceFile:106)\r\n        at kotlinx.coroutines.internal.LimitedDispatcher.run(SourceFile:42)\r\n        at kotlinx.coroutines.scheduling.TaskImpl.run(SourceFile:95)\r\n        at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(SourceFile:570)\r\n        at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(SourceFile:750)\r\n        at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(SourceFile:677)\r\n        at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(SourceFile:664)\r\n```\r\n\r\nThis is how the signature looks like:\r\n```\r\n    @Streaming\r\n    @GET(\"{apiVersion}\/{actorType}\/{actorKey}\/content\/{contentKey}\/file\/{fileKey}\/raw\/{fileName}\")\r\n    suspend fun getRawFile(\r\n        @Path(\"apiVersion\") apiVersion: String,\r\n        @Path(\"actorType\") actorType: String,\r\n        @Path(\"actorKey\") actorKey: String,\r\n        @Path(\"contentKey\") contentKey: String,\r\n        @Path(\"fileKey\") fileKey: String,\r\n        @Path(\"fileName\") fileName: String\r\n    ): Response<ResponseBody>\r\n```\r\n\r\nMy best guess is that <ResponseBody> is getting stripped away but I don't know how to configure to not remove it. I thought this would have done it but apparently not:\r\n```\r\n# R8 full mode strips generic signatures from return types if not kept.\r\n-if interface * { @retrofit2.http.* public *** *(...); }\r\n-keep,allowoptimization,allowshrinking,allowobfuscation class <3>\r\n```\r\n\r\nSo perhaps something is missing still from this commit: https:\/\/github.com\/square\/retrofit\/commit\/59d302aedce5edae4806efac57b630d4fe8c27db ?","comments":["That commit is not in the released version. Copy it into your project shrinker config and it should work until the next version is released.","Ah sorry! I was meaning to say I added that bit locally and it did not fix this issue","Keeping the replaced rules and adding the new ones from the commit https:\/\/github.com\/square\/retrofit\/commit\/59d302aedce5edae4806efac57b630d4fe8c27db fixed the issue for me.\r\n\r\n```\r\n# With R8 full mode generic signatures are stripped for classes that are not\r\n# kept. Suspend functions are wrapped in continuations where the type argument\r\n# is used.\r\n-keep,allowobfuscation,allowshrinking class kotlin.coroutines.Continuation\r\n-keep,allowobfuscation,allowshrinking interface retrofit2.Call\r\n-keep,allowobfuscation,allowshrinking class retrofit2.Response\r\n\r\n# R8 full mode strips generic signatures from return types if not kept.\r\n-if interface * { @retrofit2.http.* public *** *(...); }\r\n-keep,allowoptimization,allowshrinking,allowobfuscation class <3>\r\n```","I have same problem when update AndroidStudio Flamingo & Gradle8.0.2\r\nWhen i call a post method,  crash:\r\n` java.lang.IllegalArgumentException: Unable to create call adapter for interface w4.d`\r\n\r\nBut i solve this\uff0c add [\"retrofit\/src\/main\/resources\/META-INF\/proguard\/retrofit2.pro\"](https:\/\/github.com\/square\/retrofit\/blob\/master\/retrofit\/src\/main\/resources\/META-INF\/proguard\/retrofit2.pro) all code into my proguard-rules.pro file\r\n \r\nMaybe we can wait for retrofit2 update new version to solve this problem totally.\r\n\r\n","I am facing a similar issue with `@Streaming` annotated functions, not really a crash but just the app loading forever (only on minified builds).\r\nWhat is interesting to point out is:\r\n- This works on debug builds (`minifyEnbaled = false`)\r\n- This does not works on signed builds (`minifyEnbaled = true`). Note: Tried both fullR8Support enabled and disabled.\r\n- This works on signed builds (`minifyEnbaled = true`) if I add the `HttpLoggingInterceptor`\r\n\r\nFinally, I have 2 very similar interfaces that are `@Streaming` annotated, and one works while the other doesn't (on signed builds with `minifyEnbaled = true`).\r\nThe working one is something like\r\n```\r\n    @Streaming\r\n    @GET\r\n    suspend fun downloadFile(@Url fileUrl: String): ResponseBody\r\n```\r\n\r\nThe **non**-working one is something like:\r\n```\r\n    @Streaming\r\n    @GET(\"api\/{${MY_ID}}\/bob\")\r\n    suspend fun downloadDocument(@Path(MY_ID) myId: String, @Query(TYPE) type: String): ResponseBody\r\n```\r\n\r\nThe only difference I can spot between the two is the different types of params added?\r\n\r\nUpdate: removing the `@Streaming` tag solves the issue \ud83e\udd14  Although that could be explained by the network protocol not supporting it, it still doesn't explain why it works on debug builds or with the logging interceptor \ud83d\ude05 "],"labels":["Needs Info"],"number":3898},{"title":"Client-Side host load-balance","body":" - [ ] Feature Request. i have found my company use client-side ip load-balance,the http domain is a special service identifier\uff0cfor example:global-user-credit\uff0cthen have a common method to get ip list from register center,then perform client-side load balancing\u3002but this special service identifier cannot be recognized by retrofit\u2018s HttpUrl class.so i have requirement,the  OkHttpClient.Builder to provider a new method ,for example:baseUrlFactory\uff0callows us to dynamically set base IP.","comments":["Our general policy for this has been to use an OkHttp interceptor to rewrite the Request object to target the desired host. You can use a global host at the Retrofit layer or even just use a dummy domain like `example.com` to ensure the interceptor is required to rewrite the URL.\r\n\r\nIn the future, we may consider a factory for base URLs which is invoked each time a request is created."],"labels":["Feature"],"number":3760},{"title":"Throwing retrofit2.HttpException HTTP 500 Internal Server Error, although exception is handled","body":"I am using coroutines to call the api, If the response code is 500 then the app is crashing even though I'm catching the exception. Below is the implementation:\r\n```\r\ninterface OnboardingApi {\r\n        @PUT(\"\/verifyOtp\")\r\n        suspend fun verifyOtp(@Body verifyOtpRequest: VerifyOtpRequest): Response<VerifyOtpResponse?>\r\n}\r\n\r\noverride suspend fun verifyOtp(verifyOtpPayload: VerifyOtpPayload): VerifyOtpResponse? {\r\n        try {\r\n            val response = onboardingApi.verifyOtp(\r\n                VerifyOtpRequest(\r\n                    getDeviceDetails(sharedPreferencesHelper),\r\n                    verifyOtpPayload.mobile,\r\n                    verifyOtpPayload.otp\r\n                )\r\n            )\r\n            return if (response.isSuccessful) {\r\n                response.body()\r\n            } else {\r\n                RetrofitUtils.getErrorBody<VerifyOtpResponse>(response.errorBody())\r\n            }\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n            FirebaseCrashlytics.getInstance().recordException(e)\r\n        }\r\n        return null\r\n    }\r\n\r\nand here is the stacktrace of the crash:\r\nFatal Exception: retrofit2.HttpException: HTTP 500 Internal Server Error\r\n       at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.java:53)\r\n       at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:161)\r\n       at com.google.firebase.perf.network.InstrumentOkHttpEnqueueCallback.onResponse(InstrumentOkHttpEnqueueCallback.java:71)\r\n       at okhttp3.RealCall$AsyncCall.execute(RealCall.java:203)\r\n       at okhttp3.internal.NamedRunnable.run(NamedRunnable.java:32)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\r\n       at java.lang.Thread.run(Thread.java:764)```","comments":["I have the same issue, any updates on this? ","Is this really a Retrofit2 problem or an internal FirebasePerf problem (I'm having the same issue)","I have the same issue with no dependencies on Firebase. The issue is in okhttp: any status code != 200 throws an unhandled exception, causing a crash. Timeout also causes app crash.","any update on this still having it ?","> any update on this still having it ?\r\n\r\nI personally searched in my codebase and then found a code like this in a `okhttp3.Authenticator`. (inside of its `authenticate()` method)\r\n\r\n```kotlin\r\nsomeCoroutineScope.launch {\r\n            \/\/ a retrofit call gets 4XX\r\n        }\r\n```\r\n\r\nbut it needs to have exception handlers:\r\n\r\n```kotlin\r\nscope.launch(CoroutineExceptionHandler { _, ex -> logThisException(ex) }) {\r\n            \/\/ a retrofit call gets 4XX\r\n        }\r\n```\r\n\r\nthis is how i fixed for now.","> > any update on this still having it ?\r\n> \r\n> I personally searched in my codebase and then found a code like this in a `okhttp3.Authenticator`. (inside of its `authenticate()` method)\r\n> \r\n> ```kotlin\r\n> someCoroutineScope.launch {\r\n>             \/\/ a retrofit call gets 4XX\r\n>         }\r\n> ```\r\n> \r\n> but it needs to have exception handlers:\r\n> \r\n> ```kotlin\r\n> scope.launch(CoroutineExceptionHandler { _, ex -> logThisException(ex) }) {\r\n>             \/\/ a retrofit call gets 4XX\r\n>         }\r\n> ```\r\n> \r\n> this is how i fixed for now.\r\n\r\nIf I use that exception handler, I lose the original exception and get\r\n```\r\nCoroutineCancelationException\r\n```\r\nI need to recover the original OkHttp exception, which has messages from the server","Same issue here.. any one found any solution yet?","Without a failing test case or minimally-reproducing sample project that demonstrates the problem it's impossible to know what's going on. I'll leave the issue open for 30 days in case someone wants to make one of those to aid us in debugging."],"labels":["Needs Info"],"number":3626},{"title":"Add support for Kotlin's Result","body":"Now that inline classes are stable in Kotlin 1.5.0, it would be nice to have API endpoints return [Result](https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin\/-result\/) to wrap the outcome (success\/failure) of a retrofit call, instead of returning a value or throwing an exception.\r\n\r\nFor example:\r\n\r\n```\r\n@GET(\"me\")\r\nsuspend fun getUser(): Result<User>\r\n```","comments":["I doubt if Retrofit should support kotlin Result at this moment, because returning kotlin Result from functions is not the default behavior.\r\n\r\nAnyway, [this call adapter](https:\/\/gist.github.com\/kobito-kaba\/1c209f01a74d190beb771ba7567a4d91) will work for your use case.\r\nnote:\r\nThat call adapter will work for `suspend fun foo() : Result<Foo>` , but won't work for `fun foo(): Result<Foo>` in some reasons.","Initially I thought that might be a good addition, but I guess you can always use [runCatching](https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin\/run-catching.html) if you want the type wrapped in `Result`\r\n\r\n```\r\nval user: Result<User> = runCatching {\r\n    api.getUser()\r\n }\r\n```","> val user: Result\\u003CUser> = runCatching {\\n    api.getUser()\\n }\n\n","You can try my solution - https:\/\/github.com\/agamula90\/RetrofitKx, hosted on mavenCentral, based on retrofit + moshi + ksp if you are are looking for better kotlin api"],"labels":["Feature"],"number":3558}]