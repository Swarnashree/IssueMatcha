[{"title":"[Bug]: Jest duplicates modules imported in both global setup\/teardown and code under test","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nhttps:\/\/github.com\/maslade\/jest-singleton-bug\r\n\r\n1. `npm install`\r\n2. `npm test`\r\n\r\n\r\n### Expected behavior\r\n\r\n1. \"Loading singleton\" only appears once in output.\r\n2. The task list in `global-teardown.js` contains two strings, one added `global-setup.js` before tests and one added in `sum.js` during testing.\r\n\r\n### Actual behavior\r\n\r\n1. \"Loading singleton\" appears twice.\r\n2. The task list in `global-teardown.js` the string added by `global-setup.js`, but not the one added by `sum.js` (because it's a separate module).\r\n\r\nFrom the trace, I suspect this is related to `pirates`.\r\n\r\n```sh\r\n> project@1.0.0 test\r\n> jest\r\n\r\nTrace: Loading singleton\r\n    at Object.<anonymous> (\/private\/tmp\/project\/src\/singleton.js:1:9)\r\n    ...\r\n    at Module._compile (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:117:24)\r\n    ...\r\n    at Object.newLoader [as .js] (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:121:7)\r\n    ...\r\n    at Object.<anonymous> (\/private\/tmp\/project\/src\/global-setup.js:4:5)\r\n    ...\r\n    at Module._compile (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:117:24)\r\n    ...\r\n    at Object.newLoader [as .js] (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:121:7)\r\n    ...\r\n    at requireOrImportModule (\/private\/tmp\/project\/node_modules\/jest-util\/build\/requireOrImportModule.js:44:28)\r\n    at ScriptTransformer.requireAndTranspileModule (\/private\/tmp\/project\/node_modules\/@jest\/transform\/build\/ScriptTransformer.js:798:66)\r\n    at runGlobalHook (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/runGlobalHook.js:101:27)\r\n    at async runJest (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/runJest.js:327:5)\r\n    at async _run10000 (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/cli\/index.js:343:7)\r\n    at async runCLI (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/cli\/index.js:198:3)\r\n    at async Object.run (\/private\/tmp\/project\/node_modules\/jest-cli\/build\/run.js:130:37)\r\nsetting up\r\nAdded task. [ 'task inside global setup' ]\r\n  console.error\r\n    Trace: Loading singleton\r\n        at Object.<anonymous> (\/private\/tmp\/project\/src\/singleton.js:1:37)\r\n        at Runtime._execModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1439:24)\r\n        at Runtime._loadModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n        at Runtime.requireModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n        at Runtime.requireModuleOrMock (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1048:21)\r\n        at Object.require (\/private\/tmp\/project\/src\/sum.js:1:21)\r\n        at Runtime._execModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1439:24)\r\n        at Runtime._loadModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n        at Runtime.requireModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n        at Runtime.requireModuleOrMock (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1048:21)\r\n        at Object.require (\/private\/tmp\/project\/src\/sum.test.js:1:17)\r\n        at Runtime._execModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1439:24)\r\n        at Runtime._loadModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n        at Runtime.requireModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n        at jestAdapter (\/private\/tmp\/project\/node_modules\/jest-circus\/build\/legacy-code-todo-rewrite\/jestAdapter.js:77:13)\r\n        at runTestInternal (\/private\/tmp\/project\/node_modules\/jest-runner\/build\/runTest.js:367:16)\r\n        at runTest (\/private\/tmp\/project\/node_modules\/jest-runner\/build\/runTest.js:444:34)\r\n\r\n    > 1 | console.trace( 'Loading singleton' );\r\n        |                                     ^\r\n      2 |\r\n      3 | const tasks = [];\r\n      4 |\r\n\r\n      at Object.<anonymous> (src\/singleton.js:1:37)\r\n      at Object.require (src\/sum.js:1:21)\r\n      at Object.require (src\/sum.test.js:1:17)\r\n\r\n  console.log\r\n    Added task. [ 'task inside test' ]\r\n\r\n      at log (src\/singleton.js:8:13)\r\n\r\nPASS src\/sum.test.js\r\n  Test\r\n    \u2713 should pass (1 ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        0.115 s, estimated 1 s\r\nRan all test suites.\r\ntearing down [ 'task inside global setup' ]\r\n```\r\n\r\n### Additional context\r\n\r\nMy actual situation is a large project that uses a third-party module as a DB provider. The module exports `{ getDb, closeDb }`. The code being tested imports `getDb` from this module to obtain DB handles and execute queries. The global teardown script imports `closeDb` from this module to clean up connections.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: macOS 13.6.3\r\n  CPU: (8) arm64 Apple M1\r\nBinaries:\r\n  Node: 16.15.1 - \/usr\/local\/bin\/node\r\n  npm: 9.8.1 - \/usr\/local\/bin\/npm\r\nnpmPackages:\r\n  jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"],"number":14987},{"title":"[Docs]: Egghead.io link on snapshot testing docs page is broken","body":"### Page(s)\n\nhttps:\/\/jestjs.io\/docs\/snapshot-testing#snapshot-testing-with-jest\n\n### Description\n\nThe link posted links to the snapshot testing with jest page. There is an info block there that reccommends watching a video from egghead.io to get more information on snapshot testing with jest. This link however, appears broken.","comments":[],"labels":["Documentation :book:"],"number":14986},{"title":"[Bug]: coverageThreshold for single path is not working","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nI have a react project set-up\r\n\r\napp\r\n- src\r\n   - pages\r\n      - Layout\r\n         -  index.tsx\r\n- jest.config.ts\r\n\r\nIn my jest.config.ts\r\n```sh\r\n\r\nmodule.exports = {\r\n\ttestEnvironment: 'jest-environment-jsdom',\r\n\tglobalSetup: '<rootDir>\/global-setup.js',\r\n\tsetupFilesAfterEnv: ['<rootDir>\/jest-setup.ts'],\r\n\tmoduleNameMapper: {\r\n\t\t'\\\\.(css|scss)$': 'identity-obj-proxy',\r\n\t\t'.+\\\\.svg$': 'jest-svg-transformer',\r\n\t\t'^axios$': require.resolve('axios'),\r\n\t\t'^src\/(.*)$': '<rootDir>\/src\/$1'\r\n\t},\r\n\tcollectCoverage: true,\r\n\tcoverageReporters: ['text', 'html', 'lcov'],\r\n\tcoverageThreshold: {\r\n\t\t'src\/pages\/Layout\/index.tsx': {\r\n\t\t\tbranches: 70,\r\n\t\t\tfunctions: 70,\r\n\t\t\tlines: 70,\r\n\t\t\tstatements: 70\r\n\t\t},\r\n\t\t'src\/**\/*.{js,jsx,ts,tsx}': {\r\n\t\t\tbranches: 80,\r\n\t\t\tfunctions: 80,\r\n\t\t\tlines: 80,\r\n\t\t\tstatements: 80\r\n\t\t}\r\n\t}\r\n};\r\n\r\nexport {};\r\n```\r\n\r\n### Expected behavior\r\n\r\nAfter reading the jest documentation on coverage threshold: https:\/\/jestjs.io\/docs\/configuration#coveragethreshold-object\r\nI expect a behaviour that the report will look into given threshold and remove the warning.\r\n\r\nCommand I run to clear jest cache:\r\n`\"test:clearCache\": \"jest --clearCache\"`\r\n\r\nCommand I use to run tests coverage:\r\n`npm run test -- --coverage`\r\n\r\n### Actual behavior\r\n\r\nI am trying to add a specific threshold for my Layout under pages but everytime I run test commands I do get\r\n`Jest: \"app\\src\\pages\\Layout\\index.tsx\" coverage threshold for branches (80%) not met: 77.77%`\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (16) x64 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz\r\n  Binaries:\r\n    Node: 16.16.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 8.11.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: 29.7.0 => 29.7.0\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"],"number":14985},{"title":"[Feature]: jest could detect some errors it is currently silencing when using `jsdom` environment","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nThe following tests will not show any error when using `jsdom` environment:\r\n```ts\r\ntest('leak microtask', () => {\r\n  setImmediate(() => expect(1).toBe(2));\r\n});\r\n\r\ntest('leak timer', () => {\r\n  setTimeout(() => expect(1).toBe(2));\r\n});\r\n```\r\n\r\nIt would be nice if Jest could detect pending timers or wait for them to finish on environment teardown.\r\n\r\nThere are different options. The cheapest workaround is the one used in vitest but it will only flush queued macrotasks and 0s timers:\r\nhttps:\/\/github.com\/vitest-dev\/vitest\/blob\/fee7d8be9d6e6f710270600ae91fa35d861b7075\/packages\/vitest\/src\/runtime\/setup-node.ts#L85\r\n\r\nIdeally, in addition to this, it would be nice to grab the pending timers from `jsdom` and show a warning or an error depending on some option like `detectPendingTimers` or simply wait until they all complete (or timeout).\r\nhttps:\/\/github.com\/jsdom\/jsdom\/blob\/2f8a7302a43fff92f244d5f3426367a8eb2b8896\/lib\/jsdom\/browser\/Window.js#L494 \r\n(happy-dom exposes a `waitUntilComplete()` function, we could contribute to jsdom in order to expose something similar)\r\n\r\n_Credits go to @rainerhahnekamp for raising the issue._\r\n\r\nI'll be happy to help with a PR.\r\n### Motivation\r\n\r\nThis will help Jest detect some issues that are currently silenced. This aligns with how vitest jsdom env works.\r\n\r\n### Example\r\n\r\n_No response_\r\n\r\n### Pitch\r\n\r\nThis will help Jest detect some issues that are currently silenced.","comments":[],"labels":[":rocket: Feature Request"],"number":14984},{"title":"[Bug]: 'node' entry in package.json exports is not respected","body":"### Version\n\n29.7.0 \n\n### Steps to reproduce\n\nI don't have an example of a public npm package with `node` in exports, to provide a reproduction scenario, but I can search for it or create a dummy one if it's absolutely necessary. It doesn't seem necessary though. Please see expected\/actual behavior sections.\n\n### Expected behavior\n\nIn [package.json exports specification](https:\/\/nodejs.org\/api\/packages.html#conditional-exports) we have:\r\n\r\n> \"node\" - matches for any Node.js environment. Can be a CommonJS or ES module file.\r\n\r\nSo it seems natural for jest to prioritize that over `default` key.\r\n\r\nProbably related code:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/d4d1f2b8004b1eb4bf0cf862698dd1142e13278f\/packages\/jest-resolve\/src\/defaultResolver.ts#L243\n\n### Actual behavior\n\nJest's resolver seems not to take `node` entry into account. For example, if exports field looks like this for a package:\r\n```json\r\n\"exports\": {\r\n    \".\": {\r\n      \"types\": \".\/index.d.ts\",\r\n      \"node\": \".\/index.cjs.js\",\r\n      \"default\": \".\/index.esm.js\"\r\n    }\r\n  }\r\n  ```\r\n  the package's main entry point should resolve to `index.cjs.js` and not `index.esm.js`.\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\nBinaries:\r\n    Node: 16.17.0 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/node\r\n    Yarn: 3.2.2 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/yarn\r\n    npm: 8.1.2 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/npm\r\n    pnpm: 8.15.4 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/pnpm\r\n\r\n  jest: 29.7.0\n```\n","comments":["> Jest's resolver seems not to take `node` entry into account. For example, if exports field looks like this for a package:\r\n\r\nthat doesn't have a `node` condition.\r\n\r\nHowever, we _do_ support the `node` condition, so a reproduction is needed \ud83d\ude42 ","> that doesn't have a node condition.\n\nIt was a copy paste issue. Edited now :)\n\n\n> However, we do support the node condition, so a reproduction is needed \ud83d\ude42\n\nAlright, then maybe it had something to do with the version of jest I was using. Will check if I can reproduce with the latest version."],"labels":["Needs Triage","Bug Report"],"number":14983},{"title":"[Feature]: Auto mock class \/ object","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nI know `jest.mock(path)` and it might have use cases. But why not just allow mocking any object? In this case, a class with instance. For inspiration see [ts-mockito](https:\/\/github.com\/NagRock\/ts-mockito).\r\n\r\n### Motivation\r\n\r\nA good example is testing an Angular service which has other services as injectable in constructor.\r\n\r\n```ts\r\n@Injectable({providedIn: 'root'})\r\nexport class MyService {\r\n  constructor(private anotherService: AnotherService) {}\r\n}\r\n```\r\n\r\nSo I need an instance of a service class for this constructor. Currently I need to rewrite the object structor.\r\n\r\n\r\n```ts\r\n\/\/ AnotherService Mock\r\n\r\nconst mockAnotherService = {\r\n  methodA: jest.fn(),\r\n  methodB: jest.fn(),\r\n  methodC: jest.fn(),\r\n  \/\/ etc\r\n}\r\n\r\nconst myService = new MyService(mockAnotherService);\r\n```\r\n\r\n### Example\r\n\r\nWith my proposal you only need:\r\n\r\n```ts\r\nconst mockAnotherService = jest.mock(AnotherService);\r\nconst mockInstance = jest.instance(mockAnotherService);\r\nconst myService = new MyService(mockInstance);\r\n```\r\n\r\n\r\n### Pitch\r\n\r\nIt's delightful with focus on simplicity. You can easily mock a class and pass\/use the mock instance everywhere.\r\n\r\n### Another Example\r\n\r\nHere is another more real world test.\r\n\r\n```ts\r\nconst mocks = {\r\n  serviceA: {\r\n    methodA: jest.fn(),\r\n    methodB: jest.fn(),\r\n    methodC: jest.fn(),\r\n    methodD: jest.fn(),\r\n    methodE: jest.fn(),\r\n  },\r\n  serviceB: {\r\n    methodA: jest.fn(),\r\n    methodB: jest.fn(),\r\n    methodC: jest.fn(),\r\n    methodD: jest.fn(),\r\n    methodE: jest.fn(),\r\n  },\r\n  serviceC: {\r\n    methodA: jest.fn(),\r\n  },\r\n  serviceD: {\r\n    methodA: jest.fn(),\r\n  },\r\n};\r\n\r\nbeforeEach(() => {\r\n  TestBed.configureTestingModule({\r\n    imports: [CommonModule],\r\n    providers: [\r\n      ServiceToTest,\r\n      { provide: ServiceA, useValue: mocks.serviceA },\r\n      { provide: ServiceB, useValue: mocks.serviceB },\r\n      { provide: ServiceC, useValue: mocks.serviceC },\r\n      { provide: ServiceD, useValue: mocks.serviceD },\r\n    ],\r\n  });\r\n\r\n  serviceToTest = TestBed.inject(ServiceToTest);\r\n});\r\n```\r\n\r\nThis is what I want:\r\n\r\n```ts\r\nconst mocks = {\r\n  serviceA: jest.mock(ServiceA),\r\n  serviceB: jest.mock(ServiceB),\r\n  serviceC: jest.mock(ServiceC),\r\n  serviceD: jest.mock(ServiceD),\r\n};\r\n\r\nbeforeEach(() => {\r\n  TestBed.configureTestingModule({\r\n    imports: [CommonModule],\r\n    providers: [\r\n      ServiceToTest,\r\n      { provide: ServiceA, useValue: jest.instance(mocks.serviceA) },\r\n      { provide: ServiceB, useValue: jest.instance(mocks.serviceB) },\r\n      { provide: ServiceC, useValue: jest.instance(mocks.serviceC) },\r\n      { provide: ServiceD, useValue: jest.instance(mocks.serviceD) },\r\n    ],\r\n  });\r\n\r\n  serviceToTest = TestBed.inject(ServiceToTest);\r\n});\r\n```\r\n\r\nThe `mock` and `instance` comes from [ts-mockito](https:\/\/github.com\/NagRock\/ts-mockito). Jest must not exactly implement it like this. It's just a demo. Under the hood I can use the methods like `jest.fn()`. So I don't have to create new objects with same structure like the class I want to mock. I prefer the automatic way.\r\n\r\n### Implementation\r\n\r\nNot sure how to implement it. But we could just use \r\n\r\n```ts\r\nObject.getOwnPropertyNames(ClassToMock.prototype)\r\n```\r\n\r\nand create a new object with that names and assign `jest.fn()`. Not sure how to do this with other properties. I thinking about creating a helper function as workaround to do this.\r\n\r\nMy current workaround (not fully tested):\r\n\r\n```ts\r\nfunction createMockObjectFromClass(classToMock) {\r\n  const mockObject = {};\r\n  const methodNames = Object.getOwnPropertyNames(classToMock.prototype);\r\n  methodNames.forEach((methodName) => {\r\n    if (typeof classToMock.prototype[methodName] === 'function') {\r\n      mockObject[methodName] = jest.fn();\r\n    }\r\n  });\r\n  return mockObject;\r\n}\r\n```\r\n\r\nNo need for `instance`, since it's just an object with the method. The fake instance. \r\n\r\n(Update: The names should be filtered with getOwnPropertyDescriptor to exclude get\/set. Also, abstract methods are not includes. It's on TypeScript level.)\r\n","comments":[],"labels":[":rocket: Feature Request"],"number":14974},{"title":"[Bug]: EMFILE: too many open files jest tests on github linux pipeline","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nThis error happens consistently whenever there are more than 100 test files, so it will likely happen if you use the same environment and many test files.\r\n#### Environment:\r\n* OS: Linux 6.5 Ubuntu 22.04.4 LTS 22.04.4 LTS (Jammy Jellyfish)\r\n* CPU: (2) x64 AMD EPYC 7763 64-Core Processor\r\n#### Project:\r\n* node: 18.14.0\r\n* jest: 29.7.0\r\n* typescript: 5.3.3\r\n* npm: 9.3.1\r\n#### Test command:\r\n```\r\n\"test:changedSince\": \"node --max-old-space-size=8192 --no-compilation-cache --expose-gc .\/node_modules\/jest\/bin\/jest.js --changedSince=origin\/master --maxWorkers=2  --logHeapUsage --coverage --coverage-provider=v8  --setupFiles dotenv\/config\",\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nWe're using jest with a typescript node project and we have a Github action to run coverage check\r\n```\r\nname: Build\r\non:\r\n push:\r\n   branches:\r\n     - master\r\n pull_request:\r\n   types: [opened, synchronize, reopened]\r\njobs:\r\n  coverage:\r\n    name: CoverageCheck\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions\/checkout@v4\r\n        with:\r\n          fetch-depth: 0\r\n      - run: git fetch --no-tags --depth=1 origin master\r\n      - uses: actions\/setup-node@v3\r\n        with:\r\n          node-version: 18.14.0\r\n      - name: Install dependencies\r\n        run: npm ci\r\n      - name: Test and coverage\r\n        run: npm run test:changedSince\r\n```\r\nand here's the script we're using here \r\n```\r\n \"test:changedSince\": \"node --max-old-space-size=8192 --no-compilation-cache --expose-gc .\/node_modules\/jest\/bin\/jest.js --changedSince=origin\/master --maxWorkers=2  --logHeapUsage --coverage --coverage-provider=v8  --setupFiles dotenv\/config\",\r\n```\r\nand it's working correctly for a small number of files\r\n\r\n### Actual behavior\r\n\r\nFor some reason, the action fails with this error whenever there are many files to be run\r\n```\r\nFAIL src\/firebase\/firebase.service.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    EMFILE: too many open files, open '\/home\/runner\/work\/ads-service\/ads-service\/src\/firebase\/firebase.service.spec.ts'\r\n\r\n      at runTestInternal (..\/node_modules\/jest-runner\/build\/runTest.js:170:27)\r\n\r\nFAIL src\/moderator\/moderator.controller.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    EMFILE: too many open files, uv_resident_set_memory\r\n\r\n      at runTestInternal (..\/node_modules\/jest-runner\/build\/runTest.js:418:36)\r\n```\r\n\r\n### Additional context\r\n\r\nI tried to use `watchman` but unfortunately it did not work \r\n```\r\nname: Build\r\non:\r\n push:\r\n   branches:\r\n     - master\r\n pull_request:\r\n   types: [opened, synchronize, reopened]\r\njobs:\r\n  coverage:\r\n    name: CoverageCheck\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions\/checkout@v4\r\n        with:\r\n          fetch-depth: 0\r\n      - run: git fetch --no-tags --depth=1 origin master\r\n      - uses: actions\/setup-node@v3\r\n        with:\r\n          node-version: 18.14.0\r\n      - name: Install Watchman\r\n        run: |\r\n          sudo apt-get update\r\n          sudo apt-get install -y watchman\r\n\r\n      - name: Increase open files limit\r\n        run: |\r\n          sudo sysctl -w fs.inotify.max_user_watches=524288\r\n          sudo sysctl -w fs.file-max=524288\r\n      - name: Install dependencies\r\n        run: npm ci\r\n      - name: Test and coverage\r\n        run: npm run test:changedSince\r\n```\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 6.5 Ubuntu 22.04.4 LTS 22.04.4 LTS (Jammy Jellyfish)\r\n    CPU: (2) x64 AMD EPYC 7763 64-Core Processor\r\n  Binaries:\r\n    Node: 18.14.0 - \/opt\/hostedtoolcache\/node\/18.14.0\/x64\/bin\/node\r\n    Yarn: 1.22.22 - \/usr\/local\/bin\/yarn\r\n    npm: 9.3.1 - \/opt\/hostedtoolcache\/node\/18.14.0\/x64\/bin\/npm\r\n```\r\nDo you have any idea what could be the reason for this error? \r\nThanks in advance.","comments":["We'll need a reproduction to look at this","> We'll need a reproduction to look at this\r\n\r\nUnfortunately, our code base is private so I don't think I'll be able to share the code here, do you have any suggestion to share the reproduction if the code is private?\r\n@SimenB ","Not really, unfortunately. I've never seen this error before, so it's highly likely to be something specific to your project. The ways of creating a reproduction is quite well laid out in https:\/\/stackoverflow.com\/help\/minimal-reproducible-example"],"labels":["Needs Triage","Bug Report"],"number":14972},{"title":"[Bug]: required inputs in Angular afterNextRender hook throws an error in jest","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Pull down this project, https:\/\/github.com\/Tedgar20\/requiredInputs\/tree\/master\r\n2. npm i (make sure you're on Node >= 20)\r\n3. npm run test\r\n\r\nYou'll notice that 2\/3 tests written in test.component.spec.ts fail even though in actually use when running the application everything works fine. If you start the project using \"npm run start\" you'll see that there are no errors in the browser and Angular handles the required input fine\n\n### Expected behavior\n\nI expect that when i create a component and provide all its necessary inputs that jest wouldn't throw this error as long as the input is used in a hook where it is guranteed to be defined. The afterNextRender hook gurantees that inputs will be available\n\n### Actual behavior\n\nRegardless of how I set up the component for testing jest or I guess Angular will throw the error \"ERROR RuntimeError: NG0950: Input is required but no value is available yet. Find more at https:\/\/angular.io\/errors\/NG0950\"\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.4 Ubuntu 20.04.4 LTS (Focal Fossa)\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz\r\n  Binaries:\r\n    Node: 20.11.1 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/node\r\n    npm: 10.2.4 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":[],"labels":["Needs Triage","Bug Report"],"number":14965},{"title":"[Feature]: Print all `Error` properties instead of only `.stack` and `.cause`","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nWhy does `jest` limit the output of in the test run occured errors on `.stack` and `.cause`? I would love to see all properties printed to quickly identitfy the occured error and its cause. That would be nice if you use your own Error classes with custom fields.\r\n\r\n### Motivation\r\n\r\nsee above\r\n\r\n### Example\r\n\r\n```typescript\r\nit('fails', () => {\r\n  throw Object.assign(new Error('dummy error'), { extra: 'field' });\r\n});\r\n```\r\n\r\nRunning this test only prints `Error: dummy error` to the console.\r\n\r\n### Pitch\r\n\r\nSometimes tests fail because of custom errors with other fields than `.stack` and `.cause`. It would be nice to have all details available diretly in the test output.\r\nAlso it is the default behaviour in Node.js if a statement throws an Error, see\r\n\r\n```\r\n$ node\r\n> function test() { throw Object.assign(new Error('test'), { foo: 42 }) }\r\nundefined\r\n> \r\n> \r\n> \r\n> test()\r\nUncaught Error: test\r\n    at test (REPL2:1:39) {\r\n  foo: 42\r\n}\r\n```","comments":["We added a feature to the `jest-message-util` implementation for a possible new error formatting. Is this something you would consider having for `jest`?\r\n\r\nRunning\r\n\r\n```typescript\r\nclass TestError extends Error {}\r\n\r\ndescribe('throwError', () => {\r\n  it.only('fails', () => {\r\n    throw Object.assign(\r\n      new TestError('dummy error', { cause: new TestError('testerrortwo', { cause: new Error('end') }) }),\r\n      { extra: 'field' },\r\n    );\r\n  });\r\n});\r\n```\r\n\r\nnow yields:\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/37102755\/57872a53-cd03-4351-bfc9-321d3952dcd4)\r\n\r\nThis prints all error fields and also uses the special handling of the `cause` field through Node's `utils.inspect` function.\r\n\r\nThe current output is formatted like this (missing extra fields):\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/37102755\/9754c997-398c-4738-ab77-795b54f5facf)\r\n\r\nBefore advancing with this we wanted to make sure this is considerable for `jest`. And if so, how could we add this? One variant could be adding a new config parameter to turn it on.\r\n\r\nCheers, Luis"],"labels":[":rocket: Feature Request"],"number":14964},{"title":"[Bug]: Errors thrown in setTimeout callback are not caught by test.failing","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Clone my repo at https:\/\/github.com\/nathanielks\/jest-test-failing-settimeout\r\n2. `npm i`\r\n3. `npm test`\r\n4. Jest will not mark the setTimeout test as passing\n\n### Expected behavior\n\nI expect tests run with `test.failing` to be marked as passing when an error is thrown in a `setTimeout` callback.\n\n### Actual behavior\n\nThe test is not being marked as passing:\r\n\r\n```\r\n> test-failing-settimeout@1.0.0 test\r\n> node --experimental-vm-modules node_modules\/.bin\/jest\r\n\r\n FAIL  tests\/setTimeout.test.js\r\n  Timers\r\n    \u2713 throwing errors with test.failing marks tests as passing\r\n    \u2715 throwing errors in setTimeout with test.failing marks tests as passing (10 ms)\r\n\r\n  \u25cf Timers \u203a throwing errors in setTimeout with test.failing marks tests as passing\r\n\r\n\r\n\r\n       7 |\r\n       8 |   test.failing('throwing errors in setTimeout with test.failing marks tests as passing', async () => {\r\n    >  9 |     setTimeout(() => { throw new Error() }, 5)\r\n         |                              ^\r\n      10 |     await wait(10) \r\n      11 |   })\r\n      12 | })\r\n\r\n      at Timeout._onTimeout (tests\/setTimeout.test.js:9:30)\r\n\r\n  \u25cf Timers \u203a throwing errors in setTimeout with test.failing marks tests as passing\r\n\r\n    Failing test passed even though it was supposed to fail. Remove `.failing` to remove error.\r\n\r\n       6 |   })\r\n       7 |\r\n    >  8 |   test.failing('throwing errors in setTimeout with test.failing marks tests as passing', async () => {\r\n         |        ^\r\n       9 |     setTimeout(() => { throw new Error() }, 5)\r\n      10 |     await wait(10) \r\n      11 |   })\r\n\r\n      at tests\/setTimeout.test.js:8:8\r\n      at tests\/setTimeout.test.js:3:1\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        0.126 s, estimated 1 s\r\nRan all test suites.\r\n```\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (8) arm64 Apple M1\r\n  Binaries:\r\n    Node: 20.10.0 - ~\/.nvm\/versions\/node\/v20.10.0\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.5 - ~\/.nvm\/versions\/node\/v20.10.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["I had a thought to see what the behavior would be when using [Timer Mocks](https:\/\/jestjs.io\/docs\/timer-mocks). Interestingly, the expected behavior is the actual behavior. Said another way: when using Timer Mocks, errors thrown in setTimeout callbacks are caught and failing tests are marked as passing when using `test.failing`.\r\n\r\nI've added [this test](https:\/\/github.com\/nathanielks\/jest-test-failing-settimeout\/commit\/1c208fdf605ddcb36a52b0a932bba977c66f83a5) to the linked repo:\r\n\r\n```javascript\r\nimport { jest } from '@jest\/globals'\r\n\r\njest.useFakeTimers()\r\ndescribe('Timers', () => {\r\n  test.failing('throwing errors in setTimeout with test.failing marks tests as passing with fake timers', async () => {\r\n    setTimeout(() => { throw new Error() }, 5)\r\n    jest.runAllTimers()\r\n  })\r\n})\r\n```"],"labels":["Needs Triage","Bug Report"],"number":14963}]