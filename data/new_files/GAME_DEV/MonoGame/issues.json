[{"title":"[PAID BOUNTY] A shared base for public and console repos","body":"_MonoGame needs a new base that can be used between public and private console repos._\r\n\r\n\ud83d\udcc3**Full details**\r\n\r\nMonoGame provides console ports of itself in private repos, all you need to do to access it is to be a registered developer for the correct platform. They are in private repos because of the console NDAs.\r\n\r\nIn order to make the work between the public and private repos less separate, we wanted to move MonoGame to a new system where there will be one C# **MonoGame.Framework.dll** assembly that can be used for both. It would containt only the C# wrapper calls to our custom **monogameframework** native library, then we could switch out the native library depending on the platform you are targeting.\r\n\r\n\ud83d\udfe2 **Bounty status**\r\n\r\nOpen for applications. \u23f3\r\n\r\n\ud83d\udcb0 **Bounty**\r\n\r\n$1200,00 USD (One thousand and two hundred US dollars).\r\n\r\n\u270b **Requirements to apply**\r\n\r\n_Standard requirements from [our generic bounty requirements](https:\/\/monogame.net\/bounties\/#requirements) as well as knowlage on C++, C++ build systems, Vulkan and SDL._\r\n\r\n\ud83d\udce6 **Expected delivery content**\r\n\r\n- **MonoGame.Frameowk.Native** C# project\r\n  - All C# Stubs need to be fully filled with wrapper calls to **monogameframework**\r\n  - A generator needs to be writted to export all the wrappers to header files that need to be filled using reflection\r\n  - Needs to be hooked up to the tests and passing non graphics \/ audio tests\r\n- **monogameframework** native library\r\n  - This library needs to contain exposed methods for all the platform call MonoGame does\r\n  - All platform calls need to be fully implemented (Windowing + Input, using SDL)\r\n  - Vulkan code needs to be moved from the private MonoGame repo\r\n    - All graphics calls need to be fully hooked up, it does not need to be fully working\r\n  - No audio call should be implemented, we are planing on using FAudio and a relavent bounty for it will be released at future time\r\n- Both projects need to be fully hooked up to the CAKE Frosting build system\r\n\r\n\ud83d\udcc5 **Delivery timeline**\r\n\r\nAs soon as possible.\r\n","comments":[],"labels":["Bounty"],"number":8242},{"title":"[PAID BOUNTY] [LOCKED] Package up ffmpeg and ffprobe","body":"_MonoGame needs to package up ffmpeg and ffprobe for content compilation._\r\n\r\n\ud83d\udcc3**Full details**\r\n\r\nIn order to improve the maintainability of the 3rd party dependencies and tooling, we are trying to prepare the compilation and packaging for ffmpeg and ffprobe as per #8124.\r\n\r\nWhats expected from this task is to build 3 repositories, one for shared tooling build scripts and two repositories for the ffmpeg and ffprobe executables, see \"Expected delivery content*\" bellow for clearer details.\r\n\r\nThe MonoGame Foundation wishes to accelerate this transition by offering a paid opportunity to undertake this task.\r\n\r\n\ud83d\udd12 **Bounty status**\r\n\r\nLocked for @AristurtleDev to complete. \ud83d\udd12\r\n\r\n\ud83d\udcb0 **Bounty**\r\n\r\n$360,00 USD (Three hundred and sixty US dollars).\r\n\r\n\u270b **Requirements to apply**\r\n\r\n_Standard requirements from [our generic bounty requirements](https:\/\/monogame.net\/bounties\/#requirements)._\r\n\r\n\ud83d\udce6 **Expected delivery content**\r\n\r\n- **MonoGame.Tool.BuildScripts** repository that can be used as a shared scripts repository for all future tooling (Similary structured as [MonoGame.Library.BuildScripts](https:\/\/github.com\/MonoGame\/MonoGame.Library.BuildScripts)).\r\n- **MonoGame.Tool.FFMpeg** repository containing the packaging scripts for the ffmpeg executable. (Similary structured as [MonoGame.Library.FreeType](https:\/\/github.com\/MonoGame\/MonoGame.Library.FreeType)).\r\n  - Should build the latest stable version of ffmpeg.\r\n  - Should be packaged into a dotnet tool `mgcb-ffmpeg`.\r\n  - Should upload the nuget to GitHub packages on build.\r\n- **MonoGame.Tool.FFProbe** repository containting the packaging scripts for the ffprobe executable. (Similary structured as [MonoGame.Library.FreeType](https:\/\/github.com\/MonoGame\/MonoGame.Library.FreeType)).\r\n  - Should build the latest stable version of ffprobe.\r\n  - Should be packaged into a dotnet tool `mgcb-ffprobe`.\r\n  - Should upload the nuget to GitHub packages on build.\r\n- The C# coding style should match the standard Microsofts C# coding style guideliness.\r\n- The build scripts in all repository should use CAKE Frosting.\r\n- The CI system in all repositories should use GitHub Actions.\r\n\r\n\ud83d\udcc5 **Delivery timeline**\r\n\r\nAs soon as possible.\r\n","comments":[],"labels":["Bounty"],"number":8241},{"title":"PathHelper.GetRelativePath potential bugs","body":"### Prerequisites\r\n\r\n- [X] I have verified this issue is present in the `develop` branch\r\n- [X] I have searched [open](https:\/\/github.com\/MonoGame\/MonoGame\/issues) and [closed](https:\/\/github.com\/MonoGame\/MonoGame\/issues?q=is%3Aissue+is%3Aclosed) issues to ensure it has not already been reported.\r\n\r\n### MonoGame Version\r\n\r\nMonoGame 3.8.1\r\n\r\n### Which MonoGame platform are you using?\r\n\r\nMonoGame DesktopGL\r\n\r\n### Operating System\r\n\r\nWIndows\r\n\r\n### Description\r\nThe problem reside in function **GetRelativePath(string basePath, string path)** in file **MonoGame.Framework.Content.Pipeline\/Builder\/PathHelper.cs**\r\n```c#\r\npublic static string GetRelativePath(string basePath, string path)\r\n{\r\n    Uri uri;\r\n    if (!Uri.TryCreate(path, UriKind.Absolute, out uri))\r\n        return path;\r\n\r\n    uri = new Uri(basePath).MakeRelativeUri(uri);\r\n    var str = Uri.UnescapeDataString(uri.ToString());\r\n\r\n    return Normalize(str);\r\n}\r\n```\r\nThe issue is the return result of **PathHelper.GetRelativePath()** is relative path without the dot as the first char\r\n- The true result should be **.\/bin\/pathtomycontent.xnb**\r\n- But instead **\/bin\/pathtomycontent.xnb** without the '.'\r\n\r\nAs we understand, path without the first dot is treated as an rooted path by .NET\r\n\r\nThis is where the piece of code calling **PathHelper.GetRelativePath()** bug appears, \r\nthe function in **MonoGame.Framework.Content.Pipeline\/Builder\/PipelineManager.cs** file which retrieve infomation of cached .mgcontent file\r\n```c#\r\nprivate PipelineBuildEvent LoadBuildEvent(string destFile, out string eventFilepath)\r\n{\r\n    var contentPath = Path.ChangeExtension(PathHelper.GetRelativePath(OutputDirectory, destFile), PipelineBuildEvent.Extension);\r\n    eventFilepath = Path.Combine(IntermediateDirectory, contentPath); \/\/ This is where we messed up\r\n    return PipelineBuildEvent.Load(eventFilepath);\r\n}\r\n```\r\n**Path.Combine()** will only process the latter argument because **contentPath** is rooted and ignore **IntermediateDirectory**\r\n\r\n### Steps to Reproduce\r\n\r\nThe problem can be reproduced by calling the function with **destFile** is a full subpath of OutputDirectory. \r\n\r\nFor example calling **LoadBuildEvent(\"D:\\\\MyMonoGameProject\\\\Content\\\\out\\\\MyGameImage.xnb\", out string eventFilepath)** with **OutputDirectory** is **\"D:\\\\MyMonoGameProject\\\\Content\\\\out\\\\\"**\r\n\r\n### Expected Behavior\r\n\r\nThe out parameter **eventFilepath** should be **\"D:\\\\MyMonoGameProject\\\\Content\\\\obj\\\\MyGameImage.mgcontent\"** if the value of **IntermediateDirectory** is **D:\\\\MyMonoGameProject\\\\Content\\\\obj\\\\**\r\n\r\n### Resulting Behavior\r\n\r\nBut instead the result of **eventFilepath** be **\\MyGameImage.mgcontent** because **PathHelper.GetRelativePath()** return a rooted path","comments":["Hey, I am a first time contributor to MonoGame and I would like to work on this issue.","Hey again. Walked through the steps to replicate the issue and couldn't seem to replicate the issue at all. Currently I am using .NET 8 as my .NET version. When using console output, the GetRelativePath function returned a value without a '.' or a '.\/' in front of it. For an example, my file I was loading was under ProjectDir\\Content\\bin\\ball.xnb and when calling LoadBuildEvent with that file, it gave me an event file path as expected under the Intermediate directory. \r\n\r\nWhen looking at the documentation for Uri, it also shows that it should be returning a path without a '.' or '.\/' in front of it as I was able to get.\r\n\r\nCould @gameoflord012 replicate the issue and post a screenshot or video? That'd be much appreciated if this is an issue that is persisting. "],"labels":["Help Wanted","Good First Issue"],"number":8208},{"title":"[PAID BOUNTY] [LOCKED] Implement the Direct3D 12 \/ GDK\/GDKX backend","body":"_MonoGame needs a Direct3D 12 implementation based on the GDK\/GDKX._\r\n\r\n\ud83d\udcc3**Full details**\r\n\r\nThis implementation will be the new Windows and Xbox targets, and would replace the current WindowsDX, UWP, and Xbox targets altogether.\r\n\r\n\"D3D 11 on 12\" is not allowed in this context. Therefore, we require an actual D3D12 implementation. The use of DirectXTK is allowed.\r\n\r\n@tomspilman has worked on a partial implementation already but couldn't finish it. He's making it available to the applicant in a private repository. The state of this work requires pipeline and memory management to be done.\r\n\r\nThe Xbox (GDKX) and Windows (GDK) targets are expected to share 99% of the code. We expect that one codebase to be shared between the future WindowsDX and Xbox targets (which should be Windows Store compliant).\r\n\r\n\ud83d\udd12 **Bounty status**\r\n\r\nLocked for @Togimaro to complete. \ud83d\udd12\r\n\r\n\ud83d\udcb0 **Bounty**\r\n\r\n$5.000,00 USD (Five thousands US dollars).\r\n\r\n\u270b **Requirements to apply**\r\n\r\n_In addition to [our generic bounty requirements](https:\/\/monogame.net\/bounties\/#requirements), here are requirements specific to this bounty._\r\n\r\nThis bounty requires to be a registered console developer with Microsoft in order to access the GDKX.\r\n\r\n\ud83d\udce6 **Expected delivery content**\r\n\r\n- A Windows GDK implementation of MonoGame\r\n- An Xbox GDKX implementation of MonoGame running with NativeAOT.\r\n\r\n\ud83d\udcc5 **Delivery timeline**\r\n\r\nAs soon as possible.","comments":["Following the foundation meeting of March 14, the applications have been reviewed and this bounty has been locked for @Togimaro to complete."],"labels":["Bounty"],"number":8195},{"title":"[PAID BOUNTY] [LOCKED] Switch the console runtime from BRUTE to NativeAOT","body":"_The MonoGame Foundation wishes to incentivize the deprecation of the current console .NET runtime (BRUTE) in favor of switching to NativeAOT. This is a paid bounty._\r\n\r\n\ud83d\udcc3**Full details**\r\n\r\nThe .NET console runtime of MonoGame needs to be changed to NativeAOT (publicly known as the ```PublishAot``` build option since .NET 7, see [documentation](https:\/\/learn.microsoft.com\/en-us\/dotnet\/core\/deploying\/native-aot\/?tabs=net7%2Cwindows)).\r\n\r\nRelated issue on the MonoGame issue tracker for more context: [#7873](https:\/\/github.com\/MonoGame\/MonoGame\/issues\/7873)\r\n\r\nThe MonoGame Foundation wishes to accelerate this transition by offering a paid opportunity to undertake this task.\r\n\r\nRead this page to check how to apply and the requirements.\r\n\r\n\ud83d\udd12 **Bounty status**\r\n\r\nLocked for @tomspilman to complete. \ud83d\udd12\r\n\r\n\ud83d\udcb0 **Bounty**\r\n\r\n$5.000,00 USD (Five thousands US dollars).\r\n\r\n\u270b **Requirements to apply**\r\n\r\n_In addition to [our generic bounty requirements](https:\/\/monogame.net\/bounties\/#requirements), here are requirements specific to this bounty._\r\n\r\nThis bounty requires to be a registered developer with **all** of the console platforms (Sony, Microsoft, and Nintendo). We would like that this task is undertaken by a single person\/entity, and you would therefore have to be cleared with all manufacturers. We need the implementation to have the same structure and user experience throughout all platforms, hence it would be more complex to manage if we were to accept per-platform applications. If need be, we can help with getting registered with either platforms.\r\n\r\n\ud83d\udce6 **Expected delivery content**\r\n\r\n- All console platforms working with NativeAOT with no regression in regard to current MonoGame features (we can however expect runtime regressions since BRUTE and NativeAOT might have big differences).\r\n- A smooth \"build & run\/debug\" user experience, and if it can't be achieved a good documentation to get a project running with NativeAOT on consoles.\r\n\r\n\ud83d\udcc5 **Delivery timeline**\r\n\r\nAs soon as possible.\r\n\r\n\ud83d\udcda **Historical context**\r\n\r\nLong story: [#7873](https:\/\/github.com\/MonoGame\/MonoGame\/issues\/7873)\r\n\r\nBack when MonoGame was initially ported to game console hardware, the most recent .NET version was .NET 4.5, associated with C# 5.0. At that time, .NET was a closed source technology and there was no runtime available to run .NET applications on game consoles.\r\n\r\nMono (the open-source reimplementation of the .NET runtime) could be ported to consoles (which Xamarin did to some extent) but this didn't cover all consoles and in many scenario Mono was too slow for games on consoles. Also, it was uncertain if Xamarin would keep putting efforts into bringing Mono to new consoles. Therefore, Sickhead Games came up with a plan: create and maintain their own .NET runtime, specifically crafted for performance, and ease to implement new consoles. That runtime is BRUTE (and only available on demand).\r\n\r\nBRUTE doesn't work like any .NET runtime. It works by decompiling already compiled .NET applications into C++ source code, and developers can then compile this C++ code using console compilers directly into native code. Along the way, it plugs the C++ code with a garbage collector to manage memory, and also strips out many .NET features useless for games to boost the performances. In many cases, BRUTE is 10 to 100 times faster than Mono, and its C++ code is easily portable to any platform with a standard compiler available.\r\n\r\nFor the most part, BRUTE worked just well, down to limited hardware such as the PS Vita and the Wii U.\r\n\r\n**The problem**\r\n\r\nThe main issue with BRUTE is that it has been started at a time at which the bleeding-edge version of .NET was .NET 4.5 and the latest language version was C# 5.0. For a long time, this was just fine, and it was assumed that it wouldn't be too complex to upgrade BRUTE to newer .NET standards.\r\n\r\nIn the end, BRUTE grew to be a very big project with now 10 years of history. The fast evolutions of .NET and breaking changes within dependencies of BRUTE made upgrading BRUTE very complex. Supporting current .NET basically requires the whole tool to be rewritten from scratch, which is months of work introducing possible regressions.\r\n\r\nThe major impact is that this limitation forces the main public repository of MonoGame to enforce a strict compatibility with .NET 4.5 and C# 5.0. This only applies to MonoGame itself, games made with MonoGame don't have to abide to this (unless they want to work on consoles). This limitation drives innovation backward and induces frustration within the community.\r\n\r\n**The solution**\r\n\r\nIn the recent history of .NET, Microsoft introduced a new runtime in the name of NativeAOT (which is hidden behind the ```PublishAot``` build parameter since .NET 7.0). This new build option takes the compiled IL code and translates it directly into native code (without an intermediate language such as C++), and packages the .NET runtime with it. This produces a monolithic executable that is entirely native code. This runtime became quickly popular among game developers for requiring no runtime installation, having no JIT jitters, obfuscating code, and producing a clean single output (that is not an hidden zip file like ```PublishSingleFile``` does). Games like Streets of Rage 4, Carrion, or ScourgeBringer were published successfully to millions of players with NativeAOT on PC platforms.\r\n\r\nLately, the FNA team and Cellar Door Games ported NativeAOT to gaming consoles hardware, making the latest advancements in .NET available on consoles. Despite being less performant than BRUTE, NativeAOT is much more convenient to use and more featureful. It also has the advantage of being backed by Microsoft which guarantees its future within the .NET ecosystem.\r\n\r\nThe MonoGame Foundation has therefore voted to switch to NativeAOT and join the maintenance effort of its console ports along with the FNA team. The goal is to deprecate BRUTE.\r\n\r\n**The technical details**\r\n\r\nThe details vary depending on the platform:\r\n- **PlayStation and Xbox platforms**: those have their platform code (e.g. low level graphics, audio, and I\/O) into a native C++ library that MonoGame then calls through ```DllImport```. Switching to NativeAOT shouldn't be too complex and should theoretically involve restructuring the project template to work with NativeAOT. It is not expected to require to rewrite platform code for this to work (but we should expect the transition to not be that magical).\r\n- **Nintendo platform**: this platform is more tricky because it uses a feature unique to BRUTE to avoid having a native library wrapped around ```DllImport```. To put it bluntly, BRUTE has a feature that allows to write C++ code directly into empty C# methods. This code is then statically linked at compile time without having to do any kind of glue. Migrating to NativeAOT would require to extract all this C++ code into a native library (like the other platforms do), and replace those magic methods with ```DllImport```. This is the platform that is expected to be the most time consuming to migrate. It is not expected that the C++ code should be rewritten (and it shouldn't to avoid regressions), but it is a lot of copy\/pasting\/testing while restructuring this code into a native library.","comments":["Hello. Just a little nitpick. I think that the new `LibraryImport` is probably more appropriate than the `DllImport`, since NativeAOT is the target. \r\n\r\n> Using DllImport isn't an option for platforms that require full Native AOT scenarios and therefore using other approaches (for example, source generation) is more appropriate. \r\n> ...\r\n> The P\/Invoke source generator, included with the .NET 7 SDK and enabled by default, looks for `LibraryImportAttribute` on a static and partial method to trigger compile-time source generation of marshalling code, removing the need for the generation of an IL stub at run time and allowing the P\/Invoke to be inlined.\r\n\r\nhttps:\/\/learn.microsoft.com\/en-us\/dotnet\/standard\/native-interop\/pinvoke-source-generation","```DllImport``` works just fine with NativeAOT. Maybe some other ahead-of-time environments don't, but we already shipped games using ```DllImport``` and NativeAOT so we should be all fine.\r\n\r\n(NativeAOT has modes which are stricter and might require that, but it is not required to go as far as that on consoles with MonoGame.)","You're right. `DllImport` doesn't work only in _full_ NativeAOT.","Following the foundation meeting of March 14, the applications have been reviewed and this bounty has been locked for @tomspilman to complete."],"labels":["Bounty"],"number":8194}]