[{"title":"Fix node config warning not updating for `Multiplayer{Spawner,Synchronizer}`","body":null,"comments":[],"labels":["bug","topic:editor","cherrypick:4.2"],"number":89839},{"title":"Extremely minor tooltip updates for Debug menu.","body":"Based on updates requested in this PR for the docs: https:\/\/github.com\/godotengine\/godot-docs\/pull\/9124\r\n\r\nThese are extremely minor tweaks, but this would make the tool-tips match the docs and be more correct.","comments":[],"labels":["enhancement","topic:editor"],"number":89837},{"title":"`PackedByteArray` copied and converted to `Array` without error when passed to a function with typed arguments","body":"### Tested versions\r\n\r\n`4.2.1.stable.arch_linux`\r\n\r\n### System information\r\n\r\n`Godot v4.2.1.stable unknown - Manjaro Linux #1 SMP PREEMPT_DYNAMIC Fri Mar 15 21:05:45 UTC 2024 - X11 - Vulkan (Forward+) - dedicated NVIDIA GeForce RTX 4060 (nvidia; 550.67) - Intel(R) Core(TM) i7-9700F CPU @ 3.00GHz (8 Threads)`\r\n\r\n### Issue description\r\n\r\nIf a function has an `Array`-typed param, passing a `PackedByteArray` to it will not cause an error, and will silently convert the PBA to a normal `Array` (and making it effectively passed by value).\r\n\r\n```gdscript\r\nextends Node2D\r\n\r\nfunc _ready():\r\n    var val := PackedByteArray()\r\n    val.resize(10)\r\n    val.fill(0)\r\n    print(val)  \t# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n    f1(val) \t\t# No error!\r\n    print(val)\t# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n\r\nfunc f1(param: Array):\r\n    param[5] = 10\r\n    print(param) \t# [0, 0, 0, 0, 0, 10, 0, 0, 0, 0]\r\n```\r\n\r\n### Steps to reproduce\r\n\r\nRun the above code - there is no type error and `val` is not updated in `_ready`\r\n\r\n### Minimal reproduction project (MRP)\r\n\r\nN\/A","comments":["Related #40249"],"labels":["discussion","topic:gdscript"],"number":89829},{"title":"[MacOS] Defining Wine Executable but not rcedit causes infinite instances of Wine to start","body":"### Tested versions\n\n- 4.2.1\n\n### System information\n\nMacOS 14.4\n\n### Issue description\n\nI quickly deleted the path to rcedit because I was annoyed with how it opens an instance of the windows game on exit, and the next time I tried to export new instances of wine just kept opening forever until I killed them all in a batch in Activity Monitor. Godot froze and never recovered.\r\n<img width=\"1440\" alt=\"image\" src=\"https:\/\/github.com\/godotengine\/godot\/assets\/28269330\/226dad91-2331-4395-a2ba-5270f5b9595a\">\r\n\n\n### Steps to reproduce\n\nDefine a wine directory in Editor Settings for Windows exports, then try to export for windows on macOS.\n\n### Minimal reproduction project (MRP)\n\nShould happen with any.","comments":["This should be a relatively easy issue to tackle for new contributors. The relevant code is in `platform\/windows\/export\/export_plugin.cpp`, and most likely it needs to check that both Wine and Rcedit are configured before attempting to use either."],"labels":["bug","platform:macos","good first issue","topic:export"],"number":89828},{"title":"DRAFT: C#-Performance:  Use a custom static lookup to handle InvokeGodotClassMethod and HasGodotClassMethod","body":"### Preface\r\nThis is in a **very early** draft state and by no means complete. I am presenting my working proof of concept to discuss if and how to progress with the main idea of this PR. There are lots of open TODOs, questions and polishing to be done. Please focus on the idea instead of the very rough sketch shown here - there is also some debug output which will obviously be removed later on. \r\n\r\nBe warned: this is a long one to give readers enough context! If you want a TL;DR scroll to the bottom for the performance numbers.\r\n\r\n### Introduction\r\nThe current C# bridge implementation of `InvokeGodotClassMethod` approximately looks like this for a C# script which overrides `_Ready` and `_Process`: \r\n\r\n```csharp\r\nprotected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret)\r\n{\r\n    if (method == MethodName._Ready && args.Count == 0) {\r\n        _Ready();\r\n        ret = default;\r\n        return true;\r\n    }\r\n    if (method == MethodName._Process && args.Count == 1) {\r\n        _Process(global::Godot.NativeInterop.VariantUtils.ConvertTo<double>(args[0]));\r\n        ret = default;\r\n        return true;\r\n    }\r\n    return base.InvokeGodotClassMethod(method, args, out ret);\r\n}\r\n```\r\nWhile this seems pretty o.k. there is a small detail which makes `InvokeGodotClassMethod` more complicated than this snippet: the engine is passing the string `\"_process\"` while the user script `InvokeGodotClassMethod` checks for `\"_Process\"`. This edge case is handled by the C# glue of the builtin Godot classes (e.g. `Node2D` or `Node3D`):\r\n\r\n```csharp\r\n\/\/ excerpt from the generated Node.cs\r\n\/\/ MethodProxyName__* are the PascalCase variants, MethodName._Process is \"_process\" here\r\nif ((method == MethodProxyName__process || method == MethodName._Process) && args.Count == 1 && HasGodotClassMethod((godot_string_name)MethodProxyName__process.NativeValue))\r\n{\r\n    _Process(VariantUtils.ConvertTo<double>(args[0]));\r\n    ret = default;\r\n    return true;\r\n}\r\nif ((method == MethodProxyName__ready || method == MethodName._Ready) && args.Count == 0 && HasGodotClassMethod((godot_string_name)MethodProxyName__ready.NativeValue))\r\n{\r\n    _Ready();\r\n    ret = default;\r\n    return true;\r\n}\r\n```\r\n\r\nAnd then there is `HasGodotClassMethod` here - what does it do? It checks if a method is **actually** implemented as e.g. `Node` has to supply an empty stub implementation for `_Process(double delta)` to make this code compile. But why not just call the stub implementation? Because the C++ -> C# function parameter marshalling done via `VariantUtils` could be costly, especially for more complex types like arrays - so why marshall if an empty stub is called? This also has to be implemented this way because what happens if a user actually implements both `_Process(double)` and `_process(double)` in their script? We can't just auto-proxy `\"_process\"` to `\"_Process\"` because of this.\r\n\r\nAt this point we traversed the class hierarchy for a bit and jump back up to the original C# class to call `HasGodotClassMethod`.\r\nThis really isn't cheap and theres another part to this: the engine calls our C# script with `\"_process\"`, `\"_enter_tree\"` etc. no matter if we implement it or not and calling `HasGodotClassMethod` with an \"unimplemented\" method name traverses the whole class hierarchy and depending on what class the current C# script is based on, this can be quite expensive.\r\n\r\nThis makes the current implementation:\r\n\r\n- somewhat \"slow\"\r\n- hard to reason about as a human\r\n- hard to reason about for the branch predictor\r\n\r\n### How to improve this? \r\nI will try to keep this \"chapter\" high level:\r\n\r\nInstead of a bunch of `if`s we will use a `Dictionary<(MethodName, ParameterCount), Delegate>` to resolve functions. Adding all the C# bridge details to this yields a wrapper class (called `FunctionRegistry` for now) and the following snippet for a user script called `MainScene` which implements `_Ready` and `_Process` in C#:\r\n\r\n```csharp\r\npublic new static readonly FunctionRegistry<MainScene> Registry = new FunctionRegistry<MainScene>()\r\n    .Register(MethodName._Ready, 0, (MainScene instance, NativeVariantPtrArgs args, out godot_variant ret) => \r\n    {\r\n        instance._Ready();\r\n        ret = default;\r\n        return true;\r\n    })\r\n    .Register(MethodName._Process, 1, (MainScene instance, NativeVariantPtrArgs args, out godot_variant ret) => \r\n    {\r\n        instance._Process(global::Godot.NativeInterop.VariantUtils.ConvertTo<double>(args[0]));\r\n        ret = default;\r\n        return true;\r\n    })\r\n    .Compile();\r\n```\r\n\r\nThis still misses the  `\"_process\"` -> `\"_Process\"` mapping for the engine calls which is done via aliases, here is an excerpt from `Node.cs`:\r\n```csharp\r\n public static readonly FunctionRegistry<Node> Registry = new FunctionRegistry<Node>()\r\n    \/\/ remember MethodProxyName__process is the PascalCaseName here\r\n    .AddAlias(Node.MethodProxyName__process, 0, Node.MethodName._Process)\r\n```\r\n\r\nThese aliases are then imported which gives us:\r\n```csharp\r\npublic new static readonly FunctionRegistry<MainScene> Registry = new FunctionRegistry<MainScene>()\r\n    \/\/ this is new, we register our parents registry (aliases and function registrations)\r\n    \/\/ our parent registry did the same with Node, which did the same with GodotObject ...\r\n    .Register(global::Godot.Node3D.Registry)\r\n    .Register(MethodName._Ready, 0, (MainScene instance, NativeVariantPtrArgs args, out godot_variant ret) => \r\n    {\r\n        instance._Ready();\r\n        ret = default;\r\n        return true;\r\n    })\r\n    .Register(MethodName._Process, 1, (MainScene instance, NativeVariantPtrArgs args, out godot_variant ret) => \r\n    {\r\n        instance._Process(global::Godot.NativeInterop.VariantUtils.ConvertTo<double>(args[0]));\r\n        ret = default;\r\n        return true;\r\n    })\r\n    .Compile();\r\n```\r\nThis concept fixes all evil issues:\r\n- if a script overrides a function that its parent already implemented, it gets overriden because the registry of the parent is added first and then potentially overriden by local `.Register` definitions\r\n- if user actually implements `_process(double)` and `_Process(double)` the correct methods are invoked when the engine passes `\"_process\"` as the method name\r\n\r\nAnd now you also know why the `.Compile()` step is needed: we have to apply the aliases somewhere.\r\n\r\nAnd thats about it, invoking a function is easy and fast now, a negative response is just as fast which is a big boon (see introduction): \r\n```csharp\r\nprotected override bool InvokeGodotClassMethod(in godot_string_name method, NativeVariantPtrArgs args, out godot_variant ret)\r\n{\r\n    if (Registry.TryGetFunction(in method, args.Count, out var scriptFunction))\r\n    {\r\n         return scriptFunction(this, args, out ret);\r\n    }\r\n\r\n    ret = new godot_variant();\r\n    return false;\r\n}\r\n```\r\n### HasGodotClassMethod\r\nI went ahead and changed the implementation for `HasGodotClassMethod` as well because it kind of uses the same pattern and the `FunctionRegistry` could fulfill its requirements with minor adjustments. We will have to think about other places like `InvokeGodotClassStaticMethod`, should we apply this pattern there too? \r\n\r\n### Downsides and caveats\r\nHere is an unordered list of downsides \/ caveats I can think of:\r\n\r\n- I pointed out that the current implementation is hard to reason about, the proposed changes are not improving this in a significant way and to some people may even seem more complex, which is understandable\r\n- We have to be careful not to do too much work in a `static` context as it would negatively impact users (stutters, hanging because of load time initialization); this is especially annoying for Godot users because its hard to manually control static initialization (I think `RuntimeHelpers.RunClassConstructor` etc. should be avoided in Godot user code). Speaking from personal experience, we would have to do significantly more work for this to become noticable\r\n- We need one static dictionary per C# script type (no matter if its generated C++ glue classes or user scripts), this increases Godot C#'s memory footprint which we should measure at least once\r\n\r\n\r\n### Numbers\r\n\r\nTo stress test this I made a test project which spawns 100.000 Nodes with an attached C# script. Said C# script overrides `_Ready` and `_Process`. I used it in another PR (https:\/\/github.com\/godotengine\/godot\/pull\/89807) if you wonder why its name is different from this PR:\r\n[VariantOptimizationTestProject.zip](https:\/\/github.com\/godotengine\/godot\/files\/14733596\/VariantOptimizationTestProject.zip)\r\n\r\nOn my machine (Win11, NET.Core 7.0.2, CPU: 5800x3D), I get the following results:\r\n| Implementation | Editor -> Profiler -> Process Time (ms) |\r\n|--------|--------|\r\n| Old implementation (across multiple runs) | 238 - 245ms |\r\n| This PR (across multiple runs) | 40 - 45ms | \r\n\r\n\r\n### TODOs\r\n\r\n- [ ] Cleanup TODOs meant for myself\r\n- [ ] Talk to maintainers about open questions, issues and how to solve them (see some code TODOs)\r\n- [ ] Check with the maintainers if its ok to make `godot_string_name._data` visible with `internal` as everything else breaks apart \r\nif this change is declined\r\n- [ ] What about `InvokeGodotClassStaticMethod`?\r\n- [ ] Check the assembly size, it must have shrunk a bit\r\n- [ ] This does not handle overloading with the same parameter count, the old implementation did not support this as well, is this ok?\r\n- [ ] This PR will not build in CI as I did not adjust the code generation tests, fix this\r\n- [ ] Add unit tests for `FunctionRegistry` as the whole \"inheritance\" and aliasing part of it is pretty easily testable\r\n- [ ] Clarify why the old `HasGodotClassMethod` is used in `_Get`  without parameter count checks, a getter with parameters makes no sense to me\r\n\r\nThank you to @paulloz and @raulsntos for helping me in Rocket.Chat \/ Discord on how to go on with my idea <3","comments":[],"labels":["enhancement","topic:dotnet","performance"],"number":89826}]