[{"title":"[Bug]: Jest duplicates modules imported in both global setup\/teardown and code under test","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nhttps:\/\/github.com\/maslade\/jest-singleton-bug\r\n\r\n1. `npm install`\r\n2. `npm test`\r\n\r\n\r\n### Expected behavior\r\n\r\n1. \"Loading singleton\" only appears once in output.\r\n2. The task list in `global-teardown.js` contains two strings, one added `global-setup.js` before tests and one added in `sum.js` during testing.\r\n\r\n### Actual behavior\r\n\r\n1. \"Loading singleton\" appears twice.\r\n2. The task list in `global-teardown.js` the string added by `global-setup.js`, but not the one added by `sum.js` (because it's a separate module).\r\n\r\nFrom the trace, I suspect this is related to `pirates`.\r\n\r\n```sh\r\n> project@1.0.0 test\r\n> jest\r\n\r\nTrace: Loading singleton\r\n    at Object.<anonymous> (\/private\/tmp\/project\/src\/singleton.js:1:9)\r\n    ...\r\n    at Module._compile (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:117:24)\r\n    ...\r\n    at Object.newLoader [as .js] (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:121:7)\r\n    ...\r\n    at Object.<anonymous> (\/private\/tmp\/project\/src\/global-setup.js:4:5)\r\n    ...\r\n    at Module._compile (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:117:24)\r\n    ...\r\n    at Object.newLoader [as .js] (\/private\/tmp\/project\/node_modules\/pirates\/lib\/index.js:121:7)\r\n    ...\r\n    at requireOrImportModule (\/private\/tmp\/project\/node_modules\/jest-util\/build\/requireOrImportModule.js:44:28)\r\n    at ScriptTransformer.requireAndTranspileModule (\/private\/tmp\/project\/node_modules\/@jest\/transform\/build\/ScriptTransformer.js:798:66)\r\n    at runGlobalHook (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/runGlobalHook.js:101:27)\r\n    at async runJest (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/runJest.js:327:5)\r\n    at async _run10000 (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/cli\/index.js:343:7)\r\n    at async runCLI (\/private\/tmp\/project\/node_modules\/@jest\/core\/build\/cli\/index.js:198:3)\r\n    at async Object.run (\/private\/tmp\/project\/node_modules\/jest-cli\/build\/run.js:130:37)\r\nsetting up\r\nAdded task. [ 'task inside global setup' ]\r\n  console.error\r\n    Trace: Loading singleton\r\n        at Object.<anonymous> (\/private\/tmp\/project\/src\/singleton.js:1:37)\r\n        at Runtime._execModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1439:24)\r\n        at Runtime._loadModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n        at Runtime.requireModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n        at Runtime.requireModuleOrMock (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1048:21)\r\n        at Object.require (\/private\/tmp\/project\/src\/sum.js:1:21)\r\n        at Runtime._execModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1439:24)\r\n        at Runtime._loadModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n        at Runtime.requireModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n        at Runtime.requireModuleOrMock (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1048:21)\r\n        at Object.require (\/private\/tmp\/project\/src\/sum.test.js:1:17)\r\n        at Runtime._execModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1439:24)\r\n        at Runtime._loadModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n        at Runtime.requireModule (\/private\/tmp\/project\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n        at jestAdapter (\/private\/tmp\/project\/node_modules\/jest-circus\/build\/legacy-code-todo-rewrite\/jestAdapter.js:77:13)\r\n        at runTestInternal (\/private\/tmp\/project\/node_modules\/jest-runner\/build\/runTest.js:367:16)\r\n        at runTest (\/private\/tmp\/project\/node_modules\/jest-runner\/build\/runTest.js:444:34)\r\n\r\n    > 1 | console.trace( 'Loading singleton' );\r\n        |                                     ^\r\n      2 |\r\n      3 | const tasks = [];\r\n      4 |\r\n\r\n      at Object.<anonymous> (src\/singleton.js:1:37)\r\n      at Object.require (src\/sum.js:1:21)\r\n      at Object.require (src\/sum.test.js:1:17)\r\n\r\n  console.log\r\n    Added task. [ 'task inside test' ]\r\n\r\n      at log (src\/singleton.js:8:13)\r\n\r\nPASS src\/sum.test.js\r\n  Test\r\n    \u2713 should pass (1 ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        0.115 s, estimated 1 s\r\nRan all test suites.\r\ntearing down [ 'task inside global setup' ]\r\n```\r\n\r\n### Additional context\r\n\r\nMy actual situation is a large project that uses a third-party module as a DB provider. The module exports `{ getDb, closeDb }`. The code being tested imports `getDb` from this module to obtain DB handles and execute queries. The global teardown script imports `closeDb` from this module to clean up connections.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: macOS 13.6.3\r\n  CPU: (8) arm64 Apple M1\r\nBinaries:\r\n  Node: 16.15.1 - \/usr\/local\/bin\/node\r\n  npm: 9.8.1 - \/usr\/local\/bin\/npm\r\nnpmPackages:\r\n  jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Docs]: Egghead.io link on snapshot testing docs page is broken","body":"### Page(s)\n\nhttps:\/\/jestjs.io\/docs\/snapshot-testing#snapshot-testing-with-jest\n\n### Description\n\nThe link posted links to the snapshot testing with jest page. There is an info block there that reccommends watching a video from egghead.io to get more information on snapshot testing with jest. This link however, appears broken.","comments":[],"labels":["Documentation :book:"]},{"title":"[Bug]: coverageThreshold for single path is not working","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nI have a react project set-up\r\n\r\napp\r\n- src\r\n   - pages\r\n      - Layout\r\n         -  index.tsx\r\n- jest.config.ts\r\n\r\nIn my jest.config.ts\r\n```sh\r\n\r\nmodule.exports = {\r\n\ttestEnvironment: 'jest-environment-jsdom',\r\n\tglobalSetup: '<rootDir>\/global-setup.js',\r\n\tsetupFilesAfterEnv: ['<rootDir>\/jest-setup.ts'],\r\n\tmoduleNameMapper: {\r\n\t\t'\\\\.(css|scss)$': 'identity-obj-proxy',\r\n\t\t'.+\\\\.svg$': 'jest-svg-transformer',\r\n\t\t'^axios$': require.resolve('axios'),\r\n\t\t'^src\/(.*)$': '<rootDir>\/src\/$1'\r\n\t},\r\n\tcollectCoverage: true,\r\n\tcoverageReporters: ['text', 'html', 'lcov'],\r\n\tcoverageThreshold: {\r\n\t\t'src\/pages\/Layout\/index.tsx': {\r\n\t\t\tbranches: 70,\r\n\t\t\tfunctions: 70,\r\n\t\t\tlines: 70,\r\n\t\t\tstatements: 70\r\n\t\t},\r\n\t\t'src\/**\/*.{js,jsx,ts,tsx}': {\r\n\t\t\tbranches: 80,\r\n\t\t\tfunctions: 80,\r\n\t\t\tlines: 80,\r\n\t\t\tstatements: 80\r\n\t\t}\r\n\t}\r\n};\r\n\r\nexport {};\r\n```\r\n\r\n### Expected behavior\r\n\r\nAfter reading the jest documentation on coverage threshold: https:\/\/jestjs.io\/docs\/configuration#coveragethreshold-object\r\nI expect a behaviour that the report will look into given threshold and remove the warning.\r\n\r\nCommand I run to clear jest cache:\r\n`\"test:clearCache\": \"jest --clearCache\"`\r\n\r\nCommand I use to run tests coverage:\r\n`npm run test -- --coverage`\r\n\r\n### Actual behavior\r\n\r\nI am trying to add a specific threshold for my Layout under pages but everytime I run test commands I do get\r\n`Jest: \"app\\src\\pages\\Layout\\index.tsx\" coverage threshold for branches (80%) not met: 77.77%`\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (16) x64 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz\r\n  Binaries:\r\n    Node: 16.16.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 8.11.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: 29.7.0 => 29.7.0\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: jest could detect some errors it is currently silencing when using `jsdom` environment","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nThe following tests will not show any error when using `jsdom` environment:\r\n```ts\r\ntest('leak microtask', () => {\r\n  setImmediate(() => expect(1).toBe(2));\r\n});\r\n\r\ntest('leak timer', () => {\r\n  setTimeout(() => expect(1).toBe(2));\r\n});\r\n```\r\n\r\nIt would be nice if Jest could detect pending timers or wait for them to finish on environment teardown.\r\n\r\nThere are different options. The cheapest workaround is the one used in vitest but it will only flush queued macrotasks and 0s timers:\r\nhttps:\/\/github.com\/vitest-dev\/vitest\/blob\/fee7d8be9d6e6f710270600ae91fa35d861b7075\/packages\/vitest\/src\/runtime\/setup-node.ts#L85\r\n\r\nIdeally, in addition to this, it would be nice to grab the pending timers from `jsdom` and show a warning or an error depending on some option like `detectPendingTimers` or simply wait until they all complete (or timeout).\r\nhttps:\/\/github.com\/jsdom\/jsdom\/blob\/2f8a7302a43fff92f244d5f3426367a8eb2b8896\/lib\/jsdom\/browser\/Window.js#L494 \r\n(happy-dom exposes a `waitUntilComplete()` function, we could contribute to jsdom in order to expose something similar)\r\n\r\n_Credits go to @rainerhahnekamp for raising the issue._\r\n\r\nI'll be happy to help with a PR.\r\n### Motivation\r\n\r\nThis will help Jest detect some issues that are currently silenced. This aligns with how vitest jsdom env works.\r\n\r\n### Example\r\n\r\n_No response_\r\n\r\n### Pitch\r\n\r\nThis will help Jest detect some issues that are currently silenced.","comments":[],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: 'node' entry in package.json exports is not respected","body":"### Version\n\n29.7.0 \n\n### Steps to reproduce\n\nI don't have an example of a public npm package with `node` in exports, to provide a reproduction scenario, but I can search for it or create a dummy one if it's absolutely necessary. It doesn't seem necessary though. Please see expected\/actual behavior sections.\n\n### Expected behavior\n\nIn [package.json exports specification](https:\/\/nodejs.org\/api\/packages.html#conditional-exports) we have:\r\n\r\n> \"node\" - matches for any Node.js environment. Can be a CommonJS or ES module file.\r\n\r\nSo it seems natural for jest to prioritize that over `default` key.\r\n\r\nProbably related code:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/d4d1f2b8004b1eb4bf0cf862698dd1142e13278f\/packages\/jest-resolve\/src\/defaultResolver.ts#L243\n\n### Actual behavior\n\nJest's resolver seems not to take `node` entry into account. For example, if exports field looks like this for a package:\r\n```json\r\n\"exports\": {\r\n    \".\": {\r\n      \"types\": \".\/index.d.ts\",\r\n      \"node\": \".\/index.cjs.js\",\r\n      \"default\": \".\/index.esm.js\"\r\n    }\r\n  }\r\n  ```\r\n  the package's main entry point should resolve to `index.cjs.js` and not `index.esm.js`.\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\nBinaries:\r\n    Node: 16.17.0 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/node\r\n    Yarn: 3.2.2 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/yarn\r\n    npm: 8.1.2 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/npm\r\n    pnpm: 8.15.4 - ~\/.nvm\/versions\/node\/v16.17.0\/bin\/pnpm\r\n\r\n  jest: 29.7.0\n```\n","comments":["> Jest's resolver seems not to take `node` entry into account. For example, if exports field looks like this for a package:\r\n\r\nthat doesn't have a `node` condition.\r\n\r\nHowever, we _do_ support the `node` condition, so a reproduction is needed \ud83d\ude42 ","> that doesn't have a node condition.\n\nIt was a copy paste issue. Edited now :)\n\n\n> However, we do support the node condition, so a reproduction is needed \ud83d\ude42\n\nAlright, then maybe it had something to do with the version of jest I was using. Will check if I can reproduce with the latest version."],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: Auto mock class \/ object","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nI know `jest.mock(path)` and it might have use cases. But why not just allow mocking any object? In this case, a class with instance. For inspiration see [ts-mockito](https:\/\/github.com\/NagRock\/ts-mockito).\r\n\r\n### Motivation\r\n\r\nA good example is testing an Angular service which has other services as injectable in constructor.\r\n\r\n```ts\r\n@Injectable({providedIn: 'root'})\r\nexport class MyService {\r\n  constructor(private anotherService: AnotherService) {}\r\n}\r\n```\r\n\r\nSo I need an instance of a service class for this constructor. Currently I need to rewrite the object structor.\r\n\r\n\r\n```ts\r\n\/\/ AnotherService Mock\r\n\r\nconst mockAnotherService = {\r\n  methodA: jest.fn(),\r\n  methodB: jest.fn(),\r\n  methodC: jest.fn(),\r\n  \/\/ etc\r\n}\r\n\r\nconst myService = new MyService(mockAnotherService);\r\n```\r\n\r\n### Example\r\n\r\nWith my proposal you only need:\r\n\r\n```ts\r\nconst mockAnotherService = jest.mock(AnotherService);\r\nconst mockInstance = jest.instance(mockAnotherService);\r\nconst myService = new MyService(mockInstance);\r\n```\r\n\r\n\r\n### Pitch\r\n\r\nIt's delightful with focus on simplicity. You can easily mock a class and pass\/use the mock instance everywhere.\r\n\r\n### Another Example\r\n\r\nHere is another more real world test.\r\n\r\n```ts\r\nconst mocks = {\r\n  serviceA: {\r\n    methodA: jest.fn(),\r\n    methodB: jest.fn(),\r\n    methodC: jest.fn(),\r\n    methodD: jest.fn(),\r\n    methodE: jest.fn(),\r\n  },\r\n  serviceB: {\r\n    methodA: jest.fn(),\r\n    methodB: jest.fn(),\r\n    methodC: jest.fn(),\r\n    methodD: jest.fn(),\r\n    methodE: jest.fn(),\r\n  },\r\n  serviceC: {\r\n    methodA: jest.fn(),\r\n  },\r\n  serviceD: {\r\n    methodA: jest.fn(),\r\n  },\r\n};\r\n\r\nbeforeEach(() => {\r\n  TestBed.configureTestingModule({\r\n    imports: [CommonModule],\r\n    providers: [\r\n      ServiceToTest,\r\n      { provide: ServiceA, useValue: mocks.serviceA },\r\n      { provide: ServiceB, useValue: mocks.serviceB },\r\n      { provide: ServiceC, useValue: mocks.serviceC },\r\n      { provide: ServiceD, useValue: mocks.serviceD },\r\n    ],\r\n  });\r\n\r\n  serviceToTest = TestBed.inject(ServiceToTest);\r\n});\r\n```\r\n\r\nThis is what I want:\r\n\r\n```ts\r\nconst mocks = {\r\n  serviceA: jest.mock(ServiceA),\r\n  serviceB: jest.mock(ServiceB),\r\n  serviceC: jest.mock(ServiceC),\r\n  serviceD: jest.mock(ServiceD),\r\n};\r\n\r\nbeforeEach(() => {\r\n  TestBed.configureTestingModule({\r\n    imports: [CommonModule],\r\n    providers: [\r\n      ServiceToTest,\r\n      { provide: ServiceA, useValue: jest.instance(mocks.serviceA) },\r\n      { provide: ServiceB, useValue: jest.instance(mocks.serviceB) },\r\n      { provide: ServiceC, useValue: jest.instance(mocks.serviceC) },\r\n      { provide: ServiceD, useValue: jest.instance(mocks.serviceD) },\r\n    ],\r\n  });\r\n\r\n  serviceToTest = TestBed.inject(ServiceToTest);\r\n});\r\n```\r\n\r\nThe `mock` and `instance` comes from [ts-mockito](https:\/\/github.com\/NagRock\/ts-mockito). Jest must not exactly implement it like this. It's just a demo. Under the hood I can use the methods like `jest.fn()`. So I don't have to create new objects with same structure like the class I want to mock. I prefer the automatic way.\r\n\r\n### Implementation\r\n\r\nNot sure how to implement it. But we could just use \r\n\r\n```ts\r\nObject.getOwnPropertyNames(ClassToMock.prototype)\r\n```\r\n\r\nand create a new object with that names and assign `jest.fn()`. Not sure how to do this with other properties. I thinking about creating a helper function as workaround to do this.\r\n\r\nMy current workaround (not fully tested):\r\n\r\n```ts\r\nfunction createMockObjectFromClass(classToMock) {\r\n  const mockObject = {};\r\n  const methodNames = Object.getOwnPropertyNames(classToMock.prototype);\r\n  methodNames.forEach((methodName) => {\r\n    if (typeof classToMock.prototype[methodName] === 'function') {\r\n      mockObject[methodName] = jest.fn();\r\n    }\r\n  });\r\n  return mockObject;\r\n}\r\n```\r\n\r\nNo need for `instance`, since it's just an object with the method. The fake instance. \r\n\r\n(Update: The names should be filtered with getOwnPropertyDescriptor to exclude get\/set. Also, abstract methods are not includes. It's on TypeScript level.)\r\n","comments":[],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: EMFILE: too many open files jest tests on github linux pipeline","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nThis error happens consistently whenever there are more than 100 test files, so it will likely happen if you use the same environment and many test files.\r\n#### Environment:\r\n* OS: Linux 6.5 Ubuntu 22.04.4 LTS 22.04.4 LTS (Jammy Jellyfish)\r\n* CPU: (2) x64 AMD EPYC 7763 64-Core Processor\r\n#### Project:\r\n* node: 18.14.0\r\n* jest: 29.7.0\r\n* typescript: 5.3.3\r\n* npm: 9.3.1\r\n#### Test command:\r\n```\r\n\"test:changedSince\": \"node --max-old-space-size=8192 --no-compilation-cache --expose-gc .\/node_modules\/jest\/bin\/jest.js --changedSince=origin\/master --maxWorkers=2  --logHeapUsage --coverage --coverage-provider=v8  --setupFiles dotenv\/config\",\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nWe're using jest with a typescript node project and we have a Github action to run coverage check\r\n```\r\nname: Build\r\non:\r\n push:\r\n   branches:\r\n     - master\r\n pull_request:\r\n   types: [opened, synchronize, reopened]\r\njobs:\r\n  coverage:\r\n    name: CoverageCheck\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions\/checkout@v4\r\n        with:\r\n          fetch-depth: 0\r\n      - run: git fetch --no-tags --depth=1 origin master\r\n      - uses: actions\/setup-node@v3\r\n        with:\r\n          node-version: 18.14.0\r\n      - name: Install dependencies\r\n        run: npm ci\r\n      - name: Test and coverage\r\n        run: npm run test:changedSince\r\n```\r\nand here's the script we're using here \r\n```\r\n \"test:changedSince\": \"node --max-old-space-size=8192 --no-compilation-cache --expose-gc .\/node_modules\/jest\/bin\/jest.js --changedSince=origin\/master --maxWorkers=2  --logHeapUsage --coverage --coverage-provider=v8  --setupFiles dotenv\/config\",\r\n```\r\nand it's working correctly for a small number of files\r\n\r\n### Actual behavior\r\n\r\nFor some reason, the action fails with this error whenever there are many files to be run\r\n```\r\nFAIL src\/firebase\/firebase.service.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    EMFILE: too many open files, open '\/home\/runner\/work\/ads-service\/ads-service\/src\/firebase\/firebase.service.spec.ts'\r\n\r\n      at runTestInternal (..\/node_modules\/jest-runner\/build\/runTest.js:170:27)\r\n\r\nFAIL src\/moderator\/moderator.controller.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    EMFILE: too many open files, uv_resident_set_memory\r\n\r\n      at runTestInternal (..\/node_modules\/jest-runner\/build\/runTest.js:418:36)\r\n```\r\n\r\n### Additional context\r\n\r\nI tried to use `watchman` but unfortunately it did not work \r\n```\r\nname: Build\r\non:\r\n push:\r\n   branches:\r\n     - master\r\n pull_request:\r\n   types: [opened, synchronize, reopened]\r\njobs:\r\n  coverage:\r\n    name: CoverageCheck\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions\/checkout@v4\r\n        with:\r\n          fetch-depth: 0\r\n      - run: git fetch --no-tags --depth=1 origin master\r\n      - uses: actions\/setup-node@v3\r\n        with:\r\n          node-version: 18.14.0\r\n      - name: Install Watchman\r\n        run: |\r\n          sudo apt-get update\r\n          sudo apt-get install -y watchman\r\n\r\n      - name: Increase open files limit\r\n        run: |\r\n          sudo sysctl -w fs.inotify.max_user_watches=524288\r\n          sudo sysctl -w fs.file-max=524288\r\n      - name: Install dependencies\r\n        run: npm ci\r\n      - name: Test and coverage\r\n        run: npm run test:changedSince\r\n```\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 6.5 Ubuntu 22.04.4 LTS 22.04.4 LTS (Jammy Jellyfish)\r\n    CPU: (2) x64 AMD EPYC 7763 64-Core Processor\r\n  Binaries:\r\n    Node: 18.14.0 - \/opt\/hostedtoolcache\/node\/18.14.0\/x64\/bin\/node\r\n    Yarn: 1.22.22 - \/usr\/local\/bin\/yarn\r\n    npm: 9.3.1 - \/opt\/hostedtoolcache\/node\/18.14.0\/x64\/bin\/npm\r\n```\r\nDo you have any idea what could be the reason for this error? \r\nThanks in advance.","comments":["We'll need a reproduction to look at this","> We'll need a reproduction to look at this\r\n\r\nUnfortunately, our code base is private so I don't think I'll be able to share the code here, do you have any suggestion to share the reproduction if the code is private?\r\n@SimenB ","Not really, unfortunately. I've never seen this error before, so it's highly likely to be something specific to your project. The ways of creating a reproduction is quite well laid out in https:\/\/stackoverflow.com\/help\/minimal-reproducible-example"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: required inputs in Angular afterNextRender hook throws an error in jest","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Pull down this project, https:\/\/github.com\/Tedgar20\/requiredInputs\/tree\/master\r\n2. npm i (make sure you're on Node >= 20)\r\n3. npm run test\r\n\r\nYou'll notice that 2\/3 tests written in test.component.spec.ts fail even though in actually use when running the application everything works fine. If you start the project using \"npm run start\" you'll see that there are no errors in the browser and Angular handles the required input fine\n\n### Expected behavior\n\nI expect that when i create a component and provide all its necessary inputs that jest wouldn't throw this error as long as the input is used in a hook where it is guranteed to be defined. The afterNextRender hook gurantees that inputs will be available\n\n### Actual behavior\n\nRegardless of how I set up the component for testing jest or I guess Angular will throw the error \"ERROR RuntimeError: NG0950: Input is required but no value is available yet. Find more at https:\/\/angular.io\/errors\/NG0950\"\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.4 Ubuntu 20.04.4 LTS (Focal Fossa)\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz\r\n  Binaries:\r\n    Node: 20.11.1 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/node\r\n    npm: 10.2.4 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: Print all `Error` properties instead of only `.stack` and `.cause`","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nWhy does `jest` limit the output of in the test run occured errors on `.stack` and `.cause`? I would love to see all properties printed to quickly identitfy the occured error and its cause. That would be nice if you use your own Error classes with custom fields.\r\n\r\n### Motivation\r\n\r\nsee above\r\n\r\n### Example\r\n\r\n```typescript\r\nit('fails', () => {\r\n  throw Object.assign(new Error('dummy error'), { extra: 'field' });\r\n});\r\n```\r\n\r\nRunning this test only prints `Error: dummy error` to the console.\r\n\r\n### Pitch\r\n\r\nSometimes tests fail because of custom errors with other fields than `.stack` and `.cause`. It would be nice to have all details available diretly in the test output.\r\nAlso it is the default behaviour in Node.js if a statement throws an Error, see\r\n\r\n```\r\n$ node\r\n> function test() { throw Object.assign(new Error('test'), { foo: 42 }) }\r\nundefined\r\n> \r\n> \r\n> \r\n> test()\r\nUncaught Error: test\r\n    at test (REPL2:1:39) {\r\n  foo: 42\r\n}\r\n```","comments":["We added a feature to the `jest-message-util` implementation for a possible new error formatting. Is this something you would consider having for `jest`?\r\n\r\nRunning\r\n\r\n```typescript\r\nclass TestError extends Error {}\r\n\r\ndescribe('throwError', () => {\r\n  it.only('fails', () => {\r\n    throw Object.assign(\r\n      new TestError('dummy error', { cause: new TestError('testerrortwo', { cause: new Error('end') }) }),\r\n      { extra: 'field' },\r\n    );\r\n  });\r\n});\r\n```\r\n\r\nnow yields:\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/37102755\/57872a53-cd03-4351-bfc9-321d3952dcd4)\r\n\r\nThis prints all error fields and also uses the special handling of the `cause` field through Node's `utils.inspect` function.\r\n\r\nThe current output is formatted like this (missing extra fields):\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/37102755\/9754c997-398c-4738-ab77-795b54f5facf)\r\n\r\nBefore advancing with this we wanted to make sure this is considerable for `jest`. And if so, how could we add this? One variant could be adding a new config parameter to turn it on.\r\n\r\nCheers, Luis"],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: Errors thrown in setTimeout callback are not caught by test.failing","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Clone my repo at https:\/\/github.com\/nathanielks\/jest-test-failing-settimeout\r\n2. `npm i`\r\n3. `npm test`\r\n4. Jest will not mark the setTimeout test as passing\n\n### Expected behavior\n\nI expect tests run with `test.failing` to be marked as passing when an error is thrown in a `setTimeout` callback.\n\n### Actual behavior\n\nThe test is not being marked as passing:\r\n\r\n```\r\n> test-failing-settimeout@1.0.0 test\r\n> node --experimental-vm-modules node_modules\/.bin\/jest\r\n\r\n FAIL  tests\/setTimeout.test.js\r\n  Timers\r\n    \u2713 throwing errors with test.failing marks tests as passing\r\n    \u2715 throwing errors in setTimeout with test.failing marks tests as passing (10 ms)\r\n\r\n  \u25cf Timers \u203a throwing errors in setTimeout with test.failing marks tests as passing\r\n\r\n\r\n\r\n       7 |\r\n       8 |   test.failing('throwing errors in setTimeout with test.failing marks tests as passing', async () => {\r\n    >  9 |     setTimeout(() => { throw new Error() }, 5)\r\n         |                              ^\r\n      10 |     await wait(10) \r\n      11 |   })\r\n      12 | })\r\n\r\n      at Timeout._onTimeout (tests\/setTimeout.test.js:9:30)\r\n\r\n  \u25cf Timers \u203a throwing errors in setTimeout with test.failing marks tests as passing\r\n\r\n    Failing test passed even though it was supposed to fail. Remove `.failing` to remove error.\r\n\r\n       6 |   })\r\n       7 |\r\n    >  8 |   test.failing('throwing errors in setTimeout with test.failing marks tests as passing', async () => {\r\n         |        ^\r\n       9 |     setTimeout(() => { throw new Error() }, 5)\r\n      10 |     await wait(10) \r\n      11 |   })\r\n\r\n      at tests\/setTimeout.test.js:8:8\r\n      at tests\/setTimeout.test.js:3:1\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        0.126 s, estimated 1 s\r\nRan all test suites.\r\n```\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (8) arm64 Apple M1\r\n  Binaries:\r\n    Node: 20.10.0 - ~\/.nvm\/versions\/node\/v20.10.0\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.5 - ~\/.nvm\/versions\/node\/v20.10.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["I had a thought to see what the behavior would be when using [Timer Mocks](https:\/\/jestjs.io\/docs\/timer-mocks). Interestingly, the expected behavior is the actual behavior. Said another way: when using Timer Mocks, errors thrown in setTimeout callbacks are caught and failing tests are marked as passing when using `test.failing`.\r\n\r\nI've added [this test](https:\/\/github.com\/nathanielks\/jest-test-failing-settimeout\/commit\/1c208fdf605ddcb36a52b0a932bba977c66f83a5) to the linked repo:\r\n\r\n```javascript\r\nimport { jest } from '@jest\/globals'\r\n\r\njest.useFakeTimers()\r\ndescribe('Timers', () => {\r\n  test.failing('throwing errors in setTimeout with test.failing marks tests as passing with fake timers', async () => {\r\n    setTimeout(() => { throw new Error() }, 5)\r\n    jest.runAllTimers()\r\n  })\r\n})\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Can't configure Jest to find tests under a `node_modules` directory","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nCreate a source tree to use for the test by running the following (which extracts a base64-encoded `.tgz` file):\r\n\r\n```bash\r\nbase64 --decode <<<'\r\nH4sIALmD82UAA+1dW3PbRBQ2DAyDeYZHZslDHXdSZS\/ald2QDilkpmEaKG0H6DBMotprR6klGUn\r\nuOO3kf\/DOv+CdV\/4MwyvDruXYrnKR5crbNj7fjKPbyivn6Nv9zp6j1bGMk1uJ+rNZWRowxg7naL\r\nQU6RJTO12OgYjNHdvBWNgEYcIEsyuIL++SphjEiRupS2m7QWfw4sWl5VSxTueK7xn\/jsnyHcHxx\r\nP5B2JYHftge9GRc7s1QxP42s5X9BSME7G8CU\/u3lP2X0wgUsT+njrK\/zTnY3wim9rcO9LrVCoOO\r\n17X847i0OrBu1u3L7U9tdmZ\/wrhQ9lc3Aq4gXNoVXIEVt3\/lw88+qrxfqey7LfT9I\/QzGkPvq3y\r\nsPlR9flMfvf3HfF+58\/jxw\/GqPuN39fkkU+S96f5PW6Fvuf1+T1r9KHwuAzdoSV3gn3\/\/\/PzvD\/\r\n76r4QfCbgMU\/4\/cIf3pNuW0WbZ7UAu\/wl+lf9UdQOigoYl\/L5crDj\/GUZ+4vlymzgEKxvwBrUIo\r\nWrNIY0qd9D9vbs7D7++t\/fjrjV0kySyLqLr9s4POzuNzZ\/EvdjeHXbsqt1Ej9RJ959cddIMx6tv\r\n+v+wqpjyf1m9fz7\/bUoz\/b\/ggkL\/bwJy2A+jBLVlxx30EvSyitDmJnp8JFG3Fz5FfcVeGQUx+lb\r\ndHWgQyxgloSqdyFaC9G2DOp7yF9VZemPfTVpHt9EvVa0gajdvpj6FWuqDsV65aelV6+VxvKHusd\r\nOaKvnrRjWtdCdAbhS5JyjsoEh21ZWdVY\/iJPKCrqr7yE1UIYl8XZNsI7freoG6CrfXSy9HnXEUb\r\n0yOjyoenRE\/8\/p92R5f6QNVbK8bhJF8MP6F6rLVlZxurVhLNKv\/+27rmduV1nEcBmXWUUD\/Y0HZ\r\nyP9nAvhvBKD\/VxoX6f+y24EC+j\/lP9UngP43gaz+p4xbwnGajYbATdD\/1x5T\/i+r98\/nP1EHM\/0\r\n\/oQT6fxPQgn8tcH25dhut+Se34pM4kf7aht79XEaxFwb6CLawRdK9yUk\/LTwKFaX7Ui8i1rutVP\r\nR7QVsO1b20Vj0Fbr\/FyMR\/lhIExPPGf4SGjv85yiWA+I8JZOxvHYw85nLryLP\/bPwHEx3\/F9iG8\r\nR8zAP9vpZHh\/9QJLLEdyOX\/TPwn5b\/DHQz+nwlk\/T\/GmdXktMGUEKfg\/117ZPifDtSXXMfc+m\/C\r\nf0V\/DPrPBM7pvzPHrcQ6csf\/Zsf\/sc7\/EjYD\/98MQP+tNC7VfyW2A7n8nx3\/1\/ynugcA\/WcC58b\r\n\/KbNIkyhzCJuA\/rv2yPB\/Cb3\/AvwngmKI\/xuB54\/yf16iR6Ev98M2OkWdKPRR7avkyIs3Y7X3lh\r\n+2a1vVaisM4lAxuBd218elrRMZr1OM6\/WtKw7zqw7b2NaH3\/T\/YVVxof9nHWi7p6laJaQCFtD\/e\r\njHK\/xXAfzMA\/b\/SuJD\/Uy+glHagQP8\/5j9lBPJ\/jCCr\/4XtWJwx3FASjIP+v\/a4kP+l9v5z8F+c\r\n6\/8ZZ9D\/m0AB\/d+WcSvynsr1mtbt9doGWq+j7TujZwb0zbJe8+LRivu0J9NvCQdJ7LUlOpzNKzl\r\n85UyE5LAvW8l5l8JKwruqsiey\/0VNeQgInaq\/p3VoKsrEVfk\/6S3w+nXgovk\/iv+EQvzHBPLtf9\r\nYELH4jzG9\/B9tspP8whfwvIyhg\/4Vzw\/LsP\/H\/tf1VQWV8Rh3o\/40A\/P+VRgH+L5wblst\/gjP85\r\n5hz8P9NIOP\/M8wcizQIbtpEMPD\/rz0K8H\/h3LBC+i\/t\/4ngoP9MoJD+WzA6nDv+M5P\/xQXV9hcO\r\nB\/1nBKD\/VhoL6b+C7UAu\/7GT4T8f5X+C\/ls+aDOT\/4Wp1aBKCFIG4Z8VQAH+L5wblst\/muU\/s2H\r\n+JzMYz\/\/U6rlxPIkB6biM+r2J10I6GhMM\/Po4VuN10LreRne2kQ7SoBs30Gj7S7XdbNbPyiEUyW\r\nQQBSgN32yNdp4i2YvluRLfhX05KaLDPPDIuDkU0v8LThExt\/5X\/h8TWPHf5hTmfzUD0P8rjYX0f\r\n8F2IJf\/M+O\/Kf8FtWH+VyPIjP\/SpiMswTlpCixg\/qfrjwL8X3iCqDz+T+Z\/mvb\/DEP+lxG8Mv\/T\r\nqwZ\/rUmgYP6ndwOF4z+zz4bMORZQYPyf2ELP\/8gFB\/\/fDED\/rzQK8\/+iZ0Ny2oG59f+E\/46NYf4\r\nfIzj3\/AcnFqZNQjnDAvT\/tUdh\/hfu\/efgPz\/X\/9sw\/7sZLPf5D3ju423HJe9\/tA4e7u58s79rJc\r\nPktesooP+xTUbvf6IU\/H8zAP2\/0riE\/1OVX0I7kMv\/mfyflP96AlDQ\/yaQzf8hOv+nSZhOxQD5f\r\n\/1xCf9L7P3nGP9nONv\/q53Q\/5vAnu92vUCmb1bTkh+1vUjJ8jA6Qa0wSPTr1ZRS169Ic3tofHug\r\ndf3SNbfXk+0znd\/3D1EYVQ9P3Cg4rFtAaAAAAHjL8T95q5HhAIQAAA==' \\\r\n| tar xzf -\r\n```\r\n\r\nThen run:\r\n\r\n```\r\n$ cd jest-test\r\n$ NODE_OPTIONS=--experimental-vm-modules npx jest --config=jest.config.mjs \r\n```\r\n\r\n### Expected behavior\r\n\r\nI expected to see both defined tests get run, e.g.:\r\n\r\n```\r\n$ NODE_OPTIONS=--experimental-vm-modules npx jest --config=jest.config.mjs \r\n(node:1217) ExperimentalWarning: VM Modules is an experimental feature and might change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n PASS  code\/tests\/some.test.mjs\r\n  yes()\r\n    \u2713 is testable from `node_modules` (1 ms)\r\n    \u2713 is testable from outside `node_modules` (1 ms)\r\n\r\nTest Suites: 2 passed, 2 total\r\nTests:       2 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        0.234 s\r\nRan all test suites.\r\n```\r\n\r\n### Actual behavior\r\n\r\nOnly the test not under `node_modules` directory gets run:\r\n\r\n```\r\n$ NODE_OPTIONS=--experimental-vm-modules npx jest --config=jest.config.mjs \r\n(node:1217) ExperimentalWarning: VM Modules is an experimental feature and might change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n PASS  code\/tests\/some.test.mjs\r\n  yes()\r\n    \u2713 is testable from outside `node_modules` (1 ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        0.122 s\r\nRan all test suites.\r\n```\r\n\r\n### Additional context\r\n\r\nI think the problem may boil down to this line:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-haste-map\/src\/index.ts#L1104\r\n\r\n\u2026which seems to say that a file should be ignored if it happens to be under `node_modules`, no matter what the ignore patterns are. (This is only activated when the option `retainAllFiles` is off, but near as I can tell there's no way for a user config to cause it to be turned off with regards to finding test files.)\r\n\r\nIn terms of the big picture, the project that this example was distilled from sets up its own private modules under a `node_modules` directory, and I'm trying to get it so that tests can live next to the module definitions, as shown in the example. The `jest.config.mjs` file is meant to show how this would work for configuration, specifically, name the \"our project code\" directory in the `testMatch` pattern, so none of the external modules (which don't live under that directory) would ever get searched.\r\n\r\nRelatedly (but not quite in this bug's zone), I suspect I'm going to run into the same difficulty when I try to convince Jest to generate coverage reports for files in `code\/node_modules\/**`.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 14.3.1\r\n    CPU: (8) arm64 Apple M1\r\n  Binaries:\r\n    Node: 21.4.0 - \/opt\/homebrew\/bin\/node\r\n    Yarn: 1.22.21 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.4 - \/opt\/homebrew\/bin\/npm\r\n```\r\n","comments":["See #11084. Does that help?","@mrazauskas Thanks! Indeed that does solve the problem!\r\n\r\nI missed that `haste` was exported all the way to the main config, probably because it doesn't seem to be listed in the default `jest.config` file (which is what I was using as my basis for tweakage). I think that might be because it's not mentioned in this file: https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-config\/src\/Descriptions.ts\r\n\r\nSo, perhaps this bug should really be more of a documentation request, to help the next person who comes along with this problem. (As such, I'll leave it up to project-folk to close this issue as appropriate.)\r\n\r\nThanks again!"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Getting the compile time error ","body":"### Version\n\n    \"jest\": \"^26.6.3\",\n\n### Steps to reproduce\n\nnpm install\r\nyarn ios or yarn android\n\n### Expected behavior\n\n\r\nApp Should work as expected\n\n### Actual behavior\n\nnode_modules\/expect\/node_modules\/jest-message-util\/build\/index.js: path could not be found within the project or in these directories:\r\n  node_modules\/expect\/node_modules\r\n  node_modules\r\n   6 | exports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;\r\n   7 |\r\n>  8 | var path = _interopRequireWildcard(require('path'));\r\n     |                                             ^\r\n   9 |\r\n  10 | var _codeFrame = require('@babel\/code-frame');\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\n\"react\": \"17.0.2\",\r\n    \"react-native\": \"0.68.3\",\n```\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: When WorkerThreads are enabled the Jest fails to collect test coverage from untested files","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Clone https:\/\/github.com\/snaumov\/jest-issue-repro\r\n2. Run npm install\r\n3. Run npm run test\n\n### Expected behavior\n\nNo errors are logged to console\n\n### Actual behavior\n\n```\r\nERROR: Invalid file coverage object, missing keys, found:data\r\nSTACK: Error: Invalid file coverage object, missing keys, found:data\r\n    at assertValidObject (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/istanbul-lib-coverage\/lib\/file-coverage.js:38:15)\r\n    at new FileCoverage (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/istanbul-lib-coverage\/lib\/file-coverage.js:214:9)\r\n    at CoverageMap.addFileCoverage (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/istanbul-lib-coverage\/lib\/coverage-map.js:109:21)\r\n    at \/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/reporters\/build\/CoverageReporter.js:279:33\r\n    at async Promise.all (index 3)\r\n    at CoverageReporter._addUntestedFiles (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/reporters\/build\/CoverageReporter.js:296:7)\r\n    at CoverageReporter.onRunComplete (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/reporters\/build\/CoverageReporter.js:171:5)\r\n    at ReporterDispatcher.onRunComplete (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/core\/build\/ReporterDispatcher.js:71:9)\r\n    at TestScheduler.scheduleTests (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/core\/build\/TestScheduler.js:306:5)\r\n    at runJest (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/core\/build\/runJest.js:367:19)\r\n    at _run10000 (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/core\/build\/cli\/index.js:343:7)\r\n    at runCLI (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/@jest\/core\/build\/cli\/index.js:198:3)\r\n    at Object.run (\/Users\/stepannaumov\/Files\/temp\/jest_issue\/node_modules\/jest-cli\/build\/run.js:130:37)\r\n```\n\n### Additional context\n\nThe issue seem to be mostly cosmetic as coverage is still collected for untested files. \r\n\r\nI did some debugging and the problem seem to be related to how the coverage is passed from the worker to main jest process here\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-reporters\/src\/CoverageReporter.ts#L169-L192\r\n\r\nThe worker will create `istanbul` `FileCoverage` object and this object is then being passed back to `istanbul` (in `addFileCoverage` method). \r\nIf no worker_threads are being used the class as generated by worker will be \r\n\r\n```\r\nFileCoverage {\r\n  data: {\r\n   \/\/ coverage data\r\n }\r\n}\r\n```\r\n\r\nbut if worker_threads are being used the `FileCoverage` class gets serialized into a standard object\r\n\r\n```\r\n{\r\n  data: {\r\n  \/\/ coverage data\r\n  }\r\n}\r\n```\r\n\r\nwhich is then fails to be validated when passed to `istanbul`\r\n\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.6.4\r\n    CPU: (12) arm64 Apple M2 Max\r\n  Binaries:\r\n    Node: 18.16.0 - ~\/.nvm\/versions\/node\/v18.16.0\/bin\/node\r\n    Yarn: 1.22.19 - ~\/.nvm\/versions\/node\/v18.16.0\/bin\/yarn\r\n    npm: 9.5.1 - ~\/.nvm\/versions\/node\/v18.16.0\/bin\/npm\r\n    pnpm: 8.13.1 - ~\/.nvm\/versions\/node\/v18.16.0\/bin\/pnpm\r\n    bun: 1.0.0 - ~\/.bun\/bin\/bun\r\n  npmPackages:\r\n    jest: 29.7.0 => 29.7.0\n```\n","comments":["If this is only coverage issue, it might be fine to remove this line:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/9113f44b459f96db31e5ad3811d4d8b07f79e54f\/packages\/jest-reporters\/src\/CoverageReporter.ts#L147\r\n\r\nOr to use worker threads only, if `v8` is set as coverage provider.","actually, correction to my first message - when `workerThreads` are enabled, the coverage _is not_ being collected for untested files"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Unable to get Lit + Jest + Typescript + SWC Jest to work properly","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nI am trying to use [@swc\/jest](https:\/\/swc.rs\/docs\/usage\/jest) to speed up my tests on my `lit+typescript+jest` setup. When using the `swc\/jest` as the test runner the `willUpdate` method is not getting executed. From what I see\/find the call stack is different when using `ts-jest` & it works fine, but on using `swc\/jest` the callstack is missing the `_callSuper()`.\r\n\r\nI am attaching a simple repository that can [reproduce the issue](https:\/\/github.com\/gethari\/typescript-webpack-lit-html-jest-swc). Btw here's some screenshots that shows the above, if it is helpful\r\n\r\n### swc\r\n![image](https:\/\/github.com\/lit\/lit\/assets\/20477956\/b171e73f-8c21-4b6f-80df-54cc17dd2e41)\r\n\r\n### ts-jest\r\n![image](https:\/\/github.com\/lit\/lit\/assets\/20477956\/bda8b731-38f3-4c3c-9a26-1e2780da0855)\r\n\n\n### Expected behavior\n\nswc\/jest should not break existing tests & should call lit component lifecycle's willUpdate() method\n\n### Actual behavior\n\n`willUpdate()` method is not getting executed.\n\n### Additional context\n\nNot sure if this issue is specific to `jest` or `lit` or `swc` , I have filed the same issue on other repositories as well\r\n\r\n- https:\/\/github.com\/lit\/lit\/issues\/4580\r\n\r\n- https:\/\/github.com\/swc-project\/swc\/issues\/8734\n\n### Environment\n\n```shell\nOperating System:\r\nPlatform: linux\r\nArch: x64\r\nMachine Type: x86_64\r\nVersion: #19~22.04.1-Ubuntu SMP Wed Jan 10 22:57:03 UTC 2024\r\nCPU: (2 cores)\r\nModels: AMD EPYC 7763 64-Core Processor\r\n\r\nBinaries:\r\nNode: 20.11.1\r\nnpm: 10.2.4\r\nYarn: 1.22.19\r\npnpm: 8.15.4\r\n\r\nRelevant Packages:\r\njest : 29.7.0\n```\n","comments":["Jest only executes code provided by a transformer. Hence, if all works fine with `ts-jest`, most likely this is not an issue on Jest's side."],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: `structuredClone` under jest fails `instanceof` check","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone https:\/\/github.com\/guydunton\/jest-structured-clone-issue\r\n2. Run `npm run test`\r\n\r\n### Expected behavior\r\n\r\nI would expect the following test to pass:\r\n\r\n```javascript\r\ntest('structuredClone', () => {\r\n  const origDate = new Date();\r\n  const copyDate = structuredClone(origDate);\r\n\r\n  const isOrigDate = origDate instanceof Date; \/\/ true\r\n  const isCopyDate = copyDate instanceof Date; \/\/ false?\r\n\r\n  expect(isCopyDate).toBe(isOrigDate);\r\n});\r\n```\r\n\r\n### Actual behavior\r\n\r\n`instanceof` returns different values for a value & it's clone (using `structuredClone`) causing the test to fail.\r\n\r\n```\r\n  \u25cf structuredClone\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: true\r\n    Received: false\r\n\r\n       6 |   const isCopyDate = copyDate instanceof Date;\r\n       7 |\r\n    >  8 |   expect(isCopyDate).toBe(isOrigDate);\r\n         |                      ^\r\n       9 | });\r\n      10 |\r\n\r\n      at Object.toBe (main.test.js:8:22)\r\n```\r\n\r\n### Additional context\r\n\r\nRunning the following code in Node (20.11.1) gives the expected result:\r\n\r\n```javascript\r\nconst origDate = new Date();\r\nconst cloneDate = structuredClone(origDate);\r\nconsole.log('origDate', origDate instanceof Date);      \/\/ true\r\nconsole.log('cloneDate', cloneDate instanceof Date);    \/\/ true\r\n```\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 14.3.1\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz\r\n  Binaries:\r\n    Node: 20.11.1 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/node\r\n    Yarn: 1.22.21 - \/usr\/local\/bin\/yarn\r\n    npm: 10.2.4 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["Somewhat similar to #14011\r\n\r\nLooks like the root of the problem is #2549. Try using [`jest-light-runner`](https:\/\/github.com\/nicolo-ribaudo\/jest-light-runner). Reference: https:\/\/github.com\/jestjs\/jest\/issues\/2549#issuecomment-1098071474","> Somewhat similar to #14011\r\n> \r\n> Looks like the root of the problem is #2549. Try using [`jest-light-runner`](https:\/\/github.com\/nicolo-ribaudo\/jest-light-runner). Reference: [#2549 (comment)](https:\/\/github.com\/jestjs\/jest\/issues\/2549#issuecomment-1098071474)\r\n\r\nAh that solves it! Thank you! \r\n\r\nIt would be nice to not need to install a different runner but at least I have a way forwards","> It would be nice to not need to install a different runner but at least I have a way forwards\r\n\r\nIndeed that would be nice. To make this work Jest should give up isolating tests (unlikely) or a limitation on Node.js side should be fixed (follow https:\/\/github.com\/nodejs\/node\/issues\/31852)."],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: outputFile support for listTests option","body":"### \ud83d\ude80 Feature Proposal\n\nRight now, the --listTests option will just write the list of tests to the console. My proposal is to use the --outputFile option along with the --listTests option to write the output to the file.\n\n### Motivation\n\nWe wanted to use the list of tests in the custom sequencers. This feature will help to store the list in the file so that the sequencers can access it.\r\n\r\nNote that this is just my usecase. There may be different use cases as well.\n\n### Example\n\nPass `--outputFile=test-lists.json` along with `--listTests`\r\n\r\n`yarn test --listTests --json --outputFile=test-lists.json`\n\n### Pitch\n\nThe listTests option is a core feature of Jest and would be great if it support --outputFile as well","comments":["Raised Pull Request here -> https:\/\/github.com\/jestjs\/jest\/pull\/14944"],"labels":[":rocket: Feature Request"]},{"title":"[Feature]: Tagging test block failures with 'step' description","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nA way to get more context on where a longer, multi-step test block failed. \r\n\r\n### Motivation\r\n\r\nAt my work, we use Jest across all our JS repos and in many places use it with React Testing Library to mostly write 'integration-style' tests that test whole pages of our app. We use configuration to make each test block as free of state as possible (with the exception of some DOM state, which we can't reset). \r\n\r\nConsider that, when developers write their tests, the tests tend to fall into two styles:\r\n1. Many small test blocks and setup the tests in beforeEach\r\n2. Longer, multi-step test blocks that may test several different aspects.\r\n\r\nWe don't prescribe the testing style and personally I tend to write most of my tests in the second style (longer test blocks), for performance reasons and speed of writing tests. The motivation for this request is that it would be helpful to get better context on what part of a longer test block failed, without relying on code comments. \r\n\r\nExample usage of a utility that could solve this issue:\r\n\r\n### Example\r\n\r\n```\r\ntest('When SettingsView loads successfully', async () => {\r\n  jest.step('initial render')\r\n  render(<SettingsView \/>)\r\n  expect(await findByText('Settings page')).toBeVisible() \/\/ if this fails, add 'initial render' to the failure description\r\n  jest.step('saving data')\r\n  userEvent.click(getByText('Save'))\r\n  expect(await findByText('Save Successful')).toBeVisible() \/\/ if this fails adding 'saving data' to the test description\r\n})\r\n```\r\n\r\n### Pitch\r\n\r\nThe idea would be to have some sort of method (maybe on the jest object) that you can use to add metadata to a test block, that would give you some extra hints about what 'step' in a larger multi-step test block failed. You would use this method, which takes a string like 'saving the data to server', to notate the different steps of a large test block and give the developer better visibility of what part of a test has failed.\r\n\r\nThe idea is based loosely on the way [newrelic's SDK](https:\/\/github.com\/newrelic\/node-newrelic) adds event metadata to their monitoring of api\/lambda responses. Something like:\r\n\r\n`newrelic.addCustomAttribute(\"agency_code\", Agency);`\r\n\r\nEach time you call that newrelic function within your api handler, the new metadata would overwrite the last time you called it in the sequence of your handler. In our case we we could use something like this within our test block:\r\n`jest.step('step 2: save data')`\r\nand if there is a failure within the test block after that function was called, the text used as a parameter could be added to the failure message in the console.\r\n\r\nThis pattern would seemingly work in both async and sync test blocks and would allow us to have more flexibility with writing out tests while still getting clear indication on what step a test failed on.","comments":[],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: Jest asserts truthy when comparing undefined with Map","body":"### Version\n\n29.4.1\n\n### Steps to reproduce\n\nhttps:\/\/codesandbox.io\/p\/sandbox\/jest-playground-forked-n972cx\n\n### Expected behavior\n\nI expected the test to fail\n\n### Actual behavior\n\nThe test passes\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.0\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 18.12.0 - ~\/.nvm\/versions\/node\/v18.12.0\/bin\/node\r\n    Yarn: 1.22.19 - ~\/.nvm\/versions\/node\/v18.12.0\/bin\/yarn\r\n    npm: 9.7.2 - ~\/.nvm\/versions\/node\/v18.12.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.4.1 => 29.5.0\n```\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Validation warning for option \"reporters\" when using jest-junit to generate junit report","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. npm i jest-junit to your project\r\n2. Add the following configuration to your jest.config.ts file:\r\n` reporters: [\r\n    'default',\r\n    ['jest-junit', {\r\n      'outputName': 'auth.xml',\r\n      'outputDirectory': 'testResults',\r\n      'reportTestSuiteErrors': true,\r\n      'includeConsoleOutput': true\r\n    }]]`\r\n3. Run npx jest\r\n\r\n### Expected behavior\r\n\r\nSince all options passed seem to be correct and read from the documentation I was not expecting to see any warnings\r\n\r\n### Actual behavior\r\n\r\nI'm seeing:\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", [\"jest-junit\", {\"includeConsoleOutput\": true, \"outputDirectory\": \"testResults\", \"outputName\": \"auth.xml\", \"reportTestSuiteErrors\": true}]] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n### Additional context\r\n\r\nThis is being ran in an Angular 16 project; any help will be much appreciated\r\n\r\nthank you for looking into this; let me know if you need more details\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 14.3.1\r\n    CPU: (12) x64 Apple M2 Max\r\n  Binaries:\r\n    Node: 18.16.1 - ~\/.nvm\/versions\/node\/v18.16.1\/bin\/node\r\n    Yarn: 1.22.21 - \/usr\/local\/bin\/yarn\r\n    npm: 9.5.1 - ~\/.nvm\/versions\/node\/v18.16.1\/bin\/npm\r\n  npmPackages:\r\n    jest: 29.7.0 => 29.7.0\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Docs]: Difference between runner and testRunner?","body":"### Page(s)\n\nhttps:\/\/jestjs.io\/docs\/configuration#runner-string\n\n### Description\n\nCan you explain the difference between a runner and testRunner?\r\n\r\nIt seems a runner is what runs all the test runners no? From my own tinkering, testRunners got called once per test file, while a runner only gets called once with all tests across all files.","comments":["You can look at Jest like a sort task orchestrator. Runner then is what it manages (you can use this to e.g. run ESLint via Jest). A runner is executed once for every top level invocation (or watch mode re-run).\r\n\r\nTest runner is used by Jest's builtin runner in order to run tests. The test runner is then either `jest-circus` or the legacy `jest-jasmine`, and that's what provides `describe`, `test`, `expect` to tests and reports back a result.\r\n\r\nDoes that make sense? Happy to take PRs to clarify the docs","by top-level invocation, you mean when you run the Jest CLI right? I'll submit a clarification PR","Which abstraction would help me set some context right before an individual `test(..)` or `it(..)` runs? Like setting an environment variable or asynclocalstorage for the things in the test to read?\r\n\r\n<edited> Update: Found https:\/\/github.com\/jestjs\/jest\/issues\/7774 . What i really wanted was the test name so this should work I believe. If I have any other dynamic metadata (like some uuid I want to generate per test) I'll try the custom testRunner approach."],"labels":["Documentation :book:"]},{"title":"[Bug]: Reporter interface has onTestCaseStart, but that hook is never called","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nIf I implement a Reporter, i'd expect my hook `onTestCaseStart`, which `Reporter` seems to have, to work, but it does not.\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\nonTestCaseStart(..) gets called before a test(..) runs.\r\n\r\n### Actual behavior\r\n\r\nHook is not called.\r\n\r\n### Additional context\r\n\r\nAre the types incorrect?\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 13.4.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 20.8.0 - ~\/.nvm\/versions\/node\/v20.8.0\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.1.0 - ~\/.nvm\/versions\/node\/v20.8.0\/bin\/npm\r\n    pnpm: 8.10.4 - \/opt\/homebrew\/bin\/pnpm\r\n  npmPackages:\r\n    jest: ^29.6.2 => 29.6.2\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: `advanceTimersByTimeAsync` has inconsistent behavior regarding `setTimeout(x, 0)`","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nRun the following test:\r\n\r\n```ts\r\njest.useFakeTimers();\r\n\r\ntest(\"timers\", async () => {\r\n  let setTimeoutTest = false;\r\n  let queueMicrotaskTest = false;\r\n  let setTimeoutInMicrotaskTest = false;\r\n  let setTimeoutInTimeoutTest = false;\r\n\r\n  setTimeout(() => {\r\n    setTimeoutTest = true;\r\n  }, 0);\r\n\r\n  queueMicrotask(() => {\r\n    queueMicrotaskTest = true;\r\n    setTimeout(() => {\r\n      setTimeoutInMicrotaskTest = true;\r\n    }, 0);\r\n  });\r\n\r\n  setTimeout(() => {\r\n    setTimeout(() => {\r\n      setTimeoutInTimeoutTest = true;\r\n    }, 0);\r\n  }, 0);\r\n\r\n  await jest.advanceTimersByTimeAsync(0);\r\n  await jest.advanceTimersByTimeAsync(0); \/\/ just to be sure (does not affect results)\r\n\r\n  expect(setTimeoutTest).toBe(true); \/\/ passes\r\n  expect(queueMicrotaskTest).toBe(true); \/\/ passes\r\n  expect(setTimeoutInMicrotaskTest).toBe(true); \/\/ fails!\r\n  expect(setTimeoutInTimeoutTest).toBe(true); \/\/ fails!\r\n});\r\n```\r\n\r\n### Expected behavior\r\n\r\nWhen calling \r\n\r\n```ts\r\nawait jest.advanceTimersByTimeAsync(0);\r\n```\r\n\r\nI expect `setTimeout(x, 0)` to behave identically in all cases.\r\n\r\n### Actual behavior\r\n\r\nWhen calling \r\n\r\n```ts\r\nawait jest.advanceTimersByTimeAsync(0);\r\n```\r\n\r\nthe callbacks of `setTimeout(x, 0)` are only executed if they was scheduled inside the current task\r\n\r\n### Additional context\r\n\r\nMy jest config\r\n```json\r\n{\r\n  \"testEnvironment\": \"jsdom\",\r\n  \"preset\": \"ts-jest\"\r\n}\r\n```\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 20.11.1 - \/opt\/homebrew\/opt\/node@20\/bin\/node\r\n    Yarn: 1.22.21 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.4 - \/opt\/homebrew\/opt\/node@20\/bin\/npm\r\n    bun: 1.0.27 - \/opt\/homebrew\/bin\/bun\r\n```\r\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"OpenJS Onboarding: Create & Publish Project Charter","body":"### Page(s)\n\nN\/A\n\n### Description\n\nAs part of the [onboarding checklist ](https:\/\/github.com\/openjs-foundation\/project-status\/issues\/67)J est will need to publish a charter in the Jest Github repository.\r\n\r\n- The charter template can be found here https:\/\/github.com\/openjs-foundation\/cross-project-council\/blob\/HEAD\/PROJECT_CHARTER_TEMPLATE.md\r\n- An example of a pretty bare bones charter can be found here https:\/\/github.com\/nvm-sh\/nvm\/blob\/master\/PROJECT_CHARTER.md\r\n\r\n","comments":[],"labels":["Documentation :book:"]},{"title":"[Feature]: Global \/ system wide config ?","body":"### \ud83d\ude80 Feature Proposal\n\nHave a configuration file in a standardized place (`~\/jest.config.js|ts|mjs|cjs|json` ?) that will be used in all jest process started on the machine.\r\n\r\nTo prevent foot gun, this could be limited to a subset of the configuration\r\n\r\nThis config file would have a priority in between jest default and project config file, so the project config would still have the final word\n\n### Motivation\n\nThis will allow to override project-specific configuration for things that will always affect some machine, for example, it could allow to have such a file define `maxConcurrency` or `maxWorkers` in a CI runner by simply having the runner be built with this file, instead of having to define the CI job to start with flags for all of that runner specific config\r\n\r\nFor people where the default for `maxWorkers` is misbehaving for whatever reason, it could also allow them to set a new default system wide and be able to start tests on projects the same way as their team without risking having their machine slow to a crawl\n\n### Example\n\nSomebody have node reporting a number of CPU that makes jest `maxWorkers` default misbehave and slow down their machine. Define the file on system wide file with `maxWorkers: 4` (or whatever number works for them). This will override jest default, and still allow that project that needs to have tests runs with `maxWorkers: 1` to work\r\n\r\nSomebody likes to be notified for everything, but their personal preference is rejected by the other team members. That person can defined `notify: true, notifyMode: always` and have notifications on their machine without having the config file always showing as modified\n\n### Pitch\n\nConfiguring jest looks like something that should be part of jest itself ?","comments":[],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: Error while running watch","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. jest --watch\r\n2. I get the following error\r\n```\r\nTime:        12 snode:events:492\r\n      throw er; \/\/ Unhandled 'error' event\r\n      ^\r\n\r\nError: EPERM: operation not permitted, lstat 'C:\\repos\\emulator\\tests\\.generated\\test2\\reporting'\r\nEmitted 'error' event on NodeWatcher instance at:\r\n    at C:\\repos\\emulator\\node_modules\\.pnpm\\jest-haste-map@29.7.0\\node_modules\\jest-haste-map\\build\\watchers\\NodeWatcher.js:274:14\r\n    at FSReqCallback.oncomplete (node:fs:200:21) {\r\n  errno: -4048,\r\n  code: 'EPERM',\r\n  syscall: 'lstat',\r\n  path: 'C:\\\\repos\\\\emulator\\\\tests\\\\.generated\\\\test2\\\\reporting'\r\n}\r\n```\n\n### Expected behavior\n\nNot erroring\n\n### Actual behavior\n\nErroring\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (8) x64 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\r\n  Binaries:\r\n    Node: 20.5.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 9.8.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n    pnpm: 8.15.1 - ~\\scoop\\shims\\pnpm.EXE\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":[],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: The ability of `toHaveProperty` to parse dots in property name is so evil. Please remove it.","body":"### \ud83d\ude80 Feature Proposal\n\n**Suggestion 1:** Remove this behavior from `toHaveProperty`.\r\n\r\n**Suggestion 2:**\r\n1. Deprecate `toHaveProperty`.\r\n2. Create a new method named `toHavePropertyPath` that takes an array of string. It does not parse the dots in the string.\r\n3. Create a new method named `toHavePropertyName` that takes a string. It does not parse the dots in the string.\r\n4. We already have `string.split('.')`. No needs to provide unwanted \"convenience\".\n\n### Motivation\n\nThe only advantage parsing dots provide is less keystrokes than an array. But the cost is too great:\r\n* It creates a surprise when user pass an innocent string as key, only for jest to interpret it as a nested property path.\r\n* It makes it impossible to pass a generic string as a key. The user is restricted to only a subset of string with no dots.\n\n### Example\n\nCurrently, this would fail:\r\n\r\n```javascript\r\nexpect(bookmark).toHaveProperty('https:\/\/github.com')\r\n```\n\n### Pitch\n\n`toHaveProperty` is part of core.","comments":[],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: Using `projects` option does not \"copy the root-level configuration options to each individual child configuration during the test run\"","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nI made a [reproduction repository](https:\/\/github.com\/Llois41\/jest-projects-repro). Just check it out and run the test file inside (`npm run test`).\n\n### Expected behavior\n\nI expected that the tests will pass since the docs state [\"With the projects option enabled, Jest will copy the root-level configuration options to each individual child configuration during the test run[...]\"](https:\/\/jestjs.io\/docs\/configuration#projects-arraystring--projectconfig)\r\n\r\nI would expect to not have to copy all my default settings (like resetting mocks etc.) into my child project's configuration.\n\n### Actual behavior\n\nThe tests fail since the global config is not passed down to the child project's configuration\n\n### Additional context\n\nThe `rootDir`, `transformIgnorePatterns` and `preset` option are required to duplicate.\r\n\r\nAnd it would also be nice if options like `transform` or `setupFilesAfterEnv` would merge with the root level configuration to save some duplicate lines again.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.3.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 18.19.0 - ~\/.nvm\/versions\/node\/v18.19.0\/bin\/node\r\n    Yarn: 1.22.21 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.3 - ~\/.nvm\/versions\/node\/v18.19.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: Unexpected token 'export' when Jest test imports d3-array (3.2.4)","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nCreate an npm project for testing and initialize.\r\n\r\n```\r\nmkdir testing\r\ncd testing\r\nnpm init -y\r\n```\r\n\r\nInstall dependencies:\r\n\r\n```\r\nnpm install --save-exact d3-array\r\nnpm install --save-exact --save-dev jest ts-jest @types\/jest @types\/d3-array\r\n```\r\n\r\nCreate a test file, `example.test.ts` with these contents:\r\n\r\n```ts\r\nimport { quantile } from 'd3-array';\r\n\r\ndescribe('quantile', () => {\r\n  it('should be a function', () => {\r\n    expect(typeof quantile).toBe('function');\r\n  });\r\n});\r\n```\r\n\r\nCreate a `jest.config.js` with these contents:\r\n\r\n```\r\nmodule.exports = {\r\n  transform: { '^.+\\\\.ts?$': 'ts-jest' },\r\n};\r\n```\r\n\r\nInvoke jest:\r\n\r\n```\r\nnpx jest\r\n```\n\n### Expected behavior\n\nExample test should succeed:\r\n\r\n```\r\n$ npx jest\r\n PASS  .\/example.test.ts\r\n  quantile\r\n    \u2713 should be a function (2 ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        0.36 s\r\nRan all test suites.\r\n```\n\n### Actual behavior\n\n```\r\n$ npx jest\r\n FAIL  .\/example.test.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest encountered an unexpected token\r\n\r\n    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.\r\n\r\n    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.\r\n\r\n    By default \"node_modules\" folder is ignored by transformers.\r\n\r\n    Here's what you can do:\r\n     \u2022 If you are trying to use ECMAScript Modules, see https:\/\/jestjs.io\/docs\/ecmascript-modules for how to enable it.\r\n     \u2022 If you are trying to use TypeScript, see https:\/\/jestjs.io\/docs\/getting-started#using-typescript\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/configuration\r\n    For information about custom transformations, see:\r\n    https:\/\/jestjs.io\/docs\/code-transformation\r\n\r\n    Details:\r\n\r\n    \/home\/jimbo\/testing\/node_modules\/d3-array\/src\/index.js:1\r\n    ({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest){export {default as bisect, bisectRight, bisectLeft, bisectCenter} from \".\/bisect.js\";\r\n                                                                                      ^^^^^^\r\n\r\n    SyntaxError: Unexpected token 'export'\r\n\r\n      1 |\r\n    > 2 | import { quantile } from 'd3-array';\r\n        | ^\r\n      3 |\r\n      4 | describe('quantile', () => {\r\n      5 |     it('should be a function', () => {\r\n\r\n      at Runtime.createScriptFromCode (node_modules\/jest-runtime\/build\/index.js:1505:14)\r\n      at Object.<anonymous> (example.test.ts:2:1)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.369 s\r\nRan all test suites.\r\n\r\n```\n\n### Additional context\n\nWORKAROUND: Add the following to your `jest.config.js` to map all `d3-*` modules to their respective JavaScript implementations under `node_modules`:\r\n\r\n```\r\n  moduleNameMapper: {\r\n    '^d3-(.+)$': '<rootDir>\/node_modules\/d3-$1\/dist\/d3-$1.js',\r\n  },\r\n```\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 6.5 Ubuntu 22.04.4 LTS 22.04.4 LTS (Jammy Jellyfish)\r\n    CPU: (16) x64 AMD Ryzen 9 4900HS with Radeon Graphics\r\n  Binaries:\r\n    Node: 20.11.1 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/node\r\n    npm: 10.2.4 - ~\/.nvm\/versions\/node\/v20.11.1\/bin\/npm\r\n  npmPackages:\r\n    jest: 29.7.0 => 29.7.0\n```\n","comments":["Note: I had wanted to add my workaround to this bug: #12036, but it is locked for contributions.\r\n\r\nAdd this to your `jest.config.js`:\r\n\r\n```\r\n  moduleNameMapper: {\r\n    '^d3-(.+)$': '<rootDir>\/node_modules\/d3-$1\/dist\/d3-$1.js',\r\n  },\r\n```","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","can you set up a reproduction without `ts-jest`? That's not maintained in this repo"],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: New hook `beforeEach.successive` which is like beforeEach, but only for successive tests in the suite","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nAdd the `beforeEach.successive` hook, which runs before every test that is defined after this hook.\r\n\r\nThis idea continues the idea presented in #14614. I created a prototype for that idea and while it solved my use case it was also somewhat problematic in that one test case failure would fail all tests.\r\n\r\nThis proposal integrates much better with Jest as a whole too. It's just another hook you can use within your existing tests. You don't have to build around your tests being successive.\r\n\r\n### Motivation\r\n\r\nWhen performing integration tests that rely on complex data setup you have to either duplicate setup code in each test, extract it to a reused function or have tests that fail if you do not run them from start to finish.\r\n\r\n### Example\r\n\r\n#### The naive approach\r\n\r\nThe naive way of creating this test suite in the most readable manner would be to rely on state from previous test cases. This is problematic in that it makes Jest harder to use and that for slower tests you have to run the entire test suite regardless.\r\n\r\n<details>\r\n<summary>Naive example<\/summary>\r\n\r\n```javascript\r\ndescribe(\"article creation endpoint\", () => {\r\n    let authorization;\r\n\r\n    beforeAll(async () => {\r\n        authorization = await fetch(\"http:\/\/localhost:3000\/login\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n            },\r\n            body: JSON.stringify({\r\n                username: \"test\",\r\n                password: \"test\",\r\n            }),\r\n        })\r\n            .then((response) => response.json())\r\n            .then((data) => data.token);\r\n    });\r\n\r\n    test(\"it creates the article\", async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My first article\",\r\n                content: \"This is the content of my first article\",\r\n            }),\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json());\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n\r\n    test(\"it creates the second article\", async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My second article\",\r\n                content: \"This is the content of my second article\",\r\n            }),\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json());\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My second article\",\r\n            content: \"This is the content of my second article\",\r\n        });\r\n    });\r\n\r\n    test(\"it only deletes one article at a time\", async () => {\r\n        const articleId = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json())\r\n            .then((articles) => articles[0].id);\r\n\r\n        await fetch(`http:\/\/localhost:3000\/articles\/${articleId}`, {\r\n            method: \"DELETE\",\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json());\r\n\r\n        expect(articles).toHaveLength(1);\r\n\r\n        expect(articles).not.toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n});\r\n```\r\n<\/details>\r\n\r\n#### Duplicating setup code\r\n\r\nTo keep test state local, we can duplicate all setup steps, but that quickly becomes very verbose.\r\n\r\n<details>\r\n<summary>Duplicated setup<\/summary>\r\n\r\n```javascript\r\ndescribe(\"article creation endpoint\", () => {\r\n    let authorization;\r\n\r\n    beforeEach(async () => {\r\n        authorization = await fetch(\"http:\/\/localhost:3000\/login\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n            },\r\n            body: JSON.stringify({\r\n                username: \"test\",\r\n                password: \"test\",\r\n            }),\r\n        })\r\n            .then((response) => response.json())\r\n            .then((data) => data.token);\r\n    });\r\n\r\n    test(\"it creates the article\", async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                Authorization: `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My first article\",\r\n                content: \"This is the content of my first article\",\r\n            }),\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        }).then(\r\n            (response) => response.json(),\r\n        );\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n\r\n    test(\"it creates the second article\", async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                Authorization: `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My first article\",\r\n                content: \"This is the content of my first article\",\r\n            }),\r\n        });\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My second article\",\r\n                content: \"This is the content of my second article\",\r\n            }),\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", \r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        }).then(\r\n            (response) => response.json(),\r\n        );\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My second article\",\r\n            content: \"This is the content of my second article\",\r\n        });\r\n    });\r\n\r\n    test(\"it only deletes one article at a time\", async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                Authorization: `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My first article\",\r\n                content: \"This is the content of my first article\",\r\n            }),\r\n        });\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My second article\",\r\n                content: \"This is the content of my second article\",\r\n            }),\r\n        });\r\n\r\n        const articleId = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json())\r\n            .then((articles) => articles[0].id);\r\n\r\n        await fetch(`http:\/\/localhost:3000\/articles\/${articleId}`, {\r\n            method: \"DELETE\",\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        }).then(\r\n            (response) => response.json(),\r\n        );\r\n\r\n        expect(articles).toHaveLength(1);\r\n\r\n        expect(articles).not.toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n<\/details>\r\n\r\n#### Splitting out reused functionality\r\n\r\nSplitting out reused functionality is what I would probably consider the best approach as of today. The downside is that it can make the flow of the code much harder to follow. Especially for complex setup. It also lends itself to overly abstracting the test code in ways that lead to difficult to change tests.\r\n\r\n<details>\r\n<summary>Splitting out reused functionality<\/summary>\r\n\r\n```javascript\r\nlet authorization;\r\n\r\nconst createFirstArticle = () =>\r\n    fetch(\"http:\/\/localhost:3000\/articles\", {\r\n        method: \"POST\",\r\n        headers: {\r\n            \"Content-Type\": \"application\/json\",\r\n            Authorization: `Bearer ${authorization}`,\r\n        },\r\n        body: JSON.stringify({\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        }),\r\n    });\r\n\r\nconst createSecondArticle = () =>\r\n    fetch(\"http:\/\/localhost:3000\/articles\", {\r\n        method: \"POST\",\r\n        headers: {\r\n            \"Content-Type\": \"application\/json\",\r\n        },\r\n        body: JSON.stringify({\r\n            title: \"My second article\",\r\n            content: \"This is the content of my second article\",\r\n        }),\r\n    });\r\n\r\ndescribe(\"article creation endpoint\", () => {\r\n    beforeEach(async () => {\r\n        authorization = await fetch(\"http:\/\/localhost:3000\/login\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n            },\r\n            body: JSON.stringify({\r\n                username: \"test\",\r\n                password: \"test\",\r\n            }),\r\n        })\r\n            .then((response) => response.json())\r\n            .then((data) => data.token);\r\n    });\r\n\r\n    test(\"it creates the article\", async () => {\r\n        await createFirstArticle();\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        }).then(\r\n            (response) => response.json(),\r\n        );\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n\r\n    test(\"it creates the second article\", async () => {\r\n        await createFirstArticle();\r\n        await createSecondArticle();\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        }).then(\r\n            (response) => response.json(),\r\n        );\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My second article\",\r\n            content: \"This is the content of my second article\",\r\n        });\r\n    });\r\n\r\n    test(\"it only deletes one article at a time\", async () => {\r\n        await createFirstArticle();\r\n        await createSecondArticle();\r\n\r\n        const articleId = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json())\r\n            .then((articles) => articles[0].id);\r\n\r\n        await fetch(`http:\/\/localhost:3000\/articles\/${articleId}`, {\r\n            method: \"DELETE\",\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        });\r\n\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        }).then(\r\n            (response) => response.json(),\r\n        );\r\n\r\n        expect(articles).toHaveLength(1);\r\n\r\n        expect(articles).not.toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n<\/details>\r\n\r\n#### With `beforeEach.successive` we are much closer to what we wanted with the first example, but the test cases are independent and expensive operations can be scoped to single test cases.\r\n\r\n```javascript\r\ndescribe(\"article creation endpoint\", () => {\r\n    let authorization;\r\n\r\n    beforeEach(async () => {\r\n        authorization = await fetch(\"http:\/\/localhost:3000\/login\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n            },\r\n            body: JSON.stringify({\r\n                username: \"test\",\r\n                password: \"test\",\r\n            }),\r\n        })\r\n            .then((response) => response.json())\r\n            .then((data) => data.token);\r\n    });\r\n\r\n    \/\/ This runs 3 times and is equivalent to a beforeEach\r\n    beforeEach.successive(async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My first article\",\r\n                content: \"This is the content of my first article\",\r\n            }),\r\n        });\r\n    });\r\n\r\n    test(\"it creates the article\", async () => {\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json());\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n\r\n    \/\/ This runs 2 times\r\n    beforeEach.successive(async () => {\r\n        await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application\/json\",\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n            body: JSON.stringify({\r\n                title: \"My second article\",\r\n                content: \"This is the content of my second article\",\r\n            }),\r\n        });\r\n    });\r\n\r\n    test(\"it creates the second article\", async () => {\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json());\r\n\r\n        expect(articles).toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My second article\",\r\n            content: \"This is the content of my second article\",\r\n        });\r\n    });\r\n\r\n    \/\/ This runs 1 time\r\n    beforeEach.successive(async () => {\r\n        const articleId = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                \"Authorization\": `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json())\r\n            .then((articles) => articles[0].id);\r\n\r\n        await fetch(`http:\/\/localhost:3000\/articles\/${articleId}`, {\r\n            method: \"DELETE\",\r\n            headers: {\r\n                Authorization: `Bearer ${authorization}`,\r\n            },\r\n        });\r\n    });\r\n\r\n    test(\"it only deletes one article at a time\", async () => {\r\n        const articles = await fetch(\"http:\/\/localhost:3000\/articles\", {\r\n            headers: {\r\n                Authorization: `Bearer ${authorization}`,\r\n            },\r\n        })\r\n            .then((response) => response.json());\r\n\r\n        expect(articles).toHaveLength(1);\r\n\r\n        expect(articles).not.toContainEqual({\r\n            id: expect.any(String),\r\n            title: \"My first article\",\r\n            content: \"This is the content of my first article\",\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n### Pitch\r\n\r\n`beforeEach.successive` integrates nicely with the existing Jest platform and will let you build tests with complex incremental state changes in an easy to read manner.","comments":["I'll happily look into this if you like the idea.\r\n\r\nMinimal implementation excluding support for `test.each` and the `done`-callback:\r\n\r\n```javascript\r\nlet collectedCallbacks = [];\r\n\r\nglobal.beforeEachSuccessiveTest = (closure) => {\r\n    collectedCallbacks.push(closure);\r\n};\r\n\r\nconst test = global.test;\r\n\r\n[\"test\", \"it\"].forEach((ident) => {\r\n    global[ident] = function (name, fn) {\r\n        const beforeCallbacks = collectedCallbacks.slice();\r\n        test.call(this, name, () => {\r\n            return runAll([...beforeCallbacks, fn]);\r\n        });\r\n    };\r\n    Object.assign(global[ident], test);\r\n});\r\n\r\nfunction runAll(callbacks) {\r\n    for (let i = 0; i < callbacks.length; i++) {\r\n        const value = callbacks[i]();\r\n        if (typeof value?.then === \"function\") {\r\n            return value.then(() => {\r\n                runAll(callbacks.slice(i + 1));\r\n            });\r\n        }\r\n    }\r\n}\r\n```"],"labels":[":rocket: Feature Request"]},{"title":"[Feature]: Report duplicate test names","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nWhen I have more than one file using the exact same test name, I want jest to throw an error\r\n\r\n\r\n### Motivation\r\n\r\n* All tests should be properly described\r\n* When using schematic approaches to application programming (e.g. all controllers in a NestJS application are similar but  differ in the data they handle) - some developers - including myself sometimes tend to minimize effort of setting up the structure of the tests for a new component by copying the test of a similar, existing component and then changing the tested class etc. so that it tests the new component. Sometimes, people forget to adapt the test names to a new scenario.\r\nWhen a test fails then, it is hard to find it using the search feature of the editor because that search feature would usually report all occurrences of the test name\r\n\r\n\r\n### Example\r\n\r\nclass-a.spec.ts\r\n\r\n```\r\ndescribe(\"classA tests\", () => {\r\n  it(\"works\", () => {\r\n    expect(true).toEqual(true);\r\n  });\r\n})\r\n````\r\n\r\nclass-b.spec.ts\r\n\r\n```\r\ndescribe(\"classB tests\", () => {\r\n  it(\"works\", () => {\r\n    expect(false).toEqual(false);\r\n  });\r\n````\r\n\r\nshould lead the execution of all tests in a single jest call to fail\r\n### Pitch\r\n\r\n\r\nI experienced having the exact same test twice within the same .spec.ts file - probably happened during a merge. This is a waste of resource then.","comments":["Did you try [`eslint-plugin-jest`](https:\/\/github.com\/jest-community\/eslint-plugin-jest)? It has `no-identical-title` rule.","Works good so far, thank you for making me aware of this\n\nHowever this should be a feature automatically shipped with jest\nWhen someone simply isn't aware of the problem and the solution with eslint, problems might stack up ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"Failed build: Node Nightly CI","body":"GitHub Actions workflow [Node Nightly CI #159](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/7941487913) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [8bbe2a34a8a7979d71ece3fadc6006df3e607d9f](https:\/\/github.com\/jestjs\/jest\/commit\/8bbe2a34a8a7979d71ece3fadc6006df3e607d9f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","comments":["GitHub Actions workflow [Node Nightly CI #160](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/7948801668) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [8bbe2a34a8a7979d71ece3fadc6006df3e607d9f](https:\/\/github.com\/jestjs\/jest\/commit\/8bbe2a34a8a7979d71ece3fadc6006df3e607d9f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #161](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/7959203437) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [8bbe2a34a8a7979d71ece3fadc6006df3e607d9f](https:\/\/github.com\/jestjs\/jest\/commit\/8bbe2a34a8a7979d71ece3fadc6006df3e607d9f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #162](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/7973123194) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [e267aff33d105399f2134bad7c8f82285104f3da](https:\/\/github.com\/jestjs\/jest\/commit\/e267aff33d105399f2134bad7c8f82285104f3da)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #163](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/7988692076) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [e6d60cb1ab04a2d691dcbf025ed53d7a07327889](https:\/\/github.com\/jestjs\/jest\/commit\/e6d60cb1ab04a2d691dcbf025ed53d7a07327889)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #164](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8004139631) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [5daab9075c66f5aae6d6adfd057ad49706cca771](https:\/\/github.com\/jestjs\/jest\/commit\/5daab9075c66f5aae6d6adfd057ad49706cca771)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #165](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8018889590) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [5daab9075c66f5aae6d6adfd057ad49706cca771](https:\/\/github.com\/jestjs\/jest\/commit\/5daab9075c66f5aae6d6adfd057ad49706cca771)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #166](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8030370918) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [5daab9075c66f5aae6d6adfd057ad49706cca771](https:\/\/github.com\/jestjs\/jest\/commit\/5daab9075c66f5aae6d6adfd057ad49706cca771)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #167](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8037775569) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [7e33cd77ccab163ea525f5c7b45c3c48a3458630](https:\/\/github.com\/jestjs\/jest\/commit\/7e33cd77ccab163ea525f5c7b45c3c48a3458630)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #168](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8048512285) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [572cbfb0a538b2a56f377f79aeeab26f51eb2789](https:\/\/github.com\/jestjs\/jest\/commit\/572cbfb0a538b2a56f377f79aeeab26f51eb2789)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #169](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8064385056) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [572cbfb0a538b2a56f377f79aeeab26f51eb2789](https:\/\/github.com\/jestjs\/jest\/commit\/572cbfb0a538b2a56f377f79aeeab26f51eb2789)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #170](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8080025815) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [572cbfb0a538b2a56f377f79aeeab26f51eb2789](https:\/\/github.com\/jestjs\/jest\/commit\/572cbfb0a538b2a56f377f79aeeab26f51eb2789)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #171](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8095681270) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [572cbfb0a538b2a56f377f79aeeab26f51eb2789](https:\/\/github.com\/jestjs\/jest\/commit\/572cbfb0a538b2a56f377f79aeeab26f51eb2789)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #172](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8111039250) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [892f9a6714a9749e22e63098bb1aef9f7a91c46d](https:\/\/github.com\/jestjs\/jest\/commit\/892f9a6714a9749e22e63098bb1aef9f7a91c46d)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #173](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8122589710) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [892f9a6714a9749e22e63098bb1aef9f7a91c46d](https:\/\/github.com\/jestjs\/jest\/commit\/892f9a6714a9749e22e63098bb1aef9f7a91c46d)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #174](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8130001806) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [892f9a6714a9749e22e63098bb1aef9f7a91c46d](https:\/\/github.com\/jestjs\/jest\/commit\/892f9a6714a9749e22e63098bb1aef9f7a91c46d)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #175](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8139882913) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [442c7f692e3a92f14a2fb56c1737b26fc663a0ef](https:\/\/github.com\/jestjs\/jest\/commit\/442c7f692e3a92f14a2fb56c1737b26fc663a0ef)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #176](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8155899827) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [442c7f692e3a92f14a2fb56c1737b26fc663a0ef](https:\/\/github.com\/jestjs\/jest\/commit\/442c7f692e3a92f14a2fb56c1737b26fc663a0ef)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #177](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8171732644) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [442c7f692e3a92f14a2fb56c1737b26fc663a0ef](https:\/\/github.com\/jestjs\/jest\/commit\/442c7f692e3a92f14a2fb56c1737b26fc663a0ef)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #178](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8187775724) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [442c7f692e3a92f14a2fb56c1737b26fc663a0ef](https:\/\/github.com\/jestjs\/jest\/commit\/442c7f692e3a92f14a2fb56c1737b26fc663a0ef)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #179](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8202967149) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [3f2161feb83f4ee8c2d65b72ecd488d5eefcb4f8](https:\/\/github.com\/jestjs\/jest\/commit\/3f2161feb83f4ee8c2d65b72ecd488d5eefcb4f8)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #180](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8214343904) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [3f2161feb83f4ee8c2d65b72ecd488d5eefcb4f8](https:\/\/github.com\/jestjs\/jest\/commit\/3f2161feb83f4ee8c2d65b72ecd488d5eefcb4f8)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #181](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8221782806) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [3f2161feb83f4ee8c2d65b72ecd488d5eefcb4f8](https:\/\/github.com\/jestjs\/jest\/commit\/3f2161feb83f4ee8c2d65b72ecd488d5eefcb4f8)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #182](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8232430307) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [9113f44b459f96db31e5ad3811d4d8b07f79e54f](https:\/\/github.com\/jestjs\/jest\/commit\/9113f44b459f96db31e5ad3811d4d8b07f79e54f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #183](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8248444317) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [9113f44b459f96db31e5ad3811d4d8b07f79e54f](https:\/\/github.com\/jestjs\/jest\/commit\/9113f44b459f96db31e5ad3811d4d8b07f79e54f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #184](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8264289424) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [9113f44b459f96db31e5ad3811d4d8b07f79e54f](https:\/\/github.com\/jestjs\/jest\/commit\/9113f44b459f96db31e5ad3811d4d8b07f79e54f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #185](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8280350018) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [9113f44b459f96db31e5ad3811d4d8b07f79e54f](https:\/\/github.com\/jestjs\/jest\/commit\/9113f44b459f96db31e5ad3811d4d8b07f79e54f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #186](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8295859245) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [9113f44b459f96db31e5ad3811d4d8b07f79e54f](https:\/\/github.com\/jestjs\/jest\/commit\/9113f44b459f96db31e5ad3811d4d8b07f79e54f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #187](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8307572573) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [6b120fbc5d1cadb3ef205bd1d48549155bed5dd1](https:\/\/github.com\/jestjs\/jest\/commit\/6b120fbc5d1cadb3ef205bd1d48549155bed5dd1)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #188](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8315232034) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [ba355a47de3575ca1fe14b7460a89757090bfecf](https:\/\/github.com\/jestjs\/jest\/commit\/ba355a47de3575ca1fe14b7460a89757090bfecf)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #189](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8326185715) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [09251a53598e45a99d71dceaf97ed820e0dd2ade](https:\/\/github.com\/jestjs\/jest\/commit\/09251a53598e45a99d71dceaf97ed820e0dd2ade)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #190](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8342630932) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [09251a53598e45a99d71dceaf97ed820e0dd2ade](https:\/\/github.com\/jestjs\/jest\/commit\/09251a53598e45a99d71dceaf97ed820e0dd2ade)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #191](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8358560662) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [d4d1f2b8004b1eb4bf0cf862698dd1142e13278f](https:\/\/github.com\/jestjs\/jest\/commit\/d4d1f2b8004b1eb4bf0cf862698dd1142e13278f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #192](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8374583705) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [d4d1f2b8004b1eb4bf0cf862698dd1142e13278f](https:\/\/github.com\/jestjs\/jest\/commit\/d4d1f2b8004b1eb4bf0cf862698dd1142e13278f)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #193](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8389976526) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [cde5f7bda89b0b8fc5426e704de8e19160f2bd28](https:\/\/github.com\/jestjs\/jest\/commit\/cde5f7bda89b0b8fc5426e704de8e19160f2bd28)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>","GitHub Actions workflow [Node Nightly CI #194](https:\/\/github.com\/jestjs\/jest\/actions\/runs\/8401620125) failed.\n\nEvent: schedule\nBranch: [main](https:\/\/github.com\/jestjs\/jest\/tree\/main)\nCommit: [cde5f7bda89b0b8fc5426e704de8e19160f2bd28](https:\/\/github.com\/jestjs\/jest\/commit\/cde5f7bda89b0b8fc5426e704de8e19160f2bd28)\n\n<sup><i>Created by [jayqi\/failed-build-issue-action](https:\/\/github.com\/jayqi\/failed-build-issue-action)<\/i><\/sup>"],"labels":["build failed"]},{"title":"[Feature]: Ability to dispatch spec files to jest non-interactively","body":"### \ud83d\ude80 Feature Proposal\n\nI would like to be able to dispatch spec files non-interactively to Jest process.\n\n### Motivation\n\nDuring development, I run Jest for a couple of spec files which are affected. This is how I do it\r\n\r\n    npm run test -- <list of spec file paths>\r\n\r\nHowever, this causes jest to startup, execute tests and then stop after the tests complete. Since this happens many times during a day and each execution takes quite a lot of time. What's common across the test runs is the fact jest needs to start and stop, the only changing part is the spec files.\r\n\r\nWith this feature jest could run in the background, and I could run a command to inform jest about spec files to be run. \r\n\r\nI know this sounds like watch mode, but I do not want an interactive menu on terminal; rather a non-interactive way of dispatching spec files to jest.\r\n\r\n\n\n### Example\n\nTerminal 1: start jest \r\n\r\n`npm run test:jest-start-background \/\/ Starts jest process listening for spec files to be executed`\r\n\r\nTerminal 2: Dispatch spec files to jest\r\n\r\n` npm run test:dispatch-specs <list of spec file paths>`\n\n### Pitch\n\nBy starting up jest once during development workflow, will lead to faster feedback for developer saving a lot of time.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"[Bug]: Jest does not recognise Vite suffixes applied to imports","body":"### Version\n\n29\n\n### Steps to reproduce\n\nWith Vite we can decide how to import static assets: https:\/\/vitejs.dev\/guide\/assets .\r\nIn particular: you can add specific suffixes to the imported file, like ?inline.\r\n\r\nJest 29 does not recognize those imports and throws an error saying that the file could not be found.\r\n\r\nIf I use a moduleMapper I can map the file to a stub, but existing transforms they do not work any longer..\r\n \r\n\n\n### Expected behavior\n\nFile should have been recognize and Jest should threat the suffix not as as part of the path, but instead as metadata or ignore it vcompletely.\r\nI should be able to use a transform if in order to treat svg as ReactComponent for example.\n\n### Actual behavior\n\nJest says that the file is not found, so the related transform is not applied\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nOS: Windows\r\nJest Version: 29\r\nNode version: 18\n```\n","comments":["you can use a custom resolver to strip query parameters. not sure if there are cleaner ways of doing it","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: Error Message links to URL with . at the end, causeing wrong url to be opened","body":"### Version\n\nlatest\n\n### Steps to reproduce\n\nTrigger the Error   \r\n`Add a timeout value to this test to increase the timeout, if this is a long-running test. See https:\/\/jestjs.io\/docs\/api#testname-fn-timeout.`;`\r\n\n\n### Expected behavior\n\nhttps:\/\/jestjs.io\/docs\/api#testname-fn-timeout\n\n### Actual behavior\n\nhttps:\/\/jestjs.io\/docs\/api#testname-fn-timeout.\n\n### Additional context\n\nThe . at the end breaks the link, it should be removed\n\n### Environment\n\n```shell\nNot relevant\n```\n","comments":["PR very much welcome \ud83d\ude42 ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Feature]: toContainSnapshot and toContainInlineSnapshot","body":"### \ud83d\ude80 Feature Proposal\n\nI would like to propose adding two new functions:\r\n\r\n`toContainSnapshot` - ensures that an array contains a structure that matches a snapshot\r\n`toContainInlineSnapshot` - ensures that an array contains a structure that matches a snapshot which is inlined within the test body\r\n\r\nDuring initial creation, as the requirement is to only match one of the items in an array it would likely be best to output the entire array contents (like `toContainEqual` does on a failed match) allowing the user to delete the un-interesting items from the snapshot to enable rapid test creation.\n\n### Motivation\n\nYou often want to ensure that a particular item is within an array. This can be useful for checking more static information (such as a piece of data) or something more dynamic (such as a redux action), along with lots of other cases.\r\n\r\nCurrent we have `toContain` and `toContainEqual` which have similar behaviour to this proposal. However with realistic test data used in mocks, shapes can subtly change which can lead to having to update a lot of tests by hand. \r\n\r\nThe alternative way of writing these is to be very implicit, which are a little more difficult to understand the full context if a test fails, and are potentially more brittle with more complex implementations as they're much less specific about their assertions:\r\n\r\n```\r\nimport { myTestObj } from \".\/testdata\";\r\n\r\ndescribe(\"example of an implicit test\", () => {\r\n    it(\"adding to an array\", () => {\r\n         const myArray = [];\r\n         myArray.push({ ...myTestObj });\r\n\r\n         expect(myArray).toContainEqual(myTestObj);\r\n    });\r\n});\r\n```\n\n### Example\n\nA good example would be looking at a redux action:\r\n\r\n```\r\nimport { actions } from \".\/slice\";\r\n\r\ndescribe(\"redux actions\", () => {\r\n    it(\"fires correctly\", () => {\r\n        const store = createMockStore({\r\n           { foo: \"bar\" },\r\n        });\r\n\r\n       store.dispatch(actions.changeFoo(\"baz\"));\r\n\r\n       expect(store.getActions()).toContainEqual({\r\n           type: \"Slice:CHANGE_FOO\",\r\n           payload: \"baz\",\r\n       });\r\n    });\r\n});\r\n```\r\n\r\nIf you were to change the shape of the action then you have to update this manually. If you were using this pattern in multiple places asserting on this action then there can be chunk of manual work updating actions. If you were able to use a snapshot it would be much quicker to update the test.\n\n### Pitch\n\nThe main reason being that this is very close to the existing matchers `toContainEqual` and `toMatchSnapshot` which makes it feel like it'd fit better with the core matchers rather than an extended set.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"[Feature]: Custom diff for custom asymmetric matcher","body":"### \ud83d\ude80 Feature Proposal\n\nI would like to do the asymmetric matcher `objectContainingOrNot`, that takes an object that should be contained and a list of properties that should not be contained.\r\n\r\nIf I use the `toAsymmetricMatcher` method, no diff will be displayed.\n\n### Motivation\n\nHaving better diffs will ease the debugging in case values don't match.\n\n### Example\n\n_No response_\n\n### Pitch\n\nJest purpose is to test, hence diffing is a core element of this.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Should be kept"],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: Wrong diff for objectContaining","body":"### Version\n\n29.7\n\n### Steps to reproduce\n\nhttps:\/\/stackblitz.com\/edit\/vitejs-vite-rnytfb\r\n\r\nRun `npm run test-jest`\n\n### Expected behavior\n\nMessage:\r\n      expect(received).toEqual(expected) \/\/ deep equality\r\n    \r\n    - Expected  - 2\r\n    + Received  + 2\r\n    \r\n    - ObjectContaining {\r\n    + Object {\r\n        \"a\": 1,\r\n        \"b\": 2,\r\n    -   \"c\": 2,\r\n    +   \"c\": 3,\r\n      }\n\n### Actual behavior\n\nMessage:\r\n      expect(received).toEqual(expected) \/\/ deep equality\r\n    \r\n    - Expected  - 2\r\n    + Received  + 3\r\n    \r\n    - ObjectContaining {\r\n    + Object {\r\n    +   \"a\": 1,\r\n        \"b\": 2,\r\n    -   \"c\": 2,\r\n    +   \"c\": 3,\r\n      }\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.0 undefined\r\n    CPU: (8) x64 Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 18.18.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.19 - \/usr\/local\/bin\/yarn\r\n    npm: 10.2.3 - \/usr\/local\/bin\/npm\r\n    pnpm: 8.14.0 - \/usr\/local\/bin\/pnpm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale ofc. It is not because there is no activity that the bug disappears."],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: `transform` regex doesn't match files in folders on Windows ","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nThis was already reported here, but the issue was locked: https:\/\/github.com\/jestjs\/jest\/issues\/11333\r\n\r\nSteps to reproduce the behavior:\r\n\r\n- Be on Windows\r\n- Trying using the following `transform` regex:\r\n```js\r\n  transform: {\r\n    'tti-polyfill\/src\/.+\\\\.js': '.\/jest.babel-transform.js',\r\n  }\r\n```\r\n- The tests will fail at transformation time\r\n\r\nHere is a reproduction repo: https:\/\/github.com\/Drarig29\/repro-jest-transform-regex-windows-issue\r\n\r\nAnd this is the failing CI: https:\/\/github.com\/Drarig29\/repro-jest-transform-regex-windows-issue\/actions\/runs\/7860984313\r\n\r\n### Expected behavior\r\n\r\nI expect the unit tests to pass on **Linux, macOS and Windows** with the same Jest config.\r\n\r\n### Actual behavior\r\n\r\nInstead, I get this error:\r\n\r\n```js\r\nFAIL .\/not-working.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest encountered an unexpected token\r\n\r\n    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.\r\n\r\n    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.\r\n\r\n    By default \"node_modules\" folder is ignored by transformers.\r\n\r\n    Here's what you can do:\r\n     \u2022 If you are trying to use ECMAScript Modules, see https:\/\/jestjs.io\/docs\/ecmascript-modules for how to enable it.\r\n     \u2022 If you are trying to use TypeScript, see https:\/\/jestjs.io\/docs\/getting-started#using-typescript\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/configuration\r\n    For information about custom transformations, see:\r\n    https:\/\/jestjs.io\/docs\/code-transformation\r\n\r\n    Details:\r\n\r\n    D:\\a\\repro-jest-transform-regex-windows-issue\\repro-jest-transform-regex-windows-issue\\node_modules\\tti-polyfill\\src\\firstConsistentlyInteractiveDetector.js:19\r\n    import * as activityTrackerUtils from '.\/activityTrackerUtils.js';\r\n    ^^^^^^\r\n\r\n    SyntaxError: Cannot use import statement outside a module\r\n\r\n    > 1 | const TTI = require(\"tti-polyfill\/src\/firstConsistentlyInteractiveDetector\");\r\n        |                                                                              ^\r\n      2 |\r\n      3 | test(\"example\", () => {\r\n      4 |   expect(true).toBe(true);\r\n\r\n      at Runtime.createScriptFromCode (node_modules\/jest-runtime\/build\/index.js:1505:14)\r\n      at Object.<anonymous> (not-working.test.js:1:115)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.363 s\r\nRan all test suites.\r\n```\r\n\r\n### Additional context\r\n\r\nThe following change works (see [this branch](https:\/\/github.com\/Drarig29\/repro-jest-transform-regex-windows-issue\/actions\/runs\/7860992926)), but only in Windows (replace `\/` with `\\\\\\\\`):\r\n\r\n```diff\r\n  transform: {\r\n-    'tti-polyfill\/src\/.+\\\\.js': '.\/jest.babel-transform.js',\r\n+    'tti-polyfill\\\\\\\\src\\\\\\\\.+\\\\.js': '.\/jest.babel-transform.js',\r\n  }\r\n```\r\n\r\nSo the solution is to have 2 different configs:\r\n- One for Unix-based OSes (Linux and macOS)\r\n- One for Windows\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: Windows 10 10.0.20348\r\n  CPU: (4) x64 AMD EPYC 7763 64-Core Processor                \r\nBinaries:\r\n  Node: 18.18.2 - C:\\Program Files\\nodejs\\node.EXE\r\n  Yarn: 1.22.21 - C:\\npm\\prefix\\yarn.CMD\r\n  npm: 9.8.1 - C:\\Program Files\\nodejs\\npm.CMD\r\n```\r\n","comments":["cc. @capaj since you created https:\/\/github.com\/jestjs\/jest\/issues\/11333","In the end, I have this:\r\n\r\n```js\r\nconst path = require('path')\r\n\r\n\/** @type {import('jest').Config} *\/\r\nconst config = {\r\n  transformIgnorePatterns: ['node_modules\/(?!tti-polyfill)'],\r\n  transform: {\r\n    [`tti-polyfill\\\\${path.sep}src\\\\${path.sep}.+\\\\.js`]: '.\/jest.babel-transform.js',\r\n  },\r\n}\r\n\r\nmodule.exports = config\r\n```","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: Imports from React.lazy calls may cause random test timeouts","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n[jestTimeout.tar.gz](https:\/\/github.com\/jestjs\/jest\/files\/14214112\/jestTimeout.tar.gz)\r\n\r\nSteps to reproduce:\r\n1. Extract the attached tar file\r\n2. Run `npm install`\r\n3. Run `npm test` -- note: you _may_ need to modify the timeout in `index.test.jsx` depending upon the speed of your storage device.\r\n4. Comment out the import in `slowImport.jsx`; alternatively, add the import to the test file.\r\n\r\n\r\n### Expected behavior\r\n\r\nOne of the following:\r\n1. All `React.lazy` calls should be run once (hard, probably won't happen -- `React.lazy` doesn't have to be at the top level, and I don't _think_ they get hoisted to the top level).\r\n2. A message indicating that delayed imports such as those that may occur with `React.lazy` may cause seemingly random test timeouts.\r\n3. A note for `React.lazy` indicating that the lazy components should be imported prior to the test (in this case, this bug should be over in the react repo)\r\n4. Log `import` calls and print to console when they occur inside a test instead of during initial import loading\r\n\r\n### Actual behavior\r\n\r\nA generic timeout error is given. In my experience, this can cause tests to fail inconsistently unless the test was previously close to the timeout limit in a _consistent_ environment (like CI).\r\n\r\n### Additional context\r\n\r\nOn my machine, importing `date-fns` in the `index.test.js` file took the slow import test from >400ms to <50ms. I believe that the same amount of time was spent overall in the test, but we weren't waiting on the filesystem during the bit that needed to complete within the timeout limit.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 13.6.4\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7920HQ CPU @ 3.10GHz\r\n  Binaries:\r\n    Node: 20.11.0 - ~\/.asdf\/installs\/nodejs\/20.11.0\/bin\/node\r\n    npm: 10.2.4 - ~\/.asdf\/plugins\/nodejs\/shims\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: `toThrow(JestAssertionError)` crashes the test instead of passing ","body":"### Version\r\n\r\n29.6.1\r\n\r\n### Steps to reproduce\r\n\r\n```ts\r\nimport { JestAssertionError } from 'expect';\r\n\r\nexpect(() => {\r\n expect(\"1\").toBeNumber();\r\n}).toThrow(JestAssertionError);\r\n```\r\n\r\n### Expected behavior\r\n\r\ntest should pass\r\n\r\n### Actual behavior\r\n\r\ntest fails\r\n```\r\nexpect(received).toThrow(expected)\r\n\r\n    Expected constructor: JestAssertionError\r\n    Received constructor: JestAssertionError\r\n\r\n    Received message: \"Expected received to be a number but found 1.\"\r\n\r\n[call stack and other info trimmed]\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        2.015 s, estimated 3 s\r\nRan all test suites.\r\n```\r\n\r\n### Additional context\r\n\r\nre-raising #13858 because it was closed and locked by the stale bot without a solution.\r\n\r\n(please consider removing the stale bot, as it constantly closes valid issues that have not been resolved. just because nobody has commented on an issue in 30 days doesn't mean it's no longer an issue)\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 21.6.1 - C:\\Program Files\\nodejs\\node.EXE     \r\n    npm: 10.3.0 - C:\\Program Files\\nodejs\\npm.CMD       \r\n    pnpm: 7.27.0 - ~\\AppData\\Local\\pnpm\\pnpm.EXE        \r\n  npmPackages:\r\n    jest: ^29.6.1 => 29.6.1\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","not stale"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Error in importing from the entities folder when installing jest-environment-jsdom","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n* git clone git@github.com:alles\/jest-environment-jsdom-bug.git\r\n* yarn\r\n* yarn test\r\n\r\n### Expected behavior\r\n\r\nThis error does not appear\r\n\r\n### Actual behavior\r\n\r\nCannot find module 'entities\/someModule' from 'src\/someTest.test.ts'\r\n\r\n### Additional context\r\n\r\nWhen tests import something from the \"entities\" folder, the error message `Cannot find module 'entities\/SomeModule' from 'src\/someTest.test.ts'` appears. This happens after installing the \"jest-environment-jsdom\" package. Without installing this package, imports work fine.\r\n\r\nWork when I remove **jest-environment-jsdom**.\r\n* yarn\r\n* yarn remove jest-environment-jsdom\r\n* yarn test\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 5.18 Alpine Linux\r\n    CPU: (32) x64 AMD Ryzen Threadripper 3960X 24-Core Processor\r\n    Docker image: node:20.11-alpine\r\n  Binaries:\r\n    Node: 20.11.0 - \/usr\/local\/bin\/node\r\n    Yarn: 4.0.2 - \/usr\/local\/bin\/yarn\r\n    npm: 10.4.0 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: jest unit test fail when import antd\/es","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nWhen i test antd components, The test suite was failed:\r\n Details:\r\n\r\n    C:\\Users\\F Y Q\\Desktop\\\u9879\u76ee\\focus-pro\\node_modules\\.pnpm\\@ant-design+pro-form@2.23.1_antd@5.12.8_rc-field-form@1.41.0_react-dom@18.2.0_react@18.2.0\\node_modules\\@ant-design\\pro-form\\es\\BaseForm\\EditOrReadOnlyContext.js:1\r\n    ({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest){import React from 'react';\r\n\r\n             ^^^^^^\r\n\r\n    SyntaxError: Cannot use import statement outside a module\r\n\r\n       7 |   ProSchemaValueEnumObj,\r\n       8 | } from '@ant-design\/pro-components';\r\n    >  9 | import { EditOrReadOnlyContext } from '@ant-design\/pro-form\/es\/BaseForm\/EditOrReadOnlyContext';\n\n### Expected behavior\n\nantd\/es can be transform\n\n### Actual behavior\n\n C:\\Users\\F Y Q\\Desktop\\\u9879\u76ee\\focus-pro\\node_modules\\.pnpm\\@ant-design+pro-form@2.23.1_antd@5.12.8_rc-field-form@1.41.0_react-dom@18.2.0_react@18.2.0\\node_modules\\@ant-design\\pro-form\\es\\BaseForm\\EditOrReadOnlyContext.js:1\r\n    ({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest){import React from 'react';\r\n                                                                                      ^^^^^^\r\n\r\n    SyntaxError: Cannot use import statement outside a module\r\n\r\n       7 |   ProSchemaValueEnumObj,\r\n       8 | } from '@ant-design\/pro-components';\r\n    >  9 | import { EditOrReadOnlyContext } from '@ant-design\/pro-form\/es\/BaseForm\/EditOrReadOnlyContext';\r\n         | ^\r\n      10 | import { ProFormFieldItemProps } from '@ant-design\/pro-form\/es\/typing';\r\n      11 | import { Select } from 'antd';\r\n      12 | import { FC, useContext } from 'react';\r\n\r\n      at Runtime.createScriptFromCode (node_modules\/.pnpm\/jest-runtime@29.7.0\/node_modules\/jest-runtime\/build\/index.js:1505:14)\r\n      at Object.<anonymous> (src\/ValueType\/badges\/FormField\/index.tsx:9:1)\r\n      at Object.<anonymous> (src\/ValueType\/badges\/index.tsx:3:1)\r\n      at Object.<anonymous> (src\/ValueType\/index.ts:2:1)\r\n      at Object.<anonymous> (src\/ProConfigProvider\/index.tsx:7:1)\r\n      at Object.<anonymous> (src\/index.ts:5:1)\r\n      at Object.<anonymous> (tests\/ProConfigProvider\/index.test.tsx:2:1)\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\n\/\/ package.json\r\n{\r\n  \"name\": \"focus-pro\",\r\n  \"version\": \"0.1.0\",\r\n  \"description\": \"A react library developed with dumi\",\r\n  \"license\": \"MIT\",\r\n  \"module\": \"dist\/index.js\",\r\n  \"types\": \"dist\/index.d.ts\",\r\n  \"files\": [\r\n    \"dist\"\r\n  ],\r\n  \"scripts\": {\r\n    \"build\": \"father build\",\r\n    \"build:watch\": \"father dev\",\r\n    \"dev\": \"dumi dev\",\r\n    \"docs:build\": \"dumi build\",\r\n    \"doctor\": \"father doctor\",\r\n    \"lint\": \"npm run lint:es && npm run lint:css\",\r\n    \"lint:css\": \"stylelint \\\"{src,test}\/**\/*.{css,less}\\\"\",\r\n    \"lint:es\": \"eslint \\\"{src,test}\/**\/*.{js,jsx,ts,tsx}\\\"\",\r\n    \"prepare\": \"husky install && dumi setup\",\r\n    \"prepublishOnly\": \"father doctor && npm run build\",\r\n    \"start\": \"npm run dev\",\r\n    \"test\": \"jest\"\r\n  },\r\n  \"commitlint\": {\r\n    \"extends\": [\r\n      \"@commitlint\/config-conventional\"\r\n    ]\r\n  },\r\n  \"lint-staged\": {\r\n    \"*.{md,json}\": [\r\n      \"prettier --write --no-error-on-unmatched-pattern\"\r\n    ],\r\n    \"*.{css,less}\": [\r\n      \"stylelint --fix\",\r\n      \"prettier --write\"\r\n    ],\r\n    \"*.{js,jsx}\": [\r\n      \"eslint --fix\",\r\n      \"prettier --write\"\r\n    ],\r\n    \"*.{ts,tsx}\": [\r\n      \"eslint --fix\",\r\n      \"prettier --parser=typescript --write\"\r\n    ]\r\n  },\r\n  \"dependencies\": {\r\n    \"@ant-design\/icons\": \"^5.2.6\",\r\n    \"@ant-design\/pro-components\": \"^2.6.43\",\r\n    \"@ant-design\/pro-form\": \"^2.23.1\",\r\n    \"@ant-design\/pro-provider\": \"^2.13.5\",\r\n    \"@ant-design\/pro-utils\": \"^2.15.4\",\r\n    \"antd\": \"^5.12.8\",\r\n    \"antd-token-previewer\": \"^2.0.5\",\r\n    \"dayjs\": \"^1.11.10\",\r\n    \"history\": \"^5.3.0\",\r\n    \"lodash\": \"^4.17.21\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel\/core\": \"^7.23.7\",\r\n    \"@babel\/plugin-transform-modules-commonjs\": \"^7.23.3\",\r\n    \"@babel\/preset-env\": \"^7.23.8\",\r\n    \"@babel\/preset-typescript\": \"^7.23.3\",\r\n    \"@commitlint\/cli\": \"^17.1.2\",\r\n    \"@commitlint\/config-conventional\": \"^17.1.0\",\r\n    \"@testing-library\/react\": \"^14.1.2\",\r\n    \"@types\/enzyme\": \"^3.10.18\",\r\n    \"@types\/enzyme-adapter-react-16\": \"^1.0.9\",\r\n    \"@types\/jest\": \"^29.5.11\",\r\n    \"@types\/lodash\": \"^4.14.202\",\r\n    \"@types\/node\": \"^20.11.2\",\r\n    \"@types\/react\": \"^18.0.0\",\r\n    \"@types\/react-dom\": \"^18.0.0\",\r\n    \"@types\/react-router-dom\": \"^5.3.3\",\r\n    \"@umijs\/lint\": \"^4.0.0\",\r\n    \"axios\": \"^1.6.5\",\r\n    \"babel-jest\": \"^29.7.0\",\r\n    \"dumi\": \"^2.2.13\",\r\n    \"enzyme\": \"^3.11.0\",\r\n    \"enzyme-adapter-react-16\": \"^1.15.7\",\r\n    \"eslint\": \"^8.23.0\",\r\n    \"father\": \"^4.1.0\",\r\n    \"focus-pro\": \"^0.1.0\",\r\n    \"husky\": \"^8.0.1\",\r\n    \"jest\": \"^29.7.0\",\r\n    \"jest-environment-jsdom\": \"^29.7.0\",\r\n    \"jest-less-loader\": \"^0.2.0\",\r\n    \"lint-staged\": \"^13.0.3\",\r\n    \"prettier\": \"^2.7.1\",\r\n    \"prettier-plugin-organize-imports\": \"^3.0.0\",\r\n    \"prettier-plugin-packagejson\": \"^2.2.18\",\r\n    \"react\": \"^18.0.0\",\r\n    \"react-dom\": \"^18.0.0\",\r\n    \"stylelint\": \"^14.9.1\",\r\n    \"ts-jest\": \"^29.1.1\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"react\": \">=16.9.0\",\r\n    \"react-dom\": \">=16.9.0\",\r\n    \"react-router-dom\": \">=5.0.0\"\r\n  },\r\n  \"publishConfig\": {\r\n    \"access\": \"public\"\r\n  },\r\n  \"authors\": []\r\n}\r\n\/\/jest.config.ts\r\nmodule.exports = {\r\n  roots: ['<rootDir>\/tests'],\r\n  testRegex: 'tests\/(.+)\\\\.test\\\\.(jsx?|tsx?)$',\r\n  transform: {\r\n    '^.+\\\\.(ts|tsx|js|jsx)?$': 'ts-jest',\r\n    '.(less|css)$': 'jest-less-loader',\r\n  },\r\n  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],\r\n  modulePathIgnorePatterns: ['\/node_modules\/', '\/dist\/'],\r\n  testEnvironment: 'jsdom',\r\n  moduleNameMapper: {\r\n    'focus-pro\/(.*)': '<rootDir>\/src\/index.ts',\r\n  },\r\n  transformIgnorePatterns: ['<rootDir>\/node_modules\/'],\r\n};\r\n\/\/babel.config.js\r\nmodule.exports = {\r\n  presets: [\r\n    ['@babel\/preset-env', { targets: { node: true } }],\r\n    '@babel\/preset-typescript',\r\n  ],\r\n  env: {\r\n    test: {\r\n      plugins: ['@babel\/plugin-transform-modules-commonjs'],\r\n    },\r\n  },\r\n};\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","+1 same issue ","It seems you run jest code in esm environment, but currently jest doesn't support this automatically, more info you can check the [doc](https:\/\/jestjs.io\/docs\/ecmascript-modules)."],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: projects config item doesn't allow specified project to mocking outside of defined rootDir except in a jest.setup.ts file","body":"### Version\n\n29.2.1\n\n### Steps to reproduce\n\n[This sample repo (mock-issue branch)](https:\/\/github.com\/lgibso34\/wallaby-react-native\/blob\/mock-issue\/jest.config.ts#L13) is setup with the projects config key.\r\n\r\n\r\n[This mock](https:\/\/github.com\/lgibso34\/wallaby-react-native\/blob\/mock-issue\/src\/features\/Menu\/__tests__\/Menu.test.tsx#L6) does not actually mock (see console.log just below it). I think it is because `Menu` is a sub-project in Jest with a `rootDir` of `src\/features\/Menu` and when you do this, you can no longer mock outside of that `rootDir`.\r\n\r\nHowever, the [setupFilesAfterEnv ](https:\/\/github.com\/lgibso34\/wallaby-react-native\/blob\/mock-issue\/jest.config.ts#L35) is defined to run a `jest.setup.ts` file and you **can** mock files outside of the `rootDir` there. I would say this is more of a \"workaround\" than a proper solution to this issue. You can see this in action by uncommenting [this line](https:\/\/github.com\/lgibso34\/wallaby-react-native\/blob\/mock-issue\/src\/features\/Menu\/jest.setup.ts#L3) and the `console.log` mentioned above will print `true`.\r\n\r\nI think the `jest.mock()` should work fine if defined in a test file.\r\n\r\nI'm hoping this is maybe solvable by adding an extra config that contains paths to files outside the `rootDir`. \ud83e\udd1e \r\n\r\nThanks for reading.\r\n\n\n### Expected behavior\n\nI expect `jest.mock()` to work for modules outside of the `rootDir` inside of a test file when using the `projects` config key.\n\n### Actual behavior\n\n`jest.mock()` does not work for modules outside of the `rootDir` inside of a test file when using the `projects` config key. I have to use a `jest.setup.ts` file loaded in `setupFilesAfterEnv`\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz\r\n  Binaries:\r\n    Node: 18.15.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.19 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 9.6.7 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^29.2.1 => 29.6.2\n```\n","comments":["it will pass if I don't use the reassign `rootDir` in a subproject it works","I guess the answer is the `roots` config property. But it is a bit annoying that you have to add the root of your project along side the new `rootDir` like `roots: ['<rootDir>, '<rootDir\/..\/..\/..\/']`\r\n\r\nhttps:\/\/jestjs.io\/docs\/configuration\/#roots-arraystring","eh that didn't work. I still had to use `test` match so it would only run tests in the feature folder but that brought it back to the original issue where you cant mock outside of the rootDir","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Comment to keep alive"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: importing inside unstable_mockModule results in infinite loop","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nThis is a request to re-open https:\/\/github.com\/jestjs\/jest\/issues\/13851\r\n\r\nOn the original issue, the **github-actions** bot [said](https:\/\/github.com\/jestjs\/jest\/issues\/13851#issuecomment-1494542064):\r\n\r\n> This issue was closed because it has been stalled for 30 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.\n\n### Expected behavior\n\nPlease see original issue linked above\n\n### Actual behavior\n\nPlease see original issue linked above\n\n### Additional context\n\nPlease see original issue linked above\n\n### Environment\n\n```shell\nPlease see original issue linked above\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: `jest.unstable_mockModule` does not work with custom dynamic import wrapper","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nhttps:\/\/github.com\/conventional-changelog\/commitlint\/pull\/3850\r\n\r\nyarn test-ci\n\n### Expected behavior\n\nNo error\n\n### Actual behavior\n\n```log\r\n RUNS  @commitlint\/load\/src\/utils\/load-plugin.test.ts\r\n\/Users\/JounQin\/Workspaces\/GitHub\/commitlint\/@commitlint\/load\/src\/utils\/load-plugin.ts:35\r\n                throw new MissingPluginError(pluginName, message, {\r\n                      ^\r\n\r\nMissingPluginError: Failed to load plugin example: Cannot find module 'commitlint-plugin-example' from '@commitlint\/load\/src\/utils\/load-plugin.ts'\r\n    at loadPlugin (\/Users\/JounQin\/Workspaces\/GitHub\/commitlint\/@commitlint\/load\/src\/utils\/load-plugin.ts:35:23) {\r\n  ['__proto__']: [Function: Error] {\r\n    stackTraceLimit: 100,\r\n    prepareStackTrace: [Function: prepareStackTrace]\r\n  },\r\n  messageTemplate: 'plugin-missing',\r\n  messageData: {\r\n    pluginName: 'commitlint-plugin-example',\r\n    commitlintPath: '\/Users\/JounQin\/Workspaces\/GitHub\/commitlint\/@commitlint\/load'\r\n  }\r\n}\r\n```\n\n### Additional context\n\nI've also tried 30.0.0-alpha.2 locally but still failed.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 18.19.0 - ~\/Library\/Caches\/fnm_multishells\/43242_1705330700273\/bin\/node\r\n    Yarn: 1.22.19 - ~\/Library\/Caches\/fnm_multishells\/43242_1705330700273\/bin\/yarn\r\n    npm: 10.2.3 - ~\/Library\/Caches\/fnm_multishells\/43242_1705330700273\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["Related codes:\r\n\r\n```ts\r\nconst dynamicImport = async <T,>(id: string): Promise<T> => {\r\n  const imported = await import(\r\n    path.isAbsolute(id) ? pathToFileURL(id).toString() : id\r\n  );\r\n  return (\"default\" in imported && imported.default) || imported;\r\n};\r\n\r\ntry {\r\n  plugin = await dynamicImport<Plugin>(longName);\r\n} catch (pluginLoadErr) {}\r\n```","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","ping","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Can you put together a minimal reproduction? "],"labels":["Needs Triage","Bug Report","ES Modules","Pinned"]},{"title":"[Bug]: Unable to import external module with webpackIgnore","body":"### Version\r\n\r\n29.7\r\n\r\n### Steps to reproduce\r\n\r\nIn my code I have:\r\n`import(\/* webpackIgnore: true *\/ js_module)`\r\n\r\n### Expected behavior\r\n\r\nImport the module how a browser would import the module, based on the presence of the webpackIgnore comment. i.e. Making a network request to the provided URL.\r\n\r\n### Actual behavior\r\n\r\nIt attempts to import a local module:\r\n`Cannot find module 'http:\/\/localhost:8080\/admin\/js' from 'src\/App.js'`","comments":["Maybe this relates to #9430, but I'm not clear exactly how much it overlaps.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","> This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: jest attempts to access property 'arguments' of a jest.fn() in strict mode, resulting in error","body":"### Version\n\n^29.7.0\n\n### Steps to reproduce\n\nreproducible by creating a test with\r\n```typescript\r\n\tit('should not error', () => {\r\n\t\texpect([Object.create(jest.fn())]).toEqual([]);\r\n\t});\r\n```\n\n### Expected behavior\n\nTo work normally.\r\n\r\nIt works normally with `.toEqual([{}])` which makes the error very weird and arbitrary.\r\n\n\n### Actual behavior\n\nthrows error:\r\n```\r\n'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\r\nTypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\r\n```\n\n### Additional context\n\nFor what I could tell, somewhere in jest's code it goes collecting property keys up the prototype chain, it then attempts to access property `arguments` which is not allowed by javascript.\r\nPerhaps put a guard for that property?\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 11 10.0.22631\r\n    CPU: (12) x64 12th Gen Intel(R) Core(TM) i7-1255U\r\n  Binaries:\r\n    Node: 20.5.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 9.8.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n    pnpm: 8.12.1 - C:\\ProgramData\\chocolatey\\bin\\pnpm.EXE\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I'm getting something similar but with\r\n`expect(result).toEqual([])` throwing the same error, where `result` is a Sequelize model query e.g. `SomeModel.findAll()`\r\n\r\nError is:\r\n> TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\r\n\r\nUpdate:\r\n`expect(result).toContain([])` fails correctly.\r\ni.e. it returns\r\n```\r\nexpect(received).toContain(expected) \/\/ indexOf\r\n\r\n    Expected value: []\r\n    Received array: [{\"createdAt\": 2024-02-22T21:01:43.000Z, ... \"updatedAt\": 2024-02-22T21:01:43.000Z}]\r\n```","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: Error converting circular structure to JSON","body":"### Version\r\n\r\nv29.7.0, v30.0.0-alpha.2\r\n\r\n### Steps to reproduce\r\n\r\n1. Create a test file with the below test.\r\n2. `npx jest --workerIdleMemoryLimit=1GB path\/to\/the.test.js` (note: `--workerIdleMemoryLimit` is just to force Jest to use workers, which you could also trigger by running many tests, `--watch`, etc.)\r\n3. test suite crashes with only a circular reference error\r\n\r\nTest:\r\n```js\r\nit(\"tmp\", () => {\r\n\tconst e = new Error(\"yikes\")\r\n\te.e = e\r\n\tthrow e\r\n})\r\n```\r\n\r\n### Expected behavior\r\n\r\nI expect to see an error in my code! Which of course happens if you remove `e.e = e`.\r\n\r\nNote that this works fine without workers, and in some cases it works fine even with them (I haven't figured out why.) It seems that in some code paths Jest effectively destructures the error, getting only the fields it will use (i.e. not `e`) and then passing those over to the parent process, but in others it serializes the whole error, which fails.\r\n\r\n### Actual behavior\r\n\r\nThe error is as follows:\r\n```\r\n FAIL  .\/tmp.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    TypeError: Converting circular structure to JSON\r\n        --> starting at object with constructor 'Error'\r\n        --- property 'e' closes the circle\r\n        at stringify (<anonymous>)\r\n\r\n      at messageParent (..\/..\/.npm\/_npx\/fff1c0483a6bf0c3\/node_modules\/jest-worker\/build\/index.js:1572:19)\r\n```\r\n\r\nThis gives very little information about what actually went wrong. (\r\n\r\n### Additional context\r\n\r\nOf course in a simple repro the answer is simply \"don't do that\". But in the real cases I started from, I believe the error was likely thrown from third-party code, in an integration test in a large codebase so it's very hard to know. The circular structure in question was a `ClientRequest`, which could be used in many places. So having no stacktrace from Jest makes it very hard to track down.\r\n\r\nFor now I've hacked around it with the following patch:\r\n```diff\r\ndiff --git a\/node_modules\/jest-worker\/build\/workers\/messageParent.js b\/node_modules\/jest-worker\/build\/workers\/messageParent.js\r\nindex 62e2cce..0083989 100644\r\n--- a\/node_modules\/jest-worker\/build\/workers\/messageParent.js\r\n+++ b\/node_modules\/jest-worker\/build\/workers\/messageParent.js\r\n@@ -26,7 +26,28 @@ function messageParent(message, parentProcess = process) {\r\n       message\r\n     ]);\r\n   } else if (typeof parentProcess.send === 'function') {\r\n-    parentProcess.send([_types.PARENT_MESSAGE_CUSTOM, message]);\r\n+    try {\r\n+      parentProcess.send([_types.PARENT_MESSAGE_CUSTOM, message]);\r\n+    } catch (e) {\r\n+      if (!e.message.includes(\"circular structure to JSON\")) {\r\n+        throw e\r\n+      }\r\n+      \/\/ These errors are super annoying to debug; remove some information from\r\n+      \/\/ the error to try to get it through to the parent process.\r\n+      const { failureDetails } = message[1][1]\r\n+      failureDetails.forEach((err, i) => {\r\n+        \/\/ Keep the error message+stack, but drop other fields.\r\n+        failureDetails[i] = new Error(e.message + \"\\nOriginal error was: \" + err.message)\r\n+        if (err.stack) {\r\n+          failureDetails[i].stack = err.stack\r\n+        }\r\n+      })\r\n+      try {\r\n+        parentProcess.send([_types.PARENT_MESSAGE_CUSTOM, message]);\r\n+      } catch (e2) {\r\n+        throw e\r\n+      }\r\n+    }\r\n   } else {\r\n     throw new Error('\"messageParent\" can only be used inside a worker');\r\n   }\r\ndiff --git a\/node_modules\/jest-worker\/build\/workers\/processChild.js b\/node_modules\/jest-worker\/build\/workers\/processChild.js\r\nindex 1a47f23..0100599 100644\r\n--- a\/node_modules\/jest-worker\/build\/workers\/processChild.js\r\n+++ b\/node_modules\/jest-worker\/build\/workers\/processChild.js\r\n@@ -79,7 +79,30 @@ function reportSuccess(result) {\r\n   if (!process || !process.send) {\r\n     throw new Error('Child can only be used on a forked process');\r\n   }\r\n-  process.send([_types.PARENT_MESSAGE_OK, result]);\r\n+  try {\r\n+    process.send([_types.PARENT_MESSAGE_OK, result]);\r\n+  } catch (e) {\r\n+    if (!e.message.includes(\"circular structure to JSON\")) {\r\n+      throw e\r\n+    }\r\n+    result.testResults.forEach(testResult => {\r\n+      \/\/ These errors are super annoying to debug; remove some information from\r\n+      \/\/ the error to try to get it through to the parent process.\r\n+      const { failureDetails } = testResult\r\n+      failureDetails.forEach((err, i) => {\r\n+        \/\/ Keep the error message+stack, but drop other fields.\r\n+        failureDetails[i] = new Error(e.message + \"\\nOriginal error was: \" + err.message)\r\n+        if (err.stack) {\r\n+          failureDetails[i].stack = err.stack\r\n+        }\r\n+      })\r\n+    })\r\n+    try {\r\n+      process.send([_types.PARENT_MESSAGE_OK, result]);\r\n+    } catch (e2) {\r\n+      throw e\r\n+    }\r\n+  }\r\n }\r\n function reportClientError(error) {\r\n   return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\r\n```\r\n\r\nProbably the more robust approach is something more like what `reportError` does, but this was easier to hack in.\r\n\r\nSee also specific cases that may be the same\/similar issues: #11958, #10577 \r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 14.2.1\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 18.17.0 - \/nix\/store\/3pmw2p5lhkl6g572n1gc2la32x97815c-nodejs-18.17.0\/bin\/node\r\n    npm: 9.6.7 - ~\/.local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","We see the same issue. Would be awesome if we could get a bug fix for this.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still relevant. not sure if\/when I will have time to productionize this, so would encourage others who are affected to take a stab if you can!"],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: Show progress of tests as they run","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nEven with verbose enabled, Jest doesn't give any indication of progress through tests within a file while they are being run.\r\n\r\n### Motivation\r\n\r\nIf it's taking a long time for tests to complete, I have no indication how far through the tests it is, whether it's hanging on a particular test or just slowly progressing through tests.\r\n\r\n### Example\r\n\r\nFor comparison, pytest (the most popular test runner on Python projects) displays the result of each test as it runs, looking something like:\r\n```\r\ntests\/test_admin.py::test_path PASSED                                    [  1%]\r\ntests\/test_admin.py::test_js_module PASSED                               [  2%]\r\ntests\/test_admin.py::test_no_js_module PASSED                            [  3%]\r\n```","comments":["Hi @Dreamsorcerer \r\nWhat do you think about adding the percentage at the end of the test suite?\r\nSee the example below\r\n\r\n<img width=\"265\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/22686401\/fe970977-23d9-425b-a93e-a8f9a4634fd1\">\r\n","Anything that shows some progress while it's running would be an improvement. Displaying the results of each test as they complete though, can be more helpful, as you can figure out what test the runner is stuck on (particularly useful in weird edge cases where the runner itself ends up hanging and never completing).","I see that it is better to add it at the end of the Test suite, as placing it next to each test can get confusing when several tests occur in parallel and so this percentage shows the percentage of all tests","I think the request was for progress within a single test file, not the total (which we already have, albeit not as a percentage).\r\n\r\nSo I think it should be next to a `RUNS` (and nothing for completed ones) rather than in the summary. Probably behind some sort of option? This feels more line a continuation of #6616 with more precise data rather than doing math on the data we already display ","I misunderstood the original question. The percentage is really not important, you can do whatever you want to do with it (pytest does show the global percentage after each test, but is also, most often, run in a synchronous manner). The main point is that I should be able to see some output after each test, and can figure out which test the runner is stuck on if it were to freeze\/crash.","What if we were to add the 'X passed' field next to the path description indicating how many test were completed?\r\nIs this approach useful  @Dreamsorcerer @SimenB?\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/22686401\/c2fa878d-36d6-406a-827b-41e563a87970)\r\n","Yeah, that looks good to me! Maybe out of a total per test file as well? I think we have this information available","If you mean that the number is updated as each test passes (as opposed to a total shown at the end of the file run), then that's probably good enough.","@SimenB \r\nShould we exclude the percentage at the conclusion of the test suite?\r\n\r\nIt would be beneficial to display a percentage out of the total for each test file too but I couldn't locate any property that provides this value before or during the execution of the file.","@SimenB @Dreamsorcerer \r\nI found a way to display the total number of pending tests. To achieve this, I had to search within the Jasmine and JestAdapter classes. Below is the screenshot showing the outcome, and here is the commit for the changes in 230b11b29d7739a11d607f7efd2f4e5e511b2b26.\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/22686401\/00c2360e-aec0-4d04-b6da-067455425188)\r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","> This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\n"],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: @jest\/globals pollutes global namespace with node types","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone my repo at https:\/\/github.com\/jfirebaugh\/jest-globals-bug\r\n2. Run `npm i && npm run check`\r\n\r\n### Expected behavior\r\n\r\nShould typecheck successfully.\r\n\r\n### Actual behavior\r\n\r\n```\r\n> jest-globals@1.0.0 check\r\n> tsc\r\n\r\nbrowser.test.ts:4:11 - error TS2322: Type 'Timeout' is not assignable to type 'number'.\r\n\r\n4     const timeout: number = setTimeout(() => {}, 0);\r\n            ~~~~~~~\r\n\r\n\r\nFound 1 error in browser.test.ts:4\r\n```\r\n\r\n### Additional context\r\n\r\nThis issue precludes the use of `@jest\/globals` in any project that wants to test browser libraries written in TypeScript, or any other environment where node global types would conflict with other global types (typically DOM types). It most often surfaces as a type error in code that assigns the result of `setTimeout` to a `number`-typed variable, which will fail if the node global types (from the `@types\/node` package) have been added to the environment.  In DOM type definitions `setTimeout` returns `number` but in node type definitions it returns `NodeJS.Timeout`. Other conflicts exist, e.g. `setInterval` has a similar issue.\r\n\r\nVia the output of `npm run check -- --traceResolution | grep -C10 @types\/node\/`, you can locate the sources of global type pollution via `@jest\/globals`:\r\n\r\n* `@jest\/environment\/build\/index.d.ts` has `\/\/\/ <reference types=\"node\" \/>`\r\n* `@jest\/types\/build\/index.d.ts` has `\/\/\/ <reference types=\"node\" \/>`\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 13.6.3\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 18.17.1 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.19 - \/usr\/local\/bin\/yarn\r\n    npm: 9.6.7 - \/usr\/local\/bin\/npm\r\n    pnpm: 7.33.6 - \/usr\/local\/bin\/pnpm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["See https:\/\/github.com\/jestjs\/jest\/issues\/14418 for a similar recent bug. The same reasoning in https:\/\/github.com\/jestjs\/jest\/issues\/14418#issuecomment-1679888967 applies here.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale."],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: `findRepos` works slowly with a large number of `projects`","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone the [demo repo](https:\/\/github.com\/voronin-ivan\/jest-find-repos-issue)\r\n2. `nvm use 20.10.0`\r\n3. `npm ci`\r\n4. `npm test packages\/package-1\/example.test.js -- --watch`\r\n\r\nYou can reproduce this issue on any Node.js version starting at 18.13.0 by having a large number of `projects`.\r\n\r\n### Expected behavior\r\n\r\n--watch mode doesn't consume large amounts of resources and works fast.\r\n\r\n### Actual behavior\r\n\r\n--watch mode is resource-intensive, works slowly and slows down the whole system.\r\n<img width=\"592\" alt=\"Screenshot 2023-12-30 at 11 09 49\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/13902831\/8b62da9d-531b-4a81-a111-49701d040c7f\">\r\n\r\n\r\n### Additional context\r\n\r\n### Why it's slow\r\n[findRepos](https:\/\/github.com\/jestjs\/jest\/blob\/9ced68502ab237aedac962a1fb8f895b9d59d607\/packages\/jest-changed-files\/src\/index.ts#L59) is sluggish because of running a ton of `childProcess.spawn` under the hood (three processes per each project). It worked fast enough until Node.js version [18.13.0](https:\/\/github.com\/nodejs\/node\/blob\/main\/doc\/changelogs\/CHANGELOG_V18.md#18.13.0) was released, and this issue still persists even in the latest Node version (21.5.0).\r\n\r\n### Performance footprint for 30s\r\n`node --inspect-brk .\/node_modules\/.bin\/jest packages\/package-1\/example.test.js --watch`\r\n\r\nNode.js 18.12.1\r\n<img width=\"1512\" alt=\"Screenshot 2023-12-30 at 11 35 58\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/13902831\/8568db58-b5db-405f-91d5-af2b32b7a043\">\r\n\r\nNode.js 18.13.0 (and any later ones)\r\n<img width=\"1512\" alt=\"Screenshot 2023-12-30 at 11 37 56\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/13902831\/ca011dbd-72fb-4e57-bbf6-3c1a8e44eaf5\">\r\n\r\n### Possible ways to solve it\r\n1. Update `execa`, the current version that you use (5.0.0) is quite outdated, the latest is 8.0.1, there were some optimisation tweaks\r\n2. Don't get repos for all projects if there is only one repo: in my monorepos there is always only one git repo, so findRepos works for nothing 99% of the time. This can be solved by introducing not required jest config fields like `onlyOneRepo: boolean` or `repo: string`\r\n3. ...\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 14.1.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\nBinaries:\r\n    Node: 20.10.0 - ~\/.nvm\/versions\/node\/v20.10.0\/bin\/node\r\n    Yarn: 1.22.17 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.3 - ~\/.nvm\/versions\/node\/v20.10.0\/bin\/npm\r\n    pnpm: 8.6.2 - \/opt\/homebrew\/bin\/pnpm\r\nnpmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["Interesting! Do we know why it regressed so much in 18.13?\r\n\r\nAs for mitigations, easiest is probably just to avoid shelling out at all. Maybe walking the file system looking for `.git`? And whatever the equivalent is for Mercurial and Sapling",">Do we know why it regressed so much in 18.13?\r\n\r\nI'm not sure, at first sight, only https:\/\/github.com\/nodejs\/node\/commit\/7b68c06988 is related to `child_process` in that release.\r\n\r\n>easiest is probably just to avoid shelling out at all\r\n\r\nYes, that could be an option! \r\n\r\nIn my project, to mitigate this issue quickly knowing there is only one repo, I've made changes via [patch-package](https:\/\/github.com\/ds300\/patch-package) \ud83d\ude04 \r\n<img width=\"533\" alt=\"Screenshot 2024-01-02 at 09 40 45\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/13902831\/700a1fe7-a380-44f6-aca2-3b4a87366103\">\r\n","FWIW, #14826 helps a bit _before_ the `findRepos` calls.\r\n\r\nI found https:\/\/github.com\/antongolub\/git-root - I wonder if we should use that? I'd assume just fixing `git` is enough as that's most used \ud83d\ude05 ",">I found https:\/\/github.com\/antongolub\/git-root - I wonder if we should use that? I'd assume just fixing git is enough as that's most used \ud83d\ude05\r\n\r\nUsing git-root sounds good to me, but I'm not following how changing only `findGitRoot` solves the issue, `findHgRoot` and `findSlRoot` are still expensive and always run. So it looks like we need to tackle them all or find a way to say to Jest that project(s) contain only git repo(s)","bah, of course... Mixing VCS-es sounds horrible, but I bet we'd break _somebody_ if we looked for only looked for Mercurial and Sapling if we didn't find git roots.\r\n\r\nI see that we find the VSC roots for every test run. I bet we could at least resolve those when normalizing config instead, so at least we'd only get the hit at the start of runs rather than every re-run.\r\n\r\n---\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/pull\/14826 should help a bit, btw",">https:\/\/github.com\/jestjs\/jest\/pull\/14826 should help a bit, btw\r\n\r\nThank you, but I don't see much difference tbh because the most expensive operation is `getRoute`, tried on commit [e334898](https:\/\/github.com\/jestjs\/jest\/commit\/e334898abae1880eed88a9435ca59d072b838626) that contains your changes.\r\n`node --inspect-brk ..\/jest\/packages\/jest\/bin\/jest packages\/package-1\/example.test.js --watch`\r\n<img width=\"1512\" alt=\"Screenshot 2024-01-08 at 14 24 17\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/13902831\/ffb3d96c-1896-407b-a06b-2dddf64557d9\">\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"[Bug]: jest transform ignore patterns not working for msal react library","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nhttps:\/\/github.com\/AzureAD\/microsoft-authentication-library-for-js\r\n\r\n### Expected behavior\r\n\r\nI am trying to write test cases for my application, it has msal library authentication because of this i am not able to run test cases.\r\n\r\n### Actual behavior\r\n\r\n```\r\n\r\nerror Command failed with exit code 1.\r\ninfo Visit https:\/\/yarnpkg.com\/en\/docs\/cli\/run for documentation about this command.\r\naipl6759lt14310:typescript-sample sgorle$ yarn test\r\nyarn run v1.22.18\r\n$ jest\r\n FAIL   TypeScript  test\/App.test.tsx\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest encountered an unexpected token\r\n\r\n    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.\r\n\r\n    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.\r\n\r\n    By default \"node_modules\" folder is ignored by transformers.\r\n\r\n    Here's what you can do:\r\n     \u2022 If you are trying to use ECMAScript Modules, see https:\/\/jestjs.io\/docs\/ecmascript-modules for how to enable it.\r\n     \u2022 If you are trying to use TypeScript, see https:\/\/jestjs.io\/docs\/getting-started#using-typescript\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/configuration\r\n    For information about custom transformations, see:\r\n    https:\/\/jestjs.io\/docs\/code-transformation\r\n\r\n    Details:\r\n\r\n    \/Users\/sgorle\/Desktop\/typescript-sample\/node_modules\/@azure\/msal-react\/dist\/index.js:4\r\n    export { MsalConsumer, MsalContext } from '.\/MsalContext.js';\r\n    ^^^^^^\r\n\r\n    SyntaxError: Unexpected token 'export'\r\n\r\n      1 | import { render, screen } from '@testing-library\/react';\r\n      2 | import React from 'react';\r\n    > 3 | import { MsalProvider } from \"@azure\/msal-react\";\r\n        | ^\r\n      4 | import { msalInstance } from '..\/src\/index'\r\n      5 | import App from '..\/src\/App'\r\n      6 |\r\n\r\n      at Runtime.createScriptFromCode (node_modules\/jest-config\/node_modules\/jest-runtime\/build\/index.js:1505:14)\r\n      at Object.require (test\/App.test.tsx:3:1)\r\n```\r\n\r\njest.config.js\r\n```\r\nmodule.exports = {\r\n    displayName: \"TypeScript\",\r\n    collectCoverage: true,\r\n    collectCoverageFrom: [ 'src\/**\/*.{ts,tsx}' ],\r\n    coverageDirectory: 'coverage',\r\n    setupFilesAfterEnv: [ '<rootDir>\/jest.setup.js' ],\r\n    transformIgnorePatterns: [\r\n        \"<rootDir>\/node_modules\/(?!(@azure\/msal-react))\",\r\n    ],\r\n    testEnvironment: 'jsdom',\r\n\r\n};\r\n```\r\n\r\nApp.test.tsx\r\n```\r\nimport { render, screen } from '@testing-library\/react';\r\nimport React from 'react';\r\nimport { MsalProvider } from \"@azure\/msal-react\";\r\nimport { msalInstance } from '..\/src\/index'\r\nimport App from '..\/src\/App'\r\n\r\ndescribe('App tests', () => {\r\n\tit('should contains the heading 1', () => {\r\n\t\trender(\r\n\t\t\t<MsalProvider instance={msalInstance}>\r\n\t\t\t\t<App \/>\r\n\t\t\t<\/MsalProvider>\r\n\t\t);\r\n\t\tconst heading = screen.getByText(\/Hello world! I am using React\/i);\r\n\t\texpect(heading).toBeInTheDocument()\r\n\t});\r\n});\r\n```\r\n\r\njest.setup.ts\r\n`import '@testing-library\/jest-dom'`\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nMac Os ventura 13.4.1\r\n```\r\n","comments":["Try to change your  transformIgnorePatterns in jest.config.js to: `   transformIgnorePatterns: [\r\n        \"node_modules\/(?!@azure)\"\r\n    ]` . Hope this helps..","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","issue in msal https:\/\/github.com\/AzureAD\/microsoft-authentication-library-for-js\/issues\/6487"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Fails to report coverage of test files","body":"### Version\r\n\r\n29.7\r\n\r\n### Steps to reproduce\r\n\r\nI've added to the config:\r\n`collectCoverageFrom: [\"src\/**\", \"tests\/**\"],`\r\n\r\nBut, it doesn't report any coverage under the tests directory.\r\n\r\n### Expected behavior\r\n\r\nCoverage of test files to be included.\r\n\r\n### Actual behavior\r\n\r\nOnly covers the source files.\r\n\r\n### Additional context\r\n\r\nWe've been extending coverage reports to test files for all our projects over the past couple of years and it has highlighted several cases of tests not being run or similar such issues. Being able to check that tests have 100% coverage is very helpful to avoid these issues and make maintenance easier.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.",".","> This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","> This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: toMatchObject hangs with certain inputs","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. clone https:\/\/github.com\/drrnkin\/jest-toMatchObject\r\n2. yarn\r\n3. yarn test\r\n\r\nThe test hangs at this point in toMatchObject().\n\n### Expected behavior\n\nNo hang; objects should compare as equal.\n\n### Actual behavior\n\nJest hangs until the test eventually times out.\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (14) x64 Intel(R) Xeon(R) Gold 6338N CPU @ 2.20GHz\r\n  Binaries:\r\n    Node: 18.19.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.19 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 10.2.3 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["Note: I discovered this when upgrading from 27.0.4.  It worked fine then.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Commenting to remove stale label","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Ping to keep alive.  Will any human look at this ever?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Keep alive."],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: v8 coverage lowers when more tests are executed","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Clone https:\/\/github.com\/TWiStErRob\/repros\/tree\/main\/jest\/v8-flaky-coverage\r\n2. `npm install`\r\n3. `npm test -- --runInBand wrapped.test.js` -> tests pass, coverage 100%\r\n4. `npm test -- --runInBand` -> tests pass, coverage missing lines\n\n### Expected behavior\n\nEverything passes and coverage is better or equivalent to when only a single test is executed.\r\n\r\n<img width=\"600\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/2906988\/46acc55b-e63b-4d28-9d38-6af628012190\">\r\n\n\n### Actual behavior\n\nFile that is covered by a single test file to 100% loses coverage when an additional test is executed. The additional test calls the original function.\r\n\r\n<img width=\"593\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/2906988\/209d1b6d-489d-4ef9-b297-0cc929dd227b\">\r\n\n\n### Additional context\n\nAnything relevant changed in the repro will make it work correctly. So:\r\n * `v8` -> `babel` \u2705\r\n * changing the order of execution of tests (sorted.js `<` -> `>`) \u2705\r\n   We used a `testSequencer` to consistently reproduce the issue, otherwise it was flaky!\r\n * changing the order via removing `--runInBand` \u2705\r\n   We also used this to consistently reproduce the issue, otherwise it was flaky!\r\n\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 14.1.2\r\n    CPU: (12) arm64 Apple M2 Pro or (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 20.10.0 - \/opt\/homebrew\/opt\/node@20\/bin\/node\r\n    npm: 10.2.3 - \/opt\/homebrew\/opt\/node@20\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0 \r\n\r\nAlso on github actions ubuntu-latest (so Ubuntu 22.04 and x64).\n```\n","comments":["Hi\r\nThis seems to be the same problem as in my issue https:\/\/github.com\/jestjs\/jest\/issues\/14764\r\nHave you tested this with Node 20.9.0?\r\n","Yep, confirmed 20.9.0 -> 20.10.0 causes it.\r\n\r\nRaised https:\/\/github.com\/nodejs\/node\/issues\/51251","+1 also getting code coverage failure after updating to 20.10.0.","I found that comment following two lines in `node_modules\/collect-v8-coverage\/index.js` will fix it.\r\n```\r\n    \/\/await this.postSession('Profiler.stopPreciseCoverage');\r\n\r\n    \/\/await this.postSession('Profiler.disable');\r\n```\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/334577\/62bd0b36-424a-4f50-9148-f748c993dfad)\r\n","Verified that commenting out both lines fixes the issue.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue.","still an issue","> Yep, confirmed 20.9.0 -> 20.10.0 causes it.\r\n> \r\n> Raised [nodejs\/node#51251](https:\/\/github.com\/nodejs\/node\/issues\/51251)\r\n\r\nStill a issue and same problem with the upgrade","Seems it can be fixed with `await this.postSession('Debugger.enable');` \r\nsee https:\/\/github.com\/SimenB\/collect-v8-coverage\/pull\/235\/files\r\n"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]:  Declare ts-node as dependency of jest-config","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nWhen you have a new project with Jest set up as testing framework and you are using a typescript configuration files you get following error when launching jest tests:\r\n```\r\nError: Jest: Failed to parse the TypeScript config file C:\\Users\\nej\\source\\repos\\ddnp-gui\\jest.config.ts\r\n  Error: Jest: 'ts-node' is required for the TypeScript configuration files. Make sure it is installed\r\nError: Cannot find package 'ts-node' imported from C:\\Users\\nej\\source\\repos\\ddnp-gui\\node_modules\\jest-config\\build\\readConfigFileAndSetRootDir.js\r\n    at readConfigFileAndSetRootDir (C:\\Users\\nej\\source\\repos\\ddnp-gui\\node_modules\\jest-config\\build\\readConfigFileAndSetRootDir.js:116:13)\r\n    at async readInitialOptions (C:\\Users\\nej\\source\\repos\\ddnp-gui\\node_modules\\jest-config\\build\\index.js:403:13)\r\n    at async readConfig (C:\\Users\\nej\\source\\repos\\ddnp-gui\\node_modules\\jest-config\\build\\index.js:147:48)\r\n    at async readConfigs (C:\\Users\\nej\\source\\repos\\ddnp-gui\\node_modules\\jest-config\\build\\index.js:424:26)\r\n```\n\n### Expected behavior\n\nThrere should be no error as typescript configuration is supported according to docs. So expected behaviour is that `ts-node` should be declared as peerDependency of jest-config. Once `ts-node` is installed alll works as expected.\n\n### Actual behavior\n\nYou get error above when running jest tests using typescript configuration, because ts-node is not declared as dependency of jest-config (its only in devDependencies of jest-config).\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n  OS: Windows 10 10.0.19045\r\n  CPU: (12) x64 Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz\r\nBinaries:\r\n  Node: 20.10.0 - C:\\Program Files\\nodejs\\node.EXE\r\n  npm: 10.2.3 - C:\\Program Files\\nodejs\\npm.CMD\r\nnpmPackages:\r\n  jest: ^29.7.0 => 29.7.0\n```\n","comments":["Hey @yohny \r\nAs stated https:\/\/jestjs.io\/docs\/getting-started#using-typescript, you can either use babel or ts-node.\r\nNone of which is installed by default and it's up to you to define which way to go.\r\nAlso note (when using ts-node)\r\n> In order for Jest to transpile TypeScript with ts-jest, you may also need to create a [configuration](https:\/\/kulshekhar.github.io\/ts-jest\/docs\/getting-started\/installation#jest-config-file) file.\r\n\r\nShould work as expected.","yes, the docs mention 2 alternatives - babel and ts-jest (not ts-node), but for babel case it is only mentioned to install `@babel\/preset-typescript` and for ts-jest case its only mentioned to install `ts-jest`. Nothing about the need to install `ts-node`. Can than at least the docs be updated to reflect the reality?\r\nAlso when ts-node is required to be installed for ts-jest alternative to work, should it not be in its peerDependencies? Isn't that what peerDependencies are for? Or am I missing something?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","ping, to prevent stale bot from closing","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","ping, to prevent stale bot from closing"],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: show full error or object in promised `expect`","body":"### \ud83d\ude80 Feature Proposal\n\nWhen using `expect(promise).resolves` or `expect(promise).rejects`, and having the opposite resolution than expected, only the error message or the type of the value are being shown, hidding information. OTOH, if `await`ing the Promise object and fails, full exception with its trace is being shown. I think `expect(promise)` should show the full error with exception or the original value instead if receiving an unexpected resolution.\n\n### Motivation\n\nEasier debugging, being able to have the original error object with the additional Promise related info details provided by `expect(promise)`.\n\n### Example\n\n_No response_\n\n### Pitch\n\nCapture of failed Promises is already being done by Jest, I just only have the same behaviour when using `expect(promise)`. Since it's returning a Promise itself, probably would make sense to put the original failed one in the `cause` field of the exception.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","no stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","No stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","No stale."],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: JSDOM environment does not detect open handles","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nJest node environment detects open handles and bad things that happen after tests are done.\r\nThe tests below will fail:\r\n\r\n```TypeScript\r\ntest(\"error after tests are done\", () => {\r\n  setTimeout(() => {\r\n    throw new Error(\"after tests are done\");\r\n  }, 100);\r\n});\r\n\r\ntest(\"open handles\", () => {\r\n  setInterval(() => {}, 100);\r\n});\r\n\r\ntest(\"console usage after tests are done\", () => {\r\n  setTimeout(() => {\r\n    console.info(\"after tests are done\");\r\n  }, 100);\r\n});\r\n```\r\n\r\nUnfortunately, when using JSDOM environment, these tests do not fail.\r\n\r\n### Expected behavior\r\n\r\nAll Jest environments should detect open handles and bad things that happen after tests are done.\r\n\r\n### Actual behavior\r\n\r\nJest JSDOM environment does not detect open handles and bad things that happen after tests are done.\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nTried with Jest 29.7.0 and 30.0.0-alpha.2 + Node 20.10.0\r\n\r\nSystem:\r\n    OS: macOS 14.1.2\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 20.10.0 - \/opt\/homebrew\/opt\/node@20\/bin\/node\r\n    npm: 10.2.3 - \/opt\/homebrew\/opt\/node@20\/bin\/npm\r\n    pnpm: 8.11.0 - \/opt\/homebrew\/bin\/pnpm\r\n  npmPackages:\r\n    jest: 30.0.0-alpha.2 => 30.0.0-alpha.2\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I hate bots ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I hate bots","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"Added legacy documentation. Resolves #5371","body":"bug: resetAllMocks messes up runAllTimers when using useFakeTimers #5371\r\n\r\n<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: Nerdman4U \/ name: Joni T\u00f6yryl\u00e4  (69ac37de6ee205866b8c43b88e95e5982e080b8b)<\/li><\/ul>","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 69ac37de6ee205866b8c43b88e95e5982e080b8b |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/65701857c46b32000816e4b6 |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-14742--jestjs.netlify.app](https:\/\/deploy-preview-14742--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTE0NzQyLS1qZXN0anMubmV0bGlmeS5hcHAifQ.aONdHDC9VrL2b5Ohc0iyBFrS8WlwNTbdwueDRr8VwHM)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Stale"]},{"title":"[Bug]: `expect.toHaveBeenCalledWith` does not match when optional arguments are omitted","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Setup reproduction. [View Source](https:\/\/gist.githubusercontent.com\/Lordfirespeed\/88b36c600a141da48bab982be6564e3e)\r\n\r\n    ```bash\r\n    mkdir jest-toHaveBeenCalledWith-optional-argument-reproduction && \r\n    cd \"$_\" &&\r\n    npm install jest@29.7.0 &&\r\n    wget -O repro.test.js https:\/\/gist.githubusercontent.com\/Lordfirespeed\/88b36c600a141da48bab982be6564e3e\/raw\r\n    ```\r\n1. Run: \r\n\r\n    ```bash \r\n    npx jest repro.test.js\r\n    ```\r\n\r\n\r\n### Expected behavior\r\n\r\nThe test should pass. \r\n\r\n### Actual behavior\r\n\r\nThe test does not pass. \r\n\r\n### Additional context\r\n\r\nTesting `expect(magic).toHaveBeenCalledWith(expect.anything())` passes as expected. \r\n\r\n### Suggested Solution\r\n\r\nMatchers should use the optional parameters' default values when they are not supplied as arguments.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 6.5 Pop!_OS 22.04 LTS\r\n    CPU: (16) x64 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz\r\n  Binaries:\r\n    Node: 19.8.1 - \/usr\/local\/bin\/node\r\n    npm: 9.5.1 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","begone!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Begone!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","begone!"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Incorrect \"global\" coverageThreshold handle, while nested directories thresholds are defined","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Clone my repo https:\/\/github.com\/vvscode\/jest-coverage-issue-demo\r\n2. `npm install`\r\n3. `npx jest --config jest.config.js`\r\n4. `npx jest --config jest.configWithCollectCoverageFrom.js`\r\n\r\nThere is unexpected (by me) behaviour (described in README)\n\n### Expected behavior\n\nI expected being able to define global threshold as well as nested modules ones\n\n### Actual behavior\n\nGlobal threshold is not handled properly (not counted or counted incorrectly) if nested one is defined\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.4.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 20.8.0 - \/opt\/homebrew\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 10.2.1 - \/opt\/homebrew\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@cpojer @SimenB hey =)\r\n\r\nnot trying to prioritise this minor issue, but I'd like to understand the expected workflow for reporting","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","is anyone observing the list of issues? =)","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","sad to see full ignore =("],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: v30 alpha: `testPathPatterns` that worked in the past not working any more.","body":"### Version\n\n30.0.0-alpha.2\n\n### Steps to reproduce\n\n```sh\r\nyarn jest --config .\/config\/jest.config.js useLoadableQuery\r\n```\n\n### Expected behavior\n\nJest finds the matching file `src\/react\/hooks\/__tests__\/useLoadableQuery.test.tsx` and executes it\n\n### Actual behavior\n\nNo tests found, exiting with code 1\n\n### Additional context\n\nI understand that jest 30 had a change (in #12519) from a `[TestPathPattern]` option to `[TestPathPatterns]`, but honestly, I'm failing to get *anything* to match this new option, even specifying the full path to the test doesn't work. \r\n\r\nFrom the issue, it seems like this doesn't accept a RegEx anymore, but an array of patterns - but I'm not sure how to write those patterns. I'm getting errors like `Invalid testPattern **\/useLoadableQuery.* supplied. Running all tests instead.`.\r\n\r\nThis might be user error, but this change is very unexpected, and will probably seriously impact the workflows of most jest users and a ton of CI scripts, so I thought I'd open an issue to bring this to your attention.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.6\r\n    CPU: (8) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 20.5.0 - ~\/.nvm\/versions\/node\/v20.5.0\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 9.8.0 - ~\/.nvm\/versions\/node\/v20.5.0\/bin\/npm\r\n    pnpm: 8.7.6 - \/opt\/homebrew\/bin\/pnpm\r\n  npmPackages:\r\n    jest: 30.0.0-alpha.2 => 30.0.0-alpha.2\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Do you have a full reproduction?","@SimenB I would assume that this literally happens in every project using jest - it's just a completely different file name matching logic than before now.\r\n\r\nBut if this is actually some edge case and not intended to happen, I can create a branch of the Apollo Client repo with jest 30 after the new year; it definitely happened there, but I rolled back without creating a commit\/branch, because it was completely unusable.","It does not happen in this very repo, at least \ud83d\ude42 \r\n\r\n<img width=\"586\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/1404810\/65317f32-07e8-4207-9091-204993d68ef6\">\r\n","I'll try to reproduce it once I'm back at the job :)","Cool \ud83d\udc4d Enjoy your vacation!\r\n\r\nIdeally the reproduction is not the entire `@apollo\/client` \ud83d\ude05 ","So the *easy* (for me) reproduction is unfortunately `@apollo\/client` \ud83d\ude13 \r\n\r\nCheck out\r\nhttps:\/\/github.com\/apollographql\/apollo-client\/tree\/reproduction\/jest-30-alpha\r\n\r\nand run\r\n```sh\r\nnpm i\r\nnode --expose-gc .\/node_modules\/jest\/bin\/jest.js --config .\/config\/jest.config.js useSuspense\r\n```\r\nwhich will error with (I ran it with `--verbose` here)\r\n\r\n> No tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn \/Users\/tronic\/tmp\/apollo-client\/src\r\n  379 files checked.\r\n  testMatch: **\/__tests__\/**\/*.?([mc])[jt]s?(x), **\/?(*.)+(spec|test).?([mc])[jt]s?(x) - 142 matches\r\n  testPathIgnorePatterns: .tsx$ - 317 matches\r\n  testRegex:  - 0 matches\r\nIn \/Users\/tronic\/tmp\/apollo-client\/src\r\n  379 files checked.\r\n  testMatch: **\/__tests__\/**\/*.?([mc])[jt]s?(x), **\/?(*.)+(spec|test).?([mc])[jt]s?(x) - 142 matches\r\n  testPathIgnorePatterns: .ts$, src\/react\/hooks\/__tests__\/useSuspenseQuery.test.tsx, src\/react\/hooks\/__tests__\/useBackgroundQuery.test.tsx, src\/react\/hooks\/__tests__\/useLoadableQuery.test.tsx, src\/react\/hooks\/__tests__\/useQueryRefHandlers.test.tsx, src\/react\/query-preloader\/__tests__\/createQueryPreloader.test.tsx - 75 matches\r\n  testRegex:  - 0 matches\r\nIn \/Users\/tronic\/tmp\/apollo-client\/src\r\n  379 files checked.\r\n  testMatch: **\/__tests__\/**\/*.?([mc])[jt]s?(x), **\/?(*.)+(spec|test).?([mc])[jt]s?(x) - 142 matches\r\n  testPathIgnorePatterns: .ts$ - 80 matches\r\n  testRegex:  - 0 matches\r\nPattern: useSuspense - 0 matches\r\n\r\nThe test setup here contains three projects, and the third one should match the file `src\/react\/hooks\/__tests__\/useSuspenseQuery.test.tsx`.\r\n\r\nI'll try if I can distill this down to a smaller reproduction, but already wanted to post this here :)","~I found the issue, and it has nothing to do with the new name matching!~\r\n\r\n~The config file is in `config\/jest.config.js` and has `rootDir: \"src\"`.~\r\n\r\n~In the past, that just worked, but version 30 is now looking in `config\/src`, not in `src`.~\r\n\r\n~I'm not sure - I did not see this pointed out in the changelog, but I might have missed it.~\r\n\r\n~In case it's not there, it might be a good idea to point this change out, but feel free to close this issue if it's not actionable :)~\r\n\r\nSee next post.","Follow-up:\r\n\r\n`\"..\/src\"` doesn't work as soon as I get `projects` involved again:\r\n\r\n> \u25cf Validation Error:\r\n>\r\n>  Directory ..\/src in the rootDir option was not found.\r\n\r\nSo I switched it over to \r\n```\r\n   rootDir: `${__dirname}\/..\/src`,\r\n``` \r\nand it's failing to find the tests again.\r\n\r\nSo this might actually not be resolved? Do any alarm bells ring for you in combination with `projects`?\r\n","I believe I found it!\r\n\r\nIf you have a config file in a different folder, `testPathPatterns` are built relative to that folder and not the root folder:\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/4282439\/32f62abe-f2fe-4ad9-b77d-056e5b8f63b9)\r\n\r\n\r\nThe `\/config` should not be part of the pattern here.","It seems like the `rootDir` in the config is overwritten somehow. \r\n\r\nI hardcoded it to `rootDir: \"\/Users\/tronic\/tmp\/apollo-client\/src\"` in the config file, and it still end up as `'\/Users\/tronic\/tmp\/apollo-client\/config'` in the `config` object that is passed into the `TestPathPatterns` instance.\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/4282439\/c6b51c77-ec9d-42cd-b765-86a3ef7d749a)\r\n","This seems to be caused by the test path pattern being generated from the global config, not the project config \r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/c04d13d7abd22e47b0997f6027886aed225c9ce4\/packages\/jest-util\/src\/TestPathPatterns.ts#L23C1-L25\r\n\r\nIn our case and with that knowledge, I can work around this by adding a global `rootDir` option like\r\n\r\n```js\r\nmodule.exports = {\r\n  rootDir: `..\/src`,\r\n  projects: [tsStandardConfig, standardReact17Config, standardReact18Config],\r\n};\r\n```\r\n\r\nBut I assume it might be generally not correct to create the `testPathPatterns` relative to the \"main\" `rootDir` - project root dirs could point to completely different folders.","We looked at global config's root dir in v29 as well (have done for years). However, I do agree that seems odd \ud83e\udd14 \r\n\r\n@brandon-leapyear thoughts on this one?","FYI In the future, can you ping @brandonchinn178 instead? That account was my account for a company I worked at that has been acquired. Thanks!\r\n\r\nAh yes, so the test pattern logic used to not care about a root directory at all, it just searched the whole test file path. Now, the test pattern is actually sensitive on the root directory, and I just used the `rootDir` setting in the global config to fill this in. I didn't know that \"project configs\" was a concept that existed.\r\n\r\nI think the best fix would be to change `TestPathPatterns.fromGlobalConfig(GlobalConfig)` to `TestPathPatterns.fromConfig(GlobalConfig, ProjectConfig)`. Another option would be to remove `fromGlobalConfig` entirely and always use the `TestPathPatterns` constructor, but then someone else might call the constructor with `globalConfig.rootDir` again, if they also don't realize there's a difference between `globalConfig.rootDir`\/`projectConfig.rootDir`","Is there a reason to include a directory at all? From looking through the code with the debugger, it seems to me like these tests will only be applied to files that have been found within a project's `rootDir` in the first place?","> it seems to me like these tests will only be applied to files that have been found within a project's `rootDir` in the first place?\r\n\r\nCorrect, but the pattern needs to only match the relative path of the files, while the list of files is stored as a list of absolute paths. So we need to apply the pattern to only the relative part of the path, however we define what \"relative\" means. So the two options are:\r\n1. Add the \"base directory\" to the pattern and match the absolute paths\r\n2. Strip the \"base directory\" from the list of files and match the pattern verbatim\r\n\r\nI chose to do the first way, but the second is equally valid. But either way, you need to define the directory the paths should be considered relative against.\r\n\r\nTo reiterate the motivation for the PR, I was trying to run tests in my project named `users.spec.js`, but running `jest users` returned all tests because the absolute path of the files on my Mac is `\/Users\/<username?...`","I honestly don't really understand why we have `rootDir` on both places \ud83d\ude05  _Just_ having it in `ProjectConfig` seems correct to me","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Re: stale.\r\nHas this been addressed?","@phryneas probably not.\n\n@SimenB If you agree that rootDir should only be in ProjectConfig and not GlobalConfig, should we open a PR for that change now?","I did start messing around with removing a bunch of config from `global` that should really be on `project`, but that quickly turned unwieldy.\r\n\r\nFor `testPahPatterns`'s purposes though, we can probably migrate it over without touching `GlobalConfig` and `ProjectConfig` itself. I'd love a PR for that \ud83d\udc4d ","@brandonchinn178 would you be able to send that PR? \ud83d\ude42 ","@SimenB PR submitted!"],"labels":[":boom: Regression","Pinned"]},{"title":"feat(snapshot): support snapshotResolver and snapshotSerializers written in ESM (#12014 rebase)","body":"Just a rebase of https:\/\/github.com\/jestjs\/jest\/pull\/12014\r\n\r\nTests to not run locally for me because of watchman issues:\r\n```\r\n    expect(received).toHaveLength(expected)\r\n\r\n    Expected length: 1\r\n    Received length: 7\r\n    Received array:  [\"jest-haste-map: Watchman crawl failed. Retrying once with node crawler.\", \"  Usually this happens when watchman isn't running. Create an empty `.watchmanconfig` file in your project's root folder or initialize a git or hg repository in your project.\", \"  Error: Watchman error: watchman::RootResolveError: failed to resolve root: unable to resolve root \/tmp\/multi-project-runner-test: failed to parse json from \/tmp\/multi-project-runner-test\/.watchmanconfig: '[' or '{' expected near end of file. Make sure watchman is running for this project. See https:\/\/facebook.github.io\/watchman\/docs\/troubleshooting.\", \"jest-haste-map: Watchman crawl failed. Retrying once with node crawler.\", \"  Usually this happens when watchman isn't running. Create an empty `.watchmanconfig` file in your project's root folder or initialize a git or hg repository in your project.\", \"  Error: Watchman error: watchman::RootResolveError: failed to resolve root: unable to resolve root \/tmp\/multi-project-runner-test: failed to parse json from \/tmp\/multi-project-runner-test\/.watchmanconfig: '[' or '{' expected near end of file. Make sure watchman is running for this project. See https:\/\/facebook.github.io\/watchman\/docs\/troubleshooting.\", \"\/tmp\/multi-project-runner-test\/__tests__\/inBothProjectsTest.js\"]\r\n```\r\n\r\nSo let's see what the CI has to say about it.","comments":[" <a href=\"https:\/\/api.easycla.lfx.linuxfoundation.org\/v2\/repository-provider\/github\/sign\/35323119\/15062869\/14722\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-not-signed.svg\" alt=\"CLA Not Signed\" align=\"left\" height=\"28\" width=\"328\"><\/a><br\/><br \/><ul><li><a href='https:\/\/api.easycla.lfx.linuxfoundation.org\/v2\/repository-provider\/github\/sign\/35323119\/15062869\/14722\/#\/?version=2' target='_blank'>:x:<\/a> - login: @chentsulin \/ name: C. T. Lin . The commit (efc4f63ade9a46ae4cb089f044f9598e2e0aa69c) is not authorized under a signed CLA. <a href='https:\/\/api.easycla.lfx.linuxfoundation.org\/v2\/repository-provider\/github\/sign\/35323119\/15062869\/14722\/#\/?version=2' target='_blank'>Please click here to be authorized<\/a>. For further assistance with EasyCLA, <a href='https:\/\/jira.linuxfoundation.org\/servicedesk\/customer\/portal\/4' target='_blank'>please submit a support request ticket<\/a>.<\/li><\/ul>","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | efc4f63ade9a46ae4cb089f044f9598e2e0aa69c |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/65647f5dc815a60008941926 |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-14722--jestjs.netlify.app](https:\/\/deploy-preview-14722--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTE0NzIyLS1qZXN0anMubmV0bGlmeS5hcHAifQ.lb9FuVi0yJL_SBHFbUgyORXmPCUvhvGES54oRKE2YN4)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Stale"]},{"title":"[Bug]: Errors in `AggregateError` not displayed properly","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\nSee https:\/\/github.com\/loozhengyuan\/repro-jest-aggregateerror\/actions\/runs\/6918600341\/job\/18821023498\r\n\r\n### Expected behavior\r\n\r\nI expected to see each sub error nicely displayed.\r\n\r\n### Actual behavior\r\n\r\n```\r\nAggregateError:\r\n\r\n  at Function.Object.<anonymous>.AxiosError.from (node_modules\/axios\/lib\/core\/AxiosError.js:89:14)\r\n\r\nCause:\r\nAggregateError:\r\n```\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: Linux 6.2 Ubuntu 22.04.3 LTS 22.04.3 LTS (Jammy Jellyfish)\r\n  CPU: (4) x64 AMD EPYC 7763 64-Core Processor\r\nBinaries:\r\n  Node: 20.9.0 - \/opt\/hostedtoolcache\/node\/20.9.0\/x64\/bin\/node\r\n  Yarn: 1.22.21 - \/usr\/local\/bin\/yarn\r\n  npm: 10.1.0 - \/opt\/hostedtoolcache\/node\/20.9.0\/x64\/bin\/npm\r\nnpmPackages:\r\n  jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Indeed this is still happening, and since the original \"AggregatedError\" is encapsulated in an AxiosError you'll need to handle it as duck-typed:\r\n```js\r\ntry {\r\n  \/\/ ...\r\ncatch (e) {\r\n  let errMsg = e.errors ? e.errors.map((err) => err.toString()).join(', ') : e.toString();\r\n  \/\/ ...\r\n}\r\n```","This is also happening for raw `AggregateError`s as well, that at least should work.","PR very much welcome!"],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Feature]: Option for jest.retryTimes to retry just after the test fails","body":"### \ud83d\ude80 Feature Proposal\n\n[jest.retryTimes()](https:\/\/jestjs.io\/docs\/jest-object#jestretrytimesnumretries-options) is a great way to deal with flaky tests. It will schedule failed tests to be run AFTER testsuite ends.\r\n\r\nProposition here is to add option, to retry failed test, immidiately after test will fail, without waiting for test suite to finish first.\n\n### Motivation\n\nI need to design tests in a different way, when I use and don't use `retry`\r\n\r\nConsider such test suite:\r\n\r\n```\r\nbeforeAll() {enable feature A}\r\ntestA{use feature A}\r\ntestB{disable feature A}\r\n```\r\n\r\nTest design is proper here. I can run all tests together, I can run them separate. But if testA fails, and will be retried after testB, it will fail.\r\n\r\nIn a perfect world you control wole test env, but this is not always a case with more complex integrations.\r\n\r\nChanging design pattern to always use `beforeEach{enable feature A}` would cost run time (preparation steps sometimes take more than test itself)\n\n### Example\n\n`jest.retryTimes(3, {logErrorsBeforeRetry: true, retryFast: true});`\n\n### Pitch\n\nWIth more complex preparation steps OR when state of one test depends on another test, retrying at the end of testSuite is more risky. Option to retry just after the test - feels safer. This would add more versality for a different uses cases.\r\n\r\nSince retry mechanism is already in the core, this feels like natural extensions.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","not stale \ud83c\udf5e ","I like the idea! `jest.retryTimes({immediately: true})` or something? PR welcome \ud83d\ude42 "],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Feature]: Allow users to customize where toMatchInlineSnapshots writes to","body":"### \ud83d\ude80 Feature Proposal\n\nWhen using Bazel, `toMatchInlineSnapshot` won't work if you run the updater under the build tool because the source files the inline snapshot updater will try to write to are write protected. If, instead, we can have a way to override where the \"source tree\" is for the inline snapshot writer, we could potentially do this through bazel rules and allow users to update inline snapshots under bazel. This problem doesn't exist for normal snapshots because we can write custom snapshot resolvers.\r\n\r\nThis problem has also been reported in the bazel rules we use so that there is an existing issue on both sides of the problem https:\/\/github.com\/aspect-build\/rules_jest\/issues\/193\r\n\r\nHere is an example of how we have worked with Aspect, the rules maintainer, to work around writing snapshots back to the source tree https:\/\/github.com\/aspect-build\/rules_jest\/blob\/main\/jest\/private\/bazel_snapshot_resolver.cjs\r\n\r\nIf `InlineSnapshots` supported this sort of functionality, I _think_ it could work natively.\n\n### Motivation\n\nKeep feature parity when using jest with Bazel so we don't have to tell our users they can't use certain matcher functions\n\n### Example\n\nWe'd like to be able to run `bazel run \/\/path\/to\/target:test_snapshot_update` (which runs `jest -u` under the hood) and not have it fail with `EACCES: permission denied`.\r\n\r\nGiven my understanding of this line https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-snapshot\/src\/InlineSnapshots.ts#L98, jest keeps track of the source files it intends to write back to. If we could customize the `sourceFilePath` to be something like `BUILD_WORKSPACE_DIRECTORY` then we might be able to make the two interop.\r\n\r\nIn terms of where this feature would go, I think it needs to be in the config file similar to https:\/\/jestjs.io\/docs\/configuration#snapshotresolver-string. In addition to having `snapshotresolver` in the config, we would also have `inlineSnapshotResolver` and allow the user to define a function that returns the path. Beyond that, I don't think it warrants allowing users to customize the entire resolver since there is logic around prettier and babel that doesn't need to change\n\n### Pitch\n\nGiven inline snapshots are a main feature that's why I believe it resides in the core platform. It doesn't make sense to create a separate matcher with all the same functionality but just with a special way of writing to disk.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is still applicable.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Do not close, this is still an issue ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Do not close, this is still an issue ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"[Feature]: Support ability to recompute cache key for certain files more often","body":"### \ud83d\ude80 Feature Proposal\n\nThe ability for `TransformerFactory`'s `getCacheKey` and `getCacheKeyAsync` to notify jest if the key has changed even if the file text hasn't.\r\n\r\nSpecifically:\r\n- Add the ability for getting a cache key to be returned with some extra metadata.\r\n- Namely, an object with the following shape:\r\n    ```ts\r\n    export interface CacheKey {\r\n      key: string;\r\n      nextComputation?: \"any-file\" | \"file\";\r\n    }\r\n- The default for `nextComputation` is `\"file\"` which means the current implementation, and just returning a `string` would also continue to mean `\"any-file\"`\r\n- `\"any-file\"` would mean that this cache key would get recomputed the next time any file gets saved. This would be a transient field, meaning that a cache key getter could switch between `\"file\"` and `\"any-file\"` \n\n### Motivation\n\nSome typescript build systems (most notably `esbuild`) have support for a glob style import which transforms the import into a list of normal imports and then combines them into an array for use.\r\n\r\nThis means that if a new file is introduced matching the glob then the transformation should be redone automatically. The proposed feature would allow advanced jest users to implement this for themselves.\n\n### Example\n\nNew possible implementation (with this new feature):\r\n\r\nAdded features:\r\n- The ability to return not just a cache key, but also some meta data\r\n\r\n```ts\r\nconst globImportTransformer = {\r\n  getCacheKey: (sourceText, sourcePath, options) => {\r\n    const fileMatching = globImportRegex.exec(sourceText);\r\n    const { dynamicImportGlob } = fileMatching?.groups ?? {};\r\n\r\n    const globImportedFiles = dynamicImportGlob\r\n      ? discoverGlobFilesSync(sourcePath, dynamicImportGlob)\r\n      : [];\r\n\r\n    return {\r\n      key: computeCacheKey(globImportedFiles, sourceText, sourcePath, options),\r\n      nextCheck: dynamicImportGlob ? \"any-file\" : \"file\",\r\n    };\r\n  },\r\n   ...\r\n};\r\n```\n\n### Pitch\n\nIt is not currently possible to have this sort of back channel notification within jest, the current workaround for users is to manually trigger a `getCacheKey(Async)` call by touching the file that includes the glob.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This world still be great","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This world still be great","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still useful","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still useful","Hello! Happy to take a PR adding this \ud83d\udc4d ","not sure if it should be part of the return value of the cache key, tho. maybe it should be static in the transformer? Like `canInstrument`"],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"[Bug]: jsdom test environment fails require of json file on alterschema library","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone [my repo](https:\/\/github.com\/luiz00martins\/jest-jsdom-bug)\r\n2. Run `npm install`\r\n3. Run `npm test`\r\n\r\n\r\n### Expected behavior\r\n\r\nThe function `alterschema` is asynchronous. Therefore, when these two tests run:\r\n```js\r\nconst alterschema = require('alterschema');\r\n\r\ndescribe('Test', function() {\r\n\tconst schema = {\r\n\t\tfoo: {\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t};\r\n\r\n\tit('should fail schema', async () => {\r\n\t\texpect(alterschema(schema, 'draft4', 'draft6')).toEqual(schema);\r\n\t});\r\n\r\n\tit('should succeed schema', async () => {\r\n\t\texpect(await alterschema(schema, 'draft4', 'draft6')).toEqual(schema);\r\n\t});\r\n});\r\n```\r\n\r\nI expect `'should fail schema'` one to fail, as `Promise` will not equal the given object. I also expect `'should succeed schema'` to succeed, as the JSON objects match. \r\n\r\n### Actual behavior\r\n\r\nHowever, what happens is that it crashes:\r\n```\r\nC:\\Users\\luizh\\Local\\jest-test\\node_modules\\jest-runtime\\build\\index.js:1016\r\n        this._environment.global.JSON.parse(transformedFile);\r\n                                 ^\r\n\r\nTypeError: Cannot read properties of null (reading 'JSON')\r\n    at Runtime._loadModule (C:\\Users\\luizh\\Local\\jest-test\\node_modules\\jest-runtime\\build\\index.js:1016:34)\r\n    at Runtime.requireModule (C:\\Users\\luizh\\Local\\jest-test\\node_modules\\jest-runtime\\build\\index.js:882:12)\r\n    at Runtime.requireModuleOrMock (C:\\Users\\luizh\\Local\\jest-test\\node_modules\\jest-runtime\\build\\index.js:1048:21)\r\n    at Object.<anonymous>.module.exports (C:\\Users\\luizh\\Local\\jest-test\\node_modules\\alterschema\\bindings\\node\\walker.js:6:19)\r\n    at Object.<anonymous>.module.exports (C:\\Users\\luizh\\Local\\jest-test\\node_modules\\alterschema\\bindings\\node\\index.js:71:20)\r\n    at processTicksAndRejections (node:internal\/process\/task_queues:95:5)\r\n\r\nNode.js v18.17.0\r\n```\r\n\r\nIf the first test gets commented, the second one succeeds as expected. However, if the first test is present, jest crashes before the second one is run.\r\n\r\n### Additional context\r\n\r\nI'm using `jest-environment-jsdom`, with `testEnvironment: \"jsdom\"`.\r\n\r\nThe only reason I'm posting this bug, is because I wasted a bunch of time trying to find what the actual issue was, i.e. the missing `await`. Usually you'll just get a failed test, as the `Promise` object won't match the passed one, and you'll realize you forgot an `await`. On this one however, I has to spend a couple days trying to decrypt in which part of my environment\/code the problem was. So even if it's unsolvable\/my problem\/won't fix, I hope somebody else finds the issue useful.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Windows 10 10.0.19045\r\n    CPU: (12) x64 AMD Ryzen 5 5600G with Radeon Graphics\r\n  Binaries:\r\n    Node: 18.17.0 - ~\\scoop\\apps\\nvm\\current\\nodejs\\nodejs\\node.EXE\r\n    Yarn: 1.22.19 - ~\\scoop\\apps\\yarn\\current\\bin\\yarn.CMD\r\n    npm: 9.8.1 - ~\\scoop\\apps\\nvm\\current\\nodejs\\nodejs\\npm.CMD\r\n    pnpm: 8.6.10 - ~\\AppData\\Local\\pnpm\\pnpm.CMD\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bruh","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 30 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","This issue was closed because it has been stalled for 30 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","Wanna send a PR improving the error? We have a `isTornDown` property in the runtime that should be checked from `require` calls so we can give a better error to the user.\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/50fe2eee8868f955e143af1ad7444ba2302dd8f5\/packages\/jest-runtime\/src\/index.ts#L1415\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/50fe2eee8868f955e143af1ad7444ba2302dd8f5\/packages\/jest-runtime\/src\/index.ts#L2063\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/50fe2eee8868f955e143af1ad7444ba2302dd8f5\/packages\/jest-runtime\/src\/index.ts#L1143\r\n\r\nPossibly a couple of other places as well"],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Bug]: Jest leaks memory in ESM mode","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nclone the repository at: https:\/\/github.com\/Havunen\/jest-memory-leak\r\nrun `npm install`\r\nrun `npm test`\r\n\r\nYou should see the heap memory increasing over time until the nodejs process crashes.\n\n### Expected behavior\n\nThe nodejs process should be able to clean the memory and preferably allocate as little as possible\n\n### Actual behavior\n\nThe node js process crashes\r\n\r\n```\r\nFATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 00007FF7018A3CEF node::SetCppgcReference+15695\r\n 2: 00007FF70181E606 EVP_MD_meth_get_input_blocksize+78566\r\n 3: 00007FF7018203F1 EVP_MD_meth_get_input_blocksize+86225\r\n 4: 00007FF70228A191 v8::Isolate::ReportExternalAllocationLimitReached+65\r\n 5: 00007FF702273928 v8::Function::Experimental_IsNopFunction+1336\r\n 6: 00007FF7020D5190 v8::Platform::SystemClockTimeMillis+659552\r\n 7: 00007FF7020D2218 v8::Platform::SystemClockTimeMillis+647400\r\n 8: 00007FF7020E752A v8::Platform::SystemClockTimeMillis+734202\r\n 9: 00007FF7020E7DA7 v8::Platform::SystemClockTimeMillis+736375\r\n10: 00007FF7020F09DE v8::Platform::SystemClockTimeMillis+772270\r\n11: 00007FF702101356 v8::Platform::SystemClockTimeMillis+840230\r\n12: 00007FF702105F28 v8::Platform::SystemClockTimeMillis+859640\r\n13: 00007FF701E7D67A v8::base::Thread::StartSynchronously+372122\r\n14: 00007FF701FC15B0 v8::ObjectTemplate::IsImmutableProto+13152\r\n15: 00007FF7021EA0C9 v8::SharedValueConveyor::SharedValueConveyor+62825\r\n16: 00007FF7021EA3C8 v8::SharedValueConveyor::SharedValueConveyor+63592\r\n17: 00007FF7021E4624 v8::SharedValueConveyor::SharedValueConveyor+39620\r\n18: 00007FF7021E455A v8::SharedValueConveyor::SharedValueConveyor+39418\r\n19: 00007FF70226E84D v8::ScriptCompiler::CompileUnboundInternal+1069\r\n20: 00007FF70226EB21 v8::ScriptCompiler::CompileUnboundScript+161\r\n21: 00007FF70182E54B node::OnFatalError+57675\r\n22: 00007FF70224056E v8::SharedValueConveyor::SharedValueConveyor+416270\r\n23: 00007FF70223FE17 v8::SharedValueConveyor::SharedValueConveyor+414391\r\n24: 00007FF702240444 v8::SharedValueConveyor::SharedValueConveyor+415972\r\n25: 00007FF7022402A0 v8::SharedValueConveyor::SharedValueConveyor+415552\r\n26: 00007FF70233AC3E v8::PropertyDescriptor::writable+674286\r\n27: 00007FF7022A99B3 v8::PropertyDescriptor::writable+79715\r\n28: 00007FF682572942\r\n```\n\n### Additional context\n\nThis is continuation from here: https:\/\/github.com\/jestjs\/jest\/pull\/12205#issuecomment-1749127216\n\n### Environment\n\n```shell\nnode v20.8.0\r\nwindows 11 ver. 2261\r\nnpm 9.6.4\r\nJest 29.7\n```\n","comments":["Here is a log:\r\n\r\n```\r\n> jest-memory-leak@1.0.0 test\r\n> cross-env NODE_OPTIONS=--max-old-space-size=128 node --experimental-vm-modules .\/node_modules\/jest\/bin\/jest.js --config=jest.config.js --runInBand --logHeapUsage --no-watchman --ci\r\n\r\n(node:28376) ExperimentalWarning: VM Modules is an experimental feature and might change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n PASS  tests\/test (9).spec.spec.js (37 MB heap size)\r\n PASS  tests\/test (80).spec.spec.js (42 MB heap size)\r\n PASS  tests\/test (8).spec.spec.js (35 MB heap size)\r\n PASS  tests\/test (79).spec.spec.js (45 MB heap size)\r\n PASS  tests\/test (78).spec.spec.js (44 MB heap size)\r\n PASS  tests\/test (77).spec.spec.js (46 MB heap size)\r\n PASS  tests\/test (76).spec.spec.js (46 MB heap size)\r\n PASS  tests\/test (75).spec.spec.js (55 MB heap size)\r\n PASS  tests\/test (74).spec.spec.js (55 MB heap size)\r\n PASS  tests\/test (73).spec.spec.js (59 MB heap size)\r\n PASS  tests\/test (72).spec.spec.js (56 MB heap size)\r\n PASS  tests\/test (71).spec.spec.js (65 MB heap size)\r\n PASS  tests\/test (70).spec.spec.js (65 MB heap size)\r\n PASS  tests\/test (7).spec.spec.js (69 MB heap size)\r\n PASS  tests\/test (69).spec.spec.js (70 MB heap size)\r\n PASS  tests\/test (68).spec.spec.js (68 MB heap size)\r\n PASS  tests\/test (66).spec.spec.js (77 MB heap size)\r\n PASS  tests\/test (67).spec.spec.js (77 MB heap size)\r\n PASS  tests\/test (65).spec.spec.js (80 MB heap size)\r\n PASS  tests\/test (64).spec.spec.js (81 MB heap size)\r\n PASS  tests\/test (63).spec.spec.js (90 MB heap size)\r\n PASS  tests\/test (43).spec.spec.js (82 MB heap size)\r\n PASS  tests\/test (61).spec.spec.js (91 MB heap size)\r\n PASS  tests\/test (62).spec.spec.js (91 MB heap size)\r\n PASS  tests\/test (60).spec.spec.js (95 MB heap size)\r\n PASS  tests\/test (6).spec.spec.js (91 MB heap size)\r\n PASS  tests\/test (59).spec.spec.js (100 MB heap size)\r\n PASS  tests\/test (58).spec.spec.js (101 MB heap size)\r\n PASS  tests\/test (57).spec.spec.js (104 MB heap size)\r\n PASS  tests\/test (56).spec.spec.js (99 MB heap size)\r\n PASS  tests\/test (55).spec.spec.js (100 MB heap size)\r\n PASS  tests\/test (54).spec.spec.js (95 MB heap size)\r\n PASS  tests\/test (53).spec.spec.js (102 MB heap size)\r\n PASS  tests\/test (52).spec.spec.js (99 MB heap size)\r\n PASS  tests\/test (50).spec.spec.js (103 MB heap size)\r\n PASS  tests\/test (51).spec.spec.js (101 MB heap size)\r\n PASS  tests\/test (5).spec.spec.js (107 MB heap size)\r\n PASS  tests\/test (49).spec.spec.js (106 MB heap size)\r\n PASS  tests\/test (48).spec.spec.js (111 MB heap size)\r\n PASS  tests\/test (47).spec.spec.js (111 MB heap size)\r\n PASS  tests\/test (45).spec.spec.js (113 MB heap size)\r\n PASS  tests\/test (46).spec.spec.js (118 MB heap size)\r\n PASS  tests\/test (44).spec.spec.js (116 MB heap size)\r\n PASS  tests\/test (42).spec.spec.js (117 MB heap size)\r\n\r\n RUNS  tests\/test (41).spec.spec.js\r\n\r\n<--- Last few GCs --->\r\n\r\n[28376:000001E017CEF240]     6150 ms: Mark-Compact (reduce) 117.4 (130.8) -> 116.8 (131.3) MB, 25.51 \/ 0.00 ms  (average mu = 0.609, current mu = 0.567) allocation failure; scavenge might not succeed\r\n[28376:000001E017CEF240]     6189 ms: Mark-Compact (reduce) 118.0 (131.3) -> 116.8 (131.8) MB, 24.29 \/ 0.01 ms  (average mu = 0.526, current mu = 0.375) allocation failure; scavenge might not succeed\r\n```","tested with nodejs v21.0.0-nightly202310041a839f388e (06-Oct-2023 11:00) and it is still an issue. ","You mentioned JSON files in the other PR. This is how we construct them in ESM mode: https:\/\/github.com\/jestjs\/jest\/blob\/00ef0ed0a03764f24ff568bc87dcc1c203d28625\/packages\/jest-runtime\/src\/index.ts#L492-L500\r\n\r\nEssentially copied straight from the docs (which use a JSON example): https:\/\/nodejs.org\/api\/vm.html#class-vmsyntheticmodule\r\n\r\nSo there's no code cache here. I'd assume `JSON.parse` wouldn't cause an issue as long as the synthetic module is collected.\r\n\r\nBut yeah, maybe the flags suggested in https:\/\/github.com\/jestjs\/jest\/pull\/12205#issuecomment-1752883031 can help in narrowing down what's not freed?","@Havunen this does not reproduce if I remove the `importModuleDynamically` option from `createScriptFromCode` in `jest-runtime`. So I'm guessing it's still related to the broken code caching (i.e. nr 4 here https:\/\/github.com\/jestjs\/jest\/pull\/12205#issuecomment-1749113564)","I commented out all importModuleDynamically callbacks it still does not work using node v21.0.0-nightly20231008fce8fbadcd.\r\nI added more tests and bigger JSON to the example so its more obvious now","log:\r\n\r\n```\r\ncross-env NODE_OPTIONS=--max-old-space-size=128 node --experimental-vm-modules .\/node_modules\/jest\/bin\/jest.js --config=jest.config.js --runInBand --logHeapUsage --no-watchman --ci\r\n\r\n(node:17340) ExperimentalWarning: VM Modules is an experimental feature and might change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n PASS  tests\/test (94).spec.js (34 MB heap size)\r\n PASS  tests\/test (90).spec.js (50 MB heap size)\r\n PASS  tests\/test (234).spec.js (53 MB heap size)\r\n PASS  tests\/test (89).spec.js (61 MB heap size)\r\n PASS  tests\/test (9).spec.js (61 MB heap size)\r\n PASS  tests\/test (92).spec.js (69 MB heap size)\r\n PASS  tests\/test (91).spec.js (78 MB heap size)\r\n PASS  tests\/test (87).spec.js (74 MB heap size)\r\n PASS  tests\/test (98).spec.js (82 MB heap size)\r\n PASS  tests\/test (97).spec.js (91 MB heap size)\r\n PASS  tests\/test (50).spec.js (87 MB heap size)\r\n PASS  tests\/test (93).spec.js (95 MB heap size)\r\n PASS  tests\/test (192).spec.js (95 MB heap size)\r\n PASS  tests\/test (96).spec.js (103 MB heap size)\r\n PASS  tests\/test (86).spec.js (100 MB heap size)\r\n PASS  tests\/test (129).spec.js (107 MB heap size)\r\n PASS  tests\/test (21).spec.js (111 MB heap size)\r\n PASS  tests\/test (77).spec.js (116 MB heap size)\r\n PASS  tests\/test (186).spec.js (116 MB heap size)\r\n PASS  tests\/test (209).spec.js (121 MB heap size)\r\n PASS  tests\/test (57).spec.js (125 MB heap size)\r\n\r\n RUNS  tests\/test (56).spec.js\r\n\r\n<--- Last few GCs --->\r\n\r\n[17340:0000022DDED70080]     2645 ms: Mark-Compact (reduce) 126.9 (130.3) -> 126.9 (131.1) MB, 52.91 \/ 0.00 ms  (average mu = 0.347, current mu = 0.071) allocation failure; scavenge might not succeed\r\n[17340:0000022DDED70080]     2694 ms: Mark-Compact (reduce) 127.9 (131.1) -> 127.9 (132.1) MB, 44.15 \/ 0.00 ms  (average mu = 0.235, current mu = 0.088) allocation failure; scavenge might not succeed\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\nFATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 00007FF61DFA9A7F node::SetCppgcReference+13775\r\n 2: 00007FF61DF23B06 DSA_meth_get_flags+76070\r\n 3: 00007FF61DF25941 DSA_meth_get_flags+83809\r\n 4: 00007FF61E984111 v8::Isolate::ReportExternalAllocationLimitReached+65\r\n 5: 00007FF61E96D9B8 v8::Function::Experimental_IsNopFunction+1336\r\n 6: 00007FF61E7D5F90 v8::StackTrace::GetFrameCount+74720\r\n 7: 00007FF61E7D2D8D v8::StackTrace::GetFrameCount+61917\r\n 8: 00007FF61E7E800D v8::StackTrace::GetFrameCount+148573\r\n 9: 00007FF61E7E8892 v8::StackTrace::GetFrameCount+150754\r\n10: 00007FF61E7F166E v8::StackTrace::GetFrameCount+187070\r\n11: 00007FF61E7F976A v8::StackTrace::GetFrameCount+220090\r\n12: 00007FF61E700A5A v8::base::time_internal::TimeBase<v8::base::ThreadTicks>::operator!=+53770\r\n13: 00007FF61E6FD5AD v8::base::time_internal::TimeBase<v8::base::ThreadTicks>::operator!=+40285\r\n14: 00007FF61E702C0F v8::base::time_internal::TimeBase<v8::base::ThreadTicks>::operator!=+62399\r\n15: 00007FF61E913AD8 v8::SharedValueConveyor::SharedValueConveyor+256680\r\n16: 00007FF61E913CF0 v8::SharedValueConveyor::SharedValueConveyor+257216\r\n17: 00007FF61EA355BE v8::PropertyDescriptor::writable+676814\r\n18: 0000022DDF0633E5\r\n\r\n```\r\n\r\nAll `importModuleDynamically` removed from the whole code base \r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/2021355\/8eb61bd7-d03f-43ef-98c1-8a0f4bd08a40)\r\n\r\n","I also removed all `initializeImportMeta` callbacks and it still reproduces","I have reproduced the issue using nodejs and javascript only, and also found a work around.\r\n\r\nHaving a shared context between the modules seems to leak the memory. However setting the shared context null manually after function execution it fixes the memory leak. Setting the variable null in JS is non-sense (ref: https:\/\/github.com\/Havunen\/nodejs-memory-leak\/blob\/main\/test.js#L45-L46 ) because it goes out of scope and should be GC'd but it does not seem to happen. So its definetly a nodejs \/ v8 bug\r\n\r\nhttps:\/\/github.com\/Havunen\/nodejs-memory-leak","We do set it to `null` manually in the node environment, FWIW.\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/00ef0ed0a03764f24ff568bc87dcc1c203d28625\/packages\/jest-environment-node\/src\/index.ts#L200\r\n\r\nNot so in the JSDOM env, but the reproduction in this issue uses the Node env.\r\n\r\nMight be we keep a reference without meaning to within the runtime of course","yeah but it is not set null in the call site not sure if it needs to be nulled everywhere or how it works in low level","After testing a bit more it seems setting the context to null does not really fix the issue :\/ "],"labels":["Upstream Bug","ES Modules","Pinned"]},{"title":"[Bug]: require.resolve() with `options.paths` ignores `moduleNameMapper`","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\n1. Open https:\/\/stackblitz.com\/edit\/stackblitz-starters-7snujh\r\n2. Run `jest` in a terminal\r\n3. Notice failing tests\n\n### Expected behavior\n\nTests are simple and assert `require.resolve()` behavior:\r\n\r\n```js\r\nit('require-resolve', () => {\r\n  const result = require.resolve('@foo\/js');\r\n\r\n  expect(typeof result).toBe('string');\r\n  expect(result).toMatch(\/\\\/js\\\/index.js$\/);\r\n});\r\n\r\nit('require-resolve-paths', () => {\r\n  const paths = [__dirname];\r\n  const result = require.resolve('@foo\/js', { paths });\r\n\r\n  expect(typeof result).toBe('string');\r\n  expect(result).toMatch(\/\\\/src\\\/\\@foo\\\/js\\\/index.js$\/);\r\n});\r\n```\r\n\r\nThe expectation is that both tests will pass.\n\n### Actual behavior\n\n`require-resolve-paths` test is failing with:\r\n\r\n```\r\n    Message:\r\n      Cannot resolve module '@foo\/js' from paths ['\/home\/projects\/stackblitz-starters-7snujh\/packages'] from \/home\/projects\/stackblitz-starters-7snujh\/packages\/require-resolve-paths.test.js\r\n```\r\n\r\nWhile `moduleNameMapper` is configured:\r\n\r\n```js\r\nmodule.exports = {\r\n  moduleNameMapper: {\r\n    '@foo\/js': '<rootDir>\/js\/index.js',\r\n  },\r\n}\r\n```\r\n\r\nIt fails because once `options.paths` are used, completely different branch is used:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/1bacb5e0075e1a145d822e8a5dd22ab8aef32c25\/packages\/jest-runtime\/src\/index.ts#L1458-L1462\r\n\r\n`resolveModuleFromDirIfExists()` does not check for `moduleNameMapper` config unlike `_resolveCjsModule()` (or actually `resolveModule()` that is used in a default scenario.\r\n\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.0 undefined\r\n    CPU: (8) x64 Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 18.18.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.19 - \/usr\/local\/bin\/yarn\r\n    npm: 9.4.2 - \/usr\/local\/bin\/npm\r\n    pnpm: 8.6.12 - \/usr\/local\/bin\/pnpm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Please unstale, bot.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Please unstale, bot.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Please unstale, bot.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Please unstale, bot.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Please unstale, bot.","Wanna send a PR fixing this? I've never really used `paths` myself..."],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"[Bug]: toMatchObject incorectly handles nulls in lists of sets","body":"### Version\n\n29.7.0\n\n### Steps to reproduce\n\nFor this match\r\n```\r\nexpect([null]).toMatchObject([new Set()]);\r\n```\r\n\n\n### Expected behavior\n\nIt should throw an exception\n\n### Actual behavior\n\nBut it doesn't throw an exception. What's interesting is that\r\n```\r\nexpect(null).toMatchObject(new Set()); \r\n```\r\nbehaves as expected.\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 6.1 Debian GNU\/Linux 12 (bookworm) 12 (bookworm)\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-8365U CPU @ 1.60GHz\r\n  Binaries:\r\n    Node: 20.6.1 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.19 - \/usr\/local\/bin\/yarn\r\n    npm: 9.8.1 - \/usr\/local\/bin\/npm\r\n    pnpm: 8.7.5 - \/usr\/local\/share\/npm-global\/bin\/pnpm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Is this a bug or expected behaviour?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 30 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","Deffo a bug - PR welcome! \ud83d\ude00 ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@SimenB \r\nWill appreciate a review on the PR linked above \ud83d\ude4c \r\n","@SimenB kindly reminder \ud83d\ude04 ","@bensternthal \/ @cpojer  would appreciate a review on the PR \ud83d\ude4c "],"labels":[":bug: Bug","Help Wanted"]},{"title":"[Bug]: Multiple `--projects` specified causes `--config` to not be used","body":"### Version\r\n\r\n29.7.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone my repro: https:\/\/github.com\/AndrewSouthpaw\/2023-10-jest-projects-bug-repro\r\n2. `yarn`\r\n3. `yarn jest --showConfig` with 2+ `projects` in the config shows the global config properly set (`testTimeout: 30000`), with projects listed\r\n4. `yarn jest --projects=src\/project1 --showConfig` shows global config **not** set (no `testTimeout` specified)\r\n5. `yarn jest --projects=src\/project1 --showConfig -c jest.config.js` shows global config properly set\r\n6. `yarn jest --projects=src\/project1 src\/project2 --showConfig -c jest.config.js` shows global config **not** set\r\n\r\nThis demonstrates the `-c` flag is ignored entirely when 2 or more projects are specified in `--projects`:\r\n\r\n1. `yarn jest --projects=src\/project1 src\/project2 --showConfig -c doesNotExist.config.js` does not error\r\n2. `yarn jest --projects=src\/project1 --showConfig -c doesNotExist.config.js` does error, as expected\r\n\r\nProject structure:\r\n\r\n```\r\nsrc\r\n|__ project 1\r\n   |__ jest.config.js\r\n|__ project 2\r\n   |__ jest.config.js\r\njest.config.js\r\n```\r\n\r\nSample global `jest.config.js`:\r\n\r\n```js\r\nconst config = {\r\n  \"projects\": [\"src\/project1\", \"src\/project2\"],\r\n  \"testTimeout\": 30000,\r\n}\r\n  \r\nmodule.exports = config\r\n```\r\n\r\n### Expected behavior\r\n\r\nWhen providing `-c jest.config.js`, it is used regardless of whether I provide 1 or 2+ projects under `--projects`\r\n\r\n### Actual behavior\r\n\r\n`-c` flag is not used when `--projects` receives 2 or more arguments.\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 13.6\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 18.17.0 - ~\/.nvm\/versions\/node\/v18.17.0\/bin\/node\r\n    Yarn: 3.2.4 - ~\/.nvm\/versions\/node\/v18.17.0\/bin\/yarn\r\n    npm: 9.6.7 - ~\/.nvm\/versions\/node\/v18.17.0\/bin\/npm\r\n    pnpm: 8.8.0 - ~\/.nvm\/versions\/node\/v18.17.0\/bin\/pnpm\r\n  npmPackages:\r\n    jest: ^29.7.0 => 29.7.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue\r\n\r\n--\r\nAndrew Smith\r\n971.219.3670\r\nCode <http:\/\/www.andrewsouthpaw.com\/> | Dance\r\n<http:\/\/www.andrewsmithdance.com\/>\r\n\r\n\r\nOn Wed, Jan 10, 2024 at 12:05\u202fAM github-actions[bot] <\r\n***@***.***> wrote:\r\n\r\n> This issue is stale because it has been open 30 days with no activity.\r\n> Remove stale label or comment or this will be closed in 30 days.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https:\/\/github.com\/jestjs\/jest\/issues\/14586#issuecomment-1884362500>, or\r\n> unsubscribe\r\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/ABHSOTGK46FQNRCV2EXJAMLYNZDTFAVCNFSM6AAAAAA5OPQE2WVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTQOBUGM3DENJQGA>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue\r\n\r\n--\r\nSent from a tiny screen; please excuse brevity or errors, or both.\r\n\r\n\r\nOn Fri, Feb 9, 2024 at 08:04 github-actions[bot] ***@***.***>\r\nwrote:\r\n\r\n> This issue is stale because it has been open 30 days with no activity.\r\n> Remove stale label or comment or this will be closed in 30 days.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https:\/\/github.com\/jestjs\/jest\/issues\/14586#issuecomment-1936189995>, or\r\n> unsubscribe\r\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/ABHSOTDR37GW6IOROGLA5U3YSZCJDAVCNFSM6AAAAAA5OPQE2WVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMZWGE4DSOJZGU>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue","I'm always a bit confused by the differentiation of project and global config \ud83d\ude05 Specifically, `testTimeout` seems _very_ much like a project config thing (e.g. integration tests should probably have a higher timeout than unit tests). Regardless, this is obviously a bug!\r\n\r\nWould you be up for sending a PR?"],"labels":[":bug: Bug","Needs Triage","Pinned"]},{"title":"[Bug]: copying of jest root config to projects is broken\/unintuitive","body":"### Version\r\n\r\n29.6.4\r\n\r\n### Steps to reproduce\r\n\r\nGiven this configuration:\r\n\r\n```\r\nimport { packageToModuleNameMapper } from \"sutro-build\";\r\nimport type { JestConfigWithTsJest } from \"ts-jest\";\r\n\r\nconst config: JestConfigWithTsJest = {\r\n  preset: \"react-native\",\r\n  projects: [\r\n    { preset: \"jest-expo\/ios\" },\r\n    { preset: \"jest-expo\/android\" },\r\n    { preset: \"jest-expo\/web\" },\r\n  ],\r\n  transform: {\r\n    '^.+\\\\.jsx$': 'babel-jest',\r\n    '^.+\\\\.tsx?$': [\r\n      'ts-jest',\r\n      {\r\n        tsconfig: '<rootDir>\/tsconfig.json',\r\n      },\r\n    ],\r\n  },\r\n  globals: {\r\n    __DEV__: true,\r\n  },\r\n  setupFiles: [\r\n    \"react-native-gesture-handler\/jestSetup.js\",\r\n  ],\r\n  transformIgnorePatterns: ['<rootDir>\/node_modules\/'],\r\n\r\n  moduleFileExtensions: [\"ts\", \"tsx\", \"js\", \"jsx\"],\r\n  clearMocks: true,\r\n\r\n  \/\/ Indicates whether the coverage information should be collected while executing the test\r\n  collectCoverage: false,\r\n\r\n  \/\/ An array of glob patterns indicating a set of files for which coverage information should be collected\r\n  collectCoverageFrom: [\r\n    \"**\/*.{j,t}{s,sx}\",\r\n    \"!**\/node_modules\/**\",\r\n    \"!**\/dist\/**\",\r\n    \"!**\/data\/**\",\r\n    \"!**\/__tests__\/**\",\r\n    \"!**\/__mocks__\/**\",\r\n    \/\/ Right now, we have to ignore these because otherwise Jest fails\r\n    \"!**\/src\/components\/**\",\r\n  ],\r\n\r\n  \/\/ The directory where Jest should output its coverage files\r\n  coverageDirectory: \"coverage\",\r\n\r\n  \/\/ An array of regexp pattern strings used to skip coverage collection\r\n  \/\/ coveragePathIgnorePatterns: [\"<rootDir>\/node_modules\/\", \"<rootDir>\/dist\/\"],\r\n\r\n  \/\/ Indicates which provider should be used to instrument code for coverage\r\n  coverageProvider: \"babel\",\r\n\r\n  \/\/ A list of reporter names that Jest uses when writing coverage reports\r\n  reporters: [\r\n    \"default\",\r\n    [\r\n      \"jest-junit\",\r\n      {\r\n        outputDirectory: \"reports\",\r\n        outputName: \"report.xml\",\r\n        ancestorSeparator: \" \u203a \",\r\n        uniqueOutputName: \"false\",\r\n        suiteNameTemplate: \"{filepath}\",\r\n        classNameTemplate: \"{classname}\",\r\n        titleTemplate: \"{title}\",\r\n      },\r\n    ],\r\n  ],\r\n  coverageReporters: [[\"lcov\", { projectRoot: \"..\/..\" }]],\r\n\r\n  \/\/ An object that configures minimum threshold enforcement for coverage results\r\n  coverageThreshold: {\r\n    global: {\r\n      branches: 1,\r\n      functions: 1,\r\n      lines: 1,\r\n      statements: 1,\r\n    },\r\n  },\r\n  testEnvironment: \"jsdom\",\r\n  rootDir: `${__dirname}`,\r\n  roots: [ \"<rootDir>\/src\",\"<rootDir>\/..\/..\/__mocks__\"],\r\n  moduleNameMapper: {\r\n    ...packageToModuleNameMapper(__dirname, { exclude: [\"sutro-interpreter\"] })\r\n  }\r\n};\r\n\r\nexport default config;\r\n```\r\n\r\nRun `yarn test --debug` and review the configuration\r\n\r\n### Expected behavior\r\n\r\nI get the following configuration\r\n\r\n```\r\n{\r\n  \"configs\": [\r\n    {\r\n      \"automock\": false,\r\n      \"cache\": true,\r\n      \"cacheDirectory\": \"\/private\/var\/folders\/hk\/z614k7h119n33vqm4smys2p00000gn\/T\/jest_dx\",\r\n      \"clearMocks\": false,\r\n      \"collectCoverageFrom\": [],\r\n      \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n      \"coveragePathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"cwd\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"detectLeaks\": false,\r\n      \"detectOpenHandles\": false,\r\n      \"displayName\": {\r\n        \"name\": \"iOS\",\r\n        \"color\": \"white\"\r\n      },\r\n      \"errorOnDeprecated\": false,\r\n      \"extensionsToTreatAsEsm\": [],\r\n      \"fakeTimers\": {\r\n        \"enableGlobally\": false\r\n      },\r\n      \"forceCoverageMatch\": [],\r\n      \"globals\": {},\r\n      \"haste\": {\r\n        \"defaultPlatform\": \"ios\",\r\n        \"platforms\": [\r\n          \"ios\",\r\n          \"native\"\r\n        ]\r\n      },\r\n      \"id\": \"39dc19bf989cf7416f56fd9b62c54afa\",\r\n      \"injectGlobals\": true,\r\n      \"moduleDirectories\": [\r\n        \"node_modules\"\r\n      ],\r\n      \"moduleFileExtensions\": [\r\n        \"ios.ts\",\r\n        \"ios.tsx\",\r\n        \"ios.js\",\r\n        \"ios.jsx\",\r\n        \"native.ts\",\r\n        \"native.tsx\",\r\n        \"native.js\",\r\n        \"native.jsx\",\r\n        \"ts\",\r\n        \"tsx\",\r\n        \"js\",\r\n        \"jsx\",\r\n        \"json\"\r\n      ],\r\n      \"moduleNameMapper\": [],\r\n      \"modulePathIgnorePatterns\": [],\r\n      \"openHandlesTimeout\": 1000,\r\n      \"prettierPath\": \"prettier\",\r\n      \"resetMocks\": false,\r\n      \"resetModules\": false,\r\n      \"restoreMocks\": false,\r\n      \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"roots\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/__tests__\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/__mocks__\"\r\n      ],\r\n      \"runner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-runner\/build\/index.js\",\r\n      \"sandboxInjectedGlobals\": [],\r\n      \"setupFiles\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/setup.js\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/setup.js\"\r\n      ],\r\n      \"setupFilesAfterEnv\": [],\r\n      \"skipFilter\": false,\r\n      \"slowTestThreshold\": 5,\r\n      \"snapshotFormat\": {\r\n        \"escapeString\": false,\r\n        \"printBasicPrototype\": false\r\n      },\r\n      \"snapshotResolver\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/snapshot\/resolver.ios.js\",\r\n      \"snapshotSerializers\": [],\r\n      \"testEnvironment\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/react-native-env.js\",\r\n      \"testEnvironmentOptions\": {},\r\n      \"testLocationInResults\": false,\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*spec.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.ios.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.ios.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).ios.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.native.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.native.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).native.[jt]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"testRegex\": [],\r\n      \"testRunner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-circus\/runner.js\",\r\n      \"transform\": [\r\n        [\r\n          \"^.+\\\\.(js|ts|tsx)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/babel-jest\/build\/index.js\",\r\n          {}\r\n        ],\r\n        [\r\n          \"^.+\\\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/assetFileTransformer.js\",\r\n          {}\r\n        ]\r\n      ],\r\n      \"transformIgnorePatterns\": [\r\n        \"node_modules\/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?\/.*|@expo-google-fonts\/.*|react-navigation|@react-navigation\/.*|@unimodules\/.*|unimodules|sentry-expo|native-base|react-native-svg)\"\r\n      ],\r\n      \"watchPathIgnorePatterns\": []\r\n    },\r\n    {\r\n      \"automock\": false,\r\n      \"cache\": true,\r\n      \"cacheDirectory\": \"\/private\/var\/folders\/hk\/z614k7h119n33vqm4smys2p00000gn\/T\/jest_dx\",\r\n      \"clearMocks\": false,\r\n      \"collectCoverageFrom\": [],\r\n      \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n      \"coveragePathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"cwd\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"detectLeaks\": false,\r\n      \"detectOpenHandles\": false,\r\n      \"displayName\": {\r\n        \"name\": \"Android\",\r\n        \"color\": \"blueBright\"\r\n      },\r\n      \"errorOnDeprecated\": false,\r\n      \"extensionsToTreatAsEsm\": [],\r\n      \"fakeTimers\": {\r\n        \"enableGlobally\": false\r\n      },\r\n      \"forceCoverageMatch\": [],\r\n      \"globals\": {},\r\n      \"haste\": {\r\n        \"defaultPlatform\": \"android\",\r\n        \"platforms\": [\r\n          \"android\",\r\n          \"native\"\r\n        ]\r\n      },\r\n      \"id\": \"a96109535fbd199d54aadb624aba6aec\",\r\n      \"injectGlobals\": true,\r\n      \"moduleDirectories\": [\r\n        \"node_modules\"\r\n      ],\r\n      \"moduleFileExtensions\": [\r\n        \"android.ts\",\r\n        \"android.tsx\",\r\n        \"android.js\",\r\n        \"android.jsx\",\r\n        \"native.ts\",\r\n        \"native.tsx\",\r\n        \"native.js\",\r\n        \"native.jsx\",\r\n        \"ts\",\r\n        \"tsx\",\r\n        \"js\",\r\n        \"jsx\",\r\n        \"json\"\r\n      ],\r\n      \"moduleNameMapper\": [],\r\n      \"modulePathIgnorePatterns\": [],\r\n      \"openHandlesTimeout\": 1000,\r\n      \"prettierPath\": \"prettier\",\r\n      \"resetMocks\": false,\r\n      \"resetModules\": false,\r\n      \"restoreMocks\": false,\r\n      \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"roots\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/__tests__\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/__mocks__\"\r\n      ],\r\n      \"runner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-runner\/build\/index.js\",\r\n      \"sandboxInjectedGlobals\": [],\r\n      \"setupFiles\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/setup.js\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/setup.js\"\r\n      ],\r\n      \"setupFilesAfterEnv\": [],\r\n      \"skipFilter\": false,\r\n      \"slowTestThreshold\": 5,\r\n      \"snapshotFormat\": {\r\n        \"escapeString\": false,\r\n        \"printBasicPrototype\": false\r\n      },\r\n      \"snapshotResolver\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/snapshot\/resolver.android.js\",\r\n      \"snapshotSerializers\": [],\r\n      \"testEnvironment\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/react-native-env.js\",\r\n      \"testEnvironmentOptions\": {},\r\n      \"testLocationInResults\": false,\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*spec.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.android.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.android.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).android.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.native.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.native.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).native.[jt]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"testRegex\": [],\r\n      \"testRunner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-circus\/runner.js\",\r\n      \"transform\": [\r\n        [\r\n          \"^.+\\\\.(js|ts|tsx)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/babel-jest\/build\/index.js\",\r\n          {}\r\n        ],\r\n        [\r\n          \"^.+\\\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/assetFileTransformer.js\",\r\n          {}\r\n        ]\r\n      ],\r\n      \"transformIgnorePatterns\": [\r\n        \"node_modules\/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?\/.*|@expo-google-fonts\/.*|react-navigation|@react-navigation\/.*|@unimodules\/.*|unimodules|sentry-expo|native-base|react-native-svg)\"\r\n      ],\r\n      \"watchPathIgnorePatterns\": []\r\n    },\r\n    {\r\n      \"automock\": false,\r\n      \"cache\": true,\r\n      \"cacheDirectory\": \"\/private\/var\/folders\/hk\/z614k7h119n33vqm4smys2p00000gn\/T\/jest_dx\",\r\n      \"clearMocks\": false,\r\n      \"collectCoverageFrom\": [],\r\n      \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n      \"coveragePathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"cwd\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"detectLeaks\": false,\r\n      \"detectOpenHandles\": false,\r\n      \"displayName\": {\r\n        \"name\": \"Web\",\r\n        \"color\": \"magenta\"\r\n      },\r\n      \"errorOnDeprecated\": false,\r\n      \"extensionsToTreatAsEsm\": [],\r\n      \"fakeTimers\": {\r\n        \"enableGlobally\": false\r\n      },\r\n      \"forceCoverageMatch\": [],\r\n      \"globals\": {},\r\n      \"haste\": {\r\n        \"defaultPlatform\": \"web\",\r\n        \"platforms\": [\r\n          \"web\"\r\n        ]\r\n      },\r\n      \"id\": \"e5f841d836bdadeea32dfb9d6e8e82e8\",\r\n      \"injectGlobals\": true,\r\n      \"moduleDirectories\": [\r\n        \"node_modules\"\r\n      ],\r\n      \"moduleFileExtensions\": [\r\n        \"web.ts\",\r\n        \"web.tsx\",\r\n        \"web.js\",\r\n        \"web.jsx\",\r\n        \"ts\",\r\n        \"tsx\",\r\n        \"js\",\r\n        \"jsx\",\r\n        \"json\",\r\n        \"wasm\"\r\n      ],\r\n      \"moduleNameMapper\": [\r\n        [\r\n          \"^react-native$\",\r\n          \"react-native-web\"\r\n        ]\r\n      ],\r\n      \"modulePathIgnorePatterns\": [],\r\n      \"openHandlesTimeout\": 1000,\r\n      \"prettierPath\": \"prettier\",\r\n      \"resetMocks\": false,\r\n      \"resetModules\": false,\r\n      \"restoreMocks\": false,\r\n      \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"roots\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/__tests__\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/__mocks__\"\r\n      ],\r\n      \"runner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-runner\/build\/index.js\",\r\n      \"sandboxInjectedGlobals\": [],\r\n      \"setupFiles\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/setup-web.js\"\r\n      ],\r\n      \"setupFilesAfterEnv\": [],\r\n      \"skipFilter\": false,\r\n      \"slowTestThreshold\": 5,\r\n      \"snapshotFormat\": {\r\n        \"escapeString\": false,\r\n        \"printBasicPrototype\": false\r\n      },\r\n      \"snapshotResolver\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/snapshot\/resolver.web.js\",\r\n      \"snapshotSerializers\": [],\r\n      \"testEnvironment\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-environment-jsdom\/build\/index.js\",\r\n      \"testEnvironmentOptions\": {},\r\n      \"testLocationInResults\": false,\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*spec.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.web.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.web.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).web.[jt]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"testRegex\": [],\r\n      \"testRunner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-circus\/runner.js\",\r\n      \"transform\": [\r\n        [\r\n          \"^.+\\\\.(js|ts|tsx)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/babel-jest\/build\/index.js\",\r\n          {}\r\n        ],\r\n        [\r\n          \"^.+\\\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/assetFileTransformer.js\",\r\n          {}\r\n        ]\r\n      ],\r\n      \"transformIgnorePatterns\": [\r\n        \"node_modules\/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?\/.*|@expo-google-fonts\/.*|react-navigation|@react-navigation\/.*|@unimodules\/.*|unimodules|sentry-expo|native-base|react-native-svg)\"\r\n      ],\r\n      \"watchPathIgnorePatterns\": []\r\n    }\r\n  ],\r\n  \"globalConfig\": {\r\n    \"bail\": 0,\r\n    \"changedFilesWithAncestor\": false,\r\n    \"ci\": false,\r\n    \"collectCoverage\": false,\r\n    \"collectCoverageFrom\": [\r\n      \"**\/*.{j,t}{s,sx}\",\r\n      \"!**\/node_modules\/**\",\r\n      \"!**\/dist\/**\",\r\n      \"!**\/data\/**\",\r\n      \"!**\/__tests__\/**\",\r\n      \"!**\/__mocks__\/**\",\r\n      \"!**\/src\/components\/**\"\r\n    ],\r\n    \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n    \"coverageProvider\": \"babel\",\r\n    \"coverageReporters\": [\r\n      [\r\n        \"lcov\",\r\n        {\r\n          \"projectRoot\": \"..\/..\"\r\n        }\r\n      ]\r\n    ],\r\n    \"coverageThreshold\": {\r\n      \"global\": {\r\n        \"branches\": 1,\r\n        \"functions\": 1,\r\n        \"lines\": 1,\r\n        \"statements\": 1\r\n      }\r\n    },\r\n    \"detectLeaks\": false,\r\n    \"detectOpenHandles\": false,\r\n    \"errorOnDeprecated\": false,\r\n    \"expand\": false,\r\n    \"findRelatedTests\": false,\r\n    \"forceExit\": false,\r\n    \"json\": false,\r\n    \"lastCommit\": false,\r\n    \"listTests\": false,\r\n    \"logHeapUsage\": false,\r\n    \"maxConcurrency\": 5,\r\n    \"maxWorkers\": 9,\r\n    \"noStackTrace\": false,\r\n    \"nonFlagArgs\": [],\r\n    \"notify\": false,\r\n    \"notifyMode\": \"failure-change\",\r\n    \"onlyChanged\": false,\r\n    \"onlyFailures\": false,\r\n    \"openHandlesTimeout\": 1000,\r\n    \"passWithNoTests\": false,\r\n    \"projects\": [\r\n      {\r\n        \"preset\": \"jest-expo\/ios\",\r\n        \"roots\": [\r\n          \"<rootDir>\",\r\n          \"<rootDir>\/__tests__\",\r\n          \"..\/..\/__mocks__\"\r\n        ],\r\n        \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      },\r\n      {\r\n        \"preset\": \"jest-expo\/android\",\r\n        \"roots\": [\r\n          \"<rootDir>\",\r\n          \"<rootDir>\/__tests__\",\r\n          \"..\/..\/__mocks__\"\r\n        ],\r\n        \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      },\r\n      {\r\n        \"preset\": \"jest-expo\/web\",\r\n        \"roots\": [\r\n          \"<rootDir>\",\r\n          \"<rootDir>\/__tests__\",\r\n          \"..\/..\/__mocks__\"\r\n        ],\r\n        \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      }\r\n    ],\r\n    \"reporters\": [\r\n      [\r\n        \"default\",\r\n        {}\r\n      ],\r\n      [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-junit\/index.js\",\r\n        {\r\n          \"outputDirectory\": \"reports\",\r\n          \"outputName\": \"report.xml\",\r\n          \"ancestorSeparator\": \" \u203a \",\r\n          \"uniqueOutputName\": \"false\",\r\n          \"suiteNameTemplate\": \"{filepath}\",\r\n          \"classNameTemplate\": \"{classname}\",\r\n          \"titleTemplate\": \"{title}\"\r\n        }\r\n      ]\r\n    ],\r\n    \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n    \"runTestsByPath\": false,\r\n    \"seed\": -1190786307,\r\n    \"skipFilter\": false,\r\n    \"snapshotFormat\": {\r\n      \"escapeString\": false,\r\n      \"printBasicPrototype\": false\r\n    },\r\n    \"testFailureExitCode\": 1,\r\n    \"testPathPattern\": \"\",\r\n    \"testSequencer\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/@jest\/test-sequencer\/build\/index.js\",\r\n    \"updateSnapshot\": \"new\",\r\n    \"useStderr\": false,\r\n    \"watch\": false,\r\n    \"watchAll\": false,\r\n    \"watchman\": true,\r\n    \"workerThreads\": false\r\n  },\r\n  \"version\": \"29.6.4\"\r\n}\r\n```\r\n\r\n### Actual behavior\r\n\r\nI see the result below. \r\n\r\nSpecifically, note that `.configs.*.roots`\r\n\r\n```\r\n{\r\n  \"configs\": [\r\n    {\r\n      \"automock\": false,\r\n      \"cache\": true,\r\n      \"cacheDirectory\": \"\/private\/var\/folders\/hk\/z614k7h119n33vqm4smys2p00000gn\/T\/jest_dx\",\r\n      \"clearMocks\": false,\r\n      \"collectCoverageFrom\": [],\r\n      \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n      \"coveragePathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"cwd\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"detectLeaks\": false,\r\n      \"detectOpenHandles\": false,\r\n      \"displayName\": {\r\n        \"name\": \"iOS\",\r\n        \"color\": \"white\"\r\n      },\r\n      \"errorOnDeprecated\": false,\r\n      \"extensionsToTreatAsEsm\": [],\r\n      \"fakeTimers\": {\r\n        \"enableGlobally\": false\r\n      },\r\n      \"forceCoverageMatch\": [],\r\n      \"globals\": {},\r\n      \"haste\": {\r\n        \"defaultPlatform\": \"ios\",\r\n        \"platforms\": [\r\n          \"ios\",\r\n          \"native\"\r\n        ]\r\n      },\r\n      \"id\": \"39dc19bf989cf7416f56fd9b62c54afa\",\r\n      \"injectGlobals\": true,\r\n      \"moduleDirectories\": [\r\n        \"node_modules\"\r\n      ],\r\n      \"moduleFileExtensions\": [\r\n        \"ios.ts\",\r\n        \"ios.tsx\",\r\n        \"ios.js\",\r\n        \"ios.jsx\",\r\n        \"native.ts\",\r\n        \"native.tsx\",\r\n        \"native.js\",\r\n        \"native.jsx\",\r\n        \"ts\",\r\n        \"tsx\",\r\n        \"js\",\r\n        \"jsx\",\r\n        \"json\"\r\n      ],\r\n      \"moduleNameMapper\": [],\r\n      \"modulePathIgnorePatterns\": [],\r\n      \"openHandlesTimeout\": 1000,\r\n      \"prettierPath\": \"prettier\",\r\n      \"resetMocks\": false,\r\n      \"resetModules\": false,\r\n      \"restoreMocks\": false,\r\n      \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"roots\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      ],\r\n      \"runner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-runner\/build\/index.js\",\r\n      \"sandboxInjectedGlobals\": [],\r\n      \"setupFiles\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/setup.js\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/setup.js\"\r\n      ],\r\n      \"setupFilesAfterEnv\": [],\r\n      \"skipFilter\": false,\r\n      \"slowTestThreshold\": 5,\r\n      \"snapshotFormat\": {\r\n        \"escapeString\": false,\r\n        \"printBasicPrototype\": false\r\n      },\r\n      \"snapshotResolver\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/snapshot\/resolver.ios.js\",\r\n      \"snapshotSerializers\": [],\r\n      \"testEnvironment\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/react-native-env.js\",\r\n      \"testEnvironmentOptions\": {},\r\n      \"testLocationInResults\": false,\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*spec.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.ios.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.ios.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).ios.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.native.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.native.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).native.[jt]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"testRegex\": [],\r\n      \"testRunner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-circus\/runner.js\",\r\n      \"transform\": [\r\n        [\r\n          \"^.+\\\\.(js|ts|tsx)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/babel-jest\/build\/index.js\",\r\n          {}\r\n        ],\r\n        [\r\n          \"^.+\\\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/assetFileTransformer.js\",\r\n          {}\r\n        ]\r\n      ],\r\n      \"transformIgnorePatterns\": [\r\n        \"node_modules\/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?\/.*|@expo-google-fonts\/.*|react-navigation|@react-navigation\/.*|@unimodules\/.*|unimodules|sentry-expo|native-base|react-native-svg)\"\r\n      ],\r\n      \"watchPathIgnorePatterns\": []\r\n    },\r\n    {\r\n      \"automock\": false,\r\n      \"cache\": true,\r\n      \"cacheDirectory\": \"\/private\/var\/folders\/hk\/z614k7h119n33vqm4smys2p00000gn\/T\/jest_dx\",\r\n      \"clearMocks\": false,\r\n      \"collectCoverageFrom\": [],\r\n      \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n      \"coveragePathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"cwd\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"detectLeaks\": false,\r\n      \"detectOpenHandles\": false,\r\n      \"displayName\": {\r\n        \"name\": \"Android\",\r\n        \"color\": \"blueBright\"\r\n      },\r\n      \"errorOnDeprecated\": false,\r\n      \"extensionsToTreatAsEsm\": [],\r\n      \"fakeTimers\": {\r\n        \"enableGlobally\": false\r\n      },\r\n      \"forceCoverageMatch\": [],\r\n      \"globals\": {},\r\n      \"haste\": {\r\n        \"defaultPlatform\": \"android\",\r\n        \"platforms\": [\r\n          \"android\",\r\n          \"native\"\r\n        ]\r\n      },\r\n      \"id\": \"a96109535fbd199d54aadb624aba6aec\",\r\n      \"injectGlobals\": true,\r\n      \"moduleDirectories\": [\r\n        \"node_modules\"\r\n      ],\r\n      \"moduleFileExtensions\": [\r\n        \"android.ts\",\r\n        \"android.tsx\",\r\n        \"android.js\",\r\n        \"android.jsx\",\r\n        \"native.ts\",\r\n        \"native.tsx\",\r\n        \"native.js\",\r\n        \"native.jsx\",\r\n        \"ts\",\r\n        \"tsx\",\r\n        \"js\",\r\n        \"jsx\",\r\n        \"json\"\r\n      ],\r\n      \"moduleNameMapper\": [],\r\n      \"modulePathIgnorePatterns\": [],\r\n      \"openHandlesTimeout\": 1000,\r\n      \"prettierPath\": \"prettier\",\r\n      \"resetMocks\": false,\r\n      \"resetModules\": false,\r\n      \"restoreMocks\": false,\r\n      \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"roots\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      ],\r\n      \"runner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-runner\/build\/index.js\",\r\n      \"sandboxInjectedGlobals\": [],\r\n      \"setupFiles\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/setup.js\",\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/setup.js\"\r\n      ],\r\n      \"setupFilesAfterEnv\": [],\r\n      \"skipFilter\": false,\r\n      \"slowTestThreshold\": 5,\r\n      \"snapshotFormat\": {\r\n        \"escapeString\": false,\r\n        \"printBasicPrototype\": false\r\n      },\r\n      \"snapshotResolver\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/snapshot\/resolver.android.js\",\r\n      \"snapshotSerializers\": [],\r\n      \"testEnvironment\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/react-native\/jest\/react-native-env.js\",\r\n      \"testEnvironmentOptions\": {},\r\n      \"testLocationInResults\": false,\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*spec.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.android.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.android.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).android.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.native.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.native.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).native.[jt]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"testRegex\": [],\r\n      \"testRunner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-circus\/runner.js\",\r\n      \"transform\": [\r\n        [\r\n          \"^.+\\\\.(js|ts|tsx)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/babel-jest\/build\/index.js\",\r\n          {}\r\n        ],\r\n        [\r\n          \"^.+\\\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/assetFileTransformer.js\",\r\n          {}\r\n        ]\r\n      ],\r\n      \"transformIgnorePatterns\": [\r\n        \"node_modules\/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?\/.*|@expo-google-fonts\/.*|react-navigation|@react-navigation\/.*|@unimodules\/.*|unimodules|sentry-expo|native-base|react-native-svg)\"\r\n      ],\r\n      \"watchPathIgnorePatterns\": []\r\n    },\r\n    {\r\n      \"automock\": false,\r\n      \"cache\": true,\r\n      \"cacheDirectory\": \"\/private\/var\/folders\/hk\/z614k7h119n33vqm4smys2p00000gn\/T\/jest_dx\",\r\n      \"clearMocks\": false,\r\n      \"collectCoverageFrom\": [],\r\n      \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n      \"coveragePathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"cwd\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"detectLeaks\": false,\r\n      \"detectOpenHandles\": false,\r\n      \"displayName\": {\r\n        \"name\": \"Web\",\r\n        \"color\": \"magenta\"\r\n      },\r\n      \"errorOnDeprecated\": false,\r\n      \"extensionsToTreatAsEsm\": [],\r\n      \"fakeTimers\": {\r\n        \"enableGlobally\": false\r\n      },\r\n      \"forceCoverageMatch\": [],\r\n      \"globals\": {},\r\n      \"haste\": {\r\n        \"defaultPlatform\": \"web\",\r\n        \"platforms\": [\r\n          \"web\"\r\n        ]\r\n      },\r\n      \"id\": \"e5f841d836bdadeea32dfb9d6e8e82e8\",\r\n      \"injectGlobals\": true,\r\n      \"moduleDirectories\": [\r\n        \"node_modules\"\r\n      ],\r\n      \"moduleFileExtensions\": [\r\n        \"web.ts\",\r\n        \"web.tsx\",\r\n        \"web.js\",\r\n        \"web.jsx\",\r\n        \"ts\",\r\n        \"tsx\",\r\n        \"js\",\r\n        \"jsx\",\r\n        \"json\",\r\n        \"wasm\"\r\n      ],\r\n      \"moduleNameMapper\": [\r\n        [\r\n          \"^react-native$\",\r\n          \"react-native-web\"\r\n        ]\r\n      ],\r\n      \"modulePathIgnorePatterns\": [],\r\n      \"openHandlesTimeout\": 1000,\r\n      \"prettierPath\": \"prettier\",\r\n      \"resetMocks\": false,\r\n      \"resetModules\": false,\r\n      \"restoreMocks\": false,\r\n      \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n      \"roots\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      ],\r\n      \"runner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-runner\/build\/index.js\",\r\n      \"sandboxInjectedGlobals\": [],\r\n      \"setupFiles\": [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/setup-web.js\"\r\n      ],\r\n      \"setupFilesAfterEnv\": [],\r\n      \"skipFilter\": false,\r\n      \"slowTestThreshold\": 5,\r\n      \"snapshotFormat\": {\r\n        \"escapeString\": false,\r\n        \"printBasicPrototype\": false\r\n      },\r\n      \"snapshotResolver\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/snapshot\/resolver.web.js\",\r\n      \"snapshotSerializers\": [],\r\n      \"testEnvironment\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-environment-jsdom\/build\/index.js\",\r\n      \"testEnvironmentOptions\": {},\r\n      \"testLocationInResults\": false,\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*spec.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*spec.web.[jt]s?(x)\",\r\n        \"**\/__tests__\/**\/*test.web.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).web.[jt]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      \"testRegex\": [],\r\n      \"testRunner\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-circus\/runner.js\",\r\n      \"transform\": [\r\n        [\r\n          \"^.+\\\\.(js|ts|tsx)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/babel-jest\/build\/index.js\",\r\n          {}\r\n        ],\r\n        [\r\n          \"^.+\\\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$\",\r\n          \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-expo\/src\/preset\/assetFileTransformer.js\",\r\n          {}\r\n        ]\r\n      ],\r\n      \"transformIgnorePatterns\": [\r\n        \"node_modules\/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?\/.*|@expo-google-fonts\/.*|react-navigation|@react-navigation\/.*|@unimodules\/.*|unimodules|sentry-expo|native-base|react-native-svg)\"\r\n      ],\r\n      \"watchPathIgnorePatterns\": []\r\n    }\r\n  ],\r\n  \"globalConfig\": {\r\n    \"bail\": 0,\r\n    \"changedFilesWithAncestor\": false,\r\n    \"ci\": false,\r\n    \"collectCoverage\": false,\r\n    \"collectCoverageFrom\": [\r\n      \"**\/*.{j,t}{s,sx}\",\r\n      \"!**\/node_modules\/**\",\r\n      \"!**\/dist\/**\",\r\n      \"!**\/data\/**\",\r\n      \"!**\/__tests__\/**\",\r\n      \"!**\/__mocks__\/**\",\r\n      \"!**\/src\/components\/**\"\r\n    ],\r\n    \"coverageDirectory\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\/coverage\",\r\n    \"coverageProvider\": \"babel\",\r\n    \"coverageReporters\": [\r\n      [\r\n        \"lcov\",\r\n        {\r\n          \"projectRoot\": \"..\/..\"\r\n        }\r\n      ]\r\n    ],\r\n    \"coverageThreshold\": {\r\n      \"global\": {\r\n        \"branches\": 1,\r\n        \"functions\": 1,\r\n        \"lines\": 1,\r\n        \"statements\": 1\r\n      }\r\n    },\r\n    \"detectLeaks\": false,\r\n    \"detectOpenHandles\": false,\r\n    \"errorOnDeprecated\": false,\r\n    \"expand\": false,\r\n    \"findRelatedTests\": false,\r\n    \"forceExit\": false,\r\n    \"json\": false,\r\n    \"lastCommit\": false,\r\n    \"listTests\": false,\r\n    \"logHeapUsage\": false,\r\n    \"maxConcurrency\": 5,\r\n    \"maxWorkers\": 9,\r\n    \"noStackTrace\": false,\r\n    \"nonFlagArgs\": [],\r\n    \"notify\": false,\r\n    \"notifyMode\": \"failure-change\",\r\n    \"onlyChanged\": false,\r\n    \"onlyFailures\": false,\r\n    \"openHandlesTimeout\": 1000,\r\n    \"passWithNoTests\": false,\r\n    \"projects\": [\r\n      {\r\n        \"preset\": \"jest-expo\/ios\",\r\n        \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      },\r\n      {\r\n        \"preset\": \"jest-expo\/android\",\r\n        \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      },\r\n      {\r\n        \"preset\": \"jest-expo\/web\",\r\n        \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\"\r\n      }\r\n    ],\r\n    \"reporters\": [\r\n      [\r\n        \"default\",\r\n        {}\r\n      ],\r\n      [\r\n        \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/jest-junit\/index.js\",\r\n        {\r\n          \"outputDirectory\": \"reports\",\r\n          \"outputName\": \"report.xml\",\r\n          \"ancestorSeparator\": \" \u203a \",\r\n          \"uniqueOutputName\": \"false\",\r\n          \"suiteNameTemplate\": \"{filepath}\",\r\n          \"classNameTemplate\": \"{classname}\",\r\n          \"titleTemplate\": \"{title}\"\r\n        }\r\n      ]\r\n    ],\r\n    \"rootDir\": \"\/Users\/dancrumb\/Projects\/Sutro\/packages\/interpreter\",\r\n    \"runTestsByPath\": false,\r\n    \"seed\": 382697755,\r\n    \"skipFilter\": false,\r\n    \"snapshotFormat\": {\r\n      \"escapeString\": false,\r\n      \"printBasicPrototype\": false\r\n    },\r\n    \"testFailureExitCode\": 1,\r\n    \"testPathPattern\": \"\",\r\n    \"testSequencer\": \"\/Users\/dancrumb\/Projects\/Sutro\/node_modules\/@jest\/test-sequencer\/build\/index.js\",\r\n    \"updateSnapshot\": \"new\",\r\n    \"useStderr\": false,\r\n    \"watch\": false,\r\n    \"watchAll\": false,\r\n    \"watchman\": true,\r\n    \"workerThreads\": false\r\n  },\r\n  \"version\": \"29.6.4\"\r\n}\r\n```\r\n\r\n### Additional context\r\n\r\nExplicitly setting `roots` in the `projects` property of the config file gets the desired result, but this points to the problem.\r\n\r\nEither the copying of `roots` to the `ProjectConfig`s of each `project` is broken, or the process by which this value is copied over is unintuitive (it would seem reasonable that it would be copied or merged with anything in the preset.\r\n\r\nSince this process is undocumented, it's unclear whether this is working as designed, and the process needs documenting, or whether this is indeed a bug and needs fixing.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 13.5.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 18.17.1 - ~\/.nvm\/versions\/node\/v18.17.1\/bin\/node\r\n    Yarn: 3.6.2 - ~\/.nvm\/versions\/node\/v18.17.1\/bin\/yarn\r\n    npm: 9.6.7 - ~\/.nvm\/versions\/node\/v18.17.1\/bin\/npm\r\n```\r\n","comments":["As a side note, it seems likely that this is not unique to `roots`, but I couldn't say for sure","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is only stale because it hasn't been responded to. The issues is still relevant\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Bumping again, because it's only stale because it has been ignored ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still a bug ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still a bug","I have the same issue too.","I have the same problem, too. It seems that my `setupFiles` property is not correctly copied into the resulting Jest config.","On another note: I'm experiencing that jest (v29.7.0) also doesn't copy `transform` rules into projects. Is this actually expected?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: Constructing a mocked class does not return an object typed as a mock, but rather one typed with the original class' type","body":"### Version\r\n\r\n`jest` 29.6.4 \/ `jest-mock` 29.6.3\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone this test repo https:\/\/github.com\/ollien\/jest-mock-typing-repro\r\n2. Run `npm ci`\r\n3. Run `npx jest`, and watch the compilation fail\r\n\r\n### Expected behavior\r\n\r\nGiven the following snippet (in the repo, but I am duplicating it here for posterity's sake)\r\n\r\n```ts\r\nimport { MockedObject, ModuleMocker } from 'jest-mock';\r\n\r\nclass Foo {\r\n  bar() {}\r\n}\r\n\r\nconst moduleMocker = new ModuleMocker(global);\r\n\r\ntest('my code works', () => {\r\n  const mockMetadata = moduleMocker.getMetadata(Foo)!;\r\n  const mockClass = moduleMocker.generateFromMetadata(mockMetadata);\r\n  const x: MockedObject<Foo> = new mockClass();\r\n})\r\n```\r\n\r\nI would expect to be able to assign the mocked class to `x`, as this is what the type signatures imply (and behavior is in reality).\r\n\r\n### Actual behavior\r\n\r\nThe code fails to compile, with an error that the class `Foo` is not assignable to `MockedObject<Foo>`\r\n\r\n```\r\n$ npx jest\r\nts-jest[config] (WARN) message TS151001: If you have issues related to imports, you should consider setting `esModuleInterop` to `true` in your TypeScript configuration file (usually `tsconfig.json`). See https:\/\/blogs.msdn.microsoft.com\/typescript\/2018\/01\/31\/announcing-typescript-2-7\/#easier-ecmascript-module-interoperability for more information.\r\n FAIL  .\/test.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    test.spec.ts:12:9 - error TS2322: Type 'Foo' is not assignable to type 'MockedObject<Foo>'.\r\n      Type 'Foo' is not assignable to type '{ bar: MockedFunction<() => void>; }'.\r\n        Types of property 'bar' are incompatible.\r\n          Type '() => void' is not assignable to type 'MockedFunction<() => void>'.\r\n            Type '() => void' is not assignable to type 'MockInstance<() => void>'.\r\n\r\n    12   const x: MockedObject<Foo> = new mockClass();\r\n               ~\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        1.504 s\r\n```\r\n\r\n### Additional context\r\n\r\nAs a preface: I'm fairly sure I'm using `ModuleMocker.generateFromMetadata` properly (mostly due to the way [this test is written](https:\/\/github.com\/jestjs\/jest\/blob\/f2c78d04ff35688571a66d66c8a2c7c17a095444\/packages\/jest-mock\/src\/__tests__\/index.test.ts#L157-L171)), but it's entirely possible I'm missing something.\r\n\r\nI've done some digging into the type declarations of what I'm working with. This is why I think what I'm doing should work:\r\n\r\n1. [`generateFromMetadata<T>`](https:\/\/github.com\/jestjs\/jest\/blob\/f2c78d04ff35688571a66d66c8a2c7c17a095444\/packages\/jest-mock\/src\/index.ts#L1005) returns a `Mocked<T>`.\r\n2. Because I am passing a [`ClassLike`](https:\/\/github.com\/jestjs\/jest\/blob\/f2c78d04ff35688571a66d66c8a2c7c17a095444\/packages\/jest-mock\/src\/index.ts#L42) (that is, the class value itself), this [resolves to a `MockedClass<T>`](https:\/\/github.com\/jestjs\/jest\/blob\/f2c78d04ff35688571a66d66c8a2c7c17a095444\/packages\/jest-mock\/src\/index.ts#L86-L92))\r\n3. The definition of [`MockedClass`](https:\/\/github.com\/jestjs\/jest\/blob\/f2c78d04ff35688571a66d66c8a2c7c17a095444\/packages\/jest-mock\/src\/index.ts#L58-L61) implies that constructing the class should return a `Mocked<InstanceType<T>>` (which I believe to be equivalent to a `MockObject<T>` in this context, but changing the type of `x` to `Mocked<InstanceType<typeof Foo>>` fails to compile for the same reason.)\r\n\r\nThough I am not certain, I believe (3) is what causes the issue; a class itself is not a function which returns an instance of itself, but rather _its constructor_ is.\r\n\r\nSomething else of note: if you remove the single method from the class Foo, the above sample _does_ compile.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 6.4 Fedora Linux 38 (Thirty Eight)\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz\r\n  Binaries:\r\n    Node: 18.16.1 - \/usr\/bin\/node\r\n    Yarn: 1.22.17 - ~\/.local\/npm\/bin\/yarn\r\n    npm: 9.2.0 - ~\/.local\/npm\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.6.4 => 29.6.4 \r\n```","comments":["Thanks for report. Interesting case!\r\n\r\nQuick idea: `MockedClass` type is missing `new` signature. Trying to construct it with `new` returns `Foo` instead of `MockInstance<Foo>`. (edit: this should be `MockInstance`, not `MockedObject` or I missed something?) Fix looks like this:\r\n\r\n```diff\r\nexport type MockedClass<T extends ClassLike> = MockInstance<\r\n  (...args: ConstructorParameters<T>) => Mocked<InstanceType<T>>\r\n> &\r\n+ (new (...args: ConstructorParameters<T>) => MockInstance<InstanceType<T>>) &\r\n  MockedObject<T>;\r\n```\r\n\r\nNot sure if `MockedObject<T>` should stay here or not? Hm.. Probably it should, but perhaps `MockedFunction` needs call signature as well? Not sure, here. To figure out I have to live with this a bit more.\r\n\r\nThis is complex, but fun to play with. Feedback and ideas are more than welcome (;","You'd know better than me, but as an outside observer looking in, I believe that it should be `MockedObject`, not only a `MockInstance`, as the latter is (as far as I can tell from the definition), an instance of a mock (the type parameter `T` seems to refer to a function), while `MockedObject` seems to be a ... well, mocked object, which gets wrapped by a `MockInstance`.\r\n\r\nThat said, I do think that the signature in what you're proposing likely needs to return `MockInstance<Mocked<InstanceType<T>>>`, so that the instance's properties are also marked as mocks. Not 100%, though.","Ups.. You are right. The initial idea that the return type should be `Mocked<InstanceType<T>>` seems to be correct. `MockInstance` is a different thing.\r\n\r\nI was reshaping the `MockedClass` in  #13123. Not so long ago, but can\u2019t recall details already. I will look through carefully in few days.","I was trying to fix the typings, but that is rather complicated to figure out. Current type tests are failing, if the change gets implemented as we discussed above. At the moment my time is limited, so I will try to come back later.\r\n\r\nOr perhaps someone else would be interested to take a look?","Hi, I'd like to take a look into this!","Sure. Give it try!\r\n\r\nThe typings live in this file: https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-mock\/src\/index.ts\r\n\r\nTo run the type tests: build the library and run `test-types`. Note that any changes will be visible in test results only after (re)building. Relevant type test files can be found in this directory: https:\/\/github.com\/jestjs\/jest\/tree\/main\/packages\/jest-mock\/__typetests__"],"labels":[":bug: Bug","Help Wanted","TypeScript","Pinned"]},{"title":"[Bug]: issue when using isolateModules with an auto mocked node module in __mocks__ folder","body":"### Version\n\n27.2.1 & 29.6.2 & 29.6.3\n\n### Steps to reproduce\n\nThe issue is very similar to #11873. However, it seems to still have issue when using a node module automatically mocked via the file in `__mocks__` folder. \r\n\r\nI made a [mini repo ](https:\/\/github.com\/Yupeng-li\/jest-isolate-modules-mini-repo) to reproduce the issue. \n\n### Expected behavior\n\nI expect this test to pass \r\n\r\n```ts\r\n\/* in __mocks__ folder, lodash is mocked by the file below\r\n   lodash.ts  \r\n*\/\r\n\r\nimport * as exportsFromIndexFile from \".\/index\";\r\nimport {range} from 'lodash'\r\n\r\nlet indexModule : typeof exportsFromIndexFile\r\n\r\nbeforeEach(()=>{\r\n    jest.isolateModules(()=>{\r\n        indexModule = require('.\/index')\r\n    })\r\n})\r\n\r\nit('mocks for a library in node_modules are not working', () => {\r\n    indexModule.helloWorld(). \/\/ helloWorld is using lodash.range inside \r\n    expect(range).toHaveBeenCalled()  \r\n});\r\n```\r\n\n\n### Actual behavior\n\nBut `expect(range).toHaveBeenCalled()` failed. It says `lodash.range` was not called. If I use debugger, I can see that the it's been called. \n\n### Additional context\n\nif the module is mocked via `jest.mock('module-name')`, it seems to work fine. \n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.5.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 18.17.0 - ~\/Library\/Caches\/fnm_multishells\/24849_1670237417415\/bin\/node\r\n    Yarn: 1.22.19 - \/usr\/local\/bin\/yarn\r\n    npm: 9.6.7 - ~\/Library\/Caches\/fnm_multishells\/24849_1670237417415\/bin\/npm\r\n  npmPackages:\r\n    jest: 29.6.3 => 29.6.3\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","To keep this issue open.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still needs attention \r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still needs triage","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still needs triage","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Feature]: Deprecate `jest-repl`","body":"### \ud83d\ude80 Feature Proposal\n\nIt's (IMO) not providing much value. It was supposed to be deprecated in v28 (then v29), but I forgot both times \ud83d\ude05 \r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/pull\/12735#issuecomment-1108556747\r\n\r\nFiling an issue and adding to the milestone should _hopefully_ make sure it's not forgotten.\n\n### Motivation\n\nLess code is better\n\n### Example\n\n_No response_\n\n### Pitch\n\nn\/a","comments":["I could help to solve this too.","Thanks! A PR removing all traces of it would be very much welcome \ud83d\udc4d","I wonder, can it be useful for Detox? We were thinking recently about REPL feature for E2E tests.\r\n\r\n- https:\/\/github.com\/wix\/Detox\/issues\/4239"],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Bug]: workerThreads break --watch-all when function does not meet expected.","body":"### Version\n\n29.6.2\n\n### Steps to reproduce\n\n1. Clone my repo at: https:\/\/github.com\/roffelund\/jest-function-expect-bug\r\n2. yarn\r\n3. yarn test test.test.js --watch-all\r\n\n\n### Expected behavior\n\n![Screenshot 2023-08-17 at 10 36 09](https:\/\/github.com\/jestjs\/jest\/assets\/24315490\/0b764f0d-753f-43d5-96ea-1be53ec50b8d)\r\n\r\nI expected the test to show that the expected and received do not match. \n\n### Actual behavior\n\n![Screenshot 2023-08-17 at 10 35 19](https:\/\/github.com\/jestjs\/jest\/assets\/24315490\/4dafb5c7-3f41-4024-ab2f-e5500f5fac28)\r\n\r\nTest stops running with exception\n\n### Additional context\n\nThis only happens when running with workers. Turning off workers expected behaviour works fine.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.4\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 18.17.0 - \/opt\/homebrew\/opt\/node@18\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 9.6.7 - \/opt\/homebrew\/opt\/node@18\/bin\/npm\r\n  npmPackages:\r\n    jest: 29.6.2 => 29.6.2\n```\n","comments":["Thanks for the reproduction! I saw this happening, but didn\u2019t had time to figure out what was the exact cause. Huge objects were around, so it was difficult to reason about.\r\n\r\nSeems like serialization fails somewhere in the threads worker, because all is smooth with `workerThreads: false`.","By the way, could you mention in the title that the issue is specifically related with `workerThreads`, not just workers in general.","> Thanks for the reproduction! I saw this happening, but didn\u2019t had time to figure out what was the exact cause. Huge objects were around, so it was difficult to reason about.\r\n> \r\n> Seems like serialization fails somewhere in the threads worker, because all is smooth with `workerThreads: false`.\r\n\r\nTook some debugging to narrow it down. As you say workerThreads: false all is smooth sailing.","Hey, I tried to fix this issue here, would appreciate any feedback\/suggestions\r\nhttps:\/\/github.com\/jestjs\/jest\/pull\/14436\/"],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Bug]: Untested code is not transformed when using v8 coverage collector","body":"### Version\r\n\r\n29.5.0\r\n\r\n### Steps to reproduce\r\n\r\nRepro code is in a branch on my reproduce-issues repo: https:\/\/github.com\/spalger\/reproduce-issues\/tree\/jest\/v8-coverage-untested-ts-files\r\n\r\n1. clone repro branch:\r\n\r\n    ```\r\n    git clone --branch jest\/v8-coverage-untested-ts-files git@github.com:spalger\/reproduce-issues.git\r\n    ```\r\n\r\n2. Install packages and run tests\r\n\r\n    ```\r\n    npm i && npm run test\r\n    ```\r\n\r\n\r\n### Expected behavior\r\n\r\n`types.ts` only includes a single interface, so the file should should be ignored for the purpose of coverage calculation.\r\n\r\n### Actual behavior\r\n\r\n1. `types.ts` is not imported during test execution because TypeScript strips type-only imports by default\r\n2.  when coverage is being calculated the source of the file is not transformed using the configured transformer\r\n3. `types.ts` is reported as missing coverage on lines 1-3\r\n\r\n### Additional context\r\n\r\nThis only happens when using the v8 coverage collection because of this condition: https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-reporters\/src\/CoverageReporter.ts#L188-L190\r\n\r\nA workaround is available: set the `\"importsNotUsedAsValues\": \"preserve\"` compiler option when setting up `ts-jest` ensuring that all types referenced in the code base will be imported during tests.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: macOS 14.0\r\n  CPU: (10) arm64 Apple M1 Pro\r\nBinaries:\r\n  Node: 18.14.2 - ~\/.nvm\/versions\/node\/v18.14.2\/bin\/node\r\n  Yarn: 1.22.19 - ~\/.nvm\/versions\/node\/v18.14.2\/bin\/yarn\r\n  npm: 9.6.0 - ~\/.nvm\/versions\/node\/v18.14.2\/bin\/npm\r\n  pnpm: 8.6.0 - ~\/.nvm\/versions\/node\/v18.14.2\/bin\/pnpm\r\nnpmPackages:\r\n  jest: ^29.5.0 => 29.5.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue in jest 29.7.0: https:\/\/github.com\/spalger\/reproduce-issues\/commit\/33880e7f2a39e64608118654bef19f8297318039","Seeing this too","Not sure how to handle this. There is no `readInitialCoverage` equivalent for v8 coverage. Also, it'd make a coverage run be slower as we'd need to transform the file.\r\n\r\nI think the easiest is to just add type only files to `coveragePathIgnorePatterns` config"],"labels":[":bug: Bug","Help Wanted","Needs Triage","Pinned"]},{"title":"[Bug]: Mocking bare specifier fails when dependency is provided by `npm link`","body":"### Version\n\n29.4.1\n\n### Steps to reproduce\n\nThis is a complex reproduction; you will need to be able to `npm publish` a scoped package somewhere then `npm install` it.\r\n\r\n1. Clone https:\/\/github.com\/thw0rted\/jest-issue-test-util (main branch) and https:\/\/github.com\/thw0rted\/issue-examples (jest-npm-link branch).\r\n2. Edit `package.json` in the test-util directory and set the package name to a scope in which you have publishing rights.\r\n3. `npm install` in the test-util directory, then `npm publish`.\r\n4. `npm install` in the issue-examples directory.\r\n5. `npm test` in issue-examples; the test should pass.\r\n6. In `jest-issue-test-util`, `npm link .`, then in the issue-examples directory, `npm link @myscope\/test-util`, where \"myscope\/test-util\" matches the package name edited in step 2.\r\n7. `npm test` in the issue-examples directory; the test will fail.\n\n### Expected behavior\n\nI expect the mock specified by `jest.mock('config', ...)` to be used consistently for a given specifier.\n\n### Actual behavior\n\nThe mock is used by code in the same package where it is declared, but is not used in the consuming application.\n\n### Additional context\n\nI stepped into the mock resolution logic a bit, and it looks like the \"should mock\" determination is made based on the path to the resolved package.  The problem is that `jest.mock('config')` in the test-util package points to a `node_modules` relative to the library definition (i.e. `\/workspace\/test-util\/node_modules\/...`) when the library is referenced via `npm link`, but when the consuming code `require`s the library, it does so from its own `node_modules`, i.e. `\/workspace\/issue-examples\/node_modules\/...`.  When the library is installed via `npm install`, it winds up as a peer of `config` in the consumer's `node_modules`, the \"should mock\" check uses the correct module specifier.\r\n\r\nI'm not sure what Jest can do to fix this.  Maybe this just needs a warning in the `jest.mock` documentation, or maybe it's possible to actually detect when a mock is configured against a node_modules directory under a different root?\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 10 10.0.22621\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 18.16.1 - ~\\AppData\\Local\\fnm_multishells\\5228_1690832199131\\node.EXE\r\n    npm: 9.5.1 - ~\\AppData\\Local\\fnm_multishells\\5228_1690832199131\\npm.CMD\r\n  npmPackages:\r\n    jest: ^29.3.1 => 29.4.1\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still pertinent, is there any way to get this looked at for triage?","> I'm not sure what Jest can do to fix this.\n\nThis line made me think that you are fine to live with this limitation. I'm also not sure if there is a solution for this problem. ","I'm afraid I don't know enough Jest internals to speculate whether this can be \"fixed\", in the sense of making the `mock` call \"do what I mean\".  It does seem like it should at least be practical to e.g. set up a singleton that tracks all mocked modules during a run and warn\/fail (?) when two identical invocations of `mock('foo')` wind up mocking out different absolute paths.\r\n\r\nTaking `npm link` out of the equation for a moment, how does this work with different versions of transitive deps?  I have a biggish project that contains no fewer than 3 incompatible versions of the `semver` library -- `eslint` uses 5.x, `make-dir` uses 6.x, `jsonwebtoken` uses 7.x, etc.  If I `mock('semver')`, then use library exports from both `eslint` and `jsonwebtoken` in my tests, will Jest intercept require\/import calls for both `.\/node_modules\/eslint\/node_modules\/semver` and `.\/node_modules\/jsonwebtoken\/node_modules\/semver`?  (What about globally-installed modules?)\r\n\r\nI guess what I would like to see for a resolution is, either `mock('semver')` makes `require('semver')` always return a mock regardless of where it was invoked, or Jest has documentation to make clear when that might not be the case (and maybe an update to log a warning when it happens).","Welcome to open source. I think there are just two ways: dive into internals to figure out, or accept that there are limitations.\r\n\r\nOf course, it can be that someone who knows everything will chime in and will write detailed documentation for each and every case out there. Let\u2019s see.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","If there's no form of `mock(...)` that lets me mock out every require\/import for a named library, maybe there's an explicit form that says to mock out one in a sibling directory by absolute path?  Or maybe there's a mode where I can run Jest (or the parent Node process?) so it won't resolve softlinks to real paths?","I'm afraid the reproduction steps, while clear, are a bit much to me \ud83d\ude05 `npm link` just creates a symbolic link, right? Could we emulate this without the entire \"rename & publish\" step? Some sort of `ln -s ..\/my-pkg node_modules\/my-pkg` or some such?","I think the root issue here might be due to calling `jest.mock` from a script that lives outside the calling project's working directory.  In the repro, the library `jest-issue-test-util` exports a mock-setup function that calls `jest.mock`, pointing to a dependency of the library.  I made the complex repro because I couldn't find an existing library that follows this pattern.  (Maybe this means I should rethink my approach in the first place?)\r\n\r\nYour suggestion may well work, but I'm having trouble getting `ln` (or `fs.symlinkSync`) to create an actual softlink on Windows.  Somehow, `npm link` does it, but I can't seem to reproduce it on my own."],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"[Bug]: Since Jest 29.1.0 comparing an array of complex class instances throws an error \"TypeError: this is not a typed array\"","body":"### Version\n\n29.1.0\n\n### Steps to reproduce\n\nReproduction of the bug:\r\n\r\n1. Clone [this repo](https:\/\/github.com\/elchininet\/isometric). `git clone git@github.com:elchininet\/isometric.git`\r\n2. Checkout the branch [bug-jest](https:\/\/github.com\/elchininet\/isometric\/tree\/bug-jest). `git checkout bug-jest`\r\n3. Install dependencies: `yarn`\r\n4. Run this small test: `yarn test tests\/buggy-test.test.ts`\r\n5. All the tests will pass without any issue (same test using `toEqual`, `toStrictEqual` and `toMatchObject`)\r\n6. Update jest in `package.json` from version `29.0.3` to version `29.1.0`\r\n7. Run `yarn` again to update the package\r\n8. Run again the small test: `yarn test tests\/buggy-test.test.ts`\r\n9. The console will hang for a while and at the end it will fail in the test `Test with toMatchObject`\r\n\r\n<img width=\"625\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/3728220\/7509ad30-4c41-4a78-b7f6-97d30b579b35\">\n\n### Expected behavior\n\nJest should not fail with `toMatchObject` with an array of class instances, it should pass as `toEqual` or `toStrictEqual` pass.\n\n### Actual behavior\n\nJest fails to compare an array of class instances with `toMatchObject`. It even fails with:\r\n\r\n```javascript\r\nexpect([rectangle]).toMatchObject([rectangle]);\r\n```\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem: Apple M1 Pro\r\nBinaries:\r\n* Node: v16.15.1\r\n* Yarn: 1.22.19\r\n* npm: 8.11.0\r\nnpm packages:\r\njest `29.0.3` => `29.1.0`\n```\n","comments":["There is something odd inside the `rectangle.element` prop, because the following is passing:\r\n\r\n```ts\r\nexpect(rectangle).toMatchObject({ ...rectangle, element: expect.anything() })\r\n```\r\n\r\nIf I do `console.log(rectangle.element)` all it shows is: `SVGElement {}`. Hard to say what is going on there.","Hi @mrazauskas,\r\n\r\nThanks for your response. The oddness occurs with any class from the library, I did the example with the rectangle just to make it short but it breaks in any place that I use `toMatchObject` with `children`property (almost all the classes inherith from the same base class). That has not been occurring until version `29.1.0` and the library has been working with that matcher since [a long time ago](https:\/\/github.com\/elchininet\/isometric\/commit\/447d4bde6668bad4f9247d2879b4e832f6835302#diff-590598a11f0c267f5125b38c5dc1ac3a3c961d4a7baf05cac44a95071236a30dR92) (`jest 28.x.x`).\r\n\r\nSomething curious is that it doesn\u2018t fail with `toEqual` or `toStrictEqual`, it is just with `toMatchObject`, and all of them check that property.\r\n\r\nWhat you are getting with the `console.log` is the same that you get if you do this inside a test:\r\n\r\n```javascript\r\nconsole.log( document.createElementNS('http:\/\/www.w3.org\/2000\/svg', 'path') ); \/\/ SVGElement {}\r\n```\r\nElement will be always an `SVGElement`.\r\n\r\nRegards","As you discovered that the issue is with the `element` property, I did a small test and this also fails:\r\n\r\n```javascript\r\nit('Test with toMatchObject', (): void => {\r\n    const a = document.createElementNS('http:\/\/www.w3.org\/2000\/svg', 'path');\r\n    expect(a).toMatchObject(a);\r\n});\r\n```\r\n\r\nIt doesn\u2018t fail with `toBe`, `toEqual` or `toStrictEqual` (and it doesn\u2018t fail either with `jest 29.0.3`).","Thanks for the idea. I was able to recreate the issue in an empty repro only with `jest` and `jest-environment-jsdom` installed:\r\n\r\n```js\r\n\/**\r\n * @jest-environment jsdom\r\n *\/\r\n\r\ntest(\"document.createElementNS\", () => {\r\n  const x = document.createElementNS(\"http:\/\/www.w3.org\/1999\/xhtml\", \"div\");\r\n  const y = document.createElementNS(\"http:\/\/www.w3.org\/1999\/xhtml\", \"div\");\r\n\r\n  expect(x).toMatchObject(y);\r\n});\r\n```\r\n\r\nI was using Yarns `resolutions` and the problem narrowed down to `@jest\/expect-utils` package:\r\n\r\n- with `\"@jest\/expect-utils\": \"29.3.1\"` the test is passing;\r\n- upgrading to `\"@jest\/expect-utils\": \"29.4.0\"` gives: \"serializes to the same string\" (possibly #13639);\r\n- upgrading to `\"@jest\/expect-utils\": \"29.4.1\"` gives: \"Maximum call stack size exceeded\" (possibly #13810);\r\n- `\"@jest\/expect-utils\": \"29.4.1\"` has no changes so it trows the same error;\r\n- upgrading to `\"@jest\/expect-utils\": \"29.4.3\"` trips up Jest event more, it hangs up just like you described (possibly #13824).\r\n\r\nIf I got it right, the changes I am pointing to are related (or mostly related) with the `toMatchObject()` matcher. That explains why all works well with other matchers.\r\n\r\n---\r\n\r\nCould you confirm if adding the following to the `package.json` allows to to upgrade Jest:\r\n\r\n```json\r\n\"resolutions\": {\r\n  \"@jest\/expect-utils\": \"29.3.1\"\r\n}\r\n```","The object returned by JSDOM's `createElementNS()` method has `_globalObject.window` object. This object has more stuff installed by JSDOM and those have `_globalObject.window` prop. So here is what I tried:\r\n\r\n```js\r\n\/**\r\n * @jest-environment jsdom\r\n *\/\r\n\r\ntest(\"globalThis\", () => {\r\n  expect(globalThis).toMatchObject(globalThis);\r\n});\r\n```\r\n\r\nIt passes with `\"@jest\/expect-utils\": \"29.3.1\"`, but freezes Jest with `\"@jest\/expect-utils\": \"29.4.0\"`.","Hi @mrazauskas,\r\nYes, with `@jest\/expect-utils` `29.3.1` the issue doesn\u2018t occur and I can even upgrade to `jest` `29.6.2` without any issues.\r\nThat is aligned with my debugging yesterday, I placed breakpoints and I noticed that the issue seems to be inside `@jest\/expect-utils\/build\/jasmineUtils.js`.\r\nRegards","@mrazauskas,\r\nI didn\u2018t see this comment before.\r\n\r\n>The object returned by JSDOM's createElementNS() method has _globalObject.window object. This object has more stuff installed by JSDOM and those have _globalObject.window prop. So here is what I tried:\r\n\r\nIt could be related to that indeed, as `jest-dom` mimics the real DOM native APIs, `window` has a property named `globalThis` which is a reference to itself, maybe this is the root of the maximum call stack.\r\n\r\n```javascript\r\nwindow === window.globalThis \/\/ true\r\nwindow === window.globalThis.globalThis \/\/ true\r\n```","If I got it right, `jsdom` is using Symbols for information hiding. After #13639 that concept got broken, because `toMatchObject()` now looks at props with Symbol keys. Can be that circular references are not handled well. For instance, `globalThis`\/`window` could be the place which ends up in infinite loop.\r\n\r\n@lpizzinidev @joshkel Would you have a moment to take a look? It seems that support of Symbol property keys broke Jest for users of `jsdom`."],"labels":["Help Wanted",":boom: Regression","Pinned"]},{"title":"[Feature]: disable ts-node","body":"### \ud83d\ude80 Feature Proposal\n\nAdd an option in Jest (maybe via a env variable) to disable enabling `ts-node`.\r\n\r\nAnother option would be to disable the typecheck in `ts-node` in https:\/\/github.com\/jestjs\/jest\/blob\/70b17d2e3d2bf40dd27fecdcdd06c159d26a7c6c\/packages\/jest-config\/src\/readConfigFileAndSetRootDir.ts#L116-L122 (with `transpileOnly: true`)\n\n### Motivation\n\nIn one of my projects, I use `jest` from a script already coded in TS and thus that already has `ts-node` started.\r\nAnd applying a second time within `jest` throws TS errors\r\n\n\n### Example\n\n_No response_\n\n### Pitch\n\nts-node is directly called by the internal of jest so we cannot be modified otherwise","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Pinned"]},{"title":"Mock node modules with node: URL scheme","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\nAllow modules that use `node:` paths, i.e. `node:fs`, to be mocked and mapped to manual mocks appropriately.\r\n\r\nWith Node adopting the aforementioned URL scheme, more users will migrate to it and expect their tools to support it. \r\n\r\nJest already incorporates checks for the URL scheme but not for mapping mocks and module names. \r\n\r\nWith this change, Jest strips the URL when resolving mocks and assigning `moduleID`s, making any of the following test setups in the next section valid and point to the same module.\r\n\r\n[Source issue](https:\/\/github.com\/jestjs\/jest\/issues\/14040)\r\n\r\n## Test plan\r\n\r\nThe change resolves the URL to the module name, so the following 3 e2e tests were added to verify that by checking if the `fs` module was mocked in the following 3 scenarios.\r\n\r\nRealistically, the first scenario is the target use case.\r\n\r\n```js\r\n\/\/ URL scheme for imports and mocks\r\nconst fs = require('node:fs')\r\njest.mock('node:fs')\r\n```\r\n```js\r\n\/\/ URL scheme only when mocking\r\nconst fs = require('fs')\r\njest.mock('node:fs')\r\n```\r\n```js\r\n\/\/ URL scheme only when importing\r\nconst fs = require('node:fs')\r\njest.mock('fs')\r\n```\r\n","comments":["<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: KhaledElmorsy \/ name: Khaled Elmorsy  (6a11f1e1f18ce2a52949b8d2ff3b170682a3c13b, 630d01abe4ceec6a2542f79e936baf7b4c683af4)<\/li><\/ul>","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 630d01abe4ceec6a2542f79e936baf7b4c683af4 |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/64a6e82f6ebee20008db2610 |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-14297--jestjs.netlify.app](https:\/\/deploy-preview-14297--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTE0Mjk3LS1qZXN0anMubmV0bGlmeS5hcHAifQ.r322H0GcTWLsPHjS0K3pOgTrYu7sJSsKDEOeKNzVZTw)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","Did you check if `jest.unmock()` works? It uses resolver\u2019s `getModuleID()` method and this one is not touched in your patch. That\u2019s why I\u2019m asking.\r\n\r\nI found a branch where I was play with this fix. Seemed like it was enough to strip `'node:'` before running the logic of `getMockModule()`, `getMockModuleAsync()`, `getModuleID()` and `getModuleIDAsync()` methods. I had no time to write proper tests, so it can be that I missed something. Just wondering why the changes you made are so complex? It felt like the current logic should handle everything if `'node:'` is removed.","> Did you check if `jest.unmock()` works? It uses resolver\u2019s `getModuleID()` method and this one is not touched in your patch. That\u2019s why I\u2019m asking.\r\n> \r\n> I found a branch where I was play with this fix. Seemed like it was enough to strip `'node:'` before running the logic of `getMockModule()`, `getMockModuleAsync()`, `getModuleID()` and `getModuleIDAsync()` methods. I had no time to write proper tests, so it can be that I missed something. Just wondering why the changes you made are so complex? It felt like the current logic should handle everything if `'node:'` is removed.\r\n\r\nI strip `node:` in `Resolver._getAbsolutePath` which `getModuleID` uses and has a branch for core modules, so it felt right to extend the processing in that branch to generalize it to other methods that could use `_getAbsolutePath`.\r\n\r\nThe two spots where I strip `node:` are `_getAbsolutePath` and in `Runtime.requireMock` before the `moduleName` gets passed to `getMockModule`.\r\n\r\nThe last change was editing `getMockModule(Async)` to always return either mocks or null, because the current logic, after not finding a mock with the passed module name returns either the original module name or the result of passing the original module name into `resolveStubModuleName`. But those two values aren't mocks and force the methods that consume `getMockModule` to get really convoluted to know what `getMockModule` returned.\r\n\r\n\r\n","@mrazauskas I hope I answered your questions well enough. Is there anything more I should do on this PR?","Thanks for the details and for reminder.\r\n\r\nI was trying to look from the distance and to think a bit. These lines made me think:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/70b17d2e3d2bf40dd27fecdcdd06c159d26a7c6c\/packages\/jest-runtime\/src\/index.ts#L1683-L1687\r\n\r\nNow strings are mostly normalized in `jest-resolve`, but sometimes this will happen in `jest-runtime`. Also it can happen in higher or in lower layer. Hm.. The code works, of course. But is `jest-resolve` or `jest-runtime` broken? In general it seems like they are not. They are just tricked by user input.\r\n\r\nWhat if we would *normalize the user input* as the first thing at all the entry spots? That would ensure that we pass clean up data to modules which already do the right job.\r\n","By the way, you don\u2019t have to force push. Commits are squashed when PRs are merged.","I definitely see what you mean in doing it in one place and that would be definite improvement to the codebase. There's a few different methods that take a path as input that would need to changed, like `jest.mock`, `jest.unmock`, etc. Some pass it directly to `Resolver.getModuleID` which normalizes and others like `Runtime.requireMockOrModule` send it in many different directions. Both would benefit from pre-normalization. \r\n\r\nHaving the normalization in only the upper `Runtime` would mean updating those method that pass directly to the resolver and removing its normalization logic. It's doable and should be done but it'll be a lot of changes and needs a good look.\r\n\r\nI was actually meaning to replace the snippet you linked with `Resolver. normalizeCoreModuleSpecifier` and I'm kicking myself for forgetting (good catch).\r\n\r\nI think we should push this fix as is, after replacing that snippet, and then implement the more centralized and widely used normalizer in `Runtime` in a separate PR. Maybe it can have its own open issue so that anyone can jump on that major refactor, if I can't dedicate the time for it.\r\n\r\nWhat do you think?\r\n","Looks like I didn't forget \ud83d\ude06\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/pull\/14297\/commits\/6a11f1e1f18ce2a52949b8d2ff3b170682a3c13b#diff-c0d5b59e96fdc7ffc98405e8afb46d525505bc7b1c24916b5c8482de5a186c00L1707-L1712","You did not forget. This is why I saw these lines. `jest-runtime` was build before the `node:` scheme. Some logic is tweaked a bit, but in general it does not support the `node:` scheme.\r\n\r\nWhy not to implement the support in one go? Not sure why do you see this as major refactor? Just a line should be added for each method which take module name string. What is \"centralized and widely used normalizer\"? Is this those five lines of `normalizeCoreModuleSpecifier()` method or you have plans to normalize something more?\r\n\r\nThat was just an idea. Feel free rethink it or ignore it. Also worth mentioning that I don\u2019t have rights to merge PRs. I can only leave comments here and there (;","I was thinking of potential normalization for other cases than `node:`, but I agree, it's probably just that for now.\r\n\r\nI gave this some more thought and I think both approaches have merits. If a dozen runtime methods pass to the resolver which normalizes in only two methods with only the snippet method being the outlier in the `Runtime`, then it's also clean to consolidate it in the resolver like it is. Both approaches are viable, but I'm okay with leaving it is as is.\r\n\r\nAlso, I really appreciate your comments and insights, it's always good to be met with different approaches to consider and apply. ","@SimenB could you please approve\/merge this PR?","By the way, what happens if `jest.mock('node:fs')` is called on Node.js v14.15 (the lowest supported by Jest)? Calling `require('node:fs')` throws an error. ","I was experimenting with somewhat bigger idea to add support for URL strings and URL objects. That would work for `node:` and `file:` schemas. The change is rather minimal. Curious what you think? See #14332","While I haven't seen URLs being used to import modules, if it works, then there's no reason not to support it fully. \r\n\r\nI you should pause until this PR is merged because of the refactors & corrections, and then expand the resolution logic it adds to account for URL's as you did. I personally feel like these additions could have been added to this PR given how similar the approaches are.\r\n\r\nBut still, it's good to think of more general applications and consider the bigger picture, as well finding the most direct way to address issues.","Hi @KhaledElmorsy @mrazauskas We're blocked on an ESM transition due to https:\/\/github.com\/jestjs\/jest\/issues\/14040 If we come up with a patch, would you like us to try and coordinate between this PR and https:\/\/github.com\/jestjs\/jest\/pull\/14332 or simply proceed independently?\r\n\r\ncc @virtuoushub","Not sure I follow. How is the `node:` prefix related with ESM? Also could you elaborate what is exactly blocking you? There is some inconvenience, but that does not look blocking for me.","> Not sure I follow. How is the `node:` prefix related with ESM? Also could you elaborate what is exactly blocking you? There is some inconvenience, but that does not look blocking for me.\r\n\r\nNot directly related to ESM, but as a precursor to ESM work, I recently opened [a PR in `redwood` to prefer the node protocol.](https:\/\/github.com\/redwoodjs\/redwood\/pull\/9057) That PR is what is currently blocked.\r\n\r\n> When importing builtin modules, it's better to use the [node: protocol](https:\/\/nodejs.org\/api\/esm.html#node-imports) as it makes it perfectly clear that the package is a Node.js builtin module.\r\n\r\nsee also: https:\/\/github.com\/sindresorhus\/eslint-plugin-unicorn\/blob\/main\/docs\/rules\/prefer-node-protocol.md","I am not sure if this relates but I am running into `Cannot find module '\/[...]\/babel.config.js'` in Jest test runs. This only happens _after_ the only change is that I refactored a medium size codebase to use the `node:` protocol.","@tdeekens Hard to say. I don\u2019t think manual mocks need `babel.config.js`. That can be something else. Try creating minimal reproduction repo, perhaps?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","What's needed to move this PR along?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Pinned"]},{"title":"[Bug]: Jest main process memory usage grows unboundedly with v8 coverage","body":"### Version\r\n\r\n29.5.0\/main\r\n\r\n### Steps to reproduce\r\n\r\n1. Have a large codebase, with many test files that import much of the codebase.\r\n2. Run the tests with the v8 coverage reporter\r\n\r\n(I can create a repro here, but the root cause is clear enough that I didn't bother.)\r\n\r\n### Expected behavior\r\n\r\nIf I run N tests which import a large codebase, the jest main process memory usage should grow slowly if at all.\r\n\r\n### Actual behavior\r\n\r\nEach test file executed increases the jest main process memory usage by quite a lot -- to the point where running with coverage enabled on our whole codebase would use 16GB or more (that's where I gave up).\r\n\r\n### Additional context\r\n\r\nThe issue here is that the main process records the v8 coverage output separately for every test file that it runs, and only merges them at the end. The code that keeps them is here:\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/aaf5315537e3ad02f93721e2e230df7bdcbccd43\/packages\/jest-reporters\/src\/CoverageReporter.ts#L59\r\nand then the reports don't get merged until here (called in `onRunComplete`):\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/aaf5315537e3ad02f93721e2e230df7bdcbccd43\/packages\/jest-reporters\/src\/CoverageReporter.ts#L431-L433\r\nFor a large codebase, these outputs can be 100MB or more, because they include, among other things, the source of every imported file (and, if source maps are enabled, the pre-transpilation source too), as well as some representation of its control-flow graph.\r\n\r\nMy assumption is that the best way to fix this is to merge as we go, like the babel coverage reporter does, although I don't know if that would have too much perf cost. (Maybe merge whenever total number of yet-unmerged coverage report items is >10k or something?)\r\n\r\nI suspect this may be behind #5837, and perhaps other issues with memory usage with `--coverage`, but of course it's hard to tell.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 13.4\r\n    CPU: (10) x64 Apple M1 Max\r\n  Binaries:\r\n    Node: 16.17.1 - \/nix\/store\/fyaisfdhkviz6sb628qxlmy5wcasqfhq-nodejs-16.17.1\/bin\/node\r\n    npm: 8.12.1 - ~\/.local\/bin\/npm\r\n```\r\n","comments":["Ok, I now have a POC fix for this. The changes are roughly:\r\n1. if the coverage map gets too big, call `v8Coverage.mergeProcessCovs` immediately rather than at end of run\r\n2. don't put coverage data in `aggregatedResults`\r\n\r\nPart 1 I currently have set to run when there are more than 10k unmerged ScriptCoverage objects. That caps memory usage somewhere around 750MB in our codebase, the exact numbers will of course vary on codebase size and file size. There's obviously a perf cost to running it more often; probably the best thing to do is to make this configurable, and either have it off or a fairly high value like 10k or 30k by default so that for small projects it will never trigger.\r\n\r\nPart 2 is a breaking change as written. I'm not sure how best to handle that; if some reporter genuinely wants the file-by-file coverage data, we need to keep it around. (I can't find any public code on GitHub that obviously does so -- I found ~5 projects, excluding vendors\/forks of Jest, that look at `v8Coverage` at all, and none via `aggregatedResults` -- but obviously that's no guarantee.) Maybe this goes behind a flag as well, so that large codebases can turn it on as long as they don't use any such reporter? That seems pretty awkward. (Maybe there's a way we can flag it as a deprecated API?)\r\n\r\nAnyway, I'll put together a PR, but any suggestions as to how to handle the flagging are welcome. Also suggestions for how to test that new code doesn't, like (2), hold on to references to the original `v8Coverage` objects after the merge.","I experience the same thing, with coverage process crashes with OOM","For one project I use Jest with [`c8`](https:\/\/github.com\/bcoe\/c8). It is a CLI app and I have to spawn a process for e2e tests. If the build files have source maps, `c8` is able to collect coverage for TypeScript files.\r\n\r\nA detail to notice: `c8` generate a lot of temporary files with coverage data and processes them at some point. But that was still causing OOM for some users. As a solution recently they introduced the `mergeAsync` option. See https:\/\/github.com\/bcoe\/c8\/pull\/469\r\n\r\nSounded relevant to the problem. Also using `c8` directly with Jest can be a solution to avoid OOMs."],"labels":[":bug: Bug","Pinned"]},{"title":"[Bug]: `expect.assertions` fails when using `test.concurrent`","body":"### Version\n\n29.5.0\n\n### Steps to reproduce\n\n1. Clone my repo at https:\/\/github.com\/davecardwell\/jest-concurrent-assertion-repro\r\n2. `npm install`\r\n3. `npm test`\r\n4. You should see the error come up\n\n### Expected behavior\n\nI expect the test suite to pass.\n\n### Actual behavior\n\nThe test suite fails with the error:\r\n> Expected one assertion to be called but received two assertion calls.\r\n\r\nBoth tests have `expect.assertions(1)`.\n\n### Additional context\n\nRemove the `.concurrent` or add `.skip` to either test and the test suite passes.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.15 Ubuntu 20.04.6 LTS (Focal Fossa)\r\n    CPU: (2) x64 Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 19.9.0 - ~\/nvm\/current\/bin\/node\r\n    Yarn: 1.22.19 - \/usr\/bin\/yarn\r\n    npm: 9.6.3 - ~\/nvm\/current\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.5.0 => 29.5.0\n```\n","comments":["This was previously reported at #12911 but automatically closed as stale. The issue persists in Jest v29.5.0.","@dmitri-gb Could you take a look, please? Perhaps this something what `AsyncLocalStorage` could help to solve as well? Just thought to ping you, because you are know  the `concurrent` context (;","Yeah, ASL might be able to solve this as well","do we have an update on this?"],"labels":[":bug: Bug","Area: Concurrent","Pinned"]},{"title":"[Bug]: config options set at root level aren't copied to `projects`","body":"### Version\n\n29.5.0\n\n### Steps to reproduce\n\n1. Clone minimal repo: https:\/\/gist.github.com\/davidjb\/eb8803286d8e6b1f0ca0d95e231fe3ca\r\n2. `npm i`\r\n3. Mock project dir: `mkdir -p path\/to\/example`\r\n4. `npm test -- --showConfig`\r\n5. Observe config output where child project configuration has Jest's defaults set and not the root-level config for `testMatch`, `testPathIgnorePatterns`, `watchPathIgnorePatterns` and so on (output below).\n\n### Expected behavior\n\nThe documentation for projects (https:\/\/jestjs.io\/docs\/configuration#projects-arraystring--projectconfig) states that:\r\n\r\n> With the projects option enabled, Jest will copy the root-level configuration options to each individual child configuration during the test run, resolving its values in the child's context.\r\n\r\nSo, the expectation is that an option set at the global level would be applied to all project entries.\n\n### Actual behavior\n\nProject config use Jest's configuration defaults instead of the root-level config set. Interestingly, the global options don't actually show up under `globalConfig`, either:\r\n\r\n```json\r\n\r\n{\r\n  \"configs\": [\r\n    {\r\n      [...]\r\n      \"testMatch\": [\r\n        \"**\/__tests__\/**\/*.[jt]s?(x)\",\r\n        \"**\/?(*.)+(spec|test).[tj]s?(x)\"\r\n      ],\r\n      \"testPathIgnorePatterns\": [\r\n        \"\/node_modules\/\"\r\n      ],\r\n      [...]\r\n      \"watchPathIgnorePatterns\": []\r\n    }\r\n  ],\r\n  \"globalConfig\": {\r\n    [...]\r\n    \"projects\": [\r\n      {\r\n        \"displayName\": \"example\",\r\n        \"rootDir\": \"path\/to\/example\"\r\n      }\r\n    ],\r\n    [...]\r\n    \"testTimeout\": 12345,\r\n    [...]\r\n  },\r\n  \"version\": \"29.5.0\"\r\n}\r\n````\n\n### Additional context\n\nNote that this was tested in both `package.json` and `jest.config.js` - the results are the same. Also, whilst this example focuses on `testMatch`, `testPathIgnorePatterns` and `watchPathIgnorePatterns`, the issue appears to affect all options I've tried - such as `setupFilesAfterEnv` too.\r\n\r\nThat said, some options (such as `testTimeout`) will automatically apply to all projects, presumably because they're set at a global level and can't be applied to a project. In this specific case trying to set `testTimeout` for a project results in a Validation Warning: `Unknown option \"testTimeout\" with value 678 was found. This is probably a typing mistake. Fixing it will remove this message`.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.4\r\n    CPU: (8) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 20.2.0 - \/opt\/homebrew\/bin\/node\r\n    Yarn: 3.4.1 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 9.6.6 - \/opt\/homebrew\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.5.0 => 29.5.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","Check discussion and motivations in #12871 which introduced the lines in question. Nobody was listening, so I gave up. Just open a PR with a revert or improve the explanation.\r\n\r\nThat is complex. Global config are not copied, only options from project config. What is global and project configs? How to explain that? Uff.. Perhaps suggesting to run `jest --showConfig` and inspect the resolved configs is enough?\r\n\r\n---\r\n\r\n> developers shouldn't rely on `--showConfig` to understand how `rootDir` works only if you're using `projects`. For instance, I've been using Jest for more than 4 years and I've never heard of `--showConfig`\r\n\r\nThat\u2019s a quote from that discussion. This is why I think some more education around `--showConfig` could be good idea.\r\n\r\nHere we talked about `collectCoverageFrom` which simply ignores the `<rootDir>` token. That is another part documentation is missing.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale","The `projects` implementation is useless because its related documentation is awful. Many things simply don't work as described, others are unintuitive. I had to go one by one, splitting options between the main config file and the \"projects\" config files until they more or less worked.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\/unstale"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: Object.defineProperty setter gets called twice on a single set","body":"### Version\n\n29.5.0\n\n### Steps to reproduce\n\n```js\r\n\/**\r\n * @jest-environment jsdom\r\n *\/\r\ndescribe(\"Object.defineProperty setter\", () => {\r\n  it(\"should be sane\", () => {\r\n    let foo = jest.fn();\r\n    let setCount = 0;\r\n    Object.defineProperty(window, \"foo\", {\r\n      get: () => foo,\r\n      set: (v) => {\r\n        ++setCount;\r\n      },\r\n    });\r\n    window.foo = \"weee\";\r\n    expect(setCount).toBe(1); \/\/ FAILS with setCount = 2\r\n  });\r\n});\r\n```\n\n### Expected behavior\n\n- `setCount` should be exactly `1`, as a set operation was called once\n\n### Actual behavior\n\n- `setCount` is `2`, as the setter is incorrectly called twice\n\n### Additional context\n\nn\/a, see above\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.3.1\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 16.19.0 - ~\/Library\/Caches\/fnm_multishells\/98998_1686164082277\/bin\/node\r\n    Yarn: 1.22.19 - ~\/Library\/Caches\/fnm_multishells\/98689_1686164066187\/bin\/yarn\r\n    npm: 8.19.3 - ~\/Library\/Caches\/fnm_multishells\/98998_1686164082277\/bin\/npm\r\n  npmPackages:\r\n    jest: 29.5.0 => 29.5.0\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","not stale","The test is passing with Node 18 or 20. Fails with Node 14 or 16. The same Jest version was used, so that must be upstream bug.\r\n\r\nBoth Node 14 and 16 are currently supported by Jest, but 14 is already EOL and 16 will be EOL in a month (from [2023-09-11](https:\/\/nodejs.org\/en\/blog\/announcements\/nodejs16-eol\/)). Time to upgrade, perhaps? (;","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Upstream Bug","Pinned"]},{"title":"[Bug]: createMockFromModule not mocking class correctly","body":"### Version\n\n29.5.0\n\n### Steps to reproduce\n\n1. Clone my repo at https:\/\/github.com\/dominiktopp\/jestCreateMockFromModuleIssue\r\n2. npm install\r\n3. npm test\r\n4. tests will fail\n\n### Expected behavior\n\nI expect the test cases to succeed.\n\n### Actual behavior\n\nTests are failing because jest.createMockFromModule only mocks constructor and functions for classes but no other properties (also no getters).\r\nThe example for [jest.createMockFromModule](https:\/\/jestjs.io\/docs\/jest-object#jestcreatemockfrommodulemodulename) does not mock an exported class but an instance of a class:\r\n`class: new (class Bar {...})()`\r\n\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n  OS: Windows 10 10.0.19045\r\n  CPU: (12) x64 Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz\r\n  Memory: 10.67 GB \/ 31.76 GB\r\nBinaries:\r\n  Node: 16.15.0 - C:\\Program Files\\nodejs\\node.EXE\r\n  npm: 8.5.5 - C:\\Program Files\\nodejs\\npm.CMD\n```\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","not stale!","I think the example in the docs combines two different mocking procedures, classes(ish) and objects. It implies the class is being mocked, when it's actually an instance (object) of that class. It needs to be edited or clarified to differentiate the result of mocking an instance and class constructor.\r\n\r\nCurrently, mock classes are constructor functions that produce objects that have a mocked constructor and mocked methods up the prototype chain. There are no properties because the class isn't instantiated when mocked. \r\n\r\nMocked objects, like the next example in the docs, maintain their property keys since their shape is known and just has to be maintained.\r\n\r\nMocking an instance produces a object with its current shape (mocked object), mocked methods from its prototype chain, and a constructor that acts as a mock class. Instantiating new objects with that constructor, will produces instances that don't have the properties in the original instance. (mocked class)\r\n\r\nI can see two ways to go about this:\r\n1. Update the docs. \r\n    - Add an actual class constructor function mock example\r\n    - Highlight the lack of properties and why [classes aren't instantiated]\r\n    - Add alternatives\r\n       - Mock an instance\r\n       - Manual mocks\r\n2. Update the class mocking logic to include properties but it comes with caveats\r\n    - Instantiating a class when mocking can have side effects and\/or rely on initial conditions to decide the shape\r\n    - Static analysis can be done but will be limited to properties defined in the class declaration to circumvent the effect of initial conditions.\r\n\r\nI can work on either approach but let's first decide the direction we want to move in.","Hi Khaled,\r\n\r\nThanks for your help!\r\n\r\nWith 1 (the current state) there is a lot of boilerplate code:\r\nEither we have to define all properties after jest.createMockFromModule one by one (and remember to add new properties in the tests when adding to the class)\r\nor we have to use getter\/setter pattern backed with private properties so that jest can just mock the getters\/setters (like Java POJOs)\r\n\r\nWay 2 sounds better for our daily usage of jest but instantiating and calling the real constructor before mocking is indeed a problem.\r\nCan you explain what you mean with the limitation when using static analysis?","With 1, there will definitely be some extra boilerplate. Defined getters and setters for certain properties would constrain the user too much for testing imo (unless they want to know if a property was accessed), with JS classes, they're also in the prototype not the instance so it'd be harder to follow different instances.\r\n\r\nWith static analysis it'll be tough to match an actual instance because properties can be added conditionally in the constructor. \r\nExample with bad code:\r\n```js\r\nclass Foo {\r\n  constructor(bar) {\r\n     this[bar] = 'please';\r\n     if (bar) {\r\n        this.buzz = 'stop'\r\n     } else {\r\n        Object.assign(this, killableWithFire)\r\n     }\r\n  }\r\n}\r\n```\r\nThere's no way we can predict the actual instance's shape. To circumvent this we can limit the mocked properties to fields defined in the class declaration.\r\n\r\n```js\r\nclass Foo {\r\n  \/\/ Mock these\r\n  bar;\r\n  buzz = [1,2,3]\r\n\r\n  \/\/ Ignore completely\r\n  constructor () {\r\n     this.level = 999;\r\n     Object.assign(this, mixin);\r\n  }\r\n}\r\n```\r\nThe caveat is that the user will need to declare the properties (arguably a good thing) if they want them to be mocked. This could get annoying with mixins especially.","Thank you. For our use case the fields defined in the class declaration would be enough: Since we are using Typescript the first example does not even compile (with no implicit anys enabled)\r\nFortunately we are not using mixins. We rely on inheritance where needed.","One more thing to consider is how to set the values of the fields if they're not defined or if they're set to the values of other variables. Should they be set to undefined? \r\n\r\nWith JS, types will also be a problem, like, an array property than gets set in the constructor based on a parameter value wouldn't be defined as an empty array in the class declaration. We could also set it to undefined, but it feels like users could find that unintuitive.\r\n\r\nThe more I think about this, the more I feel like we should somehow mock an instance that the user passes. The side effect implication is made clear to them as they instance the class, and they get to decide the initial conditions.","It's not trivial.\r\nIf the user has to pass an instance, than he could also use this instance as the mock object, couldn't he?","Yeah, they could . One small improvement that could be done if we settle for an approach like that is to use the instance to make a more complete constructor that produces  fully mocked instances with the same shape instead of ones with just methods.\r\n\r\nFor a dev workflow, we could minimize this to a secondary file or folder with those base instances.\r\n```\r\nsrc\/\r\n\u251c\u2500\u2500 Foo.js\r\n\u2514\u2500\u2500 class-mocks\/\r\n    \u2514\u2500\u2500 Foo.js\r\n```\r\n```js\r\n\/\/ src\/Foo.js\r\nexport default class {\r\n   constructor(lang) {\r\n     this.lang = lang;\r\n   }\r\n}\r\n```\r\n```js\r\n\/\/ sec\/class-mocks\/Foo.js\r\nimport Foo from '..\/Foo'\r\nexport default new Foo('JS')\r\n```\r\nThen in a test:\r\n```js\r\n\/\/ Bar.test.js\r\nconst Foo = createMockFromModule('src\/class-mocks\/Foo').constructor\r\nconst testFoo = new Foo();\r\n\/\/ testFoo.lang === 'JS'\r\n```\r\nIt's very similar to the current approach with the only difference being the constructor now creating instances with properties."],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Bug]: `jest --bail` doesn't call `globalTeardown` function if test fails.","body":"### Version\r\n\r\n29.5.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone my repo at https:\/\/github.com\/broyde\/jest-teardown-bug\r\n2. `yarn install`\r\n3. `yarn test`\r\n4. You should see result like this:\r\n```\r\n FAIL  .\/jest.test.js\r\n  Should call `globalTeardown` function before exit\r\n    \u2713 without bail (806 ms)\r\n    \u2715 with bail (659 ms)\r\n\r\n  \u25cf Should call `globalTeardown` function before exit \u203a with bail\r\n```\r\n\r\nOptional steps (if you don't like `jest.test.js` - you could run `fail.test.js` directly):\r\n\r\n5. `yarn jest fail.test.js`\r\n6. You should see failed result followed by:\r\n```\r\n**************************\r\nTEARDOWN\r\n**************************\r\n```\r\n\r\n7. `yarn jest fail.test.js --bail`\r\n6. You should see the same fail, but without TEARDOWN log.\r\n\r\n### Expected behavior\r\n\r\n`yarn jest fail.test.js --bail` outputs the `TEARDOWN` message,\r\nso `yarn test` passes:\r\n```\r\n$ jest --config={} jest.test.js\r\n PASS  .\/jest.test.js\r\n  Should call `globalTeardown` function before exit\r\n    \u2713 without bail (743 ms)\r\n    \u2713 with bail (696 ms)\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n`yarn jest fail.test.js --bail` does not output the `TEARDOWN` message,\r\nso `with bail` case of `yarn test` fails:\r\n```\r\n$ jest --config={} jest.test.js\r\n FAIL  .\/jest.test.js\r\n  Should call `globalTeardown` function before exit\r\n    \u2713 without bail (750 ms)\r\n    \u2715 with bail (676 ms)\r\n\r\n  \u25cf Should call `globalTeardown` function before exit \u203a with bail\r\n\r\n    expect(received).toMatch(expected)\r\n\r\n    Expected pattern: \/TEARDOWN\/\r\n    Received string:  \"\"\r\n\r\n      15 |   it('with bail', () => {\r\n      16 |     expect(exec(['jest', 'fail.test.js', '--bail']))\r\n    > 17 |       .toMatch(\/TEARDOWN\/);\r\n         |        ^\r\n      18 |   })\r\n      19 | });\r\n      20 |\r\n\r\n      at Object.toMatch (jest.test.js:17:8)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        1.612 s, estimated 2 s\r\nRan all test suites matching \/jest.test.js\/i\r\n```\r\n\r\n### Additional context\r\n\r\nThis report is about the same bug as automatically closed https:\/\/github.com\/jestjs\/jest\/issues\/10607.\r\nHere I've created a hopefully better example with [test](https:\/\/github.com\/broyde\/jest-teardown-bug\/blob\/main\/jest.test.js) which actually checks the `jest` behavior by running [failing test](https:\/\/github.com\/broyde\/jest-teardown-bug\/blob\/main\/fail.test.js) without and with `--bail` option.\r\n\r\nYou could also [run this example on Repl](https:\/\/replit.com\/@disya\/jest-teardown-bug).\r\n\r\nReproduces on different environments and nodejs versions.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 5.15 Ubuntu 20.04.4 LTS (Focal Fossa)\r\n    CPU: (6) x64 Intel(R) Core(TM) i5-8400 CPU @ 2.80GHz\r\n  Binaries:\r\n    Node: 16.17.1 - \/usr\/bin\/node\r\n    Yarn: 1.22.5 - \/usr\/bin\/yarn\r\n    npm: 8.15.0 - \/usr\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.5.0 => 29.5.0\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@SimenB wdyt about this hotfix (`TestScheduler.ts` and `runJest.ts`)?\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/1962469\/b5a580b0-ce3f-4886-a7c8-907f4032b2be)\r\n\r\nNot the most beautiful one, but it should do the job... \ud83e\udd14 \r\n","I stubmled upon this bug in Detox. Some of users tried to run tests with `--bail` and the results are horryifing \ud83d\ude2d  the `--bail` logic disregards both the test environment cleanup and the global teardown.\r\n\r\nI'll create a workaround in Detox to fight this. Perhaps, I'll be postponing the `process.exit()` inside `onRunComplete` via our Jest reporter override. Not a bright solution but I have no options if I want to maintain support for Jest 27+.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This bug is also the reason why we can't use the [jest-puppeteer](https:\/\/github.com\/argos-ci\/jest-puppeteer)'s `server` option:\r\nthe server remains running if some test fails with `--bail` :(","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","There is a pull request actually without a review, so no wonder this is still stale. \u2639\ufe0f ","@SimenB and the Jest team,\r\n\r\nI genuinely appreciate and value the power and flexibility that Jest offers, however, the further I tinker with `jest --bail` implementation, the more disheartened I get.\r\n\r\nI've found myself having to navigate intricate workarounds, particularly to ensure 1) that `globalTeardown` is called; 2) that `Reporter#onRunComplete` isn't invoked multiple times by different failing workers in `--bail` mode, especially when dealing with prolonged async operations.\r\n\r\n1) https:\/\/github.com\/wix\/Detox\/pull\/4199\/files#diff-4cf11a746383ff61964026f3a5fd6168b8b7695de2ff898977b79d411df6b3e1R34-R47\r\n\r\n2) https:\/\/github.com\/wix\/Detox\/pull\/4115\/files#diff-4cf11a746383ff61964026f3a5fd6168b8b7695de2ff898977b79d411df6b3e1R28-R30\r\n\r\nWhile I've made efforts to address this with my proposed solution [here](https:\/\/github.com\/jestjs\/jest\/pull\/14271), I'm beginning to feel it's merely a band-aid. I believe this issue needs a more comprehensive approach. I express this not as criticism but as feedback from someone deeply engaged with the tool. I hope you could share a few thoughts on this topic, especially if you're long aware of the design inconsistencies around `--bail`.\r\n\r\nThank you for your understanding and continued dedication to the Jest community.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Oh, yeah, of course it is stale.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83d\ude44 ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83d\ude44","@broyde did the idea with the reporter hack anyhow helped you, by the way?","> @broyde did the idea with the reporter hack anyhow helped you, by the way?\r\n\r\n@noomorph\r\nJest doesn't want to stop the server (by calling `globalTeardown`), so the server has to stop by itself:\r\nInstead of using the `server` option in `jest-puppeteer` config, I directly run the test server. It then starts `jest --bail` as a sub-process and kills itself on sub-process' `close` event.\r\nI've been using this workaround for a few years and it doesn't really necessary to change it.\r\nSo, I didn't try the reporter hack.","Ah, that makes sense. Thanks for sharing!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue is still relevant."],"labels":["Needs Triage","Bug Report"]},{"title":"feat(jest-mock): add a method to mock a function only for certain arguments","body":"## Summary\r\n\r\nThe full motivation is described more fully in #13811, but the basic idea is that a common need is to mock a function only when passed certain arguments. All of the current workarounds are either messier, or require third-party packages that have to implement this in messier ways.\r\n\r\nSo in this commit I add a new method `mockWhen(args)` that says \"mock this function only when passed the given arguments\". The arguments can be `expect` matchers, which makes it quite flexible. The caller can then customize the returned mock with `mockImplementation` or any of its siblings as usual. This is all based on a similar function we've been using in tests at my company; but putting it in Jest offers a clearer API since it can be a method alongside all the other `mock*`.\r\n\r\nFor example (see the tests for more examples):\r\n```ts\r\nconst fn = jest.fn(); \/\/ or any `MockInstance` from `jest.mock`, `spyOn`, etc.\r\nfn.mockReturnValue('generic output');\r\nfn.mockWhen('special input').mockReturnValue('special output');\r\n\r\nexpect(fn('arbitrary')).toBe('generic output');\r\nexpect(fn('special input')).toBe('special output');\r\n```\r\n\r\nFixes #13811.\r\n\r\n## Test plan\r\n\r\nAdded unit tests.\r\n\r\n## TODOs\r\n\r\nI didn't add the changelog or documentation yet; I wanted to get confirmation that this is something you're interested in first. I can also add type tests if that's helpful.","comments":["This would be great to add.\r\n\r\nCould you look through the discussion in #6180? It can be fine to begin with partial support, of course. Perhaps it isn\u2019t that complicated to cover all mock-return\/resolve methods?","> It can be fine to begin with partial support, of course. Perhaps it isn\u2019t that complicated to cover all mock-return\/resolve methods?\r\n\r\nThis API already covers all the methods. (It's equivalent to the one in [this comment](https:\/\/github.com\/facebook\/jest\/issues\/6180#issuecomment-455015550) from `jest-when`, just a different name. The implementation is much simpler than `jest-when` since we don't need to reimplement anything.) The idea is that `mockWhen` creates and returns a new mock which is used only if the arguments match; you then customize that mock as usual. So in the example I did\r\n```ts\r\nfn.mockWhen('special input').mockReturnValue('special output');\r\n```\r\nbut you can just as easily use `mockImplementation`, `mockRejectedValue`, etc.\r\n\r\nThe only thing I didn't add is a parallel `mockWhenOnce` which would be removed once you call the mock with those arguments. You can do `fn.mockWhen(a).mockReturnValueOnce(b)`, but that has a bit different behavior -- when `fn.mockWhen(a)` is called it removes the return value but not the when. I think that should be possible to add but it would be a lot more invasive since we can't just push onto `specificMockImpls` in the same way -- we'd need our own mapping and logic in `mockConstructor` as well.\r\n\r\ncc @timkindberg in case they have any thoughts on how this went in `jest-when`","Wonderfull! Thanks for clarification.\r\n\r\nI think `.whenCalledWith()` reads better than `.mockWhen()`. The rest sounds good to me.\r\n\r\nPerhaps for testing you could create new test file exclusively for this API? I though that this isn\u2019t full implementation, just because tests were missing.","I also prefer `jest.fn().whenCalledWith()`.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | eef89e51cee19c1cf3625f53aab912edcb91c7a2 |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/6515f022a8386800083fdcbc |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-14076--jestjs.netlify.app](https:\/\/deploy-preview-14076--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTE0MDc2LS1qZXN0anMubmV0bGlmeS5hcHAifQ.7EM_WoVo1tF0tr55PPdGuiZFM22aq2WyxA4fasYD5Yo)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","Finally got around to updating this. I added several more tests, and some type tests, and docs. Thanks for all the comments, I think I've addressed them all now.\r\n\r\nI recommend reading the tests relating to `mock*Once` and\/or `withImplementation` as they explain the arguably-surprising interaction between the two. My experience in our codebase is the issue doesn't come up a ton -- part of the value of `whenCalledWith` is you can avoid the (often more fragile) `mock*Once` entirely -- but let me know if you think it should be documented explicitly. We could also change the behavior (although it's unclear what behavior would be clearer on the whole), or remove `mock*Once` and `withImplementation` from the `whenCalledWith` output.","Hey folks, any plan to merge this?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Stale"]},{"title":"feat(Programmatic API): Add programmatic API","body":"## Summary\r\n\r\nThis pull request adds a documented programmatic API to run Jest. It can be used to run using the new experimental API.\r\n\r\n```ts\r\nimport {createJest} from 'jest';\r\n\r\nconst jest = await createJest();\r\njest.globalConfig = {\r\n  collectCoverage: false,\r\n  ...jest.globalConfig,\r\n};\r\nconst {results} = await jest.run();\r\nconsole.log(`run success, ${result.numPassedTests} passed tests.`);\r\n```\r\n\r\nThe new `Jest` instance has the following properties:\r\n\r\n- `globalConfig`: The global configuration to use for this run. You can use it to override arbitrary options (albeit by overriding the entire object reference).\r\n- `projectConfigs`: The project configurations to run.  You can use it to override arbitrary project options (albeit by overriding the entire array reference).\r\n- `run`: Function that kicks of a test run.\r\n\r\n## Motivation\r\n\r\nThis change adds a documented programmatic API to run Jest, which makes it easier to build tools that use Jest or for users to run Jest from their own scripts. \r\n\r\n## Test plan\r\n\r\nI have run it using `yarn test`. I've also added a unit test.\r\n\r\n## TODO\r\n\r\n- [x] Document the programmatic API in `\/docs`.\r\n- [x] Add an e2e test that uses the programmatic API.\r\n- [x] Test the API from my code.\r\n\r\n@SimenB can you confirm that I'm on the right track here?\r\n\r\nCloses #14034 \r\nCloses #5048 ","comments":["The build is failing because `packages\/jest-core\/build\/cli\/index.d.ts` now has a reference to `pnpapi`. I have no clue why it would have that:\r\n\r\n```diff\r\n \/**\r\n  * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n  *\r\n  * This source code is licensed under the MIT license found in the\r\n  * LICENSE file in the root directory of this source tree.\r\n  *\/\r\n \/\/\/ <reference types=\"node\" \/>\r\n \/\/\/ <reference types=\"node\" \/>\r\n \/\/\/ <reference types=\"node\" \/>\r\n \/\/\/ <reference types=\"node\" \/>\r\n \/\/\/ <reference types=\"node\" \/>\r\n+\/\/\/ <reference types=\"pnpapi\" \/>\r\n import type { AggregatedResult } from '@jest\/test-result';\r\n```","For my use case I would need something like this:\r\n\r\n```js\r\nimport {run} from 'jest';\r\n\r\nrun(['path\/to\/some.test.ts'], {coverage:true});\r\n```\r\n\r\nReading configs is useful, of course. But how to make it possible to override some option or selecting files almost like from CLI. `runCLI()` is not a solution, because I would like to be able to pass `InitialOptions` and it does not allow selecting files.\r\n\r\nWhat if programmatic API would be shaped like this:\r\n\r\n```js\r\nimport {Jest} from 'jest';\r\n\r\nconst jest = new Jest();\r\n\r\njest.readConfig(); \/\/ same as `readConfigs()`\r\n\r\njest.setConfig({coverage: true});  \/\/ or as a shorthand new Jest({coverage: true})\r\n\r\njest.selectFiles(['path\/to\/some.test.ts']);\r\njest.selectProjects(['backend']);\r\n\r\nconst result = await jest.run();\r\n\/\/ or await jest.watch();\r\n```\r\n","Thanks for your review @mrazauskas! I've implemented your suggestions and created a separate `runCore` API. I've moved the entire `run` stuff to a new file, as it makes more sense now than a `cli\/index.ts` file.\r\n\r\nI've also decided to make `runCore` return a new object:\r\n\r\n```ts\r\n\/**\r\n * The result of running runCore.\r\n *\/\r\nexport type RunCoreResult = {\r\n  result: AggregatedResult;\r\n};\r\n```\r\n\r\nThat way, we can later introduce more return results without breaking the API.\r\n\r\n> Reading configs is useful, of course. But how to make it possible to override some option or selecting files almost like from CLI. `runCLI()` is not a solution, because I would like to be able to pass `InitialOptions` and it does not allow selecting files.\r\n\r\nThis is already possible. In fact, this is how Stryker currently works: \r\n\r\n```ts\r\nimport {runCLI} from 'jest';\r\nimport {readInitialOptions} from 'jest-config';\r\nconst initialOptions = readInitialOptions();\r\ninitialOptions.testRegex = ['path\/to\/some.test.ts'];\r\nconst result = await runCLI(\r\n      {\r\n        $0: 'unused',\r\n        _: [],\r\n        config: JSON.stringify(initialOptions)\r\n      },\r\n      [process.cwd()]\r\n    );\r\n```\r\n\r\n> What if programmatic API would be shaped like this:\r\n> \r\n> ```js\r\n> import {Jest} from 'jest';\r\n> \r\n> const jest = new Jest();\r\n> \r\n> jest.readConfig(); \/\/ same as `readConfigs()`\r\n> \r\n> jest.setConfig({coverage: true});  \/\/ or as a shorthand new Jest({coverage: true})\r\n> \r\n> jest.selectFiles(['path\/to\/some.test.ts']);\r\n> jest.selectProjects(['backend']);\r\n> \r\n> const result = await jest.run();\r\n> \/\/ or await jest.watch();\r\n> ```\r\n\r\nThis could be done, but this would be a deviation from the functional API that has been the norm so far. Note that your example can also be done with the new runCore functionality:\r\n\r\n```ts\r\nimport {runCore, readConfigs} from 'jest';\r\nconst {globalConfig, configs} = await readConfigs(process.argv, [process.cwd()]);\r\nglobalConfig.collectCoverage = true;\r\nglobalConfig.testPathPattern = ['path\/to\/some.test.ts'];\r\nconst results = await runCore(globalConfig, configs);\r\nconst projectConfigs = configs.filter(({displayName}) => displayName = 'fooProject');\r\nconst {result} = await runCore(globalConfig, projectConfigs);\r\n```\r\n\r\nI've allowed for more return properties in the future, so we might add a `jest` instance or something in the result of `runCore`, which could allow for faster subsequent runs (this is _actually_ what we would want in the end for Stryker, as we need to run thousands of times with slightly different global variables for switching between active mutants).\r\n","Sure, many things can be done with current API. That is not a question. Usability is missing. What I am looking for an API which is as easy as `jest some.test.ts` or `jest --config={\"coverage\":true} --selectProjects second`.\r\n\r\n```ts\r\nimport {Jest} from 'jest';\r\n\r\nconst jest = new Jest();\r\n\r\nconst result = await jest.run(['some.test.ts']);\r\n```\r\n\r\n```ts\r\nimport {Jest} from 'jest';\r\n\r\nconst jest = new Jest({coverage: true});\r\njest.selectProjects(['second']);\r\n\r\nconst result = await jest.run();\r\n```\r\n\r\n```ts\r\nimport {Jest, readConfig} from 'jest';\r\n\r\nconst config = readConfig('.');\r\nconfig.coverage = undefined;\r\n\r\nconst jest = new Jest(config);\r\nconst result = await jest.run();\r\n```\r\n\r\n--- \r\n\r\nAll I ask is feedback, happy to implement it myself (; Only that this has to wait for major release.","> All I ask is feedback, happy to implement it myself (; Only that this has to wait for major release.\r\n\r\nI'm not sure. I personally don't mind either API. If you want to go the class syntax route, does this PR still make sense? Also: maybe the class should be called `Jester`? \ud83d\ude1c\r\n\r\nI need some help with the failing build. Does anyone know why `pnpapi` is suddenly referenced?\r\n\r\n```\r\nError: \/home\/runner\/work\/jest\/jest\/packages\/jest-core\/build\/runCore.d.ts has the following non-node type references:\r\n\r\n\/\/\/ <reference types=\"pnpapi\" \/>\r\n\r\n    at file:\/\/\/home\/runner\/work\/jest\/jest\/scripts\/buildTs.mjs:225:17\r\n```\r\n","The `pnpapi` issue looks familiar. See #12783\r\n\r\n---\r\n\r\nClass was just a rough idea. Actually a function like `createJest()` instead of the class could be better idea, because it can be async. That way it could take anything exported from Jest config file (just another way to use it):\r\n\r\n```ts\r\nimport jestConfig from '..\/jest.config.js';\r\n\r\nconst jest = await createJest(jestConfig);\r\n\r\nconst result = await jest.run();\r\n```","[I've been able to fix the `<reference types=\"pnpapi\" \/>` error](https:\/\/github.com\/facebook\/jest\/pull\/14062\/commits\/79dbfd5c923b349dfe1907505518a6f4d5b506ed) (great linting error, btw!). I've added some e2e tests and unit tests. I'm still busy with the docs, but you should take a look.\r\n\r\n@mrazauskas I'm unopinionated about your API proposal. Maybe @SimenB can also pitch in here since he previously expressed an opinion about the programmatic API. I wouldn't want to do more work just to be shot down later...","\/easycla","<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: nicojs \/ name: Nico Jansen  (908c73d7fbf84fe7976408e4ceeb44e011a75393, e2c65f85745ef6460a88960a0fe0b34f72e6b691, 6a75acfa3d14dff79b563b35efbdf9d5aafaa84c, 7d70600c6d3e5957fe438341f0c3ffb49bd7ac35, 8155081af00bff19047e98f004bb2c2a4b21a0e3, 79dbfd5c923b349dfe1907505518a6f4d5b506ed, d0fd9a99956cd68add6f6bec96a3018c7f9c728e, b9e9278f7d36672db62c8abf643586edb20b1b42, d8f6e26fc57b148e40048b40053dfefae2983598, 68c924fa1b5f6b50803a9a41b3e32be86161c66a, 68ac3efa71ab095be4531844b5c3f825e8936e3d, a375b0d0e1d986e60b14914a53f6cc36614d2afa, 0f8f6f236651276e8501c4e4365d490a0279a792, 1935947b5eb38511d3d43eb3e93cac87f10c2aad, 77723b37387372255a4444a21e74c31dfca9cfa8, a74924332f64576ef1fd5a929c047c3945f3fa81, 48a5a94eb84e809c66caa10992b694bc31ac0998, ac2b879aa6b098f178fb83d875b19ed4fdc5c312, e5c254fac9e7fdf14ba0cb43635b97d0821257c2, 59cfa1acb5ca4ffec9e13f94ec800233b1f02979, d570bc8a67390fcded39d86008850c12a2762e2b, 80d3c235cff895129c9e294f0048127a0458be78, 098cc21c7168b1f4e41d1664d671143fd18f6ce3, 65fe53f5c0c5178e7179a6e5b180a3f509c646f3, 9f1a113a9a93ec796deab43f75d26fc1124e5e22, 8da9922faf65fc994882e8a5acc352976371a628, 6a26f7f5ff1d240da632bd2b772dc8a765dad66f, fe45d4fe4088265b27a6650c9abdd455d3a51d5b, ef783ede7ce4932f37836936186d843f281cbd52, 46a7ce9c2be83591976e182d8cf4910d3722745c, 9f056b8b32abebc10a4e92ff2896f58b3bf07bc7, 92d6d44fe20eff15c3ad6a4941540d36697974d8)<\/li><li>:white_check_mark: login: SimenB \/ name: Simen Bekkhus  (0b6f93ddc6d1aa4f4dd1f8967640e9d5fa53f1b6, 6877134113b41f2399a0ac8dc278ab16c4775370, 26e87e105d85f599c28db7de7591689bde7e86a2, f3e41ef31367d7291208f2944f250c06ff8ccc18, 2677e1dc8a3d7a8ac99509b90e59ab1a4d30c6a5, f6d0c5a782d44cb7b511a948c51ee447303be406)<\/li><li>:white_check_mark: login: KhaledElmorsy \/ name: Khaled Elmorsy  (c3b95f8cc887aa04563f62d0fbac772392324dad)<\/li><li>:white_check_mark: login: renovate[bot]  (8ec975a68d46844417590ab70436cedec7133e0d)<\/li><li>:white_check_mark: login: alexreardon \/ name: Alex Reardon  (ccc7e4e92a198b01294dfc6c7919aa8769094c11)<\/li><li>:white_check_mark: login: nolddor \/ name: Jack Nolddor  (f04118ded11fb7f36e49a8180fd58641b4dfe77c)<\/li><li>:white_check_mark: login: Mutesa-Cedric \/ name: MUTESA Cedric  (f8e025905135dd9f4bc08a0a2ef03f4d4af8bbf9)<\/li><\/ul>","I like @mrazauskas's suggestion. It should be with a function and not a class so it can be async like mentioned. I'd expect the initial function to either take a path to a config file, inline config, or nothing (which would be Jest try to find the config manually).","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 92d6d44fe20eff15c3ad6a4941540d36697974d8 |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/654161f5ba715e000860413c |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-14062--jestjs.netlify.app](https:\/\/deploy-preview-14062--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTE0MDYyLS1qZXN0anMubmV0bGlmeS5hcHAifQ.4I6gGhTqjE55d73UhgXysCKjZ4ld_njgrMaC5CQ-Gc8)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","Ok, I'll refactor in that case.\r\n\r\nCould one of you give me some pointers?\r\n\r\n- `readConfigs` currently freezes the returned values. Would you be OK with me removing that feature?\r\n- Should I refactor the current `runCLI` so it uses this new API?","> * `readConfigs` currently freezes the returned values. Would you be OK with me removing that feature?\r\n\r\nWhy does that need to change? It's not something I really care about, but I don't understand why it'd have to change.\r\n\r\n> * Should I refactor the current `runCLI` so it uses this new API?\r\n\r\nThat would be cool, but it's not important and can be done later.\r\n\r\n---\r\n\r\nOne more thing - the thing returned by `createJest` or whatever you end up naming the function should also be an event emitter. We use `emittery` already - can probably be reused. You probably read through the linked issue, but https:\/\/github.com\/jestjs\/jest\/issues\/5048#issuecomment-475065417 contains notes from a meeting 4 years ago. I think all parts are covered by what we've discussed already.","> Why does that need to change? It's not something I really care about, but I don't understand why it'd have to change.\r\n\r\nWell, the whole reason I need this API is to be able to make changes to the config once it has been read.\r\n\r\ni.e.\r\n\r\n```ts\r\nimport {createJest} from 'jest';\r\nconst jest = await createJest();\r\n\r\n\/\/ Change config\r\njest.globalConfig.collectCoverage = false;\r\njest.projectConfigs[0].testEnvironment = changeEnvironmentBasedOn(jest.projectConfigs[0].testEnvironment);\r\n\r\nconst {results} = await jest.run();\r\n```","Extending altering config could be done through options:\r\n\r\n```ts\r\ninterface CreateJestOptions {\r\n  \/**\r\n   * Options to be merged with read config.\r\n   *\/\r\n  extraConfig?: InitialOptions;\r\n  \/**\r\n   * Callback fn which will be called on each option of read config.\r\n   *\/\r\n  configFilter?: (optionKey: keyof InitialOptions) => InitialOptions[keyof InitialOptions];\r\n};\r\n\r\ndeclare function createJest(options?: CreateJestOptions): Promise<RunJest>;\r\ndeclare function createJest(config?: InitialOptions | string, options?: CreateJestOptions): Promise<RunJest>;\r\n```","Sorry, but that again wouldn't work for us. Our use case looks more like this:\r\n\r\n```js\r\nimport {createJest} from 'jest';\r\nconst jest = await createJest();\r\n\r\n\/\/ Performance improvements\r\njest.globalConfig.collectCoverage = false;\r\n\r\n\/\/ Swap test environments\r\njest.projectConfigs[0].testEnvironment = changeEnvironmentBasedOn(jest.projectConfigs[0].testEnvironment);\r\n\r\n\/\/ Focus for testing the first mutant\r\nglobalTestEnvironment.activeMutant = '1';\r\njest.globalConfig.findRelatedTests = true;\r\njest.globalConfig.nonFlagArgs = ['src\/file-under-test-1.js'];\r\n\r\n\/\/ Run the first mutant\r\nconst {results: firstResult} = await jest.run();\r\n\r\n\/\/ Focus for testing the second mutant\r\nglobalTestEnvironment.activeMutant = '2';\r\njest.globalConfig.findRelatedTests = true;\r\njest.globalConfig.nonFlagArgs = ['src\/file-under-test-2.js'];\r\n\r\n\/\/ Run the second mutant\r\nconst {results: secondResult} = await jest.run();\r\n```\r\n\r\nWe're running jest multiple times while changing the config between runs. Maybe we can work around it like this (although not very common in the javascript world):\r\n\r\n```js\r\nimport {createJest} from 'jest';\r\nconst jest = await createJest();\r\n\r\n\/\/ Performance improvements\r\njest.globalConfig = {\r\n ...globalConfig,\r\n collectCoverage: false\r\n};\r\n\r\n\/\/ Swap test environments\r\njest.projectConfigs = [{ \r\n  ...jest.projectConfigs[0], \r\n  testEnvironment: changeEnvironmentBasedOn(jest.projectConfigs[0].testEnvironment)\r\n}];\r\n\r\n\/\/ Focus for testing the first mutant\r\nglobalTestEnvironment.activeMutant = '1';\r\njest.globalConfig = { \r\n  ...jest.globalConfig,\r\n  findRelatedTests: true,\r\n  nonFlagArgs: ['src\/file-under-test-1.js'],\r\n};\r\n\r\n\/\/ Run the first mutant\r\nconst {results: firstResult} = await jest.run();\r\n\r\n\/\/ Focus for testing the second mutant\r\nglobalTestEnvironment.activeMutant = '2';\r\njest.globalConfig = { \r\n  ...jest.globalConfig,\r\n  findRelatedTests: true,\r\n  nonFlagArgs: ['src\/file-under-test-2.js'],\r\n};\r\n\r\n\r\n\/\/ Run the second mutant\r\nconst {results: secondResult} = await jest.run();\r\n```","Different solution can be found. I think the most important is to make it easy to use. The first sentence of documentation should say: \"To use programmatic API is as easy as running Jest from the command line.\"\r\n\r\nCreate React App or Stryker are the advanced use case, of course. Would be nice to make it possible to use Jest to [test VS Code extensions](https:\/\/code.visualstudio.com\/api\/working-with-extensions\/testing-extension). It is simply not possible from command line. At the moment they recommend Mocha. I would like to make it work with Jest.\r\n\r\nHow easy or hard it is for you to use Mocha\u2019s API? Just wondering. Does not mean we should copy it.\r\n\r\n---\r\n\r\nAlso I don\u2019t think user of programmatic API should know about `GlobalConfig` \/ `ProjectConfig`. These are internals. All what a user should care about should be list of files, and a path to config file (or directory with config in case it lives in `package.json`) or `Config` object (meaning `InitialOptions`): \r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/d91ab8e3fe80a0c17fea2571afe2663a777a4dce\/packages\/jest\/src\/index.ts#L19","> Also I don\u2019t think user of programmatic API should know about `GlobalConfig` \/ `ProjectConfig`. These are internals. All what a user should care about should be list of files, and a path to config file (or directory with config in case it lives in `package.json`) or `Config` object (meaning `InitialOptions`):\r\n\r\nIn that case, this programmatic API is not useful for us as explained in [our use case](https:\/\/github.com\/jestjs\/jest\/pull\/14062#issuecomment-1520794784) and #14034","Just to clarify, we need an API that allows us to change options after they are read from config files. The crucial part is this:\r\n\r\n```js\r\njest.projectConfigs[0].testEnvironment = changeEnvironmentBasedOn(jest.projectConfigs[0].testEnvironment);\r\n```\r\nIf we are only able to use the `InitialOptions`, then we are not able to override the test environment based on the configured test environment, because the configured test environment might change later because of presets. See #14034.\r\n\r\nOf course, we could extend the `InitialOptions` to include all the complexities of `GlobalConfig` and `ProjectConfig` and let `createJest` also resolve presets, but that would mean more refactoring work. I don't know if that's even possible. Jest supports multiple projects for a reason, after all. If we could capture that complexity in 1 config object, it would already use that.\r\n\r\nI don't think the complexity of `GlobalConfig` and `ProjectConfig` is a big problem for users wanting to use the programmatic API. They probably already know about multiple projects in 1 config. It is a small leap to understand that when you are not using that feature, the `projectConfigs` would contain one project. The advantage is that it gives users complete control without much refactoring work.\r\n","I've implemented the `createJest` proposal.\r\n\r\n```ts\r\nimport {createJest} from 'jest';\r\n\r\nconst jest = await createJest();\r\njest.globalConfig = {\r\n  collectCoverage: false,\r\n  ...jest.globalConfig,\r\n};\r\nconst {results} = await jest.run();\r\nconsole.log(`Run jest success, ${results.numPassedTests} passed tests.`);\r\n```\r\n\r\nThe `jest.run()` method currently doesn't accept params, but we can add them later in separate PR's if we want. However, you can do everything using the `globalConfig` and `projectConfigs` properties.\r\n\r\nI want the configuration not to be frozen. Would you like me to change that?","@mrazauskas @SimenB would you mind taking a look when you have some time? \ud83d\ude07","Thanks for your response @SimenB. I'm quite busy atm, will get to this in a week or 2.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Hey @nicojs - will you be able to find some time for this soonish? \ud83d\ude42 ","@nicojs hey again \ud83d\ude00 I think we're mostly missing docs here - would be great to get it over the line \ud83d\ude42 ","Awesome \ud83e\udd29. I'll see if I have some time this week (maybe even today?)","@segrey @DmitryMakhnev Is this something that would be usable from IntelliJ (or Fleet)? Anything obvious missing (or wrong)?\r\n\r\n@connectdotz same question - does this help the vscode extension?\r\n\r\nWould love to hear your feedback \ud83d\ude42 ","@SimenB IntelliJ\/Fleet both run Jest tests using Jest CLI. It appears that we're not currently interested in it.","Fair enough \ud83d\ude42\r\n\r\nIf you wanna use the API instead of CLI and reporter at some point in the future, I'd love to figure out what's missing then \ud83d\udc4d ","@SimenB I took a quick read on the api document; it seems these APIs are mainly to manage config, invoke the CLI\/core logic, then get back the aggregated test results from the run. It could probably save us a few steps like managing child processes (for CLI), parsing the json result file, etc. But given these are already implemented and working, changing the CLI-based eco-system is not trivial, and I didn't see extra features or additional use cases enabled by the API for our extension... so not sure we will be using the API, at least for now... \r\n\r\nI do have some general questions though:\r\n- The CLI output is pretty useful. Does the API still provide a way to output these in real-time (not at the end of the run)?\r\n- are the reporters still supported? what will a reporter looks like with the API approach?  Reporter mainly provides a more real-time, incremental information, which the API looks like only supports batch mode?\r\n- I assume the API also supports coverage reporting?","@SimenB I think I'm done now \ud83d\ude00","I've updated the PR text to reflect the recent changes. I don't know why the build is failing.","Thanks @SimenB, welcome back \ud83c\udf83\r\n\r\nI think fixed all your remarks except for one where I have a question.","@SimenB, what would you think about just making the config objects mutable? I personally don't see a reason to make it more complicated than it needs to be. What are we actually afraid of? It was always 'shallow immutable' anyway. \ud83e\udd37\u200d\u2642\ufe0f","Main issue isn't mutability, but the fact you can provide invalid configuration values. E.g. `jsdom` is _not_ valid configuration at this point - it has to be an absolute path to a module. Our `normalize` function needs to do its work on any input from the user, thus it needs to go via a setter of some kind.","@SimenB @nicojs I work on a codebase using Stryker for my tests where this PR would be a huge help to simplify the codebase. Is there anything I can do to help on this PR ? I've not contributed to many projects but I'm willing to invest some time to help here as it would help me a lot in my daily work","Hey @mbaumanndev! I think we're only missing normalization of configuration when setting it. If you could contribute that, I _think_ we're ready to land this \ud83d\ude42 "],"labels":["cla signed","Pinned"]},{"title":"[Bug]: Different reporter order leads to `coverageMap` missing in custom reporter starting in Jest 28","body":"### Version\r\n\r\n29.5.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone repo: https:\/\/github.com\/danieldiekmeier\/jest-custom-reporter-reproduction\r\n2. `npm i`\r\n3. `npm test`\r\n\r\nIn the output and in the `reporter.js` file, you can see that I had to use a `setInterval` to keep my custom reporter running until after the `CoverageReporter` is finished collecting the coverage. In Jest 27, this wasn't necessary \u2013 by the time my custom reporter ran, the `CoverageReporter` was already finished.\r\n\r\n### Expected behavior\r\n\r\nI expect my custom reporters to run last (like they did in Jest 27). Alternatively, it'd be fine if I could influence the order somehow.\r\n\r\n### Actual behavior\r\n\r\nThe coverage reporter runs after my custom reporter, making it impossible to use its results in custom reporters.\r\n\r\n### Additional context\r\n\r\nThis is the new code in Jest >=28.0.0, which registers the `CoverageReporter` _after_ the custom reporter: https:\/\/github.com\/facebook\/jest\/blob\/v28.0.0\/packages\/jest-core\/src\/TestScheduler.ts#L329-L364\r\n\r\nUp until Jest 27.5.1, the code looked like this, registering the `CoverageReporter` first: https:\/\/github.com\/facebook\/jest\/blob\/v27.5.1\/packages\/jest-core\/src\/TestScheduler.ts#L349-L380\r\n\r\nThis is probably a duplicate of the automatically closed #13479.\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: macOS 13.3\r\n  CPU: (10) arm64 Apple M1 Pro\r\nBinaries:\r\n  Node: 16.19.1 - ~\/.asdf\/installs\/nodejs\/16.19.1\/bin\/node\r\n  npm: 9.6.0 - ~\/.asdf\/plugins\/nodejs\/shims\/npm\r\nnpmPackages:\r\n  jest: ^29.5.0 => 29.5.0\r\n```\r\n","comments":["Thanks for reminding this issue. It was me who changed order of reporters some time ago.\r\n\r\nReverting it would be a breaking change. I think the problem is not the order, but the fact one of built-in reporters is adding coverage data to `aggregatedResult`. It sounds like better idea to populate the `coverageMap` before calling the `onRunComplete` method of each reporter. For example, here:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/257f250a977264656eca386629c7ce3b6481f21b\/packages\/jest-core\/src\/ReporterDispatcher.ts#L83-L92\r\n\r\nI will try to put this together. That is a breaking change as well, so it has to wait till next major.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This can't be stale, it's still in triage!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still needs triage!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@mrazauskas are you still up for sending a PR for this? \ud83d\ude42 ","Yes. Not this week, but in general I would like to do this.","@mrazauskas ping \ud83d\ude00 ","Any news on this?","Uff.. I can\u2019t find time unfortunately. Feel free to take it over."],"labels":[":bug: Bug","Pinned"]},{"title":"[Bug]: Watch fails if SL (Steam Locomotive) is installed","body":"### Version\n\n29.5.0\n\n### Steps to reproduce\n\n1. Install [SL (Steam Locomotive)](https:\/\/github.com\/mtoyoda\/sl); e.g. `brew install sl`\r\n2. Clone my repo https:\/\/github.com\/dvanoni\/jest-watch-sl-bug\r\n3. `npm install`\r\n4. `npx jest --watch`\n\n### Expected behavior\n\n`npx jest --watch` runs and prints the following message:\r\n\r\n```\r\nNo tests found related to files changed since last commit.\r\nPress `a` to run all tests, or run Jest with `--watchAll`.\r\n\r\nWatch Usage\r\n \u203a Press a to run all tests.\r\n \u203a Press f to run only failed tests.\r\n \u203a Press p to filter by a filename regex pattern.\r\n \u203a Press t to filter by a test name regex pattern.\r\n \u203a Press q to quit watch mode.\r\n \u203a Press Enter to trigger a test run.\r\n```\n\n### Actual behavior\n\n`npx jest --watch` fails with the following message:\r\n\r\n```\r\nDetermining test suites to run...\r\n\r\n  \u25cf Test suite failed to run\r\n\r\nthrown: [Error]\r\n```\n\n### Additional context\n\n#13941 introduced support for [Sapling](https:\/\/sapling-scm.com\/) which provides a command named `sl`. This conflicts with the `sl` command provided by [SL (Steam Locomotive)](https:\/\/github.com\/mtoyoda\/sl). When you have SL installed on your machine rather than Sapling, `jest-changed-files` fails to run properly.\n\n### Environment\n\n```shell\nSystem:\r\n  OS: macOS 13.2.1\r\n  CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\nBinaries:\r\n  Node: 18.15.0 - ~\/.asdf\/installs\/nodejs\/18.15.0\/bin\/node\r\n  npm: 9.5.0 - ~\/.asdf\/plugins\/nodejs\/shims\/npm\r\nnpmPackages:\r\n  jest: ^29.5.0 => 29.5.0\n```\n","comments":["Good catch. I was looking at Sapling documentation, might be there is one more related issue on PowerShell:\r\n\r\n> Note that the name of the Sapling CLI `sl.exe` conflicts with the `sl` shell built-in in PowerShell (`sl` is an alias for `Set-Location`, which is equivalent to `cd`).\r\n\r\nReference: https:\/\/sapling-scm.com\/docs\/introduction\/installation#windows\r\n\r\nSeems to be sensible to check that `sl` is really Sapling. Perhaps `sl --version` could be the command for this check? It prints: `Sapling [version number]`.","I think that would work. If you run `sl --version` with SL installed, you'll get the steam locomotive yet again. \ud83d\ude04 ","On my system, having `sl` installed didn't cause the tests to fail to run; rather, determining which tests to run takes a long time now with the `--watch` command, about 6 seconds. The tests execute instantly when running normally. Removing it via `pacman -R sl` makes `--watch` behave as before.\r\n\r\nEnvironment:\r\n\r\n```\r\n$ npx envinfo --preset jest \r\n  System: \r\n    OS: Linux 6.2 Arch Linux \r\n    CPU: (8) x64 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz \r\n  Binaries: \r\n    Node: 18.1.0 - ~\/.asdf\/installs\/nodejs\/18.1.0\/bin\/node \r\n    Yarn: 1.22.19 - ~\/.asdf\/shims\/yarn \r\n    npm: 9.6.2 - ~\/.asdf\/plugins\/nodejs\/shims\/npm \r\n  npmPackages: \r\n    jest: ^29.5.0 => 29.5.0 \r\n```","Copying from my own issue (which is now closed):\r\n\r\nHaving steam locomotive installed (on macOS via brew) caused watch runs to fail with a weird error:\r\n\r\n```\r\n  \u25cf Test suite failed to run\r\n\r\nthrown: [Error]\r\n```\r\n\r\nafter digging around it turned out that the formatting is bad (and probably should also be fixed) but that opaque error is actually the following:\r\n\r\n```\r\nError\r\n    at ChildProcess.spawn (node:internal\/child_process:413:11)\r\n    at Object.spawn (node:child_process:700:9)\r\n    at execa (\/Users\/nokel81\/repos\/lens\/node_modules\/jest-changed-files\/node_modules\/execa\/index.js:83:26)\r\n    at Object.findChangedFiles (\/Users\/nokel81\/repos\/lens\/node_modules\/jest-changed-files\/build\/sl.js:104:43)\r\n    at \/Users\/nokel81\/repos\/lens\/node_modules\/jest-changed-files\/build\/index.js:51:17\r\n    at Array.map (<anonymous>)\r\n    at getChangedFilesForRoots (\/Users\/nokel81\/repos\/lens\/node_modules\/jest-changed-files\/build\/index.js:50:43)\r\n    at processTicksAndRejections (node:internal\/process\/task_queues:96:5) {\r\n  errno: -63,\r\n  code: 'ENAMETOOLONG',\r\n  syscall: 'spawn',\r\n  originalMessage: 'spawn ENAMETOOLONG',\r\n  shortMessage: 'Command failed with ENAMETOOLONG: sl status -amnu \/Users\/nokel81\/repos\/lens\/packages\/core\\n' +\r\n    'spawn ENAMETOOLONG',\r\n  command: 'sl status -amnu \/Users\/nokel81\/repos\/lens\/packages\/core',\r\n  escapedCommand: 'sl status -amnu \"\/Users\/nokel81\/repos\/lens\/packages\/core\"',\r\n  exitCode: undefined,\r\n  signal: undefined,\r\n  signalDescription: undefined,\r\n  stdout: '',\r\n  stderr: '',\r\n  all: '',\r\n  failed: true,\r\n  timedOut: false,\r\n  isCanceled: false,\r\n  killed: false\r\n}\r\n```","I would like to suggest that fixing this issue should include displaying a more descriptive error in this case than the one it does:\r\n\r\n```console\r\n  \u25cf Test suite failed to run\r\n\r\nthrown: [Error]\r\n```","\/cc @vegerot ","We might need to revert the `sapling` support and figure out a better approach. The timeout suggested in https:\/\/github.com\/facebook\/jest\/pull\/14061 seems icky to me. My own suggestion of grepping man pages or crawling the FS doesn't seem good either.","We can take a similar approach to ripgrep and walk up the directory tree until we find a `.git`, `.sl`, or `.hg` directory which determines which program to use.\r\n\r\nI can come up with ridiculous edge cases.  What if someone install both \ud83d\ude82  and Sapling, but renames Sapling from `sl` to `sap`?  What do we do then?  I guess it would be the same problem if someone renames the `git` exe \ud83e\udd37\u200d\u2640\ufe0f .\r\n\r\nI think the best solution would be to detect \ud83d\ude82 and then skip running sapling.\r\n\r\nHacky proposal: check the size of `sl`.  \ud83d\ude82 is 34k and sapling is 49M.  I doubt \ud83d\ude82 will ever become more than 1Mb and Sapling will ever be less than 1Mb.  Let's skip running sl if sl < 1Mb.  We will have to resolve symlinks, etc.","@SimenB I called in the pros","> I would like to suggest that fixing this issue should include displaying a more descriptive error\r\n\r\nThe conclusion in https:\/\/github.com\/facebook\/sapling\/issues\/597 is similar, but what should that error say? \"Jest detected that `sl` binary is not Sapling. Please leave `sl` exclusively for Sapling\"?\r\n\r\nMany users will not know what Sapling is (I did not know few weeks ago). Also, why Jest needs `sl` to run the tests? Why a Git user should not be able to have Steam Locomotive installed? Tricky.\r\n\r\nThis brings an idea of some opt-out mechanism (leave my `sl` alone, please). Wait... Why not opt-in?! This is how I came to the idea of adding an `scm` configuration option (see https:\/\/github.com\/facebook\/jest\/pull\/14061#issuecomment-1500259969).\r\n\r\nJust wanted to explain what was the thinking path. Not a fan of adding more and more options.\r\n\r\nObviously the problem should be solved on Jest side. Its main task is to run tests. Having an opt-in `scm` option there will be no need to spent time guessing which is SCM is used in a repo. That is performance gain for test running. Users like performance and users like Steam Locomotive too (;\r\n\r\nPS By the way, if the default is set to `'git'`, only Mercurial and Sapling users will notice that something changed. Git users will get more performance for free.","I'm liking the [suggestion here](https:\/\/github.com\/facebook\/sapling\/issues\/597#issuecomment-1500619423) to ship a `sapling` command that could be used in this scenario instead of `sl`. It's certainly not the most immediate solution because it would require Sapling users to upgrade to a version that includes it (whenever that happens), but it does feel like the most robust suggestion I've seen.\n\nI think it would also avoid the issue of having to add some sort of `scm` option to Jest, and I think it also avoids the issue with any error message weirdness.\n\nOf course, this all assumes there isn't already some other tool that provides a `sapling` command. \ud83d\ude05 \n","> but what should that error say? \r\n\r\nI think that it should pass through the existing error, something like `'Command failed with ENAMETOOLONG: sl status -amnu \/Users\/nokel81\/repos\/lens\/packages\/core\\n' +\r\n    'spawn ENAMETOOLONG',`\r\n\r\nThis case doesn't need a special error, because the underlying issue should be fixed by one of the several proposals (a `sapling` command, only running `sl` if the scm configuration option is set to sapling, etc).\r\n\r\nJust having that error show up would unblock people, because you can see \"something is up with `sl`\".\r\n\r\nI'm asking for this also because this is not the only Jest error I've seen that failed with `thrown: [Error]` (the last ended up being something with watchman) and I'm hoping to get some insight into the next one of those I see, as well.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is certainly still an issue","@rmartine-ias I agree with you. If I would have seen that error I would have been able to find this bug report much faster. I only found it because I also started digging in node_modules for answers. Showing the error would help more people finding a faster solution.\r\n\r\nI uninstalled `sl` as my solution, I had even forgotten that I installed it just for fun ages ago.","> I uninstalled `sl` as my solution\r\n\r\nThis is the obviously correct solution.  The problem is that the error message is so bad people don't realize they need to do this.  I think we can check the size of the `sl` binary to provide a better error message.\r\n\r\n@sTRAGER also had another idea to improve the error reporting, but needs to elaborate it more","> This is the obviously correct solution. \r\n\r\nUnlinking\/uninstalling `sl` is a correct temporary *workaround* for this issue. (You could also use `direnv` to selectively alias it to `false` when working on jest projects, or wrap it in something that detects if jest is calling it, maybe...) \r\n\r\n[Homebrew](https:\/\/formulae.brew.sh\/formula\/sl#default) has > 20k people who have installed `sl` in the past year, debian [popcon](https:\/\/qa.debian.org\/popcon.php?package=sl) has > 1% of submitted reports with an install. I think that is more than enough usage to not declare incompatibility. It'd make me sad, too -- there is far too little whimsy on my computer and I do not like the idea that since one tool I must use has mistaken assumptions, I should have to reduce that further.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale, I like the idea of a config that defaults to git ",":+1: ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale, would be great if this was a configuration option instead ","@rmartine-ias I fully agree that uninstalling is a good temporary workaround.  What do you think a more permanent solution to the `jest --watch` incompatibility with everyone's favorite steam locomotive \u2764\ufe0f?  \r\n\r\nA config option? or something better possibly?","> @rmartine-ias I fully agree that uninstalling is a good temporary workaround. What do you think a more permanent solution to the `jest --watch` incompatibility with everyone's favorite steam locomotive \u2764\ufe0f?\r\n> \r\n> A config option? or something better possibly?\r\n\r\nI am not familiar with the project's internals, or what tradeoffs the maintainers make, so I don't think I am the person to ask. I am probably missing some context or misreading some code.\r\n\r\nThat said, I would:\r\n- Fix the error message system\r\n- Only [find roots](https:\/\/github.com\/jestjs\/jest\/blob\/f9398b12dfc235695e9a055d27a8f77936d07b01\/packages\/jest-changed-files\/src\/index.ts#L30) once, when starting the watch process\r\n- Store SCM source at that time on a new `Root` object\r\n- [Find sl roots](https:\/\/github.com\/jestjs\/jest\/blob\/f9398b12dfc235695e9a055d27a8f77936d07b01\/packages\/jest-changed-files\/src\/sl.ts#L59) through directory traversal, instead of binary calling (note: not sure if you'd need to look for [sapling-specific files](https:\/\/sapling-scm.com\/docs\/internals\/indexedlog) because of the git compatibility)\r\n- **AND\/OR**: Only find `sl` roots if any of the [sapling configuration files](https:\/\/sapling-scm.com\/docs\/introduction\/getting-started\/#setting-your-identity) exist\r\n\r\nI think this would get:\r\n- No errors, because `sl` isn't called unless a sapling root is found, and\/or a sapling config file exists\r\n- No need for additional configuration options, which would break existing workflows when mercurial\/sapling users have to add the new option across all machines (including CI)\r\n\r\nIt would make it so that adding or removing SCM roots while running watch does not work as prior, though. I am sure somebody is doing this. The \"only find roots once\" thing can be dropped; that is a performance enhancement of questionable value.\r\n\r\n","gosh I feel super frustrated when the worlds collide and you can't understand why that's happening.\r\n\r\nthe error message desperately need fixing. luckily, we do know the culprit in this example, but next time it could be some other piece of software causing interference and as-is there's not a single clue to tell the reason and debug.","~~Why not use `$(npm bin)\/sl` to call sapling?~~\r\nAh, because it's installed using brew as well, sorry.\r\n\r\nIn that case: Why not use `$(brew --prefix sapling)\/bin\/sl` to call sapling?","A framework whose purpose is to support quality approaches, with an error message like this (\"thrown: [Error]\"), with no fix in the 10 months since the bug was reported - it is shameful.  I just lost hours to this.  \r\n\r\nBy merely providing a clearer error message this would be greatly remediated, at least as a stopgap measure until a more sophisticated improvement can be made.","I just ran into the same issue; this needs to be fixed. I just spent a bunch of time debugging core jest code to properly have this error be thrown.","For a hacky solution to get yourself unblocked:\r\n* go into `node_modules\/jest-changed-files\/build\/sl.js`\r\n* inside `getRoot` return null"],"labels":["Help Wanted",":boom: Regression","Pinned"]},{"title":"[Bug]:  Manual mocks file name for node protocol imports (node:)","body":"### Version\n\n^29.5.0\n\n### Steps to reproduce\n\nI have added minimal code setup to following codesandbox\r\n\r\nhttps:\/\/codesandbox.io\/p\/sandbox\/jest-issue-node-protocol-b6ivxb\r\n\r\n\n\n### Expected behavior\n\nTo work with `node:` protocol inputs in manaul mocks without `node:` in the file name.\n\n### Actual behavior\n\nI can get this working on MacOS renaming the file to node:os.ts \r\nBut does failed checkout in Windows as colon is not permited to use in filename. Also Codesandbox doesn't allows to have colons in the file.\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 12.6.3\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\r\n  Binaries:\r\n    Node: 18.14.2 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.19 - ~\/.yarn\/bin\/yarn\r\n    npm: 9.5.0 - \/usr\/local\/bin\/npm\n```\n","comments":["Perhaps `node:` should be treated as namespaces module? I mean, mock file should be looked up in `node` directory, i.e. `node\/os.ts`.\n\nI'm trying to think how the fix should look. Does this make sense?\n\nEDIT `node:` is URL scheme. It might be better to simply ignore it while resolving manual mocks. Or?","I found out when you use it without `node:` you need to export is as module.export oppose to export default with `node:` version of manual mock. Is there any behaviour change on this?","Any updates on this?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Seems there is no update on this","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","> Perhaps `node:` should be treated as namespaces module? I mean, mock file should be looked up in `node` directory, i.e. `node\/os.ts`.\r\n> \r\n> I'm trying to think how the fix should look. Does this make sense?\r\n> \r\n> EDIT `node:` is URL scheme. It might be better to simply ignore it while resolving manual mocks. Or?\r\n\r\nI think moving towards a separate folder is a good approach to match Node's migration to the URL scheme. This'll free up the module paths avoiding future [collisions](https:\/\/www.npmjs.com\/package\/fs).\r\n\r\nBut given the scale of imposing a change like this, maybe it should start as an opt in feature, i.e. `useNodeURLPath`. ","@mrazauskas I can take a crack at this","Go on (;\r\n\r\nI was playing with this a but. Here is one detail to think about: what happens if a user is importing from `'node:fs'`, but in the test file `jest.mock('fs')` is called. I think that should work, because `'node:fs'` and `'fs'` should point to the same module.","I agree, and for compatibility's sake, this should be the default behavior. \r\n\r\nI also think that we should add an option to force paths to use the node URL scheme and `\/__mocks__\/node` to disambiguate between core modules and future packages with the same name since [npm are willing to give the paths away now.](https:\/\/www.npmjs.com\/package\/fs)\r\n\r\nEventually, this default behavior should be flipped where, to match Node's adoption,  the expectation will be to always use the URL scheme and put manual mocks in the node folder.\r\n\r\nWhat do you think?","It would be better to separate the fix of this issue and the `\/__mocks__\/node` path into two PRs \/ problems. It would be good to fix the issue without any breaking changes.\r\n\r\nThe thing is that adding new options is always tricky. Jest has too many options. I see users who are already lost and can\u2019t find what they look. Even simple helpers like the `--showConfig` flag are overlooked.","@mrazauskas Apologies for the late reply. I agree with your point and have just finished a [fix](https:\/\/github.com\/jestjs\/jest\/pull\/14297) to just the issue."],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"Update mocks to have optional arguments","body":"## Summary\r\nFixes #13961\r\n\r\nThis PR updates the following mocks to make their arguments optional:\r\n```js\r\n.mockImplementation()\r\n.mockImplementationOnce()\r\n.mockReturnValue()\r\n.mockReturnValueOnce()\r\n.mockResolvedValue()\r\n.mockResolvedValueOnce()\r\n.mockRejectedValue()\r\n.mockRejectedValueOnce()\r\n```\r\n\r\n\r\n## Test plan\r\n- Unit tests added.\r\n- Type tests added\r\n","comments":["By the way, looks like tests for `mockImplementation()` and `mockImplementationOnce()` are missing. Or those already exist in the test file and I'm just scrolling too fast? (;","@SimenB Just to leaving a note with my motivation on this use case.\r\n\r\nAt first I was rather sceptical about the idea. A method like `.mockReturnValue()` has 'value' in its name, which makes sound that calling it without value is somewhat wrong. (See discussion in the issue #13961.)\r\n\r\nIn the other hand, this was rather convincing example: `jest.spyOn(ServiceName, 'methodName').mockImplementation()`. Reads well, at least for me it is clear that the implementation will get erased, i.e. replaced with `() => {}`. So one can read `.mockReturnValue()` as: please return `void`. (Note that `.toHaveReturnedWith()` matcher also can be used without a value.)\r\n\r\nUnit tests show that calling the methods without values work as expected (there was one minor issue, but that looks like a bug). I think we can make a conclusion that in this case types were simply incorrect and did not reflect the reality.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@SimenB What you think? That\u2019s a compromise to accept that some type safety is lost, but I am more for it than against.","<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: EduardoSCosta \/ name: Eduardo Souza Costa Ara\u00fajo  (7fad8f5f4e0770648e6289a15a2e46050f0f6dac, 9e8592e442dfabe7d677bb32f4ae6ebcae690ef5, e9a2a9f944a4c77a8725a65c5627fc83c728ff88, 6352b44c7f1a53c16e561c872fd7c47f5f73cf18, 06a6370c3a3c5386045875def27b4d37f1f47248, 1a7858cacbfbc8959adf99da8678ad654b6c1684, 07c9a185e0601695d3b3a336a05610b86e45b13e, ed38c75044b2911f5761e383978daa84588edbcd, 2a4304f1637220847792cd96e29cece1d6cfb309, 4bbb9def01c4cf12cd47ca134acad4a9481a5c3c, a9eff9e653bd6e290a73e919af4f4a2262b6cc4c, cfba58434e0c9f506d2d531bbe5d1e839a3ba188, fa1328d66f2d7e429b2c18003099393a758cc7d5, 01d927cb23f15b21de34c21395f6a6299b028a0b, 0f198745fbc851ca07ca77ec7adebede0549cdaa, 7ad4b973c774990a484ce245fd0cfa54502711bf, 39560d411ca85e1ba79087ef3f1ee4dfca8e031b, e71dc09343dc555e04c16c1bf711ab614cb5d60b, 63f473dc21a39177b89f9abf979d47316ddf6cef)<\/li><li>:white_check_mark: login: SimenB \/ name: Simen Bekkhus  (ec902374f979716ee654cc8f55b27d1859dfa5cd, 679132c64bef84d1704d18b4991a2c1b5e0378ea)<\/li><\/ul>","@EduardoSCosta Could you sign the CLA, please?\r\n\r\nI see that you sign Facebook CLA, but since Jest repo was transferred to OpenJS Foundation another CLA is required. Sorry about this inconvenience. There is no other way to move forward with the PR, unfortunately.","done, @mrazauskas \ud83d\ude04 ","Thanks! Could you rebase and resolve conflicts, please? Can be that only changelog is the problem. Would be good to clean up, just in case.","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 679132c64bef84d1704d18b4991a2c1b5e0378ea |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/65129b6a85fb1200082a8f1c |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-14035--jestjs.netlify.app](https:\/\/deploy-preview-14035--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTE0MDM1LS1qZXN0anMubmV0bGlmeS5hcHAifQ.h8zYwbIpJDwP1eA8V-QZ_lPPNwkFryik-sP1CVyTQc0)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","Hmm, actually - should we tweak the docs to mention the return value can be omitted?\r\n\r\nhttps:\/\/jestjs.io\/docs\/mock-functions#mock-return-values","Hi @EduardoSCosta! Is this PR blocked by something?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Stale"]},{"title":"[Feature]: Programmatic api to resolve the entire config and run jest","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nHi \ud83d\ude4b\u200d\u2642\ufe0f It's me again \ud83d\ude05.\r\n\r\nWe currently use this code to resolve the jest config programmatically:\r\n\r\n```js\r\nconst requireFromJest = createRequire(require.resolve('jest', { paths: [resolveFromDirectory] }));\r\nconst requireFromJestCli = createRequire(requireFromJest.resolve('jest-cli'));\r\nconst jestConfig = requireFromJestCli('jest-config');\r\nconst { config, configPath } = jestConfig.readInitialOptions();\r\n```\r\n\r\nHowever, this doesn't seem to resolve presets. I.e. this:\r\n\r\n```js\r\n\/\/ jest.config.js\r\nmodule.exports = { preset: 'jest-preset-angular' };\r\n```\r\n\r\nResults in `{ preset: 'jest-preset-angular' }`\r\n\r\nI would love a way to resolve the entire config inc presets and use that config to run jest.\r\n\r\n### Motivation\r\n\r\nIn StrykerJS, we're running jest programmatically in the `@stryker-mutator\/jest-runner` plugin. We need to wrap around the user's configured test environment because we need access to the global variables to report mutation coverage; we're using the workaround specified here: https:\/\/github.com\/facebook\/jest\/issues\/7421#issuecomment-442451426\r\n\r\nTo do that, we want to know which test environment the user configured. That way, we can override that test environment by a class that extends the user's test environment (a mixin class):\r\n\r\n```js\r\nfunction mixinJestEnvironment(JestEnvironmentClass) {\r\n   class StrykerJestEnvironment extends JestEnvironmentClass {\r\n      constructor(config, context) {\r\n        super(config, context);\r\n        this.global.__stryker__ = globalThis.__stryker__; \/\/ coverage is reported on __stryker__\r\n      }\r\n      \/\/ ...\r\n  }\r\n  return StrykerJestEnvironment;\r\n}\r\n```\r\n\r\nWhen the `testEnvironment` is empty, we assume the default (\"node\"), which is incorrect when the preset would override to, say, \"jsdom\".\r\n\r\nSee also: https:\/\/github.com\/stryker-mutator\/stryker-js\/issues\/4068\r\n\r\n### Example\r\n\r\nIdeally, we would like to read the config for a project and use that in the `runCLI` API (or similar API).\r\n\r\n```js\r\nconst requireFromJest = createRequire(require.resolve('jest', { paths: [process.cwd()] }));\r\nconst requireFromJestCli = createRequire(requireFromJest.resolve('jest-cli'));\r\nconst jest = requireFromJestCli('jest');\r\nconst jestConfig = requireFromJestCli('jest-config');\r\nconst { globalConfig, projectConfig} = jestConfig.readConfig(argv);\r\n\r\n\/\/ Override the jest env\r\nglobalThis.originalJestEnv = projectConfig.testEnvironment ?? globalConfig.testEnvironment ?? 'node';\r\nprojectConfig.testEnvironment  = 'stryker-jest-env';\r\n\r\nconst { results } = await jest.run(globalConfig, projectConfig);\r\n```\r\n\r\n### Pitch\r\n\r\nA proper programmatic API would help the mission for [Jest as a Platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs).","comments":["It might be pretty straightforward to export and document `_run10000` https:\/\/github.com\/facebook\/jest\/blob\/b38d7d345a81d97d1dc3b68b8458b1837fbf19be\/packages\/jest-core\/src\/cli\/index.ts#L170","I would guess that using `readConfig` (or `readConfigs`) instead of `readInitialOptions` would work? Untested, tho","Yes, that would work. The problem is that there is currently no api (private or public) to run jest with that config. ","Aha. Happy to expose that \ud83d\ude42","F.y.i. I was wondering why it was called `_run10000`. But I found it here \ud83d\ude01: https:\/\/github.com\/facebook\/jest\/pull\/10000\/files","@SimenB I've started some work and presented it in a draft PR: #14062\r\n\r\nPlease confirm I'm on the right track. I'll add more tests and document the whole thing in `\/docs` when you confirm \u263a","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","It's not stale! It has an active PR \ud83d\ude07","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Please keep it open","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Yeah, I'll get around to it eventually. Plz keep open","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Hi, I'm really interested by this feature! My use case is to run integration tests on a VSCode Extension. Basically, I want to run jest tests inside the VSCode runtime. This is well documented in VSCode, and I'm currently able to do a `jest.run\/jest.runCli` inside the VSCode environment. However, these functions fork into another process which loses all that context.\r\n\r\nWould the current PR allow to run Jest **without forking**?\r\n\r\nThanks for your dedication!"],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Bug]: `structuredClone` fails on `toStrictEqual`","body":"### Version\r\n\r\n29.4.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone my repository at https:\/\/github.com\/JamieMagee\/jest-structuredclone-strictequal\/blob\/master\/index.spec.js\r\n2. `npm install`\r\n3. `npm test`\r\n\r\n### Expected behavior\r\n\r\nI expect to see objects cloned with `structuredClone` to pass `toStrictEqual`\r\n\r\n### Actual behavior\r\n\r\nThe values do not pass `toStrictEqual` (but do pass `toEqual`).\r\n\r\n```\r\njest \u203a toStrictEqual \u203a structured clone\r\n\r\n    expect(received).toStrictEqual(expected) \/\/ deep equality\r\n\r\n    Expected: {\"value\": \"test\"}\r\n    Received: serializes to the same string\r\n\r\n       6 |     describe('toStrictEqual', () => {\r\n       7 |         it('structured clone', () => {\r\n    >  8 |             expect(structuredClone(value)).toStrictEqual(value);\r\n         |                                            ^\r\n       9 |         });\r\n      10 |         it('JSON clone', () => {\r\n      11 |             expect(JSON.parse(JSON.stringify(value))).toStrictEqual(value);\r\n\r\n      at Object.toStrictEqual (index.spec.js:8:44)\r\n```\r\n\r\nHowever `JSON.parse(JSON.stringify())` does pass `toStrictEqual`\r\n\r\n### Additional context\r\n\r\nThe test output can be seen in [this GitHub Actions run](https:\/\/github.com\/JamieMagee\/jest-structuredclone-strictequal\/actions\/runs\/4406780242\/jobs\/7719495152).\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: Linux 6.2 NixOS 23.05 (Stoat) 23.05 (Stoat)\r\n  CPU: (32) x64 AMD Ryzen 9 7950X 16-Core Processor\r\nBinaries:\r\n  Node: 19.7.0 - \/run\/current-system\/sw\/bin\/node\r\n  Yarn: 1.22.19 - \/run\/current-system\/sw\/bin\/yarn\r\n  npm: 9.5.0 - \/run\/current-system\/sw\/bin\/npm\r\n```\r\n","comments":["I was playing with `assert` and `expect`:\r\n\r\n```js\r\nimport assert from \"node:assert\";\r\nimport { expect } from \"@jest\/globals\";\r\n\r\n\/\/ equality\r\n\r\nassert.deepEqual(JSON.parse(JSON.stringify(value)), value); \/\/ pass\r\nexpect(JSON.parse(JSON.stringify(value))).toEqual(value); \/\/ pass\r\n\r\nassert.deepEqual(structuredClone(value), value); \/\/ pass\r\nexpect(structuredClone(value)).toEqual(value); \/\/ pass\r\n\r\n\/\/ strict equality\r\n\r\nassert.deepStrictEqual(JSON.parse(JSON.stringify(value)), value); \/\/ pass\r\nexpect(JSON.parse(JSON.stringify(value))).toStrictEqual(value); \/\/ pass\r\n\r\nassert.deepStrictEqual(structuredClone(value), value); \/\/ fail !!!\r\nexpect(structuredClone(value)).toStrictEqual(value); \/\/ fail !!!\r\n```\r\n\r\nHm.. if Node and Expect agrees, that is correct behaviour. Or did I miss something?","Might be this is the explanation:\r\n\r\n```js\r\nObject.getPrototypeOf(value) === Object.getPrototypeOf(JSON.parse(JSON.stringify(value))) \/\/ true\r\n\r\nObject.getPrototypeOf(value) === Object.getPrototypeOf(structuredClone(value)) \/\/ false\r\n```","Okay, it looks like this might be a limitation of `structuredClone` and we should use `toEqual` instead. [From MDN][1] (emphasis mine):\r\n\r\n> Certain object properties are not preserved:\r\n>\r\n> - The lastIndex property of [RegExp](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/RegExp) objects is not preserved.\r\n> - Property descriptors, setters, getters, and similar metadata-like features are not duplicated. For example, if an object is marked readonly with a [property descriptor](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/getOwnPropertyDescriptor), it will be read\/write in the duplicate, since that's the default.\r\n> - **The prototype chain is not walked or duplicated.**\r\n\r\n[1]: https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/Web_Workers_API\/Structured_clone_algorithm#things_that_dont_work_with_structured_clone","My gut feeling is that I would not want to stop using `.toStrictEqual(value)` but would prefer another solution than to start using `.toEqual(value)`.\r\n\r\n`.toStrictEqual(value)` verifies a lot of other nice things. From https:\/\/jestjs.io\/docs\/expect#tostrictequalvalue:\r\n\r\n> - keys with `undefined` properties are checked, e.g. `{a: undefined, b: 2}` will not equal `{b: 2}`;\r\n> - `undefined` items are taken into account, e.g. `[2]` will not equal `[2, undefined]`;\r\n> - array sparseness is checked, e.g. `[, 1]` will not equal `[undefined, 1]`;\r\n>  - object types are checked, e.g. a class instance with fields `a` and `b` will not equal a literal object with fields `a` and `b`.\r\n\r\nI wish to not loose all these checks when using `structuredClone()`.\r\n\r\nI am not sure of the solution. One option could be to in a major version (i.e. a breaking change) omitting `.toStrictEqual(value)` to check for the prototype. Another option would be a new function.\r\n\r\nAny other options we have?","Indeed it would be useful to be able to use `.toStrictEqual()` in this case as well. What about: `.toStrictEqual(value, {skipPrototypeCheck: true})` or similar option?","@mrazauskas that is one solution. It kind of goes against other APIs at https:\/\/jestjs.io\/docs\/expect. Few function have a second argument. And if they do, it is not an object (possibly for readability?).\r\n\r\nIf a second argument is the way to go I think this is nicer: `.toStrictEqual(value, skipPrototypeCheck?)` . Could\/would be nice to add to the docs for the argument `skipPrototypeCheck` that it can be used when calling code that uses `structuredClone()`. Just as a common example.\r\n\r\nI am not sure if @SimenB has more input on how a new API to cover this should look. Argument, new function or something else.","Not sure how you define readability. A bag of options is easier to extend in the future and is understandable without looking at the docs:\r\n\r\n`.toStrictEqual(value, {skipPrototypeCheck: true, skipUndefinedCheck: false})`\r\n`.toStrictEqual(value, true, false)`\r\n\r\n`.toStrictEqual(value, {skipUndefinedCheck: false})`\r\n`.toStrictEqual(value, undefined, false)`","Yeah, I agree it is subjective.\r\n\r\nWould a new `toBeClone()` add too many similar APIs?","Great idea! I could see `.toBeClone()` implemented in [Jest Extended](https:\/\/jest-extended.jestcommunity.dev\/docs\/matchers#object) next to `.toBeFrozen()` and `.toBeSealed()`.\r\n\r\nI guess prototype should be somehow replaced for both objects before sending them into `equals()` and that is it. Or?","Selfish wish would be for it to be part of the core Jest expect functions, since we avoid Jest Extended as to not complicate users with too many options. But that is entirely subjective, as much is \ud83d\ude06 One reason to keep it on the core Jest Expect lib would be that `structuredClone()` is a standard\/global API that exists on the global object.\r\n\r\nAs for the question about `equals()` I do not know the details how the comparison is done internally. In general, replacing the prototype is considered bad and not great for performance, see https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/setPrototypeOf. Not sure if that detail adds any value to how `equals()` works?\r\n\r\n","By the way, I was trying to implement a custom matcher and came to this idea:\r\n\r\n```js\r\nconst value = { test: 123 };\r\nconst received = structuredClone(value);\r\n\r\nexpect(received).toStrictEqual(structuredClone(value)); \/\/ pass !!!\r\n```","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I suppose this is still a great feature to have.","Hi there ! I just stumbled upon the same issue, and I agree that, given [`structuredClone`](https:\/\/web.dev\/structured-clone\/) is now part of the standard library and more and more codebases, there should be an appropriate test for it. \r\n\r\nOne particular sample that should pass IMO is the following:\r\n```typescript\r\ndescribe('foo', () => {\r\n    test('date check', () => {\r\n        const date = new Date();\r\n        expect(structuredClone(date)).toStrictEqual(date);\r\n    });\r\n});\r\n```\r\nThis currently fails with \r\n```\r\n\r\nexpect(received).toStrictEqual(expected) \/\/ deep equality\r\n\r\n    Expected: 2023-05-23T13:12:11.576Z\r\n    Received: serializes to the same string\r\n```\r\n\r\nThis is key to me because using the `JSON.parse(JSON.stringify(...))` technique does not accommodate nested dates objects (they are serialised to strings), where `structuredClone` does.\r\nI don't really get what Jest sees to differentiate the original and the clone in the date exemple above, aren't the prototypes the same?","@Marchelune if you read this thread and https:\/\/github.com\/jestjs\/jest\/issues\/14011#issuecomment-1473947328 and also the comment after it, it answers the question.","@thernstig I did read that and I saw the prototypes aren't the same but it still doesn't explain why it is so.","@thernstig it specifically says `The prototype chain is not walked or duplicated.` which means after `structuredClone` the new object has no object sets for its prototype, meaning it cannot be the same. Does that not explain it?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Feels important enough to keep alive as I suspect modern JavaScript will use structuredClone","As already mentioned, the solution is simple:\r\n\r\n```ts\r\nconst value = { test: 123 };\r\nconst received = structuredClone(value);\r\n\r\nexpect(received).toStrictEqual(structuredClone(value)); \/\/ pass !!!\r\n```\r\n\r\nA new `.toBeClone()` matcher is not a good idea, because it will be passing with values wich aren\u2019t clones. There is no mechanism to check that. I think above example reads well, declares the intent and does the right job. No need to overthink.","@mrazauskas close this thread then? Or is it a docs issue?","Narrowed this down to `typeEquality`:\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/0fd5b1c37555f485c56a6ad2d6b010a72204f9f6\/packages\/expect-utils\/src\/utils.ts#L372-L387\r\n\r\nSpecifically, the `a.constructor === b.constructor` check fails, because of https:\/\/github.com\/jestjs\/jest\/issues\/2549. This has been reported before: https:\/\/github.com\/jestjs\/jest\/issues\/14074 This is an unwanted side effect of this old PR: https:\/\/github.com\/jestjs\/jest\/pull\/7005 Dropping isolation is not an option, so I think the only solution is to improve `typeEquality`. Maybe a lookup table can be introduced when isolating the modules, mapping \"fake\" constructors to the originals? So the comparison would be this:\r\n\r\n```ts\r\n(originals[a.constructor] ?? a.constructor) === (originals[b.constructor] ?? b.constructor)\r\n```\r\n\r\nAlternatively, something could be done about the isolation code, preserving the constructor, maybe?","> Hm.. if Node and Expect agrees, that is correct behaviour. Or did I miss something?\r\n\r\nIt seems @mrazauskas did miss something:\r\n```js\r\nconst assert = require(\"node:assert\");\r\nconst util = require(\"node:util\");\r\nconst values = [\"string\", 1234, [], [1, 2, 3], {}, { 0: 0 }, new Date()];\r\n\r\nconst errors = [];\r\nconsole.log(\"assert.deepStrictEqual(value, structuredClone(value))\");\r\nfor (const value of values) {\r\n  try {\r\n    assert.deepStrictEqual(value, structuredClone(value));\r\n    console.log(`    PASS (value=${util.inspect(value)})`);\r\n  } catch (error) {\r\n    console.log(`    FAIL (value=${util.inspect(value)})`);\r\n    errors.push(error);\r\n  }\r\n}\r\nfor (const error of errors) {\r\n  console.error(error.message);\r\n}\r\n```\r\nRunning this with `node` directly passes all asserts.\r\nThis is inconsistent with what `jest` does, even worse, it seems to disagree with *it's own `assert`*:\r\n```js\r\nconst assert = require(\"node:assert\");\r\nconst values = [\"string\", 1234, [], [1, 2, 3, 4], {}, { 0: 0 }, new Date()];\r\n\r\ndescribe(\"expect(structuredClone(value)).toStrictEqual(value)\", () => {\r\n  test.each(values)(\"value=%s\", (value) => {\r\n    expect(structuredClone(value)).toStrictEqual(value);\r\n  });\r\n});\r\ndescribe(\"assert.deepStrictEqual(value, structuredClone(value))\", () => {\r\n  test.each(values)(\"value=%s\", (value) => {\r\n    assert.deepStrictEqual(value, structuredClone(value));\r\n  });\r\n});\r\n```\r\n```\r\n FAIL  .\/jest.test.js\r\n  expect(structuredClone(value)).toStrictEqual(value)\r\n    \u2713 value=string (2 ms)\r\n    \u2713 value=1234\r\n    \u2713 value=[]\r\n    \u2713 value=[ 1, 2, 3, 4 ] (1 ms)\r\n    \u2715 value={} (2 ms)\r\n    \u2715 value={ '0': 0 } (1 ms)\r\n    \u2715 value=2023-08-16T08:02:14.163Z\r\n  assert.deepStrictEqual(value, structuredClone(value))\r\n    \u2713 value=string (1 ms)\r\n    \u2713 value=1234\r\n    \u2715 value=[] (3 ms)\r\n    \u2715 value=[ 1, 2, 3, 4 ]\r\n    \u2715 value={}\r\n    \u2715 value={ '0': 0 } (1 ms)\r\n    \u2715 value=2023-08-16T08:02:14.163Z (1 ms)\r\n```","@Grub4K Thanks. Good catch!\r\n\r\nSeems like this is simply #2549. Using [`jest-light-runner`](https:\/\/github.com\/nicolo-ribaudo\/jest-light-runner) solves the problem. Reference: https:\/\/github.com\/jestjs\/jest\/issues\/2549#issuecomment-1098071474\r\n\r\nWith `jest-light-runner` I got:\r\n\r\n```bash\r\n PASS  tests\/quick.test.js\r\n  expect(structuredClone(value)).toStrictEqual(value)\r\n    \u2713 value=string (1 ms)\r\n    \u2713 value=1234 (0 ms)\r\n    \u2713 value=[] (0 ms)\r\n    \u2713 value=[ 1, 2, 3, 4 ] (0 ms)\r\n    \u2713 value={} (0 ms)\r\n    \u2713 value={ '0': 0 } (0 ms)\r\n    \u2713 value=2023-08-16T10:11:58.274Z (0 ms)\r\n  assert.deepStrictEqual(value, structuredClone(value))\r\n    \u2713 value=string (0 ms)\r\n    \u2713 value=1234 (0 ms)\r\n    \u2713 value=[] (0 ms)\r\n    \u2713 value=[ 1, 2, 3, 4 ] (0 ms)\r\n    \u2713 value={} (0 ms)\r\n    \u2713 value={ '0': 0 } (0 ms)\r\n    \u2713 value=2023-08-16T10:11:58.274Z (0 ms)\r\n```\r\n\r\nWould be interesting to try this out wider. \r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@mrazauskas sorry for asking, but I am a bit confused as to the conclusion of this now. Is the suggestion for everyone to switch to jest-light-runner. Considering that Node assert also handles this. ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Comment. Still a bug.","> @thernstig it specifically says `The prototype chain is not walked or duplicated.` which means after `structuredClone` the new object has no object sets for its prototype, meaning it cannot be the same. Does that not explain it?\r\n\r\nI don't think that's correct. My reading is that it won't recursively deep clone the prototype chain, which makes sense.\r\n\r\nThis can be seen by trying out these two lines in your browser or Node.js repl: \r\n\r\n```js\r\nstructuredClone([]).constructor === [].constructor\r\n\/\/ => true\r\n\r\nObject.getPrototypeOf([]) === Object.getPrototypeOf(structuredClone([]))\r\n\/\/ => true\r\n```\r\n\r\n-----\r\n\r\nI think that this is Jest specific, because trying the same within the Jest runner results in another behaviour:\r\n\r\n```js\r\nconsole.error(structuredClone([]).constructor === [].constructor)\r\n```\r\n\r\n```text\r\n  \u25cf Console\r\n\r\n    console.error\r\n      false\r\n\r\n    > 119 |       console.error(structuredClone([]).constructor === [].constructor)\r\n          |               ^\r\n\r\n```\r\n\r\n-----\r\n\r\nMy guess is that this has something to do with worker threads\/sandboxing\/custom global environment, where maybe the global `Array` isn't the same as the `Array` constructor that `structuredClone` uses. But I'm not familiar enough with the inner workings of Jest to say for sure...","I'm a little confused about the recent discourse, doesn't the analysis I posted explain the bug? https:\/\/github.com\/jestjs\/jest\/issues\/14011#issuecomment-1656921872 Now a collaborator just needs to take a look and decide what next.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Be kind to us bot","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","> Be kind to us bot\r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","pls no stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","this is still open IMO."],"labels":["Needs Triage","Bug Report"]},{"title":"chore: correctly update worker state","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n@phawxby Is this correct? Comes from https:\/\/github.com\/facebook\/jest\/pull\/13107\/files#diff-4312b4a12bd45273f393d079b8d72df5c29472b71b2f047cb1263cb790ccff12R128\r\n\r\nJust a comparison does nothing on its own\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\n\ud83e\udd37 \r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["Yeah, your change looks right. That's a bit of a dumb bug on my part.","Cool, thanks \ud83d\udc4d \r\n\r\nCI is unhappy about it though - would you be able to take a look?","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\n\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 28ac1106625ada8354ef0947c744a815e4a5d93b |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/64bbc10f50bbcf0008287504 |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-13938--jestjs.netlify.app](https:\/\/deploy-preview-13938--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTEzOTM4LS1qZXN0anMubmV0bGlmeS5hcHAifQ.CpLZV4E-_jPBR5ugm-AxPqSh9ESz-FRVzi_SJkisUN8)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@phawxby you wouldn't happen to know why CI is failing? \ud83d\ude05 "],"labels":["cla signed","Pinned"]},{"title":"[Bug]: the jest tests performance dropped badly from node 14 to 19","body":"### Version\n\n29.4.2\n\n### Steps to reproduce\n\nI have a suite of `2158` tests distributed in `396` files - actually, we have more that we decided to skip in the CI because of the actual issue.\r\n\r\nEach test requires some imports, and some of them are done globally, via `setupFiles` and some are imported via the tests.\r\n\r\nThe total import size per test file is around `20MB`.\r\n\r\nWe were using `node 14` in our ecosystem, but because of some other factors, we decided to upgrade to the latest node version (19). Doing so we quickly noticed that our CI time for the jest tests more than doubled.\r\n\r\nThose being said we start measuring our suite against multiple node versions. All tests were done multiple times on each node version with --no-cache enabled, in order to get the most accurate readings.\r\n\r\nNode 14 - 60s\r\nNode 16 -  90s\r\nNode 18 - 120s\r\nNode 19 - 160s\r\n\r\nFor exact versions of node here is the detailed list.\r\n```ini\r\n nvm ls\r\n    19.5.0\r\n  * 18.14.0 (Currently using 64-bit executable)\r\n    16.16.0\r\n    14.20.0\r\n```\r\n\r\nThe npm command used for running the tests\r\n```javascript \r\njest --watchAll=true --config=\\\".\/_tests\/jest-tests.config.js\\\"\r\n```\r\n\r\njest-test.config.js\r\n```javascript\r\nconst config = {\r\n\tverbose: true,\r\n\tmoduleDirectories: [\r\n\t\t\"node_modules\",\r\n\t\t\"<rootDir>\/Dist\/js\/\",\r\n\t\t\"<rootDir>\/Dist\/js\/static\/\"\r\n\t],\r\n\ttestEnvironment: \"jsdom\",\r\n\ttestMatch: [\r\n\t\t\"**\/_Tests\/**\/*spec.js\",\r\n\t\t\"**\/_Tests\/**\/*Test.js\",\r\n\t\t\"**\/_Tests\/**\/*Tests.js\"\r\n\t],\r\n\ttransformIgnorePatterns: [\r\n\t\t\"\/node_modules\/\",\r\n\t\t\"<rootDir>\/Dist\/js\/\",\r\n\t\t\"<rootDir>\/Dist\/js\/static\/\"\r\n\t],\r\n\tsetupFiles: [\r\n\t\t\"<rootDir>\/_Tests\/Setup\/Common.globals.js\", \/\/ this is used for main-level mocks, and addressing some global variables\r\n\t\t\"<rootDir>\/_Tests\/Setup\/Common.setup.js\" \/\/ used for importing global stuffs like jquery, fake-indexeddb, some bundled content \r\n\t],\r\n\trootDir: \"..\",\r\n\troots: [\r\n\t\t\"<rootDir>\/_Tests\",\r\n\t\t\"<rootDir>\/Scripts\"\r\n\t],\r\n\ttestResultsProcessor: \"jest-junit\",\r\n\twatchman: false\r\n};\r\n\r\nmodule.exports = config; \r\n```\r\n\r\nAnother important fact is that the jsdom was locked to 16.4.0 as this affects all the test suites.\n\n### Expected behavior\n\nPerformance to not decrease like that over upgrading the node version.\n\n### Actual behavior\n\nThe performance between node 19 and node 14 is almost 3 times worse.\n\n### Additional context\n\nAs this comes from a real project we can't offer additional context at the given time.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 10 10.0.19044\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-10850H CPU @ 2.70GHz\r\n  Binaries:\r\n    Node: 18.14.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 9.3.1 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: 29.4.2 => 29.4.2\n```\n","comments":["I'm currently in the process of upgrading a project to node 18 and jest 29 and noticed a similar drop in performance on newer node versions.\r\n\r\nOur specs:\r\nTest Files: 495\r\nTests: 4135\r\n\r\njest config:\r\n```js\r\nmodule.exports = {\r\n    testEnvironment: \"jsdom\",\r\n    testEnvironmentOptions: {\r\n        url: \"http:\/\/localhost\" \r\n    },\r\n    setupFiles: [\"core-js\", \"<rootDir>\/tests\/setup\"],\r\n    setupFilesAfterEnv: [\r\n        \"<rootDir>\/tests\/matchers.ts\",\r\n        \"<rootDir>\/tests\/jsdomPatch.js\",\r\n        \"<rootDir>\/enzyme.config.js\"\r\n    ],\r\n    testMatch: [\"**\/*.spec.(js|ts|jsx|tsx)\"],\r\n    moduleFileExtensions: [\"js\", \"json\", \"ts\", \"jsx\", \"tsx\"],\r\n    moduleNameMapper: require(\".\/aliases.config\").jest,\r\n    coverageDirectory: \"<rootDir>\/coverage\",\r\n    coverageReporters: [\"html\", \"json\", \"cobertura\"],\r\n    reporters: [\r\n        \"default\"\r\n    ],\r\n    transformIgnorePatterns: [\r\n        \"node_modules\/(?!(react-grid-layout\/css|react-resizable\/css|lodash-es|nanoid)\/)\"\r\n    ],\r\n    testResultsProcessor: \"jest-sonar-reporter\"\r\n};\r\n```\r\n\r\n**Environment**\r\nSystem:\r\n    OS: Windows 10 10.0.19044\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz\r\n  Binaries:\r\n    Node: 14.18.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.17 - C:\\Program Files\\nodejs\\yarn.CMD\r\n    npm: 6.14.8 - ~\\AppData\\Roaming\\npm\\npm.CMD\r\n  npmPackages:\r\n    jest: 29.4.3 => 29.4.3\r\n\r\n**Test Performance**\r\nNote: only node version was changed when collecting these run times. Cold runs always started with `jest --clearCache` running prior to the tests themselves\r\n\r\nnode 14.18.1\r\ncold run: 239s\r\nhot run: 196s\r\n\r\nnode 18.14.2\r\ncold run: 276s\r\nhot run: 240s\r\n\r\n","Not sure if this is relevant, but the issue may be coming from node itself: https:\/\/github.com\/nodejs\/node\/issues\/45662","We are also facing the same issue while updating from node 12 to node 19","Same issue, updated node 12 -> 18 and Jest 26 -> 27. We have about  1000 test suites, time of testing on Jenkins CI went from 10 minutes to 23 minutes.\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I recently got a new dev machine and wanted to re-run jest + webpack on versions 14\/16\/18 of nodejs. \r\n\r\nnew machine specs:\r\n System:\r\n    OS: Windows 10 10.0.19044\r\n    CPU: (16) x64 11th Gen Intel(R) Core(TM) i9-11950H @ 2.60GHz\r\n  Binaries:\r\n    Node: 14.18.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.19 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 6.14.15 - C:\\Program Files\\nodejs\\npm.CMD\r\n\r\nBelow are the updated results:\r\n\r\n| command              | mode | 14.18.1 | 16.20.0 | 18.16.0 |\r\n|----------------------|------|---------|---------|---------|\r\n| unit (jest 29.4.3)   | cold | 72.0s   | 128.66  | 103.5s  |\r\n| unit (jest 29.4.3)   | hot  | 72.28s  | 90.71s  | 91.96s  |\r\n| build (webpack 5.70) | cold | 64.05s  | 88.28s  | 54.66s  |\r\n| build (webpack 5.70) | hot  | 38.4s   | 46.16s  | 31.17s  |\r\n\r\nNote: none of the source code or npm packages were changed between runs. On cold runs, I did delete cached webpack artefacts.\r\n\r\nFrom node 14 to 18, our jest tests ran 27% slower while our webpack build was 18% faster. This leads me to believe that the issue is not solely with node itself but some interaction between node + jest.\r\n\r\nLet me know if there is any other information that you need.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","So, jest has a huge community, but nobody is interested in performance?!? ","duplicate of #11956 I expect","jest 29.5.1, node 16.10 -> 18.16\r\n\r\nat github actions runner with `maxWorkers=2`\r\n\r\n| 16.10 | 18.16 |\r\n|--------|--------|\r\n| 21min | 27min | ","Hi, same here. Any solution?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Same thing. A huge drop of performance. I've used Angular 12 with jest 26 and CI and node 16 and tests run 5 minutes. Now I'm using Angular 15 with jest 29 and Node 18 and I'm getting 10-11 minutes with the same pack of tests.","From Node 16.4.2 to 16.14.0 or any newer version makes our current suit go from 20~ to 50+ seconds to run.","> jest 29.5.1, node 16.10 -> 18.16\r\n> \r\n> at github actions runner with `maxWorkers=2`\r\n> \r\n> 16.10\t18.16\r\n> 21min\t27min\r\n\r\nOurs went from 3min to 9min with 5 shards : \/\r\n\r\nNode 16\r\n<img width=\"164\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/29472480\/2e3e1d8a-3e29-4548-a809-8cff5de6b07a\">\r\n\r\nNode 20\r\n<img width=\"162\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/29472480\/ed97573a-45a3-47c6-9fcb-546efb48c14e\">\r\n\r\nTested with node 18, same thing. Same workflow on both.","Same here. Upgraded from Node14 to Node18 and unit tests now take >250s when they used to take just 70s","Has anyone resolved this issue? I have 350~ passing tests in node 14 and switching to node 16 or 18 causes my tests to take forever and failures start happening","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is a duplicate of #11956 follow that incident for updates - tldr light is at the end of the tunnel - there is a pr that fixed node js","Most of the comments in this issue is indeed a duplicate of https:\/\/github.com\/jestjs\/jest\/issues\/11956. But this from the OP doesn't seem like the same thing:\r\n\r\n```\r\nNode 14 - 60s\r\nNode 16 - 90s\r\nNode 18 - 120s\r\nNode 19 - 160s\r\n```","I have a similar issue, migrating from node 18 to 20, tests are 2x slower, we have a lot of tests in our app with jsdom, I also tried jest 30.0.0 alpha1 in order to use jsdom 22 but doesn't seem to improve the situation. here are some benchmarks:\r\n\r\nNode 18: 587s\r\nNode 20: 1182s\r\n\r\nOn the CI:\r\nNode 18 (80% workers): 6min5s - 7min46s\r\nNode 20 (80% workers): 24min (and some tests failing occasionally with timeout default [5000ms])\r\nNode 20 (60% workers): 11min40s\r\n","Do you have a reproduction for this somehow?\r\n\r\nAnd can you try with Node 21, that should have some good improvements (but not related to regression between 18 and 20)","Thank you @SimenB ! Node 21 works much better:\r\n\r\nnode21 80% workers: **436s**\r\nnode21 100% workers: **349s**\r\n(testing done with jest 30 alpha1 and jsdom 22.1.0)\r\n\r\nSo even better than node 18, and it's scaling much better with the number of workers, which is great news!\r\n\r\nFor now we'll postpone the migration I think, as we want to stay on LTS versions only on our CI environments. \r\nEDIT: ~~If you have hints on what's different between v20 and v21 and if these improvement will come to v20 later, I'll be interested, otherwise I'll just wait for the next LTS.~~ I found your answer to this in the memory leak issue, thanks again.","Just want to note that the fix from Node 21 made it into Node 20.10.0. My unit test runtime dropped by 50% with this fix.","> Just want to note that the fix from Node 21 made it into Node 20.10.0. My unit test runtime dropped by 50% with this fix.\r\n\r\nI also wanted to note that this node version has restored performance back to the v14 levels, the updated benchmarks for my project:\r\n\r\nnode: 14.21.3\r\ncold run: 116s\r\nhot run: 103s\r\n\r\nnode: 20.10.0\r\ncold run: 113s\r\nhot run: 103s","| 18.16.1 | 20.10.0 |\r\n|--------|--------|\r\n| 230s | 140s | \r\n\r\n\ud83c\udf89 "],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"[Feature]: Isolated coverage reports","body":"### \ud83d\ude80 Feature Proposal\n\nAn easy way to run Jest but generate coverage separately for each test file.\n\n### Motivation\n\nA common pattern is to have a test file for each source file. But coverage is generated for the whole repo so one test can \"accidentally\" cover lines in another file. This leads to a problem where when for tests that need to be written based on code coverage, it shows that a branch is tested, but it may have been executed as a result of a different test suite that doesn't actually assert on the branch in question.\n\n### Example\n\nTwo parts:\r\n\r\n* An option to generate multiple coverage reports for a single Jest run (eg: one coverage report per test file)\r\n* The ability to define `collectCoverageFrom` as a function which is passed the current test file as an argument so you can dynamically set which source files coverage can be collected from given the test that is running.\n\n### Pitch\n\nThere's not an easy or efficient way to do this without it being built-in.\r\n\r\nCurrently the best\/only way to do it is with a custom script that finds all test files, finds the associated source files for each test file (in our case that is based on the file name) and then run jest to test only a single test file and gather coverage from only the one source file. Then run Jest hundreds of times, one for each test file to generate coverage separately for each.\r\n\r\nI don't believe this is a change to the default reporter rather a different way of triggering the reporter. The way that the reporters work would stay the same, it'd just be executed anew for each test file.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale (Happy holidays)","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale (Happy new year)","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale"],"labels":[":rocket: Feature Request"]},{"title":"[Bug]: watch mode fails when git maintenance runs","body":"### Version\n\n29.4.0\n\n### Steps to reproduce\n\n1. Run your tests with `jest --watch` and wait until they finish.\r\n2. In another terminal, run `git maintenance run`.\r\n3. The watcher will fail\n\n### Expected behavior\n\nOutside process shouldn't kill the watcher.\n\n### Actual behavior\n\nWatcher dies immediately with\r\n\r\n```\r\nError: EPERM: operation not permitted, lstat 'C:\\Workspace\\my-project\\.git\\objects\\dc\\a-very-long-hash'\r\nEmitted 'error' event on NodeWatcher instance at:\r\n    at C:\\Workspace\\my-project\\node_modules\\jest-haste-map\\build\\watchers\\NodeWatcher.js:274:14\r\n    at FSReqCallback.oncomplete (node:fs:207:21) {\r\n  errno: -4048,\r\n  code: 'EPERM',\r\n  syscall: 'lstat',\r\n  path: 'C:\\\\Workspace\\\\my-project\\\\.git\\\\objects\\\\dc\\\\a-very-long-hash'\r\n}\r\n```\r\n\r\nI have also seen it point to `.git\\objects\\maintenance.lock`.\n\n### Additional context\n\n[This other issue](https:\/\/github.com\/expo\/expo-cli\/issues\/2021#issuecomment-1354537154) is where I found the suggestion that it was a background `git maintenance` command that was causing the conflict, and once I knew that it was easy to reproduce.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Windows 10 10.0.22621\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 18.12.1 - ~\\AppData\\Local\\fnm_multishells\\30672_1675721836564\\node.EXE\r\n    npm: 8.19.2 - ~\\AppData\\Local\\fnm_multishells\\30672_1675721836564\\npm.CMD\r\n  npmPackages:\r\n    jest: ^29.3.1 => 29.4.0\n```\n","comments":["Oh and in case it wasn't clear from the linked issue, this is a high priority since VSCode's built in Git integration just runs `maintenance` every couple of minutes in the background, making watch mode impossible to use while Code is open.","Does not reproduce on MacOS. Might be configuration issue or something Windows specific.\r\n\r\nStrangely it is mentioned in the docs that the watcher ignores `.git` folder. See the [watchPathIgnorePatterns](https:\/\/jestjs.io\/docs\/next\/configuration#watchpathignorepatterns-arraystring) option.","I wouldn't be surprised if this is Windows-specific, I assume the watcher used varies by filesystem type.  One thing that didn't come up in the Environment dump is that I'm running both commands (`jest` and `git`) from Git Bash; I don't know if it would fail under e.g. PowerShell or CMD.\r\n\r\nThe error I pasted in the report is all the stack-dump I get when this happens on the command line.  I made a new commit to the repository in question, and now I'm having trouble reproducing the error.  I did reproduce the error on a different project, using the same method.  I got the same limited stack info there, so I edited the `NodeWatcher.js` file referenced in the output to add a `console.error`, hoping to see a full stack dump, but now I can't reproduce the issue in the second project either.\r\n\r\nMaybe `git maintenance run` only makes the problematic filesystem interactions once, after a recent change\/commit?  I'm having some trouble nailing it down.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This bug keeps happening on Windows. It's quite intermittent. Maybe it's related to SmartGit running git maintenance in the background or something?","I've debugged the error starting point, and everything indicates that it activates within here:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-haste-map\/src\/watchers\/NodeWatcher.js#L281\r\n\r\nAnd because it is not handled properly, it forces the process to terminate when `maintenance.lock` allows `lstat()` to fail.","Hm.. But why the `.git` directory is being watched? Are you including it explicitly? Or this pattern does not work on Windows: \r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-haste-map\/src\/index.ts#L130-L132","@mrazauskas I don't know why. Seems that `.git` directory is not being ignored in fact.\r\n\r\nMy `jest.config.ts` is:\r\n\r\n```ts\r\nimport type { Config } from \"jest\";\r\n\r\nexport const jestConfig = (sourcePath = \"src\"): Config => ({\r\n  moduleNameMapper: {\r\n    \"^@\/(.*)$\": `<rootDir>\/${sourcePath}\/$1`,\r\n    \"^@Tests\/(.*)$\": \"<rootDir>\/tests\/$1\",\r\n  },\r\n  setupFiles: [\"dotenv\/config\"],\r\n  coverageThreshold: {\r\n    global: {\r\n      branches: 100,\r\n      functions: 100,\r\n      lines: 100,\r\n      statements: 100,\r\n    },\r\n  },\r\n});\r\n\r\nexport default jestConfig() as unknown;\r\n```\r\n\r\nBut I also have tried to ignore it by using `watchPathIgnorePatterns` but not works.\r\n\r\nI will try debug that, but I don't know exactly how for now.\r\n\r\nBy now, I have modified the file `NodeWatcher.js` and the problems is gone:\r\n\r\n```diff\r\n273:\r\n-     if (error && error.code !== 'ENOENT') {\r\n+     if (error && error.code !== 'ENOENT' && error.code !== 'EPERM') {\r\n\r\n301:\r\n-       if (error && error.code === 'ENOENT') {\r\n+       if (error && error.code !== 'ENOENT') {\r\n```","Right, I found a glue...\r\n\r\nThe file [`common.js`](https:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-haste-map\/src\/watchers\/common.js#L87-L90) uses `anymatch` to check if _ignore pattern_ match or no with directories.\r\n\r\nSo basically we have an ignore pattern like `\/\\\\\\.git\\\\|\\\\\\.hg\\\\|\\\\\\.sl\\\\\/` against a directory like eg. `D:\\\\project\\\\.git\\\\refs\\\\tags`, which at first glance seems to match. But `anymatch()` normalizes directories to use `\/` in place of `\\\\` instead of treating it literally\/as-is. So the ignore pattern will always fail on Windows.\r\n\r\n```js\r\nconst anymatch = require('anymatch')\r\n\r\n\/\/ Using \"\\\" on matcher (current behavior):\r\nconsole.log(anymatch(\/\\.git\\\\\/, 'D:\\\\project\\\\.git\\\\refs\\\\heads')); \/\/ Will fail!\r\n\/\/ >> false\r\n\r\n\/\/ Using \"\/\" on matcher:\r\nconsole.log(anymatch(\/\\.git\\\/\/, 'D:\\\\project\\\\.git\\\\refs\\\\heads')); \/\/ Will works!\r\n\/\/ >> true\r\n\r\n\/\/ What anymatch sent to matcher:\r\nanymatch(dir => console.log({dir}), 'D:\\\\project\\\\.git\\\\refs\\\\heads'); \/\/ The \"\\\" is converted to \"\/\"\r\n\/\/ >> D:\/project\/.git\/refs\/heads\r\n```\r\n\r\nSee: https:\/\/runkit.com\/rentalhost\/facebook.jest.issues.13869\r\n\r\nSo, I believe that the ignore pattern used in `common.js` should always use `\/` as separator, instead of respecting the used OS separator.\r\n\r\nIn this case, the problem starts exactly where you mentioned:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/e2196cab463c5a3e15668b1d7663058b09b7c0ed\/packages\/jest-haste-map\/src\/index.ts#L130-L132\r\n\r\nThe problem is whether it is safe to change `path.sep` to `\/` in any case.\r\n\r\nIn the local tests I've done, it seems to work fine. The tests continue to work perfectly and the problem no longer happens.","ref: https:\/\/github.com\/micromatch\/anymatch\/pull\/7","Good catch!\r\n\r\nI looked around. Seems like the `ignorePattern` is passed not only to `anymatch`. Perhaps the best fix would be to keep the pattern as is and to normalize it just before passing to `anymatch`? [`slash`](https:\/\/www.npmjs.com\/package\/slash) can be used (if it works in this case), because it is a dependency already.\r\n\r\nInteresting why this test is passing in CI on Windows (might be that `anymatch` is simply not involved because of mocking):\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-haste-map\/src\/__tests__\/index.test.js#L341-L347\r\n","By the way, your findings also explain why `watchPathIgnorePatterns` did not work for you on Windows. These are passed to Haste as `ignorePattern`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-runtime\/src\/index.ts#L337-L363\r\n\r\nAnd end up in the same logic as `VCS_DIRECTORIES` pattern:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-haste-map\/src\/index.ts#L276-L289\r\n","Exactly! I believe that the error is not being caught by the CI, as the CI does not run the `NodeWatcher` (which is where the problem starts). I tried to force use `NodeWatcher` in the tests but I didn't succeed (in theory, `useWatchman: false` should do that, but it ended up failing).\r\n\r\nAnyway, I'm using the `\/${vcs}\/` solution so far and everything is flowing perfectly.","It's good to fix the match bug so that the .git directory is correctly excluded, but would it also make sense to ignore EPERM errors as @rentalhost suggested? Or maybe add some kind of retry mechanism, rather than bombing completely out of the runner?","@thw0rted btw, at same file exists a function that handles just EPERM for win32:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/285b40d5954fd81e07b02db92185fd317ba92578\/packages\/jest-haste-map\/src\/watchers\/NodeWatcher.js#L367-L378\r\n\r\nPerhaps a solution would be to replace the error checking code part with this same function:\r\n\r\n```diff\r\n273:\r\n-     if (error && error.code !== 'ENOENT') {\r\n+     if (error && !isIgnorableFileError(error)) {\r\n\r\n301:\r\n-       if (error && error.code === 'ENOENT') {\r\n+       if (error && isIgnorableFileError(error)) {\r\n```","Only ignoring the error doesn't fix the issue that the `.git` directory is crawled and watched on Windows although it shouldn't be. Or I missed something?\n\nBy the way, crawling less files would also improve Jest's performance for all Windows users.\n\nI can't open a PR in this case, because I cannot verify anything without having Windows machine. ","I think that the two actions are need: ignore errors (in case error really happens) and fix VCS directories check.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Any news about that? :)","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 30 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","Reopen","I'm also running into this issue currently as well.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I get this issue often also, I think there is a bug in how jest-haste-map is handling file watcher events on Windows.  In my case  if it is watching a folder that also contains a Visual Studio project that is creating temporary .vs files then I get these errors quite often:\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/18707114\/fc0880f1-582d-40e1-9ac9-990db8c08d84)\r\n\r\nOther node.js packages have run into this and found a way to fix it, for example, see:\r\nhttps:\/\/github.com\/iden3\/snarkjs\/issues\/57","I think the issue linked to has a different cause than this one.\r\nhttps:\/\/github.com\/iden3\/snarkjs\/issues\/57#issuecomment-703231979"],"labels":[":bug: Bug","Help Wanted","Windows","Pinned"]},{"title":"[Bug]: Code for inline-snapshots incurs performance penalty even when the feature is not used","body":"### Version\r\n\r\n29.4.1\r\n\r\n### Steps to reproduce\r\n\r\n- Clone reproducer at https:\/\/github.com\/swcm-mnestler\/jest-inline-snapshots-reproducer and install modules with `npm ci`\r\n- Measure time to require original, unpatched version of `jest-snapshot` with `npm run unpatched`\r\n- Compare with patched version with `npm run patched`\r\n- The time difference should be roughly 100ms\r\n\r\n### Expected behavior\r\n\r\nI expect tests which do not use (inline-)snapshots not to have to wait ~100ms for `InlineSnapshots.js` to finish importing.\r\n\r\n### Actual behavior\r\n\r\nEvery run of  `jest` is slowed by ~100ms because `InlineSnapshots.js` is loaded eagerly in multiple locations. For example, the first time `jest-snapshot` (and therefore `InlineSnapshots.js`) is imported in my runs is [to fetch the `EXTENSION`](https:\/\/github.com\/facebook\/jest\/blob\/bc84c8a15649aaaefdd624dc83824518c17467ed\/packages\/jest-runtime\/src\/index.ts#L56) (`.snap`).\r\n\r\n\r\n### Additional context\r\n\r\nIf you have a single-project setup, this will not have a significant impact, but we use a monorepo with ~100 subprojects. When we start a clean test run, this means the ~100ms translates to 10s overhead for a feature we don't use. \r\n\r\nThe reason this file in particular takes so long to import is because of the various babel dependencies it pulls in. I had a look at some of the other typescript-transpiled files, and it seems that some of the `require` calls are wrapped in a lazy construct- e.g.:\r\n```\r\nfunction _crypto() {\r\n  const data = require('crypto');\r\n  _crypto = function () {\r\n    return data;\r\n  };\r\n  return data;\r\n}\r\n```\r\nMaybe this is the way to go here as well?\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 5.10 Ubuntu 22.04.1 LTS 22.04.1 LTS (Jammy Jellyfish)\r\n    CPU: (8) x64 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz\r\n  Binaries:\r\n    Node: 16.18.1 - (fnm)\/bin\/node\r\n    Yarn: 1.22.19 - (fnm)\/bin\/yarn\r\n    npm: 8.19.2 - (fnm)\/bin\/npm\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","`jest-runtime` should only be imported once per worker, so the hit of importing `jest-snapshot` shouldn't scale linearly with number of tests (unless you launch jest multiple times). But there might be other things we can do as well","> unless you launch jest multiple times\r\n\r\nYep, that's exactly what we're doing in our nx monorepo. I think this specific scenario wouldn't be too common to warrant any effort, but it also affects single-test runs during development.","Found out two aspects of this:\r\n- Usually, imports in Jest are rewritten to be evaluated lazily - except for packages in [`INLINE_REQUIRE_EXCLUDE_LIST`](https:\/\/github.com\/jestjs\/jest\/blob\/bc26cd79e60b7bf29d854293f0f011936fda1a5a\/scripts\/build.mjs#L42)\r\n- Even if lazy imports were enabled for `jest-snapshot`, this does not apply to the babel imports because they use `requireOutside`.\r\n\r\n  Maybe the `babel-plugin-jest-require-outside-vm` can be modified to support lazy imports? From a glance at the [original babel implementation](https:\/\/github.com\/babel\/babel\/blob\/main\/packages\/babel-helper-module-transforms\/src\/rewrite-live-references.ts#L131-L170), it seems to rewrite the entire file to replace any calls to imported values with the lazy-loading function call. \r\nA simpler possibility would be to manually perform lazy imports for the babel modules."],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"[Feature]: Add a way to mock a function only for certain arguments","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nThe idea here is basically equivalent to the `when` helper provided in some [third-party](https:\/\/github.com\/timkindberg\/jest-when) [packages](https:\/\/github.com\/marchaos\/jest-mock-extended#calledwith-extension), but within Jest. It would work similarly to `mockImplementation`, but only apply for certain arguments (possibly expect matchers).\r\n\r\nIf there's interest in this, ~once my company signs the CLA~ I may be able to contribute an implementation.\r\n\r\n### Motivation\r\n\r\nThis seems to be a quite common need, given the several third-party packages and in my own experience. (See also the pitch below.)\r\n\r\n### Example\r\n\r\nThere are a few possible APIs, but the most likely one is similar to jest-mock-extended and jest-when.\r\n```ts\r\n\/\/ API:\r\nexport interface MockInstance<T> {\r\n  mockWhen(...args: Parameters<T>): MockInstance<ReturnType<T>>\r\n}\r\n\r\n\/\/ example:\r\nconst mockFn = jest.fn() \/\/ or a function\/method from a class mocked by `jest.mock`, etc.\r\nmockFn.mockWhen(\"hello\", expect.anything()).mockReturnValue(3)\r\n```\r\nThe method `mockWhen` would return a jest mock which is used only when the arguments match, but can be customized in all the usual ways.\r\n\r\n### Pitch\r\n\r\nThis is a feature that many test frameworks and tools across many languages seem to grow, which points to its utility!\r\n\r\nThere are a few alternatives to doing this in Jest, which all seem inferior:\r\n1. Use one of the existing third-party packages. The problem with the third-party `when` implementations is that they don't use the normal Jest API; they instead provide their own which is a bit inconsistent, and there are several different packages people use which leads to fragmentation. Plus, implementing this within Jest could use the existing machinery and thus actually be a lot simpler, and could have the API be a method alongside `mockImplementation`.\r\n2. Mock the function for all return values, and then assert about the arguments with which it was called (either in the `mockImplementation` or via `.mock.calls`). This is a bit more work, and often results in more fragile tests, since if other code executed in the test makes an unrelated call to the function, it will fail the test. (And if we already have several such calls, this method no longer works.)\r\n3. Mock the function for all potential arguments (e.g. existing `mockReturnValue`), and not bother asserting anything further; this leads to weaker tests as well as not allowing different results for different arguments.\r\n4. Mock the function to have an implementation with conditionals (e.g. `if (arg === ...) return someValue; return otherValue`); this is a lot more work in most simple cases -- arguably it's so much work no one will bother.\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still relevant, I may even have time to make a PR soon","Agree, this would be super useful. In terms of possible API I suggest looking at [jest-mock-extended](https:\/\/github.com\/marchaos\/jest-mock-extended) it implements proper typesafe mocks with support for stubbing matched calls and the API is very straightforward and easy to follow.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still active! I have a PR up but need to rethink some details around `withImplementation`, as well as a few other comments. I'll hopefully have more time in the next few weeks.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still working on this! I haven't had time to get back to the issues above but hope to Soon\u2122.","I stumbled across this searching for something else, and... wow, I can't believe that jest mocking lacks this basic, essential feature.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still haven't had a chance to get back to this, still intend to though!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Bug]: Strings unexpectedly have no escaping in snapshots?","body":"### Version\n\n29.3.1\n\n### Steps to reproduce\n\n1. Clone this gist: https:\/\/gist.github.com\/lydell\/054071e15b38d9223f6bb026d6c6a73c\r\n2. Look at the inline snapshots in `index.test.js`.\r\n3. Optional: Run `npm it` to verify the snapshots.\n\n### Expected behavior\n\nI expected double quotes in strings to be escaped in snapshots.\n\n### Actual behavior\n\nDouble quotes are not escaped.\n\n### Additional context\n\nI updated from Jest 28 to 29 and was surprised seeing this in my snapshot after updating it:\r\n\r\n```\r\n      {\r\n        \"closed\": true,\r\n        \"type\": \"StringLiteral\",\r\n        \"value\": \"\"\"\",\r\n      },\r\n```\r\n\r\nhttps:\/\/github.com\/lydell\/js-tokens\/commit\/368dd65d3e126b2d8d9283ef4c141c0f027aa9c2#diff-fe86fc96fcb8e216d5f567cd722b97c78783f153bb86e01b82e02fad7d1354fdR32\r\n\r\nI was like \u2013 \u201c`\"\"\"\"`? What\u2019s up with that?\u201d And then \u201cOoooh! It\u2019s the empty string \u2026 as a string \u2026 in a snapshot string \ud83d\ude43 \u201d\r\n\r\nWanted to check if this is expected behavior or not?\r\n\r\nIt allows you to do fun things like this \u2013 how many properties does the object have?\r\n\r\n```js\r\ntest(\"Bobby\", () => {\r\n  const bob = {\r\n    name: `Bob Drop\",\\n  \"nick\": \"Bobby Tables`,\r\n    occupation: \"Student\",\r\n  };\r\n  expect(bob).toMatchInlineSnapshot(`\r\n{\r\n  \"name\": \"Bob Drop\",\r\n  \"nick\": \"Bobby Tables\",\r\n  \"occupation\": \"Student\",\r\n}\r\n`);\r\n});\r\n```\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.1\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 18.9.0 - ~\/.local\/share\/nvm\/v18.9.0\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 8.19.1 - ~\/.local\/share\/nvm\/v18.9.0\/bin\/npm\r\n  npmPackages:\r\n    jest: 29.3.1 => 29.3.1\n```\n","comments":["Yeah, this is the major breaking change of Jest 29: https:\/\/jestjs.io\/blog\/2022\/08\/25\/jest-29","Ergh, your example doesn't look too good, tho \ud83d\ude05 Anything we can do about that? I don't think we want to escape newlines in a string literal - I have a bunch of e.g. table or csv inline snapshots at work that should definitely render out the newlines and not escape them.\r\n\r\n\/cc @orta ","I think we probably want to look for newlines in the value and switch the outer character from a quote to an escaped backtick? That can keep the multi-line-ness and still describe the text - it also means the code can still be C&P'd in theory, though the backticks would get lost\r\n\r\nBut at least looking at the test, the string it is representing is the string `\"\"` so `\"\"\"\"` is a silly but reasonable answer because you wouldn't want it to be `\"\"` \ud83c\udf61 ","Btw, I really like the snapshot defaults in Jest 29, makes snapshots much easier to read in general.\r\n\r\nIf we can come up with some clever way to improve these edge cases that might be nice. Otherwise it might just be about getting used to it.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Hi @github-actions! See you again in a month or two!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Bug Report","Pinned"]},{"title":"[Bug]: Validation warnings for options like preset or coverage directory","body":"### Version\n\n29.3.0\n\n### Steps to reproduce\n\nUse a `jest.config.ts` like:\r\n\r\n```ts\r\nexport default {\r\n  preset: '.\/jest.preset.js',\r\n  coverageDirectory: '.\/coverage',\r\n};\r\n```\n\n### Expected behavior\n\nRun tests using `.\/node_modules\/.bin\/jest` without any warnings.\n\n### Actual behavior\n\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"preset\" with value \".\/jest.preset.js\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageDirectory\" with value \".\/coverage\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\n\n### Additional context\n\nMight be related to the missing default option for preset or coverage in `packages\/jest-config\/src\/ValidConfig.ts`.\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 13.0\r\n    CPU: (8) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 16.18.0 - ~\/.volta\/tools\/image\/node\/16.18.0\/bin\/node\r\n    Yarn: 1.22.19 - ~\/.volta\/tools\/image\/yarn\/1.22.19\/bin\/yarn\r\n    npm: 8.19.2 - ~\/.volta\/tools\/image\/node\/16.18.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.3.0 => 29.3.0\n```\n","comments":["Also seeing those warnings with several options:\r\n\r\n<details>\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testTimeout\" with value 5000 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"github-actions\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"packages\/ariakit\/src\/**\/*.{js,ts,tsx}\", \"packages\/ariakit-utils\/src\/**\/*.{js,ts,tsx}\", \"!**\/__examples__\/**\", \"!**\/*test.{js,ts,tsx}\", \"!**\/test-*.{js,ts}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\r\n\r\n<\/details>","Sorry about that! I'm fixing `preset` in #13583 as that's obviously a bug. However, e.g. `testTimeout` only works as global config, not as part of `projects`.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/dfc87111e708b9294dc54ab0c17712972d042c1c\/packages\/jest-circus\/src\/legacy-code-todo-rewrite\/jestAdapterInit.ts#L61-L63\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/dfc87111e708b9294dc54ab0c17712972d042c1c\/packages\/jest-jasmine2\/src\/index.ts#L43\r\n\r\nIt probably _should_ be project config, but it's not. same with `coverageDirectory` and `collectCoverageFrom` at least. Not sure about `reporters` - that is probably correct as global.\r\n\r\n---\r\n\r\nTBH global vs project config is confusing even to me after 5 years of contributing and maintaining Jest \ud83d\ude05 ","Preset fixed in https:\/\/github.com\/facebook\/jest\/releases\/tag\/v29.3.1.\r\n\r\nIt's midnight here now, so I'll need to revisit tomorrow and verify what's the correct behaviour for the other fields. Even if it makes sense that a certain option is a project config and not global, we need to look at what the _behaviour_ is first - that can only change in the next major. But if more fields are wrongly warned about, we should fix that.","```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageProvider\" with value \"v8\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"**\/*.{ts,tsx}\", \"!**\/*.d.ts\", \"!{index,routes}.ts\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\r\nI'm still getting some warnings like this post `jest-config` `29.3`. Forcing it to `<29.3` removes the validation messages.","I can confirm this works for `preset` option.","I'm getting same error on `>29.3`\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"<rootDir>\/components\/**\/*.vue\", \"<rootDir>\/pages\/**\/*.vue\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```","I'm seeing these on my end:\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageReporters\" with value [\"lcovonly\", \"html\", \"json-summary\", \"json\", \"text\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"watchPlugins\" with value [\"jest-watch-master\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"projects\" with value [\".\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```","I am also seeing this with slightly different options:\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"jest-junit\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"<rootDir>\/src\/**\/*.{ts,tsx}\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageDirectory\" with value \"<rootDir>\/coverage\/\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```","Also seeing similar to the above for supposedly valid options:\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"verbose\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", \"jest-teamcity-reporter\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"projects\" with value [\"<rootDir>\/src\/jest.*.config.js\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"name\" with value \"jsdom\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```","Same mistakes here with jest 29.3.1 and ts-jest 29.0.3:\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageDirectory\" with value \"..\/..\/coverage\/apps\/api\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageReporters\" with value [\"html\", [\"text-summary\"]] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\r\n\r\nProblems are solved downgrading to jest 28.1.3 and ts-jest 28.0.8.\r\n\r\nMy configuration is:\r\n\r\n```\r\nexport default {\r\n  displayName: 'api',\r\n  preset: '..\/..\/jest.preset.js',\r\n  testEnvironment: 'node',\r\n  maxWorkers: 2,\r\n  transform: {\r\n    '^.+\\\\.[tj]s$': [\r\n      'ts-jest',\r\n      {\r\n        tsconfig: '<rootDir>\/tsconfig.spec.json',\r\n        diagnostics: {\r\n          ignoreCodes: ['TS151001'],\r\n        },\r\n      },\r\n    ],\r\n  },\r\n  moduleFileExtensions: ['ts', 'js'],\r\n  coverageDirectory: '..\/..\/coverage\/apps\/api',\r\n  coverageReporters: ['html', ['text-summary', { skipFull: true }]],\r\n  clearMocks: true,\r\n};\r\n```","Having same issues. Would like to ask what's the state with it?","Seeing the same issue with: `coverageReporters`, `coverageProvider`, `verbose` and `watchPlugins`.","same issue with `projects` `collectCoverage` and `coverageDirectory`","I feel like it's something to do with this https:\/\/github.com\/facebook\/jest\/blob\/6e5b1d60a1214e792b5229993b5475445e9c1a6e\/packages\/jest-config\/src\/index.ts#L56 I'll have to stick a debugger on there when i get to a computer next.","@webark any luck debugging this issue?","I can confirm that this is an issue since `29.0.0` (not sure about the prereleases). Reverting back to the last version of v28 and the warning went away. ","getting the `coverageDirectory` and `maxConcurrency` warnings with `29.3.1`\r\n\r\nI do have this is a jest.config.js located inside of a project folder; and so according to @SimenB 's comment, that is incorrect.\r\n\r\nHowever though I am getting this warning, coverage _is_ being placed in the configured directory.","I'm also getting these warnings after upgarding to `29.3.1`","\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverage\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\"<rootDir>\/src\/**\/!(*.spec|*.jest).{js,jsx,vue,ts,tsx}\", \"!<rootDir>\/**\/*.d.ts\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\r\nSeeing the same issue even after upgrading jest to `29.3.1` and @types\/jest to `^29.2.4`\r\n@SimenB  Can you please Take a look at this issue :)","Hello. I do have the same issue with the `coverageDirectory` and `coverageReporters` options.\r\nI am using the `29.3.1` version.","If I understand this issue correctly:\r\n\r\n* The warnings indicate that per-project Jest configs (i.e., files referenced by a Jest config `projects` entry) are using configuration settings like `coverageDirectory`, `coverageReporters`, and `collectCoverageFrom` that can only apply at the global level.\r\n* This feature (warning about per-project settings that have no effect because they can only apply at the global level) was added in #13565.\r\n* The \"correct\" fix is to adjust your Jest configs - any project config file (i.e., anything that's referenced by another Jest config's `projects`) shouldn't have these settings.\r\n\r\nAm I understanding correctly?\r\n\r\nIn my opinion, it's sometimes useful to be able to use global settings in project configs - maybe you want to reuse a single configuration object for both, or maybe you want each package in a monorepo to have a `jest.config.ts` so that Jest can be run at the monorepo level or per project and share the same configs. ([NX](https:\/\/nx.dev\/packages\/jest), for example, defaults to putting global settings in per-project configs, for whatever reason.) Maybe Jest shouldn't warn on this, or should only warn if `--debug` or `--showConfig` is given, or should wait until Jest 30 and make a concrete recommendation about stricter separation of global and project settings then?","The only addition I would tack on to what you're saying is that: Despite the warning, the project setting does work correctly and actually does place coverage reports in the (per project) specified directory.","Getting same warnings with `jest@29.3.1`",">Am I understanding correctly?\r\n\r\nThat's correct.\r\n\r\n\r\n\r\n> The only addition I would tack on to what you're saying is that: Despite the warning, the project setting does work correctly and actually does place coverage reports in the (per project) specified directory.\r\n\r\nIf it still works, that means the error is wrong (like it was for preset before 29.3.1). Could you list out which actually works so we can make sure to not warn for those cases?","I cannot give an exhaustive list of things that are giving warnings (but are still working), but at the very least `coverageDirectory`:\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageDirectory\" with value \"..\/..\/coverage\/integrations\/xxxx-adapter\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\r\n\r\nIf that one is fixed \/ excluded from giving warnings I would be happy already. (Edit: `jest 29.3.1` btw)","There's been several comments listing out options that are throwing warning after the upgrade in the issue.","```\r\ncollectCoverageFrom\r\ncoverageDirectory\r\ncoverageProvider\r\ncoverageReporters\r\nmaxConcurrency\r\nname\r\nprojects\r\nreporters\r\ntestTimeout\r\nverbose\r\nwatchPlugins\r\n```\r\n\r\nthese were the ones I found in this issue.","Thanks for the list! `coverageReporters `, `maxConcurrency`, `reporters` (probably `verbose` as well as AFAIK it's only used in reporters) and `watchPlugins` at least are global config so the warning is correct for those. The others seem reasonable to me, will fix. But as mentioned in https:\/\/github.com\/facebook\/jest\/issues\/13576#issuecomment-1307946313 most really _are_ global config and have no effect when specified as project config.","See https:\/\/github.com\/facebook\/jest\/blob\/4fd1cb3926f93974a1f10d995ed73368784bc6b9\/packages\/jest-config\/src\/index.ts#L77-L201\r\n\r\nThe coverage stuff should probably move... We might need a major version to clean this up.\r\n\r\n---\r\n\r\nHowever, looking at OP, they get the error in a single config - that's a bug.","Would it make sense to document project vs global config and then adjust the warning? API documentation currently does not specify which configs are global, project or both.","> maybe you want each package in a monorepo to have a jest.config.ts so that Jest can be run at the monorepo level or per project and share the same configs.\r\n\r\nFWIW, this is the scenario that I have.\r\n\r\nIt _seems_ a bit annoying to split the package `jest.config.js` files into two, but perhaps that is the Right (TM) thing to do?","Hi there,\r\n\r\nI'm currently encountering a warning message in Jest that I'm having trouble resolving. The message reads:\r\n\r\n```\r\nValidation Warning:\r\n\r\nUnknown option \"coverageDirectory\" with value \"..\/..\/coverage\/apps\/epsite\" was found.\r\nThis is probably a typing mistake. Fixing it will remove this message.\r\n\r\nConfiguration Documentation:\r\nhttps:\/\/jestjs.io\/docs\/configuration\r\n```\r\n\r\nI have checked my Jest configuration file and confirmed that the \"coverageDirectory\" option is spelled correctly and is a valid Jest configuration option. I'm running the latest version of Jest, and I don't believe I'm using any third-party libraries or presets that could be causing this issue.\r\n\r\nI'm hoping someone in the community can help me figure out what's causing this warning message and how I can resolve it. Any advice or suggestions would be greatly appreciated.\r\n\r\nThank you!","I got the same issue on jest@29.4.3","Same issue with the latest (29.4.3); do you know if there is any fix for this to suppress this warning? Both these yield the same false warning:\r\n\r\n```\r\ncollectCoverage: true,\r\nverbose: true,\r\n```","What I don't understand here is why the `projects` config when listed in my top-level `jest.config.ts` is giving an error: \r\n\r\n```ts\r\nimport type { Config } from \"jest\";\r\n\r\n\/**\r\n * This Jest config tells Jest about our workspaces (Jest calls them\r\n * projects). Each workspace will have it's own Jest config which\r\n * extends the one in packages\/jest-presets.\r\n *\r\n *\/\r\nconst jestconfig: Config = {\r\n  projects: [\".\/apps\/*\", \".\/packages\/*\"]\r\n};\r\n\r\nexport default jestconfig;\r\n```","We managed to fix most of these warning by consolidating settings in jest.preset.js in the base of our monorepo. \r\n\r\nHowever, we want to specify the coverage directory for each project in that monorepo to be under the coverage directory of the root of the monorepo while maintaining separate reports for each project. This simplifies scanning and production of summary reports.\r\n\r\nThus, we need to specify a unique coverageDirectory in the jest.config.ts file of each project. This works fine, it is just annoying that we get a Validation Warning for each project.  Since this is the only want to get a consolidated directory containing all the coverage reports, this setting needs to be supported in each jest.config.ts without generating a validation warning.","Import new nodeSent from my iPhoneOn Feb 28, 2023, at 3:44 AM, Kristo Jorgenson ***@***.***> wrote:\ufeff\nWhat I don't understand here is why the projects config when listed in my top-level jest.config.ts is giving an error:\nimport type { Config } from \"jest\";\n\n\/**\n * This Jest config tells Jest about our workspaces (Jest calls them\n * projects). Each workspace will have it's own Jest config which\n * extends the one in packages\/jest-presets.\n *\n *\/\nconst jestconfig: Config = {\n  projects: [\".\/apps\/*\", \".\/packages\/*\"]\n};\n\nexport default jestconfig;\n\n\u2014Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you are subscribed to this thread.Message ID: ***@***.***>","> We managed to fix most of these warning by consolidating settings in jest.preset.js in the base of our monorepo.\r\n> \r\n> However, we want to specify the coverage directory for each project in that monorepo to be under the coverage directory of the root of the monorepo while maintaining separate reports for each project. This simplifies scanning and production of summary reports.\r\n\r\nSame for `reporters` actually. We have config for [jest-junit](https:\/\/www.npmjs.com\/package\/jest-junit) in there that also specifies a project-specific `outputDirectory`.\r\n\r\nAs you state, the functionality is obviously supported and works fine, the warning should be removed.","In Version 29.5.0, I get the warnings listed below under my nx repo. It'd be great if there were a configuration switch to turn off warnings that are unnecessary and for which the code performs the correct operation.\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageDirectory\" with value \"..\/..\/coverage\/apps\/wrap-state\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverage\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverageFrom\" with value [\".\/src\/lib\/**\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n```","I started using this patch for `coverageDirectory` so that our Nx monorepo would stop throwing warnings.\r\nIf using `coverageDirectory` at a project level is truly not intended can we get some sort of migration path?\r\n\r\n```\r\ndiff --git a\/build\/ValidConfig.js b\/build\/ValidConfig.js\r\nindex 889ea1e5e802fdf9e3d83a2213bdee91fbd724f7..08157a5cfefb5637c3b961d5ad6b1b7c05ed2a87 100644\r\n--- a\/build\/ValidConfig.js\r\n+++ b\/build\/ValidConfig.js\r\n@@ -226,6 +226,7 @@ const initialProjectOptions = {\r\n   cache: true,\r\n   cacheDirectory: '\/tmp\/user\/jest',\r\n   clearMocks: false,\r\n+  coverageDirectory: 'coverage',\r\n   coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\r\n   dependencyExtractor: '<rootDir>\/dependencyExtractor.js',\r\n   detectLeaks: false,\r\n```","Thanks for the hint, @wSedlacek , adapting your fix I added a few more lines to the initialProjectOptions (reporters, coverageDirectory and coverageReporters) and put the fixed file into a project folder. Just add more \"default\" options for whatever your test setup makes Jest shout out warnings. Then I installed copyFiles with:\r\n\r\n`npm install copyfiles --save-dev`\r\n\r\nfor OS independent copying of the fix and added a postinstall task:\r\n\r\n` \"postinstall\": \"copyfiles -f node_modules_jest_fix\/ValidConfig.js node_modules\/jest-config\/build\/\"`\r\n\r\nand the issue is settled for now. Will keep monitoring if they finally fixed the issue whenever I do nx migrate.","same here, version:    \"jest\": \"^29.5.0\",\r\n![image](https:\/\/user-images.githubusercontent.com\/780662\/233755382-8ee795c1-d34c-461a-a2f1-e89ebaad21be.png)\r\n","I'm experiencing the same issue with `coverageDirectory` and `reporters` in a mono repo managed by nx , while trying to use the jest-stare plugin. \r\n`.\/packages\/constants\/jest.config.ts`\r\n\r\n```.ts\r\nexport default {\r\n    coverageDirectory: '..\/..\/docs\/reports\/packages\/constants',\r\n    reporters: [\r\n        'default',\r\n        [\r\n            'jest-stare',\r\n            {\r\n                coverageLink: '.\/coverage.html',\r\n                resultDir: 'docs\/reports\/packages\/constants',\r\n                resultHtml: 'test-report.html',\r\n                reportTitle: 'Constants Report',\r\n                reportHeadline: 'Constants Report',\r\n                reportSummary: 'Tests report for the constants package'\r\n            }\r\n        ]\r\n    ],\r\n    displayName: 'constants'\r\n}\r\n```\r\n\r\nI threw in a `console.trace` just before the warning to get some context\r\n```javascript\r\nTrace: JEST-VALIDATE\r\n    at Object.get [as validate] (PATH_TO_MY_REPO\/node_modules\/@jest\/core\/node_modules\/jest-validate\/build\/index.js:39:13)\r\n    at normalize (PATH_TO_MY_REPO\/node_modules\/@jest\/core\/node_modules\/jest-config\/build\/normalize.js:553:55)\r\n    at readConfig (PATH_TO_MY_REPO\/node_modules\/@jest\/core\/node_modules\/jest-config\/build\/index.js:181:74)\r\n    at async Promise.all (index 0)\r\n    at async readConfigs (PATH_TO_MY_REPO\/node_modules\/@jest\/core\/node_modules\/jest-config\/build\/index.js:463:27)\r\n    at async runCLI (PATH_TO_MY_REPO\/node_modules\/@jest\/core\/build\/cli\/index.js:152:59)\r\n```\r\n\r\nFrom what I can tell, when I'm running `nx run test` to execute jest tests, it starts the jest cli and passes it the config options from my `PATH_TO_MY_REPO\/packages\/constants\/project.json` and `PATH_TO_MY_REPO\/packages\/constants\/jest.config.ts`. The jest cli then passes it through jest-config, where it defines an [example config to validate against](https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-config\/src\/ValidConfig.ts#L194), using [jest-validate](https:\/\/github.com\/jestjs\/jest\/tree\/main\/packages\/jest-validate). It chooses the example for a project, which is missing those config options. \r\n\r\n`jest-validate` has a README.md, and accepts a json object to configure it's behavior. \r\n`jest-config` does not appear to have a README.md, and does not seem to have an ability to pass on options to `jest-validate`.\r\n\r\n\r\nIn my opinion, [initialOptions](https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-config\/src\/ValidConfig.ts#L16) and [initialProjectOptions](https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-config\/src\/ValidConfig.ts#L194) should not differ. It adds unnecessary\/undocumented complexity when trying to determine [why a config option](https:\/\/jestjs.io\/docs\/configuration) isn't working.\r\n\r\nIt also hamstrings plugins from being able to use their own config if jest is going to say their options are invalid. \r\n","This may not be exactly the same error but I think it's related so posting here...\r\n\r\nI just\u00a0installed jest (with ts-jest) and following the instructions both from the jest docs and ts-jest docs and doing nothing fancy, I'm getting warnings.\r\n\r\nMy config:\r\n```typescript\r\nimport type { JestConfigWithTsJest } from 'ts-jest'\r\n\r\nconst config: JestConfigWithTsJest = {\r\n  preset: 'ts-jest',\r\n  verbose: true,\r\n};\r\n\r\nexport default config;\r\n```\r\n\r\nThe error:\r\n<img width=\"623\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/1158956\/235746111-aec8cea0-61bc-4bd3-9f11-b52b6694f2dd.png\">\r\n\r\n\r\nIt seems to me like a mismatch about expectations about the file export - meaning it's seeing an object named \"default\" when it's expecting the object at the root. Confirmed this by writing `export const preset = 'ts-jest';` - but this would break the typechecking and is not desirable...\r\n\r\nGetting everything playing nicely with modules and export syntax in all cases can be a real pain... so I'd suggest altering whatever is doing this check to just handle the case where it receives a root object named default and call it a day.\r\n\r\n\r\n\r\n","> However, we want to specify the coverage directory for each project in that monorepo to be under the coverage directory of the root of the monorepo while maintaining separate reports for each project. This simplifies scanning and production of summary reports.\r\n> \r\n> Thus, we need to specify a unique coverageDirectory in the jest.config.ts file of each project. \r\n\r\nThis is exactly our situation. \r\n\r\nAlso, when generating components using standard Nx commands, the `coverageDirectory` setting in each project is the _default behavior_. So even if we removed all the coverageDirectory settings in all the existing Nx projects, every new project would introduce the warning again.","> However, we want to specify the coverage directory for each project in that monorepo to be under the coverage directory of the root of the monorepo while maintaining separate reports for each project. This simplifies scanning and production of summary reports.\r\n\r\nAnother +1 to this, same setup here. So far `coverageDirectory` is the only configuration option causing this warning for us. Would like to see continued support for this property on a project level.","@SimenB  any updates on this?","jest@29.5.0, is there any solution?","![image](https:\/\/github.com\/jestjs\/jest\/assets\/54946311\/5329eb26-4383-4c0a-a01c-9f541fffed2b)\r\n\r\nsame issue here, any updates?","any updates on this? ","jest.preset.js...\r\n```\r\nconst nxPreset = require(\"@nx\/jest\/preset\").default;\r\n\r\nconst globalConf = {\r\n  collectCoverage: true,\r\n  coverageDirectory: `${process.env.NX_WORKSPACE_ROOT}\/coverage\/${process.env[\"NX_TASK_TARGET_PROJECT\"]}`,\r\n};\r\n\r\nmodule.exports = { ...nxPreset, ...globalConf };\r\n```","Still throwing errors, but the config itself works fine\r\n\r\n> \u25cf Validation Warning:\r\n  Unknown option \"collectCoverage\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\u25cf Validation Warning:\r\n  Unknown option \"coverageDirectory\" with value \"..\/..\/.cache\/coverage\/apps\/hooks\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\u25cf Validation Warning:\r\n  Unknown option \"collectCoverageFrom\" with value [\"src\/**\/*.{js,ts,jsx,tsx}\", \"!**\/index.(js|ts|jsx|tsx)\", \"!**\/types.(js|ts|jsx|tsx)\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\u25cf Validation Warning:\r\n  Unknown option \"coverageReporters\" with value [\"html\", \"json\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration","I had `Unknown option \"default\" with value ...` issue with my ESM (`\"type\": \"module\"`) project.\r\n\r\nThis issue occurs due to the way `jest` checks if imported object is ES module\r\n\r\n```ts\r\nif (obj.__esModule) return obj:\r\nelse return { default: obj }\r\n```\r\n\r\nTo fix t you have two options:\r\n- In case you're a user of TypeScript and able to enable `esModuleInterop` option - do it.\r\n- In case you're not able to do so, or you're not using TS - add exported constant as follows.\r\n  ```ts\r\n  export const __esModule = true;\r\n  export default cfg;\r\n  ```","Hi \r\nI am also seeing the similar issue while try to run :  **npx jest --coverage RelativePath**\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/72793185\/ae46f4f8-ff0a-4bf0-9005-896a288dca13)\r\n\r\nI have following versions installed:\r\n\r\n- \"@nrwl\/jest\": \"16.2.2\",\r\n-  \"jest\": \"^29.4.3\",\r\n-   \"jest-environment-jsdom\": \"28.1.3\",\r\n-   \"jest-preset-angular\": \"^13.1.1\",\r\n-   \"ts-jest\": \"29.1.0\",\r\n-   \"tslib\": \"^2.5.3\",\r\n\r\nCan someone please help me here?\r\n","Seems to be fixed in 29.6.1 \ud83c\udf89 ","Appears it might have been #14054","> Seems to be fixed in 29.6.1 \ud83c\udf89\r\n\r\nnope, still happening\r\n\r\n<img width=\"620\" alt=\"CleanShot 2023-07-17 at 12 56 11@2x\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/97026035\/d998821f-b891-45cb-ac12-8987297612ac\">\r\n","Okay, so SOME options appear to be fixed, the one I was using `coverageDirectory` is fixed.","Coverage configuration warnings were removed for me \ud83c\udf89. All of my remaining warnings are for watchPlugins  ","Still getting this warning for the `reporters` option even after upgrading to version `29.6.1`. Upgrading did fix it for `coverageDirectory` though.","That's correct, only a PR was made for 2 of the affected options ... See https:\/\/github.com\/jestjs\/jest\/pull\/14180","I upgraded to `jest@29.6.2` but I still see warnings for \"collectCoverage\" and \"coverageReporters\":\r\n\r\n```\r\n\u25cf Validation Warning:\r\n  Unknown option \"collectCoverage\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\u25cf Validation Warning:\r\n  Unknown option \"coverageReporters\" with value [\"text\", \"cobertura\", \"lcov\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\r\n","I get those warnings with `29.6.2`\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverage\" with value false was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"projects\" with value [\"<rootDir>\/src\"] was found.     \r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"silent\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"testSequencer\" with value \".\/jest.sequencer.js\" was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration```","My VS Code extension doesn't work for the same reason and I can't run tests through the UI of VS Code:\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/17424528\/6bdab149-84bb-437d-8892-fe9cd5e89371)\r\n","@kvart714 , that's rather a bug in the VS Code extension not being able to go around the warning.","Yes I understand it. This extension hasn't been supported for 2 years now. But unfortunately it is the best one for VS Code for me. The most popular extension has many other problems.\r\nAnyway these warnings are wrong and I just wrote one more related case","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I definitely don't think this should be closed without some kind of resolution or direction.","It is just right time to fix this. @SimenB is landing breaking changes and preparing Jest 30 release.","I wonder if we should take the opportunity to go all in on generating a json schema and just use ajv or something (like eslint does) to validate?\r\n\r\nRef https:\/\/github.com\/jestjs\/jest\/issues\/11963\r\n\r\nI haven't done anything more since landing the basics: https:\/\/github.com\/jestjs\/jest\/blob\/main\/packages\/jest-schemas\/src\/index.ts","Just to be clear - `reporters` is a valid field in global config _and_ project-specific configs, right? For that option (at least), the issue here is the spurious validation warnings, not that the functionality itself is (or should\/will be) unsupported?","I'm facing the same issue. Is there any documentation about what is valid in project vs global config? I see that `@jest\/types` exposes a `ProjectConfig` and `GlobalConfig` type but the `jest` package does not. Only `InitialOptions` from the `Config` namespace is exposed on the `jest` package. If i try and require the types from `jest` I get an error pushing me to use `jest` instead.\r\n\r\nTo further complicate this, the docs state\r\n\r\n> With the projects option enabled, Jest will copy the root-level configuration options to each individual child configuration during the test run, resolving its values in the child's context. This means that string tokens like <rootDir> will point to the child's root directory even if they are defined in the root-level configuration.\r\n\r\nBut in my testing I discovered:\r\n\r\n- **some properties are only to be used on the `GlobalConfig`**\r\n    - e.g. `reporters`, `testTimeout`, `coverageReporters`\r\n- **some properties are not copied to the project level config even if specified on the root config**\r\n    - e.g `moduleFileExtensions`, `modulePathIgnorePatterns`, `snapshotFormat`, `testPathIgnorePatterns`\r\n    \r\nI am discovering these by trial and error. It would be great to get some documentation about how root\/project configs are merged and address the typing issues.","> I had `Unknown option \"default\" with value ...` issue with my ESM (`\"type\": \"module\"`) project.\r\n> \r\n> This issue occurs due to the way `jest` checks if imported object is ES module\r\n> \r\n> ```ts\r\n> if (obj.__esModule) return obj:\r\n> else return { default: obj }\r\n> ```\r\n\r\nSo I have been looking at the same issue for the whole day now. I have a similar project that uses the exact same versions and configuration as the one that's failing that DOES work normally and it's really frustrating. For some reason, my jest.config.ts file is not interpreted as TypeScript then I guess. What could cause this?","Any workaround ?\r\nCheck documentation, apply example -> warning...","> > I had `Unknown option \"default\" with value ...` issue with my ESM (`\"type\": \"module\"`) project.\r\n> > This issue occurs due to the way `jest` checks if imported object is ES module\r\n> > ```ts\r\n> > if (obj.__esModule) return obj:\r\n> > else return { default: obj }\r\n> > ```\r\n> \r\n> So I have been looking at the same issue for the whole day now. I have a similar project that uses the exact same versions and configuration as the one that's failing that DOES work normally and it's really frustrating. For some reason, my jest.config.ts file is not interpreted as TypeScript then I guess. What could cause this?\r\n\r\nFinally found what the difference was between the project that was failing and the one that was succeeding. Apparently the failing project ran jest via ts-node instead of directly (because of a custom SDK we built on top of Nx, while testing the SDK itself). Maybe it helps someone :)","It works if you downgrade to 28.1.3...enjoy","I ran into this same issue today.  Very weird.  Using 28.1.3 does seem to address the problem, but, I'd really prefer to be using 29.x.x.  What's happening on this issue?","This validation warning happens for me when I utilize a base Jest config in a monorepo project and utilize that base config in sub-package config files;\r\n\r\n```\r\nroot\/\r\n-- packages\/\r\n---- package1\/\r\n------ jest.config.ts\r\n---- package2\/\r\n------ jest.config.ts\r\njest.config.base.ts\r\njest.config.ts\r\npackage.json\r\n```\r\n\r\nall jest.config.ts files are importing and extending the jest.config.base.ts file\r\n```TypeScript\r\nimport jestBaseConfig from \".\/jest.config.base\";\r\n\r\nconst jestConfig: JestConfigWithTsJest = {\r\n  ...jestBaseConfig,\r\n  moduleNameMapper: {\r\n    \"^(\\\\.{1,2}\/.*)\\\\.js$\": \"$1\",\r\n  },\r\n ...\r\n}\r\n```\r\n\r\nmany validation warnings\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"forceExit\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"silent\" with value false was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```\r\n\r\nbase config is\r\n```Typescript\r\nimport type { JestConfigWithTsJest } from \"ts-jest\";\r\n\r\nconst jestBaseConfig: JestConfigWithTsJest = {\r\n  preset: \"ts-jest\",\r\n  testEnvironment: \"node\",\r\n  detectOpenHandles: true,\r\n  forceExit: true,\r\n  silent: false,\r\n  verbose: true,\r\n  testPathIgnorePatterns: [\"node_modules\", \"dist\", \"env\"],\r\n  moduleDirectories: [\"node_modules\"],\r\n  extensionsToTreatAsEsm: [\".ts\"],\r\n  transform: {\r\n    \"^.+\\\\.tsx?$\": [\r\n      \"ts-jest\",\r\n      {\r\n        \/\/the content you'd placed at \"global\"\r\n        useESM: true,\r\n      },\r\n    ],\r\n  },\r\n};\r\n\r\nexport default jestBaseConfig;\r\n```","I am also using jest on a monorepo with turborepo and deployed in Vercel. With the `verbose: true` setting I get the same warning, but it seems to work. \r\nWell.. work but in a strange way. Because the logs are marked in red even if the test passes XD.\r\nI'm using the version 29.7.0 of Jest\r\nI understand that this problem may be related to this warning. Do you know more about the solution in Jest version 29?","I updated to \r\n    \"ts-jest\": \"~29.1.1\",\r\n    \"jest\": \"~29.7.0\"\r\nand this still occurs\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"coverageReporters\" with value [\"lcov\", \"text-summary\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverage\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"maxConcurrency\" with value 4 was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"passWithNoTests\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"reporters\" with value [\"default\", [\"C:\\\\workspace\\\\rfq-ui-migration\\\\rfq-ui-migration\\\\node_modules\\\\jest-html-reporter\\\\dist\\\\index.js\", {\"includeFailureMsg\": true\r\n, \"includeSuiteFailure\": true, \"outputPath\": \"reports\/tests.html\", \"pageTitle\": \"Test Report\", \"sort\": \"default\", \"theme\": \"defaultTheme\"}]] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n","Yeah, I have this same issue with `collectCoverage`, following.","Having this problem for `reporters` when using typescript its valid but the runner gives me the same issue.","I'm getting the same error but for `watchPlugins`","Same for collectCoverage while using\r\n- jest@29.7.0\r\n- ts-jest@29.1.2\r\n\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"collectCoverage\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration","Not sure if this has already been mentioned, but this [patch-package](https:\/\/www.npmjs.com\/package\/patch-package) patch works for us...\r\n\r\n`patches\/jest-validate+29.7.0.patch`:\r\n```\r\ndiff --git a\/node_modules\/jest-validate\/build\/warnings.js b\/node_modules\/jest-validate\/build\/warnings.js\r\nindex 1860d5a..aef7d81 100644\r\n--- a\/node_modules\/jest-validate\/build\/warnings.js\r\n+++ b\/node_modules\/jest-validate\/build\/warnings.js\r\n@@ -23,6 +23,13 @@ function _interopRequireDefault(obj) {\r\n  *\/\r\n \r\n const unknownOptionWarning = (config, exampleConfig, option, options, path) => {\r\n+  \/\/ HACK: do not warn about coverageReporters and reporters.\r\n+  \/\/ they are actually valid options, but are being reported as invalid.\r\n+  \/\/ https:\/\/github.com\/jestjs\/jest\/issues\/14701\r\n+  if (option === \"coverageReporters\" || option === \"reporters\") {\r\n+    return;\r\n+  }\r\n   const didYouMean = (0, _utils.createDidYouMeanMessage)(\r\n     option,\r\n     Object.keys(exampleConfig)\r\n```","Funny how our monorepo projects get `Unknown option \"verbose\" with value true` followed by a helpful link to documentation where the examples consistently use option \"verbose\" with value true :D\r\n\r\n```\r\n\u25cf Validation Warning:\r\n\r\n  Unknown option \"verbose\" with value true was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```","Some problem here. Also using NX `v18.1.1` and jest `v29.7.0`.\r\n\r\n```\r\nValidation Warning:\r\n\r\n  Unknown option \"coverageReporters\" with value [\"cobertura\", \"html\", \"text-summary\"] was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n\r\n\r\nValidation Warning:\r\n\r\n  Unknown option \"reporters\" with value XXXXXX was found.\r\n  This is probably a typing mistake. Fixing it will remove this message.\r\n\r\n  Configuration Documentation:\r\n  https:\/\/jestjs.io\/docs\/configuration\r\n```"],"labels":["Help Wanted",":boom: Regression","Pinned"]},{"title":"[Feature]: Allow code transformations to work without parsing source","body":"### \ud83d\ude80 Feature Proposal\n\nCurrently, the `process` and `processAsync` options for a code transformation receive both the source text and file name necessary to run the transform. This presumably requires Jest to load the entire file prior to running the transform.\r\n\r\nIdeally, the transformation module should be able to supply a method that does *not* receive the source text and can run with only the filename. If this method is provided and returns a truthy value, it should short-circuit any attempt to load the source text.\n\n### Motivation\n\nIt is fairly common to import non-JavaScript assets such as image directly into JavaScript files. When done in conjunction with a bundler like Webpack, these imports can be transformed into source paths that can be used in JS.\r\n\r\nSince Jest generally doesn't interact directly with a tool like Webpack, the recommendation is to write a custom transform that takes the asset and returns a JS file, like this example from the bottom of https:\/\/jestjs.io\/docs\/code-transformation:\r\n\r\n```js\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  process(sourceText, sourcePath, options) {\r\n    return {\r\n      code: `module.exports = ${JSON.stringify(path.basename(sourcePath))};`,\r\n    };\r\n  },\r\n};\r\n```\r\n\r\nThe problem is that certain assets (e.g. videos) can be quite large. Loading the entire contents of this large file as `sourceText` can eat up quite a bit of memory and is, in many cases, unnecessary to generate the transformed module.\r\n\r\nA related use case may also be a scenario where the import references a file that does not actually exist on the local file system or can't be easily loaded for whatever reason (e.g. maybe large assets aren't downloaded to the developer's machine when cloning the repo and are only available over the network).\n\n### Example\n\nThe above asset transform with the file name only option might look like this:\r\n\r\n```js\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  processWithoutSource(sourcePath, options) {\r\n    return {\r\n      code: `module.exports = ${JSON.stringify(path.basename(sourcePath))};`,\r\n    };\r\n  },\r\n};\r\n```\r\n\n\n### Pitch\n\nThe transformation API is already part of the Jest core platform. This would merely extend it to better handle use cases where we want to transform a filepath without parsing the file.","comments":["For anyone stumbling on this, one workaround we're trying that seems to be handling things well is writing a [custom resolver](https:\/\/jestjs.io\/docs\/configuration#resolver-string) that points requests for large assets to an empty stub file. The file still gets loaded and transformed, but since it's empty, we don't see the same perf hit.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still applicable","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still applicable.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Seems reasonable to me, but I'm not sure how easy such an optimization is to fit into the current way the transformer is called. With no promise of it landing, is this something you can put together a PoC for? No need to add any tests - happy to take a look if and when you've got something working before deciding if we wanna do this or not."],"labels":[":rocket: Feature Request","Pinned"]},{"title":"chore(expect): use matcher utils via context instead of direct imports","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nSort of related to #13362 - if we wanna cleanly pick up colors etc., and expect custom matchers to do so, we need to go through the same mechanisms.\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nPure refactor, so green CI\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Pinned"]},{"title":"Support for using native Node ESM loader","body":"## Summary\r\n\r\nAs previously discussed in #13143, this PR shows roughly what changes would be needed in order to support Node.js `--loader`. I'm opening this as a draft PR since I would need guidance on where the code should live, how the code should be activated by the user, and how to create tests for it.\r\n\r\nping @SimenB \r\n\r\nI would be very happy to receive any feedback, or to discuss how this could\/should work!\r\n\r\n## Test plan\r\n\r\nI've tested this by running `yarn build` and manually coping the changed files into another small test project \ud83d\ude48 \r\n\r\n**`package.json`**\r\n\r\n```json\r\n{\r\n  \"type\": \"module\",\r\n  \"dependencies\": {\r\n    \"@esbuild-kit\/esm-loader\": \"^2.5.0\",\r\n    \"jest\": \"^29.2.2\"\r\n  },\r\n  \"jest\": {\r\n    \"extensionsToTreatAsEsm\": [\r\n      \".ts\"\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n**`foobar.test.ts`**\r\n\r\n```ts\r\ntest('it works', (): void => {\r\n  expect(1).toBe(1)\r\n})\r\n```\r\n\r\n```\r\ncp ~\/coding\/jest\/packages\/jest-worker\/build\/workers\/ChildProcessWorker.js node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js\r\ncp ~\/coding\/jest\/packages\/jest-transform\/build\/NodeEsmLoaderTransformer.js node_modules\/@jest\/transform\/build\/NodeEsmLoaderTransformer.js\r\ncp ~\/coding\/jest\/packages\/jest-transform\/build\/index.js node_modules\/@jest\/transform\/build\/index.js\r\ncp ~\/coding\/jest\/packages\/jest-runner\/build\/runTest.js node_modules\/jest-runner\/build\/runTest.js\r\n```\r\n\r\n> `NODE_OPTIONS='--experimental-vm-modules --loader @esbuild-kit\/esm-loader' jest`\r\n\r\n<img width=\"875\" alt=\"Screenshot 2022-10-27 at 01 00 00\" src=\"https:\/\/user-images.githubusercontent.com\/189580\/198154467-ce317e20-abb2-471b-bbed-9bb4c4e1eca2.png\">\r\n\r\nI have currently only tested this with `@esbuild-kit\/esm-loader`, but the goal is that it should work with any `--loader`","comments":["Pushed a small fix that makes it work with [`ts-node\/esm`](https:\/\/www.npmjs.com\/package\/ts-node) as well \ud83c\udf89 \r\n\r\n<img width=\"885\" alt=\"Screenshot 2022-10-27 at 01 13 48\" src=\"https:\/\/user-images.githubusercontent.com\/189580\/198155970-d3e92d9f-f407-4b7a-9aa7-d2bb682659b6.png\">\r\n\r\n\r\n","Pushed another small fix that uses the built in loader to load the config file as well \ud83c\udf89 \r\n\r\nedit: didn't actually pushed it, but pushed now \ud83d\ude48 ","(rebased on https:\/\/github.com\/facebook\/jest\/pull\/13543)","(rebased on https:\/\/github.com\/facebook\/jest\/pull\/13543)","@SimenB @privatenumber @mariocandela \r\n\r\nIs there anything that can be done from my side to move forward with this? \u263a\ufe0f ","@SimenB @privatenumber @mariocandela\r\n\r\nWould love to move forward with this! Anything I can do from my side?","Nothing more from me, but I appreciate that you keep pushing.\r\n\r\nI think you'll want to ping @SimenB directly as he's the maintainer.","@LinusU Thanks for taking a crack at this.  Being able to use any loader will be helpful and a step in the right direction.\r\n\r\nOne thing I'm wondering is whether you ran through any scenarios using tsconfig path mapping?  With tsx supporting that out of the box, I think any solution here would likely need to also support that functionality.  I might be out of my element here, but from evaluating tsx's code base, it seems that the path mapping works via the `resolve` method on the loader.  With your proposed solution that effectively uses the loader as a transformer, I'm concerned that the loader might not be getting the actual correct filepath without calling the loader's `resolve` as well.\r\n\r\nI might be way off base here, and everything you've proposed might work fine there, but I thought it would be worth broaching the subject in case it wasn't considered.\r\n\r\nThe other thing that comes to mind here is the possibility that multiple loaders have been specified. If I'm following your solution correctly, only the first loader will be processed.  That would likely cover a huge percentage of any use case for loaders, but there could be scenarios where multiple loaders are necessary and it would not work.\r\n\r\nThanks again for your efforts to land this improvement!","> @LinusU Thanks for taking a crack at this. Being able to use any loader will be helpful and a step in the right direction.\r\n\r\nHappy to help! \ud83d\ude4f \r\n\r\n> One thing I'm wondering is whether you ran through any scenarios using tsconfig path mapping? With tsx supporting that out of the box, I think any solution here would likely need to also support that functionality. I might be out of my element here, but from evaluating tsx's code base, it seems that the path mapping works via the `resolve` method on the loader. With your proposed solution that effectively uses the loader as a transformer, I'm concerned that the loader might not be getting the actual correct filepath without calling the loader's `resolve` as well.\r\n\r\nI haven't personally used tsconfig path mapping, but you're probably right in that they wouldn't work. However, I'm not sure that they work when [using `tsx` as loader anyways](https:\/\/github.com\/esbuild-kit\/tsx#nodejs-loader). `tsx` is a standalone binary that adds a lot of features on top of node. My _guess_ is that path mapping only works with that standalone binary. Would you be able to test this? e.g. by chancing `tsx` to `node --loader tsx` and running your app.\r\n\r\nSo if my hunch is correct, I'm not sure that it's inside the scope to support this, since this is about supporting any `--loader` and not specifically `tsx`.\r\n\r\n> The other thing that comes to mind here is the possibility that multiple loaders have been specified. If I'm following your solution correctly, only the first loader will be processed. That would likely cover a huge percentage of any use case for loaders, but there could be scenarios where multiple loaders are necessary and it would not work.\r\n\r\nThis is not supported currently, but should probably be quite easy to add in. Would prefer to do it in a follow up PR though to limit the scope of this one.\r\n\r\n> Thanks again for your efforts to land this improvement!\r\n\r\n\u2764\ufe0f ","(rebased on latest master)","@SimenB I think that the only thing I need in order to take this out of the draft stage is some input on how this should be activated. The code currently checks if there is a `--loader` argument present in `NODE_OPTIONS`, which is very convenient for people that are already using loaders in their projects, and just want it to work\u2122.\r\n\r\nHowever, I'm thinking that this could be a breaking change if someone is currently passing in a loader and relying on it not being picked up.\r\n\r\nAnother option could be to add a `--loader` flag to the Jest cli. In fact, even if we also look in `NODE_OPTIONS` it could be nice to also be able to pass a loader via the cli, same as in Node.\r\n\r\nDo you have any input on this?","tsx uses https:\/\/github.com\/esbuild-kit\/esm-loader as the loader, which supports tsconfig paths:\r\nhttps:\/\/github.com\/esbuild-kit\/esm-loader\/blob\/baa3121edffee119ce8c5e506b6116027b7cf0ef\/src\/loaders.ts#L98","@privatenumber thanks for the link! It seems like one more improvement here would be to support [the `resolve` hook](https:\/\/nodejs.org\/api\/esm.html#resolvespecifier-context-nextresolve) as well!\r\n\r\nPersonally, I would prefer it if that would be done in a follow up to keep this PR as tight in scope as possible. But if this is deemed as required in order to support loaders than we can add it here.\r\n\r\nTo keep track, there is currently two \"extra\" features that would be nice:\r\n- Support for multiple loaders ([\"chaining\" as Node calls it](https:\/\/nodejs.org\/api\/esm.html#hooks))\r\n- Support for the [`resolve` hook](https:\/\/nodejs.org\/api\/esm.html#resolvespecifier-context-nextresolve)","It seems like the linting rules was recently updated, I had to make the following changes to make it happy, but I'm not sure that it is desirable. Maybe I misunderstood something?\r\n\r\n```diff\r\n     __: string,\r\n     ___: ReducedTransformOptions,\r\n   ): Promise<TransformResult> {\r\n-    throw new Error(\r\n-      '`transformSourceAsync` should not be called when using --loader',\r\n+    return Promise.reject(\r\n+      new Error(\r\n+        '`transformSourceAsync` should not be called when using --loader',\r\n+      ),\r\n     );\r\n   }\r\n```\r\n\r\n```diff\r\n       url,\r\n       {format: 'module', importAssertions: {}},\r\n       async () => {\r\n-        return {format: 'module', source: fileSource};\r\n+        return Promise.resolve({format: 'module', source: fileSource});\r\n       },\r\n     );\r\n```\r\n\r\nThese two are async functions, but they don't use `await` in them. The rule triggered was `@typescript-eslint\/require-await`.\r\n\r\n```diff\r\n       );\r\n     }\r\n \r\n-    return await requireOrImportModule(moduleName);\r\n+    return requireOrImportModule(moduleName);\r\n   }\r\n }\r\n```\r\n\r\nRemoving `await` here will remove the current function (`NodeEsmLoaderTransformer#requireAndTranspileModule`) from stack traces when the code in `requireOrImportModule` `throw`s an `Error`. This seems like it removes important information from the stack trace.\r\n\r\nMore info about this: https:\/\/github.com\/goldbergyoni\/nodebestpractices#-212-always-await-promises-before-returning-to-avoid-a-partial-stacktrace","@LinusU it's a nice concept, but I'm afraid it looks like a complicated hack to do simple thing: use custom transformer. In other words, you can create transformer.mjs in ~40 lines of code to use any ESM loader just by importing it. With some helper library it might look like this:\r\n```js\r\n\/\/ transformer.mjs referenced in jest config\r\nimport {wrapper} from 'jest-esm-loader-support';\r\nimport {resolve, load} from 'any modern ESM loader';\r\nexport default wrapper(resolve, load);\r\n```\r\n\r\nMoreover, because you can pass options to the transformer via https:\/\/jestjs.io\/docs\/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object, it doesn't need to write any code:\r\n```js\r\n{\r\n  transform: {\r\n    \"\\\\.ts$\": [require.resolve('jest-esm-loader-support-v2'), {loader: 'any modern ESM loader'}]\r\n  },\r\n}\r\n```\r\n\r\nSure, you can implement a hacky logic to load currently applied loader (which of them in case of more than 1 loader used?) too if 'loader' parameter is omitted :)","Hm.. Not sure if transformer would be enough. Config files are not passed through transformers, because it is not yet clear which transformers will be needed. ","> Hm.. Not sure if transformer would be enough. Config files are not passed through transformers, because it is not yet clear which transformers will be needed.\r\n\r\nWe have 3 type of entities here:\r\n1. Jest config file. Works fine with .js \/ .cjs \/ .mjs extensions, and use  ts-node for .ts. Which is obviously works only in CJS mode. Solution is easy - detect current mode first (package.json \"type\" field will help) and just import file without node-js tricks for ESM mode. User runtime should handle any extensions (even 'jest -c jest.config.aurebesh' will work) specified by user.\r\n2. Various files used to extend Jest (custom transformers, setup \/ teardown, etc.). Currently handled with a bit incorrect requireOrImportModule (as I mentioned in https:\/\/github.com\/facebook\/jest\/issues\/14013), but we can assume this is more or lees ok. \r\n3. Source files. Can be handled with custom transformer on 40 lines which simple uses any ESM loader. One-liner if some helper library used (may be integrated into Jest directly via exported function or indirectly - as special config flag \/ key \/ syntax).\r\n\r\nAnyway, we just can't grab loader module specifier from argv, import  & use it - because loader chaining already landed in Node. It will work only for simple scenarios with 1 loader. For more complex - not, especially if we don't want to re-implement [lib\/internal\/modules\/esm\/hooks.js](https:\/\/github.com\/nodejs\/node\/blob\/main\/lib\/internal\/modules\/esm\/hooks.js) logic.","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Stale"]},{"title":"Pass jest-diff options to fix a11 y issues#12576","body":"\r\n## Summary\r\n\r\nThis PR is a first step to solve #12576. The proposed solution was to let the user pass a `DiffOptions` to the configs, allowing them to set their own color choices. However, accessing the config where the default colors are used would require deep refactoring. \r\n\r\nAs a first approach, with this PR we let the user pass a `MatcherHintOptions` and `DiffOptions` in the expect state with expect.setState, and we make sure the default colors are used only if the user didn't overwrite them.\r\n\r\nThere are some methods where the default colors are still being used because passing a `MatcherHintOptions` or `DiffOptions` to them would require deep refactoring.\r\n\r\nThe affected files are:\r\n- packages\/jest-each\/src\/validation.ts\r\n- packages\/jest-snapshot\/*\r\n- packages\/expect\/src\/spyMatchers.ts\r\n\r\n## Test plan\r\n\r\nThese changes are not affecting the current behavior of the code or breaking any test, so no new tests have been added.\r\n","comments":["Hi @grazirs! \n\nThank you for your pull request and welcome to our community. \n\n# Action Required\n\nIn order to merge **any pull request** (code, docs, etc.), we **require** contributors to sign our **Contributor License Agreement**, and we don't seem to have one on file for you.\n\n# Process\n\nIn order for us to review and merge your suggested changes, please sign at <https:\/\/code.facebook.com\/cla>. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need to sign the corporate CLA.\n\nOnce the CLA is signed, our tooling will perform checks and validations. Afterwards, the **pull request will be tagged** with `CLA signed`. The tagging process may take up to 1 hour after signing. Please give it that time before contacting us about it.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fjest%20%2313362). Thanks!","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Meta Open Source project. Thanks!","This is a great start, thanks for working on it! I have no comments beyond the ones left by @mrazauskas \ud83d\udc4d \r\n\r\nAnd yeah, tests that assert options passed through are respected seems reasonable. This PR brings down overall code coverage - while admittedly  it's not super high currently, this PR should quite easily be able to keep the status quo \ud83d\ude42 ","Hi @SimenB and @mrazauskas, thanks for your suggestions. \r\nI started working on the tests for matcher-utils, and I'd like to have your feedback on the approach I want to have.\r\nBasically for each test already existing in matcher-utils, after all the assertions, I additionally assert that every function I changed in this PR is called with the color options passed by the user.  \r\n\r\nHere's an example of how it would look like for a test of the `toBe` matcher in `packages\/expect\/src\/__tests__\/matchers.test.js`:\r\n\r\n```\r\nconst matcherUtils = require('jest-matcher-utils');\r\nconst chalk = require('chalk');\r\nconst {stringify} = require('jest-matcher-utils');\r\nconst {expect: jestExpect} = require('..\/');\r\n\r\nconst matcherHintOptions = {\r\n  expectedColor: chalk.yellow,\r\n  noDim: true,\r\n  receivedColor: chalk.magenta,\r\n  secondArgumentColor: chalk.yellow,\r\n};\r\nconst diffOptions = {\r\n  aColor: chalk.bgHex('#0000FF'),\r\n  bColor: chalk.magenta,\r\n  noDim: true,\r\n};\r\n\r\nexpect.setState({diffOptions, matcherHintOptions});\r\n\r\nconst registerSpies = () => {\r\n  return {\r\n    matcherHint: jest.spyOn(matcherUtils, 'matcherHint'),\r\n    printDiffOrStringify: jest.spyOn(matcherUtils, 'printDiffOrStringify'),\r\n    printExpected: jest.spyOn(matcherUtils, 'printExpected'),\r\n    printReceived: jest.spyOn(matcherUtils, 'printReceived'),\r\n  };\r\n};\r\n\r\nconst expectUserColorsAreUsed = (\r\n  matcherHint,\r\n  printExpected,\r\n  printReceived,\r\n  printDiffOrStringify,\r\n) => {\r\n  matcherHint.mock.calls.forEach(call => {\r\n    const passedOptions = call[3];\r\n    Object.keys(matcherHintOptions).forEach(key => {\r\n      expect(matcherHintOptions[key]).toEqual(passedOptions[key]);\r\n    });\r\n  });\r\n\r\n  printExpected.mock.calls.forEach(call =>\r\n    expect(call[1]).toEqual(diffOptions.aColor),\r\n  );\r\n\r\n  printReceived.mock.calls.forEach(call =>\r\n    expect(call[1]).toEqual(diffOptions.bColor),\r\n  );\r\n\r\n  printDiffOrStringify.mock.calls.forEach(call =>\r\n    expect(call[5]).toEqual(diffOptions),\r\n  );\r\n};\r\n\r\n[\r\n  [1, 2],\r\n   ...\r\n  [-0, +0],\r\n].forEach(([a, b]) => {\r\n  it(`fails for: ${stringify(a)} and ${stringify(b)}`, () => {\r\n    const {matcherHint, printExpected, printReceived, printDiffOrStringify} =\r\n      registerSpies();\r\n\r\n    expect(() => jestExpect(a).toBe(b)).toThrowErrorMatchingSnapshot();\r\n\r\n    expectUserColorsAreUsed(\r\n      matcherHint,\r\n      printExpected,\r\n      printReceived,\r\n      printDiffOrStringify,\r\n    );\r\n  });\r\n});\r\n```\r\nI would do the same in all the matchers and test where styled strings are printed.\r\n\r\nTo ensure that there are no hardcoded colors used somewhere, I'm not passing the default colors in the matcher's state. This will make the snapshots update, as the output of the tests will have a different style.\r\n\r\nAs I wrote in the PR description, there are some matchers that cannot be updated in this PR, therefore their tests will not be updated.\r\n",">I would do the same in all the matchers and test where styled strings are printed.\r\n>\r\n>To ensure that there are no hardcoded colors used somewhere, I'm not passing the default colors in the matcher's state. This will make the snapshots update, as the output of the tests will have a different style.\r\n\r\nThat seems reasonable to me!","Hi @SimenB @mrazauskas! Are there any updates on this?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This PR was closed because it has been stalled for 30 days with no activity. Please open a new PR if the issue is still relevant, linking to this one.","<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: grazirs \/ name: Graziele Ribeiro Santos  (84f32f6a6f49e657003b04abec7e879333f84c62, 3383cf406edae442e1e7c8d9cb774ae4509356df, ac1c239852a43533345cfc578e8ab192a7a42e39, 2c184e6daae9c048651a6d63befbc23829b399ac, 0d4e9678a3ab2bd6f1eb7a100aebf38bcb8cd6ec, 5dc8dd2f07de9b7d15dad04cb1dd972fdac7ec75, d9d9ca6da3a0915a108c5c0fdd9eef463a46e1ed, c36b9524632c90461dfffbdfcb33abdfe62c7813, eaccdf52d56aeadedcccb2071e93971f4d7256b5, cfbf23b957c106c4b0830c28c3b1f224847ebdb8, 18cc8f6a60e52a9f638b77830049384108f78ba8, 396929f6e5d16f918cc34a36c135a1ce8cb0ddf2, 7af2685236e303413a4e52be5c4e32dee666662e, c16d49f748f6e3c096ae0da389401b7062b1a686, 83e9a4825e132bef9c860aa791e760b3bf79a7b1, 9c9c11f3b7d93d930fa13efdd2423767a6c1004a, 5fb4f436b37151077ddf84cc2453a83881690586, 13a140c5652c46b28683e2366b4a722101a1564e, 5d97465ff1dce3e2c9e031e309c7f212d8a91c2f, 25be7fc6b5b12d5f331fcd50d3e6467f0abac410, 094f16b41fe139a2c8dba9b43f5f369142450786)<\/li><li>:white_check_mark: login: SimenB \/ name: Simen Bekkhus  (bb3abfb95a297de718648644af93e5bfbfab4bcf)<\/li><\/ul>","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 094f16b41fe139a2c8dba9b43f5f369142450786 |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/64fc4b40218de70008761463 |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-13362--jestjs.netlify.app](https:\/\/deploy-preview-13362--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTEzMzYyLS1qZXN0anMubmV0bGlmeS5hcHAifQ.lVhPdahgNvMhd28Pv6gNkTusZuxbzqi1b1gAYNwXsfw)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","Hi @SimenB and @mrazauskas . I synced my branch with main and resolved the conflicts. All the tests are passing on my machine (node 16.20.0  on macOS) but the snapshot are failing on the CI. Any idea on what it might be? "],"labels":["cla signed","Pinned"]},{"title":"[Bug]: jest-config can't import TS file with moduleResolution: node16 ","body":"### Version\n\n29.1.2\n\n### Steps to reproduce\n\n1. `git clone https:\/\/github.com\/Maxim-Mazurok\/jest-config-bug-repro`\r\n1. `cd jest-config-bug-repro`\r\n1. (optional) `nvm i`\r\n1. `npm ci`\r\n1. `tsc --noEmit` - works\r\n1. `npm run test:unit` - works\r\n1. `npm run test:integration` - doesn't work\n\n### Expected behavior\n\nParse config just fine and exit with `No tests found, exiting with code 0`\n\n### Actual behavior\n\ngives error:\r\n```\r\nError: Jest: Failed to parse the TypeScript config file \/home\/maxim\/jest-config-bug-repro\/jest.integration.config.ts\r\n  Error: Cannot find module '.\/jest.config.js'\r\nRequire stack:\r\n- \/home\/maxim\/jest-config-bug-repro\/jest.integration.config.ts\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-config\/build\/readConfigFileAndSetRootDir.js\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-config\/build\/index.js\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-cli\/build\/init\/index.js\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-cli\/build\/cli\/index.js\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-cli\/build\/index.js\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-cli\/bin\/jest.js\r\n- \/home\/maxim\/jest-config-bug-repro\/node_modules\/jest\/bin\/jest.js\r\n    at readConfigFileAndSetRootDir (\/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-config\/build\/readConfigFileAndSetRootDir.js:136:13)\r\n    at async readConfig (\/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-config\/build\/index.js:208:18)\r\n    at async readConfigs (\/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-config\/build\/index.js:404:26)\r\n    at async runCLI (\/home\/maxim\/jest-config-bug-repro\/node_modules\/@jest\/core\/build\/cli\/index.js:182:59)\r\n    at async Object.run (\/home\/maxim\/jest-config-bug-repro\/node_modules\/jest-cli\/build\/cli\/index.js:155:37)\r\n```\n\n### Additional context\n\nHad to make the switch in https:\/\/github.com\/Maxim-Mazurok\/google-api-typings-generator because https:\/\/github.com\/sindresorhus\/got\/issues\/2051#issuecomment-1259401339\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.10 Ubuntu 22.04.1 LTS 22.04.1 LTS (Jammy Jellyfish)\r\n    CPU: (20) x64 12th Gen Intel(R) Core(TM) i9-12900H\r\n  Binaries:\r\n    Node: 18.10.0 - ~\/.nvm\/versions\/node\/v18.10.0\/bin\/node\r\n    npm: 8.19.2 - ~\/.nvm\/versions\/node\/v18.10.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^29.1.2 => 29.1.2\n```\n","comments":["@Maxim-Mazurok Your script in package.json is incorrect\r\n\r\nCurrent \r\n```json\r\n \"test:integration\": \"npm run jest -- --config jest.integration.config.ts\",\r\n```\r\n\r\nShould be\r\n```json\r\n\"test:integration\": \"npm run jest --config jest.integration.config.ts\",\r\n```","> @Maxim-Mazurok Your script in package.json is incorrect\r\n> \r\n> Current\r\n> \r\n> ```json\r\n>  \"test:integration\": \"npm run jest -- --config jest.integration.config.ts\",\r\n> ```\r\n> \r\n> Should be\r\n> \r\n> ```json\r\n> \"test:integration\": \"npm run jest --config jest.integration.config.ts\",\r\n> ```\r\n\r\nNo, using `--` allows to pass cli arguments to npm script as per [this answer](https:\/\/stackoverflow.com\/a\/14404223\/4536543), I've been using it for years in many projects.\r\n\r\nYou can even see this from log:\r\n```\r\n> npm run jest -- --config jest.integration.config.ts\r\n\r\n\r\n> jest\r\n> node --experimental-vm-modules node_modules\/jest\/bin\/jest.js --passWithNoTests \"--config\" \"jest.integration.config.ts\"\r\n\r\nError: Jest: Failed to parse the TypeScript config file \/home\/maxim\/jest-config-bug-repro\/jest.integration.config.ts\r\n```\r\n\r\nNotice how it has `jest.js --passWithNoTests \"--config\" \"jest.integration.config.ts\"` part where config argument is getting passed.\r\n\r\nAnd without `--` it's not being passed:\r\n\r\n```\r\n> npm run jest --config jest.integration.config.ts\r\n\r\n\r\n> jest\r\n> node --experimental-vm-modules node_modules\/jest\/bin\/jest.js --passWithNoTests \"jest.integration.config.ts\"\r\n```\r\n\r\nYou see `jest.js --passWithNoTests \"jest.integration.config.ts\"` - the `--config` disappeared.\r\n\r\nThis is an unrelated matter, perhaps you just didn't notice that I'm not doing `jest --config bla` but `npm run jest --config bla` because I have added the `jest` script. In any case, let's not focus on this as this is not the issue at hand. \r\n\r\nOne can get the same reproduction by changing `jest.config.ts` to be:\r\n```ts\r\nimport { JestConfigWithTsJest } from \"ts-jest\";\r\nimport integrationConfig from \".\/jest.integration.config.js\";\r\n\r\nconst config: JestConfigWithTsJest = { ...integrationConfig };\r\n\r\nexport default config;\r\n```\r\n\r\nAnd then run `npm run jest` with no arguments and get the same error:\r\n\r\n```\r\nError: Jest: Failed to parse the TypeScript config file \/home\/maxim\/jest-config-bug-repro\/jest.config.ts\r\n  Error: Cannot find module '.\/jest.integration.config.js'\r\n```\r\n\r\nHope that clears it up, cheers!","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Occurring an activity ","Same problem for me. tsc and esbuild work fine, jest can't resolve the import. ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","*unstaling*","same problem here. Any workarounds?","Maybe try switching to vitest, same API, even same plugins usually work, but TS and ESM stuff generally works much better with it.","Excellent tip. I was using vite but didn\u2019t know about vitest! Now \u201cfixed\u201d.   And resolve works like a charm. Problem fixed as well. \ud83d\ude1c","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","No worries! Also, unstaling the issue","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I've migrated to vitest and also using module resolution \"bundle\" so this issue is no longer relevant to me.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","As I mention it's no relevant to me, so I'll unstale it and unsubscribe, perhaps someone else can take it over, cheers","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","unstale","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","unstale","still the same","I looked at this issue again and found that this was not the case I was having.\r\n\r\nFor this issue, I think you probably need to compile TS jest config (`jest.config.ts` and `jest.integration.config.ts`) to JS jest config (`jest.config.js` and `jest.integration.config.js`) and then pass the js file to `--config` in the command.\r\n\r\nI don't think jest does any transformations on the config files.","Why is this being ignored?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is still an issue. @SimenB Is there a label that can be added so this doesn't get marked as stale? (it's adding unnecessary \"bump\" comments that's making it hard to follow along for updates)\r\n\r\nIt looks like `compilerOptions.module` is hardcoded here: https:\/\/github.com\/jestjs\/jest\/blob\/f9398b12dfc235695e9a055d27a8f77936d07b01\/packages\/jest-config\/src\/readConfigFileAndSetRootDir.ts#L118\r\n\r\na quick fix would be to update jest-config to _also_ set moduleResolution. Alternatively, respecting any existing tsconfig for the project would be nice.\r\n\r\n---\r\n\r\nAs a workaround, you can create a second tsconfig file for test, e.g. `tsconfig.test.json`:\r\n\r\n```json\r\n{\r\n    \"extends\": \".\/tsconfig.json\",\r\n    \"compilerOptions\": {\r\n        \"moduleResolution\": \"Node10\",\r\n        \"module\": \"CommonJS\",\r\n    }\r\n}\r\n```\r\n\r\nand then when running jest (I'm using yarn):\r\n\r\n```\r\n TS_NODE_PROJECT=.\/tsconfig.test.json yarn jest --config jest.config.ts\r\n```","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant.","Still relevant.","Just ran into this, wondering how jest is used with modern typescript projects using moduleResolution node16? \r\n\r\nOverriding module resolution for tests would mean you get errors from the base tsconfig.json in your editor, or when validating types using for example `tsc --noEmit`.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant","For ESM support in Node.js to work without using extra bundlers or compilers module resolution has to be node16. Otherwise the output generated by `tsc --build` isn't compatible with Node, importing files without extensions just doesn't work without a non standard loader.\r\n\r\nIf we for example want [https:\/\/swc.rs\/](swc) to generate ESM code we have to use node16 resolution, which basically means swc + jest won't work.","Still an issue, and testing with @noahnu 's solution did not work for me..","I managed to get a consistent fix\r\n\r\nchange in your package.json `\"jest\": \"npm:vitest@latest\"`"],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"fix: stop printing the same error for each individual test caused by beforeAll when it fails","body":"# Summary\r\nCloses #9901\r\n\r\nThis is a continuation of @vldmrkl PR at #10004.\r\n\r\nThe call of addErrorToEachTestUnderDescribe is causing this bug:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/264a116fd7e2bed4d3511fc85cf53226e7d9748a\/packages\/jest-circus\/src\/eventHandler.ts#L172-L174\r\n\r\nThis function adds an error to each of the tests under describe in which the failed beforeAll is. My currently proposed solution is changing this function operation to fail only one test and skip the rest, so that the error message should be printed once and all tests remain unrun.\r\n\r\nThese changes haven't broken any existing test in the project, and it looks like it is much less confusing comparing to the previous version, though I would like to get confirmation that this is the expected behaviour.\r\n\r\n## Test plan\r\nLet's reuse the example from the issue description and see a new behavior that this bug fix provides.\r\n\r\nExample:\r\n\r\n```typescript\r\ndescribe('test that a 3rd party API remains consistent', () => {\r\n  beforeAll(() => expect('login').toBe('successful')); \/\/ this will fail\r\n  test('API function 1', () => expect(1).toBe(1)); \/\/ each...\r\n  test('API function 2', () => expect(2).toBe(2)); \/\/ ...of these...\r\n  test('API function 3', () => expect(3).toBe(3)); \/\/ ...will be reported as failed too\r\n});\r\n```\r\nNew behavior:\r\n```typescript\r\n FAIL  .\/issue-9901.spec.ts\r\n  test that a 3rd party API remains consistent\r\n    \u00d7 API function 1\r\n    \u25cb skipped API function 2\r\n    \u25cb skipped API function 3\r\n\r\n  \u25cf test that a 3rd party API remains consistent \u203a API function 1\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: \"successful\"\r\n    Received: \"login\"\r\n\r\n      1 | describe('test that a 3rd party API remains consistent', () => {\r\n    > 2 |   beforeAll(() => expect('login').toBe('successful')); \/\/ this will fail\r\n        |                                   ^\r\n      3 |   test('API function 1', () => expect(1).toBe(1)); \/\/ each...\r\n      4 |   test('API function 2', () => expect(2).toBe(2)); \/\/ ...of these...\r\n      5 |   test('API function 3', () => expect(3).toBe(3)); \/\/ ...will be reported as failed too\r\n\r\n      at Object.toBe (issue-9901.spec.ts:2:35)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 2 skipped, 3 total\r\nSnapshots:   0 total\r\nTime:        1.392 s\r\nRan all test suites.\r\n```\r\n\r\nThis test is also added as an unit test on this PR.","comments":["Exciting! I agree on skipping when a hook fails \r\n\r\n>1 failed, 2 skipped, 3 total\r\n\r\nSeems wrong - all 3 were skipped","@SimenB In a matter of fact, it was my initial goal to set skip mode for all tests. But as it turns out, when all tests in a test suite are skipped, no error is printed, even though state has unhandled errors (like in afterAll hook).\r\n\r\n```\r\nTest Suites: 1 skipped, 0 of 1 total\r\nTests:       3 skipped, 3 total\r\nSnapshots:   0 total\r\nTime:        0.731 s, estimated 1 s\r\nRan all test suites.\r\n````\r\n\r\nSo if we want to modify this behavior we'll have to edit source code that calls `jest-circus`. Per my understanding it's `jest-reportes`.\r\n\r\nShould we pursue this solution? Or ignoring state errors when all tests fail is the desired behavior?",">when all tests in a test suite are skipped, no error is printed, even though state has unhandled errors\r\n\r\nThat sounds like a bug - although fixing it might be a semver major change. We have a concept of `testExecError` (e.g. syntax errors) - while it doesn't apply here there _is_ a mechanism for non-test errors","We can still land this in the meantime of course - it's strictly an improvement even if not \"perfect\"","> That sounds like a bug - although fixing it might be a semver major change. We have a concept of `testExecError` (e.g. syntax errors) - while it doesn't apply here there _is_ a mechanism for non-test errors\r\n\r\nWell yes, that's how state errors are handled in `jest-circus` now:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/f988721c02e8442b39d6dd92dba9bc2a8dd10ff0\/packages\/jest-circus\/src\/legacy-code-todo-rewrite\/jestAdapterInit.ts#L197-L205\r\n\r\nBut the errors are ignored because all test suit is skipped. I can't seem to find what calls `runAndTransformResultsToJestFormat` to find the cause of this bug. Can you show me the previous step in this workflow?\r\nbtw, this exact same problem occurs when all tests are skipped and afterAll fails in production version. No error will be printed, because it is handled with a state error.\r\n","@SimenB Also, this is my first PR and it will be helpful to me if you told me if I should mention you each time I reply.",">But the errors are ignored because all test suit is skipped.\r\n\r\nThat sounds weird - could you post a small sample test that behaves this way?\r\n\r\n> @SimenB Also, this is my first PR and it will be helpful to me if you told me if I should mention you each time I reply.\r\n\r\nThe PR will bubble up on my notifications list regardless of the ping. Doesn't hurt, tho \ud83d\ude42 I don't necessarily get a notification if you push code tho, so feel free to ping when you push \ud83d\ude42 ","@SimenB \r\n> That sounds weird - could you post a small sample test that behaves this way?\r\n\r\nHere you go:\r\n```typescript\r\ndescribe('test that a 3rd party API remains consistent', () => {\r\n  test.skip('API function 1', () => expect(1).toBe(1)); \/\/ skipped\r\n  test.skip('API function 2', () => expect(2).toBe(2)); \/\/ skipped\r\n  test.skip('API function 3', () => expect(3).toBe(3)); \/\/ skipped\r\n  afterAll(() => expect('login').toBe('successfull')); \/\/ fails, should report failure\r\n});\r\n```\r\n\r\nafterAll hook should be reported failed, but because all tests are meant to be skipped, the output ignores it.\r\nWhen the tests are not skipped, it does report a failure.\r\n\r\nSo skipping all tests in beforeAll the same way won't print the error. It might be needed to be reported in another issue.","@SimenB \r\nHave you had any chance to look into it?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Hey, should I let this PR to close?","Completely forgot about this PR, sorry!","CI is failing - would you be able to take a look? Or is that waiting for https:\/\/github.com\/facebook\/jest\/pull\/13273#issuecomment-1250138230?","> CI is failing - would you be able to take a look? Or is that waiting for [#13273 (comment)](https:\/\/github.com\/facebook\/jest\/pull\/13273#issuecomment-1250138230)?\r\n\r\nYeah, it is.\r\nCurrently the PR marks the first test as failed, although we wish it to mark all as skipped, which prints output of skipped test case suite and no error.\r\nI'll be glad if you could review my comments again and refer me to the relevant code or advise what should be the next steps here.","can we merge the PR if it is done?","> can we merge the PR if it is done?\r\n\r\nHey, as I have replied to @SimenB, this PR is yet done. There is an still an unfinished discussion about the PR implementation that I'd like one of the project maintainers could review so I can complete this feature.\r\n\r\nHere's my last comment regarding the issue: https:\/\/github.com\/jestjs\/jest\/pull\/13273#issuecomment-1435701856","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@itaizelther I just bumped the issue this links, since I assume this is still in the works?","Hey @thernstig,\r\nThis PR currently not in works.\r\nI've wrote a piece printing the error only once as desired, but it marks other tests as \"skipped\", which is incorrect.\r\nTo fix that the change needs to be done fundamentally in the module calling `jest-circus`, but as @SimenB described it in the comments above, [\"fixing it might be a sever major change\"](https:\/\/github.com\/jestjs\/jest\/pull\/13273#issuecomment-1250090334).\r\n\r\nI suggest an experienced individual should point to the module that has to be refactored or take the PR to self .\r\n","@SimenB is there a chance you have some guidance?"],"labels":["cla signed","Pinned"]},{"title":"[Feature]: Add expect.soft for setup and soft assertions","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nA new method `soft` on the `expect` object giving test authors fine grained control over the control flow of their test case. An assertion decorated with `.soft` continues execution of a test case after assertion's failure to gather more data e.g. via remaining assertions in the case. \r\n\r\n### Motivation\r\n\r\nThis provides new tools to test authors striving to write more expressive and easier to debug tests.\r\n\r\n### Example\r\n\r\nI often encounter test case with intermediary assertions designed to ensure a precondition relevant to the final assertion is met.\r\n\r\n```\r\ntest('result is as expected given precondition is met', () => {\r\n  const precondition = setup();\r\n  expect(precondition).toBe(met);\r\n \r\n  const result = fn(precondition);\r\n  expect(result).toBe(asExpected)\r\n})\r\n```\r\n\r\nThis works but is sub-optimal in so far as in the case of a precondition failure useful debugging information is lost as execution stops after the first failed assertion:\r\n\r\n```\r\n  \u25cf result is as expected given precondition is met\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: met\r\n    Received: notMet\r\n\r\n      20 |\r\n      21 | test('an assertion depending on a precondition', () => {\r\n      22 |    const precondition = setup();\r\n    > 23 |   expect(precondition).toBe(met);\r\n         |             ^\r\n      24 |   const result = fn(precondition);\r\n      25 |   expect(result).toBe(asExpected);\r\n      26 | });\r\n ```\r\n \r\n Consider the same case with a hypothetical `.soft` assertion that continues execution but fails the test case if any (soft or not) assertion is not met\r\n \r\n ```\r\n  \u25cf result is as expected given precondition is met\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: met\r\n    Received: notMet\r\n\r\n      20 |\r\n      21 | test('an assertion depending on a precondition', () => {\r\n      22 |    const precondition = setup();\r\n    > 23 |   expect.soft(precondition).toBe(met);\r\n         |             ^\r\n      24 |   const result = fn(precondition);\r\n      25 |   expect(result).toBe(asExpected);\r\n      26 | });\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: asExpected\r\n    Received: notAsExpected\r\n\r\n      20 |\r\n      21 | test('an assertion depending on a precondition', () => {\r\n      22 |    const precondition = setup();\r\n    > 23 |   expect.soft(precondition).toBe(met);\r\n      24 |   const result = fn(precondition);\r\n      25 |   expect(result).toBe(asExpected);\r\n         |             ^\r\n      26 | });\r\n ```\r\n \r\n\r\n### Pitch\r\n\r\nThis will lead to better test suites which I take is jest's mission. \ud83d\ude80 \r\n\r\n\r\n### Prior art\r\n\r\nPlaywright implements this: https:\/\/playwright.dev\/docs\/test-assertions#soft-assertions","comments":["I like the idea! Main issue is that `expect` is not bound to a test case, so we wouldn't know _which_ test failed (see for instance https:\/\/github.com\/facebook\/jest\/issues\/8297#issuecomment-1050744485). As mentioned there, and other places, once we bind `expect` to a single test it'd unblock a bunch of features we'd like. Should probably try to figure out a way to do that at some point...","```js\r\n(function (name) {\r\n    const fn = function () {\r\n        throw 123\r\n    };\r\n    Object.defineProperty(fn, \"name\", {\r\n        value: name\r\n    })\r\n    fn()\r\n})(\"'jest_id_xxx'\")\r\n```\r\nThis may allow us to use the call stacks.\r\nVery hacky, but compatibility should be fine.\r\n\ud83d\ude03\r\n![image](https:\/\/user-images.githubusercontent.com\/30521560\/196712271-5add6c78-7d5c-4fca-9bef-61c839303fc1.png)\r\n","@SimenB Do you have a rough idea of what binding expect to single tests would entail, is there some sketch of the required work I can read up on?","It is not to advertise, but to help, but I think this covers the need: https:\/\/github.com\/alfonso-presa\/soft-assert\r\n\r\nLet me know if it helps (or not :-) )","the expect should have the similar functionality than soft-assert.\r\nThe idea is minor failures, like text contents,  will be displayed and fail only at the end of the test and not stop the test. Therefore the test will validate the functional things.\r\nSee the softAssertAll() in https:\/\/www.npmjs.com\/package\/soft-assert"],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Feature]: Allow using tsx instead of ts-node for loading TS config files","body":"### \ud83d\ude80 Feature Proposal\n\nI would like to be able to use the [`tsx`](https:\/\/github.com\/esbuild-kit\/tsx) compiler for handling the `jest.config.ts` file, as opposed to relying on ts-node.\n\n### Motivation\n\n`tsx` is a quickly rising alternative to ts-node as it runs much faster as it runs on the back of esbuild, and doesn't do typechecking. While parsing the jest configuration file should already be generally quick, it could be made quicker to using tsx. Additionally, for teams that have moved to tsx, it would allow having just one runtime compiler in their dependency for everything, vs having tsx for most things, and ts-node just for reading `jest.config.ts` files.\n\n### Example\n\nIt would be used implicitly within `jest-config` library where when it detects a file that ends with `.ts`, it checks if ts-node is available and uses that, else it'll check for tsx and use that. If neither are available output an error message that neither could be found.\r\n\r\nAll the user would need to do would be to have `tsx` installed via their package manager and available via `node_modules`.\n\n### Pitch\n\nLooking at https:\/\/github.com\/facebook\/jest\/blob\/main\/packages\/jest-config\/src\/readConfigFileAndSetRootDir.ts, there didn't seem to be an obvious way to modify the behavior of how it loads config files, where even if it was possible to get tsx registered before triggering jest-config, it would still attempt to use ts-node for `.ts` extension.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I'm still interested in this. jest is the only thing pulling in ts-node in our stack, and it would be nice to be able to eliminate it for tsx.","Making this pluggable would be nice - we had a PR at some point for an SWC-based loader as well.\r\n\r\nThoughts on adding some sort of `loader` docblock at the top of the file, similar to e.g. `\/** @jest-environment jsdom *\/`?","Sure, I think that adding a brief loader docblock at the top of the file would make sense, in the concept that within your dependency tree you end up with multiple TS loaders for whatever reason, and you want to make sure that you end up using a specific one, vs the default ordering of jest. Adding support for that should be pretty straight-forward, as compared to actually implementing these other loaders.\r\n\r\n> we had a PR at some point for an SWC-based loader as well.\r\n\r\nDo you know what it was named? I did find a PR for `esbuild-loader` (https:\/\/github.com\/facebook\/jest\/pull\/12041) that has stalled, but not swc.","~~I think we could use something like a `require` option where you could put whatever transpiler out there. [This is how ava does it](https:\/\/github.com\/avajs\/ava\/blob\/main\/docs\/recipes\/typescript.md#for-packages-without-type-module). This way you can use whatever you want: `@swc-node\/register`, `ts-node\/register`, `esbuild-register`.~~\r\n\r\nEdit: My bad, this is working on running the tests, not loading the config file","I was trying to do this today and thought it would be as easy as adding `--loader @esbuild-kit\/esm-loader` to `NODE_OPTIONS`:\r\n\r\n```sh\r\nNODE_OPTIONS='--experimental-vm-modules --loader @esbuild-kit\/esm-loader' jest\r\n```\r\n\r\nHowever, when I do that I get an interesting error:\r\n\r\n```text\r\nTypeError: Unexpected response from worker: undefined\r\n    at ChildProcessWorker._onMessage (\/Users\/linus\/my-project\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:289:15)\r\n    at ChildProcess.emit (node:events:527:28)\r\n    at emit (node:internal\/child_process:938:14)\r\n    at processTicksAndRejections (node:internal\/process\/task_queues:84:21)\r\n```\r\n\r\nAdding some logging to `node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js` reveals that this is the message being sent from the child process:\r\n\r\n```json\r\n{\r\n  \"type\": \"dependency\",\r\n  \"path\": \"file:\/\/\/Users\/linus\/my-project\/node_modules\/jest-worker\/build\/workers\/processChild.js\"\r\n}\r\n```\r\n\r\nIt seems like `ChildProcessWorker` is expecting an array where the first item is the message type, not an object though...\r\n\r\nI'm not really sure how to continue debugging this, but would love some input!\r\n\r\nGenerally, I think it would be amazing if Jest could work with the `--loader` argument to Node.js!","Okay, turns out the mysterious object above wasn't emitted from Jest at all, it was the loader.\r\n\r\nFiled an issue about that here: https:\/\/github.com\/esbuild-kit\/esm-loader\/issues\/43\r\n\r\nKnowing that I simply added this code to ignore the messages:\r\n\r\n```diff\r\n  }\r\n  _onMessage(response) {\r\n+   \/\/ Ignore messages emitted by @esbuild-kit\/esm-loader\r\n+   \/\/ ref: https:\/\/github.com\/esbuild-kit\/esm-loader\/issues\/43\r\n+   if (typeof response === 'object' && typeof response.type === 'string' && response.type === 'dependency') {\r\n+     return\r\n+   }\r\n    \/\/ TODO: Add appropriate type check\r\n    let error;\r\n    switch (response[0]) {\r\n```\r\n\r\nThis led me to the next problem.\r\n\r\n> SyntaxError: Unexpected token, expected \"{\"\r\n\r\nWell, this stack trace was in Babel, and I didn't want to use that. So I added `\"transform\": {}` to my Jest config, and tried again:\r\n\r\n> SyntaxError: Unexpected token ':'\r\n\r\nThis time the stack trace only shows `Runtime.loadEsmModule`.\r\n\r\nGoing in to this function it seems like it always loads the file from disk and passes it thru a function that calls the transformers. I tried replacing it with just an import of the file instead, something like:\r\n\r\n```diff\r\n        return core;\r\n      }\r\n-     const transformedCode = await this.transformFileAsync(modulePath, {\r\n-       isInternalModule: false,\r\n-       supportsDynamicImport: true,\r\n-       supportsExportNamespaceFrom: true,\r\n-       supportsStaticESM: true,\r\n-       supportsTopLevelAwait: true\r\n-     });\r\n+     const transformedCode = `import '${modulePath}'`;\r\n      try {\r\n        const module = new (_vm().SourceTextModule)(transformedCode, {\r\n          context,\r\n```\r\n\r\nThis results in the following error though:\r\n\r\n>   \u25cf Test suite failed to run\r\n> \r\n>     Your test suite must contain at least one test.\r\n\r\n~~Hmm, alright, I'm not sure why it gives that specific error, but `SourceTextModule` won't be able to route `import` calls thru the specified loader as far as I can tell.~~ (actually, I'm not sure about this anymore, I guessed that since it looked like imports were routed via the `importModuleDynamically` callback, but I see now that that is just when calling `import(...)`)\r\n\r\nLets just try calling my loader here directly and see if it works:\r\n\r\n```diff\r\n        return core;\r\n      }\r\n-     const transformedCode = await this.transformFileAsync(modulePath, {\r\n-       isInternalModule: false,\r\n-       supportsDynamicImport: true,\r\n-       supportsExportNamespaceFrom: true,\r\n-       supportsStaticESM: true,\r\n-       supportsTopLevelAwait: true\r\n-     });\r\n+     const esmLoader = await import('@esbuild-kit\/esm-loader')\r\n+     const transformedCode = (await esmLoader.load(`file:\/\/${modulePath}`, { format: 'esm' }, (url) => {\r\n+       return { source: fs().readFileSync(new URL(url), 'utf8') }\r\n+     })).source\r\n      try {\r\n        const module = new (_vm().SourceTextModule)(transformedCode, {\r\n          context,\r\n```\r\n\r\n> Test Suites: 15 passed, 15 total\r\n> Tests:       53 passed, 53 total\r\n\r\nSuccess!\r\n\r\nOkay, if there is a way to get ahold of the loader some way I think using it to load files would be viable.\r\n\r\n@SimenB would there be any interest in maybe adding a flag for Jest that makes it use the loader that Node.js uses to load test files? I think that this would be awesome since we can run the tests in the same way that we run the normal code!\r\n\r\n-----\r\n\r\nedit: ~~actually, adding a log of `transformedCode` shows that it has `import` statements in it, that in my case refers to TypeScript files. So I'm actually only transforming the first file myself withe the call to `esmLoader.load`, any imported files seems to be transformed by Node.js using the loader specified with `--loader`.~~\r\n\r\nedit2: hmm, no every file is passed thru here I think, via the `link` function of the module...","I'd be interested in a PR that shows the changes needed. \ud83d\udc4d ","Here it is! \ud83c\udf89 \r\n\r\n#13521","#13521 wouldn't address the issue of how jest loads the config file though, just how it transforms and runs the test files right?","@MasterOdin it seems like you are right, I will make a small update to address that \ud83d\udc4d \r\n\r\nIn fact, I didn't notice that this issue was talking about config file specifically at all \ud83d\ude05 ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","(not stale)","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","(not stale)","Still happy to take a PR adding support for some sort of docblock to the config file if anyone's up for it in the new year \ud83d\ude00 ","@SimenB Trying to find time to do this now, but to be clear on your comments on this thread as well as in #12041 and #11989 is that if the user does not specify a docblock, then jest will only try to use `ts-node`, throwing the error (plus perhaps linking to the docs about the new docblock) if that's not installed. The only way to use an alternative loader is by specifying the docblock, e.g. `\/* @jest-config-loader tsx *\/`, or whatever. Of course, if that loader is not installed, then it'll throw the same error as missing `ts-node`, just mentioning the specified package.","Yeah, that sounds about right. \ud83d\udc4d We can probably remove built-in ts-node in next major and have that also be opt-in via a docblock.","Also, not sure if we should define som \"config loader\" interface (just `path-to-config.* -> Config.InitialOptions`) rather than us instantiating e.g. `tsx` and having to provide it options. Us just doing `const config = import(moduleNameFromDocblock).then(m => m.default(pathToConfig))` seems better than having to pass a bunch of different options depending on what the \"config loader\" does. Then we could link to modules providing this interface for whatever module you wanna use.","@SimenB have you considered the approach in #13521? Instead of having anything specific to Jest, that would then work with any Node.js compatible [loader](https:\/\/nodejs.org\/docs\/latest-v18.x\/api\/esm.html#loaders). It would also work with all code, instead of just the config files.","ts-node hasn't seen a release in over a year at this point and [still doesn't support TypeScript 5.0's multiple inheritance feature for `tsconfig.json` files](https:\/\/github.com\/TypeStrong\/ts-node\/issues\/2000). tsx, [swc-node](https:\/\/github.com\/swc-project\/swc-node), or the native Node.js ESM loader are looking increasingly like the way of the future to me.\r\n\r\n> > we had a PR at some point for an SWC-based loader as well.\r\n\r\n> Do you know what it was named? I did find a PR for `esbuild-loader` (#12041) that has stalled, but not swc.\r\n\r\n@MasterOdin, I believe it was #13779.","It's worth to mention `ts-node` does not work with the newest Node 18.x and 20.x anymore (works only as a loader but not a standalone command) which might make it pretty much useless for anything other than Jest config file.\r\n\r\nhttps:\/\/github.com\/TypeStrong\/ts-node\/issues\/1997\r\nhttps:\/\/github.com\/TypeStrong\/ts-node\/issues\/2094"],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"[Feature]: Support loading jest.config.ts as ESM","body":"### \ud83d\ude80 Feature Proposal\n\n- If `\"type\": \"module\"` is set in the package.json, `jest.config.ts` should be treated as ESM, not CJS\r\n- `jest.config.mts` and `jest.config.cts` should be looked for and loaded as ESM and CJS, respectively\n\n### Motivation\n\n- This is currently the behavior with `jest.config.js`, and so ESM vs CJS handling differs between JS and TS configs\r\n- I would like to be able to import ESM libraries in my TS config\n\n### Example\n\n_No response_\n\n### Pitch\n\n- Config loading is handled by core\r\n- Module behavior between JS and TS should match","comments":["Related: #11453","PR welcome! Logic for config file resolution and reading is in https:\/\/github.com\/facebook\/jest\/blob\/1919ef13df544a968bd2d32e5d7b8a2a1c4b35d1\/packages\/jest-config\/src\/readConfigFileAndSetRootDir.ts","That said, I don't think anything has changed since https:\/\/github.com\/facebook\/jest\/issues\/11453#issuecomment-1040424443 (i.e. you need a loader). But we should at least find `cts` as that is supposed to be converted to cjs","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@SimenB as a first step, maybe let's get support for `jest.config.cts`, to avoid the extra `ts-node.moduleTypes` config for `ts-node`\r\n\r\nTook a quick shot at a PR - does it need anything else? (other than fixing the tests)\r\n\r\n- https:\/\/github.com\/facebook\/jest\/pull\/14064\r\n\r\n**Edit:** @DerTimonius opened a new PR based on mine, which also fixes the tests:\r\n\r\n- https:\/\/github.com\/facebook\/jest\/pull\/14070","https:\/\/github.com\/jestjs\/jest\/releases\/tag\/v30.0.0-alpha.3 for `.cts` support"],"labels":[":rocket: Feature Request","TypeScript","Pinned"]},{"title":"Create Dockerfile for contributing","body":"Closes #9105\r\n\r\n## Summary\r\nThis PR is an addition to the pr of alex-cannon (#9109), where there seems to be no activity. I merged his half-finished work into this branch and finished it.\r\n\r\n\r\n## Test plan\r\n\r\nRun the following commands to test it (Tested on Windows):\r\n\r\n* Build Jest\r\n```\r\ndocker build -t jest .\r\n```\r\n* Run Jest\r\nYou may need to replace $PWD with the path to your Jest clone.\r\n```\r\ndocker run --volume=\"${PWD}:\/usr\/src\/app\" --rm jest:latest\r\n```\r\n\r\n## TODO\r\n* [x] Test docker container, volume etc..\r\n* [x] Fix yarn watch\r\n\r\n\r\n","comments":["The issue with `yarn watch` is that the file changes are not notified through docker volumes. If I edit the file in the docker container, yarn notices that and builds the files again. The problem is that if I change the files outside of the docker cointainer (in the volume) the files inside are updated as well, but the rebuild is not triggered by `yarn watch`-","This problem also exists with other applications when using docker volumes (one described [here](https:\/\/forums.docker.com\/t\/file-system-watch-does-not-work-with-mounted-volumes\/12038)). For example, nodemon also doesn't work with docker volumes and you have to use the -L flag to enable polling and making it work ([nodemon with docker section on npm](https:\/\/www.npmjs.com\/package\/nodemon#application-isnt-restarting)). The solution would be to use polling when using docker volumes.\r\n  \r\nWe could implement this by changing the watch.mjs script here:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/c44de55e585be824092465ed7a21d0a59c11c2ee\/scripts\/watch.mjs#L35-L43\r\n\r\nIf we add the option `usePolling: true` docker volumes will work (Tested this with windows and it works). \r\nChokidar option:\r\n```\r\n  \/**\r\n   * Whether to use fs.watchFile (backed by polling), or fs.watch. If polling leads to high CPU\r\n   * utilization, consider setting this to `false`. It is typically necessary to **set this to\r\n   * `true` to successfully watch files over a network**, and it may be necessary to successfully\r\n   * watch files in other non-standard situations. Setting to `true` explicitly on OS X overrides\r\n   * the `useFsEvents` default.\r\n   *\/\r\n  usePolling?: boolean;\r\n```\r\n[link to the code](https:\/\/github.com\/paulmillr\/chokidar\/blob\/614748746c0f36e39f11145301df0bea3dafeeea\/types\/index.d.ts#L109-L116)\r\n\r\nWe should probably create an extra script\/or add options to the watch.mjs file for if we use polling or not...\r\n","@SimenB let me know what you think...","Implemented the script with polling. Now everything works as expected.","Can i work on this issue","It's already done... we just need to wait on the feedback of @SimenB ","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This would still be a nice addition to the progress (improving developer speed).","Fixed the issues...","@SimenB @mrazauskas ","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bump, this could be useful for new and experienced developers\/contributors by creating an isolated development environment.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Another bump, still relevant...","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","4th bump.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bump","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bump"],"labels":["cla signed"]},{"title":"[Bug]: jest ts-node ignores provided tsconfig.json","body":"### Version\r\n\r\n28.0.5\r\n\r\n### Steps to reproduce\r\n\r\nCreate valid **jest.config.ts** file wit the next content:\r\n```\r\nimport { InitialOptionsTsJest } from 'ts-jest'\r\nimport path from 'path'\r\n\r\nconsole.log(import.meta)\r\n\r\nconst jestOptions: InitialOptionsTsJest = {\r\n    preset: 'ts-jest\/presets\/default-esm',\r\n    rootDir: '.\/some_root',\r\n    testMatch: [ '**\/*.test.ts' ],\r\n    extensionsToTreatAsEsm: ['.ts'],\r\n    moduleNameMapper: {\r\n        '^(\\\\.{1,2}\/.*)\\\\.js$': '$1'\r\n    },\r\n    globals: {\r\n        'ts-jest': {\r\n            useESM: true,\r\n            tsconfig: path.join(process.cwd(), 'tsconfig.json')\r\n        }\r\n    }\r\n}\r\n\r\nexport default jestOptions\r\n```\r\n\r\nNote **console.log(import.meta)**\r\n\r\nCreate valid **tsconfig.json** file:\r\n\r\n\r\n```\r\n{\r\n    \"compilerOptions\": {\r\n\t\"target\": \"esnext\",\r\n        \"module\": \"esnext\",\r\n\t\"moduleResolution\": \"node\",\r\n        \"allowJs\": true,\r\n\t\"esModuleInterop\": true,\r\n        \"strict\": true,\r\n\t\"skipLibCheck\": true,\r\n        \"declaration\": true,\r\n        \"allowSyntheticDefaultImports\": true,\r\n        \"isolatedModules\": true\r\n    }\r\n}\r\n```\r\n\r\n\r\nrun **npx jest**\r\n\r\n### Expected behavior\r\n\r\nNo TS errors\r\n\r\n### Actual behavior\r\n\r\n```\r\nError: Jest: Failed to parse the TypeScript config file .\/some_proj\/jest.config.ts\r\n  TSError: \u2a2f Unable to compile TypeScript:\r\njest.config.ts:55:13 - error TS1343: The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node12', or 'nodenext'.\r\n\r\nconsole.log(import.meta)\r\n               ~~~~~~~~~~~\r\n\r\n    at readConfigFileAndSetRootDir (\/some_proj\/node_modules\/jest-config\/build\/readConfigFileAndSetRootDir.js:136:13)\r\n    at async readConfig (\/some_proj\/node_modules\/jest-config\/build\/index.js:216:18)\r\n    at async readConfigs (\/some_proj\/node_modules\/jest-config\/build\/index.js:404:26)\r\n    at async runCLI (\/some_proj\/node_modules\/@jest\/core\/build\/cli\/index.js:140:59)\r\n    at async Object.run (\/some_proj\/node_modules\/jest-cli\/build\/cli\/index.js:155:37)\r\n\r\n```\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n  OS: Linux 5.17.12-100.fc34.x86_64\r\n  CPU: (8) arm64\r\n\r\nBinaries:\r\n  Node: 16.15.0\r\n  npm: 7.20.0\r\n\r\nnpmPackages:\r\n  \"jest\": \"28.1.0\",\r\n  \"ts-jest\": \"^28.0.5\"\r\n```\r\n\r\n\r\n### Stack overflow\r\nThere is a [question](https:\/\/stackoverflow.com\/questions\/69200870\/jest-tests-fail-using-ts-jest-when-in-a-es2020-esnext-ts-project) on stackoverflow been posted 9 months ago still not answered...\r\n\r\n\r\n### TS Jest\r\n\r\n[issue on git](https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/3648)\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Issue still present","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Issue still present ","Yeah, this isn't currently possible - see https:\/\/github.com\/facebook\/jest\/issues\/11453#issuecomment-1040424443. In #12397 we enforce CJS, might be we should tweak this. It's unfortunate this requires using a loader, tho... Would love to figure out a good way for Jest to just ask `ts-node` to load the config for us without caring about what flavour of module system it's written in","So is there any workaround for this? This is the only blocker I have for migrating my code to ESM from CJS.","Any updates about this issue? Same error while using `ts-jest` and it blocks even if I use `ts-node` to import `jest.config.ts`","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump","Well this puts us in a bind...","Any possible solution? If there's any, I can help with.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Issue still present","Any update on this ? ","Still present.","I think there's some confusion because the `tsconfig` used to compile `jest.config.ts`, before launching the test runner, is not necessarily the same `tsconfig` used by the ts-jest transformer to compile the TS code under test.\r\n\r\nI don't write my Jest config in TS -- it works fine in JS with type annotation comment directives -- but for those who do, is there really a use-case for consuming `import.meta` while configuring Jest (i.e., specifically in `jest.config.ts`)?\r\n\r\nAs far as consuming `import.meta` in the code under test, I believe that should fall into the purview of `ts-jest` -- they punted over here specifically because you're trying to refer to it in the config file, before `ts-jest` actually *does* anything.\r\n\r\nETA: actually I don't think there is a problem on the `ts-jest` side.  I just found https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/3888 which links to [this handy example](https:\/\/replit.com\/@broofa\/JestImportMetaTest), where the user is successfully running a test that uses `import.meta`, using `ts-jest\/presets\/default-esm`.  So, bottom line, this issue is only about `import.meta` in `jest.config.ts`, specifically, and if you want to use `import.meta` in your code and\/or tests, that already works.  (Again, if you *are* trying to use `import.meta` in `jest.config.ts`, I would be really curious to know why.)","@SimenB if my logic in the previous comment is correct, then this should be closed now as a duplicate of  https:\/\/github.com\/facebook\/jest\/issues\/13118 .","I don't use it specifically in the `jest.config.ts` file, but my project does use it in the `globalSetup.ts` file which has the same issue.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Issue still present ","@thw0rted The use case for me is in the globalSetup which has the same issue","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still happens","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","still happens\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant...","Issue persists...","still happens","still happens","any news here?\r\nI have the same problem\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/6597815\/43e79f89-2719-40c4-adeb-a1926513c980)\r\n","srsly wtf","still persist","Hey peeps,\r\n\r\nMy teammate @macmv came up with a work around for this using jest transformers.\r\n\r\nFeel free to use this code:\r\n\r\n```typescript\r\nconst tsJest = require(\"ts-jest\").default;\r\n\r\nmodule.exports = {\r\n  createTransformer(config) {\r\n    const transformer = tsJest.createTransformer(config);\r\n    const tsProcess = transformer.process;\r\n    transformer.process = (sourceText, ...rest) => {\r\n      sourceText = sourceText.replaceAll(\"import.meta.env\", \"({} as any)\");\r\n      return tsProcess(sourceText, ...rest);\r\n    };\r\n    return transformer;\r\n  },\r\n};\r\n```\r\n\r\nThe other nifty thing about this is you could extend it to install some kind of mock object instead of `({} as any)` for example `{ taco: \"tuesday\", pizza: \"friday\" }`.\r\n\r\nEnjoy!\r\n\r\n\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump. Not stale. Ffs.","For Yarn PnP ESM projects, I managed to workaround by opting out from ts-node commonJS register. I think [multiple loaders](https:\/\/nodejs.org\/en\/blog\/release\/v18.6.0) is working for Node 18.6+ If your project is on Node 18.6+, you can see my `yarn` [patch](https:\/\/github.com\/psychobolt\/vite-storybook-boilerplate\/blob\/8c162da83fd7b4e8c4aaf5d489686d302a215def\/.yarn\/patches\/jest-config-npm-29.7.0-97d8544d74.patch) for lines to modify.\r\n\r\n```diff\r\ndiff --git a\/build\/readConfigFileAndSetRootDir.js b\/build\/readConfigFileAndSetRootDir.js\r\nindex e989961ba71bbea43eb293ebdc7739f00f6e85e7..44429f504f568cb5cef2998f527e0a8837d47338 100644\r\n--- a\/build\/readConfigFileAndSetRootDir.js\r\n+++ b\/build\/readConfigFileAndSetRootDir.js\r\n@@ -11,6 +11,13 @@ function path() {\r\n   };\r\n   return data;\r\n }\r\n+function url() {\r\n+  const data = _interopRequireWildcard(require('url'));\r\n+  url = function () {\r\n+    return data;\r\n+  };\r\n+  return data;\r\n+}\r\n function fs() {\r\n   const data = _interopRequireWildcard(require('graceful-fs'));\r\n   fs = function () {\r\n@@ -101,7 +108,11 @@ async function readConfigFileAndSetRootDir(configPath) {\r\n   let configObject;\r\n   try {\r\n     if (isTS) {\r\n-      configObject = await loadTSConfigFile(configPath);\r\n+      const configModule = await import(path().isAbsolute(configPath)\r\n+        ? url().pathToFileURL(configPath).href\r\n+        : configPath\r\n+      );\r\n+      configObject = configModule.default;\r\n     } else if (isJSON) {\r\n       const fileContent = fs().readFileSync(configPath, 'utf8');\r\n       configObject = (0, _parseJson().default)(\r\n\r\n```\r\n\r\nThen using `ts-node-esm` loader to launch Jest CLI:\r\n```sh\r\nyarn node --loader ts-node\/esm --loader file:\/\/$PROJECT_CWD\/.pnp.loader.mjs $(yarn bin jest) # or $(yarn bin test-storybook) # `file:\/\/` for resolving windows file paths\r\n```\r\n\r\nThis should be able to read your project's `tsconfig.json`. ","This seems to be rather a limitation in jest. I'm trying to port my mocha-based project to jest as I had thought it might have fewer issues with TypeScript and modules; but apparently not. Sometimes I wonder if anyone uses typescript and ECMAScript modules for anything as nothing seems to work; I've been on a multi-hour Google\/SO\/Github issue journey and nobody seems to have solved this"],"labels":["Help Wanted","TypeScript","ES Modules","Pinned"]},{"title":"[Feature]: Allow esm https network imports","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nAdd `https:` support for esm imports.\r\n\r\n\r\n### Motivation\r\n\r\nExperimental esm https network imports was added in node.js v17 https:\/\/nodejs.org\/api\/esm.html#https-and-http-imports\r\n\r\nIt is currently behind a `--experimental-network-imports` flag.\r\n\r\nCode using this feature is not testable as of Jest v28.1.0.\r\n\r\n### Example\r\n\r\nThe following is not testable using Jest, but can be run in node.js with `--experimental-network-imports`\r\n\r\n```js\r\nimport capitalize from \"https:\/\/cdn.skypack.dev\/pin\/lodash-es@v4.17.21-rDGl8YjBUjcrrAbjNrmo\/mode=imports\/unoptimized\/capitalize.js\";\r\n\r\nconsole.log(\r\n  capitalize(\r\n    \"this string should be capitalized using an https import of lodash.capitalize\"\r\n  )\r\n);\r\n```\r\n\r\n### Pitch\r\n\r\nESM imports is core functionality in node.js and `https:` imports just another feature of it.\r\n\r\nJest should support `https:` imports as tools like [deno](https:\/\/deno.land\/) and [vite](https:\/\/vitejs.dev\/) are popularizing using esm https imports directly.\r\n\r\nImplementing this feature should be fairly simple by adding another case to: https:\/\/github.com\/facebook\/jest\/blob\/811228d6ae73a6563a98b0ee36b73f453e644f2f\/packages\/jest-runtime\/src\/index.ts#L543","comments":["For those already using vite and esm https imports, you can use [deno test](https:\/\/deno.land\/manual\/testing) as a workaround. Deno natively supports esm https imports, so the test runner would as well.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","ES Modules","Pinned"]},{"title":"[Feature]: Support `.mts` and `.cts` file extensions for code coverage","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nSupport `.mts` and `.cts` file extensions for code coverage.\r\n\r\n### Motivation\r\n\r\nTypeScript 4.7 supports two new source file extensions: `.mts` and `.cts` each of which should be supported for collecting code coverage.\r\n\r\n### Example\r\n\r\n```js\r\n\/\/ jest.config.js\r\nmodule.exports = {\r\n  testMatch: [\"<rootDir>\/src\/**\/*.test.{mts,ts}\"],\r\n  collectCoverage: true,\r\n  collectCoverageFrom: [\"src\/**\/*.{mts,ts}\"],  \/\/ currently does not work for mts files\r\n  testEnvironment: \"node\",\r\n  resolver: \"<rootDir>\/mjs-resolver.js\",  \/\/ currently a workaround that should go away\r\n  transform: {\r\n    \"^.+\\\\.(ts|mts)$\": \"babel-jest\",\r\n  },\r\n};\r\n```\r\n```js\r\n\/\/ mjs-resolver.js\r\n\/**\r\n * Resolves `.mjs` imports to `.mts`.\r\n *\/\r\nmodule.exports = (path, options) => {\r\n  const mjsExtRegex = \/\\.mjs$\/i;\r\n  const resolver = options.defaultResolver;\r\n  if (mjsExtRegex.test(path)) {\r\n    try {\r\n      return resolver(path.replace(mjsExtRegex, \".mts\"), options);\r\n    } catch {\r\n      \/\/ use default resolver\r\n    }\r\n  }\r\n  return resolver(path, options);\r\n};\r\n```\r\n\r\n```ts\r\n\/\/ src\/example.mts\r\nimport { something } from \".\/dependency.mjs\"; \/\/ extension required by TypeScript due to Node's ESM implementation\r\n\r\n\/\/ src\/dependency.mts\r\nexport const something = \"message\";\r\n```\r\n\r\n\r\n### Pitch\r\n\r\nWith these new file extensions being added by TypeScript, Jest should add support for collecting code coverage from these file types.","comments":["Possibly an upstream issue in `istanbuljs`. See https:\/\/github.com\/istanbuljs\/istanbuljs\/issues\/634\r\n\r\nCoverage is collected from `.mts` files, if I add these lines to Jest config:\r\n\r\n```js\r\ncoverageProvider: 'v8', \/\/ will use `c8` instead of `instanbuljs` to collect coverage\r\nmoduleFileExtensions: ['js', 'ts', 'mts'],\r\n```\r\n\r\n@sagargurtu Could you check and confirm, please?","Verified. Switching `coverageProvider` to `'v8'` enables code coverage from `.mts` files.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale, this is part of native esm (and ts) support"],"labels":[":rocket: Feature Request","TypeScript","ES Modules","Pinned"]},{"title":"[Bug]: import behavior has been broken for certain cases","body":"### Version\r\n\r\n28.1.0\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone my repo from: https:\/\/github.com\/noomorph\/jest-import-issue\r\n2. Follow the steps in the README.\r\n\r\nYou'll see that a vanilla installation of Jest 28 behaves in a drastically different way when it comes to importing `require('yargs\/yargs').Parser`.\r\n\r\n### Expected behavior\r\n\r\nI'd expect Jest in both cases to find the exported function.\r\n\r\n```js\r\ntest('should import yargs\/yargs Parser', () => {\r\n  expect(require('yargs\/yargs').Parser).toBeInstanceOf(Function);\r\n});\r\n```\r\n\r\n![Screen Shot 2022-05-13 at 17 37 04](https:\/\/user-images.githubusercontent.com\/1962469\/168307942-45e55193-d83a-4ecb-96c5-9ed3fadb015c.png)\r\n\r\n\r\n\r\n### Actual behavior\r\n\r\nJest 28 returns `undefined` on an attempt to `require('yargs\/yargs').Parser`.\r\n\r\n![Screen Shot 2022-05-13 at 17 37 15](https:\/\/user-images.githubusercontent.com\/1962469\/168308063-4e2e7c3c-026a-4a1e-9626-4ea2f39defbc.png)\r\n\r\n\r\n### Additional context\r\n\r\nI have to say that I can see `node_modules\/yargs\/yargs` there, a file without an extension. Inside it I see:\r\n\r\n```\r\n\/\/ TODO: consolidate on using a helpers file at some point in the future, which\r\n\/\/ is the approach currently used to export Parser and applyExtends for ESM:\r\nconst {applyExtends, cjsPlatformShim, Parser, Yargs, processArgv} = require('.\/build\/index.cjs')\r\nYargs.applyExtends = (config, cwd, mergeExtends) => {\r\n  return applyExtends(config, cwd, mergeExtends, cjsPlatformShim)\r\n}\r\nYargs.hideBin = processArgv.hideBin\r\nYargs.Parser = Parser\r\nmodule.exports = Yargs\r\n```\r\n\r\nMaybe there's some problem with the package, with the way how it exports itself. But did you actually intend to introduce a breaking behavior with 28.x compared to 27.x?\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 10.15.7\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 16.14.2 - ~\/.nvm\/versions\/node\/v16.14.2\/bin\/node\r\n    npm: 8.5.0 - ~\/.nvm\/versions\/node\/v16.14.2\/bin\/npm\r\n  npmPackages:\r\n    jest: ^28.1.0 => 28.1.0\r\n```\r\n","comments":["The issue is still relevant, just in case.","I have a similar issue. An npm package requires an script from another npm package :\r\n```js\r\nrequire('three\/examples\/js\/loaders\/FontLoader.js');\r\n```\r\nThe project itself has `three` as dependency. But somehow require can't find the script in the three npm package but three itself. I get the error:\r\n```\r\n Cannot find module 'three\/examples\/js\/loaders\/FontLoader.js' from 'node_modules\/@wmc\/zk-web3d\/dist\/es5\/services\/FontManager.js'\r\n```\r\n\r\nMy current workaround is to set a moduleNameMapper for the script in the jest.config.js\r\n```js\r\nmodule.exports = {\r\n   ...\r\n   moduleNameMapper: {\r\n        ...\r\n        'three\/examples\/js\/loaders\/FontLoader.js': 'node_modules\/three\/examples\/js\/loaders\/FontLoader.js'\r\n    }\r\n}\r\n```\r\n\r\nIt worked with jest 27.5.1 but broke after updated to 28.1.0.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Jest 28.1.3 fails at this example just as it did the first day. \ud83e\udd37\u200d\u2642\ufe0f \r\n\r\nThe issue is **relevant**.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is a bug in [`resolve.exports`](https:\/\/github.com\/lukeed\/resolve.exports) (the lib we use to resolve `exports`, which shipped in Jest 28).\r\n\r\n```js\r\nconst pkg = require('yargs\/package.json')\r\n\r\nconst { resolve } = require('resolve.exports');\r\n\r\nconsole.log(resolve(pkg, 'yargs', { conditions: ['require'], unsafe: true }));\r\nconsole.log(require.resolve('yargs\/yargs'))\r\n```\r\n\r\nPossibly https:\/\/github.com\/lukeed\/resolve.exports\/issues\/17?","Don't know if this is a good place,\r\nI notice if the dependency is:\r\n\r\n```js\r\n{\r\n  \"type\": \"module\",\r\n  \"exports\": \".\/index.mjs\",\r\n  \"main\": \".\/index.js\"\r\n}\r\n```\r\n\r\n`jest` will load `.\/index.mjs` correctly.\r\nBut if the dependency is:\r\n\r\n```js\r\n{\r\n  \"type\" : \"module\",\r\n  \"exports\": {\r\n    \"import\": \".\/index.mjs\",\r\n    \"require\": \".\/index.js\"\r\n  }\r\n}\r\n```\r\n\r\n`jest` will load `.\/index.js` instead."],"labels":["Upstream Bug","Pinned"]},{"title":"[Bug]: it.each doesn't support BigInt, complaining \"TypeError: Do not know how to serialize a BigInt\"","body":"### Version\r\n\r\n28.0.2\r\n\r\n### Steps to reproduce\r\n\r\nFollowing test will end up with an error (see section \"Action Behaviour\"), no matter the matcher is passed or failed.\r\n\r\n\r\n```js\r\ndescribe(\"error\", () => {\r\n  it.each([\r\n    [1n, 2n, 3n]\r\n  ])(\"test\", (a, b, c) => {\r\n    expect(a + b).toBe(c);\r\n  });\r\n});\r\n```\r\n\r\nAlso, Jest prints out such error whenever a test is failed (without it.each).\r\n\r\n```js\r\ndescribe(\"error\", () => {\r\n    it(\"print annoying message when a test failed.\", () => { \r\n        expect(1n + 3n).toBe(10n);\r\n    });\r\n});\r\n```\r\n\r\nBut oddly, if you write matcher outside `it(...)` functions, *Jest* will not print out the error message - it will print out messages of failed tests:\r\n\r\n```js\r\ndescribe(\"write matcher outside it(...)\", () => {\r\n    expect(1n + 3n).toBe(10n);\r\n});\r\n```\r\n\r\n```\r\n  \u25cf Test suite failed to run\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: 10n\r\n    Received: 4n\r\n\r\n      12 |\r\n      13 | describe(\"write matcher outside it(...)\", () => {\r\n    > 14 |     expect(1n + 3n).toBe(10n);\r\n         |                     ^\r\n      15 | });\r\n\r\n      at toBe (chapter.16-greedy-algorithm\/exercises\/__tests__\/16.2-7.js:14:21)\r\n      at describe (chapter.16-greedy-algorithm\/exercises\/__tests__\/16.2-7.js:13:1)\r\n```\r\n\r\n### Expected behaviour\r\n\r\nThis error should not shows up.\r\n\r\n### Actual behavior\r\n\r\nComplained that:\r\n\r\n```\r\n  \u25cf Test suite failed to run\r\n\r\n    TypeError: Do not know how to serialize a BigInt\r\n        at stringify (<anonymous>)\r\n\r\n      at messageParent (node_modules\/jest-worker\/build\/workers\/messageParent.js:33:19)\r\n```\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Windows 10 10.0.19042\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz\r\n  Binaries:\r\n    Node: 16.14.2 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.13.0 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 8.5.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^28.0.2 => 28.0.2\r\n\r\n```\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Dear, I would like to take it.","I think upgrade the `jest` version to the latest and this issue can be solved now. I have tried in my mac, and now it currently can run correctly. \r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/3050418\/88067417-2571-4277-8d51-07679b348784)\r\n\r\n\r\n### Environment\r\n```shell\r\nSystem:\r\n    OS: Apple OX 13.2.1\r\n    CPU: Apple M1 Max\r\nBinaries:\r\n    Node: 16.4.1\r\n    Yarn: 1.22.19\r\n    npm: 9.8.1\r\n    jest: 29.3\r\n```","I'm currently developing using NestJS, and when I encountered this issue, I looked it up and found this\r\n\r\nI was able to solve it from the following site: https:\/\/zenn.dev\/serinuntius\/scraps\/02dfe48b643745\r\n\r\njest.config.ts \r\n```typescript \r\n\"workerThreads\": true \r\n```\r\n\r\nI'm not using jest.config.ts, so I just added that code to the jest part of my package.json and that solved it. I'm not sure why this solves it, though, so if anyone knows how, I'd appreciate a reply."],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Bug]: jest-runtime accesses `jsdom`'s `window.localStorage`, inviting `SecurityError`s when origin is opaque","body":"### Version\r\n\r\n28.0.3\r\n\r\n### Steps to reproduce\r\n\r\nContinuing the discussion from https:\/\/github.com\/jsdom\/jsdom\/issues\/2304#issuecomment-1119172182. (I agree that this is a Jest issue, not a `jsdom` issue.)\r\n\r\n1. Clone my repo at https:\/\/github.com\/chrisbobbe\/jest-repro-security-error\/\r\n2. `yarn && yarn test`\r\n3. See output like \r\n\r\n```\r\n FAIL  .\/foo.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    SecurityError: localStorage is not available for opaque origins\r\n```\r\n\r\n### Expected behavior\r\n\r\nI should not get an error about using `localStorage` unless I'm meaningfully trying to use `localStorage` when it's forbidden.\r\n\r\n### Actual behavior\r\n\r\nI get an error about using `localStorage`, even though I'm not meaningfully trying to use it.\r\n\r\n### Additional context\r\n\r\n(Again, if you haven't, please see context at https:\/\/github.com\/jsdom\/jsdom\/issues\/2304#issuecomment-1119172182.)\r\n\r\nPasting from the test file in my repro:\r\n\r\n```js\r\n\/\/ With this line, I get this output:\r\n\/\/\r\n\/\/   FAIL  .\/sum.test.js\r\n\/\/   \u25cf Test suite failed to run\r\n\/\/  \r\n\/\/     SecurityError: localStorage is not available for opaque origins\r\n\/\/\r\njsdom.reconfigure({ url: 'file:\/\/\/something' });\r\n\/\/ \u2026Without it, the test passes.\r\n\/\/\r\n\/\/ The problem is that jest-runtime, at line\r\n\/\/   https:\/\/github.com\/facebook\/jest\/blob\/3390ec4ef6a1b93afa816655f5c1f0605066b15a\/packages\/jest-runtime\/src\/index.ts#L1165\r\n\/\/ , is inadvertently calling jsdom's `get localStorage`:\r\n\/\/   https:\/\/github.com\/jsdom\/jsdom\/blob\/4c7eed155e421c3b261667b6312d4c89d2a74c1b\/lib\/jsdom\/browser\/Window.js#L417-L426\r\n\/\/ , which throws that SecurityError when the window's location has an\r\n\/\/ opaque origin. \"file:\/\/\/something\" is an example of a URL with an opaque\r\n\/\/ origin:\r\n\/\/   https:\/\/html.spec.whatwg.org\/multipage\/origin.html#concept-origin-opaque\r\n\/\/\r\n\/\/ I can make the error go away by changing that code in jest-runtime such\r\n\/\/ that `envGlobal[key]` doesn't run if `key` equals \"localStorage\". Once I\r\n\/\/ do that, and the same for if `key` is \"sessionStorage\", the test runs and\r\n\/\/ passes.\r\n```\r\n\r\n### Environment\r\n\r\n```shell\r\n  System:\r\n    OS: macOS 12.3.1\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 17.6.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.17 - \/usr\/local\/bin\/yarn\r\n    npm: 8.5.1 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^28.0.3 => 28.0.3 \r\n```\r\n","comments":["Also blocked from upgrades by this","> I should not get an error about using `localStorage` unless I'm meaningfully trying to use `localStorage` when it's forbidden.\r\n\r\nJest isn't trying to use it either. Seems aggressive from JSDOM's side to warn on _access_, not _usage_ (i.e. `localStorage.getItem` or some such).\r\n\r\nE.g. `const jsdom = new JSDOM('<script>console.log(typeof localStorage)<\/script>', {runScripts: 'dangerously'})` prints the same error, killing feature detection.\r\n\r\nNot sure if we should just ignore `localStorage` by default or hope JSDOM tweaks their check to be more precise.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is blocking an upgrade","PR welcome \ud83d\ude03","Might be worth an issue in jsdom to make the check a bit less strict, but skipping it in jest seems reasonable in the meantime","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","Still a bug","Looks like version 29.2.2 of `jest-environment-jsdom` now defaults to `http:\/\/localhost\/` (see https:\/\/github.com\/facebook\/jest\/blob\/main\/packages\/jest-environment-jsdom\/src\/index.ts#L64)\r\n\r\n","How to fix it"],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"[Feature]: esm\/cjs autodetection for TypeScript files","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nApologies if this issue already exists, but my quick search didn't find anything.\r\n\r\nThis is a request for an API such that the detection for whether a suite should be run as module or script can be ported to non-JS files.\r\n\r\n### Motivation\r\n\r\nWorking on https:\/\/github.com\/facebook\/docusaurus\/issues\/6520. I decided this should be rolled out gradually: one package at a time, which means I will set `\"type\": \"module\"` in one package, refactor usage of `__dirname`, etc., change tsc `module` setting, and then the package is successfully migrated. It almost works, but I'm getting blocked by Jest.\r\n\r\nAFAICT, Jest works by first asking the transformer to transform the file to JS, then decides whether to run it as a module or a script. When the file is a `.js` file, it uses the same heuristics as Node to tell if a file is a module; but when the file is `.ts`, Jest only uses `extensionsToTreatAsEsm`. This means there's no way to support a CJS\/ESM hybrid code base.\r\n\r\nTypeScript 4.7 adds the `nodenext` module option, which will allow `.ts` files to be transpiled based on the package.json `type` field. I think Jest should support a similar pattern.\r\n\r\n### Example\r\n\r\nI've created a repo: https:\/\/github.com\/Josh-Cena\/esm-cjs-ts-hybrid-example\r\n\r\nI can't figure out _any_ way to make `yarn test` succeed.\r\n\r\n### Pitch\r\n\r\nRelated: https:\/\/github.com\/facebook\/jest\/issues\/9430\r\n\r\nPossible solutions:\r\n\r\n- Allow nested `jest.config.js` files, so I can override `extensionsToTreatAsEsm` within certain packages\r\n- Extend `extensionsToTreatAsEsm` to allow the detection to also be based on package.json\r\n\r\nNon-solutions:\r\n\r\n- Rename all test files to `.mts`\/`.cts` \ud83d\ude04 It's obviously not ideal, and on GitHub blame view, you lose the file's history.\r\n- Run `yarn jest` on each package. I prefer to run everything in one go, both because there's maximum paralleling, and also because I can \"copy relative path\" in my editor and invoke `yarn test` directly, instead of first focusing to one workspace.","comments":["> * Allow nested `jest.config.js` files, so I can override `extensionsToTreatAsEsm` within certain packages\r\n\r\nYou can do this today via `projects`, `extensionsToTreatAsEsm` is per project.\r\n\r\n(not saying that's super elegant or clean, but it should at least unblock you).\r\n\r\n---\r\n\r\nAnd I have nightmares about TS 4.7, I'll probably just turn off all GH notifications when it drops. It's so _incredibly_ breaking","Breaking... in terms of the `nodenext` module option? \ud83d\udc40","Tried with `projects`, could you tell me if this is the correct way to do it? https:\/\/github.com\/Josh-Cena\/esm-cjs-ts-hybrid-example\/commit\/3ffa37db6c47bc12ccc0f1068bb56eebeef203a7 (Wasn't too sure from the docs)\r\n\r\nThere's some level of duplication here; I guess that's what you mean by \"not clean\"? \ud83d\ude04","Yeah, you'll need to set `testMatch` to empty or something in the root if you have defined projects, otherwise multiple projects finds the same tests (by design, a project might e.g. be type tests or eslint).\r\n\r\nEDIT: hmm, `testPathIgnorePatterns` should probably have worked\r\n\r\n---\r\n\r\n`nodenext` stuff yeah, saying `.js` in the import even though the file on disk is `.ts(x)` is the big one for Jest.","@Josh-Cena seems I answered a deleted comment or something \ud83d\ude05 it works?","Note that you can define project config inline, so you can probably do something clever like reading the `package.json` of each module and building up the config based on that. I'd probably do 2 projects in root (one for esm and one for cjs) to get the best parallelization, instead of one project per module","Ah, yes, it works, I accidentally ran tests in the compiled output as well\ud83d\ude05 I can confirm `testPathIgnorePatterns` and `testMatch` both work. I guess I would start with `testPathIgnorePatterns` and when the number of ESM packages build up, go to `testMatch`. Both seem like good ways out to me.\r\n\r\n> 2 projects in root (one for esm and one for cjs)\r\n\r\nSo, you mean, use a glob to find all packages, read each one's `package.json`, and then build the relevant `testMatch` options? That seems like a cool way out \ud83d\udc4d","> So, you mean, use a glob to find all packages, read each one's `package.json`, and then build the relevant `testMatch` options?\r\n\r\nYep, exactly","It works haha: https:\/\/github.com\/Josh-Cena\/esm-cjs-ts-hybrid-example\/commit\/ae064df5d9b084b15ba57323ee3cbd16dcefcc8c\r\n\r\nDefinitely not ideal, but it should unblock me for now! Thanks a lot for that idea","Heh, if it works \ud83d\ude00 \r\n\r\nI'd probably do something like this, if nothing else to reduce the number of file:\r\n\r\n```js\r\nimport glob from 'glob';\r\nimport fs from 'node:fs';\r\nimport path from 'node:path';\r\n\r\nconst { cjsPackages, esmPackages } = glob\r\n  .sync(\"packages\/**\/package.json\")\r\n  .reduce(\r\n    (acc, p) => {\r\n      const packageType = JSON.parse(fs.readFileSync(p, \"utf8\")).type;\r\n\r\n      const dirname = path.dirname(path.relative(process.cwd(), p));\r\n\r\n      if (packageType === \"module\") {\r\n        acc.esmPackages.push(dirname);\r\n      } else {\r\n        acc.cjsPackages.push(dirname);\r\n      }\r\n\r\n      return acc;\r\n    },\r\n    { cjsPackages: [], esmPackages: [] }\r\n  );\r\n\r\nexport default {\r\n  projects: [\r\n    {\r\n      testMatch: [`<rootDir>\/(${(cjsPackages.join(\"|\"))})\/src\/**\/__tests__\/**`],\r\n      transform: {\r\n        \"^.+\\\\.[jt]sx?$\": \"@swc\/jest\",\r\n      },\r\n    },\r\n    {\r\n      testMatch: [`<rootDir>\/(${(esmPackages.join(\"|\"))})\/src\/**\/__tests__\/**`],\r\n      transform: {\r\n        \"^.+\\\\.[jt]sx?$\": \"@swc\/jest\",\r\n      },\r\n      extensionsToTreatAsEsm: [\".ts\"],\r\n    },\r\n  ],\r\n};\r\n```","Oh... I couldn't tell what `ProjectConfig` means from the docs, but when you give that it all makes sense\ud83d\ude07 Thanks again","np! it should work fine, but ideally we'd behave the same as TS. Not sure how to do that without breaking literally _everybody_ not on the latest version of TS, but I guess we'll figure it out \ud83e\udd37 ","Oh yeah, I can see that the `.js` extension is a pain\ud83d\ude07 (TBH, importing TS with `.js` extension has been around for a while, I had been transpiling with `\"module\": \"esnext\"` for a long time) For now it's fine, but when I try my hands on some more non-trivial packages it would be problematic...\r\n\r\nEdit: actually, it's already blocking me from migrating the `@docusaurus\/migrate` package, which is what I'm planning to do anyways (aw, migrating the migrate package...). I'll watch out for a resolution for that. Is there an issue to track the extension issue?","Not really, should probably open one","Actually, I think `moduleNameMapper: { \"(.*)\\\\.js$\": [\"$1.js\", \"$1.ts\"] }` should do it, doesn't look too bad IMO... Do you think this resolution should be supported OOTB?","I don't think so. It's a nice workaround until proper support is in place, tho","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83d\udc4b","I'll be doing something similar in `@repobuddy\/jest`. Currently, I have simplified the configuration to a single preset. ","https:\/\/github.com\/repobuddy\/jest\/blob\/main\/packages\/jest\/README.md\r\n\r\nThe preset `@repobuddy\/jest\/presets\/ts` and `@repobuddy\/jest\/presets\/ts-watch` will detect CJS\/ESM automatically."],"labels":[":rocket: Feature Request","TypeScript","Pinned"]},{"title":"switch from source-map-support to @cspotcode\/source-map-support","body":"## Summary\r\n\r\nPer comments here: https:\/\/github.com\/facebook\/jest\/issues\/12485#issuecomment-1105051830\r\n\r\nFor a list of fixes and improvements compared to source-map-support:\r\nhttps:\/\/github.com\/cspotcode\/node-source-map-support\/issues\/24\r\n\r\nSupercedes and closes #12486 \r\n\r\n## Test plan\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["Oops, I accidentally submitted this before finishing running tests locally.  Test failures are not intentional; I'll try to figure out what's going on.","Might be https:\/\/github.com\/facebook\/jest\/pull\/9147","Is there a way to attach a debugger to some of these tests, to step through what's happening?  The build process and test suite bootstrapping are quite complex.  I've tried opening `node_modules\/@cspotcode\/source-map-support\/source-map-support.js`, changing stuff, re-running the tests, but it doesn't seem to make a difference.","If I'm reading that issue correctly, jest is relying on incorrect stack traces, ones that do not match V8 \/ node's behavior?","essentially, yeah. I haven't bothered to attempt to work around it yet, but it might be time now. Should do that first, before landing this PR.\r\n\r\nSemi related: https:\/\/github.com\/facebook\/jest\/issues\/10633, https:\/\/github.com\/facebook\/react\/pull\/20026","> Is there a way to attach a debugger to some of these tests, to step through what's happening?\r\n\r\nAs long as you run a single test, debugging should work perfectly fine. Multiple tests spawns processes which at least chrome debugger has issues hitting. Can add `--run-in-band` to avoid","I've updated the snapshots in #9147, might be interesting to apply this diff on top to see if the stacks then agree","one single change, which seems sorta reasonable?","There was another test failure where jest was expecting `Error:\\n    at` but we're giving it `Error\\n    at` on newer node.  The latter matches vanilla node\/v8.  Looks like I've fixed this bug in source-map-support when running against node 16 and newer.  On node 14 and older the bug still exists, but I know what to fix, so I'll do that.","Taking a look at #10633, this PR (or rather #9147), but this doesn't fix it makes the stack trace wrong.\r\n\r\n\r\n```js\r\n\/\/ hubba.test.js\r\nfunction BadCode() {\r\n  throw new Error('noo');\r\n}\r\n\r\nfunction run(fn) {\r\n  fn();\r\n}\r\n\r\nrun(BadCode);\r\n```\r\n\r\n\r\n```se-session\r\n$ node hubba.test.js\r\n\/Users\/simen\/repos\/jest\/hubba.test.js:2\r\n  throw new Error('noo');\r\n  ^\r\n\r\nError: noo\r\n    at BadCode (\/Users\/simen\/repos\/jest\/hubba.test.js:2:9)\r\n    at run (\/Users\/simen\/repos\/jest\/hubba.test.js:6:3)\r\n    at Object.<anonymous> (\/Users\/simen\/repos\/jest\/hubba.test.js:9:1)\r\n    at Module._compile (node:internal\/modules\/cjs\/loader:1105:14)\r\n    at Object.Module._extensions..js (node:internal\/modules\/cjs\/loader:1159:10)\r\n    at Module.load (node:internal\/modules\/cjs\/loader:981:32)\r\n    at Function.Module._load (node:internal\/modules\/cjs\/loader:822:12)\r\n    at Function.executeUserEntryPoint [as runMain] (node:internal\/modules\/run_main:77:12)\r\n    at node:internal\/main\/run_main_module:17:47\r\n\r\n$  deno run hubba.test.js\r\nerror: Uncaught Error: noo\r\n  throw new Error('noo');\r\n        ^\r\n    at BadCode (file:\/\/\/Users\/simen\/repos\/jest\/hubba.test.js:2:9)\r\n    at run (file:\/\/\/Users\/simen\/repos\/jest\/hubba.test.js:6:3)\r\n    at file:\/\/\/Users\/simen\/repos\/jest\/hubba.test.js:9:1\r\n\r\n$  yarn jest hubba\r\n FAIL  .\/hubba.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    noo\r\n\r\n      1 | function BadCode() {\r\n    > 2 |   throw new Error('noo');\r\n        |         ^\r\n      3 | }\r\n      4 |\r\n      5 | function run(fn) {\r\n\r\n      at fn (hubba.test.js:2:9)\r\n      at run (hubba.test.js:6:3)\r\n      at Object.<anonymous> (hubba.test.js:9:1)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.537 s\r\nRan all test suites matching \/hubba\/i.\r\n```\r\n\r\nIf I run the same test on main\r\n\r\n```sh-session\r\n$ yarn jest hubba\r\n FAIL  .\/hubba.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    noo\r\n\r\n      1 | function BadCode() {\r\n    > 2 |   throw new Error('noo');\r\n        |         ^\r\n      3 | }\r\n      4 |\r\n      5 | function run(fn) {\r\n\r\n      at BadCode (hubba.test.js:2:9)\r\n      at fn (hubba.test.js:6:3)\r\n      at Object.run (hubba.test.js:9:1)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.468 s\r\nRan all test suites matching \/hubba\/i.\r\n```\r\n\r\nNote that it's also correct if I disable code transformation (meaning no source map) or just remove the `install` call. Not sure if the issue is Babel's source maps (which is the transform we use in this repo) or in applying it.","Yeah, might be a bug in Babel actually. The code produced by `babel-jest` for `hubba.test.js` above:\r\n\r\n```js\r\n\"use strict\";\r\n\r\nfunction BadCode() {\r\n  throw new Error('noo');\r\n}\r\n\r\nfunction run(fn) {\r\n  fn();\r\n}\r\n\r\nrun(BadCode);\r\n\/\/# sourceMappingURL=data:application\/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCYWRDb2RlIiwiRXJyb3IiLCJydW4iLCJmbiJdLCJzb3VyY2VzIjpbImh1YmJhLnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gQmFkQ29kZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub28nKTtcbn1cblxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gIGZuKCk7XG59XG5cbnJ1bihCYWRDb2RlKTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxTQUFTQSxPQUFULEdBQW1CO0VBQ2pCLE1BQU0sSUFBSUMsS0FBSixDQUFVLEtBQVYsQ0FBTjtBQUNEOztBQUVELFNBQVNDLEdBQVQsQ0FBYUMsRUFBYixFQUFpQjtFQUNmQSxFQUFFO0FBQ0g7O0FBRURELEdBQUcsQ0FBQ0YsT0FBRCxDQUFIIn0=\r\n```\r\n\r\nIf I run that file with node\r\n\r\n```sh-session\r\n$ node -v\r\nv16.15.0\r\n$ node hubba2.js\r\n\/Users\/simen\/repos\/jest\/hubba2.js:4\r\n  throw new Error('noo');\r\n  ^\r\n\r\nError: noo\r\n    at BadCode (\/Users\/simen\/repos\/jest\/hubba2.js:4:9)\r\n    at run (\/Users\/simen\/repos\/jest\/hubba2.js:8:3)\r\n    at Object.<anonymous> (\/Users\/simen\/repos\/jest\/hubba2.js:11:1)\r\n    at Module._compile (node:internal\/modules\/cjs\/loader:1105:14)\r\n    at Object.Module._extensions..js (node:internal\/modules\/cjs\/loader:1159:10)\r\n    at Module.load (node:internal\/modules\/cjs\/loader:981:32)\r\n    at Function.Module._load (node:internal\/modules\/cjs\/loader:822:12)\r\n    at Function.executeUserEntryPoint [as runMain] (node:internal\/modules\/run_main:77:12)\r\n    at node:internal\/main\/run_main_module:17:47\r\n$ node --enable-source-maps hubba2.js\r\n\/Users\/simen\/repos\/jest\/hubba.test.js:2\r\n  throw new Error('noo');\r\n        ^\r\n\r\nError: noo\r\n    at fn (\/Users\/simen\/repos\/jest\/hubba.test.js:2:9)\r\n    at run (\/Users\/simen\/repos\/jest\/hubba.test.js:6:3)\r\n    at Object.<anonymous> (\/Users\/simen\/repos\/jest\/hubba.test.js:9:1)\r\n    at Module._compile (node:internal\/modules\/cjs\/loader:1105:14)\r\n    at Object.Module._extensions..js (node:internal\/modules\/cjs\/loader:1159:10)\r\n    at Module.load (node:internal\/modules\/cjs\/loader:981:32)\r\n    at Function.Module._load (node:internal\/modules\/cjs\/loader:822:12)\r\n    at Function.executeUserEntryPoint [as runMain] (node:internal\/modules\/run_main:77:12)\r\n    at node:internal\/main\/run_main_module:17:47\r\n```\r\n\r\nThe interesting part is the second one, running node with `--enable-source-maps` - you can see the stack is broken in the same way (should be `at BadCode`, is `at fn`). Not sure if this bug is in Node's implementation of source maps or in the one's coming out of Babel. Likely culprit is the latter as it's broken in newer `source-map-support` as well as `@cspotcode\/source-map-support`?\r\n\r\n@jridgewell would you be able to comment on this?","I noticed the package.json version declaration was `0.5.13` as opposed to `^0.5.13`.  Is one preferred, caret or not?  Was going to change it to `^0.8.1`","@cspotcode caret generally, it is locked due the the issue with names I commented about above \ud83d\ude42 ","My hubba script btw has the correct trace in Chrome\r\n\r\n<img width=\"263\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/1404810\/166243026-5900da4f-c08f-48f2-b7e7-51261681626a.png\">\r\n\r\nSo it might be a bug in the algorithm of `source-map-support` which both Node and `@cspotcode\/source-map-support` has inherited","Hmm, the flag in node is supposed to come from chromium: https:\/\/github.com\/nodejs\/node\/pull\/29564\r\n\r\nEDIT: Sorry @cspotcode, it's unlikely this has anything to do with your PR, but I do think it's blocked by it","What's the likely culprit?  Does this still seem like a flaw in the sourcemaps coming from babel?  Is jest currently relying on a bug in the old source-map-support implementation?","Jest currently relies on a bug for the function name, but the current version (and node) has another bug (I think) so it's lost for another reason. https:\/\/github.com\/facebook\/jest\/pull\/12786#issuecomment-1114894586","I made a bit of progress figuring this out.\r\n\r\nhttps:\/\/github.com\/cspotcode\/node-source-map-support\/issues\/40\r\n\r\nSounds like I can probably attempt a *proper* bugfix for this, which will be good for any consumers of @cspotcode\/source-map-support, not just jest and ts-node.","Seems like Chrome is showing the correct source map only because it makes zero attempt to map the function names.  That is, if I modify the hubba example so that the function's name in the *generated* code is different than in the *source* code, I can confirm that the stack trace shows the *generated* name.  So it's mapping locations, but not function names.","The sourcemap and stack trace are correct ([visualization](https:\/\/evanw.github.io\/source-map-visualization\/#NjU3ACJ1c2Ugc3RyaWN0IjsKCmZ1bmN0aW9uIEJhZENvZGUoKSB7CiAgdGhyb3cgbmV3IEVycm9yKCdub28nKTsKfQoKZnVuY3Rpb24gcnVuKGZuKSB7CiAgZm4oKTsKfQoKcnVuKEJhZENvZGUpOwovLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnVZVzFsY3lJNld5SkNZV1JEYjJSbElpd2lSWEp5YjNJaUxDSnlkVzRpTENKbWJpSmRMQ0p6YjNWeVkyVnpJanBiSW1oMVltSmhMblJsYzNRdWFuTWlYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWm5WdVkzUnBiMjRnUW1Ga1EyOWtaU2dwSUh0Y2JpQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZHViMjhuS1R0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnY25WdUtHWnVLU0I3WEc0Z0lHWnVLQ2s3WEc1OVhHNWNibkoxYmloQ1lXUkRiMlJsS1R0Y2JpSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3hUUVVGVFFTeFBRVUZVTEVkQlFXMUNPMFZCUTJwQ0xFMUJRVTBzU1VGQlNVTXNTMEZCU2l4RFFVRlZMRXRCUVZZc1EwRkJUanRCUVVORU96dEJRVVZFTEZOQlFWTkRMRWRCUVZRc1EwRkJZVU1zUlVGQllpeEZRVUZwUWp0RlFVTm1RU3hGUVVGRk8wRkJRMGc3TzBGQlJVUkVMRWRCUVVjc1EwRkJRMFlzVDBGQlJDeERRVUZJSW4wPTM2MgB7InZlcnNpb24iOjMsIm5hbWVzIjpbIkJhZENvZGUiLCJFcnJvciIsInJ1biIsImZuIl0sInNvdXJjZXMiOlsiaHViYmEudGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBCYWRDb2RlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vbycpO1xufVxuXG5mdW5jdGlvbiBydW4oZm4pIHtcbiAgZm4oKTtcbn1cblxucnVuKEJhZENvZGUpO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBLFNBQVNBLE9BQVQsR0FBbUI7RUFDakIsTUFBTSxJQUFJQyxLQUFKLENBQVUsS0FBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBU0MsR0FBVCxDQUFhQyxFQUFiLEVBQWlCO0VBQ2ZBLEVBQUU7QUFDSDs7QUFFREQsR0FBRyxDQUFDRixPQUFELENBQUgifQ==), keep in mind this uses 0-based line\/column and not a stack trace's 1-based), the issue is node's implementation that gets the name of an enclosing function. \r\n\r\nTo begin with, the source map has no idea what the name of the real function is when you call `fn()`. `fn` is passed in as a parameter, so to a sourcemap, the functions name is \"fn\". There's no way we could track through to realize it's actually \"BadCode\", because you could have invoked the `run` function with _any_ function instance. How would we associate every instance with real name? You could only do so at runtime.\r\n\r\nSo, how does Node unminify? It has a [Consumer implementation](https:\/\/github.com\/nodejs\/node\/blob\/master\/lib\/internal\/source_map\/source_map.js), which was copied from Chrome, and the implementation is correct. It also has a [`prepareStackTrace` implementation](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js), which takes individual frames of a stack trace and tries uses the Consumer to find original names\/locations.\r\n\r\nWalking through the traces, we first have a `{ line: 4, column: 9 }` in the generated output (`new Error('noo')`). We [trace](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js#L73-L77) out a `{ line: 2, column: 9, source: 'hubba.test.js' }`. We then [call](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js#L80) [`getOriginalSymbolName`](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js#L119-L136). That [does](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js#L119-L136) a trace using the enclosing line and column to try and find the name of the enclosing function. Here's our issue: the enclosing location is `{ line: 3, column: 1 }` in the generated output, and that's `function BadCode() {` and specifically the `function`. There's no name at that location! The name \"BadCode` isn't found until column 10. So we're [not going to find](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js#L125) an enclosing name based on the sourcemap.\r\n\r\nNext, we try to find the name of the [callsite](https:\/\/github.com\/nodejs\/node\/blob\/f6f95bf61e84dae44b16c51ebb4a9c5b46194583\/lib\/internal\/source_map\/prepare_stack_trace.js#L129-L135). The callsite is a `{ line: 8, column: 3 }`, and that's `fn()`. When we trace, we find the name \"fn\", and use that in our unminfied stack.\r\n\r\nThis `getOriginalSymbolName` is trying to deal with minifiers mangling a function name. Unfortunately, I don't know of any build tool that associates the function's original name with the `function` keyword in the output. And because we're dealing with minfiers, that means both the callsite and the `frame.getFunctionName()` are likely to be the mangled name. The only way to get the unminified name would be to detect that we're at a `function foo`, and lookup the column associated with `+= 9` (and handle similar cases with arrows, methods, `async function foo() {}`, `function* foo() {}`, etc).\r\n\r\n\/cc @bcoe ","That matches my analysis as well: https:\/\/github.com\/cspotcode\/node-source-map-support\/issues\/40#issue-1223183150\r\n\r\nSo node and Chrome are attempting to get the name at the `getEnclosing{Line,Column}Number` position before doing a fallback at `get{Line,Column}Number`?  The problem is that in cases where we're running transpiled \/ unminified code, the fallback is less helpful than no fallback at all, since the runtime function name is likely to be the same or similar to the source code name.  That is, a TS function `BadCode` compiles into a JS function `BadCode`.","> So node and Chrome are attempting to get the name at the getEnclosing{Line,Column}Number position before doing a fallback at get{Line,Column}Number?\r\n\r\nJust node. Chrome has direct access to the scope information, and gets locations for tracing from the binding itself: https:\/\/source.chromium.org\/chromium\/chromium\/src\/+\/main:third_party\/devtools-frontend\/src\/front_end\/models\/source_map_scopes\/NamesResolver.ts;l=86-155;drc=0ee4cd1f428349686a6f23bb4234636ed3b4b63e\r\n\r\nWe have access to the function's generated name via `frame.getFunctionName` or `getMethodName`. We could use that, in combination with the `sourcesContent` and the `getEnclosingLineNumber`\/`getEnclosingColumnNumber` to find the identifier in the generated code, and perform a trace from that location. Or we can do some basic `isAsync`\/`isGenerator` and arrow corrections to determine how many columns to modify the trace by.","I thought about that, but I'm worried it'd get really hairy and work only inconsistently, since there are a bunch of ways to declare functions with names: `async method()`, `method()`, `const foo = function()`, `function foo()`, `const foo = async () =>`.","The issue is that node's behavior -- showing the callsite name instead of the function name -- is arguably wrong.  If we change @cspotcode\/source-map-support to stop doing the wrong thing, we fix jest but diverge from node.  Which I think is a good thing.  But it would be nice to have a couple second opinions before I go down this route.","There's a [proposal](https:\/\/github.com\/source-map\/source-map-rfc\/issues\/12) for `scopes` to be added to sourcemaps in v4, and it includes a `scopeNames` field (or possibly adding scope names to the already existing `names` field). This would solve the issue by allowing us to associate a scope name with the beginning mark of a function instance, instead of with the identifier. This particularly helps in the case of a parenthesis-less arrow `x => x`, because the enclosing line\/column is already used to mark the `x` parameter (and whatever it's unminified name is).","I'll follow along with that RFC.  Any thoughts on how source-map-support should behave today, with v3 sourcemaps?  I'm inclined to remove the call-site fallback.  This means we avoid giving misleading answers in stack traces, and we're in a good position for `scopeNames`.  But as I said, I'd really like at least a couple second opinions before going to down that route.","I would do the function's unminified name via enclosing as it does today, then runtime name via `frame.getFunctionName`, and fallback to call site name only if both failed.","When do you anticipate `frame.getFunctionName` failing?  If the function does not have a name, wouldn't it be best to put `<anonymous>` in the stack trace?  (I believe off-hand it shows `<anonymous>` for functions without names; I might be wrong about that)  Trying to best understand the situations in which we anticipate that happening.\r\n\r\nOtherwise I agree.\r\n\r\nEDIT: seems to do `at ${f.getTypeName()}.<anonymous> ${path here}` if there is a `getTypeName`, otherwise `at ${path here}`","I'd personally prefer the callsite name to anonymous, but really either would be fine.","If we keep the callsite fallback enabled by default, should we add an optional flag to disable that behavior?  @SimenB will that work for jest?","That sounds very reasonable!","I tried teaching source-map-support to map names at `getEnclosingLineNumber` and `getEnclosingColumnNumber` the way node does.  This highlighted another problem with node's sourcemap implementation -- another place where we should be deviating from node.  Thankfully, we're already there, because stable @cspotcode\/source-map-support never attempts to map enclosing position.\r\n\r\nIn this example:\r\n\r\n```\r\nit('should fail', done => {\r\n  throw new Error();\r\n});\r\n```\r\n\r\nThe first stack frame's `getEnclosing*Number()` gives us the location of the `done` identifier, because that is where the function declaration starts.  If we attempt to source-map the name at that position, we erroneously believe that the function's name is `done`.  It is not; that is the name of the first argument to the function.\r\n\r\nThis example is great, because it shows how bad it can be to attempt these imperfect sourcemap checks.  In the examples we looked at several days ago, we were mapping to the name of a function at its callsite, not its declared name.  Both names referred to the same function.  So it was imperfect, but semantically it sorta made sense.\r\n\r\nBut today's example is much worst: we are mapping to the name of an entirely different function.  This isn't merely imperfect, it's flat-out wrong and misleading.  `done` refers to a different function with a different purpose.\r\n\r\nThe fix is: never attempt to map names at the \"enclosing\" position.  The sourcemap spec, as it is today, can't do that.","I've updated this pull request to use a pre-built tarball of https:\/\/github.com\/cspotcode\/node-source-map-support\/pull\/41 because I don't want to publish to npm till it has passed all code reviews, and because trying to use a git dependency was failing some yarn integrity checks on CI.\r\n\r\nHere is the diff of my changes against #9147\r\nhttps:\/\/github.com\/SimenB\/jest\/compare\/bump-source-map-support..cspotcode:cspotcode-source-map-support","Thanks @cspotcode! I'm still unsure if this is safe to land due to the naming error - for better or worse the current stack traces seems more _useful_ to me, even if the new stacks are more correct. \"sourcemap doesn't support this\" is an unsatisfying answer when the _current_ behavior of Jest does not have the issue (although it has other issues).\r\n\r\nNot sure what the best tradeoff here is... And regardless of the stack itself, the potential performance benefit of this migration is appealing, so that alone might be worth it (although I've not run any sort of benchmarks).","Yeah, that's fair, though I still think jest needs to align with the JS language and find a way to convey that useful information with accurate stack traces.\r\n\r\nWhen I talked about avoiding the enclosing position lookup, jest *already* does not do that.  So you're not actually losing anything there.\r\n\r\nThese changes do not necessarily suppress helpful function names from appearing in stack traces.  They merely move which stack frame they appear on.\r\n\r\nFor example:\r\n\r\n```\r\nfunction it(fn) {\r\n  fn(); \/*B*\/\r\n}\r\nit(() => { \/*C*\/\r\n  throw new Error() \/*A*\/\r\n});\r\n```\r\n\r\nIn this example, we'll still see `it` in the stack trace.  But this bugfix corrects it to appear on the second stack frame instead of the third.\r\n```\r\n  at fn (line 5) \/*A*\/\r\n  at it (line 2) \/*B*\/\r\n  at <anonymous> (line 4) \/*C*\/\r\n```\r\n\r\nAnother hypothetical example: when jest says `at Object.strictEqual (__tests__\/asset-metadata-tests.js:24:17)` and when a developer knows it should say `at verifyAssetMetadataTestMacro`, there should be a stack trace *above* this one that says `at strictEqual`.  The useful info is there in the stack, just on a different (correct) frame.  Granted, I bet functions in tests are usually anonymous, they don't have descriptive names like this hypothetical.","> showing the callsite name instead of the function name -- is arguably wrong. If we change @cspotcode\/source-map-support to stop doing the wrong thing, we fix jest but diverge from node. Which I think is a good thing. But it would be nice to have a couple second opinions before I go down this route.\r\n\r\nNode's implementation is largely my best guess at what would be a good user experience. If there's consensus in a large community like Jest, that the behavior in `source-map-support` is better, I think we'd be smart to align the built-in source map support in Node.js with `source-map-support` (_tldr; perhaps you could make a patch proposing the same updates to Node's implementation?_).\r\n\r\n_aside..._\r\n\r\nI'm also pretty convinced that trying to provide [additional context](https:\/\/github.com\/nodejs\/node\/issues\/43186) , in the form of a snippet of source code, was a mistake in Node.js' `--enable-source-map` implementation. I'm pretty sure it's one of the causes of [performance issues](https:\/\/github.com\/nodejs\/node\/issues\/41541).\r\n\r\nCC: @cspotcode ","For aggressively minified code, source-mapping the callsite name *might* be better, *If* the minifier mangled the name.  But since minifiers usually don't mangle property names, that is not always true.\r\n\r\nFor un-minified code, the runtime name is likely to be best all the time.  Even when the name is changed, it'll typically be something like `foo` becomes `foo1` or `_foo`, something like that.\r\n\r\nSo that was my thinking: in the majority of cases, source-mapping callsite name is worse than using runtime name.  For minified code it's a toss-up which is better; for unminified code, the runtime name is better.\r\n\r\nAnd I was thinking specifically about the most likely use-cases.  Where we want source-mapped stack traces: testing, debugging, server-side stuff.  So minified code is not the norm.\r\n\r\nIn ts-node, the focus is unminified code, since it's TS->JS.  I suspect that's usually the focus in jest as well.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This PR was closed because it has been stalled for 30 days with no activity. Please open a new PR if the issue is still relevant, linking to this one.","This pull request has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.\nPlease note this issue tracker is not a help forum. We recommend using [StackOverflow](https:\/\/stackoverflow.com\/questions\/tagged\/jestjs) or our [discord channel](https:\/\/discord.gg\/j6FKKQQrW9) for questions."],"labels":["cla signed","Pinned"]},{"title":"[Bug]: shard option and global coverageThreshold config","body":"### Version\r\n\r\n28.0.1\r\n\r\n### Steps to reproduce\r\n\r\nRun tests with the `shard` option and have `coverageThreshold` defined in the config with some `global` values.\r\n\r\n### Expected behavior\r\n\r\nThe `global` values should only be tested against tests who ran in the given shard\r\n\r\n### Actual behavior\r\n\r\nthe `global` values are used for all tests, even those who don't run in the same shard\r\n\r\n### Additional context\r\n\r\nI'm actually not 100% sure about the right behavior to have here. But if we set some global coverage threshold, those won't be met because only a subset of tests run on each shard. All others are considered 0\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 11.6.4\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz\r\n  Binaries:\r\n    Node: 16.14.1 - ~\/.volta\/tools\/image\/node\/16.14.1\/bin\/node\r\n    npm: 8.5.0 - ~\/.volta\/tools\/image\/node\/16.14.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^28.0.1 => 28.0.1\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Ran into the same issue. I had to stop running the tests with coverage for now.","I can confirm this issue.\r\n\r\nI am using \"--shard\" to overcome the memory leak issue (#11956). However, I have to turn coverage off because the shard is not limiting the coverage. I'm not sure this can be fixed though without some changes to how Jest collects and reports coverage.\r\n\r\nNotably: the \"--shard\" option would have to output coverage to a location and then some final Jest invocation would have to combine the sharded coverage reports into one final report.\r\n\r\nAt the very least, Jest should warn about using a coverage threshold with shards.","We are facing a similar issue. It'd be great to have the possibility to run the checks of a previously-generated coverage report against the global threshold. This way we could handle the merging of all sharded coverage reports ourselves, and once we have a single file with the final results, check that it passes the global threshold.\r\n\r\nThis is still possible at the moment but we have to create a script for it ourselves.\r\n\r\nI think this would be a simple solution.","We are also facing the same issue. Even if we were able to combine the multiple reports into one, the first shard run considers all the other files (which will be tested in the next shards) as not tested. Is there any way to fix this without turning off the `coverageThreshold`? \ud83d\udcad \r\n\r\nWe found this issue referenced in the initial feature implementation and the mention of the `--includes` flag but it's not clear how that fixes the `coverageThreshold` requirement. https:\/\/github.com\/facebook\/jest\/pull\/12546#issuecomment-1068380480\r\n\r\nAny insight on this? @marionebl @SimenB \ud83d\ude4f ","Ran into the same issue. I had to stop use this features(shard). Because coverage is very important for me.","We have hit the same \"bug\" as well. We can not split unit tests via shards and have the code coverage enabled as it will look for all the files within global option instead of just the ones that were ran in the shard job. \ud83e\udd14\r\n\r\n@luke-lacroix-healthy wouldn't the command fail in the first place while generating the coverage with a `coverageThreshold.global` config set? I already see a potential problem that test cases for a single file get sharded into multiple jobs, so the file would get overriden, making the coverage wrong for that specific file if the test cases are split for that specific file? \r\n\r\nWould love to see a workaround or a solution from the jest team \ud83d\ude4f ","> We have hit the same \"bug\" as well. We can not split unit tests via shards and have the code coverage enabled as it will look for all the files within global option instead of just the ones that were ran in the shard job. \ud83e\udd14\n> \n> @luke-lacroix-healthy wouldn't the command fail in the first place while generating the coverage with a `coverageThreshold.global` config set? I already see a potential problem that test cases for a single file get sharded into multiple jobs, so the file would get overriden, making the coverage wrong for that specific file? \n> \n> Would love to see a workaround or a solution from the jest team \ud83d\ude4f \n\nMy thought is that each shards output would go into a separate folder and then combined at the end. Should work, in theory.","Thinking through this we'll have to create a 2-phase pattern to retain the original behaviour of `coverageThreshold`.\r\n\r\n1. Execute shards collecting coverage information\r\n\r\n```\r\nyarn jest --shard 1\/2 --coverage\r\nyarn jest --shard 2\/2 --coverage\r\n```\r\n\r\n2. Merge coverage information and enforce threshold\r\n\r\n```\r\nyarn jest --mergeCoverage --coverageThreshold\r\n```\r\n\r\nThere are some quality of life improvement to make, e.g. fail for certain `--shard` and `--coverage*` flag combinations with very helpful error messages. cc @SimenB - what are your thoughts on intended developer experience for this case?","Multiple runs is the only to make Jest's threshold check work.\r\n\r\nHowever, that threshold can be moved out of Jest (to e.g. coveralls or your CI) and then that could assert that the total coverage data is whatever threshold you want.\r\n\r\nI'm not sure if adding coverage merging as a separate \"mode\" is something we want in Jest. However, I don't feel strongly.","@SimenB \r\nI could be mistaken but, wouldn't that still require changes to Jest so that coverage was still collected but not reported?","@jcw- Do I get right that [jest-a-coverage-slip-detector](https:\/\/github.com\/GetJobber\/jest-a-coverage-slip-detector) is the solution to this problem?",">I could be mistaken but, wouldn't that still require changes to Jest so that coverage was still collected but not reported?\r\n\r\nYou'd remove `coverageThreshold` from Jest but still collect coverage like you do already. The responsibility of a failing status check based on coverage would be moved away from Jest itself to something that looks at all test runs collective coverage","> > I could be mistaken but, wouldn't that still require changes to Jest so that coverage was still collected but not reported?\r\n> \r\n> You'd remove `coverageThreshold` from Jest but still collect coverage like you do already. The responsibility of a failing status check based on coverage would be moved away from Jest itself to something that looks at all test runs collective coverage\r\n\r\nOk. I can test that out.","> @jcw- Do I get right that [jest-a-coverage-slip-detector](https:\/\/github.com\/GetJobber\/jest-a-coverage-slip-detector) is the solution to this problem?\r\n\r\nYes - or at least, the same strategy is. You have to collect the coverage from all shards and merge it together before you validate it against coverage targets. \r\n\r\nhttps:\/\/github.com\/GetJobber\/jest-a-coverage-slip-detector#concurrency-and-parallelism","Aside from [jest-a-coverage-slip-detector](https:\/\/github.com\/GetJobber\/jest-a-coverage-slip-detector)\r\n\r\nWhat is the alternative or the official recommendation\/guide to merge coverage files when using shard option?","> Aside from [jest-a-coverage-slip-detector](https:\/\/github.com\/GetJobber\/jest-a-coverage-slip-detector)\r\n> \r\n> What is the alternative or the official recommendation\/guide to merge coverage files when using shard option?\r\n\r\nI struggled finding an authoritative answer (but would love to see one!), but with a lot of source code reading and trial and error, landed on this approach, which uses the same underlying library as jest itself (istanbul):\r\n\r\nhttps:\/\/github.com\/GetJobber\/jest-a-coverage-slip-detector\/blob\/main\/src\/mergeCoverage.js\r\n\r\nFeel free to leverage it directly in your project, you'll just need to add three dependencies (`istanbul-lib-coverage`, `istanbul-lib-report`, `istanbul-reports`). You'll also need to generate and collect full coverage reports for each shard (not just summaries).\r\n","I was able to add coverage back into my sharded tests on Jenkins using [istanbuljs\/nyc](https:\/\/github.com\/istanbuljs\/nyc) with the following approach:\r\n\r\n1. Run sharded tests on `n` different CI executors\r\n    1. Run the sharded tests with the `--coverage` option using the `json` reporter to produce `coverage\/coverage-final.json`\r\n    2. Upload coverage from the current executor as `coverage-final-{shard_number}.json` (I used GCS)\r\n2. Merge coverage in a single CI executor after all sharded executors have completed\r\n    1. Download the coverage-final-{shard_number}.json files into `final-coverage` directory\r\n    2.  In a script, run `sed`[1] to change the path of the files in `final-coverage` to match the current executor\r\n        * nyc needs the absolute path referenced in the coverage file to calculate coverage percentages\r\n    3. execute `yarn test:ci:mergeCoverage`, `yarn test:ci:reportCoverage`, and finally `test:ci:validateCoverage` [2] in a script\r\n    \r\n\r\n[1] sed script: \r\n```\r\nfind final-coverage-files -type f -exec sed -i 's|\/path\/to\/project\/root\/on\/the\/sharded\/test\/executors|'$(pwd)'|g' {} \\;\r\n```\r\n\r\n[2] new scripts in package.json:\r\n```\r\n\"test:ci:mergeCoverage\": \"mkdir -p merged-coverage && nyc merge final-coverage-files merged-coverage\/coverage-final.json\",\r\n\"test:ci:reportCoverage\": \"nyc report --reporter=text-summary --reporter=json-summary -t merged-coverage\",\r\n\"test:ci:validateCoverage\": \"nyc check-coverage --branches 80 --functions 80 --lines 80 --statements 80 -t merged-coverage\",\r\n```","> I was able to add coverage back into my sharded tests on Jenkins using [istanbuljs\/nyc](https:\/\/github.com\/istanbuljs\/nyc) \r\n\r\nThanks for posting your approach! I wish that repo was still active, I considered using the CLI but it hasn't had any commits or releases for over two years. :(","https:\/\/github.com\/facebook\/jest\/issues\/12751#issuecomment-1314236352\r\nThis makes sense to me \r\n\r\nSince there is no activity [istanbuljs\/nyc](https:\/\/github.com\/istanbuljs\/nyc), and jest has already provided shard option, for better dev experience, it makes sense to provide `mergeCoverage`, `reportCoverage` and `validateCoverage` OOB to make shared coverage much painless.\r\n\r\n@SimenB thoughts?","I've got this mostly working locally using `nyc` to merge the coverage-final.json documents and then generate a report. However, coverage checks in nyc are only global and not based on globs. That is: I cannot specify a different set of coverage options for different sets of files.\r\n\r\nAdditionally, some of the better GitHub Actions that report Jest coverage REQUIRE the `report.json` output from Jest, which is not a format that Istanbul knows how to merge. So, aside from writing a brand new GitHub action that appropriately merges the reports, generates markdown, and generates annotations on the PR, this isn't a good solution.\r\n\r\nHaving these features directly in Jest sounds best, especially since nyc hasn't been updated in quite some time.","Are there any plans to bring coverageThreshold compatibility to shards?","This is a big problem for us. We are running our tests in shards. Once the test execution completes, Jest gets stuck in \"running coverage on untested files\" error. This is an easily reproducible error. We need to make `shard` optional and automatically collect coverage from included test files. ","Bumping this one.","Any update on this?"],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Feature]: Upstream jest-file-snapshot?","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nhttps:\/\/www.npmjs.com\/package\/jest-file-snapshot\r\n\r\nI tend to migrate my snapshots from inline to jest-file-snapshots in almost every project I write tests for (either once the snapshots become unreasonably sized for inline or there's too many). \r\n\r\nDo others have feelings about whether this library might be worth thinking about migrating into Jest itself?\r\n\r\n### Motivation\r\n\r\n It's not offensive for me to add:\r\n\r\n```ts\r\nimport { toMatchFile } from 'jest-file-snapshot';\r\n \r\nexpect.extend({ toMatchFile });\r\n``` \r\n\r\nPer each file to use the plugin\/types, but it is friction. As is ensuring that the generated files do not trigger the watcher, if the matchers were upstreamed Jest can know to watchlist ignore them.\r\n\r\n### Example\r\n\r\nN\/A\r\n\r\n### Pitch\r\n\r\nIt's ~150 LOC, so probably not a big maintenance burden and does a good job of expanding the scope of how folks can use snapshots\r\n\r\n\r\n\/cc @satya164","comments":["I'm happy to work on what's needed if we want to upstream it.","I like it! @nicolo-ribaudo would this work for the stuff you do in Babel as well? (this stuff: https:\/\/github.com\/babel\/babel\/blob\/0b9fb13cb63e4aad375f2f54524871d3b6dd9314\/packages\/babel-parser\/test\/helpers\/run-fixture-tests.js).\r\n\r\nI ask because @orta's use case sounds like just `toMatchSnapshot()` without a _huge_ benefit of separate files. But fixture tests are different","@fisker might be something for prettier tests as well?","speaking of Babel, I'd also like to mention https:\/\/github.com\/satya164\/babel-test where I used file snapshots, it was my main use case","Thanks for mentioning, looks like a good tool we can use. \ud83d\udc4d ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","Ooops, sorry. I think we wanna explore this, but I currently don't have the bandwidth ","I've been using https:\/\/github.com\/igor-dv\/jest-specific-snapshot - which sounds similar to jest-file-snapshot.\r\n\r\nIt'd be great if this type of specifying a snapshot file can be supported natively by jest.\r\n\r\nThe main use case for me is to be able to have multiple snapshot files, one for each test case, for a single test file","FWIW we've also been using `jest-specific-snapshot` in @typescript-eslint` for quite some time to do snapshots for our fixture tests.\r\n\r\nExamples:\r\n- Scope analysis fixtures: https:\/\/github.com\/typescript-eslint\/typescript-eslint\/tree\/main\/packages\/scope-manager\/tests\/fixtures\r\n- AST Parser fixtures: https:\/\/github.com\/typescript-eslint\/typescript-eslint\/tree\/main\/packages\/ast-spec\/src\/declaration\/ClassDeclaration\/fixtures\r\n- More AST parser fixtures: https:\/\/github.com\/typescript-eslint\/typescript-eslint\/tree\/main\/packages\/typescript-estree\/tests\/snapshots\r\n\r\nWe have several thousand snapshots generated in this way!\r\n\r\nIt's been a really useful way for us to do our validation testing without building out custom infra that's almost the same as snapshot diffing.","Oh, nice! Another use case for this is very nice \ud83d\udc4d \r\n\r\n---\r\n\r\nI think I'm convinced this has enough utility to be in Jest core. Anybody up for sending a PR? \ud83d\ude00  I don't have any preference between `jest-file-snapshot`, `jest-specific-snapshot` or something else (like babel's (non-Jest, but) https:\/\/github.com\/babel\/babel\/blob\/156b608d48900b9489bd31aff03189a6c18f9040\/packages\/babel-parser\/test\/helpers\/run-fixture-tests.js). But something which fits all of these use-cases would be sweet","The most complicated thing about implementing this properly in jest is keeping track of the random snapshots so you can assert that the untested ones are cleaned up properly.\n\nBecause `jest-specific-snapshot` allows you to pass any file path at all as the snapshot path - it simply cannot track the set of snapshots. Meaning you have to manually delete unnecessary snapshots.\n\nIf we can solve this concretely then it should be super simple to implement this feature natively!","This ticket feels a lot like a duplicate of the broader request at #6383. I left some thoughts on what a potential in-core implementation of `jest-file-snapshot` could evolve to at https:\/\/github.com\/jestjs\/jest\/issues\/6383#issuecomment-1652106204, but the tl;dr is that I think there's a bit more work involved to make it actually mesh nicely with Jest core than just pulling the implementation into this repo. It's fundamentally awkward to use, because Jest doesn't expect it. (Pun intended.)"],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"[Bug]: [ESM] \"ReferenceError: Export 'xxx' is not defined in module\" when mutating previously imported `node:process` from a CJS module","body":"### Version\r\n\r\n27.5.1\r\n29.3.1\r\n\r\n### Steps to reproduce\r\n\r\n1. git clone https:\/\/github.com\/Toilal\/jest-esm-process-mutate-repro\r\n2. npm install\r\n3. npm run test\r\n\r\nFailing test can be resumed to those two files:\r\n\r\n```javascript\r\n\/\/ src\/test-import-process-before.cjs.spec.js\r\nimport 'node:process'\r\nimport '.\/process-mutate.cjs'\r\n\r\nit('import node:process before cjs mutating module', () => {\r\n\r\n})\r\n```\r\n\r\n```javascript\r\n\/\/ src\/process-mutate.cjs\r\nprocess.xxx = {}\r\n```\r\n\r\n### Expected behavior\r\n\r\nJest should run properly when mutating process module, regardless import order and ESM\/CJS  import.\r\n\r\n### Actual behavior\r\n\r\nWhen running jest as ESM (with node `--experimental-vm-modules` flag) and importing (in this order) `node:process` and a\r\ncustom CJS module that adds properties to `node:process` module, jest-runtime crash with the following error\r\n\r\n```\r\nReferenceError: Export 'xxx' is not defined in module` error.\r\n```\r\n\r\n### Additional context\r\n\r\nCrash occurs here\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/a93def0e5bc938f056ada7774368f6923000d0ec\/packages\/jest-runtime\/src\/index.ts#L1645\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Linux 5.13 Ubuntu 20.04.4 LTS (Focal Fossa)\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-5930K CPU @ 3.50GHz\r\n  Binaries:\r\n    Node: 16.14.0 - ~\/.nvm\/versions\/node\/v16.14.0\/bin\/node\r\n    Yarn: 1.22.17 - ~\/.nvm\/versions\/node\/v16.14.0\/bin\/yarn\r\n    npm: 8.5.3 - ~\/.nvm\/versions\/node\/v16.14.0\/bin\/npm\r\n```\r\n","comments":["Hmm, not sure how to deal with this. Would you be up for sending a PR? Code change is in the file you linked (runtime)","Yes, i'll send a pull request, but I have to understand more deeply how `jest-runtime` and  works to solve this properly, I don't know how to deal with this too. \r\n\r\nCurrently, my workaround is this patch.\r\n\r\n```patch\r\ndiff a\/build\/index.js b\/build\/index.js\r\n--- a\/build\/index.js\r\n+++ b\/build\/index.js\r\n@@ -1785,7 +1785,15 @@ class Runtime {\r\n         this.setExport('default', required);\r\n         Object.entries(required).forEach(([key, value]) => {\r\n           \/\/ @ts-expect-error: TS doesn't know what `this` is\r\n-          this.setExport(key, value);\r\n+          try {\r\n+            this.setExport(key, value);\r\n+          } catch (error) {\r\n+            if (error.name === 'ReferenceError' && this.url === 'node:process') {\r\n+              \/\/ Ignore this error ...\r\n+            } else {\r\n+              throw error\r\n+            }\r\n+          }\r\n         });\r\n       }, \/\/ should identifier be `node:\/\/${moduleName}`?\r\n       {\r\n\r\n```","I'm sorry I still have to use this workaround (jest 29.3.1) and can't find a way to fix the issue properly.","Thank you for a really comprehensive bug report, this explains why I was hitting this error when running tests in an ESM project using [cls-hooked](https:\/\/www.npmjs.com\/package\/cls-hooked):\r\n\r\n```\r\nReferenceError: Export 'namespaces' is not defined in module\r\n    at \/lune\/backend\/node_modules\/jest-runtime\/build\/index.js:1869:16\r\n    at Array.forEach (<anonymous>)\r\n    at ModuleWrap.module.context.context (\/lune\/backend\/node_modules\/jest-runtime\/build\/index.js:1867:34)\r\n    at SyntheticModule.evaluate (node:internal\/vm\/module:226:23)\r\n    at evaluateSyntheticModule (\/lune\/backend\/node_modules\/jest-runtime\/build\/index.js:2617:16)\r\n    at ModuleWrap.<anonymous> (node:internal\/vm\/module:316:24)\r\n```\r\n\r\nedit: the actual message is more like this\r\n\r\n```\r\n        ReferenceError: Export 'namespaces' is not defined in module\r\n\r\n          at node_modules\/jest-runtime\/build\/index.js:1856:16\r\n              at Array.forEach (<anonymous>)\r\n```\r\n\r\nthe extra lines in the first log are due to me modifying jest to debug things, I think.\r\n\r\nTurns out `cls-hooked` sets `process.namespaces` (https:\/\/github.com\/Jeff-Lewis\/cls-hooked\/blob\/0ff594bf6b2edd6fb046b10b67363c3213e4726c\/context.js#L453):\r\n\r\n```\r\nprocess.namespaces = process.namespaces || {};\r\n```\r\n\r\nI'll work around this by forking `cls-hooked` and removing the assignment from there for the time being.","I also use cls-hooked in my project. Great catch :)"],"labels":[":bug: Bug","ES Modules","Pinned"]},{"title":"[Feature]: Closing stale issues and PRs automatically - do not close issues with X amount of upvotes","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nWould it be possible that the bot that closes issues automatically does not close them if they have let's say 10 upvotes?\r\n\r\n### Motivation\r\n\r\nUpvoted issues are probably wanted by many and is usually a good indication they should not be closed.\r\n\r\n### Example\r\n\r\nVS Code's triaging bot does exactly this.\r\n\r\n### Pitch\r\n\r\nUpvoted issues are wanted by the community.","comments":["cool. I like this idea.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","@SimenB would be a shame if this issue was closed as it is supposed to handle staleness issues. Any way you think this is valid, or should we close it?","Yeah, this seems reasonable. Wanna send a PR tweaking the workflow?","> Yeah, this seems reasonable. Wanna send a PR tweaking the workflow?\r\n\r\nI might give this a go! I have a heavy period of work to do now but will keep tracking this.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","hah, ironic","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Woo","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.",":("],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Feature]: Support import.meta in globalSetup\/globalTeardown","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nCurrently, the `globalSetup` and `globalTeardown` supports ESM syntax by [transpiling it to CJS before running it](https:\/\/github.com\/facebook\/jest\/blob\/main\/packages\/jest-core\/src\/runGlobalHook.ts#L49). This works well in most cases, but as the ESM standard evolves, more features are added to ESM modules that are not compatible with CJS. One of the newest features that fit into this space is the `import.meta` object, which is available in ES2020+, which does not have a \"default\" transpilation equivalent in CJS.\r\n\r\n\r\nI have taken a deep dive into the code myself, and in my head it would be possible to support global hooks with a separate Runtime. I would love to create a PR for this myself, but it would be nice with some feedback before I try going down that road. There was a mention of the whole point of `globalSetup\/globalTeardown` is that it runs before a Runtime is created in [this issue](https:\/\/github.com\/facebook\/jest\/issues\/5164#issuecomment-353731055), but what is the motivation behind this? What if we create our own Runtime just for the hooks?\r\n\r\n### Motivation\r\n\r\nCurrently, Jest runs all tests in a `Runtime`, which relies heavily on VM modules for ESM support. This makes ESM fully supported in tests, but it would be nice to have the same \"native\" support in global hooks. This way the hooks don't need to take any extra steps to be compatible with the rest of the codebase. \r\n\r\n### Example\r\n\r\nGiven the following `globalSetup.js`:\r\n```\r\nexport default async () => {\r\n  console.log(import.meta.url);\r\n};\r\n```\r\n\r\nIt should be able to run without problems. Currently the ScriptTransformer is not able to transpile `import.meta` into a sensible equivalent in CJS without involving custom Babel plugins. \r\n\r\n### Pitch\r\n\r\nESM support is growing in the community, and Jest 28 is a big step towards native ESM support. This feature is another step on the way to make ESM truly native to Jest (without transpiling to CJS)","comments":["@santi  the below setup.js is able to run on my side without involving custom Babel plugins. could you provide a repo for why `import.meta` is not work on your side?\r\n```\r\nexport default async () => {\r\n  console.log(import.meta.url);\r\n};\r\n```\r\n\r\nI made a repro repo: https:\/\/github.com\/F3n67u\/repro\/tree\/jest-esm-globalsetup","@F3n67u Sorry, I should probably have specified that this is only a problem when using TypeScript for your `globalSetup`\/`globalTeardown`. \r\n\r\nJest creates a transformer and transpiles TS in the global hooks to CJS, with no way to override the config to target output as ESM","PR welcome, not sure how to do this without Jest being run with loaders, tho","Tested `import.meta` in `testEnvironment`, getting the following error:\r\n\r\n```\r\ntest\/environment.ts:8:17 - error TS1343: The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'.\r\n```\r\n\r\nAccording to [here](https:\/\/github.com\/facebook\/jest\/blob\/fd4bfbdb1f8f7620c9da543bd68c2251bd347cdb\/packages\/jest-repl\/src\/cli\/runtime-cli.ts#L79-L81), I believe this is the same case for `testEnvironment` as well"],"labels":["Help Wanted",":rocket: Feature Request","ES Modules","Pinned"]},{"title":"[Feature]: Pass jest-diff options through jest-config to fix A11Y issues","body":"### \ud83d\ude80 Feature Proposal\r\n\r\n`jest-diff` has options for the colors in a terminal\/command-prompt (among other things):\r\n\r\n* https:\/\/github.com\/facebook\/jest\/tree\/main\/packages\/jest-diff#options\r\n\r\nThese options should be exposed to the jest-config, so end users can control these values in their project.\r\n\r\n\r\n### Motivation\r\n\r\nCurrently, the colors in every version of Jest are either broken for people with visual impairments (24.9.0 and below) or with cognitive impairments (25.0.0+). Also in 25+ there are issues on specific systems default terminals that cause issues (Windows CMD\/Powershell, ZSH, GitLab CI, IntelliJ, etc).\r\n\r\n* See: https:\/\/github.com\/facebook\/jest\/issues\/9459\r\n* See: https:\/\/github.com\/facebook\/jest\/pull\/9132\r\n\r\nPeople should be able to set their own color choices, and not be forced into a set that is incompatible with them as a human, or with their preferences via terminal, shell, theme, or tooling.\r\n\r\n\r\n### Example\r\n\r\n`jest.config.js`\r\n\r\n```js\r\nconst chalk = require('chalk');\r\n\r\nmodule.exports = {\r\n  diff: {\r\n    \/\/ The following is copied directly from https:\/\/github.com\/facebook\/jest\/tree\/main\/packages\/jest-diff#options\r\n    aAnnotation: 'Expected',\r\n    aColor: chalk.green,\r\n    aIndicator: '-',\r\n    bAnnotation: 'Received',\r\n    bColor: chalk.red,\r\n    bIndicator: '+',\r\n    changeColor: chalk.inverse,\r\n    changeLineTrailingSpaceColor: string => string,\r\n    commonColor: chalk.dim,\r\n    commonIndicator: ' ',\r\n    commonLineTrailingSpaceColor: string => string,\r\n    compareKeys: undefined,\r\n    contextLines: 5,\r\n    emptyFirstOrLastLinePlaceholder: '',\r\n    expand: true,\r\n    includeChangeCounts: false,\r\n    omitAnnotationLines: false,\r\n    patchColor: chalk.yellow\r\n  }\r\n};\r\n```\r\n\r\nBy exposing all options, it empowers communities to create their own commonly recommended settings, like so:\r\n\r\n```js\r\nconst diff = require('jest-deuteranopia-diffs');\r\nmodule.exports = { diff };\r\n```\r\n```js\r\nconst diff = require('jest-cognitive-diffs');\r\nmodule.exports = { diff };\r\n```\r\n```js\r\nconst diff = require('jest-win-cmd-diffs');\r\nmodule.exports = { diff };\r\n```\r\netc.\r\nThere could even be an `awesome-jest-diffs` with screenshots of each library, so users can more easily choose what works best for them or their teams. This could all be community-lead, but we need Jest to allow for this.\r\n\r\n\r\n### Pitch\r\n\r\nBecause humans are not all the same.\r\n\r\nBecause this software is made for humans.","comments":["> There could even be an awesome-jest-diffs with screenshots of each library, so users can more easily choose what works best for them or their teams. This could all be community-lead, but we need Jest to allow for this.\r\n> \r\n> Because humans are not all the same.\r\n> \r\n> Because this software is made for humans\r\n\r\nI like your idea. would you mind sending a pr? It will be great if you can contribute to this feature. @TheJaredWilcurt \r\n","Yeah, this is a great idea! PR very much welcome \ud83d\udc4d","As for API, I suggest extending the defaults with provided properties, e.g. `{...defaults, ...(diffOptions || {})}`, so a user does not have to provide a full set of properties (which are probably bound to change in incompatible ways).","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This wouldn't just address A11Y issues, it would also make it possible to extend or reduce the number of lines of context which can make it easier to see where problems are in certain cases.","Hi @SimenB! I\u2019ve been looking at the code to implement this issue, and we can access the 'diff options' and 'expected colors' from jest-matcher-utils\/src\/index.ts\r\n``` \r\nexport type DiffOptions = ImportDiffOptions;\r\n\r\nexport const EXPECTED_COLOR = chalk.green;\r\nexport const RECEIVED_COLOR = chalk.red;\r\nexport const INVERTED_COLOR = chalk.inverse;\r\nexport const BOLD_WEIGHT = chalk.bold;\r\nexport const DIM_COLOR = chalk.dim;\r\n```\r\nHowever, I\u2019ve been struggling to access the global config because it is not available in this file, and the other functions that have access to configs are not using the matcher utils. So I\u2019d like to know if you have any suggestions I could use to access the configs.","Good question! \ud83d\ude05 I think we can just add all the colors to `MatcherHintOptions` and then take those options into all the helpers which prints stuff? We'd need to pass those options from `expect`, but I think that can be done separately (that part seems a bit harder and probably requires more thought)","@SimenB @grazirs any update on this? I saw #13362  is still open, are you still working on it? I'm happy to help if needed.","I really want to chime in here to note that this doesn't work for me at all:\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/50332\/209990620-efd87162-9bbf-4df2-81b9-6c23dc251eec.png)\r\n\r\nI'm trying to use the information in this diff but I'm getting confused over and over again. I was pondering on whether to give up and hand this task to someone else or write tooling around `jest` that replaces the colors with the ones I'm used to. I then noticed, that I can use `--no-color` as a workaround, maybe this also helps someone else in the same situation.\r\n\r\nI have ADHD and I think in this case it makes is very hard for me to only focus on _either_ the left margin symbols (`+` and `-`) _or_ the colors. My brain unintentionally reads both parts and tries to combine them, which leads to an endless situation where my brain is in this sort of state:\r\n\r\n> ok, this green line is the \"before\" state _and also_ the \"after\" state and this red line is _also_ the \"before\" and \"after\" state at the same time???\u2026\u2026WTF \ud83e\udd2f\r\n\r\nI believe that that inverting the colors has been done with good intentions, but in my case it's a hard _no_ and very confusing and frustrating. I'm very thankful that someone here is working on resolving this!"],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"[Feature]: Allow `@jest-environment` pragma to be below other comments","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nAllow the\r\n\r\n```js\r\n\/**\r\n * @jest-environment jsdom\r\n *\/\r\n```\r\n\r\nTo not be strictly the first comment node.\r\n\r\n### Motivation\r\n\r\nDocusaurus has a very strict eslint header config that only allows:\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\/\r\n```\r\n\r\nUnfortunately, the header plugin doesn't allow optional lines yet: https:\/\/github.com\/Stuk\/eslint-plugin-header\/issues\/9 Which means we either have to add an empty line to all existing headers, so that we can have one line to accomodate the `@jest-environment jsdom`:\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n *\/\r\n\r\n\/\/ File without jsdom\r\n```\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n * @jest-environment jsdom\r\n *\/\r\n\r\n\/\/ File with jsdom\r\n```\r\n\r\nOr we resort to a super-ugly compromise of allowing extra characters on the last line:\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n * @jest-environment jsdom *\/\r\n```\r\n\r\nOr we disable the eslint rule for this file, which is definitely not desirable.\r\n\r\nOr we implement that feature in the eslint plugin, but the plugin... unfortunately seems dead.\r\n\r\nIn the end, I think this would be a useful yet (I hope) simple feature to add in Jest.\r\n\r\n### Example\r\n\r\nAllow this:\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\/\r\n\/**\r\n * @jest-environment jsdom\r\n *\/\r\n```\r\n\r\n\r\n### Pitch\r\n\r\nFlow allows the `@flow` pragma anywhere:\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\/\r\n\/**\r\n * @flow\r\n *\/\r\n```\r\n\r\n```js\r\n\/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\/\r\n\/\/ @flow\r\n```\r\n\r\nAnd I think parsing a few extra comment nodes shouldn't be technically hard...","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Mmm, no-one has ever been triaging this :\\","PR welcome! \ud83d\ude00 I think as long as the comment is connected to the first one, I think that's fine? So a random comment in the middle of a file doesn't get parses","Yeah, I think that's the idea","@SimenB Questions before I send a PR.\r\n\r\n- What's the expected semantic of the docblock? The README seems to suggest it's strictly the first comment node, and with this change it will become \"the first series of comments\". Should we only \"look ahead until we hit either a docblock with non-empty pragma directives or a non-comment\", or should we actually collect all comment nodes?\r\n- Should `docblock.extract()` return an array of docblocks, or a string with multiple docblocks concatenated, or simply the raw code string, with all empty padding lines preserved?\r\n- Should we merge the pragma from all docblocks, or should `docblock.parse()` only accept one docblock (sounds simpler IMO), and ask user to merge parse results of multiple docblocks? (Makes the most sense if we return an array of docblocks in `extract`)\r\n\r\nI'm asking these only because `jest-docblock` looks like a public API and could have larger impacts beyond jest itself","- all comment nodes up until first non-comment seems sensible to me\r\n- array seems most useful\r\n- accepting just one should be fine, yeah, mostly to not have to deal with duplicates","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Ugh, I still haven't got the time to look at it myself. I will, eventually, unless someone gets ahead of me.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83d\udc4b"],"labels":[":rocket: Feature Request","Pinned"]},{"title":"Closing stale issues and PRs automatically","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nHey! \ud83d\udc4b \r\n\r\nAs many have probably noticed, this repository has over 1500 open issues, and 150 open pull requests. I've tried in the last couple of weeks to do something about it, and while PRs have gone down from 200 (plus I've landed many new ones), the issues have been untouched. I've spot checked a few, and about half of them are no longer relevant (either due to old version of node, or just plain fixed in newer versions of Jest).\r\n\r\nAs mentioned a few times before, this project is 100% community driven, so any time spent is either taken away from work hours (which I've been guilty of the last couple of weeks \ud83d\ude05) or spare time\/weekends\/holidays. This makes it quite the chore to go through them all, and for the health of the project (and my own mental one), I think getting the number of open issues and PRs down is a good step towards making it easier to stay on top of new ones.\r\n\r\nWe've started locking old closed issues automatically, and we also have quite good issue templates that have increased the quality of both bug reports and feature requests. Both of these have helped, and I hope closing old stale issues will do the same!\r\n\r\nThat said, I understand it's frustrating to see your issue or PR you spent time putting together, and which might still be relevant, be closed as stale by some stupid bot. So feel free to provide feedback here in this issue if there's anything in the process we can improve! Just keep in mind there are unpaid humans behind this project (mostly a single human since summer), so if the solution is \"get to the issue quicker\" or \"spend more time\", that's not really scalable \ud83d\ude42 \r\n\r\nLastly, thanks for using Jest and reporting issues and sending PRs - I hope that by making the backlog more manageable the project will be easier to maintain going forward!\r\n\r\n\u2764\ufe0f\r\n\r\n---\r\n\r\nLastly, please give the alpha releases of Jest v28 a try! \ud83d\ude00 `yarn add jest@next`.","comments":["One thing I noticed immediately: The stale bot does not differentiate between types of tickets. I think feature requests should not be closed *just* because they're old. But marking them as stale might help make the decision to close them, if there wasn't much discussion or work. \r\n\r\nThis currently affects 184 tickets. Including \"Issue triage needed\" (11086) :)\r\n\r\nSimilar categories may be:\r\n\r\n- Upstream bug (4 issues)\r\n- Enhancement (6 issues)\r\n- Confirmed (10 issues)\r\n\r\nAgain: Marking those as stale may aid in evaluating the issues, but I don't think those should be remove automatically.\r\n\r\nI also think that maybe 7 days between flagging the issue and deleting it is a bit short. Go on vacation during the wrong time and the issue that still may still affect you gets closed. That's not nice. I'd bump that to 30 days.\r\n\r\n\r\nAddendum: Another thing I noticed is that there are a lot of labels for issues. Some seem less relevant and useful than others.","Issues more than a year old get 14 days, not 7. But I get what you're saying - can set them all to 30 days (messages already posted will lie I guess, but no biggie). EDIT: 3a411d19405a207216e5af5079e1e56898a7ab0e\r\n\r\nAs for marking feature requests as stale - we could maybe have a separate job for them? If there's been no activity for say 3 months, that just means nobody has the time or inclination to fix\/implement it. Keeping them around just to keep them around doesn't make a lot of sense to me?\r\n\r\n---\r\n\r\nAnd yes, we have a bunch of labels we should get rid of","Oh, and if there are specific issues you (or others) think should always be open, feel free to leave a comment here with them and I can add the `Pinned` label so they're left alone","What about the github triage permission? Stalebots have their purposes, but Jest is just a huge project and there actually are a lot of issues with it. But there are also a lot of people who would probably be willing to help clean up the mess instead of, shall we say, sweeping it under the rug.","I'm also of the opinion that jest is in some ways too large to be a monorepo, and in some ways it's still a megalith. The best thing that could happen to it is for some of its packages to become independent, use semver versioning, and have their own communities and systems of trust. They might even start getting documentation!",">  If there's been no activity for say 3 months, that just means nobody has the time or inclination to fix\/implement it. Keeping [feature requests] around just to keep them around doesn't make a lot of sense to me?\r\n\r\nAs I said, a feature request being stale is still a valid indicator to look at it again and to consider closing it. But ultimately, it should be a matter of if the feature makes sense for jest. And not whether or not someone bothered to bump it against stale-bot continuously. Some feature requests I looked over also have some valuable discussion and design work already put into them. Good example being number 7163 (\"Request to add support for CI\/CD pipelines for Test reporting).\r\n\r\nI'm also much more likely to +1 a feature request I'd like to see implemented than reopening a closed one. And maybe it's just me, but I also don't bother looking into the exact reasons why a feature request was denied - I just find it via issue search or google, see it closed and give up. \r\n\r\nAlso, just looking through some of these stale feature requests: A lot of them seem either very fringe (I'd say 7949 and 8274), are arguably out of scope (6383), or the discussion about the usefulness stalled (7090, maybe 7304), which probably why they didn't see much attention. Those can probably be closed for those reasons.","> What about the github triage permission? Stalebots have their purposes, but Jest is just a huge project and there actually are a lot of issues with it. But there are also a lot of people who would probably be willing to help clean up the mess instead of, shall we say, sweeping it under the rug.\r\n\r\nI unfortunately don't have the necessary permissions to add triagers, but that would be ideal \ud83d\ude42 But if people start to triage, even if they cannot close or add labels, that would definitely help out!\r\n\r\n> I'm also of the opinion that jest is in some ways too large to be a monorepo, and in some ways it's still a megalith. The best thing that could happen to it is for some of its packages to become independent, use semver versioning, and have their own communities and systems of trust. They might even start getting documentation!\r\n\r\nI don't disagree, but unless somebody steps up immediately (that we can trust), splitting out packages just adds _more_ work for me. Sorta chicken and egg problem, but it would exacerbate the problem I'm trying to mitigate by adding this bot.\r\n\r\nAlso, we have extensive integration tests in this repo, which is how many subtly bugs have been caught that unit tests don't pick up. You could say unit tests should be better but... more work again.\r\n\r\nThis is a big project with many moving parts, and as long as there is essentially only a single active maintainer, keeping it in one repo is IMO the only viable way of maintaining it.\r\n\r\n> > If there's been no activity for say 3 months, that just means nobody has the time or inclination to fix\/implement it. Keeping [feature requests] around just to keep them around doesn't make a lot of sense to me?\r\n> \r\n> As I said, a feature request being stale is still a valid indicator to look at it again and to consider closing it. But ultimately, it should be a matter of if the feature makes sense for jest. And not whether or not someone bothered to bump it against stale-bot continuously. Some feature requests I looked over also have some valuable discussion and design work already put into them. Good example being number 7163 (\"Request to add support for CI\/CD pipelines for Test reporting).\r\n> \r\n> I'm also much more likely to +1 a feature request I'd like to see implemented than reopening a closed one. And maybe it's just me, but I also don't bother looking into the exact reasons why a feature request was denied - I just find it via issue search or google, see it closed and give up.\r\n> \r\n> Also, just looking through some of these stale feature requests: A lot of them seem either very fringe (I'd say 7949 and 8274), are arguably out of scope (6383), or the discussion about the usefulness stalled (7090, maybe 7304), which probably why they didn't see much attention. Those can probably be closed for those reasons.\r\n\r\nYeah, I get where you're coming from, but having a bunch of open issues (valid or not) doesn't really serve any purpose I think. I will personally never look at them and it's _very_ rare they are actually picked up by someone else.\r\n\r\nHaving an enormous backlog is mentally draining, and only seeing that increase over time makes any time investment feel less worthwhile than it is.\r\n\r\nIf you want a feature into Jest, the best way will always be to contribute the code needed for it to happen. While I understand the barrier is way higher since you cannot even know if it'd be accepted, I don't know of any other way to keep the backlog relevant. Triagers as suggested above would help of course, so we're only left with high quality issues that we would want to do something about, but we'd need somebody to step up and do that job.\r\n\r\nAnd if the choice is between closing feature requests and bug reports that are valid, but nobody has had the time and\/or interest to implement and staying on top of new issues and keeping the project going, I'll choose the latter.","Yeah I know everyone makes PRs for their own little problem, but that's different than maintainership and, as you note, generally creates more work for you not less.\r\n\r\nIf the problem is that there's an incredible amount of work that only you can possibly do, then why can't we solve that problem? We are engineers, after all. So what are the barriers to adding more triagers and maintainers?\r\n\r\nFrom where I sit it looks like one big barrier is communication. It's unreasonable to expect to get help you are not asking for. Why not create and document a place to discuss direction and bring together people who are interested in the advancement of the project as a whole? I know there must be plenty of them!","Another thing would maybe to temporarily decline new feature requests so that new work isn't piled on top. Have a bit of maintenance only phase where the focus is on getting the already planned work (for the release) done and fixing known bugs.\r\n\r\nIf help with triage is welcome, I'm happy to go over the backlog and note down tickets I think can be closed and why.  Just tell me how I can go about that in a useful way.\r\n\r\nEdit: I took a couple minutes to just collect some. See this gist: https:\/\/gist.github.com\/StringEpsilon\/bd7c87f6addd26328148c5e95b0e5c37 - will update that as I find time to scroll through the backlog.","@conartist6 sure, I'd love to make that happen. Any concrete suggestions?\r\n\r\n(getting triaging permission is more about getting fb\/meta to do anything - I don't have the accesses necessary, and neither do most employees.)\r\n\r\n@StringEpsilon thank you so much, that's awesome! I'll go through tomorrow or monday. That's exactly the sort of help I'd love to have \ud83d\ude42 ","@SimenB I see only three options: facebook puts forward new owner\/maintainers, the project is forked, or the project dies.\r\n\r\nIt seems to me that you had the opportunity to become a core maintainer due to the fact that @cpojer was an active owner of the project at the time you started contributing around 2018 (see [graphs](https:\/\/github.com\/facebook\/jest\/graphs\/contributors)). I'm assuming that since active owners were reviewing your contributions, you gained their trust and eventually received privs. Unfortunately since that pathway to gaining new owners and maintainers no longer exists, it seems like you are the only thing keeping the project from being abandoned.\r\n\r\nI know this is a bit of a provocative thing to say, but I think that you should fork the project.","I cannot perceive a fork to be a good outcome for Meta, Jest contributors or the community. We are talking to Meta about actions we could take, but there is nothing new to report at this time.\r\n\r\ntbh, the way you are coming across sounds like you have a chip on your shoulder regarding Facebook more than focusing on the best outcomes for everyone.","I understand that perspective completely. And I do have a bit of a chip on my should as regards facebook, but I do not think it is relevant here.\r\n\r\nI've also spent the last two years working on tools that would make decentralized package development a reality in the npm ecosystem, something which I see the value in doing only because so many prominent open source projects have such substantial problems with trust which lead to large amounts of immensely valuable work falling on the shoulders of a few individuals.\r\n\r\nUltimately I see users being able to set up their `package.json` like this:\r\n```json\r\n{\r\n  \"devDependencies\": {\r\n    \"jest\": \"github:trustedmaintainer\/jest\"\r\n  }\r\n}\r\n```\r\n\r\nA package decentralized in this manner will be far less susceptible to permanent abandonment, and it puts front and center the real question: who do you trust? Yes, facebook's name is on jest, but anyone currently using it is essentially agreeing to trust @SimenB. If I had the option to install `github:simenb\/jest` I would indeed be immediately prompted to ask whether I trust `simenb`, and after I saw that he's written most of the lines of the code in the project, the answer would be yes.","Thanks for drafting up your proposal. I do not think this issue \u2013 nor the Jest issue tracker in general \u2013 is the right place to discuss your projects and vision for the JavaScript package management ecosystem. Let's re-center this discussion on Jest so the stakeholders of the project can work with Meta to identify a path forward. I wish you all the best on your project.","I am only describing what is possible. I am sorry, but I do not think that doing so is either irrelevant or inappropriate.","> (getting triaging permission is more about getting fb\/meta to do anything - I don't have the accesses necessary, and neither do most employees.)\r\n\r\nLet me look into it on Monday. It should be possible, we\u2019ve done it for other repos.","@vjeux Thank you for doing that.\r\n\r\nI know I am stirring the pot here, but I really have only gratitude for the people who have invested their time and energy in this project, and I'd be more than happy to see meta step forwards and provide better support.\r\n\r\nThat said, I'd love to see the process of engaging with the project's owners\/governance (to confirm, that is the Meta OSS organization?) play out publicly! Meta benefits greatly from the investment the community has made in this project, so I would hope that they could be something other than a complete black box to the non-meta-employee community.","I have sent the following message to opensource@fb.com, subject line: Jest\r\n\r\n> To whom it may concern,\r\n> \r\n> I am writing to formally request that you publicly name an administrative owner and\/or a community point of contact for the jest open source project. I am aware that I am in essence asking you to spend money on this project, and that it is likely one which is no longer of strategic importance to Meta. The project is of strategic importance to the community though, and the community is chomping at the bit to help develop and maintain it. Its chief competitors are nowhere close to its functionality or ease of use.\r\n>\r\n> I am aware that your organization is primarily set up to export open source software, but in this case you are already in the position of relying heavily on a project which the community maintains for you. The community provides you great value in its [work], but its efforts are also greatly hampered by the complete silence of the project's owners. I implore you to invest even a little in governance of this project to guide the community towards unlocking the potential it has. I have \"carbon-copied\" this message to [a thread on the jest issue tracker](https:\/\/github.com\/facebook\/jest\/issues\/12496), and would appreciate a response there.\r\n> \r\n> Regards,\r\n> Conrad\r\n\r\nEdit: missing [work]\r\n\r\n","> I am writing to formally request that you publicly name an administrative owner and\/or a community point of contact for the jest open source project.\r\n\r\n@conartist6 this exists, it is me. Thanks for pushing this, the core maintainers are fully able to handle it. I'm going to lock this as too heated, but thanks again for your perspective.","I just wanted to give an update. As a follow-up of this thread, we've concretized the plan to move Jest to a foundation which just materialized today. Hopefully this new structure will help with the challenges mentioned here. https:\/\/engineering.fb.com\/2022\/05\/11\/open-source\/jest-openjs-foundation\/"],"labels":["Infrastructure :hammer_and_wrench:","Pinned"]},{"title":"Upgrade from source-map 0.6.1 to @cspotcode\/source-map-consumer 0.8.0","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nImplements #12485.  I talked about the potential motivation there.  Submitting this pull request makes it possible for a maintainer to run the full test matrix, if they want to.\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\nThis code change will be valid if automated tests pass.\r\n","comments":["Most of this PR has conflicts due to #12692. Only the e2e test that we'd want to do this in, I think?","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","wat, `Pinned` label is here??","This PR is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83e\udd14 "],"labels":["cla signed","Pinned"]},{"title":"[Feature]: upgrade source-map to @cspotcode\/source-map","body":"### \ud83d\ude80 Feature Proposal\n\nIs there any interest in upgrading from `source-map` to `@cspotcode\/source-map`?  If so, I can attempt a pull request to see if all the tests pass.\n\n### Motivation\n\nI see it mentioned in a few places that jest is blocked from upgrading past source-map 0.6.1.\r\n\r\nhttps:\/\/github.com\/mozilla\/source-map\/issues\/331#issuecomment-385881122\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/199f9811ae68b15879cbe18b7ef7ebd61eefcf23\/packages\/jest-transform\/src\/types.ts#L29\r\n\r\n`@cspotcode\/source-map` has a sync API but the improved WASM-enabled performance of newer `source-map`.\n\n### Example\n\n_No response_\n\n### Pitch\n\nIt would improve performance.  By how much, I'm not sure.","comments":["I ran the tests locally, but not the mercurial tests, since it seems like they are always failing: https:\/\/github.com\/facebook\/jest\/issues\/8653\r\n\r\nThey are passing, so I submitted #12486 to allow you to run the full test suite if you want.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Happy to test this out after https:\/\/github.com\/cspotcode\/node-source-map-support\/issues\/37 lands \ud83d\udc4d ","Or rather, migrate to using `@cspotcode\/source-map-support`","Oh I thought this was superceded by the switch to trace-mapping.\r\n\r\nDoes jest use source-map-support, which hooks the node runtime to rewrite\r\nstack traces?  I thought it only used source-map -- now trace-mapping --\r\nthe underlying sourcemap library.  Boy these names can get confusing.\r\n\r\nEDIT: Nevermind, now I remember we've talked about this and it *is* used.  I guess I'm becoming forgetful.\r\n\r\nI hopefully have time for this over the weekend.\r\n\r\nOn Thu, Apr 21, 2022, 6:55 AM Simen Bekkhus ***@***.***>\r\nwrote:\r\n\r\n> Or rather, migrate to using @cspotcode\/source-map-support\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https:\/\/github.com\/facebook\/jest\/issues\/12485#issuecomment-1105055447>,\r\n> or unsubscribe\r\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AAC35OATGQEANCK54AKG7W3VGEX3PANCNFSM5PGGJEPA>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n","Yep, that sounds right \ud83d\ude00","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","I have been experiencing [this issue](https:\/\/github.com\/mozilla\/source-map\/issues\/243) on larger code bases.\r\nIt is not consistent but when it does come up most PR are blocked until some other changes allows it to succeed."],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Bug]: Using --outputFile --json suppresses CLI coverage output","body":"### Version\r\n\r\n27.5.1\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone https:\/\/github.com\/wilhen01\/jest-outputfile-bug-repro\r\n2. `npm install`\r\n3. `npm run test-outputfile` to see output using --outputFile --json\r\n4. `npm run test-no-outputfile` to see output without those flags\r\n\r\n### Expected behavior\r\n\r\nWith code coverage configured. via `jest.config.js` I would expect to see CLI coverage output, regardless of the use of `--outputFile --json`\r\n\r\ne.g.\r\n\r\n```\r\n PASS  test\/hello.test.ts\r\n  hello world function\r\n    \u2713 returns the correct string (1 ms)\r\n\r\n----------|---------|----------|---------|---------|-------------------\r\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\r\n----------|---------|----------|---------|---------|-------------------\r\nAll files |     100 |      100 |     100 |     100 |\r\n index.ts |     100 |      100 |     100 |     100 |\r\n----------|---------|----------|---------|---------|-------------------\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        1.83 s, estimated 2 s\r\nRan all test suites.\r\n```\r\n\r\n### Actual behavior\r\n\r\nWhen using `--outputFile --json` the CLI coverage output is suppressed. Regular test output on the command line remains.\r\n\r\ne.g.\r\n\r\n```\r\n\u276f npm run test-outputfile\r\n\r\n> jest-outputfile-bug-repro@1.0.0 test-outputfile\r\n> jest --outputFile test-results.json --json\r\n\r\n PASS  test\/hello.test.ts\r\n  hello world function\r\n    \u2713 returns the correct string (1 ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        1.935 s, estimated 3 s\r\nRan all test suites.\r\nTest results written to: test-results.json\r\n```\r\n\r\n### Additional context\r\n\r\n_No response_\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: macOS 12.2\r\n    CPU: (10) x64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 14.19.0 - ~\/.nvm\/versions\/node\/v14.19.0\/bin\/node\r\n    npm: 8.5.0 - ~\/.nvm\/versions\/node\/v14.19.0\/bin\/npm\r\n  npmPackages:\r\n    jest: latest => 27.5.1\r\n```\r\n","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This is a really small but annoying issue for us as well. There should be an easy way to get the test json output while having the nice CLI coverage during CI.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump. ","+1 for this question, Similar problem: https:\/\/github.com\/facebook\/jest\/issues\/10914","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bump","+1 for this question","Outstanding since 2017, closed by bot\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/2927","Not a fix, but a practical workaround: instead of using `--json --outputFile`, install a json-outputting reporter.  The summary box is not supplanted by other reporters.\r\n\r\nI'm using [`jest-json-reporter2`](https:\/\/www.npmjs.com\/package\/jest-json-reporter2).\r\n","Thanks for the tip @StoneCypher. Does `jest-json-reporter2` use the same output format as `--json --outputFile`? \r\n\r\nWe're using the output file with DangerJS to show unit test results in our PRs, so it's only a good workaround for us if the format is the same. ","Reporter2 has a short output and a long output.  The short output is some simple summary statistics.  For my project, the long output was 1.5 meg, and I didn't feel like digging through it.  I honestly have no idea.","Cool, thanks, I'll have a play when I get a chance \ud83d\udc4d ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump. I'd still like this fixed...","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale.  Again.\r\n\r\n","There is #12536 fwiw","While the PR is not merged, an workarround to get the same file can be:\r\n```\r\njest --coverage --testResultsProcessor=my-results-processor.js\r\n```\r\n\r\nmy-results-processor.js\r\n```js\r\nconst { writeFileSync } = require('fs')\r\nconst { join } = require('path')\r\nconst { formatTestResults } = require('@jest\/test-result')\r\n\r\nmodule.exports = (testResults) => \r\n  writeFileSync(\r\n    join(process.cwd(), 'coverage', 'my-result.json'),\r\n    JSON.stringify(formatTestResults(testResults))\r\n  )\r\n\r\n  return testResults\r\n}\r\n```\r\n"],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"[Feature]: Replace `@types\/jest`'s `expect` implementation with `@jest\/expect`","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nPeople might not want to use the globals (`expect`, `test` etc.) Jest provides (either because of ESM or just a preference). And because Jest is written in TypeScript, when doing e.g. `import {expect} from '@jest\/globals'` all built in matchers are typed. However, if you use some matchers from the community (such as `jest-extended`), they augment the matchers from `@types\/jest` instead of `expect` (or `@jest\/expect`). If instead all libraries augmented the actual `expect` types, the imported matcher would be typed correctly.\r\n\r\nHowever, this flips the problem - now people using the globals no longer get custom matchers typed! The solution to this problem is to make `@jest\/types` use `@jest\/expect` instead of shipping its own types for this.\r\n\r\nThis issue is for tracking the work that needs to be done before releasing Jest 28 stable so there's a single source of truth - the source code.\r\n\r\n---\r\n\r\nI have started: https:\/\/github.com\/SimenB\/DefinitelyTyped\/tree\/jest-expect\r\n\r\nWe need to make sure the tests pass. Most breakage is due to the tests using e.g. `jest.InverseMatchers` etc - I don't think that's super useful? I might be wrong though, in which case we should expose more of those types from `expect` and\/or `@jest\/expect`.\r\n\r\n~(note that running tests is \"impossible\" until https:\/\/github.com\/microsoft\/DefinitelyTyped-tools\/pull\/411 is merged. I ran `npm install` manually inside `types\/jest` to see errors in the tests in my IDE)~\r\n\r\n\/cc @mrazauskas","comments":["Very good move. What I was playing with roughly looked like this:\r\n\r\n1. Types of all globals are exported from `'jest'` (instead of `'@jest\/globals'`)\r\n2. `index.d.ts` inside `'@types\/jest'`:\r\n\r\n```ts\r\ndeclare const jest: import('jest').Jest;\r\n\r\ndeclare const beforeAll: import('jest').TestFrameworkGlobals['beforeAll'];\r\ndeclare const beforeEach: import('jest').TestFrameworkGlobals['beforeEach'];\r\n\r\ndeclare const afterAll: import('jest').TestFrameworkGlobals['afterAll'];\r\ndeclare const afterEach: import('jest').TestFrameworkGlobals['afterEach'];\r\n\r\ndeclare const describe: import('jest').TestFrameworkGlobals['describe'];\r\ndeclare const fdescribe: import('jest').TestFrameworkGlobals['fdescribe'];\r\ndeclare const xdescribe: import('jest').TestFrameworkGlobals['xdescribe'];\r\n\r\ndeclare const test: import('jest').TestFrameworkGlobals['test'];\r\ndeclare const xtest: import('jest').TestFrameworkGlobals['xtest'];\r\n\r\ndeclare const it: import('jest').TestFrameworkGlobals['it'];\r\ndeclare const fit: import('jest').TestFrameworkGlobals['fit'];\r\ndeclare const xit: import('jest').TestFrameworkGlobals['xit'];\r\n\r\ndeclare const expect: import('jest').JestExpect;\r\n```\r\n\r\n3. `package.json` inside `'@types\/jest'`:\r\n\r\n```json\r\n\"version\": \"28.0.0\",\r\n\"peerDependencies\": {\r\n    \"jest\": \"^28.0.0\",\r\n  }\r\n```\r\n\r\nThe idea was to turn `'jest'` into the single source of truth. There is no way using Jest without installing `'jest'`, but it is possible to install different versions of `'jest'`, `'@jest\/globals'` and `'@types\/jest'`.\r\n\r\nSo importing `import {expect, jest} from 'jest'` or augmenting through `'@types\/jest'` should reference same type definition which are installed with that particular version of Jest.\r\n\r\nMight be there is still a chance that something would drift, or overlap, or go wrong. What you think? (;","Yeah, that's essentially what https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/pull\/44365 does, and is what I want as end state. However, that loses a bunch of `jest.Thing` helpers, so not sure if it's the right move at this moment.\r\n\r\nI'd like to start with just replacing parts of `@types\/jest`, then if that works it can be \"global only\". And I'd like to start with `expect` since that's what custom matchers integrate with. \ud83d\ude42 ","Perhaps we could try it out with some `@types\/jest-28-alpha`? It just augments globals. Should work. Or?\r\n\r\nI was playing `jest.Thing` helpers as well. Very easy to have them (;","\r\nCouldn\u2019t recall in which of branches I had them. Something like this seems to be working (importing from current exports):\r\n\r\n```ts\r\ndeclare const jest: import('@jest\/environment').Jest;\r\n\r\ndeclare namespace jest {\r\n  export type MockedFunction<T> = import('jest-mock').MockedFunction<T>;\r\n  export type MockedClass<T> = import('jest-mock').MockedClass<T>;\r\n  \/\/ ...\r\n}\r\n```","Ah nice, that'd be awesome. Would also be cool if we had the same in Jest \ud83d\ude42\n\nWe should probably port over the type tests in DefinitivelyTyped to this repo well","For anyone following along, we've replace our own usage of `@types\/jest` with the types exported from `@jest\/globals` and an extra package sticking Jest's globals into TS's globals: #13344.\r\n\r\nI'd still love for `@types\/jest` to work with `@jest\/expect`, but that might just be https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/pull\/62037 or something like it instead of having steps on the way","@SimenB I think I stumbled on this issue since I want to make `jest-extended` to work with `@jest\/globals`. With this change, does it mean we can do some updates to https:\/\/github.com\/jest-community\/jest-extended\/blob\/main\/types\/index.d.ts and `jest-extended` would work nicely with `@jest\/globals`?","If this issue is resolved, yes \ud83d\ude42  As of now `@types\/jest` doesn't get its matchers from `expect`","This ticket is just like how I like a good bbq... low n slow...","Actually there is no need to have `@types\/jest` and to use it for re-exports. TypeScript picks up types from the following declaration in `package.json`:\r\n\r\n```json\r\n{\r\n  \"devDependencies\": {\r\n    \"@types\/jest\": \"npm:@jest\/test-globals@*\"\r\n  }\r\n}\r\n```\r\n\r\nAt the moment `@jest\/test-globals` is private and it needs better name too. But in general I find this solution simple and even obvious. Well.. That\u2019s rather a discovery for me, to be honest ;D","@SimenB What you think about the above idea?\r\n\r\nI was thinking `@jest\/test-globals` could be simply published as `@jest\/globals`. In this case, current exports of  `@jest\/globals` should be moved to `jest`.\r\n\r\nAnd `package.json` looks like this:\r\n\r\n```json\r\n{\r\n  \"devDependencies\": {\r\n    \"@types\/jest\": \"npm:@jest\/globals@*\"\r\n  }\r\n}\r\n```\r\n\r\nAh.. Of course, `@types\/jest` gets deprecated. The end (;\r\n\r\n---\r\n\r\nHere is somewhat similar solution I tried to put together: https:\/\/github.com\/mattphillips\/jest-expect-message\/pull\/70","`jest-runtime` depends on `@jest\/globals`, so we'd end up polluting the global namespace by default, which I wanna avoid.\r\n\r\nBut if we could end up exporting the globals from the `jest` package, that'd be cool","Right... Now I recall that we already talked about this in #12411","If we started publishing `@jest\/test-globals` - would `@types\/jest` be able to just import that and have the global environment augmented?\r\n\r\nWe're still missing some types etc., but easy enough to add any missing later","Importing `@jest\/test-globals` into `@types\/jest` is interesting idea, but it felt clumsy. This is because other `@types` libraries depend on `@types\/jest`. The change is breaking for them.\r\n\r\nIn a way they should publish major releases. Does that mean that those libraries should also bump their majors? Will everyone agree? For instance, some `@types\/x-jest` is referencing `@types\/jest`. It supports Jest 27 and up. Reexported `@jest\/test-globals` types means they have to give up supporting Jest 27 (or not)?\r\n\r\nMight be I am overthinking. In any case, it sounded that:\r\n\r\n```json\r\n\"devDependencies\": {\r\n  \"@types\/jest\": \"npm:@jest\/test-globals@*\"\r\n}\r\n```\r\n\r\nis a solution to provide global typings without even touching `@types\/jest` package. This way `@types\/x-jest` can choose to support `@jest\/test-globals` at any time they find it comfortable.","Hmm, yeah. Good question.\r\n\r\nIs it breaking in a way that we should fix? I guess we could also set the version in the deps of the packages that depend on `@types\/jest`?\r\n\r\nOr if the other packages on DT only e.g. add new matchers, they'd ideally extend `expect` types directly (much of what this issue is about). Then the other types from `@types\/jest` can still live there, but new matchers work regardless of where they're coming from.","Hm.. if I get it right, the dependency on another `@types` package is set through `\/\/\/ <reference types=\"...\" \/>` directive. Those are not versioned. Might be that is limitation of DT. Also can be I missed something.\r\n\r\nA real case is here: https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/tree\/master\/types\/heft-jest\r\n\r\nHere `jest.mocked()` is added through a `@types` package to avoid importing it from `ts-jest`.\r\n\r\nThe `jest.mocked()` which ships with Jest has different signature. Hence switching to the build-in Jest types is breaking. I opened https:\/\/github.com\/microsoft\/rushstack\/issues\/3609 to find a solution, but there is no progress for a year."],"labels":["Help Wanted",":rocket: Feature Request","TypeScript","Pinned"]},{"title":"[Feature]: Detect unused stubs in test code","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nAs described in [this article](https:\/\/www.baeldung.com\/mockito-unnecessary-stubbing-exception), JUnit and Mockito support detecting unnecessary stubs and tell the user to remove them. It would be great to have that feature in Jest.\r\n\r\n### Motivation\r\n\r\nRemoving unused stubs makes the test code cleaner and more maintainable. \r\n\r\n### Example\r\n\r\n_No response_\r\n\r\n### Pitch\r\n\r\nRemoving unused stubs makes the test code cleaner and more maintainable. This leads to users writing cleaner and more delightful tests and prevents certain errors from happening when users expect their stubs to be responsible for a specific behavior when actually they have never been called.","comments":["I like this idea! Happy to take a PR implementing it \ud83d\ude42 ","I am new to jest source code. May i contribute to this feature?","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","hi. bot. could you please keep this issue for me?","Still waiting for a way to find unused mocks.","Should we only consider not-called as unused? If we assert that a mock _wasn't_ called, it'd also be used right?","To me, mock is unused if it matches these 2 cases:\r\n - It was never called during any tests.\r\n - It was never `expected`(including not cases) in any tests.\r\n\r\nFor first case, it can only be tested after the test has run(I prefer this because we can show used mock as warnings at end of test) or if we do some kind of dynamic analysis on the source file.\r\nFor second case, it's a static analysis of the test file so combining this data at end of test run should be fine.","I agree completely in terms of an ideal solution.\r\n\r\n> It was never **expected**(including not cases) in any tests.\r\n\r\nThis would be ideal. But, if we expand it to include any access of the mock state, without tracking if whatever accessed eventually ended up in an assertion, it gets really easy to implements. Not perfect though with the chance of false negatives i.e. assigning to unused variables. It's a tradeoff of effort\/complexity and accuracy. \r\n\r\nI haven't decided how I feel about implementing something at the level of static analysis, so would tracking the mock state, with its risks, be good enough? ","+1 Would love this feature as well. "],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"[Bug]: `Worker` class of `jest-worker` does not support ESM worker modules","body":"### Version\n\nv27.4.7\n\n### Steps to reproduce\n\nAn exception is raised, if I try to initialise a worker with an ESM module: `new Worker('path\/to\/ESMworker.mjs')`. Looks like `jest-worker` is simply trying to `require` the module and that does not work:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d1bc333c549ffb53691e1ba68b16a21915fc5fdc\/packages\/jest-worker\/src\/workers\/processChild.ts#L113-L114\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d1bc333c549ffb53691e1ba68b16a21915fc5fdc\/packages\/jest-worker\/src\/workers\/processChild.ts#L96-L97\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d1bc333c549ffb53691e1ba68b16a21915fc5fdc\/packages\/jest-worker\/src\/index.ts#L32-L33\r\n\r\nI was trying to refactor the code using the `requireOrImportModule` from `jest-utils`. Unfortunately the private method `this._bindExposedWorkerMethods()` of the `Worker` class has to become async, but it is called in the constructor. Async calls are not possible in constructors.\r\n\r\nGood news: `Worker` is a named export. If I get it right, this makes it possible to export something else from `jest-worker`. So perhaps an asynchronous `createWorker()` factory function could be a non-breaking solution?\r\n\r\n```js\r\nimport {createWorker} from 'jest-worker';\r\n\r\nconst workerPath = new URL('.\/testWorker.js', import.meta.url).pathname;\r\n\r\nconst worker = await createWorker(workerPath);\r\n```\r\n\r\n@SimenB Does it look acceptable for you? Feels like I could solve it this way.\n\n### Expected behavior\n\nWould be great to support ESM worker modules in `jest-worker` package.\n\n### Actual behavior\n\n`jest-worker` package does not support ESM worker modules.\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 10.15.7\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-3615QM CPU @ 2.30GHz\r\nBinaries:\r\n    Node: 17.3.1 - ~\/.nvm\/versions\/node\/v17.3.1\/bin\/node\r\n    Yarn: 2.4.3 - \/usr\/local\/opt\/node@16\/bin\/yarn\r\n    npm: 8.3.0 - ~\/.nvm\/versions\/node\/v17.3.1\/bin\/npm\r\nnpmPackages:\r\n    jest: workspace:* => 27.4.7\n```\n","comments":["@SimenB Would it be possible to include this issue in Jest 28 milestone? I really need it for one work-in-progress test runner (;\r\n\r\nMight be there is better solution, but it seemed like having async `createWorker('path\/toWorker')` factory instead of `new Worker('path\/toWorker')` would be enough. Perhaps this breaking change could be introduced now and the real ESM support could be implemented later.\r\n\r\nThe problem is that constructor of the class cannot be asynchronous. Async `createWorker()` makes it possible to `await import()` the worker module in order to detect exported methods.",">@SimenB Does it look acceptable for you? Feels like I could solve it this way.\r\n\r\nyes! factory pattern is how we've solved other \"class does `require` in constructor, we need `await import`\"","@mrazauskas wanna send a PR for this one? \ud83d\ude42 ","Yes, I would love to. Next week (;","yay!"],"labels":[":rocket: Feature Request"]},{"title":"[Feature]: Improved console.* usability when focusing a test","body":"### \ud83d\ude80 Feature Proposal\n\nMake `console.*` more useful when focusing on a single test by either:\r\n1. Allowing to not print the test names of skipped tests (and related information such as obsolete snapshots)\r\n2. Moving `console.*` calls below the test summary\n\n### Motivation\n\nEspecially in large test suites I usually focus on a single test when working on a bug\/feature. In some cases (e.g. new codebase, simple debugging instructions) I prefer to use `console.*` methods.\r\n\r\nHowever, Jest currently displays them before the test summary which means I have to constantly scroll back up or, even worse, in the case of test failures I have to scroll between bottom (for the failure) and top (for the log).\n\n### Example\n\nIn the [React codebase (51947a14bb24bd151f76f6fc0acdbbc404de13f7)](https:\/\/github.com\/facebook\/react\/tree\/51947a14bb24bd151f76f6fc0acdbbc404de13f7) with \r\n```diff\r\ndiff --git a\/packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js b\/packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js\r\nindex 435e90d9b1..cce594175c 100644\r\n--- a\/packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js\r\n+++ b\/packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js\r\n@@ -126,6 +126,8 @@ describe('ReactDOMServerSelectiveHydration', () => {\r\n   });\r\n \r\n   it('hydrates the target boundary synchronously during a click', async () => {\r\n+    console.log(1)\r\n+    throw new Error()\r\n     function Child({text}) {\r\n       Scheduler.unstable_yieldValue(text);\r\n       return (\r\n```\r\n\r\n```bash\r\n$ yarn test ReactDOMServerSelectiveHydration --watch --testNamePattern 'hydrates the target boundary synchronously during a click'\r\nconsole.log\r\n    1\r\n\r\n      at Object.<anonymous> (packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js:129:13)\r\n\r\n FAIL  packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js\r\n  ReactDOMServerSelectiveHydration\r\n    \u2715 hydrates the target boundary synchronously during a click (99 ms)\r\n    \u2713 hydrates the target boundary synchronously during a click (createEventHandle) (50 ms)\r\n    \u25cb skipped hydrates at higher pri if sync did not work first time\r\n    \u25cb skipped hydrates at higher pri for secondary discrete events\r\n    \u25cb skipped hydrates at higher pri if sync did not work first time (createEventHandle)\r\n    \u25cb skipped hydrates at higher pri for secondary discrete events (createEventHandle)\r\n    \u25cb skipped hydrates the hovered targets as higher priority for continuous events\r\n    \u25cb skipped replays capture phase for continuous events and respects stopPropagation\r\n    \u25cb skipped replays event with null target when tree is dismounted\r\n    \u25cb skipped hydrates the last target path first for continuous events\r\n    \u25cb skipped hydrates the last explicitly hydrated target at higher priority\r\n    \u25cb skipped hydrates before an update even if hydration moves away from it\r\n    \u25cb skipped fires capture event handlers and native events if content is hydratable during discrete event\r\n    \u25cb skipped does not propagate discrete event if it cannot be synchronously hydrated\r\n    can handle replaying events as part of multiple instances of React\r\n      \u25cb skipped Inner hydrates first then Outer\r\n      \u25cb skipped Outer hydrates first then Inner\r\n\r\n  \u25cf ReactDOMServerSelectiveHydration \u203a hydrates the target boundary synchronously during a click\r\n\r\n\r\n\r\n      128 |   it('hydrates the target boundary synchronously during a click', async () => {\r\n      129 |     console.log(1)\r\n    > 130 |     throw new Error()\r\n          |           ^\r\n      131 |     function Child({text}) {\r\n      132 |       Scheduler.unstable_yieldValue(text);\r\n      133 |       return (\r\n\r\n      at Object.<anonymous> (packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js:130:11)\r\n      at asyncGeneratorStep (packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js:12:310)\r\n      at _next (packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js:12:648)\r\n      at packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js:12:813\r\n      at Object.<anonymous> (packages\/react-dom\/src\/__tests__\/ReactDOMServerSelectiveHydration-test.internal.js:12:554)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 14 skipped, 1 passed, 16 total\r\nSnapshots:   0 total\r\nTime:        0.844 s\r\n```\r\n\r\nNotice the, in my opinion, wasted space by the list of skipped tests. \r\n\r\nRelated issues: https:\/\/github.com\/facebook\/jest\/issues\/2169\r\n\n\n### Pitch\n\nThe current behavior encourages small test files or straight up not focusing on a single test. However, iteration speed for debugging is very important so people may be hesitant to add more tests due to Jest becoming harder to read when focusing on a single test.","comments":["This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 7 days.","Comment","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Comment","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bump","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","bump","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Comment","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","42","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue that needs attention -- the displayed order of console.log messages is a real pain when working with Jest output. \r\nWhy no response from the maintainers?","This sounds like it can just be a custom reporter. Or possibly configuration for the built in reporters?"],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Bug]: 0 is not considered equal to -0?","body":"### Version\n\n27.4.7\n\n### Steps to reproduce\n\n```javascript\r\nit(`these are the same. No really `, () => {\r\n  expect(0 === -0).toBe(true); \r\n  expect(0).toBe(-0);\r\n})\r\n```\r\n\r\nFirst test passes, because it should. Second test fails. It very much should not.\n\n### Expected behavior\n\nBy both maths and JS spec definition, 0 is equal to -0\n\n### Actual behavior\n\n```\r\n    Expected: -0\r\n    Received: 0\r\n\r\n       7 |   it(`these are the same. No really `, () => {\r\n       8 |     expect(0 === -0).toBe(true);\r\n    >  9 |     expect(0).toBe(-0);\r\n         |               ^\r\n      10 |   })\r\n```\n\n### Additional context\n\nFloating point numbers result in hilarious edge cases.\n\n### Environment\n\n```shell\nWin 10 Pro x64, Node v17.3.0, Jest v27.4.7\n```\n","comments":["This is by design, we use [`Object.is`](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/is). That said, I _might_ be convinced that `toEqual` should report them as the same, but we have an explicit test today that they're not: https:\/\/github.com\/facebook\/jest\/blob\/5cd75f4e0b9f8b678fedee268676864013b12d81\/packages\/expect\/src\/__tests__\/matchers.test.js#L452\r\n\r\n@thymikee @cpojer thoughts?","Given that I'm running into this as part of a maths library tests, 0 and -0 kind of need to be the same thing. The direction by which we arrive at zero is not part of the numerical equality. It's why `0 === -0` is true as per the JS language spec (ref: https:\/\/262.ecma-international.org\/6.0\/#sec-strict-equality-comparison, 7.2.13 step 4, points `d` and `e`) even if in the IEEE 754 spec the values +0 and -0 are provisioned as different bit patterns.\r\n\r\nUsing `Object.is` in this case gives you the wrong result because while theyre different _internal_ values to JS (because otherwise it wouldn't be able to show 0 vs. -0) the JS spec says they're the same value in actual code. As such, treating them as not equal is quite literally a spec violation.\r\n\r\nOf course, if a `toStrictEqual` or the like goes \"hey these are different IEEE values\" that makes a lot of sense, and even a maths library might benefit from that (e.g. to determine limiting behaviour) but the plain `equals`\/`toBe` should most definitely say \"yes, these are the same value\".","What about a custom `.toBeMathematicallyEqual` matcher? If `.toBe` matcher does not suite your project, why not to create a custom one?\r\n\r\nJust an idea. I am not tying to argue (;","@Pomax What you're saying does seem to make sense.. Are you implying then that the implementation of `Object.is` is incorrect? Or just saying that `Object.is` is not the correct function to use for the `.toBe` matcher?","Good clarification question: using `Object.is` is in this case incorrect. For primitives, JS's strict equality (`===`) should be the authority on what is, and is not, \"the same thing\". (Except for values that the spec clearly indicates as never yielding true under `===` comparison, like NaN, Infinity, etc). `Object.is` is a low level mechanism for checking whether things are effectively pointers to the same data in memory (in this case, the standard library value table), which is too low level for testing user code (rather than testing whether an implementation of the JS interpreter itself is doing the right thing).\r\n\r\nI haven't dug into the code to see how many things rely on `Object.is` but I would say that `toBe` should be based on `===`, since it's for use with primitives, with `equals` based on arbitrarily deep object comparison. The `Object.is` comparison should only be used as part of the code for `toStrictEqual`.\r\n","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 7 days.","This issue should probably not go stale.","I have no problem keeping the `Object.is` behavior with its 0 vs -0 inequality for` toBe`. Since `5\/-0` is `-Infinity` while `5\/0` is `Infinity`, the difference has implications that should be respected.\r\n\r\nThat being said, I think there very much needs to be some option to use `===` in toEqual, whether an additional parameter or an additional version of the matcher. Right now I'm testing a function that creates an array of numbers in which 0 and -0 need to be treated as equal, and the function could produce either depending on circumstances. \r\n\r\nIt's really pretty awkward to have to figure out case by case whether I need to expect, for example, `.toEqual([-3, -2, -1, 0, 1, 2])` or `.toEqual([-3, -2, -1, -0, 1, 2])` when the two are functionally equivalent for my use. And a subtle change to the function or inputs could start breaking tests that would be perfectly robust if I could just allow 0 and -0 to be compared with `===`.  ","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","obligatory \"it would be nice to solve this\" comment to prevent the stalebot from sniping this issue.","This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 30 days.","And again.","Any updates on this?","Have you tried `expect(0).toBeCloseTo(-0);`? It may work.","It may, but \"very close to zero\" and \"zero\" are wildly different things.\r\n\r\nAlso as a remark on an earlier comment that asserted that 5\/0 yields Infinity and 5\/-0 yields -Infinity: while true, the language itself specifies that 0 _is strictly equal to_ -0 and running `0 === -0` (not just `0 == -0`) must evaluate to true, or you're not implementing JS (or JS testing). \r\n\r\nSo: if you need to know whether the effect of a statement involving a possibly negative zero is some specific value, you run the statement and test the result. That's not an argument for what tests on zero itself do.\r\n\r\nIn this case using `Object.is` does something so close to what it's being used for that it feels like it does the thing it's being used for, but it's not. It checks whether two things point to the same items on the heap. The problem with that is that Number is special, and there are different bit patterns, with different heap values, that by spec-definition must be considered the same value in isolation. Zero and negative zero are the same value, even if statements involving them yield different results depending on that sign.","A solution may be: \n\n```\nconst isZero = (result) => {\n    if(typeof result !== 'number') {\n        throw NaNError('Provided argument is not a number. A possible zero result is a number!);\n} else return Number(result) === 0;\n\n}\n```\n\nJest offers matcher extension. It seems very incircunstancial, although expected to twist nose in such  situation. Why is not `expect(expectation === result).toBe(true)` a solution? :-\/\n\n\nDoes it make sense?","Is it possible to make it optional toggle and allowed user to set it? Something could be like `JEST_NEGATIVE_ZERO_COMPARISON_ENABLED=1` (or disable-ish similar)."],"labels":["Bug Report","Pinned"]},{"title":"chore: replace `vm.Script` with `vm.compileFunction`","body":"## Summary\r\n\r\nMemory leak is alleviated with `vm.compileFunction`.\r\n\r\nRelated to https:\/\/github.com\/facebook\/jest\/issues\/11956\r\n\r\nInspired by earlier work done earlier https:\/\/github.com\/facebook\/jest\/pull\/10586\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nChange is covered by existing tests.  Below is a before and after of heap usage against a trivial reproduction.\r\n\r\n**Before (against main branch)**:\r\n\r\n```bash\r\n% yarn jest --runInBand --logHeapUsage reproduce\r\n PASS  reproduce\/a19.test.js (49 MB heap size)\r\n PASS  reproduce\/a156.test.js (49 MB heap size)\r\n PASS  reproduce\/a58.test.js (56 MB heap size)\r\n PASS  reproduce\/a39.test.js (55 MB heap size)\r\n PASS  reproduce\/a89.test.js (62 MB heap size)\r\n PASS  reproduce\/a173.test.js (62 MB heap size)\r\n PASS  reproduce\/a190.test.js (69 MB heap size)\r\n PASS  reproduce\/a4.test.js (50 MB heap size)\r\n PASS  reproduce\/a50.test.js (57 MB heap size)\r\n PASS  reproduce\/a169.test.js (58 MB heap size)\r\n PASS  reproduce\/a55.test.js (60 MB heap size)\r\n PASS  reproduce\/a131.test.js (66 MB heap size)\r\n PASS  reproduce\/a179.test.js (73 MB heap size)\r\n PASS  reproduce\/a105.test.js (71 MB heap size)\r\n PASS  reproduce\/a159.test.js (77 MB heap size)\r\n PASS  reproduce\/a111.test.js (77 MB heap size)\r\n PASS  reproduce\/a168.test.js (84 MB heap size)\r\n PASS  reproduce\/a14.test.js (83 MB heap size)\r\n PASS  reproduce\/a41.test.js (90 MB heap size)\r\n PASS  reproduce\/a44.test.js (89 MB heap size)\r\n PASS  reproduce\/a162.test.js (96 MB heap size)\r\n PASS  reproduce\/a98.test.js (95 MB heap size)\r\n PASS  reproduce\/a.test.js (102 MB heap size)\r\n PASS  reproduce\/a16.test.js (101 MB heap size)\r\n PASS  reproduce\/a46.test.js (108 MB heap size)\r\n PASS  reproduce\/a75.test.js (107 MB heap size)\r\n PASS  reproduce\/a91.test.js (95 MB heap size)\r\n PASS  reproduce\/a7.test.js (102 MB heap size)\r\n PASS  reproduce\/a76.test.js (101 MB heap size)\r\n PASS  reproduce\/a49.test.js (108 MB heap size)\r\n PASS  reproduce\/a141.test.js (109 MB heap size)\r\n PASS  reproduce\/a67.test.js (115 MB heap size)\r\n PASS  reproduce\/a135.test.js (115 MB heap size)\r\n PASS  reproduce\/a17.test.js (122 MB heap size)\r\n PASS  reproduce\/a116.test.js (121 MB heap size)\r\n PASS  reproduce\/a129.test.js (128 MB heap size)\r\n PASS  reproduce\/a107.test.js (127 MB heap size)\r\n PASS  reproduce\/a117.test.js (134 MB heap size)\r\n PASS  reproduce\/a30.test.js (133 MB heap size)\r\n PASS  reproduce\/a177.test.js (140 MB heap size)\r\n PASS  reproduce\/a92.test.js (140 MB heap size)\r\n PASS  reproduce\/a32.test.js (146 MB heap size)\r\n PASS  reproduce\/a166.test.js (146 MB heap size)\r\n PASS  reproduce\/a83.test.js (153 MB heap size)\r\n PASS  reproduce\/a10.test.js (152 MB heap size)\r\n PASS  reproduce\/a45.test.js (158 MB heap size)\r\n PASS  reproduce\/a9.test.js (158 MB heap size)\r\n PASS  reproduce\/a61.test.js (165 MB heap size)\r\n PASS  reproduce\/a79.test.js (164 MB heap size)\r\n PASS  reproduce\/a24.test.js (171 MB heap size)\r\n PASS  reproduce\/a165.test.js (170 MB heap size)\r\n PASS  reproduce\/a64.test.js (177 MB heap size)\r\n PASS  reproduce\/a29.test.js (176 MB heap size)\r\n PASS  reproduce\/a80.test.js (183 MB heap size)\r\n PASS  reproduce\/a181.test.js (183 MB heap size)\r\n PASS  reproduce\/a167.test.js (190 MB heap size)\r\n PASS  reproduce\/a123.test.js (189 MB heap size)\r\n PASS  reproduce\/a149.test.js (196 MB heap size)\r\n PASS  reproduce\/a182.test.js (195 MB heap size)\r\n PASS  reproduce\/a62.test.js (202 MB heap size)\r\n PASS  reproduce\/a26.test.js (202 MB heap size)\r\n PASS  reproduce\/a136.test.js (208 MB heap size)\r\n PASS  reproduce\/a97.test.js (208 MB heap size)\r\n PASS  reproduce\/a134.test.js (214 MB heap size)\r\n PASS  reproduce\/a25.test.js (214 MB heap size)\r\n PASS  reproduce\/a84.test.js (220 MB heap size)\r\n PASS  reproduce\/a171.test.js (220 MB heap size)\r\n PASS  reproduce\/a161.test.js (226 MB heap size)\r\n PASS  reproduce\/a178.test.js (226 MB heap size)\r\n PASS  reproduce\/a31.test.js (233 MB heap size)\r\n PASS  reproduce\/a128.test.js (232 MB heap size)\r\n PASS  reproduce\/a121.test.js (238 MB heap size)\r\n PASS  reproduce\/a42.test.js (238 MB heap size)\r\n PASS  reproduce\/a20.test.js (245 MB heap size)\r\n PASS  reproduce\/a115.test.js (244 MB heap size)\r\n PASS  reproduce\/a183.test.js (251 MB heap size)\r\n PASS  reproduce\/a59.test.js (250 MB heap size)\r\n PASS  reproduce\/a158.test.js (257 MB heap size)\r\n PASS  reproduce\/a82.test.js (256 MB heap size)\r\n PASS  reproduce\/a5.test.js (263 MB heap size)\r\n PASS  reproduce\/a148.test.js (263 MB heap size)\r\n PASS  reproduce\/a150.test.js (269 MB heap size)\r\n PASS  reproduce\/a140.test.js (269 MB heap size)\r\n PASS  reproduce\/a23.test.js (275 MB heap size)\r\n PASS  reproduce\/a104.test.js (275 MB heap size)\r\n PASS  reproduce\/a48.test.js (282 MB heap size)\r\n PASS  reproduce\/a93.test.js (281 MB heap size)\r\n PASS  reproduce\/a86.test.js (288 MB heap size)\r\n PASS  reproduce\/a127.test.js (287 MB heap size)\r\n PASS  reproduce\/a1.test.js (294 MB heap size)\r\n PASS  reproduce\/a68.test.js (293 MB heap size)\r\n PASS  reproduce\/a78.test.js (300 MB heap size)\r\n PASS  reproduce\/a56.test.js (299 MB heap size)\r\n PASS  reproduce\/a34.test.js (306 MB heap size)\r\n PASS  reproduce\/a189.test.js (306 MB heap size)\r\n PASS  reproduce\/a139.test.js (312 MB heap size)\r\n PASS  reproduce\/a193.test.js (198 MB heap size)\r\n PASS  reproduce\/a151.test.js (205 MB heap size)\r\n PASS  reproduce\/a40.test.js (212 MB heap size)\r\n PASS  reproduce\/a77.test.js (210 MB heap size)\r\n PASS  reproduce\/a96.test.js (212 MB heap size)\r\n PASS  reproduce\/a36.test.js (219 MB heap size)\r\n PASS  reproduce\/a118.test.js (218 MB heap size)\r\n PASS  reproduce\/a108.test.js (225 MB heap size)\r\n PASS  reproduce\/a37.test.js (225 MB heap size)\r\n PASS  reproduce\/a196.test.js (232 MB heap size)\r\n PASS  reproduce\/a184.test.js (231 MB heap size)\r\n PASS  reproduce\/a147.test.js (238 MB heap size)\r\n PASS  reproduce\/a164.test.js (238 MB heap size)\r\n PASS  reproduce\/a174.test.js (244 MB heap size)\r\n PASS  reproduce\/a188.test.js (244 MB heap size)\r\n PASS  reproduce\/a198.test.js (250 MB heap size)\r\n PASS  reproduce\/a22.test.js (250 MB heap size)\r\n PASS  reproduce\/a133.test.js (257 MB heap size)\r\n PASS  reproduce\/a132.test.js (257 MB heap size)\r\n PASS  reproduce\/a200.test.js (264 MB heap size)\r\n PASS  reproduce\/a176.test.js (264 MB heap size)\r\n PASS  reproduce\/a187.test.js (271 MB heap size)\r\n PASS  reproduce\/a72.test.js (270 MB heap size)\r\n PASS  reproduce\/a145.test.js (276 MB heap size)\r\n PASS  reproduce\/a126.test.js (276 MB heap size)\r\n PASS  reproduce\/a87.test.js (282 MB heap size)\r\n PASS  reproduce\/a47.test.js (282 MB heap size)\r\n PASS  reproduce\/a185.test.js (289 MB heap size)\r\n PASS  reproduce\/a3.test.js (288 MB heap size)\r\n PASS  reproduce\/a53.test.js (295 MB heap size)\r\n PASS  reproduce\/a199.test.js (294 MB heap size)\r\n PASS  reproduce\/a43.test.js (301 MB heap size)\r\n PASS  reproduce\/a142.test.js (300 MB heap size)\r\n PASS  reproduce\/a88.test.js (307 MB heap size)\r\n PASS  reproduce\/a120.test.js (306 MB heap size)\r\n PASS  reproduce\/a21.test.js (313 MB heap size)\r\n PASS  reproduce\/a180.test.js (312 MB heap size)\r\n PASS  reproduce\/a74.test.js (319 MB heap size)\r\n PASS  reproduce\/a90.test.js (319 MB heap size)\r\n PASS  reproduce\/a52.test.js (325 MB heap size)\r\n PASS  reproduce\/a143.test.js (325 MB heap size)\r\n PASS  reproduce\/a153.test.js (331 MB heap size)\r\n PASS  reproduce\/a66.test.js (331 MB heap size)\r\n PASS  reproduce\/a114.test.js (338 MB heap size)\r\n PASS  reproduce\/a192.test.js (337 MB heap size)\r\n PASS  reproduce\/a197.test.js (344 MB heap size)\r\n PASS  reproduce\/a163.test.js (343 MB heap size)\r\n PASS  reproduce\/a155.test.js (350 MB heap size)\r\n PASS  reproduce\/a54.test.js (349 MB heap size)\r\n PASS  reproduce\/a137.test.js (356 MB heap size)\r\n PASS  reproduce\/a154.test.js (355 MB heap size)\r\n PASS  reproduce\/a18.test.js (362 MB heap size)\r\n PASS  reproduce\/a186.test.js (362 MB heap size)\r\n PASS  reproduce\/a109.test.js (368 MB heap size)\r\n PASS  reproduce\/a119.test.js (368 MB heap size)\r\n PASS  reproduce\/a73.test.js (374 MB heap size)\r\n PASS  reproduce\/a63.test.js (374 MB heap size)\r\n PASS  reproduce\/a172.test.js (380 MB heap size)\r\n PASS  reproduce\/a11.test.js (380 MB heap size)\r\n PASS  reproduce\/a57.test.js (386 MB heap size)\r\n PASS  reproduce\/a2.test.js (386 MB heap size)\r\n PASS  reproduce\/a85.test.js (392 MB heap size)\r\n PASS  reproduce\/a194.test.js (392 MB heap size)\r\n PASS  reproduce\/a71.test.js (398 MB heap size)\r\n PASS  reproduce\/a170.test.js (398 MB heap size)\r\n PASS  reproduce\/a102.test.js (405 MB heap size)\r\n PASS  reproduce\/a12.test.js (404 MB heap size)\r\n PASS  reproduce\/a60.test.js (411 MB heap size)\r\n PASS  reproduce\/a103.test.js (410 MB heap size)\r\n PASS  reproduce\/a70.test.js (417 MB heap size)\r\n PASS  reproduce\/a125.test.js (416 MB heap size)\r\n PASS  reproduce\/a6.test.js (306 MB heap size)\r\n PASS  reproduce\/a152.test.js (313 MB heap size)\r\n PASS  reproduce\/a106.test.js (320 MB heap size)\r\n PASS  reproduce\/a65.test.js (318 MB heap size)\r\n PASS  reproduce\/a38.test.js (324 MB heap size)\r\n PASS  reproduce\/a28.test.js (324 MB heap size)\r\n PASS  reproduce\/a81.test.js (331 MB heap size)\r\n PASS  reproduce\/a138.test.js (331 MB heap size)\r\n PASS  reproduce\/a191.test.js (337 MB heap size)\r\n PASS  reproduce\/a99.test.js (337 MB heap size)\r\n PASS  reproduce\/a33.test.js (344 MB heap size)\r\n PASS  reproduce\/a122.test.js (344 MB heap size)\r\n PASS  reproduce\/a15.test.js (350 MB heap size)\r\n PASS  reproduce\/a101.test.js (349 MB heap size)\r\n PASS  reproduce\/a8.test.js (356 MB heap size)\r\n PASS  reproduce\/a27.test.js (356 MB heap size)\r\n PASS  reproduce\/a144.test.js (362 MB heap size)\r\n PASS  reproduce\/a110.test.js (362 MB heap size)\r\n PASS  reproduce\/a100.test.js (368 MB heap size)\r\n PASS  reproduce\/a124.test.js (368 MB heap size)\r\n PASS  reproduce\/a95.test.js (374 MB heap size)\r\n PASS  reproduce\/a160.test.js (374 MB heap size)\r\n PASS  reproduce\/a13.test.js (381 MB heap size)\r\n PASS  reproduce\/a112.test.js (380 MB heap size)\r\n PASS  reproduce\/a195.test.js (387 MB heap size)\r\n PASS  reproduce\/a94.test.js (386 MB heap size)\r\n PASS  reproduce\/a113.test.js (393 MB heap size)\r\n PASS  reproduce\/a157.test.js (392 MB heap size)\r\n PASS  reproduce\/a69.test.js (399 MB heap size)\r\n PASS  reproduce\/a130.test.js (398 MB heap size)\r\n PASS  reproduce\/a175.test.js (405 MB heap size)\r\n PASS  reproduce\/a51.test.js (405 MB heap size)\r\n PASS  reproduce\/a35.test.js (411 MB heap size)\r\n PASS  reproduce\/a146.test.js (411 MB heap size)\r\n\r\nTest Suites: 201 passed, 201 total\r\nTests:       201 passed, 201 total\r\nSnapshots:   0 total\r\nTime:        19.276 s\r\n```\r\n\r\n**After (against this branch)**:\r\n\r\n```bash\r\n% yarn jest --runInBand --logHeapUsage reproduce\r\n PASS  reproduce\/a19.test.js (49 MB heap size)\r\n PASS  reproduce\/a168.test.js (55 MB heap size)\r\n PASS  reproduce\/a179.test.js (53 MB heap size)\r\n PASS  reproduce\/a169.test.js (58 MB heap size)\r\n PASS  reproduce\/a190.test.js (58 MB heap size)\r\n PASS  reproduce\/a41.test.js (63 MB heap size)\r\n PASS  reproduce\/a156.test.js (63 MB heap size)\r\n PASS  reproduce\/a14.test.js (40 MB heap size)\r\n PASS  reproduce\/a111.test.js (46 MB heap size)\r\n PASS  reproduce\/a135.test.js (52 MB heap size)\r\n PASS  reproduce\/a150.test.js (50 MB heap size)\r\n PASS  reproduce\/a147.test.js (55 MB heap size)\r\n PASS  reproduce\/a107.test.js (55 MB heap size)\r\n PASS  reproduce\/a140.test.js (61 MB heap size)\r\n PASS  reproduce\/a127.test.js (61 MB heap size)\r\n PASS  reproduce\/a37.test.js (67 MB heap size)\r\n PASS  reproduce\/a46.test.js (66 MB heap size)\r\n PASS  reproduce\/a91.test.js (72 MB heap size)\r\n PASS  reproduce\/a44.test.js (72 MB heap size)\r\n PASS  reproduce\/a118.test.js (77 MB heap size)\r\n PASS  reproduce\/a9.test.js (82 MB heap size)\r\n PASS  reproduce\/a79.test.js (82 MB heap size)\r\n PASS  reproduce\/a80.test.js (87 MB heap size)\r\n PASS  reproduce\/a177.test.js (88 MB heap size)\r\n PASS  reproduce\/a59.test.js (93 MB heap size)\r\n PASS  reproduce\/a162.test.js (92 MB heap size)\r\n PASS  reproduce\/a68.test.js (98 MB heap size)\r\n PASS  reproduce\/a75.test.js (98 MB heap size)\r\n PASS  reproduce\/a139.test.js (103 MB heap size)\r\n PASS  reproduce\/a165.test.js (108 MB heap size)\r\n PASS  reproduce\/a29.test.js (108 MB heap size)\r\n PASS  reproduce\/a42.test.js (113 MB heap size)\r\n PASS  reproduce\/a96.test.js (114 MB heap size)\r\n PASS  reproduce\/a184.test.js (119 MB heap size)\r\n PASS  reproduce\/a171.test.js (119 MB heap size)\r\n PASS  reproduce\/a199.test.js (125 MB heap size)\r\n PASS  reproduce\/a98.test.js (125 MB heap size)\r\n PASS  reproduce\/a31.test.js (130 MB heap size)\r\n PASS  reproduce\/a16.test.js (130 MB heap size)\r\n PASS  reproduce\/a39.test.js (135 MB heap size)\r\n PASS  reproduce\/a131.test.js (43 MB heap size)\r\n PASS  reproduce\/a121.test.js (48 MB heap size)\r\n PASS  reproduce\/a153.test.js (54 MB heap size)\r\n PASS  reproduce\/a76.test.js (52 MB heap size)\r\n PASS  reproduce\/a183.test.js (57 MB heap size)\r\n PASS  reproduce\/a23.test.js (58 MB heap size)\r\n PASS  reproduce\/a104.test.js (64 MB heap size)\r\n PASS  reproduce\/a67.test.js (63 MB heap size)\r\n PASS  reproduce\/a163.test.js (68 MB heap size)\r\n PASS  reproduce\/a26.test.js (68 MB heap size)\r\n PASS  reproduce\/a18.test.js (74 MB heap size)\r\n PASS  reproduce\/a196.test.js (79 MB heap size)\r\n PASS  reproduce\/a172.test.js (78 MB heap size)\r\n PASS  reproduce\/a124.test.js (84 MB heap size)\r\n PASS  reproduce\/a2.test.js (84 MB heap size)\r\n PASS  reproduce\/a95.test.js (89 MB heap size)\r\n PASS  reproduce\/a112.test.js (90 MB heap size)\r\n PASS  reproduce\/a94.test.js (95 MB heap size)\r\n PASS  reproduce\/a12.test.js (96 MB heap size)\r\n PASS  reproduce\/a174.test.js (101 MB heap size)\r\n PASS  reproduce\/a.test.js (101 MB heap size)\r\n PASS  reproduce\/a64.test.js (106 MB heap size)\r\n PASS  reproduce\/a117.test.js (106 MB heap size)\r\n PASS  reproduce\/a128.test.js (111 MB heap size)\r\n PASS  reproduce\/a181.test.js (117 MB heap size)\r\n PASS  reproduce\/a115.test.js (116 MB heap size)\r\n PASS  reproduce\/a5.test.js (122 MB heap size)\r\n PASS  reproduce\/a32.test.js (122 MB heap size)\r\n PASS  reproduce\/a22.test.js (127 MB heap size)\r\n PASS  reproduce\/a133.test.js (128 MB heap size)\r\n PASS  reproduce\/a132.test.js (133 MB heap size)\r\n PASS  reproduce\/a182.test.js (133 MB heap size)\r\n PASS  reproduce\/a58.test.js (138 MB heap size)\r\n PASS  reproduce\/a159.test.js (42 MB heap size)\r\n PASS  reproduce\/a197.test.js (48 MB heap size)\r\n PASS  reproduce\/a86.test.js (53 MB heap size)\r\n PASS  reproduce\/a62.test.js (52 MB heap size)\r\n PASS  reproduce\/a72.test.js (57 MB heap size)\r\n PASS  reproduce\/a36.test.js (58 MB heap size)\r\n PASS  reproduce\/a137.test.js (63 MB heap size)\r\n PASS  reproduce\/a136.test.js (62 MB heap size)\r\n PASS  reproduce\/a126.test.js (68 MB heap size)\r\n PASS  reproduce\/a45.test.js (68 MB heap size)\r\n PASS  reproduce\/a109.test.js (73 MB heap size)\r\n PASS  reproduce\/a110.test.js (78 MB heap size)\r\n PASS  reproduce\/a78.test.js (78 MB heap size)\r\n PASS  reproduce\/a185.test.js (83 MB heap size)\r\n PASS  reproduce\/a125.test.js (84 MB heap size)\r\n PASS  reproduce\/a69.test.js (89 MB heap size)\r\n PASS  reproduce\/a130.test.js (90 MB heap size)\r\n PASS  reproduce\/a120.test.js (95 MB heap size)\r\n PASS  reproduce\/a106.test.js (95 MB heap size)\r\n PASS  reproduce\/a65.test.js (101 MB heap size)\r\n PASS  reproduce\/a81.test.js (101 MB heap size)\r\n PASS  reproduce\/a180.test.js (107 MB heap size)\r\n PASS  reproduce\/a74.test.js (107 MB heap size)\r\n PASS  reproduce\/a191.test.js (112 MB heap size)\r\n PASS  reproduce\/a7.test.js (112 MB heap size)\r\n PASS  reproduce\/a188.test.js (117 MB heap size)\r\n PASS  reproduce\/a20.test.js (117 MB heap size)\r\n PASS  reproduce\/a198.test.js (123 MB heap size)\r\n PASS  reproduce\/a143.test.js (128 MB heap size)\r\n PASS  reproduce\/a66.test.js (127 MB heap size)\r\n PASS  reproduce\/a148.test.js (133 MB heap size)\r\n PASS  reproduce\/a151.test.js (133 MB heap size)\r\n PASS  reproduce\/a50.test.js (138 MB heap size)\r\n PASS  reproduce\/a4.test.js (41 MB heap size)\r\n PASS  reproduce\/a15.test.js (47 MB heap size)\r\n PASS  reproduce\/a176.test.js (52 MB heap size)\r\n PASS  reproduce\/a83.test.js (50 MB heap size)\r\n PASS  reproduce\/a8.test.js (55 MB heap size)\r\n PASS  reproduce\/a155.test.js (57 MB heap size)\r\n PASS  reproduce\/a108.test.js (62 MB heap size)\r\n PASS  reproduce\/a1.test.js (61 MB heap size)\r\n PASS  reproduce\/a144.test.js (66 MB heap size)\r\n PASS  reproduce\/a87.test.js (71 MB heap size)\r\n PASS  reproduce\/a11.test.js (71 MB heap size)\r\n PASS  reproduce\/a35.test.js (76 MB heap size)\r\n PASS  reproduce\/a170.test.js (77 MB heap size)\r\n PASS  reproduce\/a13.test.js (82 MB heap size)\r\n PASS  reproduce\/a102.test.js (82 MB heap size)\r\n PASS  reproduce\/a195.test.js (88 MB heap size)\r\n PASS  reproduce\/a161.test.js (87 MB heap size)\r\n PASS  reproduce\/a157.test.js (93 MB heap size)\r\n PASS  reproduce\/a34.test.js (93 MB heap size)\r\n PASS  reproduce\/a6.test.js (98 MB heap size)\r\n PASS  reproduce\/a53.test.js (103 MB heap size)\r\n PASS  reproduce\/a152.test.js (103 MB heap size)\r\n PASS  reproduce\/a21.test.js (108 MB heap size)\r\n PASS  reproduce\/a17.test.js (107 MB heap size)\r\n PASS  reproduce\/a28.test.js (113 MB heap size)\r\n PASS  reproduce\/a129.test.js (113 MB heap size)\r\n PASS  reproduce\/a175.test.js (118 MB heap size)\r\n PASS  reproduce\/a90.test.js (124 MB heap size)\r\n PASS  reproduce\/a52.test.js (123 MB heap size)\r\n PASS  reproduce\/a99.test.js (128 MB heap size)\r\n PASS  reproduce\/a30.test.js (128 MB heap size)\r\n PASS  reproduce\/a89.test.js (133 MB heap size)\r\n PASS  reproduce\/a105.test.js (42 MB heap size)\r\n PASS  reproduce\/a193.test.js (47 MB heap size)\r\n PASS  reproduce\/a158.test.js (53 MB heap size)\r\n PASS  reproduce\/a123.test.js (51 MB heap size)\r\n PASS  reproduce\/a114.test.js (57 MB heap size)\r\n PASS  reproduce\/a77.test.js (57 MB heap size)\r\n PASS  reproduce\/a200.test.js (63 MB heap size)\r\n PASS  reproduce\/a166.test.js (61 MB heap size)\r\n PASS  reproduce\/a192.test.js (67 MB heap size)\r\n PASS  reproduce\/a149.test.js (67 MB heap size)\r\n PASS  reproduce\/a10.test.js (72 MB heap size)\r\n PASS  reproduce\/a145.test.js (78 MB heap size)\r\n PASS  reproduce\/a54.test.js (77 MB heap size)\r\n PASS  reproduce\/a27.test.js (83 MB heap size)\r\n PASS  reproduce\/a154.test.js (83 MB heap size)\r\n PASS  reproduce\/a119.test.js (88 MB heap size)\r\n PASS  reproduce\/a186.test.js (89 MB heap size)\r\n PASS  reproduce\/a63.test.js (94 MB heap size)\r\n PASS  reproduce\/a97.test.js (94 MB heap size)\r\n PASS  reproduce\/a100.test.js (99 MB heap size)\r\n PASS  reproduce\/a25.test.js (99 MB heap size)\r\n PASS  reproduce\/a146.test.js (104 MB heap size)\r\n PASS  reproduce\/a71.test.js (110 MB heap size)\r\n PASS  reproduce\/a103.test.js (109 MB heap size)\r\n PASS  reproduce\/a113.test.js (115 MB heap size)\r\n PASS  reproduce\/a24.test.js (114 MB heap size)\r\n PASS  reproduce\/a3.test.js (119 MB heap size)\r\n PASS  reproduce\/a178.test.js (119 MB heap size)\r\n PASS  reproduce\/a189.test.js (125 MB heap size)\r\n PASS  reproduce\/a142.test.js (130 MB heap size)\r\n PASS  reproduce\/a164.test.js (129 MB heap size)\r\n PASS  reproduce\/a138.test.js (135 MB heap size)\r\n PASS  reproduce\/a49.test.js (134 MB heap size)\r\n PASS  reproduce\/a82.test.js (140 MB heap size)\r\n PASS  reproduce\/a141.test.js (139 MB heap size)\r\n PASS  reproduce\/a51.test.js (145 MB heap size)\r\n PASS  reproduce\/a122.test.js (150 MB heap size)\r\n PASS  reproduce\/a187.test.js (150 MB heap size)\r\n PASS  reproduce\/a173.test.js (155 MB heap size)\r\n PASS  reproduce\/a55.test.js (41 MB heap size)\r\n PASS  reproduce\/a57.test.js (47 MB heap size)\r\n PASS  reproduce\/a160.test.js (52 MB heap size)\r\n PASS  reproduce\/a84.test.js (50 MB heap size)\r\n PASS  reproduce\/a60.test.js (56 MB heap size)\r\n PASS  reproduce\/a70.test.js (57 MB heap size)\r\n PASS  reproduce\/a43.test.js (62 MB heap size)\r\n PASS  reproduce\/a116.test.js (61 MB heap size)\r\n PASS  reproduce\/a38.test.js (66 MB heap size)\r\n PASS  reproduce\/a92.test.js (66 MB heap size)\r\n PASS  reproduce\/a40.test.js (72 MB heap size)\r\n PASS  reproduce\/a33.test.js (77 MB heap size)\r\n PASS  reproduce\/a48.test.js (77 MB heap size)\r\n PASS  reproduce\/a101.test.js (82 MB heap size)\r\n PASS  reproduce\/a93.test.js (82 MB heap size)\r\n PASS  reproduce\/a73.test.js (87 MB heap size)\r\n PASS  reproduce\/a134.test.js (87 MB heap size)\r\n PASS  reproduce\/a47.test.js (93 MB heap size)\r\n PASS  reproduce\/a85.test.js (98 MB heap size)\r\n PASS  reproduce\/a194.test.js (97 MB heap size)\r\n PASS  reproduce\/a61.test.js (102 MB heap size)\r\n PASS  reproduce\/a56.test.js (103 MB heap size)\r\n PASS  reproduce\/a88.test.js (108 MB heap size)\r\n PASS  reproduce\/a167.test.js (108 MB heap size)\r\n\r\nTest Suites: 201 passed, 201 total\r\nTests:       201 passed, 201 total\r\nSnapshots:   0 total\r\nTime:        15.093 s, estimated 18 s\r\n```","comments":["Hi @rthreei! \n\nThank you for your pull request and welcome to our community. \n\n# Action Required\n\nIn order to merge **any pull request** (code, docs, etc.), we **require** contributors to sign our **Contributor License Agreement**, and we don't seem to have one on file for you.\n\n# Process\n\nIn order for us to review and merge your suggested changes, please sign at <https:\/\/code.facebook.com\/cla>. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need to sign the corporate CLA.\n\nOnce the CLA is signed, our tooling will perform checks and validations. Afterwards, the **pull request will be tagged** with `CLA signed`. The tagging process may take up to 1 hour after signing. Please give it that time before contacting us about it.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fjest%20%2312205). Thanks!","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) Report\n> Merging [#12205](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (790a026) into [main](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/0f99ff591072c8983e8c95c84c9234d01ad5dba1?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (0f99ff5) will **increase** coverage by `0.02%`.\n> The diff coverage is `66.66%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n\n```diff\n@@            Coverage Diff             @@\n##             main   #12205      +\/-   ##\n==========================================\n+ Coverage   67.51%   67.54%   +0.02%     \n==========================================\n  Files         328      328              \n  Lines       17246    17228      -18     \n  Branches     5071     5067       -4     \n==========================================\n- Hits        11644    11637       -7     \n+ Misses       5569     5556      -13     \n- Partials       33       35       +2     \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/jest-runtime\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1ydW50aW1lL3NyYy9pbmRleC50cw==) | `56.37% <66.66%> (-0.10%)` | :arrow_down: |\n| [...provider-v8\/cjs-native-without-sourcemap\/module.js](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-ZTJlL2NvdmVyYWdlLXByb3ZpZGVyLXY4L2Nqcy1uYXRpdmUtd2l0aG91dC1zb3VyY2VtYXAvbW9kdWxlLmpz) | `75.00% <0.00%> (-4.17%)` | :arrow_down: |\n| [packages\/expect\/src\/utils.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvZXhwZWN0L3NyYy91dGlscy50cw==) | `96.53% <0.00%> (+0.49%)` | :arrow_up: |\n| [...e-provider-v8\/cjs-with-babel-transformer\/module.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-ZTJlL2NvdmVyYWdlLXByb3ZpZGVyLXY4L2Nqcy13aXRoLWJhYmVsLXRyYW5zZm9ybWVyL21vZHVsZS50cw==) | `96.15% <0.00%> (+15.38%)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Last update [0f99ff5...790a026](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/12205?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Meta Open Source project. Thanks!","What needs to happen to get this over the finish line?","> What needs to happen to get this over the finish line?\r\n\r\nI guess @SimenB has some doubts about this?","Main reason is that this will make it much worse for node 12 and 14, and it's really a bug in node","Can we make it an opt-in change with a cli flag? I'm happy to do the work and update the tests. With node 14 going EOL this fall more people are going to be looking to move to 16 (including us at Plex). A cli flag would make the move much less painful. When node fixes their bug we can remove the option from jest again when it makes sense","I don't think we should add a config flag - if we do this we should just detect the version of node inline so people don't have to change anything.\r\n\r\nMaybe you could change this to use `semver` and detect broken versions (`>= 16.11.0` I guess?), and if not broken use current code? Sorta similar to https:\/\/github.com\/facebook\/jest\/blob\/7826a8f15be07b2634add73a50decf73086e5948\/packages\/test-utils\/src\/ConditionalTest.ts#L37","Sure, that approach works too. I'll open a fresh PR based on this one when I'm ready. Thanks for the quick brainstorm!","Is there anything I can do to get this PR moving along again? We generally try to avoid falling too far behind even minor versions","@phawxby nothing new since the last activity, feel free to fix: https:\/\/github.com\/facebook\/jest\/pull\/12205#discussion_r815307518","> @phawxby nothing new since the last activity, feel free to fix: [#12205 (comment)](https:\/\/github.com\/facebook\/jest\/pull\/12205#discussion_r815307518)\r\n\r\nAs you noted in the thread above, the `importModuleDynamically` issue could be a different bug. Would a way to handle this be to accept this PR but with `importModuleDynamically` implemented with the memory leak as it's not a regression in performance, for many will be a significant improvement. The `importModuleDynamically` memory leak issue can then be tackled separately? ","> > @phawxby nothing new since the last activity, feel free to fix: [#12205 (comment)](https:\/\/github.com\/facebook\/jest\/pull\/12205#discussion_r815307518)\r\n> \r\n> As you noted in the thread above, the `importModuleDynamically` issue could be a different bug. Would a way to handle this be to accept this PR but with `importModuleDynamically` implemented with the memory leak as it's not a regression in performance, for many will be a significant improvement. The `importModuleDynamically` memory leak issue can then be tackled separately?\r\n\r\n`importModuleDynamically` being implemented voids the improvement, so that doesn't help.  Unless you're seeing that it does help?","> > > @phawxby nothing new since the last activity, feel free to fix: [#12205 (comment)](https:\/\/github.com\/facebook\/jest\/pull\/12205#discussion_r815307518)\r\n> > \r\n> > \r\n> > As you noted in the thread above, the `importModuleDynamically` issue could be a different bug. Would a way to handle this be to accept this PR but with `importModuleDynamically` implemented with the memory leak as it's not a regression in performance, for many will be a significant improvement. The `importModuleDynamically` memory leak issue can then be tackled separately?\r\n> \r\n> `importModuleDynamically` being implemented voids the improvement, so that doesn't help. Unless you're seeing that it does help?\r\n\r\nAh, I misunderstood your comment as the issue only occurs when importing esm from cjs, not in all scenarios. I'm going to have a dig around this afternoon and see if I can find anything but I'm not holding out much hope. ","A bit more digging and I've found this, which suggests this isn't going to be especially easy to fix.\r\nhttps:\/\/github.com\/nodejs\/node\/issues\/25424#issuecomment-770216256\r\n\r\nWhich then ties in with this.\r\nhttps:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=12198","Instead of using a patch, one thing that can be done is to extend the default `jest-runtime` and override `_execModule`. It can be passed as `runtime` in configuration (renamed from `moduleLoader` in Jest 28).\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/f43871e37f8bf6dbe292ad2e52f4781868c4731b\/packages\/jest-runner\/src\/runTest.ts#L117-L121\r\n\r\nWhile `_execModule` is private (by convention), it's not literally private at runtime (i.e. using `#`), so overriding should be fine.\r\n\r\n```js\r\nconst {default: JestRuntime} = require('jest-runtime');\r\n\r\nmodule.exports = class CompileFunctionRuntime extends JestRuntime {\r\n  _execModule() {\r\n    \/\/ do something\r\n  }\r\n};\r\n```\r\n\r\nThis module could then be published as a workaround. _Somewhat_ brittle as `_execModule` isn't public API, but less brittle than applying a patch \ud83d\ude42 ","@a88zach has published https:\/\/github.com\/reside-eng\/jest-runtime which does what @SimenB suggested in [the last comment](https:\/\/github.com\/facebook\/jest\/pull\/12205#issuecomment-1110883415). This unblocked us from upgrading to Node > 16.10.\r\n\r\nSee https:\/\/github.com\/facebook\/jest\/issues\/11956#issuecomment-1148857787.","Hey to understand does this issue manifest without any `gc()` calls?","Same as @blimmer, I can confirm that https:\/\/github.com\/reside-eng\/jest-runtime (which is basically this PR as a workaround, using @SimenB's suggestion in [this comment](https:\/\/github.com\/facebook\/jest\/pull\/12205#issuecomment-1110883415)) significantly alleviates the memory leaking problems.\r\n\r\nI have a medium-sized TypeScript project transformed with `@swc\/jest` containing around 500 test cases that used to take up a massive 5.2 GB of RAM to run from start to finish, but now takes \"only\" 2.6 GB, effectively *halving* the RAM usage of Jest.","> Same as @blimmer, I can confirm that https:\/\/github.com\/reside-eng\/jest-runtime (which is basically this PR as a workaround, using @SimenB's suggestion in [this comment](https:\/\/github.com\/facebook\/jest\/pull\/12205#issuecomment-1110883415)) significantly alleviates the memory leaking problems.\r\n> \r\n> I have a medium-sized TypeScript project transformed with `@swc\/jest` containing around 500 test cases that used to take up a massive 5.2 GB of RAM to run from start to finish, but now takes \"only\" 2.6 GB, effectively _halving_ the RAM usage of Jest.\r\n\r\nI've just tried the fixed runtime as well. Tests ended with 1.8GB of ram instead of 6GB. ","Hi @rthreei , Using side\/jest-runtime we are seeing improvement in performance and memory usage. It is still 30% slower than node 16.10. Any clue if anything can be done. Without side\/jest-runtime there is degradation for 100%","In NodeJS v18.17.1 the heap increases from 118Mb to 5815MB and total runtime runInBand + logHeapUsage is 187sec\r\nusing `@side\/jest-runtime` the heap decreased to 5467 MB and total runtime  runInBand + logHeapUsage is 165sec\r\n\r\n:\/ ","Node landed a [fix](https:\/\/github.com\/nodejs\/node\/pull\/49950#event-10556827669) for `vm.Script` a few hours ago. Hopefully it'll be backported all the way to Node 18.","**NodeJs v20.8.0 running:**\r\n```\r\n    \"test\": \"cross-env NODE_OPTIONS=--max-old-space-size=8192 node --experimental-vm-modules .\/node_modules\/jest\/bin\/jest.js --config=jest.config.js --no-watchman --runInBand --logHeapUsage --ci\",\r\n```\r\n\r\n```\r\n  transform: {\r\n    '\\\\.ts$': '@swc\/jest',\r\n    '\\\\.vue$': '<rootDir>\/node_modules\/vue2-swc-jest',\r\n  },\r\n  runtime: '@side\/jest-runtime',\r\n```\r\n\r\nBumps heap size from 125Mb to 5601 MB heap size (execution time 166 sec )\r\n\r\nRemoving runtime: '@side\/jest-runtime', -setting:\r\n\r\nBumps heap size to 5778 MB ( execution time 178sec )\r\n\r\n\r\nremoving the runInBand and logHeapUsage\r\nwith   runtime: '@side\/jest-runtime', 44sec\r\nwithout   runtime: '@side\/jest-runtime',  44.613sec\r\n\r\nHowever not having --runInBand the memory usage is even more expensive and in dev ops cheap machines the computer is starwing... \r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/2021355\/bc96dafd-e67c-423e-b1fb-56d51e545b9f)\r\n","I'm starting to feel that there is some other memory leak issue as well, it feels like Jest keeps the test data in memory until the whole run is finished","@Havunen this fix (https:\/\/github.com\/nodejs\/node\/pull\/49950#event-10556827669) isn't in node 20.8.0. next week 20.9.0 should get released. maybe this fixes some of the memory problems","@ximex is the fix available in any nightly \/ preview release? I would like to test if it solves this issue","I'm not the expert for this. but i think so if you try the todays nightly version","https:\/\/github.com\/jestjs\/jest\/issues\/11956#issuecomment-1741000133","> https:\/\/github.com\/jestjs\/jest\/issues\/11956#issuecomment-1741000133\r\n\r\nI tried it but it does not seem to change anything? `runtimeSupportsVmModules` is true so it always sets the callback anyway?","If you use ESM the fix in Node won't help you, unfortunately - that is for `vm.Script` that does _not_ use `import()`.","For ESM you probably need to wait for https:\/\/github.com\/nodejs\/node\/issues\/33439 and\/or an upstream v8 proper fix for the code caching","NodeJs 20.8.0\r\n\r\nCommonJs - no changes -- 86sec 10GB RAM\r\n\r\nNodeJs 20.8.0\r\n\r\nCommonJs - +[patch ](https:\/\/github.com\/jestjs\/jest\/issues\/11956#issuecomment-1741000133) for runtimeSupportsVmModules to be undefined - 86sec 10GB RAM\r\n\r\nIt seems its not yet fixed","The fix is not released yet, you'll need to install the nightly. But I'm not sure if the commit made it in time for the nightly or if you'll have to wait until tomorrow","> The fix is not released yet, you'll need to install the nightly. But I'm not sure if the commit made it in time for the nightly or if you'll have to wait until tomorrow \r\n\r\nOk, I will try again tomorrow","> For ESM you probably need to wait for https:\/\/github.com\/nodejs\/node\/issues\/33439 and\/or an upstream v8 proper fix for the code caching\r\n\r\nBecause node js is not GCing dynamic modules, would it make sense to cache every created dynamic module to ensure only one gets created?","That would leak module state between tests ","The current situation in Node.js is:\r\n\r\n1. If you just create a lot of `SourceTextModule`s, they won't leak on their own. They are now GC-able after https:\/\/github.com\/nodejs\/node\/pull\/48510\r\n2. If you use `vm.Script` *without* the `importModuleDynamically` option, it will hit the isolate compilation cache again since https:\/\/github.com\/nodejs\/node\/pull\/49950, so won't be 100x slower than 16.x. And there should be no leaks (not that I know of).\r\n3. If you use `vm.Script` *with* the `importModuleDynamically` option, but you don't actually use `--experimental-vm-module` which means you probably couldn't do anything useful in that callback anyway, the plan is to ignore that useless callback and throw when `import()` happens, and keep the script hit the compilation cache when `import()` isn't actually called.\r\n4. If you use `vm.Script` + `importModuleDynamically` + `--experimental-vm-module`\/`SourceTextModule`, chances are the issue you are seeing is still unfixed, and it's possibly related to https:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=10284. This needs another simple repro that just uses Node.js with no other dependencies before it can be looked into.","Oooh, number 3 is perfect!\r\n\r\nWe'll have to try to come up with a minimal reproduction after these fixes are out to avoid conflating issues \ud83d\udc4d","<s>I have found an interesting detail, the problem does not occur with plain `.js` files, but only with compiled files for example `.ts`. I will create a new ticket and github repo with simple repro. Maybe we can shrink it to plain js node example<\/s>\r\n\r\nedit: nvm its not related to that.\r\n\r\nIt seems to be related to a json file and we have a lot of those in our app","I created a new issue here: https:\/\/github.com\/jestjs\/jest\/issues\/14605","FYI you can use [--heapsnapshot-near-heap-limit=3](https:\/\/nodejs.org\/api\/cli.html#--heapsnapshot-near-heap-limitmax_count) (or a higher value) to generate a bunch of heap snapshots and figure out what is leaking - at least what is leaking on the JS side. [--heap-prof](https:\/\/nodejs.org\/api\/cli.html#--heap-prof) might be useful too if heap snapshots take too long to generate. (On how to use the heap snapshots, check out https:\/\/developer.chrome.com\/docs\/devtools\/memory-problems\/heap-snapshots\/ though the UI screenshots are a bit outdated but the general idea stays the same). There are probably also some more up-to-date tutorials on how to use the Chrome DevTools to visualize these things if you search for them.","The reproduction linked above with ESM doesn't leak for me if I remove the `importModuleDynamically` option passed to `new Script` (and use the nightly). Dynamic `import` is not used, so the callback is never invoked. But ESM mode is enabled (so `SourceTextModule` and `SyntheticModule` _are_ used), meaning we cannot know if the callback will be needed or not until `import()` is actually evaluated within the module. Which can happen at any time.\r\n\r\nMaybe `importModuleDynamically` should be behind its own flag (either in Jest or in Node) separately from general ESM support.\r\n\r\nNot sure as we're of course back to the same upstream v8 issue the moment it's enabled. But this would allow lots of people who don't need `import` to be unblocked at least.\r\n\r\n---\r\n\r\nLots of `new Script` are called for Jest's own sources - there's quite a few module we evaluate within the vm context. We might be able to skip the callback for those sources... I don't think we use dynamic import for anything that's marked as internal","@joyeecheung @SimenB \r\n\r\nI have reproduced the issue using nodejs and javascript only, and also found a work around.\r\n\r\nHaving a shared context between the modules seems to leak the memory. However setting the shared context null manually after function execution it fixes the memory leak. Setting the variable null in JS is non-sense (ref: https:\/\/github.com\/Havunen\/nodejs-memory-leak\/blob\/main\/test.js#L45-L46 ) because it goes out of scope and should be GC'd but it does not seem to happen. So its definetly a nodejs \/ v8 bug\r\n\r\nhttps:\/\/github.com\/Havunen\/nodejs-memory-leak","I created an issue to nodejs repo: https:\/\/github.com\/nodejs\/node\/issues\/50113","Fantastic, thanks @Havunen! I also noticed I could get a pure nodejs thing to go OOM only when passing `context`, but my repro also needed to stick all modules in a Map, or they were GC-ed, so I thought it might be that. Great to see that's not needed","Hey there amazing folks !\r\n\r\nI know this PR is here been quite a long time, I just gave this PR a tried on Node 20.10, unfortunately it does not fix the issue. The heap memory usage still keeps piling up for each test files."],"labels":["cla signed"]},{"title":"[Feature]: Allow swc to transform jest.config.ts","body":"### \ud83d\ude80 Feature Proposal\n\nMostly similar in nature with #11989.\n\n### Motivation\n\n[`@swc\/jest`](https:\/\/github.com\/swc-project\/jest) lets you transform your files using [`swc`](https:\/\/github.com\/swc-project\/swc), so having `ts-node` as another dev dependency just to use `.ts` extension for the config file seems like a waste.\n\n### Example\n\n_No response_\n\n### Pitch\n\nProjects are already using `swc`, so I guess it fits to make it work with existing tooling","comments":["## This PR needs to be merged for this to work properly: https:\/\/github.com\/swc-project\/swc-node\/pull\/647\r\n\r\nFor those of you wanting an interim solution to this, *if you're not using ts-node at all* and only require it for `jest` config transpilation...\r\n\r\nWe can create a small `shim` that replicates the functionality of `ts-node#register`, using `@swc-node\/register`:\r\n\r\n```typescript\r\n\/\/ ts-node-shim\/package.json\r\n{\r\n  \"name\": \"ts-node-shim\",\r\n  \"version\": \"1.0.0\",\r\n  \"main\": \"index.js\",\r\n  \"license\": \"UNLICENSED\",\r\n  \"private\": true\r\n}\r\n\r\n\/\/ ts-node-shim\/index.js\r\nconst swcNode = require('@swc-node\/register\/register');\r\nmodule.exports.register = (options) => {\r\n    let revert;\r\n    return {\r\n        enabled: (enabled) => {\r\n            if (revert) { revert(): }\r\n            if (enabled === true) {\r\n                revert = swcNode.register(options);\r\n            }\r\n        }\r\n    };\r\n}\r\n```\r\n\r\nThen we alias the `ts-node` package using your package manager (`npm`, `pnpm`, `yarn`) to a local shim using `link:` or `file:`\r\n\r\n```json\r\n{\r\n   \/\/ ...other properties\r\n  \"devDependencies\": {\r\n     \/\/ ...other packages\r\n     \"ts-node\": \"link:.\/ts-node-shim\/index.js\"\r\n  }\r\n}\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Pinned"]},{"title":"[Bug]: Wrong visual diff for non-matching Symbols and Functions and matching asymmetric matcher in toHaveBeenCalledWith","body":"### Version\n\n27.3.1\n\n### Steps to reproduce\n\n```javascript\r\n  test('expected\/received diff mock fn', () => {\r\n    const mock = jest.fn()\r\n    mock({\r\n      sym: Symbol('hello'),\r\n      fn: () => 'world',\r\n      obj: {}\r\n    })\r\n\r\n    expect(mock).toHaveBeenCalledWith({\r\n      sym: Symbol('hello'),\r\n      fn: () => 'world',\r\n      obj: expect.any(Object)\r\n    })\r\n  })\r\n  ```\n\n### Expected behavior\n\n```\r\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\r\n\r\n    - Expected\r\n    + Received\r\n\r\n      Object {\r\n    -   \"fn\": [Function fn],\r\n    +   \"fn\": [Function fn],\r\n        \"obj\": Any<Object>,\r\n    -   \"sym\": Symbol(hello),\r\n    +   \"sym\": Symbol(hello),\r\n      },\r\n```\n\n### Actual behavior\n\n```\r\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\r\n\r\n    - Expected\r\n    + Received\r\n\r\n      Object {\r\n        \"fn\": [Function fn],\r\n    -   \"obj\": Any<Object>,\r\n    +   \"obj\": Object {},\r\n        \"sym\": Symbol(hello),\r\n      },\r\n```\n\n### Additional context\n\nThere's two things happening here:\r\n- The function and symbol both differ, but serialize to the same string: They are actually causing the test to fail, but are visually reported as matching.\r\n- The asymmetric matcher `expect.any(Object)` is matching, but is visually reported as failing. This seems to be the same thing as #6184.\r\n\r\nDoing the same with just `expect({ ... }).toMatchObject({ ... })` instead of `toHaveBeenCalledWith` is showing a slightly ~~more helpful~~ less misleading diff:\r\n\r\n```\r\n    Expected: {\"fn\": [Function fn], \"obj\": Any<Object>, \"sym\": Symbol(hello)}\r\n    Received: serializes to the same string\r\n```\r\n\r\nIt would be even more helpful to have the multi-line output as seen above, though - of course, only when the diff is actually correct... ;)\n\n### Environment\n\n```shell\nSystem:\r\n    OS: Linux 5.14 Alpine Linux\r\n    CPU: (32) x64 AMD Ryzen 9 3950X 16-Core Processor\r\n  Binaries:\r\n    Node: 16.11.1 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.15 - \/usr\/local\/bin\/yarn\r\n    npm: 8.0.0 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: 27.3.1 => 27.3.1\n```\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue with jest 29.3.1"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: ECMAScript Modules with multi spec can not debug","body":"### Version\n\n27.3.1\n\n### Steps to reproduce\n\nnpm  script:     {\"test\": \"NODE_OPTIONS=\\\"--experimental-vm-modules  --inspect-brk\\\" jest\"}\r\nlaunch.json \r\n```json\r\n    {\r\n      \"name\": \"test\",\r\n      \"type\": \"node\",\r\n      \"request\": \"launch\",\r\n      \"cwd\": \"${workspaceRoot}\",\r\n      \"runtimeExecutable\": \"npm\",\r\n      \"runtimeArgs\": [\"run-script\", \"test\"],\r\n      \"port\": 9229\r\n    },\r\n```\r\nwhen spec pattern match only one(not xdescribe,is one file one describe)\r\nI can debug one spec\r\nwhen spec pattern match multi will throw error and can't debug\r\n```\r\n(node:85313) UnhandledPromiseRejectionWarning: Error: You need to run with a version of node that supports ES Modules in the VM API. See https:\/\/jestjs.io\/docs\/ecmascript-modules\r\n    at invariant (\/Users\/chen\/my-project\/angular-miniprogram\/node_modules\/jest-runtime\/build\/index.js:2423:11)\r\n    at importModuleDynamically (\/Users\/chen\/my-project\/angular-miniprogram\/node_modules\/jest-runtime\/build\/index.js:1735:11)\r\n    at importModuleDynamicallyWrapper (internal\/vm\/module.js:451:21)\r\n    at exports.importModuleDynamicallyCallback (internal\/process\/esm_loader.js:30:14)\r\n    at eval (eval at <anonymous> (\/Users\/chen\/my-project\/angular-miniprogram\/src\/builder\/util\/load_esm.ts:2:33), <anonymous>:3:1)\r\n    at \/Users\/chen\/my-project\/angular-miniprogram\/src\/builder\/util\/load_esm.ts:5:4\r\n    at Generator.next (<anonymous>)\r\n    at \/Users\/chen\/my-project\/angular-miniprogram\/src\/builder\/util\/load_esm.ts:8:71\r\n    at new Promise (<anonymous>)\r\n    at Object.<anonymous>.__awaiter (\/Users\/chen\/my-project\/angular-miniprogram\/src\/builder\/util\/load_esm.ts:4:12)\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n(node:85313) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https:\/\/nodejs.org\/api\/cli.html#cli_unhandled_rejections_mode). (rejection id: 6)\r\n(node:85313) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n```\r\nbut I add `--experimental-vm-modules` flag and run success on one spec one describe.\n\n### Expected behavior\n\nmulti spec file also run success\n\n### Actual behavior\n\nonly match one spec can run success\n\n### Additional context\n\n_No response_\n\n### Environment\n\n```shell\nSystem:\r\n    OS: macOS 11.1\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz\r\n  Binaries:\r\n    Node: 14.17.1 - ~\/.nvm\/versions\/node\/v14.17.1\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.13 - ~\/.nvm\/versions\/node\/v14.17.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.3.1 => 27.3.1\n```\n","comments":["Sorry, I don't follow to example. Could you put together a reproduction I can pull down and run?","```ts\r\n\/\/b.spec.ts\r\nimport { angularCompilerPromise, getAngularCompiler } from \".\/load_esm\";\r\ndescribe(\"aaaa\", () => {\r\n  it(\"bbbb\", async () => {\r\n    let result = await getAngularCompiler();\r\n    console.log(result);\r\n    console.log(\"222\");\r\n  });\r\n});\r\n\r\n```\r\n```ts\r\n\/\/ a.spec.ts\r\ndescribe(\"\", () => {\r\n  it(\"\", () => {\r\n    console.log(\"111\");\r\n  });\r\n});\r\n```\r\n\r\n```ts\r\n\/\/load_esm.ts\r\nexport async function loadEsmModule<T>(modulePath: string): Promise<T> {\r\n  const namespaceObject = await new Function(\"modulePath\", `return import(modulePath);`)(modulePath);\r\n\r\n  \/\/ If it is not ESM then the values needed will be stored in the `default` property.\r\n  \/\/ TODO_ESM: This can be removed once `@angular\/*` packages are ESM only.\r\n  if (namespaceObject.default) {\r\n    return namespaceObject.default;\r\n  } else {\r\n    return namespaceObject;\r\n  }\r\n}\r\n\r\nexport function getAngularCompiler() {\r\n  return loadEsmModule<any>(\"@angular\/compiler\");\r\n}\r\nexport const angularCompilerPromise = getAngularCompiler();\r\nexport const angularCompilerCliPromise = loadEsmModule<any>(\"@angular\/compiler-cli\");\r\n\r\n```\r\n\r\n```ts\r\n\/\/jest.config.ts\r\nexport default {\r\n  clearMocks: true,\r\n  collectCoverage: true,\r\n  coverageDirectory: \"coverage\",\r\n  coverageProvider: \"v8\",\r\n  moduleFileExtensions: [\"js\", \"ts\"],\r\n  transform: {\r\n    \"^.+\\\\.(t|j)s$\": \"ts-jest\",\r\n  },\r\n  testRunner: \"jasmine2\",\r\n};\r\n```\r\n```json\r\n  \"scripts\": {\r\n    \"test\": \"NODE_OPTIONS=\\\"--experimental-vm-modules  --inspect-brk\\\" jest\",\r\n  },\r\n```\r\nwhen delete `a.spec.ts`. I can debug(with inspec-brk) and run success","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Getting same issue","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"[Bug]: toThrow discards non-Error objects when used with promises, while accepting them in synchronuous code","body":"### Version\n\n26.4.2\n\n### Steps to reproduce\n\n```\r\ndescribe(\"set\", () => {\r\n\ttest(\"syncTest\", () => {\r\n\t\texpect(\r\n\t\t\t() => {throw {message: \"testval\"};}\r\n\t\t)\r\n\t\t\t.toThrow(\"testval\");\r\n\t});\r\n\ttest(\"asyncTest\", async () => {\r\n\t\tawait expect(\r\n\t\t\tasync () => {throw {message: \"testval\"};}\r\n\t\t).rejects\r\n\t\t\t.toThrow(\"testval\");\r\n\t});\r\n});\r\n```\r\nrun these tests\n\n### Expected behavior\n\nI expect both tests to succeed. Alternatively, I would expect both tests to fail, as they are doing the same, +- the use of Promise.\n\n### Actual behavior\n\nSynchronous (non-promise) tests succeeds, asynchronous tests fails with a misleading error `Received function did not throw`.\r\n\r\nThis happens because of https:\/\/github.com\/facebook\/jest\/pull\/5670 merged in https:\/\/github.com\/facebook\/jest\/commit\/27a1dc659dd3f2c91efb106961a5d0c640a1085b, which added a condition (a I will be linking code from latest version) https:\/\/github.com\/facebook\/jest\/blob\/01c278019726d7b01c924dd185e10b79a1f97610\/packages\/expect\/src\/toThrowMatchers.ts#L93-L95 that the rejection-reason must be an Error, https:\/\/github.com\/facebook\/jest\/blob\/01c278019726d7b01c924dd185e10b79a1f97610\/packages\/expect\/src\/utils.ts#L376-L384 otherwise the `received` is plainly ignored and `thrown` is kept just initialized to null, and the code path continues as if the reason was null. Later on, an internal function (in this specific case `toThrowExpectedString`) is called, and see `thrown` to be null and fails the matcher with the mentioned misleading error `Received function did not throw`.\r\n\r\nNote that the synchronous code path, where the `received` is a function (passed to expect()) to be called and which should throw, does not have any such condition!:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/01c278019726d7b01c924dd185e10b79a1f97610\/packages\/expect\/src\/toThrowMatchers.ts#L108-L112\r\n\r\nThe full code: https:\/\/github.com\/facebook\/jest\/blob\/01c278019726d7b01c924dd185e10b79a1f97610\/packages\/expect\/src\/toThrowMatchers.ts#L91-L114\n\n### Additional context\n\nIt is completely legal to throw \"non-Errors\" (see the implementation of the isError check above) in JS, and the toThrow Jest API does not document that the thrown object\/rejection must satisfy any special conditions _(currently implemented to have Error in prot chain or has an overloaded toStringTag \/ be a special native object to satisfy the Object.prototype.toString test)_.\r\n\r\nIn my case, I am working with production code that has custom exceptions that do not have Error in their prototype chain, but they are compliant with the Error (typescript) interface. Jest toThrow was working flawlessly for synchronous code with them, but I got really puzzled when I tried to use it with async code! \r\n\r\nI propose to simply drop the `isError` check, as there is no technical need for it and the presence of that check is counter intuitive.\r\nI was reading through https:\/\/github.com\/facebook\/jest\/pull\/5670 which did not indicate any reason for this addition expect linking to older https:\/\/github.com\/facebook\/jest\/pull\/4884#issue-152281796 (to a specific comment that does not show up to me?), which also does not mention anyting about a need to limit this functionality only to \"Error  instances\" - https:\/\/github.com\/facebook\/jest\/pull\/4884 mainly fixes the matcher itself to work correctly in promise\/async variants and updates docs to use an example with Error (which I think was good because it teaches good practices) instead of string. \r\nhttps:\/\/github.com\/facebook\/jest\/pull\/4884 links to an older https:\/\/github.com\/facebook\/jest\/issues\/3601 which initally added promise\/async support to all matches, but it did not work correctly for toThrow.\r\n\r\nTagging @peterdanis , an author of https:\/\/github.com\/facebook\/jest\/pull\/5670 which caused this inconsistency.\n\n### Environment\n\n```shell\nirrelevant\n```\n","comments":["I am very sorry for any inconvenience caused. To be honest, `.toThrow` matcher does not make much sense in terms of async code, as in the end there is no way (at least I am not aware of any) to distinguish between throwing and simply rejecting the promise.\r\n\r\nWithout `isError` check `toThrow` matcher would be the same as `toBe` \/ `toEqual` matchers, checking whether resolved\/rejected value matches expected value (before #5670 it even worked on `resolves.toThrow`).\r\n\r\nIn your case you can use `rejects.toBe` \/ `rejects.toEqual` instead, but I agree with you that I should have documented that `rejects.toThrow` chain expects an actual `Error` object to be thrown.\r\n\r\n\r\n\r\n","First, let me thank you for a superb fast reaction!\r\n\r\n> To be honest, .toThrow matcher does not make much sense in terms of async code, as in the end there is no way (at least I am not aware of any) to distinguish between throwing and simply rejecting the promise.\r\n\r\nRight, I am also not aware of  a way to distinguish whether something from within async function throw an exception which triggered a rejection of the implicit promise, or if it there was a non-async function returning (in the future) rejected Promise. \r\nBut with the uptake of async\/await that's exactly why I would expect `reejcts.toThrow` to work the same way as if it works with a synchronous function throwing trough call-stack.\r\n\r\n> Without isError check toThrow matcher would be the same as toBe \/ toEqual matchers, checking whether resolved\/rejected value matches expected value ...\r\n\r\nNot true AFAIK!. It actually has it's own logic https:\/\/github.com\/facebook\/jest\/blob\/01c278019726d7b01c924dd185e10b79a1f97610\/packages\/expect\/src\/toThrowMatchers.ts#L116-L141 to compare the thrown object\/rejection \"reason\", based on what is pass in the \"expected\" value. If it's string, it compares it with `message` property of the thrown object. If it's object, it compares its `message` property with that property on the thrown `object`, there is variant with prototype check... \r\n\r\nIf these are valid use-cases for \"non-errors\" in the synchronous `toThrow` (without isError restriction), I don't see why they should be invalid for \"non-errors\" in the `rejects.toThrow`. Am I missing something?\r\n\r\n>  (before #5670 it even worked on resolves.toThrow)\r\n\r\nFrom the diff, I would assume that \r\n`await expect(\r\n\t\t\tasync () => {throw new Error()}\r\n\t\t).resolves\r\n\t\t\t.toThrow(Error);`\r\nstill worked after it that change?\r\nIf the problem is that `fromPromise` is set equally by `.resolves` and `.rejects`, I would suggest we make a \"better fix\" \ud83d\udc4d.\r\n\r\n> but I agree with you that I should have documented that rejects.toThrow chain expects an actual Error object to be thrown.\r\n\r\nFrankly, I haven't known about Jest at that time, but I still don't see a point for a) doing change at all b) doing it just for the async case. I would make it at least less surprising if it would be done as a breaking change for the synchronous `toThrow` too back in the day....","\/\/edited:\r\n\r\nI would like to add that after some more playing with the toThrow matcher, it's capability, which is actually also listed here: https:\/\/jestjs.io\/docs\/expect#tothrowerror (I tried to reverse engineer it in the previous message), is very limited, so I will likely aim for a custom matcher that is able to check something else then the message! (that's actually easier with async flow, just `.rejects.toMatchObject(..)` for example)\r\n\r\nIt seems I hit the same thing as https:\/\/github.com\/facebook\/jest\/issues\/8140 :\/","I was just bitten by this, and being a JS noob, spent too many hours assuming the problem was somewhere in my code-under-test.\r\n\r\nIf code changes are out of consideration, could we please at least update the Jest docs to make the `Error` requirement explicit, and recommend `.rejects.toBe()\/toEqual()` for handling \"general\" (i.e., possibly non-`Error`) exceptions? Happy to make a docs PR for this if there's some chance it will be merged. Thanks!","> In your case you can use rejects.toBe \/ rejects.toEqual instead, but I agree with you that I should have documented that rejects.toThrow chain expects an actual Error object to be thrown.\r\n\r\nAlso the message should be changed from the absolutely misleading \"Received function did not throw\" to something else.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I encountered the same issue. It would be nice to fix it or at least document it.","This error cost me some time debugging. \ud83d\ude2d"],"labels":["Needs Triage","Bug Report"]},{"title":"feat(snapshot): support snapshotResolver and snapshotSerializers written in ESM","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\nPart of #11167.\r\n\r\nSee the discussion on the `snapshotResolver` and  `snapshotSerializers` config: https:\/\/github.com\/facebook\/jest\/issues\/11167#issuecomment-953569252 https:\/\/github.com\/facebook\/jest\/issues\/11167#issuecomment-953585698\r\n\r\n## Test plan\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n\r\nIntegration test added.\r\n","comments":["@chentsulin I wonder if this could be finalized or if it is waiting for a re-review from @SimenB ?...\r\n\r\nWe need this here: https:\/\/github.com\/Maxim-Mazurok\/google-api-typings-generator\/blob\/062854a2021be2dd244855261a73f5172bf597c2\/custom-resolver.cjs for the use-case of using one snapshot file per test.\r\n\r\nThank you!","Main issue is that we load the resolver _within_ the tests (https:\/\/github.com\/facebook\/jest\/pull\/12014#discussion_r739624598), which means it's pretty much blocked by full ESM support","Ah, I see, thank you for the update, we [are re-considering](https:\/\/github.com\/Maxim-Mazurok\/google-api-typings-generator\/pull\/706#pullrequestreview-1123564900) our approach now. Cheers!","It might make sense to not load it within, but that means people who have written it in TS or something that requires transpilation will fail. So not sure which tradeoff is the best here","It's been a year. Any updates?"],"labels":["cla signed"]},{"title":"[Bug]: yarn test fails on main branch: unable to resolve path to module","body":"### Version\r\n\r\nmain branch\r\n\r\n### Steps to reproduce\r\n\r\n1. On a Windows (10) machine\r\n2. Follow the instructions in [CONTRIBUTING.md](https:\/\/github.com\/facebook\/jest\/blob\/main\/CONTRIBUTING.md)\r\n    1. Clone Jest's repository\r\n    2. (install nodejs & yarn & python if needed)\r\n    3. Run `yarn install`\r\n    4. Run `yarn build`\r\n    5. Run `yarn test`\r\n3. `yarn test` fails with many errors from eslint import\/no-unresolved in various files in `\/packages` and `\/test-types` directories (\"Unable to resolve path to module\")\r\n\r\n### Expected behavior\r\n\r\nAfter following CONTRIBUTING.md I expect to be able to run `yarn test` and the tests to pass\r\n\r\n### Actual behavior\r\n\r\n`yarn test` fails with many errors from eslint import\/no-unresolved in various files in `\/packages` and `\/test-types` subdirectories (\"Unable to resolve path to module\")\r\n\r\n### Additional context\r\n\r\n```\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest>yarn test\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\e2e\\transform-linked-modules\\ignored\\symlink.js\r\n  1:0  error  Parsing error: Declaration or statement expected\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\babel-jest\\src\\index.ts\r\n  22:8   error  Unable to resolve path to module '@jest\/transform'  import\/no-unresolved\r\n  23:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\asymmetricMatchers.ts\r\n  9:31  error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\extractExpectedAssertionsErrors.ts\r\n  14:8  error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\index.ts\r\n  11:31  error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\matchers.ts\r\n  11:36  error  Unable to resolve path to module 'jest-get-type'       import\/no-unresolved\r\n  29:8   error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\print.ts\r\n  17:8  error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\spyMatchers.ts\r\n   8:36  error  Unable to resolve path to module 'jest-get-type'       import\/no-unresolved\r\n  23:8   error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\toThrowMatchers.ts\r\n  21:8   error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n  22:58  error  Unable to resolve path to module 'jest-message-util'   import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\types.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'         import\/no-unresolved\r\n  10:40  error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\expect\\src\\utils.ts\r\n  11:27  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-changed-files\\src\\git.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-changed-files\\src\\hg.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-changed-files\\src\\index.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-changed-files\\src\\types.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\eventHandler.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\formatNodeAssertErrors.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'         import\/no-unresolved\r\n  16:8   error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n  17:38  error  Unable to resolve path to module 'pretty-format'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\globalErrorHandlers.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\index.ts\r\n   8:35  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n   9:32  error  Unable to resolve path to module 'jest-each'    import\/no-unresolved\r\n  10:41  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\legacy-code-todo-rewrite\\jestAdapter.ts\r\n   8:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n   9:46  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  10:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  11:26  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  12:38  error  Unable to resolve path to module 'jest-snapshot'      import\/no-unresolved\r\n  13:30  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\legacy-code-todo-rewrite\\jestAdapterInit.ts\r\n   9:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  16:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  17:43  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  18:67  error  Unable to resolve path to module 'expect'             import\/no-unresolved\r\n  19:20  error  Unable to resolve path to module 'jest-each'          import\/no-unresolved\r\n  20:52  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  26:8   error  Unable to resolve path to module 'jest-snapshot'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\legacy-code-todo-rewrite\\jestExpect.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  16:8   error  Unable to resolve path to module 'jest-snapshot'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\run.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\state.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\testCaseReportHandler.ts\r\n  8:34  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\types.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-circus\\src\\utils.ts\r\n  14:44  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  15:35  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  16:69  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  17:38  error  Unable to resolve path to module 'pretty-format'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-cli\\src\\cli\\args.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  9:39  error  Unable to resolve path to module 'jest-config'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-cli\\src\\cli\\index.ts\r\n  12:34  error  Unable to resolve path to module '@jest\/core'         import\/no-unresolved\r\n  13:37  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  14:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  15:34  error  Unable to resolve path to module 'jest-config'        import\/no-unresolved\r\n  16:38  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  17:34  error  Unable to resolve path to module 'jest-validate'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-cli\\src\\init\\generateConfigFile.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  9:38  error  Unable to resolve path to module 'jest-config'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-cli\\src\\init\\index.ts\r\n  12:25  error  Unable to resolve path to module 'jest-config'  import\/no-unresolved\r\n  13:27  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-cli\\src\\init\\types.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\Defaults.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n  11:38  error  Unable to resolve path to module 'jest-regex-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\Deprecated.ts\r\n   9:38  error  Unable to resolve path to module 'jest-validate'  import\/no-unresolved\r\n  10:38  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\Descriptions.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\ReporterValidationErrors.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  10:23  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n  11:31  error  Unable to resolve path to module 'jest-validate'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\ValidConfig.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n   9:38  error  Unable to resolve path to module 'jest-regex-util'  import\/no-unresolved\r\n  10:36  error  Unable to resolve path to module 'jest-validate'    import\/no-unresolved\r\n  11:57  error  Unable to resolve path to module 'pretty-format'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\getCacheDirectory.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  11:27  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\getMaxWorkers.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\index.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'   import\/no-unresolved\r\n  12:27  error  Unable to resolve path to module 'jest-util'     import\/no-unresolved\r\n  20:60  error  Unable to resolve path to module 'jest-resolve'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\normalize.ts\r\n  15:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n  16:38  error  Unable to resolve path to module 'jest-regex-util'  import\/no-unresolved\r\n  22:8   error  Unable to resolve path to module 'jest-resolve'     import\/no-unresolved\r\n  28:8   error  Unable to resolve path to module 'jest-util'        import\/no-unresolved\r\n  29:41  error  Unable to resolve path to module 'jest-validate'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\readConfigFileAndSetRootDir.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  12:60  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\resolveConfigPath.ts\r\n  12:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\setFromArgv.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-config\\src\\utils.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  11:22  error  Unable to resolve path to module 'jest-resolve'   import\/no-unresolved\r\n  12:31  error  Unable to resolve path to module 'jest-validate'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-console\\src\\BufferedConsole.ts\r\n  12:42  error  Unable to resolve path to module 'jest-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-console\\src\\CustomConsole.ts\r\n  12:37  error  Unable to resolve path to module 'jest-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-console\\src\\getConsoleOutput.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  14:8   error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\FailedTestsCache.ts\r\n  8:37  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\FailedTestsInteractiveMode.ts\r\n  10:56  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  11:39  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  12:20  error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\ReporterDispatcher.ts\r\n  10:53  error  Unable to resolve path to module '@jest\/reporters'    import\/no-unresolved\r\n  16:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  17:28  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\SearchSource.ts\r\n  11:25  error  Unable to resolve path to module '@jest\/test-result'          import\/no-unresolved\r\n  12:27  error  Unable to resolve path to module '@jest\/types'                import\/no-unresolved\r\n  13:33  error  Unable to resolve path to module 'jest-changed-files'         import\/no-unresolved\r\n  14:36  error  Unable to resolve path to module 'jest-config'                import\/no-unresolved\r\n  15:34  error  Unable to resolve path to module 'jest-regex-util'            import\/no-unresolved\r\n  16:34  error  Unable to resolve path to module 'jest-resolve-dependencies'  import\/no-unresolved\r\n  17:28  error  Unable to resolve path to module 'jest-runtime'               import\/no-unresolved\r\n  18:37  error  Unable to resolve path to module 'jest-snapshot'              import\/no-unresolved\r\n  19:55  error  Unable to resolve path to module 'jest-util'                  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\SnapshotInteractiveMode.ts\r\n  10:56  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  11:39  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  12:20  error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\TestNamePatternPrompt.ts\r\n   8:31  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  15:8   error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\TestPathPatternPrompt.ts\r\n   8:25  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n   9:28  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  16:8   error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\TestScheduler.ts\r\n  19:8   error  Unable to resolve path to module '@jest\/reporters'    import\/no-unresolved\r\n  28:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  29:39  error  Unable to resolve path to module '@jest\/transform'    import\/no-unresolved\r\n  30:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  31:31  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  32:29  error  Unable to resolve path to module 'jest-runner'        import\/no-unresolved\r\n  33:28  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  35:37  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\cli\\index.ts\r\n  11:29  error  Unable to resolve path to module '@jest\/console'       import\/no-unresolved\r\n  12:37  error  Unable to resolve path to module '@jest\/test-result'   import\/no-unresolved\r\n  13:27  error  Unable to resolve path to module '@jest\/types'         import\/no-unresolved\r\n  14:40  error  Unable to resolve path to module 'jest-changed-files'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module 'jest-config'         import\/no-unresolved\r\n  16:27  error  Unable to resolve path to module 'jest-haste-map'      import\/no-unresolved\r\n  17:32  error  Unable to resolve path to module 'jest-runtime'        import\/no-unresolved\r\n  18:46  error  Unable to resolve path to module 'jest-util'           import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\collectHandles.ts\r\n  13:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  14:31  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  15:30  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getChangedFilesPromise.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'         import\/no-unresolved\r\n  10:60  error  Unable to resolve path to module 'jest-changed-files'  import\/no-unresolved\r\n  11:31  error  Unable to resolve path to module 'jest-message-util'   import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getConfigsOfProjectsToRun.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getNoTestFound.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getNoTestFoundFailed.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  10:29  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getNoTestFoundRelatedToChangedFiles.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  10:29  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getNoTestFoundVerbose.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getNoTestsFoundMessage.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getProjectDisplayName.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getProjectNamesMissingWarning.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\getSelectProjectsMessage.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\activeFiltersMessage.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\createContext.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'     import\/no-unresolved\r\n   9:35  error  Unable to resolve path to module 'jest-haste-map'  import\/no-unresolved\r\n  10:32  error  Unable to resolve path to module 'jest-runtime'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\handleDeprecationWarnings.ts\r\n  9:20  error  Unable to resolve path to module 'jest-watcher'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\isValidPath.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  9:30  error  Unable to resolve path to module 'jest-snapshot'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\logDebugMessages.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\updateGlobalConfig.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n   9:38  error  Unable to resolve path to module 'jest-regex-util'  import\/no-unresolved\r\n  10:41  error  Unable to resolve path to module 'jest-watcher'     import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\lib\\watchPluginsHelpers.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'   import\/no-unresolved\r\n  9:43  error  Unable to resolve path to module 'jest-watcher'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\plugins\\FailedTestsInteractive.ts\r\n   8:56  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n   9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  15:8   error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\plugins\\Quit.ts\r\n  8:42  error  Unable to resolve path to module 'jest-watcher'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\plugins\\TestNamePattern.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'   import\/no-unresolved\r\n  14:8   error  Unable to resolve path to module 'jest-watcher'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\plugins\\TestPathPattern.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'   import\/no-unresolved\r\n  14:8   error  Unable to resolve path to module 'jest-watcher'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\plugins\\UpdateSnapshots.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'   import\/no-unresolved\r\n  14:8   error  Unable to resolve path to module 'jest-watcher'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\plugins\\UpdateSnapshotsInteractive.ts\r\n  10:56  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  11:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  12:62  error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\runGlobalHook.ts\r\n   9:25  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  10:39  error  Unable to resolve path to module '@jest\/transform'    import\/no-unresolved\r\n  11:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  12:26  error  Unable to resolve path to module 'pretty-format'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\runJest.ts\r\n  12:29  error  Unable to resolve path to module '@jest\/console'         import\/no-unresolved\r\n  19:8   error  Unable to resolve path to module '@jest\/test-result'     import\/no-unresolved\r\n  20:32  error  Unable to resolve path to module '@jest\/test-sequencer'  import\/no-unresolved\r\n  21:27  error  Unable to resolve path to module '@jest\/types'           import\/no-unresolved\r\n  22:54  error  Unable to resolve path to module 'jest-changed-files'    import\/no-unresolved\r\n  23:22  error  Unable to resolve path to module 'jest-resolve'          import\/no-unresolved\r\n  24:28  error  Unable to resolve path to module 'jest-runtime'          import\/no-unresolved\r\n  25:50  error  Unable to resolve path to module 'jest-util'             import\/no-unresolved\r\n  26:41  error  Unable to resolve path to module 'jest-watcher'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\testSchedulerHelper.ts\r\n  8:25  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\types.ts\r\n   8:25  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n   9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  10:28  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-core\\src\\watch.ts\r\n  13:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  17:8   error  Unable to resolve path to module 'jest-haste-map'     import\/no-unresolved\r\n  18:31  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  19:28  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  25:8   error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  26:31  error  Unable to resolve path to module 'jest-validate'      import\/no-unresolved\r\n  33:8   error  Unable to resolve path to module 'jest-watcher'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-create-cache-key-function\\src\\index.ts\r\n  13:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-diff\\src\\diffLines.ts\r\n  8:18  error  Unable to resolve path to module 'diff-sequences'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-diff\\src\\diffStrings.ts\r\n  8:27  error  Unable to resolve path to module 'diff-sequences'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-diff\\src\\index.ts\r\n   9:23  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n  13:8   error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n  14:40  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-diff\\src\\normalizeDiffOptions.ts\r\n  9:32  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-diff\\src\\types.ts\r\n  7:32  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-each\\src\\bind.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  10:30  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-each\\src\\index.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-each\\src\\table\\array.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  11:32  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-each\\src\\table\\interpolation.ts\r\n   9:27  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n  10:32  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-each\\src\\table\\template.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-each\\src\\validation.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  11:32  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-environment-jsdom\\src\\index.ts\r\n  10:56  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  11:50  error  Unable to resolve path to module '@jest\/fake-timers'  import\/no-unresolved\r\n  12:35  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  13:28  error  Unable to resolve path to module 'jest-mock'          import\/no-unresolved\r\n  14:36  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-environment-node\\src\\index.ts\r\n   9:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  10:50  error  Unable to resolve path to module '@jest\/fake-timers'  import\/no-unresolved\r\n  11:35  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  12:28  error  Unable to resolve path to module 'jest-mock'          import\/no-unresolved\r\n  13:36  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-environment\\src\\index.ts\r\n   9:55  error  Unable to resolve path to module '@jest\/fake-timers'  import\/no-unresolved\r\n  10:43  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  15:8   error  Unable to resolve path to module 'jest-mock'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-fake-timers\\src\\legacyFakeTimers.ts\r\n  11:50  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  12:33  error  Unable to resolve path to module 'jest-mock'          import\/no-unresolved\r\n  13:25  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-fake-timers\\src\\modernFakeTimers.ts\r\n  13:50  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-globals\\src\\index.ts\r\n  8:25  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-haste-map\\src\\HasteFS.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  9:53  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-haste-map\\src\\ModuleMap.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-haste-map\\src\\crawlers\\watchman.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-haste-map\\src\\index.ts\r\n  16:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n  17:34  error  Unable to resolve path to module 'jest-regex-util'  import\/no-unresolved\r\n  18:24  error  Unable to resolve path to module 'jest-serializer'  import\/no-unresolved\r\n  19:22  error  Unable to resolve path to module 'jest-worker'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-haste-map\\src\\types.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\assertionErrorMessage.ts\r\n  14:8  error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\each.ts\r\n  8:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  9:32  error  Unable to resolve path to module 'jest-each'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\errorOnPrivate.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  9:30  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\expectationResultFactory.ts\r\n  8:36  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  9:38  error  Unable to resolve path to module 'pretty-format'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\index.ts\r\n   9:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  10:27  error  Unable to resolve path to module '@jest\/source-map'   import\/no-unresolved\r\n  11:48  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  12:35  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  13:26  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  14:38  error  Unable to resolve path to module 'jest-snapshot'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\isError.ts\r\n  8:38  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\jasmineAsyncInstall.ts\r\n  16:35  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\jasmine\\Env.ts\r\n  34:41  error  Unable to resolve path to module 'jest-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\jasmine\\Spec.ts\r\n  34:58  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  35:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\jasmine\\Suite.ts\r\n  34:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  35:41  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\jestExpect.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  18:8   error  Unable to resolve path to module 'jest-snapshot'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\queueRunner.ts\r\n  8:26  error  Unable to resolve path to module 'jest-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\reporter.ts\r\n  12:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  13:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  14:35  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\setup_jest_globals.ts\r\n   8:35  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n   9:67  error  Unable to resolve path to module 'expect'         import\/no-unresolved\r\n  15:8   error  Unable to resolve path to module 'jest-snapshot'  import\/no-unresolved\r\n  16:27  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-jasmine2\\src\\types.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-leak-detector\\src\\index.ts\r\n  13:27  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n  14:38  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-matcher-utils\\src\\Replaceable.ts\r\n  8:23  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-matcher-utils\\src\\deepCyclicCopyReplaceable.ts\r\n  8:23  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-matcher-utils\\src\\index.ts\r\n  20:8   error  Unable to resolve path to module 'jest-diff'      import\/no-unresolved\r\n  21:36  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n  25:8   error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-message-util\\src\\index.ts\r\n  15:39  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  16:38  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-phabricator\\src\\index.ts\r\n  8:37  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-repl\\src\\cli\\index.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  12:34  error  Unable to resolve path to module 'jest-config'    import\/no-unresolved\r\n  13:34  error  Unable to resolve path to module 'jest-validate'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-repl\\src\\cli\\repl.ts\r\n  14:36  error  Unable to resolve path to module '@jest\/transform'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n  16:37  error  Unable to resolve path to module 'jest-util'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-repl\\src\\cli\\runtime-cli.ts\r\n  12:29  error  Unable to resolve path to module '@jest\/console'      import\/no-unresolved\r\n  13:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  14:39  error  Unable to resolve path to module '@jest\/transform'    import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  16:46  error  Unable to resolve path to module 'jest-config'        import\/no-unresolved\r\n  17:21  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  18:38  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  19:34  error  Unable to resolve path to module 'jest-validate'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\BaseReporter.ts\r\n  12:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  13:29  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\CoverageReporter.ts\r\n  24:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  25:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  26:40  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  27:22  error  Unable to resolve path to module 'jest-worker'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\CoverageWorker.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\DefaultReporter.ts\r\n   9:32  error  Unable to resolve path to module '@jest\/console'      import\/no-unresolved\r\n  14:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  16:40  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\NotifyReporter.ts\r\n  11:37  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  12:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  13:25  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\Status.ts\r\n  14:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\SummaryReporter.ts\r\n   9:54  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  10:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  11:39  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\VerboseReporter.ts\r\n  14:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  16:40  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\generateEmptyCoverage.ts\r\n  12:57  error  Unable to resolve path to module '@jest\/transform'  import\/no-unresolved\r\n  13:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\getResultHeader.ts\r\n  10:31  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  11:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  12:26  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\getSnapshotStatus.ts\r\n   9:31  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  10:25  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\getSnapshotSummary.ts\r\n   9:36  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  10:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  11:25  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\getWatermarks.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\index.ts\r\n  17:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  22:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\types.ts\r\n  13:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  14:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  15:45  error  Unable to resolve path to module 'jest-haste-map'     import\/no-unresolved\r\n  16:27  error  Unable to resolve path to module 'jest-resolve'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-reporters\\src\\utils.ts\r\n  11:53  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  12:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  13:37  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve-dependencies\\src\\index.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'     import\/no-unresolved\r\n  10:34  error  Unable to resolve path to module 'jest-haste-map'  import\/no-unresolved\r\n  11:61  error  Unable to resolve path to module 'jest-resolve'    import\/no-unresolved\r\n  12:48  error  Unable to resolve path to module 'jest-snapshot'   import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\ModuleNotFoundError.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\defaultResolver.ts\r\n  15:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\fileWalkers.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  11:27  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\nodeModulesPaths.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n  12:27  error  Unable to resolve path to module 'jest-util'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\resolver.ts\r\n  13:27  error  Unable to resolve path to module '@jest\/types'     import\/no-unresolved\r\n  14:31  error  Unable to resolve path to module 'jest-haste-map'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module 'jest-util'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\shouldLoadAsEsm.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\types.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-resolve\\src\\utils.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  11:31  error  Unable to resolve path to module 'jest-validate'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runner\\src\\index.ts\r\n  18:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  19:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  20:30  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n  21:48  error  Unable to resolve path to module 'jest-worker'        import\/no-unresolved\r\n  34:52  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runner\\src\\runTest.ts\r\n  19:8   error  Unable to resolve path to module '@jest\/console'       import\/no-unresolved\r\n  20:36  error  Unable to resolve path to module '@jest\/environment'   import\/no-unresolved\r\n  21:46  error  Unable to resolve path to module '@jest\/test-result'   import\/no-unresolved\r\n  22:39  error  Unable to resolve path to module '@jest\/transform'     import\/no-unresolved\r\n  23:27  error  Unable to resolve path to module '@jest\/types'         import\/no-unresolved\r\n  24:27  error  Unable to resolve path to module 'jest-docblock'       import\/no-unresolved\r\n  25:26  error  Unable to resolve path to module 'jest-leak-detector'  import\/no-unresolved\r\n  26:31  error  Unable to resolve path to module 'jest-message-util'   import\/no-unresolved\r\n  27:48  error  Unable to resolve path to module 'jest-resolve'        import\/no-unresolved\r\n  28:31  error  Unable to resolve path to module 'jest-runtime'        import\/no-unresolved\r\n  29:64  error  Unable to resolve path to module 'jest-util'           import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runner\\src\\testWorker.ts\r\n  14:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  15:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  16:47  error  Unable to resolve path to module 'jest-haste-map'     import\/no-unresolved\r\n  17:40  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  18:27  error  Unable to resolve path to module 'jest-resolve'       import\/no-unresolved\r\n  19:21  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n  20:29  error  Unable to resolve path to module 'jest-worker'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runner\\src\\types.ts\r\n   9:36  error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  15:8   error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  16:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  17:30  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runtime\\src\\helpers.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runtime\\src\\index.ts\r\n  32:8   error  Unable to resolve path to module '@jest\/environment'  import\/no-unresolved\r\n  33:55  error  Unable to resolve path to module '@jest\/fake-timers'  import\/no-unresolved\r\n  34:35  error  Unable to resolve path to module '@jest\/globals'      import\/no-unresolved\r\n  35:38  error  Unable to resolve path to module '@jest\/source-map'   import\/no-unresolved\r\n  36:61  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  45:8   error  Unable to resolve path to module '@jest\/transform'    import\/no-unresolved\r\n  46:35  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  47:31  error  Unable to resolve path to module 'jest-haste-map'     import\/no-unresolved\r\n  48:22  error  Unable to resolve path to module 'jest-haste-map'     import\/no-unresolved\r\n  49:58  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  50:55  error  Unable to resolve path to module 'jest-mock'          import\/no-unresolved\r\n  51:34  error  Unable to resolve path to module 'jest-regex-util'    import\/no-unresolved\r\n  52:45  error  Unable to resolve path to module 'jest-resolve'       import\/no-unresolved\r\n  54:47  error  Unable to resolve path to module 'jest-util'          import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-runtime\\src\\types.ts\r\n   8:27  error  Unable to resolve path to module '@jest\/types'     import\/no-unresolved\r\n   9:45  error  Unable to resolve path to module 'jest-haste-map'  import\/no-unresolved\r\n  10:27  error  Unable to resolve path to module 'jest-resolve'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\InlineSnapshots.ts\r\n  17:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  18:26  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\SnapshotResolver.ts\r\n  10:40  error  Unable to resolve path to module '@jest\/transform'  import\/no-unresolved\r\n  11:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n  12:37  error  Unable to resolve path to module 'jest-util'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\State.ts\r\n   9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n  10:47  error  Unable to resolve path to module 'jest-message-util'  import\/no-unresolved\r\n  11:59  error  Unable to resolve path to module 'pretty-format'      import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\index.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'         import\/no-unresolved\r\n  12:34  error  Unable to resolve path to module 'jest-haste-map'      import\/no-unresolved\r\n  22:8   error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\mockSerializer.ts\r\n  8:30  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\plugins.ts\r\n  12:8  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\printSnapshot.ts\r\n  15:31  error  Unable to resolve path to module 'expect\/build\/utils'  import\/no-unresolved\r\n  26:8   error  Unable to resolve path to module 'jest-diff'           import\/no-unresolved\r\n  27:36  error  Unable to resolve path to module 'jest-get-type'       import\/no-unresolved\r\n  36:8   error  Unable to resolve path to module 'jest-matcher-utils'  import\/no-unresolved\r\n  37:38  error  Unable to resolve path to module 'pretty-format'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\types.ts\r\n  10:33  error  Unable to resolve path to module 'expect'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-snapshot\\src\\utils.ts\r\n  12:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n  16:8   error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-test-result\\src\\helpers.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-test-result\\src\\types.ts\r\n  10:34  error  Unable to resolve path to module '@jest\/console'   import\/no-unresolved\r\n  11:55  error  Unable to resolve path to module '@jest\/types'     import\/no-unresolved\r\n  12:45  error  Unable to resolve path to module 'jest-haste-map'  import\/no-unresolved\r\n  13:27  error  Unable to resolve path to module 'jest-resolve'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-test-sequencer\\src\\index.ts\r\n   9:43  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  10:22  error  Unable to resolve path to module 'jest-haste-map'     import\/no-unresolved\r\n  11:28  error  Unable to resolve path to module 'jest-runtime'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-transform\\src\\ScriptTransformer.ts\r\n  19:27  error  Unable to resolve path to module '@jest\/types'     import\/no-unresolved\r\n  20:22  error  Unable to resolve path to module 'jest-haste-map'  import\/no-unresolved\r\n  26:8   error  Unable to resolve path to module 'jest-util'       import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-transform\\src\\shouldInstrument.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'      import\/no-unresolved\r\n  11:34  error  Unable to resolve path to module 'jest-regex-util'  import\/no-unresolved\r\n  12:53  error  Unable to resolve path to module 'jest-util'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-transform\\src\\types.ts\r\n  9:43  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\createDirectory.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\globsToMatcher.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\installCommonGlobals.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\replacePathSepForGlob.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\requireOrImportModule.ts\r\n  10:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\testPathPatternToRegExp.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-util\\src\\tryRealpath.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-validate\\src\\errors.ts\r\n  9:23  error  Unable to resolve path to module 'jest-get-type'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-validate\\src\\utils.ts\r\n  10:38  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-validate\\src\\validateCLIOptions.ts\r\n  11:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-watcher\\src\\BaseWatchPlugin.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-watcher\\src\\PatternPrompt.ts\r\n  10:28  error  Unable to resolve path to module 'jest-util'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest-watcher\\src\\types.ts\r\n  8:37  error  Unable to resolve path to module '@jest\/test-result'  import\/no-unresolved\r\n  9:27  error  Unable to resolve path to module '@jest\/types'        import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\jest\\src\\jest.ts\r\n  14:8   error  Unable to resolve path to module '@jest\/core'  import\/no-unresolved\r\n  16:19  error  Unable to resolve path to module 'jest-cli'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\test-utils\\src\\alignedAnsiStyleSerializer.ts\r\n  10:30  error  Unable to resolve path to module 'pretty-format'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\packages\\test-utils\\src\\config.ts\r\n  8:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\test-types\\expect.test.ts\r\n  8:30  error  Unable to resolve path to module 'expect'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\test-types\\top-level-config.test.ts\r\n  9:27  error  Unable to resolve path to module '@jest\/types'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\test-types\\top-level-expect-namespace.test.ts\r\n  9:22  error  Unable to resolve path to module '@jest\/globals'  import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\test-types\\top-level-globals.test.ts\r\n  16:8   error  Unable to resolve path to module '@jest\/globals'  import\/no-unresolved\r\n  17:27  error  Unable to resolve path to module '@jest\/types'    import\/no-unresolved\r\n\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\test-types\\top-level-jest-namespace.test.ts\r\n   9:20  error  Unable to resolve path to module '@jest\/globals'  import\/no-unresolved\r\n  10:25  error  Unable to resolve path to module 'jest-mock'      import\/no-unresolved\r\n\r\n\u2716 473 problems (473 errors, 0 warnings)\r\n```\r\n\r\n### Environment\r\n\r\n```shell\r\nSystem:\r\n    OS: Windows 10 10.0.19043\r\n    CPU: (16) x64 Intel(R) Core(TM) i7-10700K CPU @ 3.80GHz\r\nBinaries:\r\n    Node: 14.15.0 - E:\\Program Files\\NodeJS\\node.EXE\r\n    Yarn: 2.4.3 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.14.8 - E:\\Program Files\\NodeJS\\npm.CMD\r\nnpmPackages:\r\n    jest: workspace:* => 27.3.1\r\n```\r\n","comments":["Same here on Linux","Same here on MacOS\r\n\r\n","I recently encountered this same problem.\r\n\r\nWhat helped was doing the following two things and then issuing `yarn test`:\r\n\r\ni) Temporarily add the following to `package.json`:\r\n```\r\n...\r\n    \"jest-coverage\": \"yarn jest --coverage\",\r\n    \"lint\": \"eslint . --cache --ext js,jsx,cjs,mjs,ts,tsx,md\",\r\n    \"lint:no-cache\": \"eslint . --ext js,jsx,cjs,mjs,ts,tsx,md\", \/\/ this line\r\n    \"lint:prettier\": \"prettier . \\\"!**\/*.{js,jsx,cjs,mjs,ts,tsx}\\\" --write\",\r\n...\r\n```\r\n\r\nii) Issue `yarn lint:no-cache`","@abdih nice one! however, for me it fixes everything but\r\n```\r\nC:\\Users\\USER\\Documents\\Software Engineering\\Personal\\jest\\e2e\\transform-linked-modules\\ignored\\symlink.js\r\n  1:0  error  Parsing error: Declaration or statement expected\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"[Feature]: Stubbing Classes","body":"### \ud83d\ude80 Feature Proposal\n\nI would like to complete the mocking\/stubbing picture with an easy way to create a stub instance of an class.\r\n\r\nThis feature should be similar to Sinon's [`createStubInstance`](https:\/\/sinonjs.org\/releases\/v11.1.2\/utils\/) function.\r\nIt should create an instance of an class (or from an object prototype) that has all methods and properties stubbed. Similar to `jest.fn()`, the created instance should enable assertions about calls to the instance's methods and should provide the ability to define the return-value\/implementation of the stubbed methods.\n\n### Motivation\n\nIt is not always possible to stub a class by providing a mock for the containing module as it is suggested in the [docs](https:\/\/jestjs.io\/docs\/es6-class-mocks). For example, stubbing native web APIs, such as `WebSocket` or `BroadcastChannel` does not appear to work with the approach suggested in the documentation.\r\n\r\nI have yet to find a good solution to create a stub instance of these classes when I want to test a function\/class that expects an instance of these classes as an argument. In particular, spying on `WebSocket` methods would not be sufficient because the internal behavior of an instance should be removed, since it automatically tries to create a `WebSocket` connection.\r\n\r\nAn API similar to Sinon's [`createStubInstance`] would simplify tests when stub objects are required and would align them with tests that use `jest.fn()` to create stub callbacks. \n\n### Example\n\n_No response_\n\n### Pitch\n\nSuch class stub has already been implemented by @asvetliakov[^1] but the package does no longer appear to be maintained. As mentioned above, I think it would complete the picture around stubbing\/mocking in Jest if an API similar to `jest.fn()` is available for classes\/object-prototypes in the core.\r\n\r\n[^1]: https:\/\/github.com\/asvetliakov\/jest-create-mock-instance","comments":["Since I opened this issue, I stumbled upon [jest-mocked-extended](https:\/\/npmjs.com\/package\/jest-mock-extended), which works just as proposed and is actively developed.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant. Coming from the Ruby world where this was a standard, I\u2019d love to have this feature.","I recently ended up writing a util to use Jest's mocking tools to do this. Jest actually already has all the machinery we need, it's just a matter of exposing it in a convenient way rather than only via mocking entire modules. The advantage of using Jest's mocking instead of `jest-mock-extended` is that the API is completely consistent, mocks are automatically cleared by `jest.clearAllMocks`, and so on.\r\n\r\nSpecifically, the util I have takes a constructor and uses `ModuleMocker.getMetadata` and `ModuleMocker.generateFromMetadata` to build a mock for it, then calls the mock to create an instance of the class. Then you can pass that instance into code under tests, use `mockImplementation` and friends to customize the mock, and so on.\r\n\r\nIf this is something Jest would be interested in adding, I may be able to add it ~once my company signs the CLA~. The implementation is just a few lines, so it could also easily be rewritten if someone else gets there first.","@benjaminjkraft even though `jest-mock-extended` is covering all of my concerns really well, I can relate to your argument about consistency. Would you be able to share that snippet of code here for future reference?"],"labels":[":rocket: Feature Request"]},{"title":"[Feature]: Allow usage of tsm instead of ts-node?","body":"### \ud83d\ude80 Feature Proposal\n\nJest allows for configuration in TypeScript via `ts-node`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/7f39f0a589703191a0cd3c6db558920281f7195f\/docs\/Configuration.md?plain=1#L37\r\n\r\nIt would be great to also enable support for [`tsm`](https:\/\/www.npmjs.com\/package\/tsm)\n\n### Motivation\n\n- `tsm` is lighter weight and faster than `ts-node`\r\n- if projects are already using `tsm` for other tasks, it would be nice to not have to also install `ts-node` only for Jest\n\n### Example\n\n_No response_\n\n### Pitch\n\nNot entirely sure I understand this field, but maybe:\r\n\r\nIt fits Jest's ideology of being fast and enabling modern techniques","comments":["PR very much welcome!","The disadvantage to using `tsm` is that there is no programmatic way to invoke it. This is a problem because then we need to spawn a child process in which we run `node --loader tsm jest.config.ts` to import the config file. Then we must pass back the imported config to Jest. This can't be done across process boundaries without sacrificing support for function config files.\r\n\r\nWhat I propose instead:\r\n1. Use `@swc\/cli` in a child process like this: `npx swc jest.config.,ts -o \/node_modules\/jest-config\/_jest.config.js` where `\/node_modules\/jest-config\/_jest.config.js` is a temporary file.\r\n3. `require(\"\/node_modules\/jest-config\/_jest.config.js\")` which gives us the config object.\r\n4. Delete the temporary file.\r\n-> Now we have the config object available.\r\n\r\nI chose `swc` because of the stability. I know there is also `esbuild` which `tsm` uses, and they are similar in size.\r\n\r\n@SimenB would you accept a PR implementing this approach?","would that work if said file imported another ts file? or will swc bundle?","If said file imported another TS file, it wouldn't work. I know `esbuild` can do bundling, that might be an option. I don't know many cases in which you might import from other files though, but yeah, I'd be happy to use `esbuild` instead and do bundling. Let me know what you prefer \u263a\ufe0f","`@swc\/core` has a `bundle` export: https:\/\/www.runpkg.com\/?@swc\/core@1.2.106\/index.js#229\r\n\r\n(I don't care if `swc` or `esbuild` is chosen, I've never used either and haven't cared to check any of them out)","Ah, okay. I'll look into it. Just to confirm, you are open to a PR removing `ts-node` and implementing support for `jest.config.ts` files with `swc` or `esbuild`?","I don't think we should remove `ts-node` (but as it would be a breaking change, but also since I don't think any of the alternatives does any type checking?), but making it configurable in some way (`--config-loader=blah` or some such?) sounds reasonable","What would be breaking about removing `ts-node`? Depending on it's type-checking features would be one? I can do a CLI option","For people currently using `ts-node` it would stop working - it's a peer dependency, not a dependency","Ah okay. I will implement `esbuild` under a flag","What about a fallback mechanism where Jest will try to parse the config file with esbuild if `ts-node` is not installed?","If config loading happens within a CJS context, something like this would work just fine: https:\/\/boostlib.dev\/docs\/module#commonjs-requires","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale? There is also now another alternative called [`tsx`](https:\/\/github.com\/esbuild-kit\/tsx)","Current thinking: https:\/\/github.com\/facebook\/jest\/issues\/13143#issuecomment-1249081951\r\n\r\nI.e. allowing a user to specify which loader to use.","Both `tsm` and `tsx` support would be provided by https:\/\/github.com\/facebook\/jest\/pull\/13521 \ud83c\udf89 ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale"],"labels":[":rocket: Feature Request"]},{"title":"[Feature]: Create Schema for JSON and YAML Config Files","body":"### \ud83d\ude80 Feature Proposal\r\n\r\nWrite a [draft v4 JSON schema](https:\/\/json-schema.org\/specification-links.html#draft-4) defining Jest config files for inclusion in [JSON SchemaStore](https:\/\/www.schemastore.org\/json\/).\r\n\r\n### Motivation\r\n\r\nJest config files are powerful, complex, and offer many options. A number of them (e.g., [coverageReporters](https:\/\/jestjs.io\/docs\/configuration#coveragereporters-arraystring--string-options), [coverageThreshold](https:\/\/jestjs.io\/docs\/configuration#coveragethreshold-object), [moduleNameMapper](https:\/\/jestjs.io\/docs\/configuration#modulenamemapper-objectstring-string--arraystring), [reporters](https:\/\/jestjs.io\/docs\/configuration#reporters-arraymodulename--modulename-options), [transform](https:\/\/jestjs.io\/docs\/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object)) have complex types, and a number (e.g., `*PathIgnorePatterns`) have long names.\r\n\r\n### Example\r\n\r\nOffering a schema makes it easy for projects that desire to validate their config files to do so with minimal effort and receive precise, helpful, real-time [in-editor](https:\/\/code.visualstudio.com\/docs\/languages\/json#_json-schemas-and-settings) warnings and autocomplete suggestions regarding typos in key names. A schema would also make it easy to validate Jest config files in CI. JSON Schema Store recommends use of draft v4 JSON schemas for maximum compatibility.\r\n\r\n### Pitch\r\n\r\n> \"Quis custodiet ipsos custodes?\" (\"Who will guard the guards themselves?\") ~ *Satires* (Satire IV lines 347-348), Decimus Junius Juvenalis (a.k.a., Juvenal)\r\n\r\nOr as retold via Gru from Despicable Me:\r\n\r\n![Write the tests before any of the code. Run the tests; they should fail. The tests all pass. The tests all pass?!](https:\/\/pics.me.me\/write-the-tests-before-any-of-the-code-run-the-31537735.png)\r\n\r\nI don't know whether or not a schema would catch any issues that Jest itself wouldn't catch when run, but it's generally preferable to catch issues as they are introduced, and auto-completion of keys is an appreciated productivity boost. A JSON schema is extremely precise documentation, leaving no ambiguity as to what constitutes a valid JSON\/YAML config file. Using a JSON schema may simplify Jest's validation logic, facilitate automatically testing whether the JSON\/YAML and JavaScript\/TypeScript config file options are in sync with one another, and allow documentation to be auto-generated if these things aren't happening already. In the meantime, users who want stronger type checking and auto-completion can presently use a TypeScript file. However, dynamic code execution introduces another possible point of failure, and TypeScript config files require some extra setup (e.g., introducing a dev dependency on ts-node, which can be especially burdensome in high-security settings). Many projects also prefer to use static JSON or YAML config files for simplicity.","comments":["Having a schema file would be awesome! \ud83d\ude42 Very happy to accept a PR here for hosting one.\r\n\r\nIdeally, we would write it using https:\/\/github.com\/sinclairzx81\/typebox or some such which also provides TS types and can generate the schema from code. That should ensure there's no drift (and we can then use ajv or something to validate).\r\n\r\nOptions supported are roughly https:\/\/github.com\/facebook\/jest\/blob\/ae1f04bf0a71482ffe9ddb0d93b28b8d2079e13d\/packages\/jest-types\/src\/Config.ts#L141-L264, so any schema should take those as a starting point","Hi, i'd like to contribute to this :smile: if nobody is already working on it !\r\nI also want to know where\/when should we validate the JSON schema ? maybe inside `jest-config`:thinking: ? and for the shcema should we create a new package like `jest-json` or something like that ? or just put it at the root as `schema.json` ?","I don't believe anyone is working on it. We already use JSONSchemaStore via [MegaLinter](https:\/\/megalinter.github.io) to validate all of our JSON and YAML configs that have schemas, but I imagine other users would appreciate Jest validating its own config file. I am not familiar enough with Jest internals to offer any helpful guidance to you unfortunately.","Maybe @SimenB knows the answers to your questions?","I'd start by using typebox (linked above) to build up the json schema in memory. We can then write that to disk for publishing somewhere (probably a new module, but we can look at that later), and use ajv or something to validate it internally within `jest-config`.","For anyone looking to pick this up, I made a super rough (and probably non-working) start here: https:\/\/github.com\/SimenB\/jest\/tree\/schema\r\n\r\nTo write the schema to disk, run `yarn build:js` and then this script\r\n\r\n```js\r\n\/\/ write-schema.mjs\r\nimport {writeFileSync} from 'fs';\r\nimport {InitialOptions} from '@jest\/schemas';\r\n\r\nwriteFileSync('.\/schema.json', JSON.stringify(InitialOptions, null, 2));\r\n```\r\n\r\nOnce we have a schema that works, we can start using it inside Jest. How to get that schema onto some schema store I don't know, but probably fairly straightforward","I'll land that package in #12384, but it won't (nearly) cover the entire `InitialOptions`. PRs to expand it until it covers the entire thing would be appreciated \ud83d\ude42 As mentioned there, once complete we'll write the JSON to disk (and validate it), but for now it should just extract the parts needed.\r\n\r\nBranch now that some has landed: https:\/\/github.com\/SimenB\/jest\/tree\/schema-initial","\ud835\udc13\ud835\udc2a\n\nOn Mon, Feb 14, 2022, 4:45 PM Simen Bekkhus ***@***.***>\nwrote:\n\n> I'll land that package in #12384\n> <https:\/\/github.com\/facebook\/jest\/pull\/12384>, but it won't (nearly)\n> cover the entire InitialOptions. PRs to expand it until it covers the\n> entire thing would be appreciated \ud83d\ude42 As mentioned there, once complete\n> we'll write the JSON to disk (and validate it), but for now it should just\n> extract the parts needed.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/11963#issuecomment-1038804444>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AXNZNGX7LPPVT5XBB55HQTLU3C5YZANCNFSM5GBK4KNA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https:\/\/apps.apple.com\/app\/apple-store\/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https:\/\/play.google.com\/store\/apps\/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n","Published that in https:\/\/github.com\/facebook\/jest\/releases\/tag\/v28.0.0-alpha.1","Bravo! Adding schemas to JSON Schema Store is indeed straightforward and [documented](https:\/\/github.com\/SchemaStore\/schemastore\/blob\/master\/CONTRIBUTING.md#json-schema).\r\n\r\n> Once we have a schema that works, we can start using it inside Jest. How to get that schema onto some schema store I don't know, but probably fairly straightforward","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale."],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"[Bug]: jest-circus runner ignores `toJSON` serialization, causing `Converting circular structure to JSON` warnings","body":"### Version\r\n\r\n28.1.1\r\n\r\n### Steps to reproduce\r\n\r\n1. Clone my repo https:\/\/github.com\/blimmer\/jest-issue-repro\r\n2. Run `npm ci`\r\n3. Run `npm run test:jest-jasmine2`. You'll see that the error message from the test is properly serialized. You can see that output [in GitHub actions](https:\/\/github.com\/blimmer\/jest-issue-repro\/actions\/workflows\/test-jest-jasmine2.yml) without cloning the repo.\r\n\r\n```\r\n FAIL  .\/circular-structure.test.js\r\n  \u25cf circular structure \u203a fails\r\n\r\n    Error with thing!\r\n\r\n      47 |     \/\/ This error should not have a circular reference because `toJSON` is implemented on `thing` that creates a\r\n      48 |     \/\/ safe, non-circular object.\r\n    > 49 |     throw new ThingError(thing);\r\n         |           ^\r\n      50 |   })\r\n      51 | })\r\n      52 |\r\n\r\n      at Object.<anonymous> (circular-structure.test.js:49:11)\r\n```\r\n\r\n4. Run `npm run test:jest-circus`. You'll see an error message about `Converting circular structure to JSON`. You can see that output [in GitHub actions](https:\/\/github.com\/blimmer\/jest-issue-repro\/actions\/workflows\/test-jest-circus.yml) without cloning the repo.\r\n\r\n```\r\n(node:10437) UnhandledPromiseRejectionWarning: TypeError: Converting circular structure to JSON\r\n    --> starting at object with constructor 'Object'\r\n    |     property 'thingManager' -> object with constructor 'Object'\r\n    |     property 'things' -> object with constructor 'Array'\r\n    --- index 0 closes the circle\r\n    at stringify (<anonymous>)\r\n    at writeChannelMessage (internal\/child_process\/serialization.js:127:20)\r\n    at process.target._send (internal\/child_process.js:812:17)\r\n    at process.target.send (internal\/child_process.js:710:19)\r\n    at reportSuccess (\/Users\/blimmer\/code\/jest-issue-repro\/node_modules\/jest-worker\/build\/workers\/processChild.js:59:11)\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n(node:10437) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https:\/\/nodejs.org\/api\/cli.html#cli_unhandled_rejections_mode). (rejection id: 2)\r\n(node:10437) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n\r\n RUNS  .\/circular-structure.test.js\r\n```\r\n\r\nIn my test, I have three classes: `Thing`, `ThingManager` (which tracks all `Thing`s) and a custom `ThingError` that has a reference to a `thing`: https:\/\/github.com\/blimmer\/jest-issue-repro\/blob\/0ccc0debd32599c2415f9e9dd1c727aa4b1c075c\/circular-structure.test.js#L1-L40\r\n\r\nThe circular reference issue is because each `Thing` has a reference to itself `via ThingManager.things`. In the standard Node world, I work around this by defining a `toJSON` method on `Thing` that removes the circular reference: https:\/\/github.com\/blimmer\/jest-issue-repro\/blob\/0ccc0debd32599c2415f9e9dd1c727aa4b1c075c\/circular-structure.test.js#L24-L26\r\n\r\n### Expected behavior\r\n\r\nI expected `jest-circus` to serialize the error message (by calling `toJSON`) just like `jest-jasmine2` did.\r\n\r\n### Actual behavior\r\n\r\nWhen running with `jest-circus`, I get an error message about the JSON serialization failing, not the error message from the test itself. This makes it difficult to debug which test is failing, as there's no reference to the issue in the output.\r\n\r\nI think I tracked the issue down to this code in `jest-circus`: https:\/\/github.com\/facebook\/jest\/blob\/7dd17d541bcdb4d17d96b53586949fb195294040\/packages\/jest-circus\/src\/legacy-code-todo-rewrite\/jestAdapter.ts#L96-L99\r\n\r\nBecause `keepPrototype` is set to `false`, I believe it's discarding the `toJSON` method, which triggers the issue. The code comment makes it seem like this might be a known issue that you're already looking to correct.\r\n\r\n### Additional context\r\n\r\nInterestingly enough, this repro case also exposes the issue here described in https:\/\/github.com\/facebook\/jest\/issues\/10577 .\r\n\r\nIf you look at [this Github Actions run](https:\/\/github.com\/blimmer\/jest-issue-repro\/actions\/runs\/1339553822), you'll notice that the build hangs (and is killed by my 1-minute timeout on the action) on Node 12.x and 14.x.\r\n\r\n![Screen Shot 2021-10-13 at 4 58 10 PM](https:\/\/user-images.githubusercontent.com\/630449\/137223846-00f66011-e87f-4dea-8497-31db8b18bef6.png)\r\n\r\n### Environment\r\n\r\n```shell\r\n  System:\r\n    OS: macOS 12.4\r\n    CPU: (10) arm64 Apple M1 Pro\r\n  Binaries:\r\n    Node: 16.15.0 - ~\/.asdf\/installs\/nodejs\/16.15.0\/bin\/node\r\n    Yarn: 1.22.19 - \/opt\/homebrew\/bin\/yarn\r\n    npm: 8.5.5 - ~\/.asdf\/plugins\/nodejs\/shims\/npm\r\n  npmPackages:\r\n    jest: ^28.1.1 => 28.1.1\r\n```\r\n","comments":["Happens with **axios** as well (when axios throws error)\r\n\r\n\r\n```\r\nnode:internal\/child_process\/serialization:127\r\n    const string = JSONStringify(message) + '\\n';\r\n                   ^\r\n\r\nTypeError: Converting circular structure to JSON\r\n    --> starting at object with constructor 'Object'\r\n    |     property 'socket' -> object with constructor 'Object'\r\n    --- property '_httpMessage' closes the circle\r\n    at stringify (<anonymous>)\r\n    at writeChannelMessage (node:internal\/child_process\/serialization:127:20)\r\n    at process.target._send (node:internal\/child_process:839:17)\r\n    at process.target.send (node:internal\/child_process:739:19)\r\n    at reportSuccess (....\/node_modules\/jest-worker\/build\/workers\/processChild.js:59:11)\r\n\r\n```\r\n\r\n\r\n**Workaround:**\r\n1) add to jest.config \r\n```\r\nsetupFilesAfterEnv: [ '.\/jest.axios-workaround.setup.ts'],\r\n```\r\n\r\n2) file `jest.axios-workaround.setup.ts`\r\n\r\n\r\n```\r\nimport axios from 'axios'\r\n\r\naxios.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    if ('request' in error) delete (error as any).request\r\n    if ('response' in error) delete (error as any).response?.request\r\n    return Promise.reject(error)\r\n  },\r\n)\r\n\r\n\r\n```\r\n(or if you use js, simply remove types)\r\n\r\n\r\n","If you still need internals of request you can use this approach\r\n\r\n\r\n```\r\nfunction axiosErrorWorkaround(error: AxiosError) {\r\n  if (!error?.request) return\r\n  const picked = _.pick(error.request, [\r\n    'outputData',\r\n    'writable',\r\n    'destroyed',\r\n    'chunkedEncoding',\r\n    'shouldKeepAlive',\r\n    'maxRequestsOnConnectionReached',\r\n    'useChunkedEncodingByDefault',\r\n    'sendDate',\r\n    'finished',\r\n    'method',\r\n    'maxHeaderSize',\r\n    'path',\r\n    'aborted',\r\n    'timeoutCb',\r\n    'upgradeOrConnect',\r\n    'host',\r\n    'config',\r\n    '_header',\r\n    '_keepAliveTimeout',\r\n  ])\r\n  error.request = picked\r\n  if (error.response?.request) {\r\n    error.response.request = picked\r\n  }\r\n}\r\n```","For others running in to this, @brudil found that Jest is not respecting the prototype when doing the cross-worker serialization, so if you've implemented `toJSON` as a class method, it will get ignored.\r\n\r\nIf you implement `toJSON` as a method directly on the instance, then it'll work fine.\r\n","@npwork your first solution did not work for me (it caused my Axios aggregator to throw an error):\r\n\r\n```cmd\r\nAuth \u203a should throw 400 error when lastName is not a valid string; undefined\r\n\r\n    AggregateError:\r\n\r\n      at Function.Object.<anonymous>.AxiosError.from (..\/..\/node_modules\/axios\/lib\/core\/AxiosError.js:89:14)\r\n      at RedirectableRequest.handleRequestError (..\/..\/node_modules\/axios\/lib\/adapters\/http.js:610:25)\r\n      at ClientRequest.eventHandlers.<computed> (..\/..\/node_modules\/follow-redirects\/index.js:38:24)\r\n      at Axios.request (..\/..\/node_modules\/axios\/lib\/core\/Axios.js:45:41)\r\n\r\n    Cause:\r\n    AggregateError:\r\n```\r\n\r\nAnd your second solution fixes that issue but produces a new one :smiling_face_with_tear::\r\n\r\n```cmd\r\nTypeError: Cannot read properties of undefined (reading 'status')\r\n\r\n      25 |       );\r\n      26 |\r\n    > 27 |       expect(res.status).toBe(200);\r\n         |                  ^\r\n      28 |       expect(res.data).toStrictEqual({\r\n      29 |         some: 123,\r\n      30 |       });\r\n\r\n      at src\/auth\/auth-validation.spec.ts:27:18\r\n      at fulfilled (..\/..\/node_modules\/tslib\/tslib.js:166:62)\r\n```\r\n\r\nHere is how I did it:\r\n\r\n```ts\r\nimport axios from 'axios';\r\nimport _ from 'lodash';\r\n\r\naxios.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    if (!error?.request) {\r\n      return;\r\n    }\r\n    const picked = _.pick(error.request, [\r\n      'outputData',\r\n      'writable',\r\n      'destroyed',\r\n      'chunkedEncoding',\r\n      'shouldKeepAlive',\r\n      'maxRequestsOnConnectionReached',\r\n      'useChunkedEncodingByDefault',\r\n      'sendDate',\r\n      'finished',\r\n      'method',\r\n      'maxHeaderSize',\r\n      'path',\r\n      'aborted',\r\n      'timeoutCb',\r\n      'upgradeOrConnect',\r\n      'host',\r\n      'config',\r\n      '_header',\r\n      '_keepAliveTimeout',\r\n    ]);\r\n    error.request = picked;\r\n    if (error.response?.request) {\r\n      error.response.request = picked;\r\n    }\r\n  },\r\n);\r\n```\r\n\r\n## What helped me to figure out what is wrong with my axios req.\r\nAt least I realized that it had nothing to do with axios and jest :sweat_smile:, so I added the `setupFileAfterEnv` so to understand what is going on and it helped me:\r\n```ts\r\nimport axios from 'axios';\r\n\r\naxios.interceptors.response.use(\r\n  (response) => response,\r\n  (error) => {\r\n    console.dir(error, { depth: null });\r\n    return Promise.reject(error);\r\n  },\r\n);\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"chore: run leak tests with Jasmine on GH Actions","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n#10871 added a Jasmine run (circus at the time) to GH actions, no need to duplicate it on CircleCI\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nGreen CI\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) Report\n> Merging [#11944](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (f66a3b0) into [main](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/92f3279e697c36e38127626e030abaed684ae54b?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (92f3279) will **not change** coverage.\n> The diff coverage is `n\/a`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n\n```diff\n@@           Coverage Diff           @@\n##             main   #11944   +\/-   ##\n=======================================\n  Coverage   67.25%   67.25%           \n=======================================\n  Files         330      330           \n  Lines       17354    17354           \n  Branches     5073     5073           \n=======================================\n  Hits        11671    11671           \n  Misses       5651     5651           \n  Partials       32       32           \n```\n\n\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Last update [92f3279...f66a3b0](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11944?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Pinned"]},{"title":"[Bug]: jest does not log to stdout, so its output cannot be captured.","body":"### Version\r\n\r\n27.2.2\r\n\r\n### Steps to reproduce\r\n\r\nrun `npx jest > output.txt` - you don't even need to run any tests to see this go wrong, even the standard jest output isn't going to stdout\r\n\r\n### Expected behavior\r\n\r\na file `output.txt` is created, containing the output of the jest run, with no output written to the console except for execution errors.\r\n\r\n### Actual behavior\r\n\r\n`output.txt` is empty, and all of jest's output is in the console\r\n\r\n### Additional context\r\n\r\nThis is not how CLI tools should behave. Errors should go to stderr, output should go to stdout, \r\n\r\n### Environment\r\n\r\n```shell\r\nwin10 pro x64, node 16.7.0, npm 7.20.3\r\n```\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Frustrating ","If a bug is still on \"needs triage\", it should not be part of stale-bot weeding. ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","If a bug is still on \"needs triage\", it should not be part of stale-bot weeding.","related?\r\n\r\nMy failed tests do not output anything (runtime errors, failed test description, etc):\r\n\r\n```\r\n    \u2715 creates the valid verification process (2054 ms)\r\n    \u2715 verifies as expected (19 ms)\r\n\r\n  \u25cf proof chain example \u203a creates the valid verification process\r\n\r\n\r\n\r\n\r\n\r\n  \u25cf proof chain example \u203a verifies as expected\r\n\r\n\r\n\r\n\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       2 failed, 2 total\r\n```\r\n\r\nWhich makes it hard to know what happened.\r\n\r\njest@29.7.0 (just updated and problem persists)\r\nts-jest@29.1.1 if relevant.","That looks more like you forgot the verbosity flags so that jest gives more details during the run. My issue was about the fact that jest doesn't seem to write to stdout so you can't even capture its output to a file.","hm no passing `--verbose` does not change anything for my trouble. But sorry it's not the same issue then."],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]: HTML Coverage does not understand template strings","body":"### Version\n\n27.1.1\n\n### Steps to reproduce\n\n1. clone https:\/\/github.com\/hasezoey\/jest-template-string-repro\r\n2. cd into the repository\r\n3. run `yarn install`\r\n4. run `yarn run test`\r\n5. open `coverage\/lcov-report\/some_source.js.html` in a browser (in my case it was firefox)\n\n### Expected behavior\n\nTo handle and show Template strings properly\n\n### Actual behavior\n\nTemplate Strings are not recognized and syntax highlighting can go haywire (see complex repository \/ original problem repository)\n\n### Additional context\n\nThe original Project where i noticed this problem, is `https:\/\/github.com\/typegoose\/typegoose\/`, in particular it is the `errors.ts` file\r\n\r\nSteps for this complex repository:\r\n1. clone the mentioned repository\r\n2. cd into the repository\r\n3. run `yarn install`\r\n4. run `yarn run test:coverage`\r\n5. open `coverage\/lcov-report\/src\/internal\/errors.ts.html` in a browser (in my case firefox)\r\n6. look at the syntax highlighting going haywire (and also showing wrong values on the wrong lines?)\n\n### Environment\n\n```shell\n$ yarn envinfo --preset jest \r\nyarn run v1.22.11\r\n$ \/home\/hasezoey\/Downloads\/jest-test\/node_modules\/.bin\/envinfo --preset jest\r\n\r\n  System:\r\n    OS: Linux 5.14 Manjaro Linux\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz\r\n  Binaries:\r\n    Node: 16.8.0 - \/tmp\/yarn--1631453447308-0.8985475973800452\/node\r\n    Yarn: 1.22.11 - \/tmp\/yarn--1631453447308-0.8985475973800452\/yarn\r\n  npmPackages:\r\n    jest: ^27.1.1 => 27.1.1 \r\n\r\nDone in 0.18s.\n```\n","comments":["updated reproduction repository to jest 28, where it still happens (added more example cases)\r\n\r\nto clarify, it seems like somehow the template string is not seen as a string and applies colors based on keywords (like `undefined` is a different color from `and`, even though it is not in `${}`)","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","updated reproduction repository to jest 29(.5.0), where the same result can still be observed\r\n\r\nexample screenshot, i would expect the template string to be the same color before and after the `${}` and to not highlight `undefined` \/ `null` while not being in a `${}` and also not change the color if a normal string is inside the template string:\r\n![example](https:\/\/github.com\/jestjs\/jest\/assets\/10911626\/1a7511b2-7681-467b-a580-a2fd7027072d)\r\n"],"labels":["Needs Triage","Bug Report"]},{"title":"[Bug]:  False negative (instanceof Float32Array)","body":"### Version\r\n\r\n27.1.1\r\n\r\n### Steps to reproduce\r\n\r\nI prepared an example [here](https:\/\/github.com\/o-alexandre-felipe\/jest-onnxruntime), simply run `npm install` then you have the `node run.js` that shows the expected behavior (without jest), and `npx jest` will show the behavior when running in `jest`.\r\n\r\n### Expected behavior\r\n\r\nIn this instance I expected that `Float32Array` created by native code to be `instanceof Float32Array`.\r\n\r\n### Actual behavior\r\n\r\nIt seems that jest redefined `Float32Array` globally, maybe we could simply surround commands like this by some function that would restore the native functions. `jest.withNativeTypes( () => do my test )` \r\n\r\n### Additional context\r\n\r\n\r\n`onnxjs` is a frame work to evaluate neural network models in the format ONNX, it supports\r\ndifferent backends. `onnxjs-node` enables the use of `onnxruntime` in `onnxjs`.\r\n\r\nThese libraries use tensors objects, a tensor class is a multidimensional view of a typed array.\r\nThe outputs of a neural network are constructed in NAPI as typed arrays\r\n[[1]](https:\/\/github.com\/microsoft\/onnxruntime\/blob\/e5ee0b435db9007921adeadffe929f247a5d6055\/js\/node\/src\/tensor_helper.cc#L257).\r\n\r\nBoth the native code and javascript code have typed array maps [[2]](https:\/\/github.com\/microsoft\/onnxruntime\/blob\/e5ee0b435db9007921adeadffe929f247a5d6055\/js\/node\/src\/tensor_helper.cc#L55),[[3]](https:\/\/github.com\/microsoft\/onnxruntime\/blob\/009f342caf425edd1fe00832047d78d536d36402\/js\/common\/lib\/tensor-impl.ts#L18), and the javascript code checks if the value \r\nreturned is an array of the expected type[[4]](https:\/\/github.com\/microsoft\/onnxruntime\/blob\/009f342caf425edd1fe00832047d78d536d36402\/js\/common\/lib\/tensor-impl.ts#L108). Normally this works, but if we invoke this from a jest test, that check will evaluate to false,\r\nand finally it will throw an error[[5]](https:\/\/github.com\/microsoft\/onnxruntime\/blob\/009f342caf425edd1fe00832047d78d536d36402\/js\/common\/lib\/tensor-impl.ts#L111).\r\n\r\n\r\n### Environment\r\n\r\nFor a way to reproduce, check [Dockerfile](https:\/\/github.com\/o-alexandre-felipe\/jest-onnxruntime\/blob\/master\/Dockerfile), and [docker-compose.yaml](https:\/\/github.com\/o-alexandre-felipe\/jest-onnxruntime\/blob\/master\/docker-compose.yml).\r\n","comments":["I've come across this problem too. It appears to be related to\/a recurrence of: https:\/\/github.com\/facebook\/jest\/issues\/10786, which also replicates for me in version `27.3.1`. \r\n\r\nAs far as I can tell, there is no workaround for this, and Jest cannot be used to test any code using `onnxruntime`. I'd live with any backdoor way to get access to the original `Float32Array`, but without the original, no compatible data can be passed. It might be a corner case, but it's a blocking corner case.","Hello,\r\n\r\nI had this same problem, and after a lot of tinkering I eventually found a workaround.\r\n \r\nAs far as I can tell, the problem happens because Jest uses the module `node:vm` to run tests. This module allows running JavaScript code in a different V8 context. The module `onnxruntime` doesn't recognize the instances of `Float32Array` because they were defined in another VM context. Their constructor is different from the `Float32Array` of the current context, so the operator `instanceof` returns `false` and an exception is thrown.\r\n\r\nFor some reason, the utility functions in the module `node:utils\/types` seems immune to this problem : they return the correct result no matter which VM context the argument comes from.\r\n\r\nI ended up making use of [`Symbol.hasInstance`](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Symbol\/hasInstance) to overload the `instanceof` operator. \r\nIt's not a clean solution, but it works, and it allows me to run my model using Jest.\r\n\r\n```typescript\r\n\/\/ Import Node typing utilities\r\nimport * as types from \"node:util\/types\";\r\n\r\n\/\/ Import onnxruntime-node's default backend\r\nimport { onnxruntimeBackend } from \"onnxruntime-node\/dist\/backend\";\r\nimport { registerBackend } from \"onnxruntime-common\";\r\n\r\n\/\/ Define the constructors to monkey-patch\r\nconst TYPED_ARRAYS_CONSTRUCTOR_NAMES = [\r\n  \"Int8Array\",\r\n  \"Int16Array\",\r\n  \"Int32Array\",\r\n  \"Uint8Array\",\r\n  \"Uint8ClampedArray\",\r\n  \"Uint16Array\",\r\n  \"Uint32Array\",\r\n  \"Float32Array\",\r\n  \"Float64Array\",\r\n] as const;\r\n\r\n\/\/ Keep a reference to the original initialization method\r\nconst originalMethod = onnxruntimeBackend.init;\r\n\r\n\/\/ Monkey-patch the initialization function\r\nonnxruntimeBackend.init = function (...args) {\r\n  \/\/ There is probably a better way to do this\r\n  Array.isArray = (x: any): x is any[] =>\r\n    typeof x === \"object\" &&\r\n    x !== null &&\r\n    typeof x.length === \"number\" &&\r\n    x?.constructor.toString() === Array.toString();\r\n\r\n  \/\/ For each typed array constructor\r\n  for (const ctorName of TYPED_ARRAYS_CONSTRUCTOR_NAMES) {\r\n    \/\/ Get the constructor from the current context\r\n    const ctor: Function = global[ctorName]!;\r\n\r\n    \/\/ Get the corresponding test function from the `util` module\r\n    const value = types[`is${ctorName}`].bind(types);\r\n\r\n    \/\/ Monkey-patch the constructor so \"x instanceof ctor\" returns \"types[`is${ctorName}`](x)\"\r\n    Object.defineProperty(ctor, Symbol.hasInstance, {\r\n      value,\r\n      writable: false,\r\n      configurable: false,\r\n      enumerable: false,\r\n    });\r\n  }\r\n\r\n  \/\/ Call the original method\r\n  return originalMethod.apply(this, args);\r\n};\r\n\r\n\/\/ Register the backend with the highest priority, so it is used instead of the default one\r\nregisterBackend(\"test\", onnxruntimeBackend, Number.POSITIVE_INFINITY);\r\n```\r\n\r\nI hope this code can be useful to other people who have the same problem.","Anything new on this issue? The work around by @m-r-r works nicely, but this can't be a viable long-term solution.","Also just bumped into this issue. Would be nice to have a proper fix for it.","I hit this issue as well. I couldn't get the above workaround to work, so I solved it by mocking `Array.isArray`. Details are [here](https:\/\/github.com\/microsoft\/onnxruntime\/issues\/16622#issuecomment-1626413333) in case it helps anyone.","I don't know whether there should be a general fix in `testjs`, or `onnxruntime` should submit a fix for compatibility for supporting testjs.\r\n\r\nIs the tfjs PR mentioned above (https:\/\/github.com\/tensorflow\/tfjs\/pull\/7181) a good example for enhance test compatibility? Perhaps I can port that change to onnxruntime"],"labels":["Needs Triage","Bug Report"]},{"title":"Jest runtime blows up if internals are not defined in ES module","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nSimple test to test ESM imports fails with `ReferenceError: Export '__signal_exit_emitter__' is not defined in module`.\r\n\r\n## To Reproduce\r\n\r\nThe issue can be reproduced in this [codesandbox](https:\/\/codesandbox.io\/s\/sad-khorana-2uw98?file=\/src\/__tests__\/importESModule.test.js) by opening a new terminal and running: `yarn rebuild && yarn test importESModule.test.js`\r\n\r\nIf you prefer, you can also clone `https:\/\/github.com\/mekwall\/ffmpeggy\/tree\/jest-runtime-esm-import-bug` and do the same.\r\n\r\nThe test looks like this:\r\n```js\r\ndescribe(\"import ES modules\", () => {\r\n  it(\"should be able to import\", async () => {\r\n    if (process.version.startsWith(\"v12\")) {\r\n      \/\/ Next line blows up on v12 so let's skip this for now\r\n      return;\r\n    }\r\n    \/\/ Jest runtime blows up with the next line\r\n    const module = await import(\"..\/..\/es\/index.mjs\");\r\n    expect(module.FFmpeggy).toBeDefined();\r\n    const ffmpeggy = new module.FFmpeggy();\r\n    expect(ffmpeggy).toBeInstanceOf(module.FFmpeggy);\r\n  });\r\n});\r\n```\r\n\r\nSteps to reproduce the behavior:\r\n\r\n1) Check out the repo\r\n2) Install the deps with `npm install` or `yarn`\r\n3) Build with `npm run rebuild` or `yarn rebuild`\r\n4) Run the `importESModule.test.js` with jest (don't forget to pass the `--experimental-vm-modules` flag)\r\n\r\n## Expected behavior\r\n\r\nJest runtime should not blow up if internals are not defined in the module.\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.13 Manjaro Linux\r\n    CPU: (20) x64 Intel(R) Core(TM) i9-10900K CPU @ 3.70GHz\r\n  Binaries:\r\n    Node: 16.6.2 - ~\/.nvm\/versions\/node\/v16.6.2\/bin\/node\r\n    Yarn: 1.22.11 - ~\/.nvm\/versions\/node\/v16.6.2\/bin\/yarn\r\n    npm: 7.20.1 - ~\/repos\/ffmpeggy\/node_modules\/.bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.6 => 27.0.6\r\n```\r\n","comments":["Any updates or workaround on this bug?","I am experiencing this issue as well. \r\n\r\n```\r\n FAIL  test\/hello.test.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    ReferenceError: Export '__signal_exit_emitter__' is not defined in module\r\n\r\n      at node_modules\/.pnpm\/jest-runtime@29.5.0\/node_modules\/jest-runtime\/build\/index.js:1540:16\r\n          at Array.forEach (<anonymous>)\r\n          at async Promise.all (index 0)\r\n          at async Promise.all (index 5)\r\n          at async Promise.all (index 6)\r\n          at async Promise.all (index 0)\r\n          at async Promise.all (index 0)\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"doc : jest fake timers : expect on setTimeout not working","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nIn https:\/\/jestjs.io\/fr\/docs\/timer-mocks, we can see that we can assert that setTimeout has been called once : `expect(setTimeout).toHaveBeenCalledTimes(1);`\r\n\r\nHowever, if you do this in a test, jest will complain : \r\n\r\n    expect(received).toHaveBeenCalledTimes(expected)\r\n\r\n    Matcher error: received value must be a mock or spy function\r\n\r\n    Received has type:  function\r\n    Received has value: [Function setTimeout]\r\n\r\n      216 |     \/\/TODO: test refresh works\r\n    > 217 |     expect(setTimeout).toHaveBeenCalledTimes(1);\r\n          |                        ^\r\n      218 |   });\r\n      219 | });\r\n      220 |\r\n\r\n      at Object.<anonymous> (xxx.spec.ts:217:24)\r\n\r\nI think the documentation should be fixed to explain how we can do ...\r\n\r\n","comments":["if you are using jest 27, it uses modern timers now by default\r\nyou will need to spy on window.setTimeout beforeHands ","I feel that the timer function used is an implementation detail, and that you would get more robust tests by instead looking at what you expect to happen once the task runs. \r\n\r\nInstead of checking if `setTimeout()` has been called you could pass it a mocked function as the callback, fast forward in time with for example `jest.runAllTicks()`, and then assert that the mocked callback function was called with the parameters you expect. If you later replace `setTimeout()` with another timer implementation, it wouldn't necessarily break the test. Meaning you can have greater confidence in it.\r\n\r\nAnd similarly, if you need to verify that callbacks are scheduled with a particular time or interval, it would make sense to use `jest.advanceTimersByTime()` and make assertions based on what you expect to happen at different points in time. Just checking if `setTimeout()` has been called with a given amount of milliseconds is generally not that meaningful, imo.","Since this issue is tagged with \"needs repro\", [here is a repro](https:\/\/github.com\/hughrawlinson\/jest-timers-repro).\r\n\r\nI copied the example from the docs exactly, and setTimeout is not mocked. When I use legacy timers, the documented example works as expected. This suggests that the documentation demonstrates the legacy timers, not the modern timers. That document was last updated 8 months ago, and the commit history doesn't seem to suggest that the document was changed since the migration to modern timers.\r\n\r\nI can't actually find a document on the jest site for modern timers. Hopefully this reflects my own inability to find the right search terms, rather than that jest has migrated to an undocumented timer mock API?","No, you are right; the current documentation is for the legacy timers and is outdated. I'm working on a new one \ud83d\udc4d ","How *is* one supposed to solve this issue?\r\n\r\nMy tests start to fail as described in the inital report (i.e. I get a \"received value must be a mock or spy function\" error when invoking `expect(setTimeout).not.toHaveBeenCalled()` in a test).\r\n\r\nAdding `jest.spyOn(window, 'setTimeout')` inexplicably produces a \"ReferenceError: setTimeout is not defined\" error:\r\n\r\n```\r\nnode:internal\/process\/promises:246\r\n          triggerUncaughtException(err, true \/* fromPromise *\/);\r\n          ^\r\n\r\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"ReferenceError: setTimeout is not defined\".] {\r\n  code: 'ERR_UNHANDLED_REJECTION'\r\n}\r\n```\r\n\r\nI\u2019m using `testEnvironment: 'jsdom'`. The function `window.setTimeout` does exist in the test, so I don\u2019t really understand how it can appear as not defined to the test runner.","If you are using Jest 27 with its new default timer implementation, the current documentation is - as mentioned above - outdated. I have a draft for updated documentation in progress @ #11731. Perhaps the [FAQ answer](https:\/\/deploy-preview-11731--jestjs.netlify.app\/docs\/timer-mocks#timer-functions-are-no-longer-a-mock-or-spy-function-how-can-i-assert-against-them) I added there could be of help?\r\n\r\nI would try to think about why you are trying to assert against `setTimeout`, and if you could achieve the same (and perhaps even get more robust tests) with instead looking at what you expect to happen once the task scheduled by that `setTimeout` runs. For example designing your code in a way that allows you to pass in a spy as the callback for `setTimeout` and verify that this has been called the way you expect it to.","> Perhaps the [FAQ answer](https:\/\/deploy-preview-11731--jestjs.netlify.app\/docs\/timer-mocks#timer-functions-are-no-longer-a-mock-or-spy-function-how-can-i-assert-against-them) I added there could be of help?\r\n\r\nThat does explain the situation very well, thank you.\r\n\r\n> I would try to think about why you are trying to assert against `setTimeout`, and if you could achieve the same (and perhaps even get more robust tests) with instead looking at what you expect to happen once the task scheduled by that `setTimeout` runs.\r\n\r\nThe specifics of my case make this undesirable (at least in my opinion). I\u2019m updating a very small polling function that\u2019s published as an npm package. Changing the code so that I\u2019m able to pass a function as the `setTimeout` callback that I can set-up as a spy is not feasible (in my case, `setTimeout` is used in `new Promise(resolve => setTimeout(resolve, delay))`).\r\n\r\nNow in truth, the assertions looking at `setTimeout` are always accompanied with assertions looking at the callback function that is passed to the poll function (and that I can spy on without problem). Timing-wise, they\u2019re not however \u201cnext to each other\u201d. Practically speaking, I could perhaps do without spying on `window.setTimeout`, but I would really prefer not to. Why wouldn\u2019t I be able to spy on a global function? I understand how this could lead to testing internals of an implementation that might not contribute to a proper unit test, but that\u2019s a decision a developer should be able to make rather than having the testing framework force this decision upon them. For now, I think I\u2019m more comfortable relying on the legacy timer implementation.\r\n\r\n---\r\n\r\nSide note: Specifically what I\u2019d like to still be able to do is assess whether certain calls happened in an expected order. I don\u2019t much care about the exact processor time that elapses but rather the information that events A, B, and C happened before event D.","> Why wouldn\u2019t I be able to spy on a global function? I understand how this could lead to testing internals of an implementation that might not contribute to a proper unit test, but that\u2019s a decision a developer should be able to make rather than having the testing framework force this decision upon them.\r\n\r\nI went by all the reports about it not working and thought that perhaps it was sacrificed for the fact that relying on an external library greatly simplifies things for Jest. \r\n\r\nBut actually, I was partially wrong and should have tested it more thoroughly. \r\n\r\nAfter you have enabled the fake timers you can spy on the global:\r\n\r\n```js\r\njest.spyOn(global, 'setTimeout');\r\n```\r\n\r\nThat said; I do still stand by my comment on it most often being more favourable not to do so.\r\n\r\n> \r\n> Side note: Specifically what I\u2019d like to still be able to do is assess whether certain calls happened in an expected order. I don\u2019t much care about the exact processor time that elapses but rather the information that events A, B, and C happened before event D.\r\n\r\nWhen you use the modern fake timers, \"processor time\" should not play into the millisecond timing of when a given task can be expected to run though, because time is entirely faked. So with for example `jest.advanceTimersByTime()` you do have a lot of power.\r\n\r\nI would also think that tasks under fake timers would run in the natural order they are scheduled in. So if you want to ignore the exact timing... and only care about the order... then perhaps you can use `jest.runAllTimers()` to fast forward in time and exhaust all the queues, and then `toHaveBeenNthCalledWith()` to verify them?","Oh, and @kleinfreund, I almost forgot; there's also `jest.advanceTimersToNextTimer()` that would allow you to step through the timers sequentially","> After you have enabled the fake timers you can spy on the global:\r\n> \r\n> ```js\r\n> jest.spyOn(global, 'setTimeout');\r\n> ```\r\n\r\nAh, interesting. I had tried both: `jest.spyOn(window, 'setTimeout')` and `jest.spyOn(global, 'setTimeout')`. Placing one such call at the start of the first test in my test suite led to the `ReferenceError: setTimeout is not defined` error. What I didn\u2019t realize is that it actually works if I use a call to `jest.spyOn(window, 'setTimeout')` in all tests that assert whether the function has been called. So it turns out that spying on the `setTimeout` function works for both `window` or `global` as long as I register the spy in all tests making an assertion on it being called. I misread the `ReferenceError: setTimeout is not defined` as a principle issue with the attempt of registering the spy when it truth it\u2019s likely caused by the missing spy in the other tests where I didn\u2019t register it.\r\n\r\n> That said; I do still stand by my comment on it most often being more favourable not to do so.\r\n\r\nI do agree.","\ud83d\ude4c \r\n\r\n`global` is more environment agnostic than `window` here - e.g. working in both `node` and `jsdom`","I\u2019m experiencing a very strange return of this issue in the same project as before.\r\n\r\nI\u2019ve made changes to my TypeScript source code (effectively adding 2 `await` statements to function calls) and doing so causes the jest to crash when running the tests:\r\n\r\n```\r\n RUNS  src\/poll.test.ts\r\nnode:internal\/process\/promises:246\r\n          triggerUncaughtException(err, true \/* fromPromise *\/);\r\n          ^\r\n\r\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"ReferenceError: setTimeout is not defined\".] {\r\n  code: 'ERR_UNHANDLED_REJECTION'\r\n}\r\n```\r\n\r\nThe underlying error is once more \u201cReferenceError: setTimeout is not defined\u201d. The tests don\u2019t run at all. The `test(\u2026)` blocks are completely unchanged and start off with the line `jest.spyOn(global, 'setTimeout')`. Removing it stops jest from crashing but\u2014very much expectedly\u2014causes my tests to fail. This happens on Jest 27 using fake timers and JSDOM as the test environment.\r\n\r\nReproduction steps:\r\n\r\n1. Clone https:\/\/github.com\/kleinfreund\/poll\r\n2. Run `npm install`\r\n3. Run `npm test` to see the tests pass\r\n4. Change [src\/poll.ts#L18](https:\/\/github.com\/kleinfreund\/poll\/blob\/2515e587974dd7881ce9f342f67335b30826964b\/src\/poll.ts#L18) to `if (await shouldStopPolling()) {` (note the added `await`)\r\n5. Run `npm test` to see the tests crash","I confirm that I also get `ReferenceError: setTimeout is not defined` in `27.0.3`, the scenario is as follows:\r\n\r\n```\r\nafterEach(jest.useRealTimers);\r\n\r\nit('test A', () => {\r\n   jest.useFakeTimers();\r\n   jest.spyOn(global, 'setTimeout');\r\n\r\n   \/\/ run code which calls setTimeout\r\n   expect(setTimeout).toHaveBeenCalledTimes(1);\r\n   expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 1000);\r\n});\r\n\r\nit('test B', () => {\r\n   \/\/ run code which calls setTiemout\r\n\r\n   \/\/ perform other assertions not related to setTimeout on same code as exercised in test A\r\n  expect(...);\r\n  expect(...);\r\n}\r\n```\r\n\r\nTest A passes, but code executed by Test B fails, `console.log(setTimeout)` in that code returns `undefined`.\r\nIf I remove the spy on Test A, then Test B passes.\r\n\r\n@sigveio , not testing `setTimeout`, but a callback instead as you mention in previous comments is not an option for me. My `setTimeout` performs a recursive call to the same function, which is not exposed. Something like:\r\n\r\n```\r\nmodule.exports = function() {\r\n\r\n    const recursiveFunc = function() {\r\n\r\n        const expire = ....;\r\n         \r\n        setTimeout(recursiveFunc, expire);\r\n\r\n    }\r\n\r\n}\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Is the documentation still out of date? Would be a shame to let this issue be closed without updating the docs.","I also encountered the `ReferenceError: setTimeout is not defined` error. I'm using jest@27.5.1 and the following setup code in one of the tests\r\n\r\n```js\r\n    beforeAll(() => {\r\n      jest.useFakeTimers();\r\n      jest.spyOn(global, 'setTimeout');\r\n    });\r\n\r\n    afterAll(() => {\r\n      jest.useRealTimers();\r\n    });\r\n```\r\n\r\ncauses my `msw` server closing in jest setup file\r\n\r\n```js\r\nafterAll(() => server.close());\r\n```\r\n\r\nto fail with error `ReferenceError: setTimeout is not defined`.\r\n\r\nI fixed this for now by just removing the `server.close()` step which seems to work, but is suboptimal.\r\n\r\nAny ideas on how to debug this?\r\n\r\nBTW, the line in `msw` source that throws the error is\r\n\r\n```js\r\nexport function nextTick(callback: () => void) {\r\n  setTimeout(callback, 0)  \/\/ <-- THIS\r\n}\r\n\r\nexport function nextTickAsync(callback: () => void) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve(callback())\r\n    }, 0)\r\n  })\r\n}\r\n\r\n```","OK, it seems that the error above was caused by msw - more specifically msw versions >= 0.42.0. I'll post an issue to msw repo.","What is the status of this issue? In my case, due to the timeouts being messed, I am having issues on the CI pipeline in github actions. Locally, everything looks fine, but in GA it seems that is not waiting enough for components to be rendered.","I just found at that using\r\n\r\n```js\r\njest.useFakeTimers()\r\n```\r\n\r\ndoesn't work at all if the calls to timer functions are imported instead of using globalThis.\r\n\r\nI had to remove\r\n\r\n```js\r\nimport { setInterval, clearInterval } from 'node:timers';\r\n```\r\n\r\nto get the tests to pass."],"labels":["Needs Triage","Bug Report"]},{"title":"[jest-circus] missing fail() method","body":"This might be a known issue, but I could not find an existing issue so creating one here \ud83d\ude0a  Also, I guess fail() was a bit of an undocumented feature, but we rely on it in our app for some nice developer experience improvements.\r\n\r\n## \ud83d\udca5 Regression Report\r\n\r\nAfter upgrading to Jest v27 (with jest-circus as default) the `fail()` method is no longer defined.\r\n\r\n```\r\nReferenceError: fail is not defined\r\n```\r\n\r\n## Last working version\r\n\r\nWorked up to version: 26.6.3\r\n\r\nStopped working in version: 27.0.0\r\n\r\nCan circumvent in 27.x with `testRunner: \"jest-jasmine2\"` in jest.config.js\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n1. Open a JS project with jest >= 27.0.0\r\n1. Write a test that includes a `fail()` method call\r\n1. Notice that any tests with a call to `fail()` might pass (depending on the structure), and you will see a \"fail is not defined\" error message in Jest v27 with jest-circus (works correctly with jest-jasmine2)\r\n\r\n## Expected behavior\r\n\r\nExpected fail() to work by default, as before, without any changes to jest.config.js.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nSee this repo for example of the regression: https:\/\/github.com\/Darep\/jest-circus-fail-method\r\n\r\nCheck the branch `jasmine` where the testRunner is changed and the tests run correctly \ud83d\ude42 \r\n\r\nThe repo also hilights the way we use fail(), just to give some background info & motivation from our use-case \ud83d\ude04 \r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```\r\n$ npx envinfo --preset jest\r\nnpx: installed 1 in 0.976s\r\n\r\n  System:\r\n    OS: macOS 11.4\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 14.16.1 - ~\/n\/bin\/node\r\n    Yarn: 1.21.1 - ~\/n\/bin\/yarn\r\n    npm: 6.14.12 - ~\/n\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.6 => 27.0.6 \r\n```\r\n","comments":["Any update on this? Many of my integration tests are missing the correct messaging now that this is undefined, and its causing a lot of confusion.","Same here! Would love to have this issue alleviated sooner than later :) ","As a result of this issue, there is currently a discrepancy between `@types\/jest`, which does define `fail`, and `jest-circus`, which does not define `fail`. [Discussion in DefinitelyTyped](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/discussions\/55803)\r\n\r\nAs a temporary workaround, you can define your own `fail` function:\r\n```js\r\nfunction fail(reason = \"fail was called in a test.\") {\r\n  throw new Error(reason);\r\n}\r\n\r\nglobal.fail = fail;\r\n```","Same here","Same here, too. No change after fix","> As a result of this issue, there is currently a discrepancy between `@types\/jest`, which does define `fail`, and `jest-circus`, which does not define `fail`. [Discussion in DefinitelyTyped](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/discussions\/55803)\r\n> \r\n> As a temporary workaround, you can define your own `fail` function:\r\n> \r\n> ```js\r\n> function fail(reason = \"fail was called in a test.\") {\r\n>   throw new Error(reason);\r\n> }\r\n> \r\n> global.fail = fail;\r\n> ```\r\n\r\nUnfortunately that's not equivalent. The problem I'm having is that I need to fail a test from a location where any `throw` will be caught. Is there any more equivalent option available?","I just ran into a test where I was getting \"fail() is undefined\" and had assumed all this time that fail worked like it used to since it exists in @types\/jest.\r\n\r\nJust to clarify why this functionality is important:\r\n\r\n```\r\nit('should fail if the document does not exist.', async () => {\r\n      await c.accessor.delete();\r\n\r\n      const exists = await c.accessor.exists();\r\n      expect(exists).toBe(false);\r\n\r\n      try {\r\n        await c.accessor.update(c.dataForUpdate());  \/\/ should not succeed\r\n        fail();   \/\/ previously this would signal to Jest to properly end the test as a failure, but not get caught in the below.\r\n      } catch (e) {\r\n        expect(e).toBeDefined(); \/\/ expect an error occured\r\n      }\r\n});\r\n```\r\n\r\nThe above code with Jest 28 will now incorrectly always succeed, as `fail()` throw an exception that gets caught by the `catch`.\r\n\r\nWe don't want to catch any error either though, as unexpected errors should result in a test failure rather than success. We just want the tests to succeed when failures are expect.\r\n\r\nI went ahead and created some [test utility functions](https:\/\/github.com\/dereekb\/dbx-components\/pull\/13\/files#diff-804b3fec2e873eae4e195d907659cf0c43da9dc8511515452cabb1a4856cbff9) so I can continue using this pattern. I did end up finding and resolving a few more bugs too. Now the example test looks like:\r\n\r\n```\r\n    import { itShouldFail, expectFail } from '@dereekb\/util\/test';\r\n    \r\n    ...\r\n\r\n    itShouldFail('if the document does not exist.', async () => {\r\n      await c.accessor.delete();\r\n\r\n      const exists = await c.accessor.exists();\r\n      expect(exists).toBe(false);\r\n\r\n      await expectFail(() => c.accessor.update(c.dataForUpdate()));\r\n    });\r\n```\r\n\r\nIt will be published on npm with [`@dereekb\/util@^8.1.0`](https:\/\/www.npmjs.com\/package\/@dereekb\/util).\r\n\r\nI'm not too familiar with the inner workings of Jest or why it dropped the previous functionality of `fail()`, but I imagine it could be brought back for the cases where we are looking for a specific error. Jest's it functionality could be extended with a function that looks for failures, (I.E. it.fail, or something) and then watch for a specific exception to be thrown that is thrown by failSuccessfully() or something to that manner. Someone more familiar with building Jest extensions may see a better way to implement it as an extension as well.","also running into this while trying to upgrade from jest 26 to jest 27..\r\n```\r\nReferenceError: fail is not defined\r\n```\r\n","Any update on this? ","Any update on this?\r\n\r\nOr at least some information as to:\r\n\r\n- Why this feature has been removed\r\n- How can we achieve what we used to achieve with `fail`","Same here, still getting the `fail is not defined` error, any update or insight would be great","Seeing as this thread isn't moving towards an upcoming resolution in the `jest-circus` runner, I figured out how to restore the missing `fail()` functionality without re-implementing it. Essentially, if you install `jest-jasmine2` and modify your Jest config to set `\"test-runner\": \"jest-jasmine2\"`, you can now use `fail()` in your tests.\r\n\r\nSee https:\/\/stackoverflow.com\/a\/73922010\/1396477","Hi, just wanted to share the workaround I'm using.\r\nI have created a fail function using `expect` and a failing comparison. It also displays messages in an okayish way. It's not the cleanest solution, but it solves the problem mentioned [here](https:\/\/github.com\/facebook\/jest\/issues\/11698#issuecomment-1135857402).\r\nMaybe it is helpful for someone.\r\n\r\n\r\n```ts\r\nfunction fail(message = \"\") {\r\n    let failMessage = \"\";\r\n    failMessage += \"\\n\";\r\n    failMessage += \"FAIL FUNCTION TRIGGERED\\n\";\r\n    failMessage += \"The fail function has been triggered\";\r\n    failMessage += message ? \" with message:\" : \"\";\r\n\r\n    expect(message).toEqual(failMessage);\r\n}\r\n```","Using the answer proposed [here](https:\/\/stackoverflow.com\/questions\/30874676\/how-to-get-mocha-to-fail-a-test) I tested if the same behavior could be applied to Jest. My theory was correct. It is possible to fail a Jest test if you call the done callback function with some param. Here an example:\r\n\r\n```javascript\r\n    test('this test must fail', (done) => {\r\n        done('hey Rainyel this is a failed test')\r\n    });\r\n````\r\n\r\nOutput: \r\n\r\n  \u25cf this test must fail\r\n\r\n    Failed: \"hey Rainyel this is a failed test\"\r\n\r\n       6 |\r\n       7 | test('this test must fail', (done) => {\r\n    >  8 |   done('hey Rainyel this is a failed test')\r\n         |   ^\r\n       9 |\r\n      10 | });\r\n      11 |\r\n\r\n      at Object.<anonymous> (src\/__tests__\/test.super.ts:8:3)\r\n","This is still happening in 29.5.0","Hi! How this incredibly stupid bug could still be present after a so long time?! I've never seen a test framework without a fail() method in my whole life. This not fixed regression after 2 years is a huge embarrassment for jest and a huge lack of serious.","@vtgn: maybe because there are bigger and older issues with Jest, like #6695.","Building off @rayniel95's [answer](https:\/\/github.com\/jestjs\/jest\/issues\/11698#issuecomment-1351991694)...\r\n\r\nTests will [fail with a timeout](https:\/\/jestjs.io\/docs\/asynchronous#:~:text=if%20done()%20is%20never%20called%2C%20the%20test%20will%20fail%20(with%20timeout%20error)%2C%20which%20is%20what%20you%20want%20to%20happen.) if `done` is never called.\r\n\r\n```typescript\r\ntest('passing done fails after timeout if unused', (done) => {\r\n  \/\/ This test will fail after a few seconds\r\n  \/\/ because `done` is never invoked.\r\n})\r\n```\r\n\r\n### **Here's how to use `done` as a stand-in for `fail`:**\r\n\r\n```typescript\r\n\/\/ FUNCTION TO TEST\r\nfunction invokeCallbackIf(condition: boolean, callback: () => void) {\r\n  if (condition) callback();\r\n}\r\n\r\n\/\/ TESTS\r\ntest('callback invoked when true', () => {\r\n  invokeCallbackIf(true, () => expect(\"test passes\").toBeTruthy());\r\n})\r\n\r\ntest('callback NOT invoked when false', (done) => {\r\n  invokeCallbackIf(false, () => done(\"should not have been called\"));\r\n  done(); \/\/ <-- REQUIRED or the test will fail with a timeout\r\n})\r\n```\r\n\r\n> **Note**\r\n> A properly functioning `fail` is still preferred over any `done` workaround:\r\n> 1. `fail(reason)` has clearer semantics than `done(reason)`\r\n> 2. `fail` avoids the \"boilerplate\" of passing it as a param and calling it without arguments.","I just saw @atz3n's [workaround](https:\/\/github.com\/jestjs\/jest\/issues\/11698#issuecomment-1332760625) and decided to simplify it...\r\n\r\n### Write a custom `fail` function\r\n```typescript\r\nfunction fail(message: string = '') {\r\n  expect(`[FAIL] ${message}`.trim()).toBeFalsy();\r\n}\r\n```\r\n\r\n<details>\r\n  <summary>Full example<\/summary>\r\n\r\n```typescript\r\n\/\/ FUNCTION TO TEST\r\nfunction invokeCallbackIf(condition: boolean, callback: () => void) {\r\n  if (condition) callback();\r\n}\r\n\r\n\/\/ TESTS\r\nfunction fail(message: string = '') {\r\n  expect(`[FAIL] ${message}`.trim()).toBeFalsy();\r\n}\r\n\r\ntest('callback NOT invoked when false', () => {\r\n  invokeCallbackIf(true, () => fail(\"callback erroneously invoked\"));\r\n});\r\n\r\ntest('callback invoked when true', () => {\r\n  invokeCallbackIf(true, () => expect('test passes').toBeTruthy());\r\n});\r\n```\r\n\r\n<\/details>\r\n\r\n---\r\n> **Note**\r\n> This workaround is still inferior to the original `fail`\r\n> 1. The original `fail` was automatically globally available.\r\n> 2. In failure messages, code snippets showed the invocation of the original `fail`. This workaround shows the `expect` call in its implementation.","> I just saw @atz3n's [workaround](https:\/\/github.com\/jestjs\/jest\/issues\/11698#issuecomment-1332760625) and decided to simplify it...\r\n> \r\n> ### Write a custom `fail` function\r\n> ```ts\r\n> function fail(message: string = '') {\r\n>   expect(`[FAIL] ${message}`.trim()).toBeFalsy();\r\n> }\r\n> ```\r\n> \r\n> Full example\r\n> Note This workaround is still inferior to the original `fail`\r\n> \r\n> 1. The original `fail` was automatically globally available.\r\n> 2. In failure messages, code snippets showed the invocation of the original `fail`. This workaround shows the `expect` call in its implementation.\r\n\r\nThere are already simple work-arounds like this in the thread above. There's also another way you've missed that it's inferior to the original `fail`: it simply doesn't work if it's executed within a callback where a parent performs a `catch`. E.g.:\r\n\r\n```\r\nfunction underTest(callback) {\r\n  try {\r\n    return callback();\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\nIn cases like this any `fail()` call in `callback` will be silently ignored and the test still passes because all it does it throw an exception anyone can catch rather than actually mark the test as failed. That's a pretty big drawback.","> There are already simple work-arounds like this in the thread above. There's also another way you've missed that it's inferior to the original `fail`: it simply doesn't work if it's executed within a callback where a parent performs a `catch`.\r\n\r\nI saw the [\"workaround\" that simply raises an error](https:\/\/github.com\/jestjs\/jest\/issues\/11698#issuecomment-922351139). Since, like you, I consider \"errors\" in a test a completely separate result from \"failures\" in a test, such a workaround is unsatisfactory for me, even if it weren't further plagued by incompatibility with `try\/catch` blocks. Thus, my deliberate omission of any work to offer improvements on those suggestions.\r\n\r\nI had thought my one-line function which you quoted does work in try\/catch blocks, but upon further testing I'm realizing that jest's `expect` clauses simply raise a `JestAssertionError`, so it does suffer from the same problem :\/\r\n\r\n```javascript\r\nfunction invokeWithTry(callback) {\r\n  try {\r\n    return callback();\r\n  } catch (err) {\r\n    return err;\r\n  }\r\n}\r\n\r\nfunction fail(message = \"\") {\r\n  expect(`[FAIL] ${message}`.trim()).toBeFalsy();\r\n}\r\n\r\ntest(\"fail works in a try\/catch\", () => {\r\n  const result = invokeWithTry(() => fail(\"expected failure\")); \/\/ Erroneously passes\r\n  expect(result).toBeUndefined(); \/\/ Actually fails here b\/c `result` is a `JestAssertionError`\r\n});\r\n```\r\n\r\nThis limitation also applies to [`expect().fail(message)` from `jest-extended`](https:\/\/jest-extended.jestcommunity.dev\/docs\/matchers\/fail) since that matcher also raises an error instead of quietly recording a test failure.","After spending a few more hours on the problem this morning, I found a satisfactory solution using a [custom matcher](https:\/\/jestjs.io\/docs\/expect#expectextendmatchers) which builds off of the [`fail()` matcher from `jest-extended`](https:\/\/jest-extended.jestcommunity.dev\/docs\/matchers\/fail).\r\n\r\n### Use a Custom Matcher (works in `try\/catch` blocks)\r\n```javascript\r\nfunction toFail(_, message) {\r\n  this.dontThrow();  \/\/ <-- Enables recording failures in try\/catch blocks\r\n  return {\r\n    pass: false,\r\n    message: () => (message ? message : 'fails by .toFail() assertion'),\r\n  };\r\n}\r\n\r\nexpect.extend({ toFail });\r\n```\r\n\r\n<details>\r\n<summary>Example<\/summary>\r\n\r\n```javascript\r\n\/\/ FUNCTION UNDER TEST\r\nfunction invokeWithTry(callback) {\r\n  try {\r\n    return callback();\r\n  } catch (err) {\r\n    return err;\r\n  }\r\n}\r\n\r\n\/\/ SETUP THE CUSTOM MATCHER\r\nfunction toFail(_, message) {\r\n  this.dontThrow();  \/\/ Just record the error when a test fails, no error throwing\r\n  return {\r\n    pass: false,\r\n    message: () => (message ? message : 'fails by .toFail() assertion'),\r\n  };\r\n}\r\n\r\nexpect.extend({ toFail });\r\n\r\n\/\/ TESTS\r\ntest(\"fail works in a try\/catch\", () => {\r\n  expect().not.toFail(\"unexpected failure\"); \/\/ Correctly passes\r\n  const result = invokeWithTry(() => expect().toFail(\"expected failure\")); \/\/ Correctly fails\r\n  expect(result).toBeUndefined(); \/\/ Correctly passes\r\n});\r\n```\r\n\r\n<\/details>","Any chance this will be fixed in any new release?","Hell... I've just arrived here to find a *regression* from >2.5 years ago and it's full of workarounds.\r\n\r\nWill someone either close this as won't fix or fix it!","Or just move to another testing framework. I moved one project to vitest (Jest api compatible) this week, and noticed there was an expect.fail function. ","> Hell... I've just arrived here to find a _regression_ from >2.5 years ago and it's full of workarounds.\r\n> \r\n> Will someone either close this as won't fix or fix it!\r\n\r\nWhat a shame! This would be the worst answer to do not fix it!\r\nAnd yes you're right, it's pathetic that this regression on such a basic feature is more than 2,5 years old!! And being required to use workarounds is as pathetic too!","> Or just move to another testing framework. I moved one project to vitest (Jest api compatible) this week, and noticed there was an expect.fail function.\r\n\r\nThat's what I will do now: by letting this shit for a so long time, they completely discredited themselves and showed their total lack of seriousness. I will replace jest by another framework for my current and next projects for all the companies, and hardly advise to everybody to never choose that framework for their tests.\r\nI already do the same with TypeOrm which proved its total lack of seriousness too about the non fixed regressions and bugs.","Don't take me wrong, but they don't owe you or us anything. The developers have their own lives, with their own problems and need to pay their bills at the end of the month too. If you really need this, you can use your spare time (like they do when they develop jest) and submit a PR to fix this issue. \r\n","> Don't take me wrong, but they don't owe you or us anything. The developers have their own lives, with their own problems and need to pay their bills at the end of the month too. If you really need this, you can use your spare time (like they do when they develop jest) and submit a PR to fix this issue.\r\n\r\nThat's what I do, but not on abandoned framework like here. I don't have time to waste either. Have a nice day!"],"labels":[":boom: Regression"]},{"title":"Missing coverage information in random lines","body":"## \ud83d\udc1b Bug Report\r\n\r\nSince update jest to version 27 (27.0.6) we have the problem that on random lines no coverage information are collected. Our project is using Angular. So maybe thats an problem in that combination. I made a minimal angular project with that behaviour. When I run all tests with jest --coverage I got this result: https:\/\/biga-software.de\/assets\/dummy.page.ts.html\r\nThe method cardMessageText is tested but according to the report there is no coverage availible.\r\n\r\n## To Reproduce\r\n\r\nDon't know just took our project and remove sources.\r\n\r\n## Expected behavior\r\n\r\nHaving correctly coverage information. Method is tested.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/MoritzOtto\/jest_coverage_bug\r\n\r\n## envinfo\r\n\r\n  System:\r\n    OS: Linux 5.8 Ubuntu 20.04.2 LTS (Focal Fossa)\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz\r\n  Binaries:\r\n    Node: 15.14.0 - ~\/.nvm\/versions\/node\/v15.14.0\/bin\/node\r\n    npm: 7.7.6 - ~\/.nvm\/versions\/node\/v15.14.0\/bin\/npm\r\n","comments":["Hitting this in react, in my case, somehow:\r\n```tsx\r\n\tif (company.logoUrl == null || company.logoUrl == \"\" || imageLoadFailed) {\r\n-\t\treturn <BusinessName variant=\"body1\">{company?.name || \"\"}<\/BusinessName>;\r\n-\t}\r\n-\r\n-\treturn (\r\n-\t\t<BusinessImage\r\n-\t\t\tonError={() => setImageLoadFailed(true)}\r\n-\t\t\tsrc={company.logoUrl}\r\n-\t\t\talt={company.name || \"\"}\r\n\t\t\theight={40}\r\n\t  \/>\r\n\t);\r\n```\r\nlines marked with `-` are not covered.\r\nRunning tests one by one produces result tables that indicate that those lines are covered, but running all tests mark those lines as not covered.\r\n\r\nJest: 27.3.0","Here's a minimal reproduction: https:\/\/github.com\/CharlesStover\/monorepo-template\/runs\/4734914005?check_suite_focus=true\r\n100% coverage in Jest 26. By simply upgrading to Jest 27, you get uncovered _empty_ lines [in a file that only exports](https:\/\/github.com\/CharlesStover\/monorepo-template\/blob\/1072665d0e8ca09a64be30f7ce799696ad077fed\/packages\/module\/src\/index.ts).","@CharlesStover It could be that in your case `ts-jest` is the issue. Here is what I get:\r\n\r\n- using `jest` 27 and `babel`\r\n<img width=\"600\" alt=\"Screenshot 2022-01-07 at 09 43 57\" src=\"https:\/\/user-images.githubusercontent.com\/72159681\/148509750-d6e6bf1d-e3a0-4841-8f66-d977e87a4f36.png\">\r\n\r\n- using `jest` 27 and `ts-jest` 27\r\n<img width=\"600\" alt=\"Screenshot 2022-01-07 at 09 44 56\" src=\"https:\/\/user-images.githubusercontent.com\/72159681\/148510018-1a54366c-7802-4d3e-8af3-9a538eac28b8.png\">\r\n\r\n","@mrazauskas Nice debugging. What configuration did you use for Babel to get those results?","> What configuration did you use for Babel to get those results?\r\n\r\nHere is the whole `babel.config.json`:\r\n\r\n```json\r\n{\r\n  \"presets\": [\r\n    [\"@babel\/preset-env\", { \"targets\": { \"node\": \"current\" } }],\r\n    [\"@babel\/preset-react\", { \"runtime\": \"automatic\" }],\r\n    \"@babel\/preset-typescript\"\r\n  ]\r\n}\r\n```\r\n\r\nTo be honest, I have no experience with React. The line with `@babel\/preset-react` is just a guess.","@CharlesStover Found it. Including `\"sourceMap\": true` in `tsconfig.json` makes the `jest` v27 and `ts-jest` v27 duo work just like you would expect. Seems like `ts-jest` changed its defaults: https:\/\/github.com\/kulshekhar\/ts-jest\/blob\/main\/CHANGELOG.md#breaking-changes","> using jest 27 and babel\r\n\r\n@mrazauskas  I am also having the same issue where `index.ts` is coming up 0. do you know of a config that would resolve that? also, does it effect reporting overall test coverage?\r\n\r\nactually, even with babel, i'm seeing something similar to your `ts-jest` example as well\r\n<img width=\"523\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/13007960\/180842980-7a883d1c-a246-4bb0-b697-f3d64f13ccab.png\">\r\n\r\n\r\n","The same issue.\r\nReproducible repo [here](https:\/\/github.com\/Yegorich555\/web-ui-pack\/tree\/issue_coverage) - just clone & run `npm i && npm test`\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/25006810\/181789627-829307bc-093f-4fd7-9c22-0171ee02cc99.png)\r\n\r\nIn my case coverage for single file works correct. \r\nWhen files were 5...6 - it was ok. \r\nBut now when files a lot it's wrong and different time to time (just try to run `npm test` several times and compare)\r\n\r\n","Facing this same problem, but with Jest 26.6.3 in a Node server","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Ping"],"labels":["Needs Triage","Bug Report"]},{"title":"globalSetup, globalTeardown and testEnvironment does not recognize moduleNameMappers config","body":"## \ud83d\udc1b Bug Report\r\n\r\nModules defined in `globalSetup`, `globalTeardown` and in `testEnvironment` are not being recognized by `moduleNameMappers` (and maybe others like `transform`). I think this may be a bug, otherwise consider this as a feature request.\r\n\r\nThis is maybe related to #5164 and #6179\r\n\r\n## To Reproduce\r\n\r\n1. Create a moduleNameMapper entry in jest config file;\r\n2. Create `globalSetup`, `globalTeardown` or `testEnvironment` files;\r\n3. Import the module alias on those files;\r\n4. Run jest;\r\n5. `Cannot find module '<module alias>'` error should appear.\r\n\r\n## Expected behavior\r\n\r\n`globalSetup`, `globalTeardown` or `testEnvironment` files should import modules defined on `moduleNameMappers` config.\r\n\r\n## Link to repl or repo\r\n\r\n1. In the file `jest.config.js` uncomment `globalSetup`, `globalTeardown` or `testEnvironment` config entries;\r\n2. Open new terminal\r\n3. Run `npm run test`\r\n\r\nhttps:\/\/codesandbox.io\/s\/jest-module-alias-bug-v3wij\r\n\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.4 Debian GNU\/Linux 10 (buster) 10 (buster)\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz\r\n  Binaries:\r\n    Node: 14.16.1 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/node\r\n    Yarn: 1.22.10 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/yarn\r\n    npm: 6.14.12 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.6 => 27.0.6\r\n\r\n\r\n  System:\r\n    OS: Linux 5.4 Debian GNU\/Linux 10 (buster) 10 (buster)\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz\r\n  Binaries:\r\n    Node: 14.16.1 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/node\r\n    Yarn: 1.22.10 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/yarn\r\n    npm: 6.14.12 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.6 => 27.0.6\r\n\r\n\r\n  System:\r\n    OS: Linux 5.4 Debian GNU\/Linux 10 (buster) 10 (buster)\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz\r\n  Binaries:\r\n    Node: 14.16.1 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/node\r\n    Yarn: 1.22.10 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/yarn\r\n    npm: 6.14.12 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.6 => 27.0.6\r\n```\r\n","comments":["I can share that I am facing the same issue. For my case, I am importing another module which uses aliases in the module defined for `testEnvironment`. Initially I had thought it was a misconfiguration in my jest config and I tried all sorts of fixes before I chanced upon this thread and realised that it may be because `moduleNameMappers` is not respected by `testEnvironment` \ud83d\ude13 ","oh damn. this just cost me several hours.","Having the same issue.","Please solve it","Having the same issue, any plan for this point?","This is such a frustrating bug, with `testEnvironment` you can remove tonnes of boilerplate setup and teardown code from all of your tests.\r\n\r\nBut unfortunately its not usable in a modern TS application, as pretty much every app will be using either `paths` or at least a `baseDir` to allow relative imports.\r\n\r\nTherefore the `moduleNameMapper` is _required_\r\n\r\nSo as it currently stands this bug is blocking out this feature for TS jest users\r\n","Any information on whether this is being fixed?","Any information on whether this is being fixed?","Hello fellow developer who spent ~~many~~ a few hours ~~in rage~~ bugfixing before stumbling across this issue, like me. I might have a quick workaround for you:\r\n\r\nInstall [tsconfig-paths](https:\/\/www.npmjs.com\/package\/tsconfig-paths) and add `import 'tsconfig-paths\/register';` on top   of your `globalSetup` or `globalTeardown` files.\r\n","i also just run into this while trying to change my code work for both CJS and ESM (because ESM requires explicit endings, but those files do not exist when using `ts-jest` and having to use `globalSetup` \/ `globalTeardown` for some setup)\r\n\r\nusing jest 28","`globals` don't apply as well. \ud83d\ude22 ","Bumping this. It's really confusing. The one-liner fix suggested in https:\/\/github.com\/facebook\/jest\/issues\/11644#issuecomment-1171646729 works well. This should be the built-in behavior. ","hello folks.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/11644#issuecomment-1171646729\r\n\r\nAdding `import 'tsconfig-paths\/register';` on top of my `globalSetup` initially saved my day for a single spec file Jest project. However, as soon as I add the second `.spec.ts` file on my project, it crushed again.","tsconfig-paths can be quite finicky when combined with Jest as it can take priority over Jest's transformers.","Just figured out I can add `--runInBand` option on Jest CLI to fix the problem. It's highly possible that it ain't work well within the parallel context that Jest provides \ud83e\udd14 ","I had the same problem, [this comment](https:\/\/github.com\/facebook\/jest\/issues\/11644#issuecomment-1171646729) solved it.\r\n[this one](https:\/\/github.com\/facebook\/jest\/issues\/11644#issuecomment-1403325708) was not useful","> Hello fellow developer who spent ~many~ a few hours ~in rage~ bugfixing before stumbling across this issue, like me. I might have a quick workaround for you:\r\n> \r\n> Install [tsconfig-paths](https:\/\/www.npmjs.com\/package\/tsconfig-paths) and add `import 'tsconfig-paths\/register';` on top of your `globalSetup` or `globalTeardown` files.\r\n\r\nHelpful.\r\nIf it still not works for you guys, make sure that this `import` goes BEFORE any other `import` in `globalSetup` file.","Working on an older project that isn't Typescript related, and also running into the same issue.","Still running into the same issue, even with ```import 'tsconfig-paths\/register';```","same issue here, typescript is great but all typescript ecosystem is pure insanity"],"labels":["Needs Triage","Bug Report"]},{"title":"jest-worker fails with \"Do not know how to serialize a BigInt\" in `messageParent.ts` instead of showing the actual assertion error message when there are 2 or more test suite files executing in parallel","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nMinimal reproduction repo: [jest-bigint-worker-issue](https:\/\/github.com\/klesun-productions\/jest-bigint-worker-issue)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nWhen you have multiple test suite files executing in parallel, and some of the tests are asserting values with `bigint` numbers in them and the assertion fails, instead of showing this assertion error message, [`jest-worker`](https:\/\/www.npmjs.com\/package\/jest-worker) fails itself on attempt to serialise this value during the call to the:\r\n```javascript\r\nparentProcess.send([_types().PARENT_MESSAGE_CUSTOM, message]);\r\n```\r\n(in [`messageParent.js`](https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-worker\/src\/workers\/messageParent.ts))\r\n\r\nI assume that's because `message` includes `failureDetails.matcherResult` holding the compared `bigint` values that can't be passed to [`process.send()`](https:\/\/nodejs.org\/api\/process.html#process_process_send_message_sendhandle_options_callback), as unlike [`worker_threads`](https:\/\/nodejs.org\/api\/worker_threads.html#worker_threads_broadcastchannel_postmessage_message) it does not support non-json values out of the box.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n```bash\r\ngit clone git@github.com:klesun-productions\/jest-bigint-worker-issue.git # clone minimal reproduction repo\r\ncd jest-bigint-worker-issue\r\nnpm ci # install jest dependency\r\nnpm test # run the test that reproduces the issue\r\n```\r\n\r\n## Expected behavior\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\nYou should have seen the assertion error informing you that `expect(1n).toEqual(2n);` expectation failed\r\n\r\n## Actual behavior\r\n\r\nBut instead you get following output due to an internal [`jest-worker`](https:\/\/www.npmjs.com\/package\/jest-worker) error:\r\n\r\n```bash\r\n PASS  tests\/some-other.test.js\r\n  \u2713 should succeed (2 ms)\r\n\r\n FAIL  tests\/bigint.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    TypeError: Do not know how to serialize a BigInt\r\n        at stringify (<anonymous>)\r\n\r\n      at messageParent (node_modules\/jest-worker\/build\/workers\/messageParent.js:42:19)\r\n\r\nTest Suites: 1 failed, 1 passed, 2 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        0.777 s\r\n```\r\n\r\nWith no details of what the actual error that [`jest-worker`](https:\/\/www.npmjs.com\/package\/jest-worker) tried to report was in `tests\/bigint.test.js`.\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: macOS 11.3.1\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 14.17.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.13 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.5 => 27.0.5\r\n```\r\n\r\n## Misc\r\n\r\nI assume that's a transport issue that user of `jest` is not supposed to be aware of. One thing I did that at least somehow solved the absence of the real message was [patching](https:\/\/github.com\/klesun-productions\/jest-worker-bigint\/commit\/31bed58c2ce1ab803abcd4f0941a963e992ca4b3) the [`jest-worker`](https:\/\/www.npmjs.com\/package\/jest-worker) wrapping the call to `parentProcess.send()` in a `try-catch` and `console.log`-ing the message whose serialisation failed:\r\n```javascript\r\ntry {\r\n  parentProcess.send([_types().PARENT_MESSAGE_CUSTOM, message]);\r\n} catch (error) {\r\n  console.error('jest-worker message serialisation failed', error);\r\n  console.dir(message, {depth: 10});\r\n  throw error;\r\n}\r\n```\r\n\r\nThere is likely a number of ways how to better address this problem...","comments":["@SimenB, since you [changed this part](https:\/\/github.com\/facebook\/jest\/pull\/10984) of `jest-worker` not so long ago, maybe you could, please, give us an advice here for the discussion to move in the right direction?\r\n","Related: https:\/\/github.com\/facebook\/jest\/pull\/10293\r\n\r\n@kunal-kushwaha fyi","cc @sauravhiremath ","Will look into this tomorrow!","The choice to use JSON stock JSON serialization moving forward is not helpful.  While Jest has been doing better and better with comparison support of native BigInt, the reporting of assertion failures (for me, OOB) still consistently reports an inability to serialize the bigint.  With this configuration (OOB) of Jest, [polyfills to fix this problem are inconsistent at best](https:\/\/realonetech.wordpress.com\/2021\/03\/24\/jest-custom-matcher-in-typescript\/).  \r\n\r\nThere are new serializers that can be configured and dropped in for the one way (or even two-way if you configure them correctly) representations for error reports, for example: [json-bigint](https:\/\/www.npmjs.com\/package\/json-bigint)[](url)","For those of you that got here because a failing test involves some `BigInt`, you can temporarily circumvent this issue by setting `maxWorkers: 1` in your jest configuration.","> For those of you that got here because a failing test involves some `BigInt`, you can temporarily circumvent this issue by setting `maxWorkers: 1` in your jest configuration.\r\n\r\n@gomain That actually works, but I cannot understand why turning down the maxworkers do the trick. Have you found any other solution that does not have impact on the total test time?","@JCastrejonE serialization (currently using JSON, it does not support `BigInt`) only happens when sending data between worker threads. Limiting workers to `1` eliminates the need to serialize at all. Until a fix for this, we wait for our single worker to finish.\r\n\r\nIf only a small number of tests involve `BigInt` you could separate them, such as (!!! not tested !!!)\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"test:no-bigint\": \"jest --testPathIgnorePatterns=.*\\\\.bigint\\\\.test\\\\.js\",\r\n    \"test:bigint\": \"jest --maxWorkers=1 --testPathPattern=.*\\\\.bigint\\\\.test\\\\.js\",\r\n    \"test\": \"npm run test:no-bigint && npm run test:bigint\"\r\n  }\r\n}\r\n```","Any update?","This is quite unplesant issue. Testing library cannot handle one of built-in language types? Srsly? Please fix it somebody!","+1","+1","+1","Developing a cryptography package now. Looking forward to any fix to this!","+1","+1","Workaround I put into my project as a post install hook:\r\n\r\nimport { readFile, writeFile } from 'fs\/promises';\r\nimport { resolve } from 'path';\r\n\r\n```\r\n\/\/ https:\/\/github.com\/facebook\/jest\/issues\/11617\r\n\/\/ Fix for Jest failing to serializbe BigInt.\r\n\/\/ Is unsafe for values above Number.MAX_SAFE_INTEGER\r\nexport async function hook() {\r\n  async function patch(file) {\r\n    await readFile(file, 'utf-8').then((content) => {\r\n      if (content.includes('\/\/ Allow unsafe bigint serialization')) return;\r\n\r\n      content =\r\n        [\r\n          '\/\/ Allow unsafe bigint serialization',\r\n          \"BigInt.prototype['toJSON'] = function () {\",\r\n          '  return Number(this);',\r\n          '};',\r\n        ].join('\\n') +\r\n        '\\n' +\r\n        content;\r\n\r\n      return writeFile(file, content).then(() =>\r\n        console.log('Patched jest-worker'),\r\n      );\r\n    });\r\n  }\r\n\r\n  const expectedFilePos = resolve(\r\n    process.cwd(),\r\n    `.\/node_modules\/.pnpm\/jest-worker@29.4.2\/node_modules\/jest-worker\/build\/workers\/messageParent.js`,\r\n  );\r\n\r\n  \/\/ Automatically resolving the path worked, but the resolved module was not the one actually being used by jest.\r\n  \/\/ Might be because I'm using pnpm or because jest-worker is a subdependency... IDK\r\n  \/\/\r\n  \/\/ const a = require.resolve('jest-worker');\r\n  \/\/ const dir = dirname(a);\r\n  \/\/ const expectedFilePos = '.\/workers\/messageParent.js';\r\n  \/\/ const file = resolve(dir, expectedFilePos);\r\n  return patch(expectedFilePos);\r\n}\r\n```\r\n\r\nThis will allow jest to keep running.\r\nHowever this might cause issues as the serialized bigint can be incorrect.\r\n","Anu updates on solving this issues on jest without workarounds?","The [workerthreads](https:\/\/jestjs.io\/docs\/configuration#workerthreads) configuration option might help. It is a new feature which was shipped yesterday with [Jest v29.5](https:\/\/github.com\/facebook\/jest\/releases\/tag\/v29.5.0).\r\n\r\nNote that this is **!!! strictly experimental !!!** and wasn\u2019t tryout widely at all. Use it at your own risk.\r\n\r\nCurrently I run tests with `workerThreads: true` in one repo. Give it a try.","Realized Prisma is returning `BigInt` which made my zod parsing fail on a raw query while validating the return data, which lead me to here. Luckily our system is running the latest Node which will support structured cloning and we're up to date to be on a version of Jest that supports the experimental `workerThreads`, but I would prefer to get away from them, as it seems I do not get a performance boost from the flag, if anything a slow down. I guess another route would have been to just make the type validation on Zod to be looser to accept int or BigInt, but I'd rather be more explicit here...","I'm currently developing using NestJS, and when I encountered this issue, I looked it up and found this\r\n\r\nI was able to solve it from the following site: https:\/\/zenn.dev\/serinuntius\/scraps\/02dfe48b643745\r\n\r\njest.config.ts \r\n```typescript \r\n\"workerThreads\": true \r\n```\r\n\r\nI'm not using jest.config.ts, so I just added that code to the jest part of my package.json and that solved it. I'm not sure why this solves it, though, so if anyone knows how, I'd appreciate a reply.","One thing to note is that your error messages on failing tests when utilizing `workerThreads` are much more confusing and less helpful. I think if I recall correctly this is due to something like `workerThreads` utilizing the new structured clone, while the other was likely utilizing JSON serialization. So if you utilize something like Decimal JS it does not support structured cloning which will then have Jest blowing up on its internals \ud83d\ude2c  ie: https:\/\/github.com\/MikeMcl\/decimal.js\/issues\/224\r\nIt's good to note this is still an experimental feature, so it may be unstable or change.","Same Prisma issue as @ctsstc. It's funny how passing tests work, but then upon failing assertion it errors. I guess it's the failing test results that causes returning the data and fail serialization. And as background we have added support for bigints on our JSON.parse\/stringify but this doesn't seem used by the workers then for some reason.\r\n\r\nDoes someone have skills to revive @sauravhiremath attempt fixing this https:\/\/github.com\/jestjs\/jest\/pull\/11624#issue-934013512"],"labels":["Needs Triage","Bug Report"]},{"title":"Sporadic \"Command failed with exit code 1\" but no test failure","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nIn the CI of my repository, I frequently see this error:\r\n\r\n```\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nHowever, the log before does not show any failure, just some passing tests and some console outputs from the code under test. Locally, I am unable to reproduce this issue.\r\n\r\nMy tests are defined as asynchronous functions, but I have taken care to use `await` appropriately so, in theory, this should not be an issue. Nevertheless, it seems as if jest ends before all tests have been completed.\r\n\r\n## To Reproduce\r\n\r\nSee link to repl below, unfortunately, the issue occurs sporadically only.\r\n\r\n## Expected behavior\r\n\r\nEither the exit code should be zero, or there should be at least one failing test displayed, or there should be an error message if the test setup is wrong for whatever reason.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nJust check out my repository where I have collected a number of these flaky builds: https:\/\/github.com\/LinqLover\/downstream-repository-mining\/issues\/65\r\n\r\n## envinfo\r\n\r\n- OS: Ubuntu 20.04.2 LTS\r\n- Node 14.17.0\/x64\r\n- Yarn: v1.22.10\r\n- jest: ^26.6.3 => 26.6.3 \r\n\r\n---\r\n\r\nThanks in advance!","comments":["In some cases, I also see some of my tests timing out. This is a problem of myself, of course, but could jest maybe fail to show up a proper timeout error if the test is running asynchronously?","This is weird:\r\n\r\n```\r\n    thrown: \"Exceeded timeout of 5000 ms for a test.\r\n    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.\"\r\n```\r\n\r\nIn the very first line of my (async) test, I do exactly this and set the timeout to 10000 ms. Apparently my test times out even before it starts ...","This is the most obvious output I have gotten so far:\r\n\r\n```\r\nyarn run v1.22.10\r\n$ cross-env NODE_OPTIONS=--experimental-vm-modules jest\r\n(node:1806) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\nerror Command failed with exit code 1.\r\ninfo Visit https:\/\/yarnpkg.com\/en\/docs\/cli\/run for documentation about this command.\r\nError: Process completed with exit code 1.\r\n```\r\n\r\n(https:\/\/github.com\/LinqLover\/downstream-repository-mining\/runs\/2885248978#step:8)","Further investigation has revealed that the issue only appears when running tests from all test files together but not when I only run a single test file. I added some debugging statements at the end of each test and found out that sometimes jest indicates the success of one of these tests before the final console statement is printed!\r\n\r\nI guess something with asynchronous test execution is broken. Everything after an `await` in my test apparently is executed after the jest has already registered the test as a success and then it hangs ...:\r\n\r\nhttps:\/\/github.com\/LinqLover\/downstream-repository-mining\/blob\/0316d80141db5681eb53e59b306a0b13e851f7f8\/test\/npm-deps.test.ts#L56-L78\r\n\r\nPS: I traced this further down and found out that in my case, the test execution will always be interrupted when the first asynchronous call to `fs` is awaited.","## Reproduction\r\n\r\n```bash\r\n$ git clone https:\/\/github.com\/LinqLover\/downstream-repository-mining.git\r\n$ cd downstream-repository-mining\r\n$ git checkout 0316d80141db5681eb53e59b306a0b13e851f7f8\r\n$ yarn install\r\n$ yarn test test\/references.test.ts  # optionally run with option -i\r\n  yarn run v1.22.10\r\n  $ cross-env NODE_OPTIONS=--experimental-vm-modules jest test\/references.test.ts\r\n  (node:1712) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time\r\n  (Use `node --trace-warnings ...` to show where the warning was created)\r\n  \r\n   RUNS  test\/references.test.ts\r\n  error Command failed with exit code 1.\r\n```","I have the same issue.\r\nIs there any workarounds?","Any solution? Bump","same issues , any work around?","I am facing the same issue after updating react-script from v4 to v5. any workaround or solution?","same issue\r\n\r\nSolved it: it was caused by a forgotten `await` in front of the async func which was logging after the test ended. Although all tests were passing because of this logging Jest was exiting with code:1","I had this issue because I had a few obsolete snapshots. Removing them caused it to exit properly","Also run into this randomly with Jest v29.5.0 .\r\nThere was not \"Logging after tests\" message, but found this in between the tests:\r\n```\r\n(node:66) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 response listeners added to [ClientRequest]. Use emitter.setMaxListeners() to increase limit\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"Only failed tests not working in watch mode","body":"## \ud83d\udc1b Bug Report\r\n\r\n\"only failed tests\" mode while in watch mode continues to run every test.\r\n\r\n## To Reproduce\r\n\r\n```\r\n\/\/ test.js\r\ntest('passes', () => {\r\n  console.log('passing test')\r\n  expect(true).toBeTruthy();\r\n})\r\n\r\ntest('fails', () => {\r\n  console.log('failing test')\r\n  expect(true).toBeFalsy();\r\n})\r\n```\r\n\r\n```\r\n\/\/ package.json\r\n{\r\n  \"scripts\": {\r\n    \"test\": \"jest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"jest\": \"^27.0.4\"\r\n  }\r\n}\r\n```\r\n\r\n1. `npm install`\r\n2. `npm test -- --watch`. Both tests run, 1 pass and 1 fail\r\n3.  `f` to Press f to run only failed tests. Both tests still run, 1 pass and 1 fail.\r\n\r\n## Expected behavior\r\n\r\nAfter the initial run I would expect only the failing test to run\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\nhttps:\/\/replit.com\/@samjg1\/watch-test\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\nSystem:\r\n    OS: macOS 11.4\r\n    CPU: (8) arm64 Apple M1\r\n  Binaries:\r\n    Node: 15.11.0 - ~\/.nvm\/versions\/node\/v15.11.0\/bin\/node\r\n    Yarn: 1.22.10 - ~\/.nvm\/versions\/node\/v15.11.0\/bin\/yarn\r\n    npm: 7.6.0 - ~\/.nvm\/versions\/node\/v15.11.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.4 => 27.0.4\r\n```\r\n","comments":["Also seeing this bug.\r\n```\r\nSystem:\r\n    OS: macOS 11.2.2\r\n    CPU: (8) arm64 Apple M1\r\n  Binaries:\r\n    Node: 14.6.0\r\n    npm: 7.19.1\r\n  npmPackages:\r\n    jest: ^27.0.4\r\n ```","I experience the same issue in all my projects.\r\n\r\nLooks like almost no one uses that feature, hence there's so few reports here \ud83d\ude1e ","@MichalLytek I use it and have been stuck on 26 for a while now. It\u2019s mildly disturbing how little attention this has gotten though.","Closed my duplicate bug, here's the test repo: https:\/\/github.com\/ildella\/jest-watch-failures-behavior and the config\r\n\r\n```\r\nnpx: installed 1 in 0.522s\r\n\r\n  System:\r\n    OS: Linux 5.11 Ubuntu 20.04.2 LTS (Focal Fossa)\r\n    CPU: (8) x64 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz\r\n  Binaries:\r\n    Node: 14.18.0 - \/usr\/bin\/node\r\n    Yarn: 1.22.11 - ~\/n\/bin\/yarn\r\n    npm: 6.14.15 - ~\/n\/bin\/npm\r\n  npmPackages:\r\n    jest: 27.2.5 => 27.2.5\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","it's still an issue","I'm seeing something likely related.\r\n\r\nI have a set of failing tests.\r\n\r\nFrom the command line I run `yarn test --watch` and it runs the failing tests.\r\n\r\n```\r\nTest Suites: 9 failed, 9 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        8.078 s\r\n```\r\n\r\nIf I press `f`, it says nothing to do\r\n```\r\nNo failed test found.\r\nPress `f` to quit \"only failed tests\" mode.\r\n\r\nWatch Usage: Press w to show more.\r\n\r\n```\r\nif I press `f` again, it runs *all* tests\r\n```\r\nTest Suites: 9 failed, 5 passed, 14 total\r\nTests:       54 passed, 54 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        8.422 s\r\n```\r\nif I press `f` again, it says nothing to do\r\n```\r\nNo failed test found.\r\nRun Jest without `--onlyFailures` or with `--all` to run all tests.\r\n\r\nWatch Usage: Press w to show more.\r\n```\r\nbut the previous test *just* showed 9 failures.\r\n\r\nIf I run all `yarn test` and then with watch it only runs failures\r\n```\r\n$ yarn test\r\n...\r\nTest Suites: 9 failed, 5 passed, 14 total\r\nTests:       54 passed, 54 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        12.851 s\r\n\r\n$ yarn test --watch\r\nTest Suites: 9 failed, 9 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        7.473 s\r\n```\r\nand again `f` for failed only mode does not work.\r\n\r\nI did notice `--watch --onlyFailures` on the command line does initially run only failures (but it seems `yarn test --watch` also does that).\r\n\r\nThen if I actually fix a test and it runs again, then it continues to run all tests.\r\n\r\n```\r\n\/\/ after repairing a test with --watch --onlyFailures flags\r\n\r\nTest Suites: 8 failed, 1 passed, 9 total\r\nTests:       6 passed, 6 total\r\nSnapshots:   0 total\r\nTime:        8.643 s\r\nRan all test suites related to changed files.\r\n```\r\n\r\nIt feels like the whole `--watch` + only failures doesn't work anymore.  It's been a while but I've used it before and I remember it working.  This is a new project and we've been trying to keep up with the latest.\r\n\r\n```\r\n# Mac Intel \r\n$ uname -a\r\nDarwin kinda 21.6.0 Darwin Kernel Version 21.6.0: Wed Oct  4 23:55:28 PDT 2023; root:xnu-8020.240.18.704.15~1\/RELEASE_X86_64 x86_64\r\n$ node -v \r\nv18.14.2\r\n$ yarn -v  \r\n1.22.21\r\n```\r\n\r\nJest related packages (`grep jest package.json`)\r\n```\r\n\r\n# Jest related packges\r\n    \"@jest\/globals\": \"^29.7.0\",\r\n    \"@testing-library\/jest-dom\": \"^6.2.1\",\r\n    \"@types\/jest\": \"^29.5.12\",\r\n    \"babel-jest\": \"^29.7.0\",\r\n    \"eslint-plugin-jest\": \"^27.6.3\",\r\n    \"eslint-plugin-jest-dom\": \"^5.1.0\",\r\n    \"jest\": \"^29.7.0\",\r\n    \"jest-environment-jsdom\": \"^29.7.0\",\r\n    \"jest-scss-transform\": \"^1.0.3\",\r\n    \"ts-jest\": \"^29.1.2\",\r\n    ```","@bunnymatic yes that's also another issue. \r\nIf a test is failing in some particular way, it won't rerun in \"only-failure\" mode. \r\nClassic example: an error in the test suite is thrown in `before*` function. That woul make the suite fail, but no rerun tests in only-failure mode. \r\n\r\nBut it's a different issue. "],"labels":["Needs Triage","Bug Report"]},{"title":"Jest with TypeScript and ES modules can't import \"named imports\" from cjs modules","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nUsing TS, exports from CJS modules can be imported with syntax as if they were named ES module exports, e.g.:\r\n\r\n```\r\nimport { sync } from 'glob';\r\n```\r\n\r\nHowever, with Jest and ES modules, when this style of import is in a test file or in a dependency of a test file, it says `SyntaxError: The requested module 'glob' does not provide an export named 'sync'`\r\n\r\nGoing through all one by one and changing them to `import glob from 'glob';` and then calling `glob.sync()` seems to work, however when migrating some legacy stuff from another test runner to Jest this may not be an option, because there are a lot of those such imports in the codebase.\r\n\r\nIs there a way around this, so that `import { whatever } from 'whatever';` will work for CJS modules?\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nRunning jest with: `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js` (as described in https:\/\/jestjs.io\/docs\/ecmascript-modules), and using Jest config:\r\n```\r\n  resetMocks: true,\r\n  testEnvironment: \"node\",\r\n  testMatch: [\r\n    \"**\/src\/**\/*.(spec|test).[tj]s?(x)\"\r\n  ],\r\n  preset: 'ts-jest\/presets\/default-esm',\r\n  transform: {},\r\n  'extensionsToTreatAsEsm': [\".ts\", \".tsx\"],\r\n  globals: {\r\n    'ts-jest': {\r\n      useESM: true,\r\n      tsconfig: {\r\n        allowSyntheticDefaultImports: true,\r\n        declaration: true,\r\n        esModuleInterop: true,\r\n        jsx: \"react\",\r\n        lib: [\"esnext\"],\r\n        module: \"es2020\",\r\n        moduleResolution: \"node\",\r\n        outDir: \"build\",\r\n        sourceMap: true,\r\n        strictNullChecks: true,\r\n        target: \"ES2020\",\r\n      }\r\n    },\r\n  }\r\n```\r\n\r\n## Expected behavior\r\n\r\n`import { sync } from 'glob'` and similar imports from CJS modules work.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/themaskedavenger\/tsjestcjerepro\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz\r\n  Binaries:\r\n    Node: 15.14.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.0 - \/usr\/local\/bin\/yarn\r\n    npm: 7.7.6 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.4 => 27.0.4 \r\n```\r\n","comments":["In hopes that it speeds things along and removes any question as to ownership, I forked the repository provided by @themaskedavenger and removed all typescript related stuff to show it's a jest issue.\r\n\r\nhttps:\/\/github.com\/k2snowman69\/tsjestcjerepro\r\n\r\nHopefully this removes any doubt that this is a ts or a ts-jest issue\r\n\r\nTested with node 14.17.1 and node v16.1.0","Okay so dug into this a bit and hopefully my investigation helps whoever ends up fixing this on jest's side.\r\n\r\nThe first and important thing to note is that jest does not use nodejs to resolve files. This tripped me up a lot until I figured this out. Both jest and nodejs use `cjs-module-lexer` which uses basic regex to parse a contents of a file to determine what the exported functions are from a cjs library. The owner of that library had a [great explanation](https:\/\/github.com\/guybedford\/cjs-module-lexer\/issues\/57#issuecomment-862413992) that helped guide the rest of this investigation. Now what this means is the same package has the possibility of behaving differently between nodejs and jest and that's really important because that gap between the two is going to cause lots of confusion... so using a few examples let's take this package by package...\r\n\r\n### glob\r\n\r\nGlob's export code looks like `module.exports = glob` which would require an eval on the js code to determine what the exports are. This is why `cjs-module-lexer` cannot determine the exports, because it's purely basing it off regex for performance reasons required by nodejs. This will fail in both nodejs and jest.\r\n\r\n### enzyme\r\n\r\nEnzyme's export code looks like\r\n```\r\nmodule.exports = {\r\n  render: _render2['default'],\r\n  shallow: _shallow2['default'],\r\n  mount: _mount2['default'],\r\n  ShallowWrapper: _ShallowWrapper2['default'],\r\n  ReactWrapper: _ReactWrapper2['default'],\r\n  configure: _configuration.merge,\r\n  EnzymeAdapter: _EnzymeAdapter2['default']\r\n};\r\n```\r\nhowever it seems that `cjs-module-lexer` is only able to extract the first exported function. I commented about this bug in https:\/\/github.com\/guybedford\/cjs-module-lexer\/issues\/57 and provided a unit test for reproduction. Hopefully we can see it get fixed.\r\n\r\n### tslib\r\n\r\ntslib actually supports cjs, es6 through the `module` property (non-standard) and ESM through the `exports` property (node compatible) so this should work.\r\n\r\nWhen running the following code in node in either cjs or esm there are no errors (as expected)\r\n```\r\nimport { __assign } from \"tslib\";\r\n\r\nconst d = __assign({ a: \"a\" });\r\nconsole.log(d.a);\r\n```\r\n\r\nHowever when running the following test in Jest ESM:\r\n```\r\nimport { __assign } from \"tslib\";\r\n\r\ntest.only(\"General config is working\", async () => {\r\n  const d = __assign({ a: \"a\" });\r\n  expect(d.a).toBe(\"a\");\r\n});\r\n```\r\nYou'll get the following error:\r\n```\r\n FAIL  src\/tslib.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    SyntaxError: The requested module 'tslib' does not provide an export named '__assign'\r\n\r\n      at Runtime.linkAndEvaluateModule (node_modules\/jest-runtime\/build\/index.js:669:5)\r\n```\r\n\r\nWhich means that jest's resolver isn't resolving the same file that node js is resolving that eventually gets sent to `cjs-module-lexer` so that it can correctly determine the exports.\r\n\r\n### Summary\r\n\r\nHopefully that gives some guidance to someone who investigates this and maybe we can at least fix this for tslib. To fix this for glob however, you'll need to fix it in `cjs-module-lexer`. I'd still leave this ticket open to hopefully fix it for tslib though.","This happens to me even with react.\r\nCan't use `import {useState} from 'react'`\r\nHave to write it this way\r\n\r\n```js\r\nimport React from 'react'\r\nconst {useState} = React\r\n```\r\n\r\nAnd `react-use` has the same problem\r\n","Just ran into this myself...incredibly frustrating bug.","+1 I am seeing the same issue with a very similar setup (jest with ESM, relying on named exports from a CJS module).","Is there no fix for this yet? ","+1 also wondering if there is a solution for this?","@k2snowman69  Thanks for your detailed analysis of the root cause of the problem. \r\n\r\nLike @yqrashawn  i am also facing Jest not able to do perform named export even in react package. \r\n\r\nCurrent Temp solution is to import the whole package default and extract individual exports \r\n\r\n```\r\nimport React from 'react'\r\n\r\nReact.useEffect\r\n```\r\n\r\nBut its a pain staking process, and i would like to automate somehow, any suggestion. "],"labels":["Needs Triage","Bug Report"]},{"title":"Resolve PnP Virtuals when collecting test coverage","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\n<!-- A clear and concise description of what the feature is. -->\r\n\r\nYarn Berry introduces the concept of a virtual package, whereby a source file may appear to Jest under a name different than the \"real path\". This happens when installing a workspace in a monorepo as a peer dependency of another workspace. As a result, when collecting coverage across the entire monorepo, if `.yarn\/__virtual__` is added to `collectCoverageFrom`, we will get more than one file with coverage reported, even though they point to the same underlying file in the filesystem.\r\n\r\nI propose we resolve the virtuals to the real path, to allow coverage merging.\r\n\r\n## Motivation\r\n\r\n<!-- Please outline the motivation for the proposal. -->\r\n\r\nI have a monorepo with workspaces `monodeploy`, `@monodeploy\/cli`, `@monodeploy\/changelog`.\r\n\r\n`monodeploy` depends on `@monodeploy\/cli` as a dependency, and `@monodeploy\/cli` depends on `@monodeploy\/changelog` as a peer dependency. This results in `require.resolve('@monodeploy\/changelog')` pointing to a virtual path, e.g. `.yarn\/__virtual__\/@monodeploy-changelog-virtual-699b9c0a11\/1\/packages\/changelog\/src`.\r\n\r\nI have tests that run in each workspace. The tests colocated in `@monodeploy\/changelog` will generate coverage for `<rootDir>\/packages\/changelog\/**\/*.ts`. The tests located in `monodeploy` which indirectly depend on `@monodeploy\/changelog` will generate coverage for `.yarn\/__virtual__\/@monodeploy-changelog-virtual...`. I want these 2 coverage files to be merged, and listed under the real path.\r\n\r\n## Example\r\n\r\n<!-- Please provide an example for how this feature would be used. -->\r\n\r\nIdeally this would just work, no need for additional setup. Only requirement would be to instruct jest to collect coverage from the .yarn virtuals filepath.\r\n\r\n## Pitch\r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nThis is required in jest because it cannot be added anywhere else. Yarn is not aware of how it will be used, so it can't make an exception for jest's coverage.\r\n\r\n## Additional Comments\r\n\r\nHere's an example of resolving a virtual path as it's used by the typescript yarn patch: https:\/\/github.com\/yarnpkg\/berry\/blob\/e53036a37f5763d2568a1f7465c9a7562e091129\/.yarn\/sdks\/typescript\/lib\/tsserver.js#L40.\r\n\r\n```ts\r\nconst pnpApi = require(`pnpapi`)\r\n\r\nconst mySourceFile = '<rootDir>\/.yarn\/__virtual__\/...\/my\/file.ts'\r\npnpApi.resolveVirtual(mySourceFile)\r\n```\r\n\r\n---\r\n\r\nI managed to get accurate reporting by adding this to `FileCoverage` in `istanbul-lib-coverage\/lib\/file-coverage.js` so perhaps this is out of scope of jest and should be moved to a feature request in istanbul? Or is there somewhere in jest where we call istanbul that we can pass a different name? (I'm using `ts-jest` for reference).\r\n\r\n```js\r\nif (process.versions.pnp && this.data.path && this.data.path.includes('\/__virtual__\/')) {\r\n        this.data.path = require('pnpapi').resolveVirtual(this.data.path);\r\n}\r\n```\r\n\r\nAlthough the reporting was accurate, the report itself still showed the virtual path. I think perhaps we can transform the paths before passing it off into istanbul? So we can keep this in one place in jest. Perhaps the CoverageReporter file?","comments":["Got this working with a Yarn patch on istanbul-lib-coverage, though as I mention in the issue, I think this should be hoisted into jest somehow:\r\n\r\n```diff\r\ndiff --git a\/lib\/coverage-map.js b\/lib\/coverage-map.js\r\nindex 0a1ebd0a90f958cabf94481fc6ea2dff206bfeb2..36c26a7c423c6db22d2cf1a433d6775a7c0346ce 100644\r\n--- a\/lib\/coverage-map.js\r\n+++ b\/lib\/coverage-map.js\r\n@@ -41,6 +41,16 @@ class CoverageMap {\r\n         } else {\r\n             this.data = loadMap(obj);\r\n         }\r\n+\r\n+        if (process.versions.pnp && this.data) {\r\n+            const pnpapi = require('pnpapi');\r\n+            this.data = Object.fromEntries(Object.entries(this.data).map(([k, data]) => {\r\n+                if (k.includes('\/__virtual__\/')) {\r\n+                    return [pnpapi.resolveVirtual(k), data];\r\n+                }\r\n+                return [k, data];\r\n+            }));\r\n+        }\r\n     }\r\n \r\n     \/**\r\ndiff --git a\/lib\/file-coverage.js b\/lib\/file-coverage.js\r\nindex ed056a6f3bd7eaa7bd38b2778c029be5b422648f..2b7d43454f0e3e83a479237fdff60cc48f0601a1 100644\r\n--- a\/lib\/file-coverage.js\r\n+++ b\/lib\/file-coverage.js\r\n@@ -76,6 +76,10 @@ class FileCoverage {\r\n             throw new Error('Invalid argument to coverage constructor');\r\n         }\r\n         assertValidObject(this.data);\r\n+\r\n+        if (process.versions.pnp && this.data.path && this.data.path.includes('\/__virtual__\/')) {\r\n+            this.data.path = require('pnpapi').resolveVirtual(this.data.path);\r\n+        }\r\n     }\r\n \r\n     \/**\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I'd definitely like this directly addressed, though my patch has been working quite well. I still don't believe istanbul is the  right place to do this.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Feature request is still relevant I believe."],"labels":[":rocket: Feature Request"]},{"title":"Jest 27: jest.setTimeout has no effect when used in `async` test","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udca5 Regression Report\r\n\r\n<!-- A clear and concise description of what the regression is. -->\r\n\r\n## Last working version\r\n\r\nWorked up to version: 26.6.3\r\n\r\nStopped working in version: 27.0.0\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n1. Have an `async` test that takes longer than 5 seconds\r\n2. Use `jest.setTimeout(10000)` to increase timeout\r\n3. Run test, see this\r\n   <img src=\"https:\/\/user-images.githubusercontent.com\/17641229\/121192806-9616d000-c86d-11eb-916a-ca25c1e731cb.png\" width=\"600\" \/>\r\n\r\n\r\n## Expected behavior\r\n\r\n`jest.setTimeout(...)` to have an effect like it did in v26.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/AlCalzone\/jest-settimeout-repro\r\n\r\n1. clone the repo\r\n2. `yarn && yarn test`\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```\r\n  System:\r\n    OS: Windows 10 10.0.19041\r\n    CPU: (24) x64 AMD Ryzen 9 3900X 12-Core Processor\r\n  Binaries:\r\n    Node: 12.22.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.10 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.14.13 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^27.0.4 => 27.0.4\r\n```\r\n","comments":["I had the same problem and was able to (temporarily) resolve it by moving the `jest.setTimeout(...)` to the top level scope, i.e. outside of the `describe` block. This is obviously not ideal as it applies to all tests within that file but might help some people until this is issue fixed.\r\n\r\nIn [this related issue](https:\/\/github.com\/facebook\/jest\/issues\/11500) the author also mentioned that setting the timeout in the global jest config still works.\r\n","Hello @AlCalzone , can you tell me what is the ts-jest, @types\/jest versions are you using with jest @26.6.3 for which test cases are working?\r\n\r\nHello @Krillian111  when we say setting the timeout in the global jest config, did you mean in the test file or in the beforeAll() of jest.config.json file?. Actually, I tried both for jest V27, but still getting the same error. Even increased the timeout value to 60000, but still no difference.\r\n\r\nYour inputs are highly appreaciated, since have been dealing with the error on the 2nd day. Have already tried whatever found on the Google.","`ts-jest` not used, I'm using `babel-jest ^26.6.3`\r\n`@types\/jest`: `^26.0.23`","experiencing the same problem. I was using `setTimeout` to flush promises\/simulate a period of time passing (in legacy tests). I suspect this is related to the new \"modern\" implementation of timers and how the globals such as `setTimeout` are modified.","Using `@babel\/preset-env ^7.14.8` and `jest ^27.0.5` I encountered the same behaviour. If the timer is meant to last per test, just add the timeout value as a parameter as showed in https:\/\/github.com\/facebook\/jest\/issues\/5055#issuecomment-558316914\r\n\r\nIt worked for me","also encountered this issue, @seffs solution works like a charm. thank you!","```\r\n\"@types\/jest\": \"27.0.1\",\r\n\"jest\": \"27.2.0\",\r\n\"ts-jest\": \"27.0.5\",\r\n```\r\n\r\nsolution with global timeout works for me as well","This is still happening for me. Passing a 3rd argument to the `it` function works, but it destroys the readability of the test - it looks like some random number hanging out at the end of a test when I'd rather declare `jest.setTimeout(...)` at the top of a test. Not a deal breaker, but would definitely like to nudge this issue a little bit. ","Hard to believe in 2022 this is STILL an issue, but here we are!","It's even harder to believe that it's 2022 and people still troll around leaving useless condemning comments on free open source projects. There are numerous related issues and workarounds, thereby making this a very minor inconvenience. You're also welcome to fix it yourself and open a PR, or maybe even start a bounty to encourage someone else to fix it. Or nothing... you could try doing absolutely nothing... and that would be more helpful than your comment. ","Zing!\n\nOn Mon, Aug 1, 2022 at 2:11 PM Ryan Wheale ***@***.***> wrote:\n\n> It's even harder to believe that it's 2022 and people still troll around\n> leaving useless condemning comments on free open source projects. There are\n> numerous related issues and workarounds, thereby making this a very minor\n> inconvenience. You're also welcome to fix it yourself and open a PR, or\n> maybe even start a bounty to encourage someone else to fix it. Or\n> nothing... you could try doing absolutely nothing... and that would be more\n> helpful than your comment.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/11543#issuecomment-1201725810>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AP65RMX5Q5HYQNZWVGCFZETVXA4RPANCNFSM46J6MZCA>\n> .\n> You are receiving this because you commented.Message ID:\n> ***@***.***>\n>\n-- \nDanno Mayer\nCell: (206) 920-0056\n***@***.***\nhttps:\/\/www.linkedin.com\/in\/dvmayer\/\n","For now a simple replacement that worked for me was using\r\n\r\n```ts\r\nit('should be a long running test', async () => {\r\n  expect(true).toBe(true);\r\n\r\n  \/\/ Setting the time here as a second parameter seems to work even with async.\r\n}, 30_000)\r\n```","> It's even harder to believe that it's 2022 and people still troll around leaving useless condemning comments on free open source projects. There are numerous related issues and workarounds, thereby making this a very minor inconvenience. You're also welcome to fix it yourself and open a PR, or maybe even start a bounty to encourage someone else to fix it. Or nothing... you could try doing absolutely nothing... and that would be more helpful than your comment.\r\n\r\nlet me explain something to you *expletive* and maybe.. just may be.. you will understand. \r\na day has 24 hours. 9 hrs goes to sleep, 9 hrs goes to work, 2 hrs goes to exercise prep and eat food -- that is 20 hrs and is a pretty moderate disposition. \r\n\r\nthat leaves 4 hrs on weekdays and 13 hrs on weekends which is 76 hrs a week.\r\n\r\nhow many hours do you need to wrap your head around this issue.. depends... but lets be generous and for someone who never looked at the jest codebase before it could easily take 40 hrs. (8 hrs week)\r\n\r\ndont know what you *expletive* do for a living but i will speak for us full stack engineers who deal with gazillions of open source frameworks and having very moderately speaking 3 issues like this on a daily basis.\r\n\r\nso if we were to use your *genius* approach to fix everything we come across we'd accumulate 3*40 = 120 hrs of work each week at that would leave us 44 hrs behind each week.\r\n\r\n44 hrs behind each week. and that is living a very dedicated lifestyle of just coding which doesnt allow time for gf, any kind of fun, personal errands even dr. appts etc etc -- forget travelling -- that is the no-life lifestyle and even with that lifestyle you'd be left behind 44 hrs behind each week.\r\n\r\nnow, most time we dont even get to choose what frameworks we want to use so we'd be stuck with whatever *expletive* framework that *expletive* manager of ours picks.\r\n\r\nSO **lots of expletives**","Let me tell you something about open source - most of the time it is half-assed. I do not say commercial software is good, but open sourse is half-assed ridiculously often. The reason for this is some \"bright\" guy from company with recognizable name, say F, has decided to make integration of technology X and Y. He created PoC and then just lost interest to the project because got what he was aming for. The the community saw that there is a nice new project with some potential and started to make contributions that were eventually merged to the project that made It looks like it is alive. Now we have zombi project and nobody tries to create a clone or replacement for years, because it is supported by the guy from F and thus by F itself. You know what I mean? Then there are different scenario like we all know eslint-plugin-node (that is kinda of good scenario) and jest\/typescript\/typeorm\/react-router\/react-big-calendar\/etc... where we have such stupid issues lasting for years. Jest was developed as the replacement of everdiying mocha but apperently shares the same destiny. So stop bitching about bad community that is bugging you for years and fix that damn bug.\r\n\r\nPS just want to say special \"hello\" to some of those guys who values their time and shits on the community @taion @pleerock \r\n","You have written such an awesome post. Have you though about writting a PR to fix this issue? I'm not sure if It would take you less time than the one you've employ on your rant, but definitely It would have cost you less characters and key strokes.","> It's even harder to believe that it's 2022 and people still troll around leaving useless condemning comments on free open source projects. There are numerous related issues and workarounds, thereby making this a very minor inconvenience. You're also welcome to fix it yourself and open a PR, or maybe even start a bounty to encourage someone else to fix it. Or nothing... you could try doing absolutely nothing... and that would be more helpful than your comment.\r\n\r\nFor the people that don't want or not have time to learn the internals of the library and don't want to fix themselves every little error they found the only thing they can do is live with the problem , you say is free but they have other forms of make money , there is a lot of companies making money using free software. we want better libraries or at least listen to the people. these people travel the world talking about their library full of bugs making money with a \"mediocre\" software."],"labels":[":boom: Regression"]},{"title":"Add option to use .gitignore or at least accept a function returning a boolean in testPathIgnorePatterns","body":"https:\/\/github.com\/facebook\/jest\/issues\/3515 got automatically closed and this is really useful to have.\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nAccept `.gitignore` with an option like `--ignore-path` as ESLint and Prettier do, in order to help to centralize common ignored patterns for tooling.\r\n\r\n## Motivation\r\n\r\nIn the current state we need to duplicate the patterns from other tooling in the Jest config file, and often we'll update just a single place and forget to update the other.\r\n\r\n## Example\r\n\r\n1st option) (**preferred**, to be aligned with other toolings)\r\n`jest --ignore-path .gitignore`\r\n\r\n2nd option)\r\n\r\n**jest.config.js**\r\n```js\r\nconst gitignorePatterns = parseGitIgnore(...);\r\n\r\nmodule.exports = {\r\n  testPathIgnorePatterns: function (filePath) {\r\n    return gitignorePatterns.some(pattern => pattern.test(filePath));\r\n  },\r\n}\r\n```\r\n\r\n## Pitch\r\n\r\nAll other major toolings have this option.\r\n","comments":["Currently `testPathIgnorePatterns` is an array of RexExps, it should fit your 2nd option.\r\n\r\nRegarding to 1st option, I think it is a nice idea for a feature.","The function sample using a regex was an arbitrary implementation detail, but the idea is to open it to be anything (e.g read the .gitignore manually and convert it to regexes).","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","This is still a relevant feature as all other toolings have a similar option.","Would also like to see this functionality. @rdsedmundo did you use a tool to generate the gitignore regex patterns, or is that a custom function you wrote?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale.\r\n\r\n@william-will-angi yes, I ended up using https:\/\/www.npmjs.com\/package\/parse-gitignore."],"labels":[":rocket: Feature Request"]},{"title":"fix: jest-circus shares events among imports #11483","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\ncloses #11483\r\n\r\n## Summary\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\nThe issue is described here: https:\/\/github.com\/facebook\/jest\/issues\/11483\r\n\r\nA public interface to subscribe to events from `jest-circus`.\r\n\r\n## Test plan\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n\r\nNo changes in UI.","comments":["Hi @satanTime! \n\nThank you for your pull request and welcome to our community. \n\n# Action Required\n\nIn order to merge **any pull request** (code, docs, etc.), we **require** contributors to sign our **Contributor License Agreement**, and we don't seem to have one on file for you.\n\n# Process\n\nIn order for us to review and merge your suggested changes, please sign at <https:\/\/code.facebook.com\/cla>. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need to sign the corporate CLA.\n\nOnce the CLA is signed, our tooling will perform checks and validations. Afterwards, the **pull request will be tagged** with `CLA signed`. The tagging process may take up to 1 hour after signing. Please give it that time before contacting us about it.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fjest%20%2311529). Thanks!","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) Report\n> Merging [#11529](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (fcde463) into [main](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/faef0b4b7082df574a0e4423b86d468847360f17?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (faef0b4) will **decrease** coverage by `0.06%`.\n> The diff coverage is `100.00%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n\n```diff\n@@            Coverage Diff             @@\n##             main   #11529      +\/-   ##\n==========================================\n- Coverage   68.47%   68.41%   -0.07%     \n==========================================\n  Files         324      324              \n  Lines       16967    16972       +5     \n  Branches     5060     5062       +2     \n==========================================\n- Hits        11618    11611       -7     \n- Misses       5317     5329      +12     \n  Partials       32       32              \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/jest-circus\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jaXJjdXMvc3JjL2luZGV4LnRz) | `70.66% <\u00f8> (\u00f8)` | |\n| [packages\/jest-circus\/src\/state.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jaXJjdXMvc3JjL3N0YXRlLnRz) | `95.65% <100.00%> (+16.70%)` | :arrow_up: |\n| [packages\/jest-circus\/src\/types.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jaXJjdXMvc3JjL3R5cGVzLnRz) | `100.00% <100.00%> (\u00f8)` | |\n| [packages\/jest-circus\/src\/eventHandler.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jaXJjdXMvc3JjL2V2ZW50SGFuZGxlci50cw==) | `0.75% <0.00%> (-9.10%)` | :arrow_down: |\n| [packages\/jest-circus\/src\/formatNodeAssertErrors.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jaXJjdXMvc3JjL2Zvcm1hdE5vZGVBc3NlcnRFcnJvcnMudHM=) | `9.21% <0.00%> (-2.64%)` | :arrow_down: |\n| [packages\/jest-circus\/src\/utils.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jaXJjdXMvc3JjL3V0aWxzLnRz) | `11.32% <0.00%> (-0.48%)` | :arrow_down: |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Last update [faef0b4...fcde463](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11529?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n","HI @SimenB,\r\n\r\nthe PR has been rebased.","HI @SimenB,\r\n\r\nthe PR has been rebased.","Hi @SimenB,\r\n\r\nthe PR has been rebased.","Hi @SimenB,\r\n\r\nthe PR has been rebased.","Hi @SimenB, might you explain what the problem with this PR is?\r\nIts merge would bring huge relief in life-cycle management.","Hi @satanTime! I'd just like to say thank you for sticking by this PR without any feedback from me. Unfortunately, I've had little to no combination of time, effort, energy or plain want to work on OSS for months, so this (and other stuff) has just been hanging. The entire \ud83d\udca9storm that is ESM in Node (and specifically its `vm` API which upstream V8 seems to not care about enabling) completely drained any and all joy I got out of working on OSS in general and Jest specifically.\r\n\r\nHopefully I'll come back to it sooner rather than later, but PRs such as this (where the code itself isn't the hard part, but rather if the underlying issue is something we should support and secondly if the solution here is correct) is not something I'm currently in the correct place to consider","@SimenB I'm curious, are you the only maintainer of jest now? Is facebook not supporting this project internally anymore?","Nobody at FB (Meta?) has worked on Jest for years at this point, beyond a few PRs here and there like any other open source contributor ","Hi @SimenB, glad to see you alive :) And happy new year!\r\n\r\nOpen source is huge pain in the hole :) I hope nobody will give up, only the brave!\r\n\r\nI've rebased the PR. Please let me know if there is anything I need to change \/ explain etc :)","Regarding the issue, I think it's context hell.\r\n\r\nDifferent dependencies require `jest-circus` in different places and each `require` creates a different context, that's why `require` in global scope has its own context and doesn't allow to properly manage `EVENT_HANDLERS`.","> Nobody at FB (Meta?) has worked on Jest for years at this point, beyond a few PRs here and there like any other open source contributor\r\n\r\nI honestly though you were working for Facebook in development of Jest, what a shame :-(","I commented it on Twitter: https:\/\/twitter.com\/mafalda_sfu\/status\/1488600128680341517\r\n\r\nWe need to make noise, @meta is still publicing Jest as from them but they are not maintaining anymore, while in fact they should have contracted @SimenB to maintaining it, that's the fair thing to do on this topic.","(To avoid potential drama I _definetely_ do not have the energy for, I'll make this preemptive post).\r\n\r\nJust to make sure everybody is on the same page - while FB has never paid me (or, as far as I know, any other non-employee) to work on Jest, that doesn't mean there hasn't been opportunities to be paid for the work I and others have put into the project. Specifically the Open Collective has been available, and I've been told multiple times to file expenses against it. However, personally, I've preferred to keep the time I've spent on this project without compensation to avoid feeling compelled to work on it. It might be idealistic, but by not getting paid for the work I've purposefully kept the project from something I've felt obligated to work on. I think by taking the money I'd feel obligated (rightly!) to dedicate time to the project. Which I've never felt comfortable doing. This is a personal choice to keep my independence (and freedom to not interact with the project as much as I probably should the last months), but does not reflect on FB's\/Meta's motivations or priorities. My personal choices doesn't mean FB has expected me to work for free, just that I've chosen not to take salary\/compensation.\r\n\r\nThat said I want to be clear there's no \"bad guy\" here - nobody is forcing me to (or trying to) work on things, and my off hands approach is solely down do lack of time and energy, and not any deeper motivation. Jest has been an open source project for years and continues to be so. Anybody missing any features should continue to feel free to contribute to make those features happen.\r\n\r\n(For transparency, FB paid for my and other OSS maintainers trip to London to work physically together on the project back in 2017 and 2018. I can provide more details if people want)","Hi all, could we keep this thread related to the PR with no drama and a pure focus on solving the issue?","@SimenB Is Meta using a different testing framework internally, or Jest is just good enough as-is for them?","Hi @SimenB, the PR has been rebased.\r\nWhat stops you from including in it the next major release?\r\n\r\nThe issue is context:\r\n\r\ncurrently it is like that:\r\n```ts\r\nconst a = () => {\r\n  const context = {};\r\n\r\n  return context;\r\n};\r\n\r\na() === a(); \/\/ false\r\n```\r\n\r\nwhen it should be \r\n```ts\r\nglobal.context = global.context || {};\r\n\r\nconst a = () => {\r\n  return global.context;\r\n};\r\n\r\na() === a(); \/\/ true and everybody is happy\r\n```","Hi @satanTime,\r\n\r\nSeeing the time needed for this to be merged, maybe you could publish a gist to use along with https:\/\/www.npmjs.com\/package\/patch-package, installed via a postinstall script ? Just wondering if this is doable....\r\nOf course, hotpatching jest isn't a viable long term solution, but it might at least be a POC users will use, and eventually give confidence to maintainers to (*finally*) merge this PR.\r\n\r\nI'm having the feeling that this package, used by a lot of people, would gain by redefining contributors permissions & include more people, so that you\/we could have more people to talk to to bring evolutions in.\r\n\r\nCheers","Hi @GerkinDev, it's a good idea, thanks for the hint. I just need to find time to implement it.","I wanted to give an update, in order to address the maintenance concerns mentioned in this thread, Jest has been transferred to a foundation. Hopefully this will help! https:\/\/engineering.fb.com\/2022\/05\/11\/open-source\/jest-openjs-foundation\/","Hi @vjeux, \r\n\r\nnot sure if that's changed anything, in the article it says \"Jest joining the OpenJS foundation does not change how Jest is developed or released\".\r\n\r\n@SimenB, is there a way to get someone from your team to take a look at this PR?\r\nWithout this change, and knowing about the issue in hooks https:\/\/github.com\/facebook\/jest\/issues\/12678, `jest` becomes a framework, which is very hard to support in 3rd-party libraries.","<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: satanTime  (d9cda507c07db32a0a38dc112013ac1042058e32)<\/li><\/ul>","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | d9cda507c07db32a0a38dc112013ac1042058e32 |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/6554ae3fd4495900082223dd |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-11529--jestjs.netlify.app](https:\/\/deploy-preview-11529--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTExNTI5LS1qZXN0anMubmV0bGlmeS5hcHAifQ.3FgstIaJx7c1tYnXqTIg6CjdewMO_V5Y5q27ZxWAgIE)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","Hi @SimenB, happy Wednesday!\r\n\r\nIs there an opportunity to get your attention on this issue again?\r\nThe fix is here for more than 2 years."],"labels":["cla signed"]},{"title":"the same context for addEventHandler from `jest-circus\/src\/state.ts`","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nThe problem is that I need to distinguish scopes on every `beforeAll` and `beforeEach` call.\r\nHowever, adding a listener on `addEventHandler` doesn't bring the desired effect, because the listener is added to a different context and hasn't been ever called.\r\n\r\nWith `jasmine` it was quite easy:\r\n\r\n```ts\r\njasmine.getEnv().addReporter(reporterStack);\r\n```\r\n\r\nAnd would be great to have the same behavior in `jest-circus`.\r\n\r\n## To Reproduce\r\n\r\nThis is the test and desired code: https:\/\/github.com\/satanTime\/jest-circus-hooks\/blob\/master\/src\/app\/app.component.spec.ts#L7-L21\r\n\r\nSteps to reproduce the behavior:\r\n\r\n- clone https:\/\/github.com\/satanTime\/jest-circus-hooks\r\n- npm install\r\n- npm run test\r\n- failure\r\n\r\n```\r\n> jest -w 1 --config jest.js\r\n\r\n FAIL  src\/app\/app.component.spec.ts\r\n  main block\r\n    \u2715 uses listener (2 ms)\r\n    sub block\r\n      \u2713 simulates positive (3 ms)\r\n```\r\n\r\n- edit `jest.ts` and uncomment `testRunner: 'jest-jasmine2',`\r\n- npm run test\r\n- no failure\r\n\r\n\r\nThis is the place I want to add my callback to.\r\n> https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-circus\/src\/state.ts#L14\r\n\r\n## Expected behavior\r\n\r\n`addEventHandler` register a callback properly and the callback is triggered on events.\r\n\r\nFor example, when I change the source code in `node_modules` to:\r\n\r\n```ts\r\nconst eventHandlers = window.eventHandlers || [_eventHandler.default, _formatNodeAssertErrors.default];\r\nwindow.eventHandlers = eventHandlers;\r\n```\r\n\r\nit works correctly.\r\n\r\n### Proposed PR with a fix\r\n\r\nThe PR is here https:\/\/github.com\/facebook\/jest\/pull\/11529\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: macOS 11.4\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz\r\n  Binaries:\r\n    Node: 12.22.1 - \/opt\/local\/bin\/node\r\n    Yarn: 1.22.10 - \/opt\/local\/bin\/yarn\r\n    npm: 6.14.13 - \/opt\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: 27.0.3 => 27.0.3\r\n```\r\n","comments":["Bump!","Hi there, I'll prepare a min demo today \/ next days.","Added a min repo with steps. ","I've created a PR with a fix.","Great work @satanTime","Hi @SimenB,\r\n\r\nI hope this finds you well.\r\n\r\nThere are 9 upvotes already, could you take a look at the issue and its fix when you have time?\r\n\r\nThank you in advance!","Hi @SimenB, could you take a look at the issue and the related PR?\n\nThank you in advance!","Hi @SimenB, \r\n\r\nthere are 40 upvotes and a proposed fix.\r\nMight you take a look when you have time or forward me to a person who could take care about code review?\r\n\r\nThank you in advance.","Hi @SimenB,\r\n\r\nI hope this finds you well.\r\n\r\nHowever, it is a pity to see how you treat your community.\r\nThere are 60 upvotes within less than 2 months.\r\nThe issue is one of the most upvoted...\r\n\r\n...and zero feedback from your side.\r\n\r\nHow should open source encourage devs to participate in it, when an easy fix stumbles over \u0430 disregard from the repo maintainers?","To be fair - the reason it's one of the most upvoted is probably because people are being prompted by `ng-mocks` to go and do so. So the upvote count doesn't necessarily reflect the real impact of this issue on the community as a whole, or how urgent it is to fix compared to other things.\r\n\r\nI understand that it's frustrating to put time and effort into proposing a fix without getting response in a timely manner.  But I feel the tone in your last comment is unnecessarily sharp\/negative. Warranted or not, I don't think it will help at all. \r\n\r\nSimen (and I'm sure others) are doing a tremendous effort to bring us awesome tooling here, and I bet there are a lot of different things demanding their attention every single day. We should try to remain respectful to each other and not add to the burden they are already carrying.\r\n\r\nIt's also worth keeping in mind that many have had a demanding year and a half with the pandemic. And that it's currently vacation time in much of Europe. So expect extra delays.\r\n\r\nMeanwhile... perhaps there are some qualified individuals amongst those 60 who could take the time to review the PR and not just upvote? It might help move it along when someone with access to merge have time to look at it. \r\n\r\n\u270c\ufe0f @ \u2764\ufe0f ","Hi @sigveio, you are welcome to review the PR.","I can only speak for myself, but I stumbled upon this PR when searching for a way to add test event handlers, and it looked much like how I would have done it. For a reasonably sized package, I would have just forked it privately, exposed the functionality and never bothered to search in the first place, and ultimately would never know people taking voting advice from NPM packages was a thing, so maybe it was all for the best;).","Hey @SimenB, the issue is still here, likewise its fix.\r\nPlease take a look when you have time, it's all only about improving `jest` for developers.","Any chance the PR can be approved? Not sure to understand what is the blocking point since last summer?","The main point is that maintainers don't understand the fix and don't have time to understand it.\n\nAlthough, I thought, it is an easy one. ","For anyone interested here a workaround using [patch-package](https:\/\/www.npmjs.com\/package\/patch-package) and `jest-circus@28.1.3`:\r\n\r\nAdd file `patches\/jest-circus+28.1.3.patch` to your workspace:\r\n\r\n```\r\ndiff --git a\/node_modules\/jest-circus\/build\/index.d.ts b\/node_modules\/jest-circus\/build\/index.d.ts\r\nindex adab032..a1ed485 100644\r\n--- a\/node_modules\/jest-circus\/build\/index.d.ts\r\n+++ b\/node_modules\/jest-circus\/build\/index.d.ts\r\n@@ -113,6 +113,10 @@ export declare const setState: (state: Circus.State) => Circus.State;\r\n \r\n export declare type State = Circus.State;\r\n \r\n+export declare const addEventHandler: (handler: Circus.EventHandler) => void;\r\n+\r\n+export declare const removeEventHandler: (handler: Circus.EventHandler) => void;\r\n+\r\n declare const test_2: Global.It;\r\n export {test_2 as test};\r\n \r\ndiff --git a\/node_modules\/jest-circus\/build\/index.js b\/node_modules\/jest-circus\/build\/index.js\r\nindex 1c848bf..7e9c6d4 100644\r\n--- a\/node_modules\/jest-circus\/build\/index.js\r\n+++ b\/node_modules\/jest-circus\/build\/index.js\r\n@@ -35,6 +35,18 @@ Object.defineProperty(exports, 'setState', {\r\n     return _state.setState;\r\n   }\r\n });\r\n+Object.defineProperty(exports, 'addEventHandler', {\r\n+  enumerable: true,\r\n+  get: function () {\r\n+    return _state.addEventHandler;\r\n+  }\r\n+});\r\n+Object.defineProperty(exports, 'removeEventHandler', {\r\n+  enumerable: true,\r\n+  get: function () {\r\n+    return _state.removeEventHandler;\r\n+  }\r\n+});\r\n exports.test = void 0;\r\n \r\n var _jestEach = require('jest-each');\r\ndiff --git a\/node_modules\/jest-circus\/build\/state.js b\/node_modules\/jest-circus\/build\/state.js\r\nindex 528b774..f194111 100644\r\n--- a\/node_modules\/jest-circus\/build\/state.js\r\n+++ b\/node_modules\/jest-circus\/build\/state.js\r\n@@ -32,7 +32,7 @@ function _interopRequireDefault(obj) {\r\n  * This source code is licensed under the MIT license found in the\r\n  * LICENSE file in the root directory of this source tree.\r\n  *\/\r\n-const eventHandlers = [_eventHandler.default, _formatNodeAssertErrors.default];\r\n+global[_types.EVENT_HANDLERS] = global[_types.EVENT_HANDLERS] || [_eventHandler.default, _formatNodeAssertErrors.default];\r\n const ROOT_DESCRIBE_BLOCK_NAME = 'ROOT_DESCRIBE_BLOCK';\r\n exports.ROOT_DESCRIBE_BLOCK_NAME = ROOT_DESCRIBE_BLOCK_NAME;\r\n \r\n@@ -74,7 +74,7 @@ const setState = state => (global[_types.STATE_SYM] = state);\r\n exports.setState = setState;\r\n \r\n const dispatch = async event => {\r\n-  for (const handler of eventHandlers) {\r\n+  for (const handler of global[_types.EVENT_HANDLERS]) {\r\n     await handler(event, getState());\r\n   }\r\n };\r\n@@ -82,7 +82,7 @@ const dispatch = async event => {\r\n exports.dispatch = dispatch;\r\n \r\n const dispatchSync = event => {\r\n-  for (const handler of eventHandlers) {\r\n+  for (const handler of global[_types.EVENT_HANDLERS]) {\r\n     handler(event, getState());\r\n   }\r\n };\r\n@@ -90,7 +90,14 @@ const dispatchSync = event => {\r\n exports.dispatchSync = dispatchSync;\r\n \r\n const addEventHandler = handler => {\r\n-  eventHandlers.push(handler);\r\n+  global[_types.EVENT_HANDLERS].push(handler);\r\n };\r\n \r\n exports.addEventHandler = addEventHandler;\r\n+\r\n+const removeEventHandler = handler => {\r\n+  const i = global[_types.EVENT_HANDLERS].indexOf(handler);\r\n+  global[_types.EVENT_HANDLERS].splice(i, 1);\r\n+};\r\n+\r\n+exports.removeEventHandler = removeEventHandler;\r\ndiff --git a\/node_modules\/jest-circus\/build\/types.js b\/node_modules\/jest-circus\/build\/types.js\r\nindex 70116de..5f552fb 100644\r\n--- a\/node_modules\/jest-circus\/build\/types.js\r\n+++ b\/node_modules\/jest-circus\/build\/types.js\r\n@@ -25,3 +25,6 @@ const TEST_TIMEOUT_SYMBOL = Symbol.for('TEST_TIMEOUT_SYMBOL');\r\n exports.TEST_TIMEOUT_SYMBOL = TEST_TIMEOUT_SYMBOL;\r\n const LOG_ERRORS_BEFORE_RETRY = Symbol.for('LOG_ERRORS_BEFORE_RETRY');\r\n exports.LOG_ERRORS_BEFORE_RETRY = LOG_ERRORS_BEFORE_RETRY;\r\n+\r\n+const EVENT_HANDLERS = Symbol.for('EVENT_HANDLERS');\r\n+exports.EVENT_HANDLERS = EVENT_HANDLERS;\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","We're still having to patch jest circus like @mircoba suggested: https:\/\/github.com\/jestjs\/jest\/issues\/11483#issuecomment-1109359940"],"labels":["Needs Triage","Bug Report"]},{"title":"Open Knex database causes open handles issues in Jest 27","body":"## \ud83d\udc1b Bug Report\r\n\r\nIf a test creates an in-memory SQLite3 Knex database and doesn't destroy it, then Jest 27 hangs with the following error:\r\n\r\n> Jest did not exit one second after the test run has completed.\r\n>\r\n> This usually means that there are asynchronous operations that weren't stopped in your tests. Consider running Jest with `--detectOpenHandles` to troubleshoot this issue.\r\n\r\nIf I run with `--detectOpenHandles`, then Jest doesn't print any messages, but it still hangs once the tests have finished.\r\n\r\n(This is the same issue as #9473, but it occurs in Jest 27.)\r\n\r\nThis issue _only_ happens in Jest 27. In Jest 26 and jest-circus 26, Jest cleanly exits with no warnings.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior: Clone the https:\/\/github.com\/joshkel\/jest-knex-open-handles repository and run `npm i && npm test`\r\n\r\nDowngrade to Jest 26 and note that it cleanly exits: `npm i jest@^26 jest-circus@^26 && npm test`\r\n\r\n## Expected behavior\r\n\r\nJest cleanly exits; or, if Jest doesn't cleanly exit because of the open database, then `--detectOpenHandles` should explain the problem.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/joshkel\/jest-knex-open-handles\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: macOS 11.4\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-4980HQ CPU @ 2.80GHz\r\n  Binaries:\r\n    Node: 12.18.3 - ~\/.nvm\/versions\/node\/v12.18.3\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.8 - ~\/.nvm\/versions\/node\/v12.18.3\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.1 => 27.0.1 \r\n```\r\n","comments":["Running [wtfnode](https:\/\/www.npmjs.com\/package\/wtfnode) shows that a timer from Knex's Tarn connection pool is what's keeping Jest from exiting:\r\n\r\n```\r\n[WTF Node?] open handles:\r\n- File descriptors: (note: stdio always exists)\r\n  - fd 1 (tty) (stdio)\r\n  - fd 2 (tty) (stdio)\r\n  - fd 0 (tty)\r\n- Intervals:\r\n  - (1000 ~ 1000 ms) (anonymous) @ \/Users\/joshkelley\/src\/jest-workspace\/jest-knex-open-handles\/node_modules\/tarn\/dist\/Pool.js:451\r\n```\r\n\r\nJest should probably [show non-user-created resources](https:\/\/github.com\/facebook\/jest\/blob\/00888027257e5a751ffb7002805248b1fc758681\/packages\/jest-core\/src\/collectHandles.ts#L80) to help troubleshoot issues like this; see [this comment](https:\/\/github.com\/facebook\/jest\/issues\/11464#issuecomment-850055381). (In other words, these two issues may be at least partial duplicates.)","Similar behaviour occurs when a `redis` connection is still open.\r\nUsing `jest@26.4.0` version with options `jest --findRelatedTests --runInBand --detectOpenHandles --forceExit` it forces `redis` to exit\/disconnect; after upgrading to `jest@27.x.x`, Jest complains about `redis` process potentially keeping it from exiting.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Has anyone found a great workaround for this? I found that I can call `knex.destroy()` in my \"last\" test to prevent this, but that's not a real elegant or maintainable solution since if Jest ends up running any *other* tests after the one I *assumed* would be last one to use `knex`, they end up failing kind of cryptically because their connection is unexpectedly broken.",">  I found that I can call knex.destroy() in my \"last\" test to prevent this, but that's not a real elegant\r\n\r\nHave you tried using [global teardown](https:\/\/jestjs.io\/docs\/configuration\/#globalteardown-string)?","> Have you tried using [global teardown](https:\/\/jestjs.io\/docs\/configuration\/#globalteardown-string)?\r\n\r\nThanks, I think that's a near-perfect fit! Unfortunately pointing `globalTeardown: '.\/jest.teardown.ts'` to a file like this:\r\n\r\n```\r\nimport { knex } from \".\/knex\/sharedConnection\";\r\n\r\nmodule.exports = async function () {\r\n  await knex.destroy();\r\n};\r\n```\r\n\r\ndoes **not** work in practice in our case because the \"sharedConnection\" module ends up not actually being fully shared for some reason! (i.e. the instance that gets `.destroy()` called on it here is not the same instance that the tests were using.) My assumption is that's on us and not a Jest-specific issue though.","If that is a shared `knex` instance it should do the job.\r\nWhy do you say it's not working? Is the exported function being triggered?"],"labels":["Needs Triage","Bug Report"]},{"title":"Jest 27: incorrect `afterEach` order with `jest-circus`","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udca5 Regression Report\r\n\r\n<!-- A clear and concise description of what the regression is. -->\r\n\r\nIn Jest 26, it was possible to set up `afterEach` callback in a `setupFilesAfterEnv` script which was correctly called after the tests specific `afterEach` callbacks. It makes sense to behave like this because it allows us to set up callbacks that are executed after any test was completed (including their specific `afterEach` callbacks).\r\n\r\nIt seems that Jest 27 calls the \"global\" `afterEach` _before_ the test-specific `afterEach` which breaks our codebase. It's because some of the tests are calling `jest.restoreAllMocks` in `afterEach` and later we are checking (in the global `afterEach`) whether all `console` mocks were actually restored or not.\r\n\r\nUse case: we are capturing unexpected console logs in a similar way like React, see:\r\n\r\n- https:\/\/github.com\/facebook\/react\/blob\/bb1c8215569f59b70276e8939bd8a59aa7f28f53\/scripts\/jest\/setupTests.js#L159-L160\r\n- our code: https:\/\/github.com\/adeira\/universe\/blob\/adc8bdf25d253b8bb883a040b6bf0d4bd1b66404\/scripts\/jest\/setupTests.js#L63-L92\r\n\r\nTest file:\r\n\r\n```js\r\nafterEach(() => {\r\n  jest.restoreAllMocks();\r\n});\r\n```\r\n\r\nSetup file:\r\n\r\n```js\r\nafterEach(() => {\r\n  \/\/ here we check whether `restoreAllMocks` (or any equivalent which restores console mocks) was called\r\n  \/\/ HOWEVER, if this global callback is called first then the test-specific mocks are not restored yet breaking the logic\r\n});\r\n```\r\n\r\n## Last working version\r\n\r\nWorked up to version: 26.6.3\r\n\r\nStopped working in version: 27.0.1\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n- setup `afterEach` callback in `setupFilesAfterEnv` script\r\n- setup `afterEach` callback in some test\r\n- check the order of execution of these callbacks (the test specific one should be run _before_ the one from `setupFilesAfterEnv`)\r\n\r\n## Expected behavior\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\nThe order of `afterEach` callbacks is not changed from version 26 so it's still possible to register custom global `afterEach` callback.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!-- Please provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\nhttps:\/\/replit.com\/@mrtnzlml\/jest-afterEach-bug (try to change the Jest versions in `package.json` and check the difference in the order)\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```\r\n  System:\r\n    OS: macOS 11.2.3\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz\r\n  Binaries:\r\n    Node: 16.2.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 7.14.0 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.0.1 => 27.0.1 \r\n```\r\n","comments":["I'm not sure what makes the most sense. @jeysal?","@SimenB In case this issue gets dismissed, is there any other way how to have a global `afterEach` callback so we can achieve the same thing?","Tbh I would say the previous behavior is rather unexpected (and I certainly didn't know it used to behave that way), because in any other case `afterEach`s would be executed in the order they are declared.\r\nThere is no drop in replacement that comes to my mind to get the previous behavior, only things that require more changes like calling something explicitly at the end of each test file, or monkey patching things. But I suppose the same is true with the *old* behavior if you wanted your `afterEach` to be run *before* the test `afterEach`s. So maybe this issue should be about giving users a way to control that easily. Or maybe there is already a good enough way? Not sure","We ran into this issue as well. In several cases we have `afterEach` calls in our test files that do some localized cleanup, then we have a global `afterEach` that does things like clearing out the DOM. Upgrading to Jest 27 breaks a lot of tests for us as our code assumes that they are run in order of locality. In other words, we expect global `beforeEach` and `afterEach` callbacks to be the first and last in the chain respectively.\r\n\r\nPutting the global `afterEach` before the local one causes confusing test behavior. Previously, it was a convenience that helped smooth the developer experience between tests. They could largely ignore it. Now it means developers have to be very aware of how it behaves whenever they're writing tests.","I'm not sure if this bug I just found is related to this, but I was always under the impression that beforeEach\/afterEach are always run in order of their declaration if within the same block.  In my code, we have 2 global afterEach, one to do an expect, and another to do a cleanUp.  Since the expect can throw, I didn't want to put it in the same block since I wanted the cleanup to run even if the expect fails:\r\n\r\n```\r\nafterEach(() => expect(nock).toBeDone());\r\nafterEach(() => nock.cleanAll());\r\n```\r\n\r\nHere I'm expecting the `expect` afterEach to be called first, then the `cleanAll` after that, but it's the inverse.  And because of this was giving false positives for our tests.  :exploding_head: \r\n","In that specific case, you can probably do\r\n\r\n```js\r\nafterEach(() => {\r\n  try {\r\n    expect(nock).toBeDone();\r\n  } finally {\r\n    nock.cleanAll();\r\n  }\r\n});\r\n```","I understand that, but that doesn't \"fix\" the original issue which is against what the documentation mentions around order of execution.","Where in the docs is this specified?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","do not close, please","Still experiencing this issue with `jest-circus`... For now we have unblocked ourselves from upgrading past Jest 26 by using explicitly specifying `jest-jasmine2` as our test runner. ","Hi @jeysal ,\r\n\r\nI would still vote for fixing a bug instead of documenting it.\r\n\r\nThere are many testing libraries around, which use hooks under the hood, and the expectation is that the order of their execution will be respected, as it is in all other testing frameworks. Not sure why `jest` decided to invent own way and to cause issues.\r\n\r\nLet's take a look at a simple example: we want to backup a global variable for a test, and restore it afterwards.\r\nTo avoid copy-pasting of tons of lines of code, we decided to write a helper function:\r\n\r\n```ts\r\nconst backupTest = (newValue: typeof globalVar): void => {\r\n  let backup: typeof globalVar;\r\n\r\n  beforeEach(() => {\r\n    backup = globalVar;\r\n    globalVar = newValue;\r\n  });\r\n\r\n  afterEach(() => {\r\n    globalVar = backup;\r\n  });\r\n};\r\n```\r\n\r\nThe idea is simple, our test should look like that:\r\n\r\n```ts\r\ndescribe('globalVar', () => {\r\n  backupTest(1);\r\n\r\n  it('equals 1', () => {\r\n    expect(globalVar).toEqual(1);\r\n  });\r\n});\r\n```\r\n\r\nso instead of having 10 lines of code how to backup `globalVar` for each test, we have just 1.\r\n\r\nNow, let's imagine that `globalVar` isn't primitive, but a complex object and `backupTest` does only 1 modification, whereas we need an additional modification, for example, another group of stub members.\r\n\r\nIn all testing libraries it will look like that:\r\n\r\n```ts\r\ndescribe('globalVar', () => {\r\n  backupTest(1); \/\/ one group of stub members.\r\n  backupTest(2); \/\/ another group of stub members.\r\n\r\n  \/\/ tests\r\n});\r\n```\r\n\r\nand it works well, after the test, `globalVar` will have its initial value before the suite, because the first executed `afterEach` belongs to `2` and the second executed `afterEach` belongs to `1`.\r\n\r\nHowever, with the new changes in `jest`, `globalVar` is going to be `1`, because of the broken order, because first `jest`  executes `afterEach` for `1`, and then `afterEach` for `2`, which restores a wrong value.\r\n\r\n```ts\r\nlet globalVar = 0;\r\n\r\nconst backupTest = (newValue: typeof globalVar): void => {\r\n  let backup: typeof globalVar;\r\n\r\n  beforeEach(() => {\r\n    backup = globalVar;\r\n    globalVar = newValue;\r\n  });\r\n\r\n  afterEach(() => {\r\n    globalVar = backup;\r\n  });\r\n};\r\n\r\ndescribe('backup', () => {\r\n  it('equals 0 before all', () => {\r\n    expect(globalVar).toEqual(0);\r\n  });\r\n\r\n  describe('globalVar', () => {\r\n    backupTest(1); \/\/ setting globalVar to 1 and restoring it to 0 afterwards\r\n    backupTest(2); \/\/ setting globalVar to 2 and restoring it to 1 afterwards\r\n\r\n    it('equals 2 before each', () => {\r\n      expect(globalVar).toEqual(2);\r\n    });\r\n\r\n    describe('each', () => {\r\n      backupTest(3); \/\/ setting globalVar to 3 and restoring it to 2 afterwards\r\n      backupTest(4); \/\/ setting globalVar to 4 and restoring it to 3 afterwards\r\n\r\n      it('equals 4 after each', () => {\r\n        expect(globalVar).toEqual(4);\r\n      });\r\n    });\r\n\r\n    it('resets to 2 after each', () => {\r\n      expect(globalVar).toEqual(2);\r\n    });\r\n  });\r\n\r\n  it('resets to 0 after all', () => {\r\n    expect(globalVar).toEqual(0);\r\n  });\r\n});\r\n```\r\n\r\nwhich fails on `jest` as\r\n\r\n```\r\n    expect(received).toEqual(expected) \/\/ deep equality\r\n\r\n    Expected: 0\r\n    Received: 1\r\n\r\n      42 |\r\n      43 |   it('resets to 0 after all', () => {\r\n    > 44 |     expect(globalVar).toEqual(0);\r\n         |                       ^\r\n      45 |   });\r\n      46 | });\r\n      47 |\r\n```\r\n\r\nproposed fix long time ago: https:\/\/github.com\/jestjs\/jest\/pull\/12861","I was recently affected by this unexpected behavior too.\r\n\r\nIn my case, it was caused by different testing utilities using beforeEach\/afterEach to patch `console.error`:\r\n\r\n- https:\/\/github.com\/ValentinH\/jest-fail-on-console ([code](https:\/\/github.com\/ValentinH\/jest-fail-on-console\/blob\/72fc01b942027f01fb1f405bfd1f119c896bf371\/index.js#L102-L115)) cc @ValentinH\r\n- https:\/\/github.com\/testing-library\/react-hooks-testing-library ([code](https:\/\/github.com\/testing-library\/react-hooks-testing-library\/blob\/121344370b2285dc3d5166a16ead71186bfe85d8\/src\/core\/console.ts#L41-L45)) cc @mpeyper\r\n- Own code used to hide React's \"Can't perform a React state update on an unmounted component\" warning, which looked more or less like this:\r\n\r\n  ```ts\r\n  let originalConsoleError: typeof console.error\r\n\r\n  beforeEach(() => {\r\n    originalConsoleError = console.error\r\n    console.error = (...args) => {\r\n      const reactUpdateOnUnmountedWarning = `Can't perform a React state update on an unmounted component`\r\n      if (String(args[0]).includes(reactUpdateOnUnmountedWarning)) return\r\n      originalConsoleError.call(console, ...args)\r\n    }\r\n  })\r\n\r\n  afterEach(() => {\r\n    console.error = originalConsoleError\r\n  })\r\n  ```\r\n\r\nI wonder what's the recommended approach to address scenarios like this.\r\n\r\nThe best approach I could come up with is to not unpatch console.error at all (not tested):\r\n\r\n```ts\r\nlet shouldHideReactUpdateOnUnmountedWarning = false\r\n\r\nbeforeAll(() => {\r\n  const originalConsoleError: typeof console.error\r\n  console.error = (...args) => {\r\n    const reactUpdateOnUnmountedWarning = `Can't perform a React state update on an unmounted component`\r\n    if (\r\n      shouldHideReactUpdateOnUnmountedWarning &&\r\n      String(args[0]).includes(reactUpdateOnUnmountedWarning)\r\n    ) {\r\n      return\r\n    }\r\n    originalConsoleError.call(console, ...args)\r\n  }\r\n})\r\n\r\nbeforeEach(() => {\r\n  shouldHideReactUpdateOnUnmountedWarning = true\r\n})\r\n\r\nafterEach(() => {\r\n  shouldHideReactUpdateOnUnmountedWarning = false\r\n})\r\n```"],"labels":[":boom: Regression"]},{"title":"Add failing test for `request for ... is not yet fulfilled`","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nThis is a test for https:\/\/github.com\/facebook\/jest\/issues\/11434\r\n\r\n","comments":["Perfect, thanks @nicolo-ribaudo! I'll try to find the time soonish to dig into this","@nicolo-ribaudo You\u00a0apparently\u00a0need to\u00a0update test\u00a0snapshots for\u00a0`e2e\/__tests__\/nativeEsm.test.ts`:\r\n<details>\r\n<summary><code>e2e\/__tests__\/nativeEsm.test.ts<\/code> and\u00a0snapshots<\/summary>\r\n\r\n<https:\/\/github.com\/facebook\/jest\/blob\/e1fa70b85544f72654082fc02d77683ef65b277a\/e2e\/__tests__\/__snapshots__\/nativeEsm.test.ts.snap#L11-L17><https:\/\/github.com\/facebook\/jest\/blob\/e1fa70b85544f72654082fc02d77683ef65b277a\/e2e\/__tests__\/nativeEsm.test.ts#L23-L36>\r\n<\/details>","The test will fail regardless (or rather, the snapshot will then encode a failing test as correct, which it's not \ud83d\ude42 )","FWIW, I believe the underlying issue here is one of the ones tracked in https:\/\/github.com\/nodejs\/node\/issues\/37648 (specifically the shared cache thing), so I'm waiting for that to be resolved upstream before spending more time on it in Jest","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | a6156c1b0e946efac46f1a4337b6eb33964e8521 |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/6502b7fcabb2e80008bdd60c |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-11437--jestjs.netlify.app](https:\/\/deploy-preview-11437--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTExNDM3LS1qZXN0anMubmV0bGlmeS5hcHAifQ.qzA9s8VYEuo0byIBEvsKAiGOE_HRZIF3kD6j8u6D2RM)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._"],"labels":["cla signed","Pinned"]},{"title":"[ESM] Jest crashes with `request for ... is not yet fulfilled` linking error","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nWhen two modules dynamically imported in parallel depend on the same file*, Jest crashes with a `request for ... is not yet fulfilled` error. The error is thrown by https:\/\/github.com\/nodejs\/node\/blob\/e46c680bf2b211bbd52cf959ca17ee98c7f657f5\/src\/module_wrap.cc#L535, so it's possible that this is a Node.js bug and not a Jest bug.\r\n\r\nIn my repository example below, I import two files in parallel (if I import them serially the test passes):\r\nhttps:\/\/github.com\/nicolo-ribaudo\/babel\/blob\/31dac517b7ce0d504bda794075f0a88029cedd58\/packages\/babel-plugin-proposal-private-methods\/test\/repro.js#L6-L7\r\n\r\nThose two files both depend on `packages\/babel-helper-create-class-features-plugin\/lib\/index.js`. `packages\/babel-helper-create-class-features-plugin\/lib\/index.js` depends on `packages\/babel-helper-create-class-features-plugin\/lib\/fields.js`, and the error I get is about that file:\r\n```\r\nrequest for '.\/fields.js' is not yet fulfilled\r\n```\r\n\r\n## To Reproduce\r\n\r\nRepository link: https:\/\/github.com\/nicolo-ribaudo\/babel\/tree\/jest-esm-request-not-yet-fulfilled-error\r\n\r\nSteps to reproduce:\r\n```\r\nmake bootstrap\r\nnode --experimental-vm-modules .\/node_modules\/.bin\/jest babel-plugin-proposal-private-methods\/test\/repro\r\n```\r\n\r\n## Expected behavior\r\n\r\nIt shouldn't crash\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.8 Ubuntu 20.10 (Groovy Gorilla)\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz\r\n  Binaries:\r\n    Node: 14.17.0 - \/usr\/local\/bin\/node\r\n    Yarn: 2.4.1 - \/usr\/bin\/yarn\r\n    npm: 7.9.0 - ~\/.npm-global\/bin\/npm\r\n  npmPackages:\r\n    jest: 27.0.0-next.11 => 27.0.0-next.11 \r\n```\r\n\r\nIt also fails with Node.js 16.2.0","comments":["I know nothing about this other than what the GH search surfaced, but:\r\n- I think this error is `linking error, dependency promises must be resolved on instantiate`, just with a new error message\r\n- From the last messages in https:\/\/github.com\/nodejs\/node\/issues\/37426, maybe the problem is that the two imports try to `link()`\/`evaluate()` the same file at the same time? ","Interesting find! The error is thrown when `await` the promise returned by `module.link` here: https:\/\/github.com\/facebook\/jest\/blob\/22267424a824310779bad3cafaae59485ce2a6c7\/packages\/jest-runtime\/src\/index.ts#L530. `module.status` at this point is `unlinked`, but the module which node says is \"not yet fulfilled\" is `linking`. I would have thought node just waited for modules in status `linking` to complete when it's returned from `module.link` callback, but maybe not?\r\n\r\nI've tried for about an hour to understand why it goes boom without luck... Might need to ask in the node repo. I think we currently _do_ only call `link` and `evaluate` on entry points and on dynamic imports, but I might be wrong \ud83d\ude1b \r\n\r\nDo you think you would be able to create a reproduction outside of the babel repo? I tried to add a failing test to this repo without success.\r\n\r\nIn https:\/\/github.com\/facebook\/jest\/blob\/22267424a824310779bad3cafaae59485ce2a6c7\/e2e\/native-esm\/__tests__\/native-esm.test.js\r\n\r\n```js\r\ntest('import same file in parallel indirectly', async () => {\r\n  await Promise.all([import('..\/file1.js'), import('..\/file2.js')]);\r\n});\r\n```\r\n\r\nand then both `file1.js` and `file2.js` being\r\n\r\n```js\r\nimport func from '.\/sharedImport.js';\r\n\r\nfunc();\r\n```\r\n\r\nand `sharedImport.js`\r\n\r\n```js\r\nexport default function func() {\r\n  console.log('woop');\r\n}\r\n```\r\n\r\nThis passes instead of failing with the same error, though.","Sure, I can try \ud83d\udc4d","https:\/\/github.com\/nicolo-ribaudo\/jest-bug-not-yet-fulfilled\r\n\r\n~~However, I don't see the error if I add a test similar to my repository to https:\/\/github.com\/facebook\/jest\/blob\/22267424a824310779bad3cafaae59485ce2a6c7\/e2e\/native-esm\/__tests__\/native-esm.test.js :thinking:~~ **EDIT:** https:\/\/github.com\/facebook\/jest\/pull\/11437","Node throws if the promise isn't already resolved: https:\/\/github.com\/nodejs\/node\/blob\/e46c680bf2b211bbd52cf959ca17ee98c7f657f5\/src\/module_wrap.cc#L534\r\n\r\nHowever, it seems in contrast with the idea behind promises: the \"settled\" status shouldn't be observed, a promise already resolved to `x` should behave exactly like a promise that will resolve to `x`.","same issue here, but I can't tell the detail. It's to complicated lol\r\nI use polka (like express) and map the routes with middleware. I use Promise.all to map the routes and middleware. Some middleware import multer (and I mock it). This middleware is attached twice to the routes. I found that the first route is fine, but the second one is failed to run, and throw this error message\r\n`FATAL request for 'multer' is not yet fulfilled`\r\n`{\"code\":\"ERR_VM_MODULE_LINK_FAILURE\"}`\r\nSomething like multer module cannot load for the second time\r\n\r\nIt's only happen when I test my app with jest. In production is fine\r\n\r\nthis is the copy of my code\r\n```js\r\nconst runServices = async (routes, routeMiddleware) => {\r\n    await Promise.all([\"post\", \"get\", \"patch\", \"put\", \"delete\"].map(async (method) => {\r\n        await Promise.all((routes[method] || []).map(async (r) => {\r\n            let service;\r\n            let localMiddleware = [];\r\n            try {\r\n                const instance = await import(servicePath + r.service);\r\n                service = instance.default || instance;\r\n                (service.middleware || []).forEach((m, i) => {\r\n                    let mInstance = m.default || m; \/\/multer imported here\r\n                    localMiddleware[i] = async (req, res, next) => {\r\n                        try {\r\n                            await mInstance(req, res, next);\r\n                        }\r\n                        catch (err) {\r\n                            handleError(req, res, err);\r\n                        }\r\n                    };\r\n                });\r\n                router[method](routes.prefix + r.path, ...routeMiddleware, ...localMiddleware, async (req, res) => {\r\n                    try {\r\n                        await serviceExec(req, res, service);\r\n                    }\r\n                    catch (err) {\r\n                        handleError(req, res, err);\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                Log.fatal(err);\r\n            }\r\n        }));\r\n    }));\r\n};\r\n```\r\n System:\r\n    OS: Linux 5.11 elementary OS 6 Odin\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-5300U CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 16.6.2 - ~\/.nvm\/versions\/node\/v16.6.2\/bin\/node\r\n    Yarn: 1.22.11 - ~\/.nvm\/versions\/node\/v16.6.2\/bin\/yarn\r\n    npm: 7.20.3 - ~\/.nvm\/versions\/node\/v16.6.2\/bin\/npm\r\n  npmPackages:\r\n    jest: ^27.1.0 => 27.1.0 ","Hi I have same issue with oas-tools getting  'request for .\/middleware\/index.js is not yet fulfilled' oas-tools\/oas-tools#342\r\nAny updates on this one?","Same here. Having problems when using @oas-tools\/core.","Again, this is a node (or rather, v8) bug linked above. Until that's fixed, no need to add any \"+1\"s to this issue","Is it possible to know when this issue is schedule to be resolved? or maybe a workaround? \r\n","You can track any of the issues linked in https:\/\/github.com\/nodejs\/node\/issues\/37648","I'm still hitting this issue.  This has not yet been resolved?\r\n\r\nIn my situation I have code like the following:\r\n\r\n```\r\nasync function proxyData(table: string, mock: boolean = false): Promise<PersistenceGateway | object> {\r\n  let database: PersistenceGateway;\r\n  if (config.db_mock) {\r\n    return await import(`.\/gateways\/${table}.local.inmemory.gateway`);\r\n  } else {\r\n    return await import(`.\/gateways\/${table}.mysql.gateway`);\r\n  }\r\n}\r\n```\r\n\r\nIt's failing in either the if or the else on the import.  That dynamic import opens up a module who's first line is the following:\r\n\r\n```\r\nimport log from '..\/logging.service';\r\n```\r\n\r\nAnd the error I'm getting is:\r\n```\r\nrequest for '..\/logging.service' is not yet fulfilled\r\n```"],"labels":[":bug: Bug","ES Modules","Pinned"]},{"title":"Babel unexpectedly transpiling\/converting node_modules","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\nJest appears to configure Babel in such a way that it is transpiling\/converting existing modules in the node_modules folder. This can be seen when Babel outputs the following warning, for example:\r\n```\r\n[BABEL] Note: The code generator has deoptimised the styling of \/REPOSITORY_ROOT\/node_modules\/@google-cloud\/logging\/build\/protos\/protos.js as it exceeds the max of 500KB.\r\n```\r\n\r\nThis corresponds to close to 1GB of memory usage when running the tests, even when using Node's \"--expose-gc\" and Jest's \"--runInBand\" and \"--logHeapUsage\". This, in turn, causes the CI server to run out of memory as there are multiple modules being tested and compiled concurrently.\r\n\r\nWe do have a mono-repository setup through Lerna and it is possible that the symlinking is responsible for this behavior. However, Babel's default options should exclude all files in all node_modules folders. We are not using a bundler or Babel - we use the Typescript compiler.\r\n\r\n## To Reproduce\r\nSteps to reproduce the behavior:\r\n\r\n1. Create\/use a mono-repository using Lerna\r\n2. Jest configured to collect code coverage\r\n3. Add the @google-cloud\/logging NPM module to your module, update your code that is covered to include the module, and then run Jest with coverage enabled.\r\n4. Run Jest against the build output or Typescript source - we run again the JS output during CI, as the Typescript compilation by Babel doubles the memory usage in some cases, and we run against the source\/TS during local development \r\n\r\n## Expected behavior\r\nWe do not believe that Jest should configure Babel to transpile or modify node_modules for code-coverage.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n## envinfo\r\n```\r\n14:22 $ npx envinfo --preset jest\r\nnpx: installed 1 in 1.015s\r\n\r\n  System:\r\n    OS: Linux 5.8 Ubuntu 20.04.2 LTS (Focal Fossa)\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-10310U CPU @ 1.70GHz\r\n  Binaries:\r\n    Node: 14.16.1 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/node\r\n    npm: 6.14.12 - ~\/.nvm\/versions\/node\/v14.16.1\/bin\/npm\r\n```\r\n","comments":["Do you use babel-jest in your project?  ","We do not use Babel directly at all. This is Jest using Babel to add\ncoverage statements to the JS files.\n\nOn Sat, May 22, 2021, 10:06 Ahn ***@***.***> wrote:\n\n> Do you use babel-jest in your project?\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/11431#issuecomment-846413212>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/ABT6LNUDEWMOTURN4AROGMTTO627FANCNFSM45HTCJBA>\n> .\n>\n","I am using `babel-jest` in my Lerna based monorepo setup. And seeing this warning when running test with `--coverage` flag.\r\n\r\nIn my setup, I am receiving the warnings for 2 files.\r\n\r\n* `\/path\/to\/project\/node_modules\/react-dom\/cjs\/react-dom.development.js`\r\n* `\/path\/to\/project\/node_modules\/react-test-renderer\/cjs\/react-test-renderer.development.js`\r\n\r\nwarning that is logged from `@babel\/generator`'s [lib\/index.js](https:\/\/github.com\/babel\/babel\/blob\/079f8cd5bc44db20db9c62c3a280c24feaf2f0ba\/packages\/babel-generator\/src\/index.ts#L90)\r\n\r\n```\r\n[BABEL] Note: The code generator has deoptimised the styling of \/path\/to\/project\/node_modules\/react-dom\/cjs\/react-dom.development.js as it exceeds the max of 500KB.\r\n```\r\n\r\nI tried the following configuration options in root `babel.config.js`, but none of them seem to seemed to have an effect on the warning.\r\n\r\n```javascript\r\n\/\/ configuring `compact: false` at top most level\r\n{\r\n  compact: false\r\n}\r\n\r\n\/\/ configuring `compact: false` through `generatorOpts` - https:\/\/babeljs.io\/docs\/en\/options#generatoropts\r\n{\r\n  generatorOpts: { compact: false }\r\n}\r\n\r\n\/\/ configuring through `overrides`\r\n{\r\n  overrides: [{\r\n    test: \"node_modules\/**\/*.js\"\r\n    compact: false\r\n  }]\r\n}\r\n```\r\n\r\nAt this point, I cannot say whether the issue lies with babel or jest. I logged `format` & `opts` along with the warning console log, like this\r\n\r\n```js\r\nif (format.compact === \"auto\") {\r\n  format.compact = code.length > 500000;\r\n\r\n  if (format.compact) {\r\n    console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + `${opts.filename} as it exceeds the max of ${\"500KB\"}.`, format, opts);\r\n  }\r\n}\r\n```\r\n\r\nAmusingly, `format.compact` was true & `opts.compact` was \"auto\". How? I cannot explain. \ud83e\udd14 \r\n\r\n---\r\n\r\nversions\r\n```\r\n@babel\/core@7.13.14\r\n@babel\/generator@7.13.9\r\nbabel-jest@26.6.3\r\njest@26.6.3\r\n```",">We do not use Babel directly at all. This is Jest using Babel to add\r\ncoverage statements to the JS files.\r\n\r\nShouldn't jest ignore transpiling all files in node_modules by default as per [`transformIgnorePatterns`](https:\/\/jestjs.io\/docs\/configuration#transformignorepatterns-arraystring)?","We have a custom `transformIgnorePatterns` as is common in a react native project. Can reproduce this consistently when running tests with the `--coverage` flag. Fix was to add `coveragePathIgnorePatterns: ['<rootDir>\/node_modules\/*']` to jest config.","> We have a custom `transformIgnorePatterns` as is common in a react native project. Can reproduce this consistently when running tests with the `--coverage` flag. Fix was to add `coveragePathIgnorePatterns: ['<rootDir>\/node_modules\/*']` to jest config.\r\n\r\nI am able to consistently replicate when running tests with the `--coverage` and `--no-cache` flags. Without the `--no-cache` flag I was not able to replicate locally and only saw the error produced on CI.\r\n\r\nUnfortunately, adding `coveragePathIgnorePatterns: ['<rootDir>\/node_modules\/']` or `coveragePathIgnorePatterns: ['<rootDir>\/node_modules\/*']` did not resolve the issue. `transformIgnorePatterns: ['\/node_modules\/']` is also set in configuration.\r\n\r\nPossibly the same issue as reported https:\/\/github.com\/jestjs\/jest\/issues\/13048"],"labels":["Needs Triage","Bug Report"]},{"title":"top level `transform` is not available in `projects`","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nAs title.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nhttps:\/\/github.com\/markuplint\/markuplint\/blob\/main\/package.json#L62\r\n\r\nmove the two `transform` options into top level\r\n\r\ntest cases will be unable to run any more.\r\n\r\n## Expected behavior\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\nNo error\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\nAs above.\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```log\r\n  System:\r\n    OS: macOS 11.3.1\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 12.22.1 - ~\/.nvm\/versions\/node\/v12.22.1\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.12 - ~\/.nvm\/versions\/node\/v12.22.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.6.3 => 26.6.3\r\n```\r\n","comments":["Seem like `projects` doesn\u2019t inherit from top level config, not sure if other config options have the same behavior too, probably yes.","probably Jest maintainers can tell if `projects` can inherit root config options.","> probably Jest maintainers can tell if `projects` can inherit root config options.\r\n\r\nUnfortunately it does not. I ended up duplicating everything twice for my unit and integration tests setup.\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/10991#issuecomment-1137699168\r\n\r\nThe only two options I could find working are\r\n- collectCoverage\r\n- coverageReporters","This is somewhat confusing to me, some baffling behavior:\r\n- Some properties like `collectCoverage`, `coverageReporters` (as mentioned by @igorpupkinable), and `verbose` need to be in the root config if they are to work when running jest from the root.\r\n- Properties like `preset` and `transform` do not seem to be used from the root config\r\n\r\nI am finding to have this make sense I need to share common config (leveraging an import and spread operator or maybe this: https:\/\/github.com\/facebook\/jest\/issues\/10991#issuecomment-1185427440) between the root jest config and the sub-projects, so that I can run jest from the root or the sub-projects and have the same behavior.  The main benefit I can see right now from using jest projects instead of something like npm workpaces and `npm run test --workspaces=true` is the combination of the coverage reporting.","Either this feature is not working as intended, or the documentation is incorrect.\r\n\r\nhttps:\/\/jestjs.io\/docs\/configuration#projects-arraystring--projectconfig\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/117312398\/215531868-5160a192-e485-4ca9-9dda-9f70ea6e95e3.png)\r\n\r\nWith a monorepo setup, I have a root `jest.config.js` which includes\r\n\r\n```js\r\n\/** @type {import('ts-jest').JestConfigWithTsJest} *\/\r\nmodule.exports = {\r\n  projects: ['<rootDir>\/packages\/**\/jest.config.js'],\r\n  preset: 'ts-jest',\r\n  testEnvironment: 'node',\r\n  testPathIgnorePatterns: ['\/node_modules\/', '<rootDir>\/dist\/'],\r\n};\r\n```\r\n\r\nEach package contains a `jest.config.js` with these contents.\r\n\r\n```js\r\n\/** @type {import('jest').Config} *\/\r\nmodule.exports = {\r\n  displayName: 'my-package',\r\n  preset: 'ts-jest',\r\n  testEnvironment: 'node'\r\n};\r\n```\r\n\r\nHowever, `testPathIgnorePatterns` is not being copied into the child context for each project, and files in `\/dist` are read by jest. If I add `testPathIgnorePatterns` to the child `jest.config.js`, then the files are properly ignored.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump"],"labels":["Needs Triage","Bug Report"]},{"title":"toMatchObject seems to ignore Map and Set","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nI've noticed that `.toMatchObject` ignores any Map and Set objects, silently accepting different things.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nAttempt to match an object against a Map or Set, for example:\r\n\r\n```js\r\nexpect({ hello: 'world' }).toMatchObject(new Set()); \/\/ Passes, should fail\r\nexpect({ hello: [] }).toMatchObject({ hello: new Map() }); \/\/ Passes, should fail\r\n```\r\n\r\n## Expected behavior\r\n\r\nThe test should fail, because Map and Set are always different from strings and arrays.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\nhttps:\/\/replit.com\/@fabiosantoscode\/jest-playground#matchobject.test.js\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.8 Ubuntu 20.04.2 LTS (Focal Fossa)\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz\r\n  Binaries:\r\n    Node: 15.4.0 - ~\/.nvm\/versions\/node\/v15.4.0\/bin\/node\r\n    Yarn: 1.22.10 - ~\/.nvm\/versions\/node\/v15.4.0\/bin\/yarn\r\n    npm: 7.6.3 - ~\/.nvm\/versions\/node\/v15.4.0\/bin\/npm\r\n  npmPackages:\r\n    jest: 26.2.2 => 26.2.2 \r\n\r\n```\r\n\r\n(and also in the REPL, which has this envinfo)\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.4 Debian GNU\/Linux 9 (stretch) 9 (stretch)\r\n    CPU: (4) x64 Intel(R) Xeon(R) CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 12.21.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.5 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.11 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.6.3 => 26.6.3 \r\n```\r\n","comments":["May be related to https:\/\/github.com\/facebook\/jest\/issues\/11112 -- RegExp objects also have the same effect as Map in this case.","Just got into this as well. The fact that it silently accepts the value and passes the test is error-prone.","Fixed the REPL to make it clearer. I started experimenting with regexes shortly after I posted this issue, but then I didn't revert my changes :) ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I've updated the reproduction REPL to use Jest 29.4.3, and can still reproduce this issue.","I've just ran into this issue when trying to use `expect.objectContains` with a value that is a `Map`.\r\n\r\nThis issue describes the problem: https:\/\/github.com\/jestjs\/jest\/issues\/13968, but is unfortunately already closed."],"labels":["Needs Triage","Bug Report"]},{"title":"fix(jsdom-env): remove Buffer","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nFollowing up on #11222. For some reason a JSDOM test takes about 12 seconds rather than less than 1 with this change. (slow enough that a test fails since it crosses the test length threshold, causing a snapshot diff)\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nGreen CI, eventually\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["This test should be deleted too I think?\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/167aad4565f6960968a8666d78234ed198fa0770\/e2e\/env-test\/__tests__\/equivalent.test.js#L15-L20","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241?src=pr&el=h1) Report\n> Merging [#11241](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241?src=pr&el=desc) (167aad4) into [master](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/167aad4565f6960968a8666d78234ed198fa0770?el=desc) (167aad4) will **not change** coverage.\n> The diff coverage is `n\/a`.\n\n> :exclamation: Current head 167aad4 differs from pull request most recent head 412360d. Consider uploading reports for the commit 412360d to get more accurate results\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241?src=pr&el=tree)\n\n```diff\n@@           Coverage Diff           @@\n##           master   #11241   +\/-   ##\n=======================================\n  Coverage   64.24%   64.24%           \n=======================================\n  Files         308      308           \n  Lines       13502    13502           \n  Branches     3289     3289           \n=======================================\n  Hits         8675     8675           \n  Misses       4117     4117           \n  Partials      710      710           \n```\n\n\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241?src=pr&el=footer). Last update [167aad4...412360d](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11241?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments).\n","Do we have a workaround for the issue with Reference error besides using `resolutions`? Now if I do `yarn add -D jest@27.0.0-next.5` I always get `next.6`","> Do we have a workaround for the issue with Reference error besides using `resolutions`? Now if I do `yarn add -D jest@27.0.0-next.5` I always get `next.6`\r\n\r\nWhat issue?","`referenceerror: buffer is not defined`, only occur after I upgraded to **next-6**","This PR doesn't remove `Buffer`, so not related.\r\n\r\nI'm guessing you env is old or custom (and using `installCommonGlobals` which does not add `Buffer` automatically anymore). Regardless, not related to this PR","Aw thanks, I found the issue. My angular tests depend on `ts-jest` which still uses `jest-util` **next.5** "],"labels":["cla signed"]},{"title":"Slow start times due to use of barrel files","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nIt is unclear that large dependency graphs caused by the use of barrel files can slow test initialization dramatically. There are some tangential mentions of this in the documentation, but it is not outlined in a clear and direct manner. This likely leads to a lot of inefficiency in many projects.\r\n\r\nHere are the most important points to stress:\r\n * Jest simulates Node's require cache to allow for isolation and mocking\r\n * The require cache is built independently for every test suite\r\n * All dependencies of a file are included, even if unused\r\n\r\nIt is the last bullet that leads to the largest reduction in efficiency, due mainly to barrel files. Barrel files are `index` files that re-export the exports of other files in a directory. They make it possible to import multiple related dependencies in a single `import` statement. The downside of this is that Jest sees all of the re-exported contents of the barrel file as dependencies and crawls through them, used or not.\r\n\r\nReducing the use of barrel files can help quite a bit in reducing the amount of time it takes before a test can start. This is especially true of dependencies pulled from NPM packages. Packages are typically developed with a root index file that acts as a barrel file for the entire package. If the package is rolled up into a single file at build time, there is only one file for the Jest runtime to open and parse. If the package publishes its source files independently, without a rollup stage, the Jest runtime will need to open and parse every file in the package independently.\r\n\r\nIn an enterprise setting, there are often internally developed tools and libraries. These packages can grow to be fairly large, and given their internal use, it can be tempting to provide the source files as the output of the packages. In fact, this can improve tree shaking when building the applications that depend on them. Jest, however, can suffer greatly in this environment because the raw number of files can grow without bounds. This problem becomes exponentially worse when overly tight internal dependency semvers reduce the ability of package managers to de-duplicate their installs.\r\n\r\nResolving these issues can lead to tremendous decreases in Jest's test suite initialization and this should be highlighted in the documentation. Barrel files can have a huge impact on the number of files that the Jest runtime needs to parse, and that is not clear without a deep dive into the way dependencies are evaluated. Sharing this knowledge more broadly could make an already fantastic test runner that much better and improve the quality of many products that rely upon it in the process.\r\n\r\n## To Reproduce\r\n\r\nAs this is a documentation issue and not a code issue, this may not apply. However, in the spirit of completeness:\r\n * Read the Jest documentation\r\n * Experience slow test start times in enterprise scale development\r\n * Be unaware of the impact that barrel files can have on running Jest\r\n\r\n## Expected behavior\r\n\r\nThe expectation is that the Jest documentation should more explicitly explain the impact that barrel files can have on test start times.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nGiven that this issue is manifested in large scale applications with many inter-related dependencies, it is not feasible to provide a replication of the issue.\r\n\r\n## envinfo\r\n\r\nN\/A\r\n","comments":["On our project we have ~100 test suites, ~600 tests. it take about 6 minutes to run all the tests.\r\nThe tests are very fast (less than 50ms. per test), but the startup time is very slow (And annoying)\r\n\r\nI've created a script that changes all the imports from barrel files to explicit import, and the tests run 10x faster (Still not optimal, but shows the problem)\r\n\r\nAnyone with a solution\/workaround\/idea?","I'm happy to take a PR outlining this issue. \ud83d\udc4d \r\n\r\n---\r\n\r\nIn Jest itself we've made lots of `import`s lazy to avoid this issue, but doing across the entire codebase requires the use of `babel` (or some other code transform). Might be an OK workaround in tests, but won't help in `node_modules` as it's not transformed by default (you can have Jest transform node_modules if you want, but at some point there are diminishing returns since you then have to wait for the file to be transformed).","@gilamran could you please share that script for changing the barrel files import? I'm in a similar bind where changing one reusable component is running 100s of tests. I've tried using babel transform plugin imports but it was not working for me.","@fadi-george sorry I don't have the script anymore (Maybe I can look it up in the git history), but I've found even faster solution.\r\nI'm using `esbuild` to bundle ALL my tests + code into one huge file, then I run jest on this file only. so instead of 350sec. with jest as it is, it's taking 30sec tops.\r\n\r\nI had to do some juggling to make esbuild and jest work together, like importing svgs etc.\r\nyou can see the script [here](https:\/\/github.com\/gilamran\/fast-jest-with-esbuild)","@gilamran ah interesting approach, thank you for sharing! I'll definitely play around with that idea.","@gilamran I assume you are doing something like this? Have you ran into any memory issues?\r\n\r\n```\r\nnode build-tests && jest .\/src\/bundle.spec.ts\r\n````\r\n\r\nbundle.spec.ts:\r\n```\r\nimport testBundle from '.\/tests\/bundle';\r\n\r\ntest('should pass', () => {\r\n  testBundle();\r\n});\r\n```","I believe I fixed my memory issues but now I ran into this problem with jest mocks and mockImplementations failing.","@gilamran did you use any jest.mock calls? For me, it forces my tests to fail\r\n\r\n```\r\nimport { someAction } from 'actions\/something';\r\njest.mock('actions\/something');\r\n```\r\n\r\nIt might be supported later on with esbuild or jest, I tried top-level-await but I couldn't get it to work\r\n\r\n```\r\njest.mock('actions\/something');\r\nconst { someAction } = await import('actions\/something');\r\n```\r\n\r\n","I don't use `jest.mock` at all (And I think that it's bad practice in most cases).\r\nI also don't think that it's possible to use when doing the esbuild bundle. The bundle already includes all the code, and I think that `jest.mock` is overriding the `import` which doesn't exist anymore... ","I have made a simple repo that reproduces this issue using a barrel file provided by a large third-party library, in this case Material UI icons: https:\/\/github.com\/rsslldnphy\/jest-barrel-files\r\n\r\nOn my machine, the test that imports icons as `import * as Icons from \"@mui\/icons-material\";` takes about 7 seconds to run, compared to fractions of a second for the test that doesn't.\r\n\r\nI do not have a good understanding of the mechanics of what goes on (with treeshaking etc) when importing files in this way, but I'm not encountering this slowness issue the other tools I'm using - is there a way to make jest aware of code that can be ignored?","@rsslldnphy for material specifically, which is a quite big library, I isolate the parts of the library my code actually uses in a re-exported barrel file:\r\n\r\n```ts\r\n\/\/ components\/index.ts\r\n\r\nexport { default as AppBar, type AppBarProps } from \"@mui\/material\/AppBar\";\r\nexport { default as Button, type ButtonProps } from \"@mui\/material\/Button\";\r\n\/\/ ...\r\n\r\nexport { default as DateRangeIcon } from \"@mui\/icons-material\/DateRange\";\r\nexport { default as CheckCircleIcon } from \"@mui\/icons-material\/CheckCircle\";\r\nexport { default as LocalShippingIcon } from \"@mui\/icons-material\/LocalShipping\";\r\n\/\/ ... keep in mind that even 50-100 icons is only a small part of the 2000+ icons material exports\r\n```\r\n\r\nTo be fair, we did this to mark to other developers in the team what parts of the material ui they could use without having to have a talk with our UI\/UX designer beforehand. But it also mitigates this issue as a side effect.","> On our project we have ~100 test suites, ~600 tests. it take about 6 minutes to run all the tests. The tests are very fast (less than 50ms. per test), but the startup time is very slow (And annoying)\r\n> \r\n> I've created a script that changes all the imports from barrel files to explicit import, and the tests run 10x faster (Still not optimal, but shows the problem)\r\n> \r\n> Anyone with a solution\/workaround\/idea?\r\n\r\nI've had this problem. Problem is barreling, and the way the import mapping works. \r\n\r\nUnfortunately, it seems that transpilers (TypeScript), bundlers (WebPack, SnowPack, Vite, Rollup) can't differentiate exactly which is the import you're trying to use, and it will pull *all* the other files that were specified in the barrel index file. I'm currently refactoring a somewhat big app because I was waiting for 3 minutes until I ran 3 tests, and it was because my entire app was barreled. ","> @rsslldnphy for material specifically, which is a quite big library, I isolate the parts of the library my code actually uses in a re-exported barrel file:\r\n> \r\n> ```ts\r\n> \/\/ components\/index.ts\r\n> \r\n> export { default as AppBar, type AppBarProps } from \"@mui\/material\/AppBar\";\r\n> export { default as Button, type ButtonProps } from \"@mui\/material\/Button\";\r\n> \/\/ ...\r\n> \r\n> export { default as DateRangeIcon } from \"@mui\/icons-material\/DateRange\";\r\n> export { default as CheckCircleIcon } from \"@mui\/icons-material\/CheckCircle\";\r\n> export { default as LocalShippingIcon } from \"@mui\/icons-material\/LocalShipping\";\r\n> \/\/ ... keep in mind that even 50-100 icons is only a small part of the 2000+ icons material exports\r\n> ```\r\n> \r\n> To be fair, we did this to mark to other developers in the team what parts of the material ui they could use without having to have a talk with our UI\/UX designer beforehand. But it also mitigates this issue as a side effect.\r\n\r\nNice idea on both counts @PupoSDC! May well implement this. Will be a bit of a faff to set up and maintain with icons especially but not a bad trade-off at all for mitigating this issue. Thanks!","Not sure if it will help, but here's my 2 cents:\r\n\r\nI face problems with barrel files not only in jest, but on some external and internal libs that have optional peer dependencies. Including these libs which do all exports from a barrel causes compile errors due to indirect import of unused components that use optional not installed dependencies\r\n\r\nTo fix this, I was using the already mentioned [babel-plugin-transform-imports](https:\/\/bitbucket.org\/amctheatres\/babel-transform-imports\/src\/master\/), which IMO works great (although I had to [fork](https:\/\/github.com\/Grohden\/babel-transform-imports-clone) it and fix import aliases issues)\r\n\r\nI even tried to improve the transform imports solution writing [babel-plugin-resolve-barrel-files](https:\/\/github.com\/Grohden\/babel-plugin-resolve-barrel-files), but its a simple solution for ESM modules only.\r\n\r\n\r\nBut I guess that for jest, people could try [implementing a lazy import with mocks](https:\/\/stackoverflow.com\/a\/66691909\/4777865):\r\n\r\n```js\r\njest.mock('module-with-barrel', () => {\r\n\r\n  const RequiredComponent = jest.requireActual('module-with-barrel\/RequiredComponent').default;\r\n  return {\r\n     __esModule: true,\r\n    RequiredComponent\r\n    \/\/ or use a more lazy approach...\r\n    \/\/  get RequiredComponent() {\r\n    \/\/     return jest.requireActual('module-with-barrel\/RequiredComponent').default;\r\n    \/\/ }\r\n   }\r\n})\r\n```\r\n\r\n----\r\n> Unfortunately, it seems that transpilers (TypeScript), bundlers (WebPack, SnowPack, Vite, Rollup) can't differentiate exactly which is the import you're trying to use\r\n\r\nThey probably can, but since barrel files are normal source code files, they can execute [side effects (read the tip)](https:\/\/webpack.js.org\/guides\/tree-shaking\/#mark-the-file-as-side-effect-free) (eg: some dep exporting global stuff).. so it's more safe to just don't optimize unless you explicit tell them to do it (the case for the babel plugins and webpack configs)","I confirm. Using barrel imports extreamly slows down starting test suites. Test cases run very fast. Please manage this problem.","Is there any solution for this? I have more than 3000 imports to change if i want to reverse the barrels import to full file path import, which would take very long time.","No solution, but there's a [workaround](https:\/\/github.com\/facebook\/jest\/issues\/11234#issuecomment-905319778)","Just a thought on this as recently i was facing a similar issue and the way i fixed it is by creating a custom barrel import transformer. The way it works is in first step we iterate all files to determine all the exports of files in project making a Map of import to lookup later.\r\n\r\nNow when the test start to execute, using jest transform configuration, then execute a transform which uses the import lookup map created in first step to rewrite the import statements to specific imports statements and then jest executes on the transformed code.\r\n\r\nWas able to significant improvement with this approach when using jest with ts-jest (isolatedModules enabled).","> \r\n\r\nHow did you manage it? Do you have any example somewhere? I am very interested as i can't manage to reduce the time execution of my spec files due to the size of the project and barrel imports everywhere.","@boubou158  added a typescript based sample here with some readme- https:\/\/github.com\/dsmalik\/ts-barrel-import-transformer","After spending a month trying to make esm working on our project trying to speed up the jest performance, it seems impossible to have 100% working. I am giving up on the esm option. I am now checking your solution (thanks a lot for that by the way !) but i am a little confused on how i could integrate this transformer with the transformer used by jest-preset-angular?","> @fadi-george sorry I don't have the script anymore (Maybe I can look it up in the git history), but I've found even faster solution. I'm using `esbuild` to bundle ALL my tests + code into one huge file, then I run jest on this file only. so instead of 350sec. with jest as it is, it's taking 30sec tops.\r\n> \r\n> I had to do some juggling to make esbuild and jest work together, like importing svgs etc. you can see the script [here](https:\/\/github.com\/gilamran\/fast-jest-with-esbuild)\r\n\r\nHow would you apply your approach on an angular project? I am running esbuild on a single spec file with --bundle option, it is then throwing errors TypeError: Cannot read properties of null (reading 'ngModule') every where when i run this file with jest.\r\nThe barrel imports slow performance is definitely a major issue of using jest for big projects :(","We decided to introduce jest.mock('your-module') to our jest setup file and we are able to see a decrease in setup time.\r\n\r\nReference: https:\/\/jestjs.io\/docs\/manual-mocks#mocking-user-modules","For the one looking for a quick solution, adding the option isolatedModules: true to ts-jest and it divided by 6 the execution time. We are now able to run parralel agent on a pipeline to run our thousands of tests thanks to this little option.","**TLDR**\r\n\r\nFor those struggling with 3rd party barrle imports and using **babel** as a jest transformer - [babel-plugin-direct-import](https:\/\/www.npmjs.com\/package\/babel-plugin-direct-import) does seem to improve load times (at least for us)\r\n\r\nWe test a component which imports another component from a 3rd party lib (let's call it **libA** to be short).\r\nThe **libA** imports an icon from some icon pack which exports icons via a barrel import, kinda similar to the way **material-ui** does it.\r\nSo what we have as a result is jest importing and transforming around 8k icons even though **libA** just uses a single one of them.\r\nI had to exclude this icon pack from **transformIgnorePatterns** because I simply could not figure out how to foce jest into working with esm, **--experimental-vm-modules** did not work for me, I guess there is some problem with the way that icons pack build commonjs and esm files\r\n\r\nOn my PC such a test was running for **80-90 sec** (the actual test took around **50ms**)\r\nI don't have a solid grasp on how all these modules magic works so this is what I tried:\r\n\r\n1. **babel-jest** -> **@swc\/jest** with no .swcrc at all. My test started to take only **35-40 sec** to run which already was a huge improvement. I tried to configure swc with [@swc\/plugin-transform-imports](https:\/\/github.com\/swc-project\/plugins\/tree\/main\/packages\/transform-imports) to get rid of barrel imports but it seems like I cannot use look-around regexp in Rust to split an icon component name the way I need it (( Looking into it now\r\n\r\n3. jest -> vitest. I had huge hopes for that one but unfortunately it didn't work with icons pack, I get a **<icons pack name>\/<icon>.js seems to be an ES Module but shipped in a CommonJS package**. Again - I guess the icon pack is doing smth wrong while building esm\r\n\r\n5. \u2714\ufe0f**babel-plugin-direct-import**. \r\nAdding \r\n```\r\n  plugins: [\r\n    [\r\n      \"babel-plugin-direct-import\",\r\n      {\r\n        modules: [\"<icon pack name>\"],\r\n      },\r\n    ],\r\n  ],\r\n```\r\nmade our test run for 10 sec comparing to initial 80-90 so I see it as a huge improvement\r\n\r\nHope it helps someone! Cheers!","We have around 1300 test suites with about 6k tests. Jest is taking a lot of time. We believe Barrel import is one of the main contributors to the overall slowness. It would be super helpful to get some guidance from the Jest maintainers on addressing this problem.","Would #9430 resolve this issue by allowing for tree-shaking in Jest tests?","> Would #9430 resolve this issue by allowing for tree-shaking in Jest tests?\n\nAs far as I know, tree shaking is a bundler feature, not a native ESM feature, so it's dubious it would help. ","> @fadi-george sorry I don't have the script anymore (Maybe I can look it up in the git history), but I've found even faster solution. I'm using `esbuild` to bundle ALL my tests + code into one huge file, then I run jest on this file only. so instead of 350sec. with jest as it is, it's taking 30sec tops.\r\n> \r\n> I had to do some juggling to make esbuild and jest work together, like importing svgs etc. you can see the script [here](https:\/\/github.com\/gilamran\/fast-jest-with-esbuild)\r\n\r\nI know it's been a long time since you've posted this solution, but I hope you can help me out. I have been trying to use this approach and the bundling seems to work fine. Also, when passing the single bundled file to jest, it doesn't work for tests that are using `jest.mock()` to mock some of our own modules that are defined within the same project.\r\n\r\nFor instance, we have this piece of code in one of our tests:\r\n`jest.mock(\"..\/services\/ProductService\/ProductService\");`\r\n\r\nThe corresponding file (both the actual implementation and mocked version) does exist, but when running Jest, it gives the following error:\r\n`Cannot find module '..\/services\/ProductService\/ProductService' from 'bundles\/test-files-bundle.js'`\r\nHave you by any chance ran into this and\/or do you know how to fix this?","We also face long startup times in our tests. After trying a lot of \"solutions\" mentioned on the internet we discovered that in our case the problem are the barrel files.\r\n\r\nI created two simple unit tests in our code base. Test `A` which imports from barrel files and test `B`, in which these imports are replaced by named imports. Here are the results:\r\n| test | duration |\r\n| ---- | -------- |\r\n| `A` | ~29s |\r\n| `B` | 91ms |\r\n\r\nTo be able to dig deeper into the problem you have to understand what is going on during the long startup time.\r\nFor this I modified the class `Runtime` in `node_modules\/jest-runtime\/build\/index.js`.\r\n\r\n## Modify Jest Runtime Class\r\nInstead of a patch I link the code-pointers and the added code, in case you run a different jest version. \r\nAll modifications are marked with `\/\/ MARKER` to easily find them afterwards.\r\n\r\nThe file to modify is: `node_modules\/jest-runtime\/build\/index.js`\r\n\r\n#### Step 1\r\nAdd additional class properties to track the number of loaded modules.\r\n[code pointer](https:\/\/github.com\/jestjs\/jest\/blob\/bd3a7e9fd7ba7d4eafa1f0ceb1e3a4186e7b3abd\/packages\/jest-runtime\/src\/index.ts#L230)\r\nAdd before the marked line:\r\n```\r\n\/\/ MARKER\r\nthis._LOAD_COUNTER = 0;\r\nthis._INDENTS = [];\r\n\/\/ MARKER\r\n```\r\n#### Step 2\r\nCount and log loaded modules.\r\n[code pointer 1](https:\/\/github.com\/jestjs\/jest\/blob\/bd3a7e9fd7ba7d4eafa1f0ceb1e3a4186e7b3abd\/packages\/jest-runtime\/src\/index.ts#L1107)\r\nAdd before the marked line:\r\n```\r\n\/\/ MARKER\r\nthis._LOAD_COUNTER += 1;\r\nconsole.log(`${this._INDENTS.join('')}>>_loadModule`, this._LOAD_COUNTER, moduleName)\r\nthis._INDENTS.push('\\t')\r\n\/\/ MARKER\r\n```\r\n\r\n[code pointer 2](https:\/\/github.com\/jestjs\/jest\/blob\/bd3a7e9fd7ba7d4eafa1f0ceb1e3a4186e7b3abd\/packages\/jest-runtime\/src\/index.ts#L1131)\r\nAdd before the marked line:\r\n```\r\n\/\/ MARKER\r\nthis._INDENTS.pop()\r\n\/\/ MARKER\r\n```\r\n\r\n## Outcome\r\nAfter patching the `Runtime` class I got the following numbers for my simple unit tests:\r\n| test | loaded modules |\r\n| ---- | -------- |\r\n| `A` | 17424 |\r\n| `B` | 1503 |\r\n\r\nAnd you can clearly see by the logged output that jest is importing everything in case of barrel files before running a test.\r\n\r\nAfter adjusting only some of the imports (to use named imports) in our code base as a PoC, I was able to reduce the build time from 15 minutes to 6 minutes.","We have around 3200 test suites and 35k tests. We had the similar issue. @mui\/icons-material is the culprit in our case. We simply mocked the package and time came down from 50 minutes to 18 minutes. We are still going through other packages but that's a significant time improvement for mocking just one package,\r\nHaven't tried with [babel-plugin-direct-import](https:\/\/www.npmjs.com\/package\/babel-plugin-direct-import). But i'm concerned how modules array will look in larger projects which uses around 50 MUI icons. ","> Instead of a patch I link the code-pointers and the added code, in case you run a different jest version. All modifications are marked with `\/\/ MARKER` to easily find them afterwards.\r\n\r\nThis is fantastic. Thanks for sharing your patch.\r\n\r\nI've got it printing out the results, but I'm not sure what to look for. I can see that it's certainly loading a ton of modules, but nothing stands out as something that can be optimized. Do you have any advice? Currently taking >20s to run a <3s test.","@TSMMark \r\n\r\n> I've got it printing out the results, but I'm not sure what to look for.\r\n\r\n\r\nTo investigate, you should select a simple and rather small test that has an unexpectedly long start time. \r\n\r\nMaybe you can see the difference better in the following react example. As mentioned by others `@mui\/icons-material` is a good candidate to slow down your tests massively. \r\n\r\nIf you are not already using `@mui\/icons-material` in your project, add it as a devDependency for demo purposes.\r\n\r\nCreate a test tsx-file and add the following code:\r\n```\r\nimport React from 'react'\r\n\/\/ this import slows your test down\r\nimport { DoNotDisturbOn } from '@mui\/icons-material'\r\n\/\/ this import not\r\n\/\/ import DoNotDisturbOn from '@mui\/icons-material\/DoNotDisturbOn'\r\n\r\ntest('should demo the problem', () => {\r\n  <DoNotDisturbOn \/>\r\n  expect(1).toBe(1)\r\n})\r\n```\r\n\r\nThe test with the second import for `DoNotDisturbOn` should start much faster because it imports far fewer modules.\r\n\r\nNow run the single test with only one of the two imports for `DoNotDisturbOn` and compare the amount of loaded modules. Search in the output for `@mui\/icons-material` to see what jest also imported from it.\r\n\r\nWith this knowledge, you should be able to find problematic imports in your codebase.","is there a plugin or something that can solve all barrel files usages?","> is there a plugin or something that can solve all barrel files usages?\r\n\r\nUnfortunately not. There are several workarounds in this thread, but none are low-effort.\r\n\r\n---\r\n\r\nFYI, if you're looking at any of the above issues, here are some limitations and things to experiment with:\r\n\r\n**- Remove barrel files and only test what you can see**\r\n\r\nSure-fire way to fix this. However, not feasible in larger codebases using barrel files liberally. (Plus, it's tilting at windmills. Build for the actual need, not the ideal.) In addition, mock things your test subject is using, so that your test is focused on exactly the logic you wrote. Let TypeScript make sure your interfaces continue to align, and if you're worried, you can have another layer of tests to ensure interop between modules. (We have a test capital-i, where we have 100% unit test coverage, and a comprehensive set of end-to-end tests that validate high-level module interop. Almost no integration tests because those often end up _slower_ than our end-to-end tests!).\r\n\r\n**- Try out the various Babel plugins listed above**\r\n\r\nThis may work for you on relatively small projects without using a lot of mocks and spies. However, most of these are opt-in, and are only useful if you can identify up-front where a lot of your heftier barrel files are. In many cases, this isn't feasible.\r\n\r\n**- Try another test runner**\r\n\r\nSomething like Vite might work better, but most people won't have a 1:1 transition from Jest. Vite uses  enforces strict modules (e.g., not mockable\/spyable in the same ways Jest is). Also, it suffers from the [same issues](https:\/\/vitest.dev\/guide\/coverage.html#ignoring-code) as those described below, since it also uses ESBuild. But you might have luck here if you don't do anything fancy with mocks\/spies.\r\n\r\n**- ESBuild\/SWC all the things**\r\n\r\nIf you barely use Jest's mocking\/spy features, this might be feasible. However, any alternative transformer to Babel will be a pain if you use them. Synthetic exports in babel are loosely constructed (e.g., they're mutable references, so can be replaced spied on). Tools like SWC and ESBuild adhere more to official specs for modules (e.g., modules are immutable, can't be monkey patched, etc.).\r\n\r\nI have not yet tried Rollup for our tests. Might be worth a shot if someone has the energy, but I'd be surprised if it's any faster\/better\/useable than any of the above examples.\r\n\r\nI have experimented with a custom Jest transformer, too, that uses Babel to hoist `jest.mock` calls; esbuild to transpile everything else; and comprehensive set of modifications to `esbuild` output that enables things like `istanbul ignore` lines (`esbuild` transpiles out all comments unless you mark them as legally required) and switches it to a loose module system with easy find\/replace. But this also has limitations (e.g., if you're not careful, it can break your source maps; it _still_ transpiles a million things, but at least `esbuild` is faster than babel at it). This is a fraught game of whack a mole. You have to know and account for every weird way people use mocks and spies ahead of time, and with thousands of tests, there are probably a couple hundred combinations to account for \ud83d\ude2d \r\n\r\n---\r\n\r\nIn my case, we're a bit stuck. We have a huge codebase with tons of mocks and spies (we require 100% code coverage, and suggest that developers have 1:1 test -> adjacent test file with 100% coverage, so our codebase is at least half test code). This has been excellent for maintaining high code quality based on the standards when we began (circa 2019). But the barrel file issue is a thorny one. In new code, we don't allow them, but we've got thousands of tests that drag because of this.\r\n\r\n**To put it simply:** there's no easy solution here. In hindsight, it was probably engineering malpractice to suggest the use of barrel files, and we're paying for our past oversight! \ud83d\ude06\r\n\r\nThe only clear way forward at the moment is to suck it up, deal with slow tests for a while, and refactor them as you get the opportunity. I've been experimenting on the side for my team for _years_ looking for ways to make this better, especially as our lazier engineers realize how easy we've made it to write thick tests that exercise huge swaths of the platform. Yeah, it's less test code, but it takes two minutes to get feedback. Some folks don't mind waiting, but I sure do.\r\n\r\nDespite our best efforts, even the best engineers will take shortcuts to shave off a few minutes from their tickets, and make everyone pay for that in the time it takes to run tests. Amortized over several years and several dozen developers, and you're looking at 3 minute startup times for a single, 3ms test that ensures an `if` statement works correctly in a 12 line file.\r\n\r\nI almost think Jest (or some other tool) needs a way to elevate how much code a certain test is using and give us the ability to set upper limits. It's a waste of time and CPU to load 20,000 modules to test a couple of logical branches. No matter what Jest does to make this better, without the automatic tooling for us tech leads to set upper bounds on this, I don't foresee this being all that fixable with some out of the box solution... \ud83e\udd14","I have taken a stab at writing my own jest transformer to accomplish this. I'm using an Nx mono repo with about 11 Angular libraries inside (v17.1), I have about 1600 unit tests, and it takes about 5 minutes to run. The jest transformer I've created will correctly replace all of the paths in my ts config with the import pointing to the actual file of where it's exported. However, my solution doesn't work when it comes to transforming 3rd-party paths like @angular\/core, @ngrx\/store, etc., because ts.createProgram will only return declaration files for any path I pass in that points to a node_module file. With this transformer only changing local imports, it's only shaved about 30 seconds off the execution time.\r\n\r\nIf there is anyone who might be able to lend a helping hand with this transformer, I would be very appreciative. I'm sure it could be very beneficial to others coming here as well. I only started working with the TypeScript compiler api a few days ago, so I'm sure that my solution is far from optimal. `modifyImportDeclaration` is where I would need the most help. I was also looking into SWC, to see if they had an api that would do something like ts.createProgram and ts.transpileModule, but I couldn't find anything. \r\n\r\n``` js\r\n\/\/ jest.preset.js \r\n\r\n{\r\n  ...\r\n  transform: {\r\n    '^.+\\\\.(ts|mjs|js|html)$': [\r\n      '<rootDir>\/jest-import-transformer.js'\r\n    ]\r\n  },\r\n  ...\r\n}\r\n```\r\n\r\n``` JavaScript\r\n\/\/ jest-import-transformer.js\r\n\r\nvar fs = require('fs');\r\nconst path = require('path');\r\nconst mkdirp = require('mkdirp');\r\nvar angularPreset = require('jest-preset-angular');\r\nconst presetConfig = {\r\n  tsconfig: '<rootDir>\/tsconfig.spec.json',\r\n  stringifyContentPathRegex: '\\\\.(html|svg)$',\r\n  isolatedModules: true\r\n};\r\nvar baseTransformer = angularPreset.default.createTransformer(presetConfig);\r\nconst ts = require('typescript');\r\nconst tsConfig = require('.\/tsconfig.base.json');\r\nconst pathCache = {};\r\nconst filePaths = {};\r\n\r\nfunction extractAllExportStatements(filePath) {\r\n  const program = ts.createProgram([filePath], {\r\n    target: tsConfig.compilerOptions.target,\r\n    module: tsConfig.compilerOptions.module\r\n  });\r\n  const output = {};\r\n  for (const sourceFile of program.getSourceFiles()) {\r\n    if (!sourceFile.isDeclarationFile || processDeclarations) {\r\n      \/\/ Walk the tree to search for exported nodes\r\n      if (!filePaths[sourceFile.fileName]) {\r\n        filePaths[sourceFile.fileName] = path\r\n          .relative(__dirname, sourceFile.fileName)\r\n          .replaceAll('\\\\', '\/');\r\n      }\r\n      const fileName = filePaths[sourceFile.fileName];\r\n      ts.forEachChild(sourceFile, node => visit(node, fileName));\r\n    }\r\n  }\r\n\r\n  return output;\r\n\r\n  function visit(node, fileName) {\r\n    \/\/ Only consider exported nodes\r\n    if (!isNodeExported(node)) {\r\n      return;\r\n    }\r\n\r\n    if (ts.isModuleDeclaration(node)) {\r\n      \/\/ This is a namespace, visit its children\r\n      ts.forEachChild(node, visit);\r\n    } else if (node.name) {\r\n      output[node.name.text] = fileName;\r\n    } else if (ts.isVariableStatement(node)) {\r\n      output[node.declarationList?.declarations[0]?.name?.text] = fileName;\r\n    } else if (ts.isExportDeclaration(node)) {\r\n      output[node.exportClause?.name?.text] = fileName;\r\n    } else {\r\n      debugger;\r\n    }\r\n  }\r\n\r\n  function isNodeExported(node) {\r\n    return (\r\n      (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 ||\r\n      (!!node.parent && node.parent.kind === ts.SyntaxKind.SourceFile) ||\r\n      node.exportClause?.name?.text \/\/ export * as [Name] syntax\r\n    );\r\n  }\r\n}\r\n\r\nfunction ensureBarrelIsCached(oldPath, barrelPath, options) {\r\n  if (!pathCache[barrelPath]) {\r\n    \/\/ Not in the cache, let's check the cacheDirectory\r\n    const cacheFilePath = path.join(options.config.cacheDirectory, oldPath + '.json');\r\n    if (fs.existsSync(cacheFilePath)) {\r\n      pathCache[barrelPath] = JSON.parse(fs.readFileSync(cacheFilePath));\r\n    } else {\r\n      \/\/ https:\/\/github.com\/microsoft\/TypeScript\/wiki\/Using-the-Compiler-API#using-the-type-checker\r\n      pathCache[barrelPath] = extractAllExportStatements(barrelPath);\r\n      const dirName = path.dirname(cacheFilePath);\r\n      mkdirp.sync(dirName);\r\n      fs.writeFileSync(cacheFilePath, JSON.stringify(pathCache[barrelPath]));\r\n    }\r\n  }\r\n}\r\n\r\nfunction modifyImportDeclaration(node, src, fileName, options) {\r\n  const oldPath = node.moduleSpecifier.text;\r\n  \/\/ only transform paths defined in our tsConfig\r\n  const barrelPath = tsConfig.compilerOptions.paths[oldPath]?.[0];\r\n  let barrelExports;\r\n  if (barrelPath) {\r\n    ensureBarrelIsCached(oldPath, barrelPath, options);\r\n    barrelExports = pathCache[barrelPath];\r\n  } else if (!oldPath.startsWith('.')) {\r\n    \/\/ @angular\/core etc.\r\n    if (!npmPackagePaths[oldPath]) {\r\n      \/\/ TODO: Remove when we have a full list\r\n      console.info(oldPath);\r\n      return src;\r\n    }\r\n\r\n    \/\/ TODO: This won't work, because createProgram will only output declaration files when calling getSourceFiles()\r\n    \/\/ extractAllExportStatements(npmPackagePaths[oldPath]);\r\n  }\r\n\r\n  if (!barrelExports) {\r\n    return src;\r\n  }\r\n\r\n  if (node.importClause && node.importClause.namedBindings) {\r\n    var directImports = [];\r\n    for (importNode of node.importClause.namedBindings.elements) {\r\n      importNode = importNode.getFullText().trim();\r\n      if (!barrelExports[importNode]) {\r\n        console.warn('Import not found!', importNode, fileName);\r\n        break;\r\n      }\r\n\r\n      var relPath = path\r\n        .relative(fileName, __dirname + '\/' + barrelExports[importNode])\r\n        .replaceAll('\\\\', '\/')\r\n        .replace('.ts', '')\r\n        .replace('..\/', '');\r\n      directImports.push(`import {${importNode}} from '${relPath}';`);\r\n    }\r\n    if (directImports.length) {\r\n      var transformedFileSrc = src.replace(node.getFullText(), directImports.join('\\r\\n'));\r\n      return transformedFileSrc;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n\r\nfunction processFile(src, filename, options) {\r\n  var transformedFileContent = src;\r\n  ts.transpileModule(src, {\r\n    compilerOptions: tsConfig.compilerOptions,\r\n    fileName: filename,\r\n    transformers: {\r\n      before: [\r\n        context => {\r\n          return sourceFile => {\r\n            function visit(node) {\r\n              if (ts.isImportDeclaration(node)) {\r\n                transformedFileContent = modifyImportDeclaration(\r\n                  node,\r\n                  transformedFileContent,\r\n                  filename,\r\n                  options\r\n                );\r\n                \/\/ TODO find a way to replace the node with multiple import nodes instead\r\n              }\r\n              return ts.visitEachChild(node, visit, context);\r\n            }\r\n            return ts.visitNode(sourceFile, visit);\r\n          };\r\n        }\r\n      ]\r\n    }\r\n  });\r\n  return transformedFileContent;\r\n}\r\n\r\nmodule.exports = {\r\n  process(src, fileName, options) {\r\n    let newSrc = src;\r\n    if (fileName.endsWith('.ts') && !ignoreFiles.some(f => fileName.includes(f))) {\r\n      newSrc = processFile(src, fileName, options);\r\n    }\r\n\r\n    \/\/ This is far from optimal, as I'm sure jest-preset-angular will also transpile the module\r\n    return baseTransformer.process(newSrc, fileName, {\r\n      ...options,\r\n      transformConfig: presetConfig\r\n    });\r\n  }\r\n};\r\n\r\nconst ignoreFiles = ['test-setup', 'test-polyfills'];\r\nconst npmPackagePaths = {\r\n  '@ngrx\/effects': 'node_modules\/@ngrx\/effects\/esm2022\/public_api.mjs',\r\n  '@ngrx\/entity': 'node_modules\/@ngrx\/entity\/esm2022\/public_api.mjs',\r\n  '@ngrx\/operators': 'node_modules\/@ngrx\/operators\/esm2022\/public_api.mjs',\r\n  '@ngrx\/router-store': 'node_modules\/@ngrx\/router-store\/esm2022\/public_api.mjs',\r\n  '@ngrx\/store': 'node_modules\/@ngrx\/store\/esm2022\/src\/index.mjs',\r\n  '@angular\/animations': 'node_modules\/@angular\/animations\/esm2022\/public_api.mjs',\r\n  '@angular\/cdk': 'node_modules\/@angular\/cdk\/esm2022\/public_api.mjs',\r\n  '@angular\/common': 'node_modules\/@angular\/common\/esm2022\/public_api.mjs',\r\n  '@angular\/common\/http': 'node_modules\/@angular\/common\/esm2022\/http\/public_api.mjs',\r\n  '@angular\/core': 'node_modules\/@angular\/core\/esm2022\/public_api.mjs',\r\n  '@angular\/core\/testing': 'node_modules\/@angular\/core\/esm2022\/testing\/public_api.mjs',\r\n  '@angular\/forms': 'node_modules\/@angular\/forms\/esm2022\/public_api.mjs',\r\n  '@angular\/material': 'node_modules\/@angular\/material\/esm2022\/public_api.mjs',\r\n  '@angular\/router': 'node_modules\/@angular\/router\/esm2022\/public_api.mjs',\r\n  'rxjs': 'node_modules\/rxjs\/dist\/esm\/index.js',\r\n  '@testing-library\/angular': 'node_modules\/@testing-library\/angular\/esm2022\/index.mjs'\r\n};\r\n```"],"labels":["Discussion"]},{"title":"Expose project matching behaviour","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nExpose the logic that determines what project a file belongs to. Given a file path and a Jest configuration, what options apply?\r\n\r\n## Motivation\r\n\r\nTo allow third-party tools to understand Jest configurations. E.g: https:\/\/github.com\/jest-community\/eslint-plugin-jest\/pull\/754#issuecomment-780396777\r\n\r\n## Example\r\n\r\nI am not sure what package this logic currently resides in, but something along the lines of:\r\n```\r\nimport { resolveOptions } from '@jest\/options';\r\nimport { readConfig } from '@jest\/config';\r\n\r\nconst config = await readConfig('\/path\/to\/jest.config.js');\r\nconst options = await resolveOptions('\/path\/to\/unit.test.js', config);\r\n```\r\n\r\n## Pitch\r\n\r\nThe projects logic is very specific to Jest, and recreating it externally would likely be erroneous and fall out-of-date quickly.\r\n","comments":["Yep, should deffo do this \ud83d\udc4d \r\n\r\nI honestly don't know of the top of my head where this logic resides \ud83d\ude05 I assume it's somewhere in `@jest\/core`. Should be moved to its own module probably, or even as part of `jest-config` (`core` is... big)","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"Support ESM versions of all pluggable modules","body":"Once Node 10 is EOL at the end of April, lots of libraries and modules will probably be written in native ESM rather than CJS. While we've mostly been focusing on getting _tests_ running in ESM, we're sorta limited\/slowed down by the fact the `vm` APIs are experimental and flagged on Node's side. That is not the case for \"normal\" ESM.\r\n\r\nWe already support user configuration written in ESM.\r\n\r\nWith that in mind, all modules in Jest that are \"pluggable\" should be able to load ESM.\r\n\r\n- [x] `dependencyExtractor` (#12008)\r\n- [x] `globalSetup` (#11267)\r\n- [x] `globalTeardown` (#11267)\r\n- [x] `preset` (#11200)\r\n- [ ] `prettierPath`\r\n- [x] `reporters` (#11427)\r\n- [ ] `resolver`\r\n- [x] `runner` (#11232)\r\n- [ ] `snapshotResolver`\r\n- [ ] `snapshotSerializers`\r\n- [x] `testEnvironment` (#11033)\r\n- [x] `testResultsProcessor` (#12006)\r\n- [x] `testRunner` (#11232)\r\n- [x] `testSequencer` (#11207)\r\n- [x] `transformers` (#11163)\r\n- [x] `watchPlugins` (#11315)\r\n\r\nAny and all help here would be greatly appreciated!\r\n\r\nIn general, it means attempting to `require`, and if that fails with an ESM error, use `import()` and verify it's the `default` export. Paired with an integration test that has the module in question written in ESM and verifying it works.\r\n\r\nExample: https:\/\/github.com\/facebook\/jest\/blob\/ab014c140af2e10ae7c5790c2406009790787cdb\/packages\/jest-transform\/src\/ScriptTransformer.ts#L177-L196\r\n\r\n---\r\n\r\nWhenever we drop Node 10 (_probably_ for Jest 28) we can do _just_ the `import` call as that can load both ESM and CJS, but that'll be a simple refactor as it's just removing the initial `require` and `try-catch`. So I still think it's worth it to add support now as the code difference is quite small and the later refactor is minimal","comments":["I think it\u2019s wise to pin this issue so it stands out to everyone :)","sure \ud83d\ude42 ","I think we can already drop the support node 10 for `jest@27`, there is no need to wait for `jest@28` as it will reach EOL. :+1: ","D-Day for Node 10 is here xD","Jest 27 will support Node 10 so people who are stuck on older versions (of which there are _many_) can use it","@SimenB you listed `globalSetup` as one of thing to migrate to ESM but I don't see `setupFiles`. Is it an omission or it will be taken care with `globalSetup`?\r\n","`setupFiles` are part of the test run, so that already works \ud83d\ude42","Maybe that's one of the modules I am using but I cannot use ESM in my `setupFiles` with the current version `27.0.0-next.9`","Could you open up a new issue with a reproduction?","I want to do `reporters` and `resolver`, then release v27. Anyone up for sending PRs for those?\r\n\r\n- `reporters`: https:\/\/github.com\/facebook\/jest\/blob\/a4358d619131498287e25a2c2f604f813481ddeb\/packages\/jest-core\/src\/TestScheduler.ts#L403\r\n- `resolver`: A bit more involved as we'll need to load the resolver ahead of time instead of on demand. I.e. passing a `resolverModule` option in addition to `resolver`? The place it's `require`d today needs to stay synchronous. https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-resolve\/src\/index.ts#L108","> Maybe that's one of the modules I am using but I cannot use ESM in my `setupFiles` with the current version `27.0.0-next.9`\r\n\r\nHi @gilles-yvetot \r\n\r\nIf you want to fix the `setupFiles` thing, you can compare your approach to what I'm doing in [firebase-jest-testing](http:\/\/github.com\/akauppi\/firebase-jest-testing). It uses both Jest 27.0.0-next.9 and ESM `globalSetup`.","Decided to skip `resolver` for now, as I think having to make it async will probably be more natural together with adding async resolution in #9505.\r\n\r\nOpened up #11427 for `reporters`","Should `moduleNameMapper` be part of this meta-task?","Hmm, maybe. I'd have assumed that worked as it should seeing as it should just remap the identifier and the rest should work as \"normal\". Is that not the case?","I tested it, and it does work \ud83d\ude06 ","Hi @SimenB,\r\nI just try to help doing these parts:\r\n\r\n- dependencyExtractor\r\n- prettierPath\r\n- snapshotResolver\r\n- snapshotSerializers\r\n\r\nAfter I dived into it, I found there're some problems that I can't solve by myself.\r\n\r\n## dependencyExtractor\r\n\r\n`dependencyExtractor` is used in the constructor:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-haste-map\/src\/index.ts#L241-L250\r\n\r\nSo the only chance I could find is to make the whole HasteMap factory async like this:\r\n\r\n```js\r\nawait HasteMap.create(...);\r\n```\r\n\r\nIs this a right approach?\r\n\r\n## prettierPath\r\n\r\n`prettierPath` is required using a helper called `requireOutside`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-snapshot\/src\/InlineSnapshots.ts#L53-L60\r\n\r\nThis `requireOutside` function will be transformed by `babel-plugin-jest-require-outside-vm`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/scripts\/babel-plugin-jest-require-outside-vm.js#L13-L21\r\n\r\nI currently don't have enough knowledge about how to handle this with ESModules.\r\n\r\n## snapshotResolver & snapshotSerializers\r\n\r\nThose two are relying on the `localRequire` function:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-snapshot\/src\/SnapshotResolver.ts#L79-L85\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-jasmine2\/src\/setup_jest_globals.ts#L95-L104\r\n\r\nSo, should we pass `runtime.unstable_importModule.bind(runtime)` as `localImport` to solve this problem?\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-circus\/src\/legacy-code-todo-rewrite\/jestAdapter.ts#L34\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-runtime\/src\/index.ts#L622","Wonderful, thanks!\r\n\r\n> `dependencyExtractor`\r\n\r\nYeah, that seems correct. Makes it a breaking change though, so need to wait for Jest 28.\r\n\r\n> `prettierPath`\r\n\r\nGood point, we might have to leave that alone. This is for a specific module (`prettier`) though, so not as likely that people plug in their own thing which is ESM. If (when) `prettier` migrates to ESM only, we must change, but up until that leaving it as `require` seems sensible.\r\n\r\n> `snapshotResolver` & `snapshotSerializers`\r\n\r\nYeah, passing in `unstable_importModule` makes sense. Should probably also pass in https:\/\/github.com\/facebook\/jest\/blob\/3d04f33daa3b9ec21838c9177ab7acab8c983155\/packages\/jest-runtime\/src\/index.ts#L421","Passing `localRequire`, `unstable_importModule` and `unstable_shouldLoadAsEsm` through multiple layers looks a little bit tricky and breaks function signature unavoidably.\r\n\r\nHow about replacing `localRequire` with a `localRequireOrImportModule` function?","That should work as well \ud83d\udc4d ","@SimenB is there any work left to do? I am very glad to push these things forward.","Great! The ones not crossed out in the OP are still missing. Not sure how feasible they are","@SimenB is this waiting for nodejs team to provide support?","HI @SimenB \r\ni'm currently facing badly issue using jest ES6 to mock axios in nodejs \r\njest doesn't mock axios like when using **ESM** like it was when using require to **import** module\r\nPlease take a look here https:\/\/github.com\/axios\/axios\/issues\/5676#issue-1682834041\r\n","Is it possible to make  [`expect`](https:\/\/github.com\/jestjs\/jest\/tree\/main\/packages\/expect) ESM compatible?\r\nESM\u00a0compatibility is worthwhile since it can be installed as a separate module\/dependency.","> Good point, we might have to leave that alone. This is for a specific module (`prettier`) though, so not as likely that people plug in their own thing which is ESM. If (when) `prettier` migrates to ESM only, we must change, but up until that leaving it as `require` seems sensible.\r\n\r\nPrettier seems to have moved on to ESM: https:\/\/prettier.io\/blog\/2023\/07\/05\/3.0.0.html.","\ud83c\udfbb "],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"How to add own unhandledRejection handler?","body":"I recently *NEEDED* to get the information out of node's `unhandledRejection` handler for test debugging purposes. I needed access to the `promise` argument and also be able to write my own unhandled handler so I could read some `async_hooks` information and\/or add a `debugger` statement.  Context: I had a mystery unhandled promise rejection I was hunting down for about a week. I could see where the rejection Error came from, but no possible way to figure out which *promise* was rejecting and being unhandled, not without doing some `async_hooks` magic.\r\n\r\nCurrently debugging this type of thing seems impossible with Jest? Only way I could make it work was to get in and hack up Jest's code in `node_modules`.\r\n\r\n----\r\n\r\n### Things I Tried\r\n\r\nI couldn't find any way to get my own `unhandledRejection` handler to run, I tried these to no avail:\r\n\r\n* Adding handler in the jest setup script module body\r\n* Adding handler in the jest setup script returned async function body\r\n* Adding handler within the test file itself\r\n* `--runInBand` \r\n* `process.on('uncaughtExceptionMonitor'`\r\n\r\nStill couldn't make it work after commenting out Jest's rejection handler stuff in `jest-circus\/build\/globalErrorHandlers.js` and also in `jest-jasmine2\/build\/jasmine\/Env.js`, (I don't think this was running with jest-circus, but I commented it out just to be sure):\r\n\r\n```js\r\n\/\/ node_modules\/jest-circus\/build\/globalErrorHandlers.js\r\nconst injectGlobalErrorHandlers = parentProcess => {\r\n  const uncaughtException = process.listeners('uncaughtException').slice();\r\n  const unhandledRejection = process.listeners('unhandledRejection').slice();\r\n  \/\/ parentProcess.removeAllListeners('uncaughtException');\r\n  \/\/ parentProcess.removeAllListeners('unhandledRejection');\r\n  \/\/ parentProcess.on('uncaughtException', uncaught);\r\n    parentProcess.on('unhandledRejection', (reason, promise) => {\r\n        debugger\r\n    })\r\n  return {\r\n    uncaughtException,\r\n    unhandledRejection\r\n  };\r\n};\r\n\r\nexports.injectGlobalErrorHandlers = injectGlobalErrorHandlers;\r\n\r\nconst restoreGlobalErrorHandlers = (parentProcess, originalErrorHandlers) => {\r\n  \/\/ parentProcess.removeListener('uncaughtException', uncaught);\r\n  \/\/ parentProcess.removeListener('unhandledRejection', uncaught);\r\n\r\n  \/\/ for (const listener of originalErrorHandlers.uncaughtException) {\r\n    \/\/ parentProcess.on('uncaughtException', listener);\r\n  \/\/ }\r\n\r\n  \/\/ for (const listener of originalErrorHandlers.unhandledRejection) {\r\n    \/\/ parentProcess.on('unhandledRejection', listener);\r\n  \/\/ }\r\n};\r\n\r\n```\r\n\r\n\r\n\r\nNothing worked. Perhaps at a minimum Jest could provide some warning \"this won't work\" if you try to add a `unhandledRejection` handler, rather than just having it just not work silently and mysteriously?\r\n\r\nI am genuinely curious why the rejection handler still doesn't work after commenting this stuff out, is Jest doing some magic stuff to give per-test `process` instances or something? Can this be turned off?\r\n\r\n----\r\n\r\n### Hacky Workaround\r\n\r\nOnly thing I could do that would work was to hack into the `injectGlobalErrorHandlers` source in `node_modules\/\u2026\/globalErrorHandlers.js` to add my own handler there:\r\n\r\n```js\r\n\/\/ node_modules\/jest-circus\/build\/globalErrorHandlers.js\r\nconst injectGlobalErrorHandlers = parentProcess => {\r\n  parentProcess.on('unhandledRejection', (reason, promise) => {\r\n    debugger\r\n  })\r\n  \/\/ \u2026\r\n}\r\n ```\r\n\r\nThis is obviously not a good solution. \r\n\r\nI understand why Jest wants to know about the uncaughtException\/unhandledRejection but I wish this were optional or had some way I could attach my own code into the handler. Not sure there's currently a way to do this short of writing a custom reporter?\r\n\r\n ----\r\n\r\n### Additionally\r\n\r\nEven if I did something like set up my own test reporter to receive `dispatch` information, Jest's `uncaught` handler doesn't even report all the available information that one might need for debugging! It's missing the second parameters: `promise`  for unhandled rejections and `origin` for uncaught exceptions:\r\n\r\n```js\r\n\/\/ node_modules\/jest-circus\/build\/globalErrorHandlers.js\r\nconst uncaught = error => {\r\n  (0, _state.dispatchSync)({\r\n    error,\r\n    name: 'error'\r\n  });\r\n};\r\n\/\/ \u2026\r\n\r\nparentProcess.on('uncaughtException', uncaught);\r\n```\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/417650e749470bb9e1bbade3788e2f5912325eff\/packages\/jest-circus\/src\/globalErrorHandlers.ts#L11-L14\r\n \r\n \r\n It should probably be something like: \r\n ```js\r\n \/\/ node_modules\/jest-circus\/build\/globalErrorHandlers.js\r\n const uncaught = (reason, originOrPromise) => {\r\n   \/\/ \u2026\r\n }\r\n ```\r\n\r\n ----\r\n\r\nPerhaps related to: \r\n* https:\/\/github.com\/facebook\/jest\/issues\/5620","comments":["This has been driving me nuts today. ","I expected adding a listener in `jest.config.js`: `process.on('unhandledRejection')` would work, but it doesn't do anything.\r\n\r\nI'm tracking down a bug with unresolved promise and this is all I got `(node:2331380) UnhandledPromiseRejectionWarning: [object Object]`. It's not very helpful.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump"],"labels":["Needs Triage","Bug Report"]},{"title":"Document expect(.not).(array|object)Containing()'s actual behavior","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\nThe existing documentation for `expect.objectContaining()`, `expect.not.objectContaining()`, and to a lesser degree `expect.arrayContaining()` and `expect.not.arrayContaining()` doesn't match their behavior. This has resulted in a number of issues (see #11126, #10462, #10186) and attempts to align the behavior with the documentation (see #10508, #10766, #10708), with varying degrees of success.\r\n\r\nIn this PR, I documented the actual behavior of these asymmetric matchers on `master`. As it turns out, the actual behavior of `expect.objectContaining()` is quite strange. Unfortunately, I don't know what the behavior should be, so I'm submitting this PR as-is rather than opening issues.\r\n\r\nDocumentation\/behavior conflicts and edge cases:\r\n\r\n- `expect.objectContaining()`, `expect.not.objectContaining()` are not recursive\r\n- `expect.objectContaining()` can match primitive values\r\n    - `expect.objectContaining()` boxes truthy primitives and doesn't box falsy primitives\r\n- `expect.arrayContaining([])` can match non-arrays (and in fact matches anything)\r\n- `expect.not.arrayContaining([])` matches nothing\r\n\r\nI recommend **not** merging this PR and instead deciding what `expect.objectContaining()` should actually do. I'd be happy to update this to reflect the intended behavior, or someone else could submit a new PR.\r\n\r\nThis PR would close #11126 and close #10462.\r\n\r\n## Test plan\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n\r\nSeveral tests were added to cover `expect.objectContaining()` and `expect.not.objectContaining()`'s behavior with primitive received values.\r\n","comments":["# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=h1) Report\n> Merging [#11157](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=desc) (da3ad5c) into [master](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/1d8f95588861139ad60949c2f87d05e9c12eaffc?el=desc) (1d8f955) will **decrease** coverage by `0.01%`.\n> The diff coverage is `n\/a`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master   #11157      +\/-   ##\n==========================================\n- Coverage   64.20%   64.19%   -0.02%     \n==========================================\n  Files         307      307              \n  Lines       13371    13371              \n  Branches     3261     3261              \n==========================================\n- Hits         8585     8583       -2     \n- Misses       4082     4083       +1     \n- Partials      704      705       +1     \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=tree) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/expect\/src\/utils.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157\/diff?src=pr&el=tree#diff-cGFja2FnZXMvZXhwZWN0L3NyYy91dGlscy50cw==) | `94.83% <0.00%> (-1.30%)` | :arrow_down: |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=footer). Last update [1d8f955...da3ad5c](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/11157?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments).\n","Hey @ninevra! I'd love to land this - any particular reason it's a draft? \ud83d\ude42 \r\n\r\nEDIT:\r\n\r\n> I recommend **not** merging this PR and instead deciding what `expect.objectContaining()` should actually do. I'd be happy to update this to reflect the intended behavior, or someone else could submit a new PR.\r\n\r\nOh \ud83d\ude05 Let me give it a think, and add it to the milestone so we don't forget","I don't want this to hold up the release, so swapping milestone. I'll probably have time to deal with this before next major (which will be this summer after node 17 is EOL)"],"labels":["cla signed"]},{"title":"mockResolvedValue not resolving in time with Angular fakeAsync\/tick","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n1. Using a new Angular project with jest set up, run the following [test](https:\/\/github.com\/aziparu\/angular-jest\/blob\/main\/src\/app\/test.service.spec.ts):\r\n```\r\nimport { fakeAsync, tick } from '@angular\/core\/testing';\r\n\r\nclass TestService {\r\n  constructor(private dependency: any) {}\r\n\r\n  doSomething() {\r\n    this.dependency.getPromise().then(() => this.dependency.run());\r\n  }\r\n}\r\n\r\ndescribe('TestService', () => {\r\n  let dependency;\r\n  let testService: TestService;\r\n\r\n  beforeEach(() => {\r\n    dependency = {\r\n      run: jest.fn(),\r\n      getPromise: jest.fn()\r\n    };\r\n    testService = new TestService(dependency);\r\n  });\r\n\r\n  it('this fails', fakeAsync(() => {\r\n    dependency.getPromise.mockResolvedValue('arbitrary');\r\n\r\n    testService.doSomething();\r\n    tick();\r\n\r\n    expect(dependency.run).toHaveBeenCalled();\r\n  }));\r\n\r\n  it('this passes', fakeAsync(() => {\r\n    dependency.getPromise.mockImplementation(() => Promise.resolve('arbitrary'));\r\n\r\n    testService.doSomething();\r\n    tick();\r\n\r\n    expect(dependency.run).toHaveBeenCalled();\r\n  }));\r\n});\r\n```\r\n\r\n## Expected behavior\r\nBoth tests should pass\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\n## Link to repl or repo (highly encouraged)\r\nhttps:\/\/github.com\/aziparu\/angular-jest\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (16) x64 Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz\r\n  Binaries:\r\n    Node: 12.10.0 - ~\/.nodenv\/versions\/12.10.0\/bin\/node\r\n    Yarn: 1.22.4 - ~\/.nodenv\/versions\/12.10.0\/bin\/yarn\r\n    npm: 6.14.11 - ~\/.nodenv\/versions\/12.10.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.6.3 => 26.6.3\r\n```\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump!","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump"],"labels":["Needs Triage","Bug Report"]},{"title":"Tests logging after teardown do not fail tests in non-watch mode","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n#10728 sets the exit code to 1 when tests log after teardown. This correctly terminates the process if run in non-watch mode. However, if you do `jest --watch` then all tests are reported as passing, despite there being a warning:\r\n\r\n> Cannot log after tests are done. Did you forget to wait for something async in your test?\r\n\r\nAdditionally, I noticed that `console.warn` and `console.error` don't cause failures - is that intended? I'm also happy to open a dedicated issue if you prefer keeping things isolated.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n1. Given this test:\r\n\r\n    ```js\r\n    \/\/ sum.test.js\r\n    \r\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n    \r\n    test('should fail in watch mode', () => {\r\n      async function foo() {\r\n        await delay(100);\r\n    \r\n        console.log('this should fail tests in watch mode too');\r\n      }\r\n    \r\n      foo();\r\n      expect(true).toBe(true);\r\n    });\r\n    ```\r\n\r\n1. Run `yarn jest --watchAll` (or `--watch` if running inside a git repo)\r\n1. Observe that Jest reports a passing test, although it does log a warning:\r\n\r\n    <img width=\"694\" alt=\"Screenshot 2021-02-28 at 23 05 55\" src=\"https:\/\/user-images.githubusercontent.com\/2852660\/109436851-bd6e2d80-7a32-11eb-92de-760d04c6f72c.png\">\r\n\r\n1. Now if you just run `yarn jest`, you'll see the process exits with exit code 1.\r\n\r\n## Expected behavior\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\nJest should report a test failure.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/@NMinhNguyen\/jest-playground#sum.test.js\r\n\r\nNote: you'll need to run it in watch mode: `yarn jest --watchAll` (`--watchAll` since it's not inside a git repo).\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\nnpx envinfo --preset jest\r\nnpx: installed 1 in 3.502s\r\n\r\n  System:\r\n    OS: Linux 5.4 Debian GNU\/Linux 9 (stretch) 9 (stretch)\r\n    CPU: (4) x64 Intel(R) Xeon(R) CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 12.18.3 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.4 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.6 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: 27.0.0-next.3 => 27.0.0-next.3 \r\n```\r\n","comments":["I will take a look and send a PR for this in near future.","Thanks @snitin315!","@SimenB Can I take this if no one's working on it already?","Hi! I'm one of the program coordinators of a nonprofit program called [CodeDay Init](https:\/\/labs.codeday.org\/), and we partner with colleges to help CS students make their first open-source contribution. \r\n\r\nWe'll claim this issue for now and a group of students will be on it soon with mentorship! If this issue is no longer relevant, please let me know. ","AFAIK this is still relevant - can't remember merging anything that should affect it at least \ud83d\ude42 ","I'm experiencing the same issue - when running on my machine, I get the  `Cannot log after tests are done. Did you forget to wait for something async in your test?` errors but Jest still finishes with exit code 0. When running the same jest command, but with `--runInBand` Jest does exit with code 1 like it should. I took me hours to figure out why Jest failed in my CI machine and not locally :-( ","I also spent many hours trying to debug this. IMO the user experience of having no tests fail, but having the process exit with a non-0 status is extremely confusing. Is there any way to correlate logging with the test that may have issued the promise (or whatever) that caused the logging after cleanup? The other problem that I experienced is that it was quite difficult to definitively find which test was causing the issue.","I also meet the problem. The jest show all tests is passed, however it return the exit code to 1 so it make my CI machine failed (this situation is appear mostly on CI machine and difficult to reproduce when running test on local). Also the error log can not help me to find the cause of the problem, I have no ideal how to handle this occasional fail test situation on my CI machine.\r\n\r\nP.S. The error message `Cannot log after tests are done. Did you forget to wait for something async in your test? ` show occasionally make the exit code return 1 and fail the CI machine process when running test.","@snitin315 commented [on Mar 1, 2021](https:\/\/github.com\/facebook\/jest\/issues\/11132#issuecomment-787561794)\r\n> I will take a look and send a PR for this in near future.\r\n\r\nThumbs up! May the \"near future\" not be long away.\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":bug: Bug","Help Wanted","Stale"]},{"title":"Prevent EPERM windows transform issue from failing tests","body":"## Summary\r\n\r\nWe would like to not have jest failing multiple runs a day because of #4444.\r\n\r\nSee https:\/\/github.com\/facebook\/jest\/issues\/4444#issuecomment-782923561 for an explanation of what is going on.\r\n\r\n## Test plan\r\n\r\nThis is really hard to test... If you think this is an approach you could accept I'd be happy to discuss what else you need.\r\n","comments":["This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Don\u2019t close - it\u2019s awaiting review :(","could you rebase?","How to proceed with this PR?","`EasyCLA Expected \u2014 Waiting for status to be reported` - can someone with write access force this to update so the PR can be merged please?","By the way, it looks like `watchPathIgnorePatterns` does not work on Windows and this might be related. See https:\/\/github.com\/jestjs\/jest\/issues\/13869#issuecomment-1503848263 and the following conversation.\r\n\r\nI think, first it would be good if someone with Windows machine could fix the issue with `anymatch` and prove that it works as expected. Having `watchPathIgnorePatterns` fixed, users could ignore problematic files. Also `.git` folder would not be watched.\r\n\r\nEDIT Ignoring errors is fun, but that hides underlying problems instead of fixing them.","<a href=\"https:\/\/easycla.lfx.linuxfoundation.org\/#\/?version=2\"><img src=\"https:\/\/s3.amazonaws.com\/cla-project-logo-prod\/cla-signed.svg\" alt=\"CLA Signed\" align=\"left\" height=\"28\" width=\"328\" ><\/a><br\/><br \/>The committers listed above are authorized under a signed CLA.<ul><li>:white_check_mark: login: lukeapage \/ name: Luke Page  (575bc01309e312e9a8b2690ef846c03fbf0cdc61, c949669dfaec11fbd9396763712d2491aaa92bb4, 5ed41456de14ec60971e7944cfaf46827e64fbae)<\/li><\/ul>","### <span aria-hidden=\"true\">\u2705<\/span> Deploy Preview for *jestjs* ready!\nBuilt [without sensitive environment variables](https:\/\/docs.netlify.com\/configure-builds\/environment-variables\/#sensitive-variable-policy)\n\n|  Name | Link |\n|:-:|------------------------|\n|<span aria-hidden=\"true\">\ud83d\udd28<\/span> Latest commit | 5ed41456de14ec60971e7944cfaf46827e64fbae |\n|<span aria-hidden=\"true\">\ud83d\udd0d<\/span> Latest deploy log | https:\/\/app.netlify.com\/sites\/jestjs\/deploys\/6540a48b84ca45000850424a |\n|<span aria-hidden=\"true\">\ud83d\ude0e<\/span> Deploy Preview | [https:\/\/deploy-preview-11104--jestjs.netlify.app](https:\/\/deploy-preview-11104--jestjs.netlify.app) |\n|<span aria-hidden=\"true\">\ud83d\udcf1<\/span> Preview on mobile | <details><summary> Toggle QR Code... <\/summary><br \/><br \/>![QR Code](https:\/\/app.netlify.com\/qr-code\/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1cmwiOiJodHRwczovL2RlcGxveS1wcmV2aWV3LTExMTA0LS1qZXN0anMubmV0bGlmeS5hcHAifQ.VBlBCc_SwEq2PQ-9lGT8luNrOCLAigXeflts1zPKBLs)<br \/><br \/>_Use your smartphone camera to open QR code link._<\/details> |\n---\n\n_To edit notification comments on pull requests, go to your [Netlify site configuration](https:\/\/app.netlify.com\/sites\/jestjs\/configuration\/deploys#deploy-notifications)._","> `EasyCLA Expected \u2014 Waiting for status to be reported` - can someone with write access force this to update so the PR can be merged please?\r\n\r\nmerged latest and signed\r\n\r\n\r\n\r\n> By the way, it looks like `watchPathIgnorePatterns` does not work on Windows and this might be related. See [#13869 (comment)](https:\/\/github.com\/jestjs\/jest\/issues\/13869#issuecomment-1503848263) and the following conversation.\r\n> \r\n> I think, first it would be good if someone with Windows machine could fix the issue with `anymatch` and prove that it works as expected. Having `watchPathIgnorePatterns` fixed, users could ignore problematic files. Also `.git` folder would not be watched.\r\n> \r\n> EDIT Ignoring errors is fun, but that hides underlying problems instead of fixing them.\r\n\r\nThis is unrelated.. I'd much rather fix the issue, but as per the PR description - there is a link to a comment in the issue where I explain what happens, the problem is around 2 jest agents trying to update\/write the same file at once and its because on windows, rename operations are not atomic.","Nearly a year since this was originally reviewed. What is the status here?","@SimenB Please could you find some time to review this PR?\r\n\r\nTheres a whole load of people using a special patch package to patch jest to fix this issue, for years:\r\nhttps:\/\/github.com\/fluffynuts\/patch-jest-cache\r\nhttps:\/\/github.com\/jestjs\/jest\/issues\/4444#issuecomment-1786547835\r\n\r\nbut now v30 will mean that package needs fixing to work with the new bundled files.\r\n\r\nI'd much rather get this merged and we can retire the patches and close the issue.\r\n\r\nI'll do whatever you want to this PR - remove the logging, make it an option, whatever but I'd really like to be able to use jest without is breaking and without having to patch it every install."],"labels":["cla signed"]},{"title":"jest.useFakeTimers() does not work with whatwg-fetch>=3.1.0","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nDue to this change: https:\/\/github.com\/github\/fetch\/pull\/575 using whatwg-fetch to make fetch work in node and then trying to run timers will cause the fetches to never resolve.\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n- use whatwg-fetch\r\n- nock a response\r\n- jest.useFakeTimers()\r\n- fetch\r\n- advance time\r\n\r\n## Expected behavior\r\n\r\nThe promise should resolve. Instead, the nock response gets called - but the then clause of the promise never gets run\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/coinbase\/rest-hooks\/pull\/553\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n\r\n  System:\r\n    OS: Linux 4.19 Ubuntu 20.04 LTS (Focal Fossa)\r\n    CPU: (16) x64 Intel(R) Core(TM) i7-10875H CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 14.8.0 - ~\/.nvm\/versions\/node\/v14.8.0\/bin\/node\r\n    Yarn: 1.22.5 - \/usr\/bin\/yarn\r\n    npm: 7.5.4 - ~\/.nvm\/versions\/node\/v14.8.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.6.3 => 26.6.3 \r\n\r\n```\r\n","comments":["You have to add\r\njest.runOnlyPendingTimers()\r\nor\r\njest.runAllTimers()\r\nafter advancing time to resolve your issue.","runOnlyPendingTimers() didn't change anything. runAllTimers() caused infinite loop (due to other timers in my code).\r\n\r\nIs there some sort of debug thing for jest mock timers where I can see the current timers in flight?\r\n\r\nBased on the probing it seems like the whatwg-fetch addition of setTimeout is somehow not being mocked at all.","The problem is the setTimeout isn't called until the promise is resolved...this must be BEFORE runOnlyPendingTimers is run, otherwise it doesn't advance that timer.\r\n\r\nHowever, since this is internal to whatwg-fetch library, I have no way of hooking code up to after the settimeout is called, since there is no promise resolution *until* that part runs.","Call\r\njest.runOnlyPendingTimers()\r\nafter calling\r\njest.advanceTimersByTime\r\n\r\nThis way timers with setTimeout(fn,0) will be called and you promise will resolve.","@CrOrc you already said that, and I tried to explain why that doesn't work. you can see this in my PR here https:\/\/github.com\/coinbase\/rest-hooks\/pull\/553\r\n\r\nFind any of the newly failing tests and add that - it doesn't work. I explained why in the comment above.","I had hard time using `whatwg-fetch` with `useFakeTimers`. My suggestion is to use `unfetch`.\r\nThe reason is `whatwg-fetch` relies on `setTimeout` and when you are in `async` mode it's not easy to handle timers functions.","This solved to mock frontend web API.\r\nAlthough, I still have the issue on node with `node-fetch`.","I am experiencing the same issue,  but it seems to work with the legacy `useFakeTimers('legacy')`.  Did the legacy implementation had a special case for 0 ms timeouts so they were run without calling `jest.runAllTimers()` ?\r\n\r\nIf that is the case, perhaps the same special case could be introduced in the new implementation?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant.","Any updates on this? Seems like devs are moving away from `jest-fetch-mock` to `whatwg-fetch` + `msw`\/`nock`, but this seems to me like a blocker. Any good workarounds? Not sure what I feel about using `unfetch` over `whatwg-fetch`."],"labels":["Needs Triage","Bug Report"]},{"title":"resetAllMocks between describe blocks is counter-intuitive","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nWhen you run `jest.resetAllMocks()` in one `describe` block, it will also reset mocks defined in other `describe` blocks. This struck me as counter-intuitive, even if after reading the docs carefully it seems to be how it is documented.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior: Run the following test file:\r\n\r\n```javascript\r\nconst topLevel = jest.fn();\r\n\r\ndescribe(\"first block\", () => {\r\n  const one = jest.fn();\r\n  const two = jest.fn();\r\n  const three = jest.fn();\r\n\r\n  afterEach(() => jest.resetAllMocks());\r\n\r\n  \/\/ Assume the tests in this block each configure the mocks with some values \/ implementation\r\n  test(\"first block test\", () => {\r\n    expect([topLevel, one, two, three]).toBeDefined();\r\n  });\r\n});\r\n\r\ndescribe(\"second block\", () => {\r\n  const local = jest.fn(() => 123);\r\n\r\n  test(\"second block test\", () => {\r\n    expect(local()).toBe(123); \/\/ Fails! Expected: 123 \/ Received: undefined\r\n  });\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nThe intuitive behavior, IMO, would be for the _second block test_ to succeed. One expects that what happens in one describe block does not affect other describe blocks, except via global state.\r\n\r\nI think I understand what actually happens: Jest first runs both `describe` blocks, and it gathers tests and before\/after blocks. Then it starts running each test (with any appropriate before\/after blocks). This means that the `local` mock is defined (and captured by the second block tests) before any test is run. Then Jest runs the first test; its after block calls `resetAllMocks`, which also resets the `local` mock, removing its implementation. Then Jest runs the second test, but `local` no longer has an implementation, so it fails.\r\n\r\nI think the intuitive behavior would be that `resetAllMocks` (and other similar methods such as `clearAllMocks`), when called from inside a `describe` block, would only affect (1) mocks defined in that `describe` block and (2) mocks defined in parent `describe` blocks and\/or at global scope.\r\n\r\n(I mean, probably the correct thing would be to cleared\/reset mocks after every test by default, or even forcefully, but that I understand might take some time.)\r\n\r\nAlso, if mocks are cleared\/reset after each test by default, `jest.fn`, `spy` and similar functions should not accept an implementation or other mock configuration when called directly inside a `describe` block. Mocking values and implementations should only be allowed inside tests and before\/after blocks, anything else is a clear error, since they would be lost after each test.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/@BogdanButnaru\/jest-playground\r\n\r\n## envinfo\r\n\r\n```\r\nnpx: installed 1 in 2.3s\r\n\r\n  System:\r\n    OS: Windows 10 10.0.18363\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-7300U CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 14.7.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.4 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.14.11 - C:\\Program Files\\nodejs\\npm.CMD\r\n```\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I still consider this issue valid.","Valid!"],"labels":["Needs Triage","Bug Report"]},{"title":"transformIgnorePatterns not working when ignoring untranspiled package from another Github repo","body":"## \ud83d\udc1b Bug Report\r\n\r\nI am currently running into an issue where a jest test is breaking because I'm importing a package in another repo I have created in my package.json which breaks the test that imports that package. Using transformIgnorePatterns to ignore this package should fix this issue, but it unfortunately does not.\r\n\r\n## To Reproduce\r\n\r\nIn the package.json of freddies_testing_playground, I link greeter, another repo I have created like so:\r\n\r\n```\r\n\"greeter\": \"git@github.com:Freddie-Pike\/greeter.git#semver:0.0.1\"\r\n```\r\n\r\n\"Greeter\" is a repo that I have setup that uses the Greeter example in the TypeScript docs to show an example of importing a Github repo in a package.json. Here's what the Greeter class looks in the greeter repo:\r\n\r\n```\r\n\/\/ From the TypeScript docs: https:\/\/www.typescriptlang.org\/docs\/handbook\/classes.html\r\nclass Greeter {\r\n  greeting: string;\r\n  constructor(message: string) {\r\n    this.greeting = message;\r\n  }\r\n  greet() {\r\n    return \"Hello, \" + this.greeting;\r\n  }\r\n}\r\nexport default Greeter;\r\n```\r\n\r\nUnfortunately, a jest test in freddies_testing_playground breaks because of the greeter repo. A react component(I wanna stress up front, that the react component isn't breaking, as I have tested the component in the actual browser) called GreeterUI imports the greeter class like so:\r\n\r\n```\r\nimport React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport Greeter from \"greeter\";\r\n\r\nfunction GreeterUI({ person }) {\r\n  const greeter = new Greeter(person);\r\n  return <div>{greeter.greet()}<\/div>;\r\n}\r\n\r\nGreeterUI.propTypes = {\r\n  person: PropTypes.string,\r\n};\r\n\r\nexport default GreeterUI;\r\n```\r\n\r\nThe test uses react-testing-library, which I wanna stress is not the problem here, as I have another test in this repo that uses react-testing-library which works fine. Here's the code for the test that's breakiing:\r\n\r\n```\r\nimport React from \"react\";\r\nimport { render, screen } from \"@testing-library\/react\";\r\nimport GreeterUI from \"..\/GreeterUI\";\r\n\r\ndescribe(\"GreeterUI\", () => {\r\n  it(\"renders greeting text.\", () => {\r\n    render(<GreeterUI person={\"Fred\"} \/>);\r\n    const greeting = screen.queryByText(\/hello, fred\/i);\r\n    expect(greeting).toBeInTheDocument();\r\n  });\r\n});\r\n```\r\n\r\nWhen running the test suite using npm run test, this stack trace occurs:\r\n\r\n```\r\n FAIL  js\/components\/GreeterUI\/__tests__\/GreeterUI.test.jsx\r\n  \u25cf Test suite failed to run\r\n    Jest encountered an unexpected token\r\n    This usually means that you are trying to import a file which Jest cannot parse, e.g. it's not plain JavaScript.\r\n    By default, if Jest sees a Babel config, it will use that to transform your files, ignoring \"node_modules\".\r\n    Here's what you can do:\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/en\/configuration.html\r\n    Details:\r\n    \/Users\/freddiepike\/github_action_jest\/node_modules\/greeter\/dist\/index.js:1\r\n    ({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,global,jest){export { default } from \".\/Greeter\";\r\n                                                                                             ^^^^^^\r\n    SyntaxError: Unexpected token 'export'\r\n      1 | import React from \"react\";\r\n      2 | import PropTypes from \"prop-types\";\r\n    > 3 | import Greeter from \"greeter\";\r\n        | ^\r\n      4 | \r\n      5 | function GreeterUI({ person }) {\r\n      6 |   const greeter = new Greeter(person);\r\n      at Runtime.createScriptFromCode (node_modules\/jest-runtime\/build\/index.js:1266:14)\r\n      at Object.<anonymous> (js\/components\/GreeterUI\/GreeterUI.jsx:3:1)\r\nTest Suites: 1 failed, 2 passed, 3 total\r\nTests:       2 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        9.077 s\r\nRan all test suites.\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! github_action_jest@1.0.0 test: `jest --runInBand`\r\nnpm ERR! Exit status 1\r\nnpm ERR! \r\nnpm ERR! Failed at the github_action_jest@1.0.0 test script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     \/Users\/freddiepike\/.npm\/_logs\/2020-11-16T22_05_57_035Z-debug.log\r\n```\r\n\r\nReading the stack trace, I have tried to set the transformIgnorePatterns in order for the greeter import so the import works. Here's the excerpt of what the transformIgnorePatterns does in my jest.config.js.\r\n\r\n```\r\ntransformIgnorePatterns: [\"<rootDir>\/node_modules\/(?!${greeter})\"],\r\n```\r\n\r\nThis still returns the same error, despite following the snippet from the jest docs on this that says:\r\n\r\n> Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside node_modules are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use transformIgnorePatterns to allow transpiling such modules. You'll find a good example of this use case in React Native Guide.\r\n\r\nI've done a bit of research on this issue, and found that this is a common error and I have tried to apply several solutions I've found with no luck. So any help on this issue would be much appreciated!\r\n\r\n## Expected behavior\r\n\r\nThe `GreeterUI` component should be able to be imported in my test and not break when importing the Greeter package.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/Freddie-Pike\/freddies_testing_playground -> The repo that uses the greeter package, broken test located in js\/components\/GreeterUI\/tests\/GreeterUI.test.jsx.\r\nhttps:\/\/github.com\/Freddie-Pike\/greeter -> The repo that causes the test failure.\r\nGreeter example in the TypeScript docs: https:\/\/www.typescriptlang.org\/docs\/handbook\/classes.html\r\n\r\nGithub issues I found about this problem that unfortunately didn't help:\r\n\r\nhttps:\/\/github.com\/nrwl\/nx\/issues\/812\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/6053\r\n\r\n## envinfo\r\n\r\n```\r\nfreddiepike$ npx envinfo --preset jest\r\nnpx: installed 1 in 1.264s\r\n\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 13.11.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.4 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.8 - \/usr\/local\/bin\/npm\r\n```\r\n","comments":["Hmm, this issue has the \"Needs Repro\" label on it yet it has repos that reproduce this issue. Can anyone with permissions to remove that label do so for me?","should this:\r\n```\r\ntransformIgnorePatterns: [\"<rootDir>\/node_modules\/(?!${greeter})\"],\r\n```\r\nbe this?\r\n```\r\ntransformIgnorePatterns: [\"<rootDir>\/node_modules\/(?!(greeter)\/)\"],\r\n```","did it help?","Another gotcha where I just spent 2h is that the current version of Babel doesn't process files in `node_modules` if its configuration is defined in ` .babelrc`. Renaming to `babel.config.json` works. More information and rationale there => https:\/\/babeljs.io\/docs\/en\/config-files","I have jest configured in package.json\r\n\r\n> \"jest\": {\r\n    \"resetMocks\": false,\r\n    \"transform\": {\r\n      \"^.+\\\\.(js|jsx)$\": \"babel-jest\"\r\n    },\r\n    \"transformIgnorePatterns\": [\r\n      \"\/node_modules\/(?!(@shopify|d3-scale))\/\"\r\n    ],\r\n    \"coverageReporters\": [\r\n      [\r\n        \"lcov\",\r\n        {\r\n          \"projectRoot\": \"..\/..\/\"\r\n        }\r\n      ]\r\n    ]\r\n  },\r\n\r\nAnd I have configured babel.config.js\r\n\r\n> module.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel\/preset-env\",\r\n      {\r\n        targets: {\r\n          node: \"current\",\r\n        },\r\n      },\r\n    ],\r\n    \"@babel\/preset-react\",\r\n  ],\r\n};\r\n\r\nI am getting this error while running the tests -\r\n\r\n> node_modules\/d3-scale\/src\/index.js:1\r\n    ({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,global,jest){export {\r\n                                                                                             ^^^^^^\r\n\r\n    SyntaxError: Unexpected token 'export'\r\n\r\n      at Runtime.createScriptFromCode (..\/..\/node_modules\/jest-runtime\/build\/index.js:1350:14)\r\n      at Object.<anonymous> (..\/..\/node_modules\/@shopify\/polaris-viz-core\/build\/cjs\/utilities\/createGradient.js:5:15)\r\n\r\nIf i remove the import of package @shopify\/polaris-viz, the tests run successfully.\r\ncan somebody help me with this?","It looks like that your configuration uses `@Shopify` (capital letter `S`) while the package is in a directory `@shopify` (small letter `s`). Could that be your problem?"],"labels":["Needs Triage","Bug Report"]},{"title":"failing before hooks still cause tests to run","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nA before hook (either set by `beforeAll` or `beforeEach`) that fails (either by throwing or by rejecting) does not prevent a test from running.\r\n\r\n## To Reproduce\r\n\r\n1. Have a `beforeEach` hook always throw\r\n2. Have a test that always passes (and logs some output)\r\n3. Run tests\r\n\r\n## Expected behaviour\r\n\r\nThe test fails with `\"beforeEach hook failed\"` or something similar.\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\nhttps:\/\/repl.it\/talk\/share\/jest-before-hook\/119943\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (12) x64 Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 12.20.1 - ~\/.nvm\/versions\/node\/v12.20.1\/bin\/node\r\n    Yarn: 1.22.5 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.8 - ~\/repos\/lens\/node_modules\/.bin\/npm\r\n  npmPackages:\r\n    jest: ^26.0.1 => 26.0.1\r\n```\r\n\r\nThough the above repl is configured to be the latest version of jest and it still shows this problem.\r\n","comments":["Tests are not waiting for beforeAll hooks to complete. Jest started to run the test parallely.\r\n\r\n```\r\nasync function consoleIt(n, resolve) {\r\n  console.log('Logging', n);\r\n  resolve();\r\n}\r\n\r\nasync function initializeSuite() {\r\n  console.log('log0');\r\n  await new Promise((resolve) => setTimeout(consoleIt.bind(null, 1, resolve), 20));\r\n  console.log('log1');\r\n  await new Promise((resolve) => setTimeout(consoleIt.bind(null, 2, resolve), 10));\r\n  console.log('log2');\r\n  await new Promise((resolve) => setTimeout(consoleIt.bind(null, 3, resolve), 50));\r\n  console.log('log3');\r\n  await new Promise((resolve) => setTimeout(consoleIt.bind(null, 4, resolve), 30));\r\n  console.log('log4');\r\n}\r\n\r\nbeforeAll(initializeSuite, 500);\r\n\r\ndescribe('Sample test case describe', () => {\r\n  it('Sample test case', async () => {\r\n    console.log('******executed');\r\n  });\r\n});\r\n```\r\n\r\n\r\nExpected output is:\r\n ```\r\nLogging 1\r\n log1\r\n Logging 2\r\n log2\r\n Logging 3\r\n log3\r\n Logging 4\r\n log4\r\n ******executed\r\n```\r\n \r\n But its not executing all console statements. Especially when the timeout is 0, it works absolutely fine. Otherwise its not waiting for the beforeAll to finish its process. It executes the test case, but not printing the log within test case as well","So it seems more broken than I thought","@Nokel81 any workaround you have for the issue you are facing?","I have not found any, the tests seem to fail as well but they take longer to fail.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still very relavent ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue"],"labels":["Needs Triage","Bug Report"]},{"title":"Test case specific coverage reports","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nJest should support test case specific coverage reporting.\r\n\r\n<!-- A clear and concise description of what the feature is. -->\r\n\r\n## Motivation\r\n\r\nWhen taking code coverage test by test basis, it would enable writing a reporter that sorts failed tests based on the blast radius: If you have multiple failing tests, the one with smallest footprint\/least lines affected\/least functions called is likely the test you should focus on fixing since that's closest to the failing code. By fixing the simplest test case, you are more likely to fix other tests as well. Or at least make sure that other failed tests does not fail to same issue, which is also valuable.\r\n\r\nModern testing often tests many layers from very small units to full blown api tests. When you break something fundamental, you might have single unit test covering it, but also 15 api tests start failing because of the same functionality. In this case you should not focus on the API tests, but the one with smallest blast radius since it is likely to fix the rest of the tests.\r\n\r\nIf you focus on test that has larger blast radius, there's greater risk that this test covers multiple erroneous cases. Smaller test case has smaller risk for this. It would also give more value to write smaller tests since they would highlight failed code much better than larger tests.\r\n\r\n<!-- Please outline the motivation for the proposal. -->\r\n\r\n## Example\r\n\r\n<!-- Please provide an example for how this feature would be used. -->\r\nI have a whole POC written for this:\r\nhttps:\/\/github.com\/villesau\/test-fix-ordering-poc\r\n\r\nIn the above example the failed tests are sorted in a way that the smallest broken unit is always on top. As you see, every time you fix the smallest unit, also some other tests get fixed for free. That way you always find the fastest possible order to fis your tests. This saves you from a lot of hassle, especially with code bases you are not yet familiar with.\r\n\r\nYou can see my jest changes here (note, very hacky just to get the PoC working): [here](https:\/\/github.com\/villesau\/jest\/compare\/master...villesau:test-ordering#diff-ee383e699ee2a7fcff0e375e4b598b12ae4d5213cfcd67606da33957f878022aR197)\r\n\r\n## Pitch\r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nThis belongs to Jest since there is no way to write plugin for taking test case specific coverage reports. It would also provide much greater visibility over which failed test to focus on. In overall this would be a significant productivity boost. Test runner should be able to point out which failed test to focus on and this is the way to make it possible. This has potential to change the way we think about testing and testing pyramids.","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","still valid.","Oh, I like this idea! I don't think we should enable the inspector and collect coverage by default, but behind some config\/cli flag might make sense \ud83d\ude42 ","@SimenB if you are interested, see my PoC repos! :) I got it working back in the days, but I'm fairly sure there are better ways to achieve it, I just hacked it in the first place where I see it is possible. I also do not know how (test case specific) coverage reports would affect performance. Maybe the CLI could have option to \"sort by blast radius\" along with \"run failed only\" etc. which would enable coverage under the hood if it has considerable effect on performance? ","I think the bigger the codebase grows, the more value this kind of functionality could bring.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I still think this would be a good idea :+1: ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still thinking this is an awesome idea."],"labels":[":rocket: Feature Request"]},{"title":"Significant difference between behavior of development PC and CI","body":"## \ud83d\udc1b Bug Report\r\n\r\nHi.  I took the plunge and converted a set of 2500 tests from `ava` to `jest`.  I've been using `jest` exclusively on new projects for a couple years, but conversions are a bear, so I've been dragging my heels.\r\n\r\nI finally got around to it two days ago.  Yesterday, I finished.  There were two coverage defects - one line that's obviously being covered is marked not-covered, and some blank lines are marked not-covered - which is concerning.\r\n\r\nBut I figured whatever, I need to get out of `ava`, let's just go ahead.  Pushed it to Github.\r\n\r\nI hit a problem I've never seen before.  [Many of the test specs are behaving as if they're part of the same file.](https:\/\/github.com\/StoneCypher\/jssm\/pull\/416\/checks?check_run_id=1714133321#step:4:232)  \r\n\r\nIt's not actually clear to me how this is possible.\r\n\r\n```\r\n FAIL  src\/ts\/tests\/machine_attributes.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    src\/ts\/tests\/machine_attributes.spec.ts:2:7 - error TS2451: Cannot redeclare block-scoped variable 'jssm'.\r\n\r\n    2 const jssm = require('..\/jssm'),\r\n            ~~~~\r\n\r\n      src\/ts\/tests\/general.spec.ts:4:7\r\n        4 const jssm = require('..\/jssm');\r\n                ~~~~\r\n        'jssm' was also declared here.\r\n```\r\n\r\nIt appears to be saying that a declaration in one file is conflicting with an unrelated declaration in a different file.\r\n\r\nThe specs do not load one another (one tiny exception for `constants.spec`), and are not attached in any meaningful way.\r\n\r\nI cannot figure out why a const in one file is conflicting with a const in another file.\r\n\r\nWeirder yet?  ***It's not all of them***.  Almost every spec in this test suite has `const jssm = require('..\/jssm')` at the top, but only about half of them collide.  The pattern isn't clear.\r\n\r\nThese should, honestly, be `import`s; this is the result of my having done this half-awake, converting away from an `ava` test set that tested the post-compile, instead of the pre-compile.  And I'll be moving them to requires next, because these tests are gaining value from TS enforcement\r\n\r\nIn the meantime, though, ***my development machine and CI behave radically differently with the same test setup***, and that seems bizarre and unsafe.\r\n\r\nI will update this issue once I've moved everything to `import` instead of `require`.  However, this defies the language spec under `require`, so I think it's a bug even if doing things the normal way \"fixes\" it\r\n\r\n.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n* Check out the CI link above\r\n* If you like, check out the project and `npm run build`.  ***The defect is on the branch `MoveFromAvaToJest`, not main***\r\n\r\n.\r\n\r\n## Expected behavior\r\n\r\nI expect a test suite to pass with perfect coverage.\r\n\r\nOn my dev machine, a test suite passes with near-perfect coverage.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/77482\/104818833-ce464500-57de-11eb-88d4-eba583c8720d.png)\r\n\r\nThose coverage failures are incorrect, and I don't know what to make of them.\r\n\r\n[Line 795 is tested here](https:\/\/github.com\/StoneCypher\/jssm\/blob\/MoveFromAvaToJest\/src\/ts\/tests\/theme.spec.ts#L12)\r\n\r\n[Lines 928-944 include a lot of non-testable stuff](https:\/\/github.com\/StoneCypher\/jssm\/blob\/MoveFromAvaToJest\/src\/ts\/jssm.ts#L928-L944), and are fully tested ([1](https:\/\/github.com\/StoneCypher\/jssm\/blob\/MoveFromAvaToJest\/src\/ts\/tests\/general.spec.ts#L318), [2](https:\/\/github.com\/StoneCypher\/jssm\/blob\/MoveFromAvaToJest\/src\/ts\/tests\/general.spec.ts#L244))\r\n\r\n.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n[Repo](https:\/\/github.com\/StoneCypher\/jssm\/)\r\n\r\n[Continuous integration build showing build problem](https:\/\/github.com\/StoneCypher\/jssm\/pull\/416\/checks?check_run_id=1714133321#step:4:232) (look at this instead)\r\n\r\n.\r\n\r\n## envinfo\r\n\r\nWorks as expected at home, with minor coverage defects.  Win10 pro 64, node 14.4.0, nothing installed globally.  Typescript version comes from package (currently 4.1.3).\r\n\r\nFails miserably the same way under Github Actions on continuous integration.  Tested configurations include:\r\n* Ubuntu-current Node 15\r\n* Ubuntu-current Node 14\r\n* Ubuntu-current Node 10\r\n* Ubuntu-current Node 8\r\n* Windows-current Node 15\r\n\r\n```\r\njohn@DESKTOP-26H4050 MINGW64 ~\/projects\/jssm (MoveFromAvaToJest)\r\n$ npx envinfo --preset jest\r\nnpx: installed 1 in 2.435s\r\n\r\n  System:\r\n    OS: Windows 10 10.0.19041\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz\r\n  Binaries:\r\n    Node: 14.4.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.21.1 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.14.5 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^26.6.3 => 26.6.3\r\n```\r\n","comments":["It seems like moving them from `require` to `import` resolves whatever's going on\r\n\r\nIt's not clear to me how that's possible either tbh.  \r\n\r\nMoving is slow, because in switching from `ava` testing of js post-compiles to `jest` testing of ts, I'm finding a lot of sloppy type bugs I should've fixed years ago, lol","oh wow.  as i've been working on them, progressively, now one is firing on my dev machine. \r\n\r\nso this is probably a cache issue, or if not, a race condition.\r\n\r\ni have run `npx jest --no-cache -c relevant_config` with no impact\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/77482\/104827302-05354e80-5811-11eb-9b90-d4ff5fd234d4.png)\r\n","I don't know what to think now.  At first I thought it was a caching issue, where the error was being hidden by a faulty cache of old code and the CI was exposing it because there was never a cache.\r\n\r\nSo I performed the rain dance fix on `weighted_rand_select` by changing it from require to import.  Gone.  Okay, cool.\r\n\r\nFor fun, change it back.  ... nnnnnnnnnnnnnnnnnnnnnnnnnno problem, given the old faulting code.  In fact, it seems to be fine either way (as one might expect) now.\r\n\r\nExcept, it's broken in CI, where there's no prior cache?\r\n\r\nAnd the behavior seems well controlled, so I don't think it's a timing thing.","okay so, in retrospect i've learned the difference between red as total misses and yellow as branch misses, found the html reporter that lets me find then, and so on.\r\n\r\nthe difference between `require` and `import` causing name collisions across unrelated modules remains unclear to me however","> Except, it's broken in CI, where there's no prior cache?\r\n\r\nI've got a similar issue. Since GitHub [deletes](https:\/\/docs.github.com\/en\/actions\/using-workflows\/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy) all caching after 7 days, Jest will fail after 7 days of no CI runs because it can't handle no available cache when running in CI apparently\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump :\/"],"labels":["Needs Triage","Bug Report"]},{"title":"`beforeAll` and `afterAll` get executed if `test.todo` is present in `describe.skip`.","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nIf there is a describe block with a `beforeAll` and\/or `afterAll` and a `test.todo`, the `beforeAll` and\/or `afterAll` will get executed even if the `describe` is changed to `describe.skip`.\r\n\r\n## To Reproduce\r\n\r\n- Create a new project with `yarn init`.\r\n- Install `jest` with `yarn add -D jest`.\r\n- Create a `beforeAll.test.js` file in the root of the project.\r\n- Add this code in `beforeAll.test.js`:\r\n```js\r\ndescribe.skip( \"describe block\", () => {\r\n\r\n  beforeAll( async () => {\r\n    console.log( \"beforeAll()\" );\r\n  } );\r\n\r\n  afterAll( async () => {\r\n    console.log( \"afterAll()\" );\r\n  } );\r\n\r\n  beforeEach( async () => {\r\n    console.log( \"beforeEach()\" );\r\n  } );\r\n\r\n  afterEach( async () => {\r\n    console.log( \"afterEach()\" );\r\n  } );\r\n\r\n  test( \"logs a message to the console\", async () => {\r\n    console.log( \"It logs a message to the console.\" )\r\n  } );\r\n\r\n  test.todo( \"Future test\" );\r\n\r\n} );\r\n```\r\n\r\n- Run the test with `npx jest beforeAll.test.js`. You will see the `console.log` statements for the `beforeAll` and `afterAll`, but not for the `beforeEach` and `afterEach`.\r\n- Comment out the `test.todo` line and run `npx jest beforeAll.test.js`. You will not see any console.log statements.\r\n\r\n## Expected behavior\r\n\r\nHaving a `test.todo` should not cause the `beforeAll` and `afterAll` to run in a skipped `describe` block.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n[repl.it reproduction](https:\/\/repl.it\/@JarodLegault\/jest-playground#beforeAll.test.js)\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 15.2.1 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 7.0.10 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.6.3 => 26.6.3 \r\n```\r\n","comments":["+1 `todo`s should be skipped in `describe.skip` blocks. Otherwise, we are commenting out these `todo` specs and we're losing the value of using the `todo` in the first place as a placeholder for specs to be written.","I have observed that `beforeAll` and `afterAll` are also executed even when all tests in the `describe` block would be skipped for other reasons, such as a `.only` in another nested `describe`.\r\n\r\n```ts\r\ndescribe(\"outter\", () => {\r\n  describe(\"inner1\", () => {\r\n    beforeAll(async () => {\r\n      console.log(\"should not execute, but does\");\r\n    });\r\n    it(\"is skipped\", async () => {\r\n      console.log(\"is not executed, as expected\");\r\n    });\r\n  });\r\n  describe(\"inner2\", () => {\r\n    it.only(\"the only test\", async () => {\r\n      console.log(\"is executed, as expected\");\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nIs it correct to expect some suit analysis such that `before\/afterAll` are only executed if, and only if, there are tests to be run. Currently they act as special test cases where there is control over order of execution, one being first, the other being last. But not partake in the `.only` or `.skip` mechanism. And have no relation to what they are to be run before or after.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Happy to take a PR \ud83d\udc4d","Hey @jarod-legault, it this still an issue?\r\n\r\nBecause, I tried to run locally the same test scenario you shared and the `beforeAll()` and `afterAll()` logs didn't show up.","Hasn't it been fixed in https:\/\/github.com\/jestjs\/jest\/pull\/10806 already?"],"labels":[":bug: Bug","Help Wanted"]},{"title":"feat(circus): expose expect.deadline()","body":"## Summary\r\n\r\nExpose the test's timeout back to the the test, so it can make decisions based on this, if it wants.\r\n\r\nSome proposed uses are included in #10895, but the implementation, in #10905, has got rather big.\r\n\r\nNone of the rest absolutely have to be core. This part does. This is a subset of the above PR, and is compatible.\r\n\r\n## Test plan\r\n\r\nThere's an included e2e test which checks a vaguely plausible value is being computed. You can, as a user, implement `expect.withinDeadline` and use that, in your project.\r\n\r\nThe above PR has done very poorly trying to actually get CI to have repeatable timings, for actually triggering behaviour based on short timeouts, so I have not done that.\r\n\r\n## Alternatives\r\n\r\nElsewhere it was proposed that:\r\n\r\n```\r\n  await dispatch({name: 'test_fn_start', test});\r\n  const timeout = test.timeout || getState().testTimeout;\r\n```\r\n...could be changed to:\r\n```\r\n  test.timeout = test.timeout || getState().testTimeout;\r\n  await dispatch({name: 'test_fn_start', test});\r\n```\r\n\r\n...and then an Environment could perform the rest of the work. I think I prefer it being Circus state, as timeouts are a Circus concern, not an environment concern.","comments":["> ## Alternatives\r\n> Elsewhere it was proposed that:\r\n> \r\n> ```\r\n>   await dispatch({name: 'test_fn_start', test});\r\n>   const timeout = test.timeout || getState().testTimeout;\r\n> ```\r\n> \r\n> ...could be changed to:\r\n> \r\n> ```\r\n>   test.timeout = test.timeout || || getState().testTimeout;\r\n>   await dispatch({name: 'test_fn_start', test});\r\n> ```\r\n> \r\n> ...and then an Environment could perform the rest of the work. I think I prefer it being Circus state, as timeouts are a Circus concern, not an environment concern.\r\n\r\nI still think we should do this. Not because it would enable the environment to do anything, but because the test \"instance\" should have the real timeout of the test in the state.\r\n\r\n\/cc @jeysal any drawback to that you can think of?","> Elsewhere it was proposed that:\r\n> \r\n> ```\r\n>   await dispatch({name: 'test_fn_start', test});\r\n>   const timeout = test.timeout || getState().testTimeout;\r\n> ```\r\n> \r\n> ...could be changed to:\r\n> \r\n> ```\r\n>   test.timeout = test.timeout || getState().testTimeout;\r\n>   await dispatch({name: 'test_fn_start', test});\r\n> ```\r\n> \r\n> ...and then an Environment could perform the rest of the work. I think I prefer it being Circus state, as timeouts are a Circus concern, not an environment concern.\r\n\r\nI agree environments should not need to play a role in this. For the actual code options here, not sure I have a strong opinion on 1 vs 2. Based on my understanding I see the advantages as:\r\nAdvantage of 1: A test object still lets you figure out whether that test has a timeout set for it specifically because only then it has a value (doesn't seem like a very useful thing to do though).\r\nAdvantage of 2: A test object lets you immediately figure out the *effective* timeout for it. Otherwise you'd have to read it from the `expect` instance.\r\nI lean towards 2, so Simen's option. The advantage of 1 seems useless in practice. Not having the advantage of 2 seems to make it cumbersome if you need to calculate the effective timeout.","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I'd still like this to be merged, bot, but I am not going to rebase the PR at this time, unless there's further discussion on where it should go.","Main issue with adding this sort of API is that it won't work when tests are running concurrently (`test.concurrent`). Of course, the same is the case for snapshots etc. - anything that needs to know what test is currently running will run into issues here.\r\n\r\nThat said, we're not really close to figuring out how to have scoped `expect` (and other things bound to a single test), so it probably shouldn't block this effort.\r\n\r\n---\r\n\r\nWould it make sense for a first go to add it to `this` in tests? Of course, then arrow functions are out the door, so not as useful as it could be. But it would avoid the global issue."],"labels":["cla signed","Pinned"]},{"title":"Jest projects do not inherit root\/global config","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nThis isn't mentioned anywhere in the docs, so I'm not entirely sure how this is supposed to work. But I have a monorepo (yarn workspaces) and I want some packages to have expanded Jest configs, while all of them to inherit \"common\" configs. I assumed that any settings in the root `jest.config.js` would be inherited for all project configs, but this does not seem to be the case, and is honestly very tedious to work around.\r\n\r\nIf I have this root config:\r\n\r\n```ts\r\nmodule.exports = {\r\n  projects: ['packages\/*'],\r\n  setupFilesAfterEnv: ['<rootDir>\/tests\/setup.ts'],\r\n};\r\n```\r\n\r\nI would expect all projects to inherit the `setupFilesAfterEnv` setting, but they do not. According to `--showConfig`, it's just an empty array. How else are we supposed to share config _without having to create a `jest.config.js` in each project_?\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nMentioned above.\r\n\r\n## Expected behavior\r\n\r\nProjects would inherit the root\/global config.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\nnpx envinfo --preset jest\r\n\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 12.18.3 - ~\/.nvm\/versions\/node\/v12.18.3\/bin\/node\r\n    Yarn: 1.22.10 - ~\/.nvm\/versions\/node\/v12.18.3\/bin\/yarn\r\n    npm: 6.14.6 - ~\/.nvm\/versions\/node\/v12.18.3\/bin\/npm\r\n```\r\n","comments":["[Here's a link](https:\/\/github.com\/Rossh87\/jest_issue_10991_repro) to a repo that verifies the behavior you're describing.  However, this is almost definitely working as intended.  If you'd like to share a partial configuration between projects, I believe [this](https:\/\/stackoverflow.com\/questions\/40726702\/is-there-anyway-to-extend-a-jest-configuration-file) is the preferred approach.  \r\n\r\nThat said, it wouldn't be overly complicated to search for a base config in the worktree root and merge it with each project config.  Maybe there's interest in having a flag for this behavior?","@Rossh87 seems strange that this is working as intended. I have a file that adds custom expect assertions that all projects are using. This means I have to copy over `setupFilesAfterEnv` into each project. Sure it is easy enough to spread it out when using `jest.config.js` however using `package.json` can lead to typos and make it annoying to change. There has to be some easier way to set this up\r\n\r\n\r\n","The way I have it in my monorepos is using [`preset`](https:\/\/jestjs.io\/docs\/configuration#preset-string) to point to a `jest.preset.js` in the root of the repo. Check out [this example](https:\/\/github.com\/nrwl\/nx-examples\/blob\/master\/libs\/products\/home-page\/jest.config.js) from Nx to see it in practise.","@manchuck I probably shouldn't have tried to speak to the authors' intentions, since I'm not a maintainer.  What I mean is just that I can imagine root config-sharing by default leading to confusion or slowing down tests a *lot* for monorepos whose projects have very different external dependencies (databases, servers, etc.) that need to be setup for tests.  For example, if I have a client module and a server module in a monorepo that represents all the code for some website, I might want to spin up a real database for integration testing the server, but probably won't need it for testing the client.  If the database setup ended up in the root config, I'd be needlessly spinning up a database every time I ran the client test suite, which isn't ideal.  Conceptually, my impression is that workspaces are intended to be autonomous, and sharing setup creates implicit dependency, which isn't ideal IMO.  I do see your point, though, and it's perfectly reasonable to disagree.\r\n\r\nDepending on your specific case, you could try extracting your custom assertion library into its own workspace, turning it into a discrete package that your other workspaces can _explicitly_ depend on by importing it.  That's what I would personally prefer for a custom assertion library, but YMMV.","Here is an example of my Jest config for two cases: unit tests and integration tests. Unfortunately it is not possible to share repeated configuration in top level as it just does not work. It would help a lot if properties from top level would be augmented to `projects` with simple `Object.assign`.\r\n\r\n```\r\nconst DO_NOT_CHANGE = 100;\r\n\r\nmodule.exports = {\r\n  collectCoverage: true,\r\n  coverageReporters: [\r\n    ['text', { skipFull: true }],\r\n    'text-summary',\r\n  ],\r\n  projects: [\r\n    {\r\n      cacheDirectory: '<rootDir>\/.jestcache',\r\n      collectCoverageFrom: [\r\n        'packages\/*\/src\/**\/*.ts?(x)',\r\n      ],\r\n      coveragePathIgnorePatterns: [\r\n        '\/__template__\/',\r\n        '\/lib\/',\r\n        '\/node_modules\/',\r\n      ],\r\n      coverageThreshold: {\r\n        global: {\r\n          statements: DO_NOT_CHANGE,\r\n          branches: DO_NOT_CHANGE,\r\n          functions: DO_NOT_CHANGE,\r\n          lines: DO_NOT_CHANGE,\r\n        },\r\n      },\r\n      displayName: 'unit',\r\n      errorOnDeprecated: true,\r\n      globals: {\r\n        'ts-jest': {\r\n          tsconfig: '<rootDir>\/tsconfig.common.json',\r\n        },\r\n      },\r\n      moduleNameMapper: {\r\n        '\\\\.css$': 'identity-obj-proxy',\r\n        '^!svg-url-loader!(.*)$': '$1',\r\n        '^!url-loader!(.*)$': '$1',\r\n      },\r\n      preset: 'ts-jest',\r\n      resetMocks: true,\r\n      setupFiles: [\r\n        '<rootDir>\/__tests__\/setupTestEnvironment.ts',\r\n      ],\r\n      setupFilesAfterEnv: [\r\n        '<rootDir>\/__tests__\/setupTests.ts',\r\n      ],\r\n      snapshotSerializers: [\r\n        'enzyme-to-json\/serializer',\r\n      ],\r\n      testMatch: [\r\n        '**\/src\/**\/*.spec.ts?(x)',\r\n      ],\r\n      transform: {\r\n        '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': '<rootDir>\/__mocks__\/fileTransformer.js',\r\n      },\r\n    },\r\n    {\r\n      cacheDirectory: '<rootDir>\/.jestcache',\r\n      collectCoverageFrom: [\r\n        'packages\/*\/src\/?(*\/)?(*\/)*.ts?(x)', \/\/ Report only 2 levels deep.\r\n        '!**\/*.spec.ts?(x)',\r\n      ],\r\n      coveragePathIgnorePatterns: [\r\n        '\/__template__\/',\r\n        '\/lib\/',\r\n        '\/node_modules\/',\r\n      ],\r\n      coverageThreshold: {\r\n        global: {\r\n          statements: DO_NOT_CHANGE,\r\n          branches: DO_NOT_CHANGE,\r\n          functions: DO_NOT_CHANGE,\r\n          lines: DO_NOT_CHANGE,\r\n        },\r\n      },\r\n      displayName: 'integration',\r\n      errorOnDeprecated: true,\r\n      globals: {\r\n        'ts-jest': {\r\n          tsconfig: '<rootDir>\/tsconfig.common.json',\r\n        },\r\n      },\r\n      moduleNameMapper: {\r\n        '\\\\.css$': 'identity-obj-proxy',\r\n        '^!svg-url-loader!(.+)$': '$1',\r\n        '^!url-loader!(.*)$': '$1',\r\n      },\r\n      preset: 'ts-jest',\r\n      resetMocks: true,\r\n      setupFiles: [\r\n        '<rootDir>\/__tests__\/setupTestEnvironment.ts',\r\n      ],\r\n      setupFilesAfterEnv: [\r\n        '<rootDir>\/__tests__\/setupTests.ts',\r\n      ],\r\n      snapshotSerializers: [\r\n        'enzyme-to-json\/serializer',\r\n      ],\r\n      testMatch: [\r\n        '**\/__tests__\/**\/*.test.ts?(x)',\r\n      ],\r\n      transform: {\r\n        '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': '<rootDir>\/__mocks__\/fileTransformer.js',\r\n      },\r\n    },\r\n  ],\r\n};\r\n```","@igorpupkinable Would you mind to elaborate on how exactly it does not work when sharing common properties using `Object.assign` ?\r\n\r\n```javascript\r\nconst DO_NOT_CHANGE = 100;\r\n\r\nconst common = {\r\n  cacheDirectory: '<rootDir>\/.jestcache',\r\n  coveragePathIgnorePatterns: [\r\n    '\/__template__\/',\r\n    '\/lib\/',\r\n    '\/node_modules\/',\r\n  ],\r\n  coverageThreshold: {\r\n    global: {\r\n      statements: DO_NOT_CHANGE,\r\n      branches: DO_NOT_CHANGE,\r\n      functions: DO_NOT_CHANGE,\r\n      lines: DO_NOT_CHANGE,\r\n    },\r\n  },\r\n  errorOnDeprecated: true,\r\n  globals: {\r\n    'ts-jest': {\r\n      tsconfig: '<rootDir>\/tsconfig.common.json',\r\n    },\r\n  },\r\n  moduleNameMapper: {\r\n    '\\\\.css$': 'identity-obj-proxy',\r\n    '^!svg-url-loader!(.*)$': '$1',\r\n    '^!url-loader!(.*)$': '$1',\r\n  },\r\n  preset: 'ts-jest',\r\n  resetMocks: true,\r\n  setupFiles: [\r\n    '<rootDir>\/__tests__\/setupTestEnvironment.ts',\r\n  ],\r\n  setupFilesAfterEnv: [\r\n    '<rootDir>\/__tests__\/setupTests.ts',\r\n  ],\r\n  snapshotSerializers: [\r\n    'enzyme-to-json\/serializer',\r\n  ],\r\n  transform: {\r\n    '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': '<rootDir>\/__mocks__\/fileTransformer.js',\r\n  },\r\n};\r\n\r\nmodule.exports = {\r\n  collectCoverage: true,\r\n  coverageReporters: [\r\n    ['text', { skipFull: true }],\r\n    'text-summary',\r\n  ],\r\n  projects: [\r\n    Object.assign({}, common, {\r\n      displayName: 'unit',\r\n      collectCoverageFrom: [\r\n        'packages\/*\/src\/**\/*.ts?(x)',\r\n      ],\r\n      testMatch: [\r\n        '**\/src\/**\/*.spec.ts?(x)',\r\n      ],\r\n    }),\r\n    Object.assign({}, common, {\r\n      displayName: 'integration',\r\n      collectCoverageFrom: [\r\n        'packages\/*\/src\/?(*\/)?(*\/)*.ts?(x)', \/\/ Report only 2 levels deep.\r\n        '!**\/*.spec.ts?(x)',\r\n      ],\r\n      testMatch: [\r\n        '**\/__tests__\/**\/*.test.ts?(x)',\r\n      ],\r\n    }),\r\n  ],\r\n};\r\n``` ","@hesalx you do augmentation manually in your example. I meant it should be done by Jest under the hood, e.g.\r\n```\r\nprojects.forEach((project) => {\r\n  Object.assign(project, { ..config, projects: undefined });\r\n});\r\n```","It means root level jest config into a monorepo should only contain \"projects\" key? I assumed the same thought of @milesj in the beginning :\/\r\n\r\nA bit tricky in my opinion... as @manchuck said, it forces us to duplicate files with setup config.\r\n\r\nAn example: I'm using [msw](https:\/\/mswjs.io\/) and I need to setup msw server using `setupFilesAfterEnv`. But, in order to do it, I need to setup my env file before using [dotenv](https:\/\/github.com\/motdotla\/dotenv) into `setupFiles`, so my server will be able to read my `BASE_URL`.\r\n\r\nIn this case I need to duplicate my setup files into every project\/package of my monorepo.","@gsevla I wound up just having the custom expectations in a file and mapping over all the projects ni the config, then appending the expectations. Hopefully that can help you keep the config DRY","The documentation seems to indicate the root configuration _should_ be copied to each project.\r\n\r\nhttps:\/\/jestjs.io\/docs\/configuration#projects-arraystring--projectconfig\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/117312398\/215534060-6445f00c-332b-4edd-aa85-224f0d4509d2.png)\r\n\r\n\r\n","Based on how it works in practice, I suppose the confusion comes from the usage of the term \"root-level\".\r\nHere \"root-level configuration\" means \"the configuration file in the project's root\" and not \"the root of the exported object in the configuration file\".\r\nThis NOTE primarily clarifies the resolution of the template variables and not the inheritance of configurations per se.\r\nIn other words,\r\n_With the `projects` option enabled, Jest will copy **each individual item of the projects option** of the root-level configuration to **respective child configuration** during the test run, however the values will be resolved in the child's context, i.e. `<rootDir>` will point to the child's root directory and not to the root-level configuration directory._","Perhaps clarity can be found in the discussion from the PR which added this note: https:\/\/github.com\/facebook\/jest\/pull\/12871. ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump"],"labels":["Needs Triage","Bug Report"]},{"title":"feat(runtime): add jest.mockModule","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nA start on #10025. Lots of stuff missing\r\n\r\n- [ ] Manual mocks (i.e. mocks from `__mocks__` directories)\r\n- [ ] Docs\r\n- [ ] mocks without factories - not sure how to load them and determine types etc.\r\n- [ ] behavior when calling `mock` and `doMock` on an ES Module, and `mockImport` on CJS. I think it should throw?\r\n- [ ] `jest.importActual`\r\n- [ ] handle concurrent imports of mocks. Right now there's a race condition since it doesn't populate the cache immediately upon creating a mock. Need some sort of mutex\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nI'll add more tests as we go\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["@SimenB as you said in https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-750349327 this is needed to implement the `exports` feature: do you know of any workaround meanwhile? ","> @SimenB as you said in [#9430 (comment)](https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-750349327) this is needed to implement the `exports` feature: do you know of any workaround meanwhile?\r\n\r\nThis is not related to `exports`, what I meant is that that is the final missing piece. Not dependent on the feature in this PR. You can track `exports` support in #9771","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=h1) Report\n> Merging [#10976](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=desc) (eac6673) into [master](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/a03b6fe40764564ef62c82c33ddcfe64de6721e4?el=desc) (a03b6fe) will **decrease** coverage by `0.10%`.\n> The diff coverage is `30.23%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master   #10976      +\/-   ##\n==========================================\n- Coverage   64.28%   64.17%   -0.11%     \n==========================================\n  Files         308      308              \n  Lines       13480    13512      +32     \n  Branches     3286     3291       +5     \n==========================================\n+ Hits         8665     8671       +6     \n- Misses       4106     4134      +28     \n+ Partials      709      707       -2     \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=tree) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/jest-resolve\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976\/diff?src=pr&el=tree#diff-cGFja2FnZXMvamVzdC1yZXNvbHZlL3NyYy9pbmRleC50cw==) | `45.96% <0.00%> (\u00f8)` | |\n| [packages\/jest-runtime\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976\/diff?src=pr&el=tree#diff-cGFja2FnZXMvamVzdC1ydW50aW1lL3NyYy9pbmRleC50cw==) | `53.15% <30.95%> (-1.70%)` | :arrow_down: |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=footer). Last update [a03b6fe...eac6673](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=lastupdated). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments).\n","what's the state of this?","I currently don't have the motivation to work on this feature, so it's in hiatus until I get back to it. Others are of course free to pick it up (missing stuff is mostly laid out in the OP from what I remember) \ud83d\ude42 I can rebase this, tho","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) Report\n> Merging [#10976](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (9af07a9) into [master](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/90d6908492d164392ce8429923e7f0fa17946d2d?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (90d6908) will **decrease** coverage by `0.01%`.\n> The diff coverage is `14.28%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n\n```diff\n@@            Coverage Diff             @@\n##           master   #10976      +\/-   ##\n==========================================\n- Coverage   68.93%   68.92%   -0.02%     \n==========================================\n  Files         312      312              \n  Lines       16398    16401       +3     \n  Branches     4749     4750       +1     \n==========================================\n  Hits        11304    11304              \n- Misses       5067     5070       +3     \n  Partials       27       27              \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/jest-runtime\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1ydW50aW1lL3NyYy9pbmRleC50cw==) | `57.12% <14.28%> (-0.21%)` | :arrow_down: |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Last update [90d6908...9af07a9](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10976?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n","@SimenB, is there a natural point to split up this PR \/ what remains? For example, if `__mocks__` or `jest.importActual` is a significant amount of work, would it be preferable for a contributor to work on the rest first and land those things in a follow up PR?\r\n\r\nI can take a look at helping with some of this tomorrow. A rebase, if it'd be quick for you, would be appreciated (assuming there might be conflicts to be resolved that I wouldn't have the context for).","@connorjclark awesome if you wanna pick this up! I just rebased it. Not sure where the best point to pick something up would be. I assume e.g. `jest.importActual` should be fairly self-contained and not too advanced, so should be a nice place to start \ud83d\ude42 ","Some of the items from above look required to merge this, but I wonder if some might be able to be moved to follow-ups? E.g. this could provide a lot of value without manual mocks support","Sure, pretty much every point could be moved to a follow-up except possibly docs... Although one could argue docs can wait until the feature is more stabilized. I could add this as `jest.unstable_mockModule` or something for now to be safe, and remove the prefix when it's feature complete (and then the `unstable` function in the next major)","Checking it in as `jest.unstable_mockModule` would be awesome and very much appreciated!","@benmccann landed that now, will release tonight or tomorrow (cest)","Out in https:\/\/github.com\/facebook\/jest\/releases\/tag\/v27.1.1","Thank you so much!","@SimenB time to update https:\/\/jestjs.io\/docs\/ecmascript-modules , it still says \"Please note that we currently don't support jest.mock in a clean way in ESM, but that is something we intend to add proper support for in the future. Follow this issue for updates.\"","@n0mer if you're up for a quick PR adding a small note that'd be awesome \ud83d\udc4d  Can link to https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-915109139 or something for the caveats","Are there any plans to continue this work in the near term? @SimenB ","All work on ESM  is paused until most issues linked in https:\/\/github.com\/nodejs\/node\/issues\/37648 are solved.\n\n(I got a message from a developer at Google last week about movement, so hopefully that'll actually move along very soon)","That said, happy to take PRs of course. But any personal effort is on pause until node's APIs are closer to stabilization.","The downside to ```jest.unstable_mockModule()``` right now is that it mocks the entire module.  This is maybe not a downside if that's what you're looking for.  It's really falling down for me right now though, because I only want to mock a few functions from the module.  This really needs a ```jest.importActual()``` to fill in that missing gap.  Trying to use ```jest.requireActual()``` on an ESM of course returns a 'Must use import to load ES Module' error, which one would expect to happen.  I'm getting to the point where even I might take a crack at implementing that functionality, but \r\n\r\na) For the past 26 years I've written in pure javascript for use in a browser environment (hence why I'm using ESM)\r\nb) Am not super familiar with TypeScript outside of Haxe because I've always been able to do what I need to in pure JavaScript (And transpiling\/bundling feels dirty since it's supposed to be a runtime script)\r\nc) Am not super familiar with Node outside of using npm to pull down libraries, as the server side has always been Perl\/PHP\/C#\/Python up until the last few years.  Of course this all means that using Jest has been a ~~struggle~~ learning opportunity.\r\n\r\nAt the very least it looks like the ```requireActual()``` implementation is happening in node_modules\/jest-runtime\/build\/index.js, and that it is basically just calling ```requireModule()``` with a flag flipped to true.  The flag being flipped to true seems to only really effect if ```modulePath = manualMock``` or not, which then effects if you receive the mocked module or the actual module through ~~black magic~~ Node CJS ~~shennanigans~~ transforms.\r\n\r\nFrom this I would guess that within the same file, the ```unstable_importModule()``` function (or further down the line ```loadEsmModule()``` function) could be extended to accept the same sort of flag solution.  However, once we get there, there is even more Pure ES Standards Javascript to CJS\/Babel transform voodoo to decipher.  When I get to this point it starts bringing on too many Bad Memories of the JavaScript vs. JScript days and I get triggered and have to leave the room and have a lie down.\r\n\r\nI guess if anybody was to take a crack at ```jest.importActual``` that's the place to do it (or wherever jest-runtime\/build\/index.js is actually transpiled down from).  Unfortunately, it's probably not going to be me, because ironically I find pure JavaScript easy (again, 26 years of practice), but find the modern workflow bloated and overly complicated. However, I hope somebody who understands the newer way of doing things finds the research helpful, or like Simen says, we wait for Node to support the standards and it doesn't take another few years.","> The downside to `jest.unstable_mockModule()` right now is that it mocks the entire module. This is maybe not a downside if that's what you're looking for. It's really falling down for me right now though, because I only want to mock a few functions from the module. This really needs a `jest.importActual()` to fill in that missing gap. Trying to use `jest.requireActual()` on an ESM of course returns a 'Must use import to load ES Module' error, which one would expect to happen. I'm getting to the point where even I might take a crack at implementing that functionality, but\r\n> \r\n> a) For the past 26 years I've written in pure javascript for use in a browser environment (hence why I'm using ESM) b) Am not super familiar with TypeScript outside of Haxe because I've always been able to do what I need to in pure JavaScript (And transpiling\/bundling feels dirty since it's supposed to be a runtime script) c) Am not super familiar with Node outside of using npm to pull down libraries, as the server side has always been Perl\/PHP\/C#\/Python up until the last few years. Of course this all means that using Jest has been a ~struggle~ learning opportunity.\r\n> \r\n> At the very least it looks like the `requireActual()` implementation is happening in node_modules\/jest-runtime\/build\/index.js, and that it is basically just calling `requireModule()` with a flag flipped to true. The flag being flipped to true seems to only really effect if `modulePath = manualMock` or not, which then effects if you receive the mocked module or the actual module through ~black magic~ Node CJS ~shennanigans~ transforms.\r\n> \r\n> From this I would guess that within the same file, the `unstable_importModule()` function (or further down the line `loadEsmModule()` function) could be extended to accept the same sort of flag solution. However, once we get there, there is even more Pure ES Standards Javascript to CJS\/Babel transform voodoo to decipher. When I get to this point it starts bringing on too many Bad Memories of the JavaScript vs. JScript days and I get triggered and have to leave the room and have a lie down.\r\n> \r\n> I guess if anybody was to take a crack at `jest.importActual` that's the place to do it (or wherever jest-runtime\/build\/index.js is actually transpiled down from). Unfortunately, it's probably not going to be me, because ironically I find pure JavaScript easy (again, 26 years of practice), but find the modern workflow bloated and overly complicated. However, I hope somebody who understands the newer way of doing things finds the research helpful, or like Simen says, we wait for Node to support the standards and it doesn't take another few years.\r\n\r\nI appreciate all the work done on Jest but I'm switching to [vitest](https:\/\/vitest.dev\/) for first-class typescript and ESM support, including support for hoisted ESM mocks and importActual support","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Pinned"]},{"title":"Ability to add coverageReporter by tools","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nIt'd be great to have possibility to add a coverage reporter to coverage reporters configured in Jest configs without changing the configs.\r\n\r\n## Motivation\r\n\r\nIntelliJ Jest integration can visualize coverage collected by Jest. It needs `lcov.info` generated for that. The problem is that `lcov.info` might be not configured in user's jest config. Passing `--coverageReporters=lcov` solves this issue partially, because it overwrites all user's configured reporters, unfortunately. IntelliJ needs to preserve coverage reporters configured by user. So, it'd be great to have a way to add `lcov` coverage reporter somehow without modifying Jest config files.\r\n\r\nIntelliJ runs Jest tests with its own reporter. Is it OK to add a custom coverage reporter via Jest API? If yes, it will work too.\r\n\r\nBTW, seems `--coverageReporters` is an unofficial CLI option, but it works. Could you please clarify that?\r\n\r\nI'm a maintainer of IntellJ Jest integration, feel free to ask me any questions regarding it.\r\n\r\n## Example\r\n\r\nA hypothetical CLI-based solution could be like this: `--coverageReporters=+lcov`\r\n\r\n<!-- Please provide an example for how this feature would be used. -->\r\n\r\n## Pitch\r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nThis issue relates to coverage and\/or to processing of CLI option. Probably it belongs to Jest code platform, but I'm not fully sure.","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Not stale!","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","We should do this - enabling better IDE integration is important to me (especially as an IntelliJ user myself \ud83d\ude00).\r\n\r\n> Passing `--coverageReporters=lcov` solves this issue partially, because it overwrites all user's configured reporters, unfortunately\r\n\r\nIs that an issue? Running tests from within your IDE I'd assume you'd not be interested in other reporters?\r\n\r\n> BTW, seems `--coverageReporters` is an unofficial CLI option, but it works. Could you please clarify that?\r\n\r\nWe've just forgotten to document it probably"],"labels":[":rocket: Feature Request","Pinned"]},{"title":"Less ambiguous jest.mock","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nThe proposal is to allow to specify that `jest.mock('my-module')` should use `__mocks__` or not.\r\n\r\n## Motivation\r\n\r\n`jest.mock` is too magical, it's nearly always known if it's automocking or `__mocks__` that is expected in a test. Silently switching between auto and manual mock in `jest.mock('my-module')` results in a undetermined behaviour that may not be evident and needs to be debugged.\r\n\r\nA notable example is facebook\/create-react-app#7539\r\n\r\n## Example\r\n\r\nUses manual mock if it exists, throws an error that contains full path to expected  `__mocks__\/my-module.js` otherwise:\r\n\r\n```js\r\nimport myModule from 'my-module';\r\njest.mock('my-module', { manual: true })\r\n```\r\nIgnores `__mocks__\/my-module.js` and does automocking:\r\n```js\r\nimport myModule from 'my-module';\r\njest.mock('my-module', { manual: false })\r\n```\r\n\r\n## Pitch\r\n\r\nModule mocking is core Jest feature and needs to be practical out of the box.","comments":["I second this. I have just spent an hour trying to debug why a manual mock isn't being used and this would be immensely useful.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","The issue is still relevant.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","The issue is still relevant."],"labels":[":rocket: Feature Request"]},{"title":"Support maxWorkers or runInBand when using 'projects'","body":"## \ud83d\udc1b Bug Report\r\n\r\nWhen defining multiple projects via the `projects` config option, where one project has `maxWorkers` set (ie. 1), that setting is not respected.\r\n\r\nIn the case of a mono-repo, assume we have two projects. One which runs parallel, and another which needs to be run sequentially. For this, the latter has the config setting `maxWorkers: 1`.\r\n\r\nWhen we run jest from the base config, however, the latter runs in parallel, ignoring the `maxWorkers: 1` setting.\r\n\r\n## To Reproduce\r\n\r\n1. Setup a mono-repo with two jest config files\r\n2. Set one to `maxWorkers: 1`\r\n3. Add both config paths to base `projects` property\r\n4. Run jest\r\n\r\n## Expected behavior \/ Proposal\r\n\r\nI propose the following:\r\n1. Determine global max workers as:\r\n   - (If present) `maxWorkers` setting in base config \r\n   - (Otherwise) Determine the _maximum value_ specified for `maxWorkers` found in all projects config files\r\n2. Allow each project to use\r\n   - (If present) Its own `maxWorkers` # of workers\r\n   - (Otherwise) The global maximum # of workers\r\n\r\nEffectively, this ensures that `maxWorkers` behaviour matches that of running jest on an individual project.\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: Windows 10 10.0.19041\r\n    CPU: (4) x64 Intel(R) Core(TM) i7-4510U CPU @ 2.00GHz\r\n  Binaries:\r\n    Node: 14.13.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.4 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.14.4 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^26.5.3 => 26.6.2\r\n```","comments":["Can you put up a minimal repro that could be downloaded? ","`maxWorkers` is currently a part of GlobalConfig so this is expected. I'm not sure if Jest should allow projects to limit the number of workers, as this may quickly go out of hand, causing inconsistencies between execution environments. The only scenario I see this could be helpful is limiting to 1 worker, in other words allowing `runInBand` to be configurable in a project. E.g. for E2E tests running on a device\/simulator where parallelization doesn't make sense (unless having multiple devices).\r\n\r\n@SimenB @jeysal thoughts?","> The only scenario I see this could be helpful is limiting to 1 worker, in other words allowing `runInBand` to be configurable in a project.\r\n\r\nThat's a good point. I can think of one other use case, but I think there may be a better proposal to cover that (detail to follow).\r\n\r\nI can see it being useful to allocate a smaller fraction of the overall worker threads in some instances. \r\n\r\nSay we have that scenario in a very large mono-repo with multiple projects. Several config files contain very long-running tests, and those particular tests hit first. In this scenario, we might want to limit the total threads for the longer running config file so that we can run our faster tests in parallel along-side of them. This way it can fail more quickly if there are problems in the shorter running tests and avoid having to run separate calls to jest to accomplish this.\r\n\r\nIt's maybe not a perfect example, but it should give an idea.\r\n\r\nIn that scenario, we could specify a max of 3 threads to the long running out of the global 8.\r\n\r\n_However..._\r\n\r\n## Amended Proposal \r\n\r\nI think you're right about `runInBand`. All things considered, I'd amend my proposal to the following:\r\n\r\n1. `maxWorkers` remains a global setting, allowing you to define max threads for the entire process\r\n2. Introduce: `runInBand` on the project-level (This would make several folks happy #6709 #3215)\r\n3. Introduce: `minWorkers` on the project-level\r\n\r\n### minWorkers\r\n\r\nAllows configuring the minimum number of threads to be used for a particular project. (This setting would only have effect when run in projects mode)\r\n\r\nThis would allow giving specific projects the ability to use more of the allotted threads while allowing elasticity when threads are free. \r\n\r\nSo in our example above, we could configure `minWorkers: 5` for our faster tests and set a global `maxWorkers: 8` \r\n\r\nThis would effectively give us a 3 \/ 5 distribution unless the faster tests finish first, in which case the longer tests will fill up the remaining slots.","> Can you put up a minimal repro that could be downloaded?\r\n\r\n@thymikee Did you still need this?","> @thymikee Did you still need this?\r\n\r\nNah, we're good","This would be amazing!! \r\n\r\nOur use case is fullstack testing for [Blitz apps](https:\/\/github.com\/blitz-js\/blitz). We want client code tests to run in parallel but run server tests in series because they use the same test DB.","> This would be amazing!!\r\n> \r\n> Our use case is fullstack testing for [Blitz apps](https:\/\/github.com\/blitz-js\/blitz). We want client code tests to run in parallel but run server tests in series because they use the same test DB.\r\n\r\nVery similar use case here. Want to run all tests with unit tests running in parralel while integration tests run in series.","Considering there's a super simple runner that provides this functionality: https:\/\/github.com\/gabrieli\/jest-serial-runner it shouldn't be too difficult to add this option to the project config.","I share @taylorhoward92's use-case exactly. I thought I had come up with a solution ([here](https:\/\/stackoverflow.com\/a\/65190814\/2065427)), and indeed it does seem to work for me, but apparently I'm just getting lucky :).","I've got a draft PR for this, thought it'll need updating: #10912","> `maxWorkers` is currently a part of GlobalConfig so this is expected. I'm not sure if Jest should allow projects to limit the number of workers, as this may quickly go out of hand, causing inconsistencies between execution environments. The only scenario I see this could be helpful is limiting to 1 worker, in other words allowing `runInBand` to be configurable in a project. E.g. for E2E tests running on a device\/simulator where parallelization doesn't make sense (unless having multiple devices).\r\n> \r\n> @SimenB @jeysal thoughts?\r\n\r\nrunInBand at the project level is definitely a very welcome compromise. I've just moved a monorepo project to use Jest's `projects` instead of manually invoking with `yarn workspaces foreach -p run test  --runInBand` because I want to collect consolidate coverage for the entire workspace. Unfortunately using `yarn workspaces foreach` is ~1.8x - 2x faster than invoking `yarn jest` which is significant in economic cost and cumulative time.","Finally updated my [PR](https:\/\/github.com\/facebook\/jest\/pull\/10912) to implement this. Would be great to get a review :)\r\n\r\n![Peek 2021-10-17 12-49](https:\/\/user-images.githubusercontent.com\/11363036\/137629095-6a208f38-838d-4e39-83c6-b71ce5490066.gif)\r\n\r\n","@thymikee Is it possible someone could take a look at the PR for this? It may have been buried as it was first opened a year ago","how about all cli options?  seems ridiculous that this is not all configurable.  why is maxWorkers in the config documentation but doesn't work?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale. There's an open PR for this."],"labels":[":rocket: Feature Request"]},{"title":"process beforeExit event not called ","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n`beforeExit` event is never called.\r\n\r\nWe are using this event to release resources of a Rust library upon object's garbage collection, using https:\/\/github.com\/node-ffi-napi\/weak-napi.\r\n\r\n\r\n## To Reproduce\r\n\r\n```js\r\nprocess.on('beforeExit', () => {\r\n    console.log('beforeExit')\r\n})\r\n\r\n\r\ndescribe('mytest', () => {\r\n\r\n    it('should do stuff', () => {\r\n        console.log('hey')\r\n    })\r\n})\r\n```\r\n\r\n## Expected behavior\r\n\r\nWe should see `beforeExit` logged.\r\n\r\nThe same test works fine with Mocha, where `beforeExit` is successfully called.\r\n\r\n## envinfo\r\n\r\n```  \r\nSystem:\r\n    OS: macOS 10.15.7\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz\r\n  Binaries:\r\n    Node: 12.19.1 - ~\/.nvm\/versions\/node\/v12.19.1\/bin\/node\r\n    Yarn: 1.22.10 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.8 - ~\/.nvm\/versions\/node\/v12.19.1\/bin\/npm\r\n\r\n```\r\n","comments":["Just hit this. Any thoughts? It seems not so great that this doesn't work.","As part of my other bug report I went ahead and added a reproduction for this bug as well since they might be related? https:\/\/github.com\/cowboyd\/jest-suite-hooks-on-sigint","@OoDeLally It should also be noted that the same holds true for the `exit` event.","Any thoughts on how we can contribute to the resolution of this?\r\n\r\nAre there any work arounds?","@eladchen I have not been able to find any \ud83d\ude22 ","This is still the case in 27.5.1, it really shouldn't be.","Strong agree. Hopefully with Facebook setting this project free this will get some attention.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83d\udc4d\ud83c\udffb ","Just faced this with pino transport which runs in a worker thread and listens to the 'beforeExit' event:\r\n```\r\nJest has detected the following 1 open handle potentially keeping Jest from exiting\r\n```","I just ran into this. We use this handler to ensure that certain child processes spawned by a service is killed when the program exits, but it doesn't work under jest."],"labels":["Needs Triage","Bug Report"]},{"title":"feat: allow `runInBand` to be configured at project level","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md at the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n![Peek 2021-10-17 12-49](https:\/\/user-images.githubusercontent.com\/11363036\/137626102-18602469-14a8-48b6-93e2-9365bea6312b.gif)\r\n\r\nLots of feedback from people looking for this feature in #10936 \r\n\r\nCurrently running tests in band has to be configured on a global level through `--runInBand` arg. \r\n\r\nThis doesn't take into account some projects (particularly monorepos) which may need to be granular in this setting at a project level, some packages may be able to run tests in parallel, while others, integration tests for example, may require that all tests are run serially.\r\n\r\nBecause jest already has the mechanism to run tests across multiple projects, it makes sense that this setting is available to be switched on at a per project level, where the overall test strategy will be in parallel, but tests in an individual project will run in serial.\r\n\r\nExample\r\n\r\n```javascript\r\nmodule.exports = {\r\n  \"projects\": [\r\n    {\r\n      \"displayName\": \"integration\",\r\n      \"testEnvironment\": \"node\",\r\n      \"runInBand\": true,\r\n      \"testMatch\": [ \"**\/__integration__\/**\/*.[jt]s?(x)\", \"**\/?(*.)+(integration).[jt]s?(x)\" ]\r\n    },\r\n    {\r\n      \"displayName\": \"e2e\",\r\n      \"testEnvironment\": \"node\",\r\n      \"runInBand\": true,\r\n      \"testMatch\": [ \"**\/__e2e__\/**\/*.[jt]s?(x)\", \"**\/?(*.)+(e2e).[jt]s?(x)\" ]\r\n    },\r\n    {\r\n      \"displayName\": \"unit\",\r\n      \"testEnvironment\": \"node\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## Test plan\r\n\r\n- [x] Add unit tests\r\n- [x] Fix failing tests\r\n- [x] Update snapshots\r\n- [x] Create e2e test\r\n","comments":["Hi @freshollie! \n\nThank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file.\n\nIn order for us to review and merge your code, please sign at <https:\/\/code.facebook.com\/cla>. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need to sign the corporate CLA.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fjest%20%2310912). Thanks!","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!","~~@SimenB Looking for feedback before continuing fixing\/writing tests. POC works, but is this something you would consider in the main codebase?~~\r\n\r\nSplitting this into a runner is possible, but requires mostly duplicating logic already found in `jest-runner`, and without this change there is no way to use the project config to determine how each individual project should be executed.","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) Report\n> Merging [#10912](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (eb49789) into [main](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/b89a1bbe3652a3f5a8969ce768f3b74298ca021d?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (b89a1bb) will **increase** coverage by `0.00%`.\n> The diff coverage is `64.00%`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n\n```diff\n@@           Coverage Diff           @@\n##             main   #10912   +\/-   ##\n=======================================\n  Coverage   66.97%   66.98%           \n=======================================\n  Files         329      329           \n  Lines       17341    17355   +14     \n  Branches     5066     5070    +4     \n=======================================\n+ Hits        11615    11625   +10     \n- Misses       5694     5698    +4     \n  Partials       32       32           \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/jest-config\/src\/Defaults.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jb25maWcvc3JjL0RlZmF1bHRzLnRz) | `100.00% <\u00f8> (\u00f8)` | |\n| [packages\/jest-config\/src\/ValidConfig.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jb25maWcvc3JjL1ZhbGlkQ29uZmlnLnRz) | `100.00% <\u00f8> (\u00f8)` | |\n| [packages\/jest-config\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jb25maWcvc3JjL2luZGV4LnRz) | `20.73% <\u00f8> (\u00f8)` | |\n| [packages\/test-utils\/src\/config.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvdGVzdC11dGlscy9zcmMvY29uZmlnLnRz) | `0.00% <\u00f8> (\u00f8)` | |\n| [packages\/jest-runner\/src\/index.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1ydW5uZXIvc3JjL2luZGV4LnRz) | `63.44% <52.63%> (-0.85%)` | :arrow_down: |\n| [packages\/jest-config\/src\/normalize.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jb25maWcvc3JjL25vcm1hbGl6ZS50cw==) | `88.92% <100.00%> (+0.02%)` | :arrow_up: |\n| [packages\/jest-core\/src\/testSchedulerHelper.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1jb3JlL3NyYy90ZXN0U2NoZWR1bGVySGVscGVyLnRz) | `100.00% <100.00%> (\u00f8)` | |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Last update [b89a1bb...eb49789](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/10912?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n","This would be extremely useful for me, having integration tests in a monorepo. My life will get better when this is merged.","@SimenB @thymikee any chance I could get some eyes on this please :)\r\n\r\nIt's got a large amount of traction but no feedback. PR has e2es and Unit tests. \r\n\r\nWould be good to know if I should continue to maintain this change.","@SimenB @thymikee can we possibly get this merged? I really need this feature.","@revmischa I'm considering re-opening this PR it seems to have been buried... ","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","It's fine, switching to vitest greatly improved my life","@revmischa same lol","Still something that'd be useful to me, how has it gone ignored for so long? Bumping to keep alive, don't know why fully fleshed out PR is being closed by a bot after having absolutely no feedback from a maintainer. @SimenB @thymikee"],"labels":["cla signed"]},{"title":"mockResolvedValue returns undefined","body":"## \ud83d\udc1b Bug Report\r\n\r\nusing jest version 2.26.0\r\nand react scripts 4\r\n----\r\nwhen applying mock functions on jest.fn inside a jest mock factory function it seams they have no affect\r\ndoesn't work: \r\n\r\n```\r\njest.mock('.\/a_dependency', () => {\r\n  return {\r\n    dependency_func: jest.fn().mockResolvedValue('hello'),\r\n  };\r\n});\r\nimport { testMe } from '.\/a';\r\ndescribe('test', () => {\r\n  it('test me', async () => {\r\n    \/\/ calls inside to dependency_func\r\n    const res = testMe();\r\n    \/\/ will fail because res returns 'undefined' for some reason\r\n    expect(res).toBe('hello');\r\n  });\r\n});\r\n```\r\n\r\nworks:\r\n```\r\njest.mock('.\/a_dependency', () => {\r\n  return {\r\n    dependency_func: jest.fn(),\r\n  };\r\n});\r\nimport { dependency_func } from '.\/a_dependency';\r\nimport { testMe } from '.\/a';\r\ndescribe('test', () => {\r\n  it('test me', async () => {\r\n    dependency_func.mockResolvedValue('hello');\r\n    \/\/ calls inside to dependency_func\r\n    const res = testMe();\r\n    \/\/ will work now\r\n    expect(res).toBe('hello');\r\n  });\r\n});\r\n```\r\n\r\n## To Reproduce\r\n\r\ncraco(create react app configuration) generated app\r\nadded jest\r\ntried to mock a function from different file\r\nwhen using mockResolvedValue inside the jest.mock() - the function returns `undefined`\r\nwhen using mockResolvedValue in one of the tests it works as expected.\r\n\r\n## Expected behavior\r\n\r\nmockResolvedValue when used inside the mock factory function should return the value\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-8559U CPU @ 2.70GHz\r\n  Binaries:\r\n    Node: 12.19.0 - ~\/.nvm\/versions\/node\/v12.19.0\/bin\/node\r\n    Yarn: 1.22.4 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.8 - ~\/.nvm\/versions\/node\/v12.19.0\/bin\/npm\r\n```\r\n","comments":["see https:\/\/github.com\/facebook\/jest\/issues\/10849#issuecomment-740236180 it might be the same issue","I solved it by adding `mockResolvedValue()` in `beforeEach(() => { ... })`","> see [#10849 (comment)](https:\/\/github.com\/facebook\/jest\/issues\/10849#issuecomment-740236180) it might be the same issue\r\n\r\nThank you. your comment solved the issue for me. \ud83c\udf7b","> I solved it by adding `mockResolvedValue()` in `beforeEach(() => { ... })`\r\n\r\nIt worked for me. But any idea why it doesn't work in beforeAll block?"],"labels":["Needs Triage","Bug Report"]},{"title":"Options to prevent tweaking `console.{log|debug}`?","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nHave a command line flag \/ config option to avoid touching `console.{log|debug}`\r\n\r\n## Motivation\r\n\r\nDebugging via console output is often very useful.\r\n\r\n## Pitch\r\n\r\n(This is possibly something that is possible, though I found nothing at all, not on the web and not when asking people.)\r\n\r\nI often use `console.log` etc to debug code.  Should be obvious why it's useful.  But for each output, jest shows: a `console.debug` line, the actual output, an empty line, a source code location, and another empty line for good measure.  Use N `console.log`s with M tests, and you have an output messy enough to be either useless or make you go through cumbersome grep\/emacs\/etc gymnastics.\r\n\r\nWhen trying to see if there's an existing way to get just the output, all I found was some useless SO answers, and #8819 (leading to #9741) which apparently made it worse by adding a separate line for the source location.\r\n\r\nI got the vague impression that I can achieve that with a custom reporter, or more test code or whatever -- but I'm just debugging something else, I want to just run it with sane output temporarily while I'm debugging; I don't want to change the test output permanently, and I certainly don't want to diverge into a mini side-project of writing jest code for the occasional debugging need.  I also don't want to use an interactive debugger (I have a bunch of similar tests, and I want to eyeball all of them on a single screen rather than stepping through each and every one).\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","activity","activity","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","activity "],"labels":[":rocket: Feature Request"]},{"title":"jest-circus beforeAll hook behaviour on failure","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nWhen you have a failing `beforeAll` hook, all remaining `beforeAll` hooks will still run. Contrast that to `beforeEach` which after failing will skip the rest of the `beforeEach` hooks and skip the test.\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n## Expected behavior\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\nI think after the first beforeAll failure, every other beforeAll hook and child test should be skipped \/ failed.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n\r\nSee https:\/\/stackoverflow.com\/help\/minimal-reproducible-example for information on how to create good reproductions\r\n-->\r\n\r\n```typescript\r\nimport wrap from 'jest-snapshot-serializer-raw';\r\nimport {runTest} from 'jest-circus\/src\/__mocks__\/testUtils';\r\n\r\ntest('a failing beforeAll will not skip other beforeAll hooks', () => {\r\n    const {stdout} = runTest(`\r\n    describe('test suite beforeAll', () => {\r\n\r\n    beforeAll(() => {\r\n        console.log('beforeAll 1 runs')\r\n        throw new Error('beforeAll 1');\r\n    });\r\n\r\n    beforeAll(() => {\r\n        console.log('beforeAll 2 runs')\r\n        throw new Error('beforeAll 2');\r\n    });\r\n\r\n    test('should not run', () => {\r\n        console.log('the test ran')\r\n    });\r\n\r\n});\r\n  `);\r\n\r\n    expect(wrap(stdout)).toMatchSnapshot();\r\n});\r\n\r\n```\r\n\r\n```javascript\r\n\/\/ Jest Snapshot v1, https:\/\/goo.gl\/fbAQLP\r\n\r\nexports[`a failing beforeAll will not skip other beforeAll hooks 1`] = `\r\nObject {\r\n  Symbol(jest-snapshot-serializer-raw): \"start_describe_definition: test suite beforeAll\r\nadd_hook: beforeAll\r\nadd_hook: beforeAll\r\nadd_test: should not run\r\nfinish_describe_definition: test suite beforeAll\r\nrun_start\r\nrun_describe_start: ROOT_DESCRIBE_BLOCK\r\nrun_describe_start: test suite beforeAll\r\nhook_start: beforeAll\r\nbeforeAll 1 runs\r\nhook_failure: beforeAll\r\nhook_start: beforeAll\r\nbeforeAll 2 runs\r\nhook_failure: beforeAll\r\ntest_start: should not run\r\ntest_fn_start: should not run\r\ntest_done: should not run\r\nrun_describe_finish: test suite beforeAll\r\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\r\nrun_finish\r\n\r\nunhandledErrors: 0\",\r\n}\r\n`;\r\n\r\n```\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n\r\n```\r\n","comments":["Imo if `beforeAll` hook fail it should skip all related tests and `afterAll` hook should be run in any case (to ensure clean up is done, because `beforeAll` hook may initialize something partially)","@fider-apptimia The current behaviour for jest circus is to mark the test as error when a beforeAll hook fails. The test will not run but the rest of the beforeAll, afterEach, and afterAll hooks will still run. I feel like once the first beforeAll fails, the rest of the beforeAll hooks should skip and then afterAll hooks immediately run. There is an open issue to fix this in the jest jasmine runner. I didn't see any issue specifically related to circus for this behaviour.","@njmaeff imo issue here is that `test`s will be executed even if `beforeAll` throw.","Tests should definitely not run if `before*` fails. Whether or not `after*` should run is probably a separate discussion","`afterEach()` is also run in case `beforeAll()` fails. Is that a separate issue?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Stale? Has this been fixed. I think this is still an issue and should be fixed. I think @SimenB's comment summarized it perfectly: \r\n\r\n> Tests should definitely not run if before* fails. Whether or not after* should run is probably a separate discussion\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still not fixed as far as I'm aware of so we should keep it open."],"labels":["Needs Triage","Bug Report"]},{"title":"The original function name gets lost in the Jest error stack","body":"```js\r\ntest('hello world', () => {\r\n function BadCode() {\r\n    throw new Error('noo')\r\n  }\r\n\r\n  function run(fn) {\r\n    fn()\r\n  }\r\n\r\n  run(BadCode)\r\n});\r\n```\r\n\r\nI expect to see `BadCode` in the stack because it's a named function. But it shows up as `fn` instead:\r\n\r\n```\r\n      at fn (sum.test.js:3:11)\r\n      at run (sum.test.js:7:5)\r\n      at Object.<anonymous> (sum.test.js:10:3)\r\n```\r\n\r\nSame with `error.stack` property.\r\n\r\n## Isn't this just a Node issue?\r\n\r\nNope, try it in Node REPL and see `BadCode`:\r\n\r\n```\r\nUncaught Error: noo\r\n    at BadCode (repl:2:11)\r\n    at run (repl:2:5)\r\n```\r\n\r\nAlso works correctly in Chrome.\r\n\r\nI've done both locally so I used the same Node version (`12.18.3`). So it's Jest-specific.\r\n\r\nI can also reproduce this on Repl.it: https:\/\/repl.it\/repls\/SecondaryItchyGui\r\n\r\nI've tried `vm.runInContext` locally but that did not trigger the issue. I also verified I'm not transpiling anything. So I have no idea what is the cause of this. The underlying bug is probably in Node or V8 but we need to figure out what is special about Jest that is triggering it.\r\n\r\n## Why fix this?\r\n\r\nThis affects the new React component stack printing strategy so it would be unfortunate for this to stay unfixed very long.","comments":["Would love to give it a shot!\r\n","Go for it \ud83d\ude42 ","Hmm, maybe not. @gaearon did you test with latest version of Jest? Repl.it is on 24 by default This is what I'm seeing running your example in `jest@26.5.2` (node 12.19.0)\r\n\r\n```\r\n  \u2715 hello world (3 ms)\r\n\r\n  \u25cf hello world\r\n\r\n    noo\r\n\r\n      1 | test('hello world', () => {\r\n      2 |   function BadCode() {\r\n    > 3 |     throw new Error('noo');\r\n        |           ^\r\n      4 |   }\r\n      5 |\r\n      6 |   function run(fn) {\r\n\r\n      at BadCode (test.js:3:11)\r\n      at fn (test.js:7:5)\r\n      at Object.run (test.js:10:3)\r\n```","No, I didn't test with a different Jest version. This looks better! Although I'm still confused about why `fn` even exists in the stack..","@SimenB I tried the same and got `fn`: \r\n```\r\n  \u2715 hello world (2 ms)\r\n\r\n  \u25cf hello world\r\n\r\n    noo\r\n\r\n      1 | test(\"hello world\", () => {\r\n      2 |   function BadCode() {\r\n    > 3 |     throw new Error(\"noo\");\r\n        |           ^\r\n      4 |   }\r\n      5 | \r\n      6 |   function run(fn) {\r\n\r\n      at fn (__tests__\/index.test.js:3:11)\r\n      at run (__tests__\/index.test.js:7:5)\r\n      at Object.<anonymous> (__tests__\/index.test.js:10:3)\r\n```\r\nNode: v12.19.0\r\nJest: v26.5.3","Interesting! It doesn't reproduce in the Jest repo or the project at work.","Oh, yeah! Jest repo gives me `BadCode`: \r\n```\r\n  \u25cf hello world\r\n\r\n    noo\r\n\r\n      1 | test('hello world', () => {\r\n      2 |   function BadCode() {\r\n    > 3 |     throw new Error('noo');\r\n        |           ^\r\n      4 |   }\r\n      5 | \r\n      6 |   function run(fn) {\r\n\r\n      at BadCode (index.test.js:3:11)\r\n      at fn (index.test.js:7:5)\r\n      at Object.run (index.test.js:10:3)\r\n```","do you have a repository that reproduces?","React repo does.","(but with the old version)","You could also try this: https:\/\/github.com\/flozender\/jest-fnName\/","React repo doesn't reproduce for me \ud83d\ude48 \r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/96034628-17929b80-0e62-11eb-9da2-78c4ca3c3a1e.png)\r\n","Hmm. Actually sorry I created some confusion here \u2014 it reproed in a separate setup unrelated to our main Jest config. My mind blanked.\r\n","This is where I could repro it. https:\/\/github.com\/facebook\/react\/tree\/master\/fixtures\/legacy-jsx-runtimes\r\nRun `yarn && yarn test` in that directory.","@flozender's repo works (or doesn't... It reproduces the bug, is what I'm trying to say)","This \"fixes\" the reproduction\r\n\r\n```diff\r\ndiff --git i\/yarn.lock w\/yarn.lock\r\nindex 3d75ffc..d290b3c 100644\r\n--- i\/yarn.lock\r\n+++ w\/yarn.lock\r\n@@ -3019,9 +3019,9 @@ source-map-resolve@^0.5.0:\r\n     urix \"^0.1.0\"\r\n \r\n source-map-support@^0.5.6:\r\n-  version \"0.5.19\"\r\n-  resolved \"https:\/\/registry.yarnpkg.com\/source-map-support\/-\/source-map-support-0.5.19.tgz#a98b62f86dcaf4f67399648c085291ab9e8fed61\"\r\n-  integrity sha512-Wonm7zOCIJzBGQdB+thsPar0kYuCIzYvxZwlBa87yi\/Mdjv7Tip2cyVbLj5o0cFPN4EVkuTwb3GDDyUx2DGnGw==\r\n+  version \"0.5.13\"\r\n+  resolved \"https:\/\/registry.yarnpkg.com\/source-map-support\/-\/source-map-support-0.5.13.tgz#31b24a9c2e73c2de85066c0feb7d44767ed52932\"\r\n+  integrity sha512-SHSKFHadjVA5oR4PPqhtAVdcBWwRYVd6g6cAXnIbRiIwc2EhPrTuKUBdSLvlEKyIP3GCf89fltvcZiP9MMFA1w==\r\n   dependencies:\r\n     buffer-from \"^1.0.0\"\r\n     source-map \"^0.6.0\"\r\n```\r\n\r\nSo related to #9147 somehow is my guess\r\n\r\nAdding `\"jest\": {\"transform\": {}}` to `package.json` also \"fixes\" it, fwiw","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one."],"labels":[":bug: Bug","Confirmed","Help Wanted","Pinned"]},{"title":"Zero width chars not showing in diff","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nDifferences in strings containing zero width chars are not highlighted, making them incredibly hard to spot and debug. Eg, one of the following strings has as its first character (character at position 0) a [byte order mark character](https:\/\/en.wikipedia.org\/wiki\/Byte_order_mark) as its first character, and the other has the letter \"T\" as its first character.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/4924405\/95023090-b9a4cd80-0683-11eb-8754-1699d5b17d84.png)\r\n\r\nAdditional useful info\r\n* [UTF-16 spec on Byte Order Mark character](https:\/\/www.unicode.org\/charts\/PDF\/UFE70.pdf) (scroll to end of page). Its hex code is `FEFF`, or 65279 in decimal.\r\n* Related issues: #8448, #6881\r\n\r\n## To Reproduce\r\n\r\nJust create two strings that look identical, one of which contains a character such as the BOM character.\r\n\r\n## Expected behavior\r\n\r\nA clear indication of the difference.\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.4 Ubuntu 18.04.5 LTS (Bionic Beaver)\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz\r\n  Binaries:\r\n    Node: 14.4.0 - ~\/.nvm\/versions\/node\/v14.4.0\/bin\/node\r\n    Yarn: 1.21.1 - \/usr\/bin\/yarn\r\n    npm: 6.14.5 - ~\/.nvm\/versions\/node\/v14.4.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.0.1 => 26.0.1 \r\n```\r\n","comments":["hey can I work on this issue","@devil-cyber sure, thanks!","Can you please explain a bit how to get satrted\n\nOn Tue, Oct 6, 2020, 4:27 PM Simen Bekkhus <notifications@github.com> wrote:\n\n> @devil-cyber <https:\/\/github.com\/devil-cyber> sure, thanks!\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/10584#issuecomment-704191431>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AMPIV6SRF6YBAJ7PXUA6NDLSJLZZ7ANCNFSM4SD3APZA>\n> .\n>\n","This is really @pedrottimark's domain, but it should be somewhere in https:\/\/github.com\/facebook\/jest\/tree\/5da90b58eb6673e6f406f9ebc369b1f0fb747384\/packages\/jest-diff. Maybe @jeysal could provide some more details?","Ok\n\nOn Tue, Oct 6, 2020, 5:00 PM Simen Bekkhus <notifications@github.com> wrote:\n\n> This is really @pedrottimark <https:\/\/github.com\/pedrottimark>'s domain,\n> but it should be somewhere in\n> https:\/\/github.com\/facebook\/jest\/tree\/5da90b58eb6673e6f406f9ebc369b1f0fb747384\/packages\/jest-diff.\n> Maybe @jeysal <https:\/\/github.com\/jeysal> could provide some more details?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/10584#issuecomment-704206685>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AMPIV6RNGEGSFLYBHMN4X6LSJL5T5ANCNFSM4SD3APZA>\n> .\n>\n","I would expect most of the changes to be in `pretty-format` more likely than `jest-diff`.\r\nWe want to serialize a string starting with certain characters in a different way.\r\nThere should probably be a brief discussion on how exactly this should be visualized, ideally with input from @aryzing as well.\r\nMaybe `\"\\uFEFFbla\"`, but then how do we distinguish it from a string actually containing those characters (afaik backslashes are not an escape character in formatted strings)? Maybe move it before the `\"`?","Ok\n\nOn Tue, Oct 6, 2020, 5:06 PM Tim Seckinger <notifications@github.com> wrote:\n\n> I would expect most of the changes to be in pretty-format more likely\n> than jest-diff.\n> We want to serialize a string starting with certain characters in a\n> different way.\n> There should probably be a brief discussion on how exactly this should be\n> visualized, ideally with input from @aryzing <https:\/\/github.com\/aryzing>\n> as well.\n> Maybe \"\\uFEFFbla\", but then how do we distinguish it from a string\n> actually containing those characters (afaik backslashes are not an escape\n> character in formatted strings)? Maybe move it before the \"?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/10584#issuecomment-704209663>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AMPIV6URBXMS6UGEMQXIOIDSJL6MXANCNFSM4SD3APZA>\n> .\n>\n","@jeysal on my side no strong preferences on display, just thought I'd bring this up as it might trip up others in the future. Perhaps there's appetite for visually separating parts of the string corresponding to invisible characters or whitespace characters other than [the typical whitespace you get with the spacebar](https:\/\/util.unicode.org\/UnicodeJsps\/character.jsp?a=0020).\r\n\r\nMaybe (fyi, [00A0 is no-break space](https:\/\/util.unicode.org\/UnicodeJsps\/character.jsp?a=00A0))\r\n```\r\nExpected: \"Rest of string\"\r\nReceived: \\uFEFF + \"Rest of\" + \\u00A0 + \"string\"\r\n```\r\n\r\nLike I said, no strong feelings either way, I'm sure that any reasonable indication of the presence of such characters will be fine.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Believe this isn't resolved yet, is it?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I was just thinking about a solution for the issue.\r\n\r\nSorry I couldn't declare it before working on it.\r\n\r\nI will try to create a PR as well.\r\n\r\nI thought https:\/\/github.com\/facebook\/jest\/pull\/13997 was a very good approach.\r\n\r\nI thought the issue was that simply replacing a zero-width space with a no-break space makes it difficult to recognize that it is a zero-width space.\r\nAlso, there are multiple zero-width spaces other than `FEFF`, so I think this needs to be detected as well.\r\n\r\nI took the approach of using Note to tell that a zero-width space exists. The disadvantages of this approach are that it is difficult to visually see where the zero-width space exists and that it is impossible to detect when there are multiple zero-width spaces.\r\n\r\nI hope my PR will be of help and reference for a good solution."],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"Circular references hang jest when assertions fail on node 14","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\nWhen an assertion fails where either the expected or actual value is circular, and both values are objects, jest encounters an error stating it failed to convert a circular structure to JSON, resulting in the test run not completing.\r\n\r\n## To Reproduce\r\n```ts\r\nit(\"test\", () => {\r\n  const foo = {};\r\n  foo.ref = foo;\r\n\r\n  expect(foo).toEqual({});\r\n});\r\n```\r\n\r\nRunning jest gives me the following error:\r\n```\r\n(node:11685) UnhandledPromiseRejectionWarning: TypeError: Converting circular structure to JSON\r\n    --> starting at object with constructor 'Object'\r\n    --- property 'ref' closes the circle\r\n    at stringify (<anonymous>)\r\n    at writeChannelMessage (internal\/child_process\/serialization.js:117:20)\r\n    at process.target._send (internal\/child_process.js:804:17)\r\n    at process.target.send (internal\/child_process.js:702:19)\r\n    at reportSuccess (\/Users\/verit\/basic-jsx\/node_modules\/jest-worker\/build\/workers\/processChild.js:67:11)\r\n```\r\nJest continues running indefinitely (I only tested up to ten minutes) and reports nothing regarding the test suite.\r\n\r\nI traced this to the [added `failureDetails` property on error messages](https:\/\/github.com\/facebook\/jest\/pull\/9496\/files#diff-0755289e4b7e144aa0ef6f59f5bcf748R436), landed in [26.3.0](https:\/\/github.com\/facebook\/jest\/releases\/tag\/v26.3.0).\r\n\r\n## Expected behavior\r\nI'd expect the test to fail and jest to complete running.\r\n\r\n## envinfo\r\nI only tested two versions. The above error occurs on 14.9.0, but does not on 12.16.1.\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.6\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7920HQ CPU @ 3.10GHz\r\n  Binaries:\r\n    Node: 14.9.0 - ~\/.nodenv\/versions\/14.9.0\/bin\/node\r\n    npm: 6.14.8 - ~\/.nodenv\/versions\/14.9.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.4.2 => 26.4.2 \r\n```\r\n","comments":["Is there any workaround?","@Lonli-Lokli Looks like the only workaround for now is `--detectOpenHandles `\r\n\r\nHowever, this causes a massive decrease in performance. \r\n\r\nI hope this can be fixed soon. I have migrated several of our projects to jest... and now it causes hiccups all throughout our build system when one test breaks. \r\n\r\nIt would be nice if `--testTimeout` worked in this scenario... but it still allows the test to just hang until Jenkins or circle ci times out. ","I can reproduce this when I have two such tests (in separate files - but not sure if this matters) and I have to run it with `--watch`. Here, however, it can be reproduced even without `--watch`: https:\/\/repl.it\/@Frantiekiaik\/jest-playground-1\r\n","I just ran into what I assume is the same issue on Node 10.16.0 and Jest 26.6.2. I can't reproduce it as written, but if I make a file containing two copies of @voces's example test and run it in watch mode, I get the same error.\r\n\r\nThe test:\r\n```js\r\nit('test', () => {\r\n  const foo = {};\r\n  foo.ref = foo;\r\n\r\n  expect(foo).toEqual({});\r\n});\r\nit('test 2', () => {\r\n  const foo = {};\r\n  foo.ref = foo;\r\n\r\n  expect(foo).toEqual({});\r\n});\r\n```\r\n\r\nThe error:\r\n```\r\n(node:58951) ExperimentalWarning: The fs.promises API is experimental\r\n(node:58951) UnhandledPromiseRejectionWarning: TypeError: Converting circular structure to JSON\r\n    at JSON.stringify (<anonymous>)\r\n    at process.target._send (internal\/child_process.js:735:23)\r\n    at process.target.send (internal\/child_process.js:634:19)\r\n    at reportSuccess (\/Users\/richardmunroe\/analytics_ui\/node_modules\/jest-worker\/build\/workers\/processChild.js:67:11)\r\n(node:58951) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)\r\n(node:58951) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n```\r\n\r\nRunning with `--detectOpenHandles` makes the problem go away for me too.","This is happening since #9496 \r\nCommit 918636142791a3dd4ddfe9367149a90437bd6da9\r\n\r\nAnd it seems to happen because of some inter-process serialization. After adding `failureDetails` property, the serialization fails on cyclic references as it contains the objects being under test. Maybe some sanitization of the `failureDetails` property would help.","Note that after commit 5f6f2ec8e17555b695d65ab68824926c77730216 which changes default runner to circus, the error message is \r\n```\r\n\"messageParent\" can only be used inside a worker\r\n\r\n      at messageParent (packages\/jest-worker\/build\/workers\/messageParent.js:46:11)\r\n```\r\n\r\nwith `JEST_JASMINE=1` the error is as before.","Added a PR as an attempt to fix this.\r\n\r\nAlso, please note that the `messageParent` error mentioned above is due to [this line](https:\/\/github.com\/facebook\/jest\/blob\/245a58278ce189019e4af3537b0f987bf9ff210e\/packages\/jest-worker\/src\/workers\/messageParent.ts#L33) which swallows the real error message which is also about circular references.\r\n","> Added a PR as an attempt to fix this.\r\n\r\n\ud83c\udf89 \r\n\r\n> Also, please note that the `messageParent` error mentioned above is due to [this line](https:\/\/github.com\/facebook\/jest\/blob\/245a58278ce189019e4af3537b0f987bf9ff210e\/packages\/jest-worker\/src\/workers\/messageParent.ts#L33) which swallows the real error message which is also about circular references.\r\n\r\nWe should not swallow errors like that...","We confirm it happens in Node 12, and it\u2019s more common when using Angular Dependency Injection (I think they have cyclic structures in some error-states).\r\n\r\nThe process hangs in such scenario, but this can be improved slightly be applying `--unhandled-rejection=strict` to nodejs script, instead running jest as separate binary. It helps `jest` to recover and fail suite (but it does not resolve cyclic reference of course).","I can confirm this problem as very common with Angular DI with Node 12 as @piotrl mentioned. \r\nUsing Jest 26.6.3\r\n\r\nHow can I run it with `--unhandled-rejection=strict` flag?  \r\n\r\n```json\r\n    \/\/package.json > scripts\r\n    \"test:unit\": \"node --unhandled-rejections=strict $(npm bin)\/jest --env=jest-environment-jsdom-sixteen \",\r\n```\r\nthis is actually stopping the execution, is that the right workaround?","@SimenB from angular issue\r\n\"jest\": \"26.6.3\",\r\n \"jest-canvas-mock\": \"2.3.0\",\r\n \"jest-preset-angular\": \"8.3.2\",\r\nNow, the correct error is displayed in the console.\r\nHowever, the test runner process still does not stop. i.e. Process does not end when error is found.","@Lonli-Lokli I have the exact same versions as you, still getting meaningless errors: \r\n```\r\n(node:6657) UnhandledPromiseRejectionWarning: TypeError: Converting circular structure to JSON\r\n    --> starting at object with constructor 'Object'\r\n    |     property 'element' -> object with constructor 'Object'\r\n    |     property 'componentProvider' -> object with constructor 'Object'\r\n    --- property 'parent' closes the circle\r\n    at stringify (<anonymous>)\r\n    at writeChannelMessage (internal\/child_process\/serialization.js:117:20)\r\n    at process.target._send (internal\/child_process.js:805:17)\r\n    at process.target.send (internal\/child_process.js:703:19)\r\n    at reportSuccess (\/builds\/smallstack\/products\/cloud\/node_modules\/jest-runner\/node_modules\/jest-worker\/build\/workers\/processChild.js:67:11)\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n```\r\n\r\nThe error should have been a NullInjectorError: `NullInjectorError: No provider for CloudApiClient`","I have debugged a bit why this happens, and it happens because Angular TestBed configure its compiler to [add some additional meta-info to the errors](https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/view\/errors.ts#L27-L46). That configuration is getted from [the same file, calling to `initServicesIfNeeded` function](https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/view\/services.ts#L34) from some place into TestBed.\r\n\r\nI don't know if it should be fixed by jest or Angular (maybe implementing a `toJSON` method to its errors, to avoid to include this meta-properties to serialization). But it's a problem with jest-workers and Angular TestBed errors","Why not just use https:\/\/github.com\/WebReflection\/circular-json or https:\/\/www.npmjs.com\/package\/json-stringify-safe or similar libraries to be safe with Object JSON stringify?","The fix for this will be reverted (#11172) as it caused other serialization issues. Might need to use a custom json serializer, yeah","What is the recommended way of handling this?","Personally, I recommend rolling back the jest-jasmine2 (or jest-circus) version to one that isn't broken. I haven't tried it for a while yet, so there might be mysterious failures if you use try to use features introduced by the newer jest versions; you can do that if you don't directly depend on jest-jasmine2 by adding this to your package.json:\r\n\r\n```,\r\n    \"resolutions\": {\r\n        \"jest-jasmine2\": \"26.0.1\"\r\n    }\r\n```\r\n\r\n","In our case this ended up being an uncaught exception.  We eventually were able to log out the exception, and fix the unit test.  Then it worked fine.  Just FYI if anyone else runs into this.  Scary stuff.","For Angular users this might be the fix\/workaround:\r\n1. Error reads something like \r\n\r\n> TypeError: Converting circular structure to JSON\r\n>         --> starting at object with constructor 'Object'\r\n>         |     property 'element' -> object with constructor 'Object'\r\n>         |     property 'componentProvider' -> object with constructor 'Object'\r\n>         --- property 'parent' closes the circle\r\n>         at stringify (<anonymous>)\r\n\r\n2. Run `npm run test:detectOpenHandles` or the equivalent `jest --detectOpenHandles`\r\n3. Error now reads \r\n\r\n> Found the synthetic listener @transform.start. Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.\r\n\r\n OR \r\n\r\n> Found the synthetic property @transitionMessages. Please include[...]\r\n\r\n4. To fix, import `BrowserAnimationsModule` or `NoopAnimationsModule` in your test\r\n\r\nI don't know what the above errors are caused by though. Hopefully this helps.\r\n\r\nEDIT: Formatting","I was creating a repro case for a similar issue (see #11958) and I noticed that the issue of the `jest` runner hanging only appears to affect `jest-circus` on Node 12.x and 14.x.\r\n\r\nIf you look at this GitHub actions run: https:\/\/github.com\/blimmer\/jest-issue-repro\/actions\/runs\/1339553822 you'll see that 12.x and 14.x get killed by a timeout, while 16.x completes normally.\r\n\r\nSo, for those who are able to upgrade to Node 16.x, that's another possible workaround to this issue.","I've faced this issue recently in a React-Native project. The was due to declaring `ref` on a TouchableOpacity element. Which created a huge snapshot I guess, and the expectSnapshot failed. I removed from it and used on a wrapper view to get around this error. Btw, do not forget to use[ collapsable on the view](https:\/\/github.com\/gre\/react-native-view-shot\/issues\/7#issue-175153015), else it will cause App crash.\r\n![Screen Shot 2021-11-16 at 1 54 05 PM](https:\/\/user-images.githubusercontent.com\/15947845\/142047937-6a980c59-0b85-45a1-bf45-3296f6b19717.png)\r\n\r\n\r\n","same here, any solution ?\r\n\r\nnode: v14.17.6\r\nnpm: 6.14.15\r\njest: 24.8.0","@SimenB I know you might not have time for this work but do you still remember about this issue? ;)","@SimenB very tentative looking back into this (I just can't help myself sometimes \ud83d\ude48) and can't comment on my PR as it's now locked.\n\nYou outlined what you think the high level solution for this should be here: https:\/\/github.com\/facebook\/jest\/pull\/11467#issuecomment-1040878924\n\nI'm wondering if you had any thoughts on how to do that? From what I remember when I the `failureDetails` property it's structure was very ad-hoc (starting with \"a bunch of arrays or a single error\", iirc) so I'm concerned about how this could actually be solved robustly.\n\nIt could be that I'm misremembering or that ultimately the types boil down to a stable union of complex but well defined types. (I want to say the type of that property is `unknown` but I'm on mobile so can't confirm - if it is I'd say a good first step is probably to get that property's type completely defined)","cc @segrey I imagine you're probably pretty familiar with the different values the `failureDetails` property can be expected to hold - since it's likely that fixing this will result in less details, it would be good if you could detail what information you're actually using in WebStorm so we can keep them.","I think we can fix this by patching the jest-worker, when detecting a circular error, just fail the case.\r\n```\r\ndiff --git a\/node_modules\/jest-worker\/build\/workers\/processChild.js b\/node_modules\/jest-worker\/build\/workers\/processChild.js\r\nindex a4f5acb..4c2a018 100644\r\n--- a\/node_modules\/jest-worker\/build\/workers\/processChild.js\r\n+++ b\/node_modules\/jest-worker\/build\/workers\/processChild.js\r\n@@ -64,7 +64,13 @@ function reportSuccess(result) {\r\n     throw new Error('Child can only be used on a forked process');\r\n   }\r\n \r\n-  process.send([_types().PARENT_MESSAGE_OK, result]);\r\n+  try {\r\n+    process.send([_types().PARENT_MESSAGE_OK, result]);\r\n+  } catch (e) {\r\n+    if (e.message.indexOf(\"circular\") > -1) {\r\n+      reportClientError(e);\r\n+    }\r\n+  }\r\n }\r\n \r\n function reportClientError(error) {\r\n```","Same issue on node 18","@SimenB I've dug into this and confirmed that if I comment out [this line](https:\/\/github.com\/facebook\/jest\/blob\/ecab294cd5c1653041289b5cf80deea11af40f3f\/packages\/jest-circus\/src\/utils.ts#L357) the issue goes away, and also that this is because `test.errors` holds both Jest errors and _user_ errors.\r\n\r\nSo to ensure that that is JSON serializable I think we've got three options:\r\n\r\n1. Only hold Jest-based errors (e.g. `AssertionResult`), which internally would be ensured are JSON serializable\r\n    * From what I can tell `AssertionResult` is only represented as a type so we'd have to come up with a stable way to check if an error is of that type (which could be as simple as `matcherResult in error`, but it'd have to be stable)\r\n    * I don't know if there are other Jest errors that end up here that we'd also want to preserve\r\n    * This would mean that reporters could not have any special handling on non-jest errors (e.g. pretty handling of ESLint errors)\r\n2. Use a library like `flatted` to serialize the content\r\n    * My understanding is there is not a single standard for serializing circular json, so this would mean consumers would be required to use whatever Jest decides to use, which could be an annoying overhead\r\n    * This'd mean any tools currently using this property would require updating since they'll currently be expecting the content as a standard object rather than a string that needs to be parsed by an external library\r\n3. Require downstream users to ensure their errors are serializable as JSON\r\n   * This would have huge overhead and based on #11958 there might even be conflicts in Jest that makes it impossible for users to do this\r\n\r\nI think 1. is probably the option to go with at least for - afaik JetBrains are actually the only people using this property and they're definitely only interested in the `AssertionResult` errors from Jest; I think that should also be easier to extend afterwards if someone did want to preserve user errors e.g. we could implement a config option for providing a handler to do the serialization and only apply that to non `AssertionResult` errors.","After digging further into this I think I've come to what you were outlining [here](https:\/\/github.com\/facebook\/jest\/pull\/11467#issuecomment-1040849566) @SimenB, which is that `AssertionError` is not being properly serialized.\r\n\r\nThe bigger problem with this is that it's the `actual` and `expected` properties that are not being properly serialized which feels to me like it almost puts us back to where we started with #11467 just higher up \ud83e\udd14 I've not looked into how reporters actually fit into Jest, but I'm wondering if maybe the best solution here would be to accept a parse\/stringify pair that gets called here + before the final data gets passed to whatever reporters are being used - that way people can opt-in to handling this how they want and hopefully we don't have to do a breaking change for all existing reporters...\r\n\r\nThat'd also fix the issue for both `AssertionError` & external errors. @SimenB what do you think?","I get this issue with mocking await functions in many tests in different `describes` in the same file which all fail when I have a `mockReturnValueOnce` in one describe, but doesn't appear with `mockReturnValue` in the `describe` block, it's as if the mocks are shared between `describe` blocks because the return value from an upper `describe` was being returned in my other `describe` block mock instead of its own return value...\r\n```\r\nnode:internal\/child_process\/serialization:127\r\n    const string = JSONStringify(message) + '\\n';\r\n                   ^\r\n\r\nTypeError: Converting circular structure to JSON\r\n    --> starting at object with constructor 'Object'\r\n    |     property '_httpMessage' -> object with constructor 'Object'\r\n    --- property 'socket' closes the circle\r\n    at stringify (<anonymous>)\r\n    at writeChannelMessage (node:internal\/child_process\/serialization:127:20)\r\n    at process.target._send (node:internal\/child_process:819:17)\r\n    at process.target.send (node:internal\/child_process:719:19)\r\n    at reportSuccess (C:\\node-projects\\telus\\tps\\cdo-tps-quote-mgmt-api\\node_modules\\jest-worker\\build\\workers\\processChild.js:59:11)\r\n```\r\n\r\nIf I do `jest --detectOpenHandles` or `jest --runInBand` the errors don't appear, and I don't have a bunch of tests fail anymore.","@KrisBNelson yeah, the circular reference error does not happen with  `jest --runInBand` , why ?","@gaurav5430 because with `--runInBand` everything (assertion failures\/etc.) stays within a single Node process.\r\n\r\nIt's only when Jest has N child worker processes that, when a test fails in the child worker, the assertion failure needs to be serialized (via JSON) and sent to the parent process, and then a \"cannot convert to JSON\" error happens.\r\n","> @gaurav5430 because with `--runInBand` everything (assertion failures\/etc.) stays within a single Node process.\r\n> \r\n> It's only when Jest has N child worker processes that, when a test fails in the child worker, the assertion failure needs to be serialized (via JSON) and sent to the parent process, and then a \"cannot convert to JSON\" error happens.\r\n\r\nwhat's the actual solution for this issue? would downgrading jest work ?","Any solution for this issue?","@SimenB gentle nudge to get your thoughts on what I've outlined in [this](https:\/\/github.com\/facebook\/jest\/issues\/10577#issuecomment-1186296425) and [that](https:\/\/github.com\/facebook\/jest\/issues\/10577#issuecomment-1186306643) comment :)","@SimenB Kindly have this bug fixed, please!","hey, any solution on this issue ?\r\n","Similar problem - `expect(someDomeNode).toBe(someOtherNode)` loops somewhere in the serialization of endless React\/JSDOM structure and ends as an OOM exception.","Node v16.19 Jest 29.5 simply calling a method that raises an error with a circular reference.\r\n\r\nTry\/catching the method call and replacing the error in the catch is a work-around. Without that, jest throws the unintuitive error message. Example:\r\n\r\n```\r\n       TypeError: Converting circular structure to JSON\r\n        --> starting at object with constructor 'ClientRequest'\r\n        |     property 'socket' -> object with constructor 'TLSSocket'\r\n        --- property '_httpMessage' closes the circle\r\n        at stringify (<anonymous>)\r\n\r\n      at messageParent (node_modules\/jest-worker\/build\/workers\/messageParent.js:29:19)\r\n```\r\n\r\nThe underlying dependency of the package throwing the error in this case is Axios.\r\n\r\nThe root problem with Jest is assuming JSON.stringify is always going to work. Use a safe stringify implementation, please.","Currently a solution could be [`workerThreads: true`](https:\/\/jestjs.io\/docs\/configuration#workerthreads) option.\r\n\r\nNote that it is marked **experimental**. That is recently added feature and it is not tested widely yet.\r\n\r\n","i was getting the same error for ZoneJs object with circular structure\r\nwas able to workaround this issue by adding to following to testWorker.js (line 127)\r\n\r\n```\r\nconst sendMessageToJest = (eventName, args) => {\r\n  \/\/ start here\r\n  if (args[1].failureDetails) {\r\n    args[1].failureDetails.forEach((fd) => {\r\n      fd.rejection = null;\r\n      fd.promise = null;\r\n      fd.zone = null;\r\n      fd.task = null;\r\n    })\r\n  };\r\n  \/\/ end here\r\n  (0, _jestWorker().messageParent)([eventName, args]);\r\n};\r\n```\r\nnow getting the real error with stacktrace message and without any \"Converting circular structure to JSON\" errors\r\nyou may need to make adjustments depending on your code\r\n\r\nA more correct approach might be to set null for each property of failureDetails item except 'stack' and 'message' props\r\n\r\njest v28.1.0 or 29.5.0\r\nnode v16.19.0","With jest@29.5.0, the following generic workaround helped me:\r\n\r\n```js\r\nfunction deCircle(o, seen = new Set()) {\r\n  if (!o || typeof o !== 'object') return;\r\n  Object.entries(o).forEach(([k,v]) => {\r\n    if (seen.has(v)) {\r\n      o[k] = null;\r\n      return;\r\n    }\r\n    const s = new Set(seen);\r\n    s.add(v);\r\n    deCircle(v, s);\r\n  })\r\n}\r\nfunction reportSuccess(result) {\r\n  if (!process || !process.send) {\r\n    throw new Error('Child can only be used on a forked process');\r\n  }\r\n  deCircle(result); \/\/ \u2190 patching the object\r\n  process.send([_types.PARENT_MESSAGE_OK, result]);\r\n}\r\n```\r\n\r\nYou might need to patch on error as well, depending on the circumstances.","I had this problem a few minutes ago. Found out it happened when I had two test files with same name in different folders. Once I renamed one of the files the problem was gone.","Glad to see this is not a general problem with testing eslint rules. In my case, when a test fails, because almost all eslint nodes have circular references this problem is quite common.","Still happening even though I am just expecting a number to be there and even thought it is but still tests fails \ud83d\ude2d \r\nLook here: https:\/\/github.com\/kasir-barati\/nestjs-materials\/blob\/main\/typeorm\/src\/modules\/talent-e2e\/get-all.e2e-spec.ts#L9\r\n\r\n# The Solution that worked for me\r\nhttps:\/\/github.com\/jestjs\/jest\/issues\/10577#issuecomment-1262528952","Coming back again to the same issue, it seems that this time adding `--detectOpenHandles` flag is not gonna help me, I cannot deduce the issue from the logs and when I add that flag test suit fails immediately after it reaches the point that it should make a http req via axios (so no room to log anything in my test suit) and just logs that axios request failed with 400 http status code but in reality it even won't enter the `catch` block, any idea?\r\n\r\n```cmd\r\nTypeError: Converting circular structure to JSON\r\n    --> starting at object with constructor 'Object'\r\n    |     property 'res' -> object with constructor 'Object'\r\n    --- property 'req' closes the circle\r\n    at stringify (<anonymous>)\r\n    at writeChannelMessage (node:internal\/child_process\/serialization:159:20)\r\n    at process.target._send (node:internal\/child_process:852:17)\r\n    at process.target.send (node:internal\/child_process:752:19)\r\n    at reportSuccess (\/home\/kasir\/projects\/you-say\/node_modules\/jest-worker\/build\/workers\/processChild.js:82:11)\r\n\r\nNode.js v20.10.0\r\n FAIL   backend-e2e  apps\/backend-e2e\/src\/auth\/auth-business.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest worker encountered 4 child process exceptions, exceeding retry limit\r\n\r\n      at ChildProcessWorker.initialize (..\/..\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:181:21)\r\n```"],"labels":[":bug: Bug","Help Wanted"]},{"title":"Provide a way to find out whether fake timers have been enabled.","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nProvide a method (e.g. `jest.usingFakeTimers()`) that returns `true` if `jest.useFakeTimers` was previously invoked.  Alternatively, a property or a config object could be exposed with the same information.  \r\n\r\n## Motivation\r\n\r\nIt is often convenient to have a global cleanup routine for tests that does things like always reverting to real timers, etc.   It would be awesome if we could flush timers (e.g. `jest.runOnlyPendingTimers()`) in this cleanup routine as well, but to do that, one would need to find out if fake timers are actually being used.\r\n\r\nThere are already examples of libraries resorting to introspection of the `setTimeout` implementation to try to deduce this for similar purposes.\r\n\r\n@kentcdodds had to do the following https:\/\/github.com\/testing-library\/react-testing-library\/pull\/720\/files recently\r\n```js\r\nfunction getIsUsingFakeTimers() {\r\n  return (\r\n    typeof jest !== 'undefined' &&\r\n    typeof setTimeout !== 'undefined' &&\r\n    (setTimeout.hasOwnProperty('_isMockFunction') ||\r\n      setTimeout.hasOwnProperty('clock'))\r\n  )\r\n}\r\n```\r\n\r\nWould be awesome if `jest` exposed an official method to check the above, so that tooling wouldn't break if the\u00a0underlying implementation were to change.\r\n\r\n## Example\r\n\r\n```js\r\nafterEach(() => {\r\n  if (jest.usingFakeTimers()) {\r\n    jest.runOnlyPendingTimers();\r\n  }\r\n});\r\n```\r\n\r\n## Pitch\r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nSince `jest.useFakeTimers` is a part of the core platform, it seems reasonable to be able to find out whether that call had previously been invoked.  The core platform is the only place that would be able to provide this information.","comments":["I think something similar can be achieved by doing the following:\r\n\r\n```js\r\nafterEach(() => {\r\n  if (jest.isMockFunction(setTimeout)) {\r\n    jest.runOnlyPendingTimers();\r\n    jest.useRealTimers();\r\n  }\r\n});\r\n```\r\n\r\nhttps:\/\/jestjs.io\/docs\/jest-object#jestismockfunctionfn","I do exactly this: https:\/\/github.com\/kentcdodds\/bookshelf\/blob\/d4851afda9ae40feb61ca28f76e957290ed2bfab\/src\/setupTests.js#L52-L55","Thanks for the suggestion @cschwebk ! That seems like a very clean workaround, but it'd be awesome if it was officially supported\/documented, since strictly speaking without that, it's not guaranteed that enabling fake timers will make `setTimeout` an actual mock function and could thus break at any time if the underlying implementation changes.","It's worth noting that these methods aren't actually correct. If you use `jest.spyOn(global, \"setTimeout\")`, the checks above will still be true despite the fact that timers aren't actually using the fake implementations. So simply checking if `setTimeout` is mocked isn't enough to definitively determine.\r\n\r\nI was not able to find any way to differentiate between a spy and a mock so I'm not sure how it'd be possible to determine this reliably, even in a hacky way.\r\n\r\nIf only there was a property\/method exposed by Jest which could help us! \ud83d\ude09 ","This seems not to work with jest 28.1.0 - `jest.isMockFunction(setTimeout)` will always return `false`, regardless of using real or fake timers.\r\n\r\nAs a temporary and hacky workaround that is almost certain to break, checking the `setTimeout.name` property seems to be an indication of whether the timers are mocked, but this will be extremely brittle long term. When the timers _are_ mocked, `setTimeout.name === \"setTimeout\"`, and when using real timers, `setTimeout.name === undefined`.\r\n\r\nI can't explain why this is the case (maybe some setup from jest-environment-jsdom?), as `setTimeout.name === \"setTimeout\"` in browsers as well as node, but it seems to work for the time being.\r\n\r\nTo maybe provide some reasoning for why this feature is useful, it can be used with the react-testing-library user-event companion library. Setup of this is something like:\r\n\r\n```js\r\nuserEvent.setup();\r\n```\r\n\r\nBut when using mocked timers, you must provide an `advanceTimers` function to hook into jest\r\n\r\n```js\r\nuserEvent.setup({ advanceTimers: jest.advanceTimersByTime });\r\n```\r\n\r\nTo simplify this, it is often put in a setup wrapper, so should be able to dynamically set the correct `advanceTimers` function based on whether or not the running test context has mocked time. ","I can confirm that `jest.isMockFunction(setTimeout)` doesn't work in Jest 29 either, always returns `false` even if fake timers enabled :( I ended up doing the following.\r\n\r\n```javascript\r\nif (typeof jest !== 'undefined' && setTimeout.clock != null && typeof setTimeout.clock.Date === 'function') {\r\n  \/\/ ...\r\n}\r\n```\r\n\r\nCan you **please** consider deprecating `useFakeTimers()` ?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale","`jest@29.7.0` use `@sinonjs\/fake-timers` internally to fake timers, they detect fake timers by checking `global.Date.isFake`, i guess it safe for now to do the same, to check for fake timers.\r\n\r\nhttps:\/\/github.com\/sinonjs\/fake-timers\/blob\/0f2861015f3fab85d36367281395ee94a7eac4fe\/src\/fake-timers-src.js#L1731\r\n\r\n```ts\r\ndeclare global {\r\n    interface DateConstructor {\r\n        \/* Jest uses @sinonjs\/fake-timers, that add this flag *\/\r\n        isFake: boolean;\r\n    }\r\n}\r\n\r\nconst hasFakeTimers = global.Date.isFake === true;\r\n```"],"labels":[":rocket: Feature Request"]},{"title":"Custom snapshot matcher name is ignored","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nA custom snapshot matcher cannot have a custom matcher name as indicated in https:\/\/jestjs.io\/docs\/en\/expect#custom-snapshot-matchers\r\n\r\n## To Reproduce\r\n\r\nFollow https:\/\/jestjs.io\/docs\/en\/expect#custom-snapshot-matchers and add \r\n```js\r\nexpect.extend({\r\n  toMatchTrimmedSnapshot(received, length) {\r\n    return toMatchSnapshot.call(\r\n      this,\r\n      received.substring(0, length),\r\n      'toMatchTrimmedSnapshot',\r\n    );\r\n  },\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nA failing `toMatchTrimmedSnapshot` is described as `expect(received).toMatchTrimmedSnapshot(hint)`.\r\n\r\nWhich would also be problematic since that's not the actual signature. The correct signature would be `expect(received).toMatchTrimmedSnapshot(length)`\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/eps1lon\/jest-custom-snapshot-matcher\/blob\/master\/index.test.js\r\n\r\nThe third argument of `toMatchSnapshot` is considered as the `hint`. The matcher name is hardcoded right now: https:\/\/github.com\/facebook\/jest\/blob\/6499debdaa4fde3cc83ad1f42b3210478a389026\/packages\/jest-snapshot\/src\/index.ts#L165\r\n\r\n## envinfo\r\n\r\n```\r\nSystem:\r\n    OS: Windows 10 10.0.18363\r\n    CPU: (6) x64 Intel(R) Core(TM) i5-9400 CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 14.0.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.4 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 6.14.4 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^26.4.2 => 26.4.2\r\n```\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","a","Wait is this bot actually expecting a more long-form comment?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump"],"labels":["Needs Triage","Bug Report"]},{"title":"Evaluating inline scripts within  jsdom container","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nTesting vanilla HTML \/ JS using build-in jsdom - cannot get the inline scripts being executed. \r\nLoading an HTML content with a `<script>` tags and expecting the scripts to be evaluated by jsdom, but nothing happens.\r\n \r\n## To Reproduce\r\n```ts\r\n  test('evaluates inline script', async () => {\r\n    const html = `\r\n      <script>\r\n        console.debug('evaluated');\r\n        function run() {\r\n          console.debug('run');\r\n          const el = document.createElement('div')\r\n          el.setAttribute('data-testid', 'custom');\r\n          document.body.appendChild(el);\r\n        }\r\n\r\n        window.addEventListener('load', run);\r\n      <\/script>\r\n    `;\r\n\r\n    document.body.innerHTML = html;\r\n\r\n    window.dispatchEvent(new Event('load'));\r\n    await new Promise((resolve) => setTimeout(resolve, 500));\r\n\r\n    const $el = document.querySelector('[data-testid=\"custom\"]');\r\n    expect($el).toBeTruthy();\r\n  });\r\n```\r\n\r\n## Expected behavior\r\n\r\nThe test \ud83d\udc46\ud83c\udffb should pass - inline JS code should be evaluated and DOM modified.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/repls\/ClassicDarkvioletCurrency#inline-js.test.js\r\n\r\n## envinfo\r\n\r\n\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.6\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7920HQ CPU @ 3.10GHz\r\n  Binaries:\r\n    Node: 13.8.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.0 - \/usr\/local\/bin\/yarn\r\n    npm: 6.13.7 - \/usr\/local\/bin\/npm\r\n```\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I'm experiencing a similar issue. I need to call a script to define custom elements within the HTML I am testing, but the custom elements do not get defined as the script is not being run.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","We do pass `runScripts: dangerously` - I'd have thought that was enough?\r\n\r\nhttps:\/\/github.com\/jestjs\/jest\/blob\/892f9a6714a9749e22e63098bb1aef9f7a91c46d\/packages\/jest-environment-jsdom-abstract\/src\/index.ts#L72"],"labels":["Needs Triage","Bug Report"]},{"title":"[jest-circus] Support both done callback and async test simultaneously","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nPlease support writing async tests that can also use the `done` callback.\r\n\r\nThis didn't work \"properly\" before the new `jest-circus` runner forbid this combination, but it did sorta work enough to be useful. https:\/\/github.com\/facebook\/jest\/pull\/9129\r\n\r\nIdeally, an `async (done) => {}` test would not complete successfully unless both:\r\n* the `done` callback  was called without error AND\r\n* the Promise returned by the test resolved\r\n\r\nTest would fail immediately if one of:\r\n\r\n* the `done` callback is invoked with a truthy (error) value OR\r\n* the returned `Promise` rejects OR\r\n* test timeout reached\r\n\r\nWhen to proceed to after hooks and next test is debatable:\r\n\r\n* If `done` errors, should it wait for the promise to settle or timeout occurs?\r\n* If the promise rejects before `done` is called, should it wait for `done` to be called or timeout occurs?\r\n* Both of the above?\r\n\r\nIMO it should always wait for promise to settle\/timeout, but not wait for `done` if the promise rejects.\r\n\r\n## Motivation\r\n\r\nCurrently:\r\n\r\n* Testing Promises \ud83d\udc4d \r\n* Testing Events\/callbacks \ud83d\udc4d \r\n* Testing a mix of promises and events\/callbacks: \ud83d\udc4e  \r\n\r\nWith the `done` OR `Promise` setup, how do you set up a test that checks both that a promise resolved AND an event was fired? Seems like this should be simple, but is it?\r\n\r\nConsider a `connection` object , something like:\r\n\r\n```js\r\nclass Connection extends EventEmitter {\r\n    isConnected() {\r\n        return !!this._isConnected\r\n    }\r\n\r\n    async connect() {\r\n        return new Promise((resolve, reject) => {\r\n            \/\/ \u2026 implementation details go here\r\n            \/\/ imagine that it also rejects + emits 'error' on an error\r\n            setTimeout(() => { \r\n                this._isConnected = true\r\n                this.emit('connected') \/\/ or maybe after the resolve?\r\n                resolve()\r\n            }, 100)\r\n        })\r\n    }\r\n}\r\n```\r\nHow to test the behaviour of this?\r\n\r\nHere's some examples of partial\/naive solutions to testing this that I have seen in the wild (or done myself).\r\n\r\nFor example, this doesn't verify that the promise resolved, or didn't reject before moving onto the next test:\r\n\r\n```js\r\ntest('this will not check both event + promise v1', (done) => {\r\n    connection.once('error', done) \/\/ auto-fail test if an error is emitted\r\n    connection.once('connected', () => {\r\n        expect(connection.isConnected()).toBeTruthy()\r\n        done() \/\/ but we haven't checked if connect call resolved\/rejected\r\n    })\r\n    connection.connect().catch(done)\r\n})\r\n```\r\n\r\nAnd conversely using an `async ` test, we can't check that the event was fired before the test ended:\r\n\r\n```js\r\ntest('this will not check both event + promise v2', async () => {\r\n    connection.once('error', done) \/\/ auto-fail test if an error is emitted\r\n    connection.once('connected', () => {\r\n        expect(connection.isConnected()).toBeTruthy() \/\/ if connected event fires after resolution then this won't be checked\r\n    })\r\n    await connection.connect()\r\n})\r\n```\r\n\r\nOne way to set it up that will work, and handle all cases, is to queue the promise and then resolve the promise with done:\r\n\r\n```js\r\ntest('this will check both event + promise v1', (done) => {\r\n    connection.once('error', done) \/\/ auto-fail test if an error is emitted\r\n    let task\r\n    connection.once('connected', () => {\r\n        expect(connection.isConnected()).toBeTruthy()\r\n        task.then(() => done(), done)\r\n    })\r\n    task = connection.connect()\r\n})\r\n```\r\n\r\nBut IIUC with the new `jest-circus` runner (at least in version 26.4.2), if that expect call fails, then test will wait to time out before moving on to the next test because `done` is never called because `expect` threw. This isn't ideal if we want fast tests. So I guess we have to wrap every event handler in a try\/catch?\r\n\r\n```js\r\ntest('this will check both event + promise v1', (done) => {\r\n    connection.once('error', done) \/\/ auto-fail test if an error is emitted\r\n    let task\r\n    connection.once('connected', () => {\r\n        try {\r\n            expect(connection.isConnected()).toBeTruthy()\r\n        } catch (err) {\r\n            done(err)\r\n            return \/\/ does return here also make a task rejection trigger an unhandled rejection?\r\n        }\r\n        task.then(() => done(), done)\r\n    })\r\n    task = connection.connect()\r\n})\r\n```\r\n\r\nPerhaps that's off-topic. update: I've opened a ticket about uncaught exception waiting for timeout here https:\/\/github.com\/facebook\/jest\/issues\/10530\r\n\r\nThe `done` callback style test doesn't give us the convenience of `await` though. \r\nTo set it up with an `async` test you have to do something like the code below:\r\n\r\n```js\r\ntest('this will check both event + promise v2', async () => { \/\/ auto-fail test if an error is emitted\r\n    const task = new Promise((resolve, reject) => {\r\n        connection.once('connected', resolve).once('error', reject)\r\n    }).then(() => {\r\n        expect(connection.isConnected()).toBeTruthy() \/\/ won't be executed synchronously with the 'connected' event now\r\n    })\r\n\r\n    await connection.connect()\r\n    expect(connection.isConnected()).toBeTruthy()\r\n    await task\r\n})\r\n```\r\n\r\nHowever the above does change the task timing of when the 'connected' event's expect call is run, it no longer runs in the same microtask as the event, so to restore this timing you have to do something like:\r\n\r\n```js\r\ntest('this will check both event + promise v3', async () => {\r\n    const task = new Promise((resolve, reject) => {\r\n        connection.once('connected', () => {\r\n            expect(connection.isConnected()).toBeTruthy()\r\n            resolve()\r\n        }).once('error', reject)\r\n    })\r\n\r\n    await connection.connect()\r\n    expect(connection.isConnected()).toBeTruthy()\r\n    await task\r\n})\r\n```\r\n\r\nHowever on failure, this will never call the `reject`\/`resolve` so the test will also time out. Perhaps we wrap the `expect` in a try\/catch?\r\n\r\n```js\r\ntest('this will check both event + promise v4', async () => {\r\n    const task = new Promise((resolve, reject) => {\r\n        connection.once('connected', () => {\r\n            try {\r\n              expect(connection.isConnected()).toBeTruthy()\r\n              resolve()\r\n            } catch (err) {\r\n              reject(err)\r\n            }\r\n        }).once('error', reject)\r\n    })\r\n\r\n    await connection.connect()\r\n    expect(connection.isConnected()).toBeTruthy()\r\n    await task\r\n})\r\n```\r\n\r\nOverall this is all a lot of thinking and messing around in order to get robust tests for something that could be simple.\r\n\r\n## Example\r\n\r\nIdeally the Promise + done test would work something like so:\r\n\r\n```js\r\ntest('desired workflow', async (done) => {\r\n    connection.once('error', done) \/\/ auto-fail test if an error is emitted\r\n    connection.once('connected', () => {\r\n        expect(connection.isConnected()).toBeTruthy()\r\n        done() \/\/ this must be called before timeout\r\n    })\r\n    await connection.connect() \/\/ this must also resolve\r\n    expect(connection.isConnected()).toBeTruthy()\r\n})\r\n```\r\n\r\nTest would pass once both done and the returned promise resolve, one of them rejects, or the test times out. \r\nAnd the test runner would do something like this (pseudocode):\r\n\r\n```JS\r\nlet done = () => {} \/\/ noop for good measure\r\nconst onDone = new Promise((resolve, reject) => {\r\n    if (!testFn.length) {\r\n        resolve() \/\/ just resolve if test takes no `done` argument \r\n        return \/\/ optional I guess\r\n    }\r\n    done = (err) => err ? reject(err) : resolve()\r\n})\r\n\r\nawait Promise.race([\r\n    \/\/ immediately rejects if either testFn promise rejects, or done passes an error\r\n    \/\/ otherwise waits for both to resolve before proceeding\r\n    Promise.all([\r\n        Promise.resolve().then(() => ( \/\/ wrap to reject on sync exceptions\r\n            testFn(done) \/\/ testFn is the test to be executed\r\n        ), \r\n        onDone, \/\/ resolves when done is called (if testFn takes a callback)\r\n    ]),\r\n    rejectOnUnhandledOrUncaught(), \/\/ convert global unhandled\/uncaught event to rejection\r\n    getTimeout(testFn), \/\/ rejects on test timeout\r\n])\r\n```\r\n\r\nCould also consider using `Promise.allSettled` instead of `Promise.all` in order to wait for both done + resolve\/reject before continuing, but that would forces the test to hit timeout in a case like `expect` throwing inside an event handler leading to `done` not being called? Or perhaps, when an unhandled exception\/rejection fires, this implicitly calls `done`, so it doesn't have to wait?\r\n\r\n----\r\n\r\nAnother option would be to use `expect.assertions(n)` to signal the test's end, but this is a PITA if you have `expect` assertions in before\/after hooks, as these are included in the overall count for every test affected by those hooks.\r\n\r\n----\r\n\r\nedit: Perhaps the correct answer in this case is to simply test events and promises separately, which requires no changes and is arguably cleaner?\r\n\r\n```js\r\ntest('event is fired', (done) => {\r\n    connection.once('error', done)\r\n    connection.once('connected', () => {\r\n        expect(connection.isConnected()).toBeTruthy() \/\/ this failing shouldn't force test to wait for timeout though\r\n        done() \/\/ this must be called before timeout\r\n    })\r\n    connection.connect() \/\/ ignore resolve, reject will be picked up as unhandled\r\n})\r\n\r\ntest('promise is resolved', async () => {\r\n    await connection.connect()\r\n    expect(connection.isConnected()).toBeTruthy()\r\n})\r\n```","comments":["+1, this prevents `jest-preset-angular` to use `jest-circus`","I've been snoozing this issue for weeks meaning to get back to it \ud83d\ude1b The OP was very detailed and well thought out, so I wanted to let it simmer for a bit.\r\n\r\n---\r\n\r\nI don't wanna rollback the change as I think it's a good one - tests are way easier to reason about when there's not multiple async paradigms in use at the same time. We've also been warning for at least a full major version.\r\n\r\nTo concretely come up with a working test for the example in the OP I'd do something like this\r\n\r\n```js\r\nimport { once } from 'events';\r\n\r\ntest('intended workflow', async () => {\r\n  const connectedPromise = once(connection, 'connected');\r\n\r\n  await Promise.all([connection.connect(), connectedPromise]);\r\n\r\n  expect(connection.isConnected()).toBeTruthy();\r\n});\r\n```\r\n\r\n`once` comes from node core and handles the `error` event by rejecting: https:\/\/nodejs.org\/api\/events.html#events_events_once_emitter_name_options. You can probably build that helper yourself if you don't wanna rely on node core modules - it's not [too complex](https:\/\/github.com\/nodejs\/node\/blob\/32d58d72710e262a94693488b57c60fa66a6653e\/lib\/events.js#L708-L744) (at least if you ignore abort signals etc.).\r\n\r\nWould be even better if events were guaranteed to be emitted on next tick, but that's not the way node event emitters work, thus the `connectedPromise` assignment. If the `connected` is guaranteed to be emitted asynchronously it's even shorter\r\n\r\n```js\r\nimport { once } from 'events';\r\n\r\ntest('intended workflow', async () => {\r\n  await Promise.all([connection.connect(), once(connection, 'connected')]);\r\n\r\n  expect(connection.isConnected()).toBeTruthy();\r\n});\r\n```\r\n\r\nAll that to say is that I think the change is a good one - APIs mixing callbacks and promises are weird and hard to reason about, and coercing them to follow a single paradigm (by wrapping the APIs or using helpers like I've done in this post) makes the code cleaner and easier to reason about.\r\n\r\n---\r\n\r\n\/cc @jeysal @thymikee @cpojer would love your thoughts on this","@SimenB \r\n\r\nThe `once` API with `Promise.all` is an ok solution, however I see that's still not perfect since a late rejection will potentially infect other tests with unhandled rejections from the previous test. Really should use `Promise.allSettled` then some helper to lift `status: \"rejected\"` entries into a rejection, e.g. using `AggregateError`.\r\n\r\nBut yeah, I reiterate:\r\n\r\n> Overall this is all a lot of thinking and messing around in order to get robust tests.\r\n\r\nNot even really Jest's fault either, JS just doesn't provide a lot of utility for writing robust, non-trivial async workflows. But it'd be good if Jest could help pave a cowpath so it was easier to write clean, robust, async tests.\r\n\r\n> tests are way easier to reason about when there's not multiple async paradigms in use at the same time\r\n\r\nAgreed but unfortunately fairly common to have multiple paradigms in play and may be unavoidable in many codebases. Ideally it wouldn't be so perilous to do so.","Any progress on this? I reaaly wanted to switch to jest-circus for razzle but this is a blocker for that. ","Definitely e deal breaker for transitioning from the `jest-jasmine2` to `jest-circus` runner...","I\u2019m surprised this is being called for. For me, the `jest-circus` approach of either using `done` or `await` was a welcome one, and the few places where I needed to wrap callbacks were nothing to write about.\r\n\r\nWriting this not to raise arguments, but to support @SimenB \u2019s write from Dec 2020.","+1 can't wait till this feature is restored ","> None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.\r\n\r\nFrom https:\/\/jestjs.io\/docs\/asynchronous should be updated to point this out, while it doesn't say you can mix and match within a single test, it should clearly state that these 2 methods of testing are incompatible.","Here's a workaround for now. I don't know if there's any gotcha's, I assume there are some, if it was that simple jest would've already supported it.\r\n\r\n```ts\r\n  function itAsyncDone(\r\n    name: string,\r\n    cb: (done: jest.DoneCallback) => Promise<void>,\r\n    timeout?: number,\r\n  ) {\r\n    it(\r\n      name,\r\n      (done) => {\r\n        let doneCalled = false;\r\n        const wrappedDone: jest.DoneCallback = (...args) => {\r\n          if (doneCalled) {\r\n            return;\r\n          }\r\n\r\n          doneCalled = true;\r\n          done(...args);\r\n        };\r\n\r\n        wrappedDone.fail = (err) => {\r\n          if (doneCalled) {\r\n            return;\r\n          }\r\n\r\n          doneCalled = true;\r\n\r\n          done.fail(err);\r\n        };\r\n\r\n        cb(wrappedDone).catch(wrappedDone);\r\n      },\r\n      timeout,\r\n    );\r\n  }\r\n```\r\n\r\n","Hi @masad-frost, thank you so much for your workaround.\r\n\r\nWe are migrating from Jasmine to Jest lots of projects that use both done callback and async functions so your method is making our lifes easier.\r\n\r\nI modified it with two changes:\r\n\r\n1. I called the function \"it\" instead of \"itAsyncDone\" in order to work with our previous test syntax. Because of this, I changed the \"it\" call inside the function with \"test\" as it is the same function in Jest.\r\n2. I changed the done.fail(err) line with done(err), as Jest does not support done.fail syntax anymore. I opened this issue #11780  but it seems it is not supported anymore. With your function I made done.fail() available again.\r\n\r\nThank you so much, greetings.","+1 This is breaking every test where I'm testing thrown errors. The methods I'm running are `async`, so I have to `await` them, but if I don't call `done` in my catch, the test times out. If I don't call done in the try, the test times out if what I'm testing doesn't throw as expected. I'm sure there's another way around it, but the change seems a bit arbitrary.\r\n\r\nEDIT TO ADD: For my case, chaining a `.catch` and testing the error output there worked. It's not prime, but it works, and the tests function as expected.","```\r\nTest functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\r\n    Returned value: Promise {}\r\n```\r\n\r\ntried running done inside a .catch() instead of async await , but didn't work also","My tests now look pretty silly because I can not use `await`\r\n\r\n```ts\r\nit(\"should be able subscribe to container set change\", (cb) => {\r\n  \/\/ This is silly \r\n  ;(async () => {\r\n    const cont = getMainMockAppContainer()\r\n    let containerSet = await cont.getContainerSet([\"aCont\", \"bCont\", \"cCont\"]) \/\/ await improves readability\r\n\r\n    expect(containerSet.bCont.b2).toMatchObject({ a1: {} })\r\n    expect(containerSet.cCont.c2.size).toBe(5)\r\n\r\n    cont.subscribeToContinerSet([\"aCont\", \"bCont\", \"cCont\"], (containerSet) => {\r\n      expect(containerSet.cCont.c2.size).toBe(10)\r\n      cb()\r\n    })\r\n\r\n    containerSet.cCont.upgradeCContainer()\r\n  })()\r\n})\r\n\r\n```\r\n\r\nI would rather do this\r\n\r\n```ts\r\nit(\"should be able subscribe to container set change\", async (cb) => {\r\n  const cont = getMainMockAppContainer()\r\n  let containerSet = await cont.getContainerSet([\"aCont\", \"bCont\", \"cCont\"])\r\n\r\n  expect(containerSet.bCont.b2).toMatchObject({ a1: {} })\r\n  expect(containerSet.cCont.c2.size).toBe(5)\r\n\r\n  cont.subscribeToContinerSet([\"aCont\", \"bCont\", \"cCont\"], (containerSet) => {\r\n    expect(containerSet.cCont.c2.size).toBe(10)\r\n    cb()\r\n  })\r\n\r\n  containerSet.cCont.upgradeCContainer()\r\n})\r\n```","> From https:\/\/jestjs.io\/docs\/asynchronous should be updated to point this out, while it doesn't say you can mix and match within a single test, it should clearly state that these 2 methods of testing are incompatible.\r\n\r\nAlso, this is a breaking change, because it worked until jest 25 or something and I am sure I have hundreds of spec files written that way","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I think this issue is still valid and we have interest in it. I'd either like to see this regression fixed or some clearer guidance on why these two async test strategies should not be combined.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump"],"labels":["Discussion",":rocket: Feature Request"]},{"title":"[jest-circus] suite level retry","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nSupport test suite level retry\r\n\r\n## Motivation\r\n\r\ncurrently jest-circus only support re-run test cases  according to <https:\/\/github.com\/facebook\/jest\/blob\/23f425c15a5cdf80dd165a1b50c07b92edb8c10c\/packages\/jest-circus\/src\/run.ts#L69>\r\n\r\nhowever, in common e2e test scenario, some test cases are not isolated with others, they depend on the status of the previous test cases, so  retry in test case level may  be not helpful but suite level can\r\n \r\n## Example\r\nmaybe we can extend the `jest.retryTimes` method:\r\n```ts\r\njest.retryTimes(TestCaseNumRetries: number, TestSuiteNumRetries?: number);\r\n```\r\n\r\njust a proposal, I am not good at design api. but if you guys think my proposal is doable, I'm glad to send a PR to implement it. \ud83e\udd23 \r\n\r\n## Pitch\r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nCommon feature proposals that do not typically make it to core:\r\n\r\n- New matchers (see [jest-extended](https:\/\/github.com\/jest-community\/jest-extended))\r\n- Changes to the default reporter (use custom reporters instead)\r\n- Changes to node\/jsdom test environments (use custom environments instead)\r\n","comments":["I totally agree with @stkevintan and looking for this feature too, can also add a bit more details why I need it.\r\n\r\nAs I understand the actual problem is running failed test at the end of suite.\r\nIf you run\r\n\r\n```\r\nit('a)\r\nit('b')\r\nit('c')\r\n```\r\n\r\nAnd `b` fails, it will run `a -> b (failed) -> c -> b (retry)`\r\nI do not understand why we have this ordering, `a -> b (failed) ->  b (retry) -> c` should solve a lot of possible problems inside suite.\r\n\r\nMaybe we have a way to run it in this ordering right now? I didn't find it, but anyway @stkevintan request to rerun test suite will be very helpful, in my case I run browser tab for every test suite and tests dependce on prev browser state. ","> As I understand the actual problem is running failed test at the end of suite.\r\n> If you run\r\n> \r\n> ```\r\n> it('a)\r\n> it('b')\r\n> it('c')\r\n> ```\r\n> \r\n> And `b` fails, it will run `a -> b (failed) -> c -> b (retry)`\r\n> I do not understand why we have this ordering, `a -> b (failed) -> b (retry) -> c` should solve a lot of possible problems inside suite.\r\n\r\n\r\nThis is better than the current implementation, i.e. re-running the failed case before proceeding to the next in the suite. However, ideally you want the option to re-run the entire suite if any case fails. This is especially useful in an e2e test context, where the entire suite tests a general workflow, with each case in the suite potentially causing side-effects e.g. mutating data or state that impacts later test cases. The suite will generally have a `beforeAll` that sets up and ensures a clean state, with an `afterAll` that cleans up. \r\n\r\nSo you would want something akin to\r\n`beforeAll -> a -> b (failed) -> beforeAll -> a -> b -> c`\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","who ever sees this, I think jest is a unit testing tool, and we should no longer use jest for e2e tests;\r\nFor unit tests the results are always black and white, no so much with e2e tests;\r\n\r\nJest circus has test retry, but it will not retry any BeforeAll block.\r\nSupertest - super agent also has request retry, but the logging is appalling. (we'd never know if something was retried unless we proxy and monitor the requests)\r\n\r\nOverall just a bad experience so far trying to maintain e2e tests written ages ago using jest.\r\n\r\nI'd recommend anyone to just start using playwright, it worked great in one of my previous engagements.\r\n\r\nUPDATE 1: Some relief\r\nActually in jest ^26.6.1, we can use: npx jest --onlyFailures , which will do a retry of all the failed tests,\r\nI know, the OP wanted the config at a suite level, but this --onlyFailures offers something.\r\nIts just that I need to pass a custom config, so that original reports are not overwritten.","@vijay-zip - does your custom config allow you to run `--onlyFailures` without breaking coverage thresholds? It would be really helpful for us to be able to use the `--onlyFailures` flag in our CI jobs to speed up retrying a flaky test but we can't right now without triggering coverage failures.\r\n\r\nRight now I'm working around that with the following cli flag but it's brittle and hacky:\r\n`--collectCoverageFrom \"$(jq -r 'to_entries | map(select(.value[0] == 0)) | [.[].key]' .jest_cache\/perf* | tr '\\n' ' ' | sed 's\/.spec\/\/g' | sed 's|'\\\"${PWD}\\\"'|**|g')`\"`","For all interested parties, you may try out this add-on:\r\n\r\nhttps:\/\/github.com\/wix-incubator\/jest-retry-all-hooks\r\n\r\nIt monkey-patches `beforeAll` and `afterAll` hooks in a way that is more suitable for E2E tests.\r\n\r\ncc @oldwin, @robvree, @theseyi, @c0d3d, @pauldraper, @vijay-zip, @pierrebeitz, @sirdir, @WarpRat, @MuckT, @stkevintan \r\n","PR very much welcome adding support for this :+1:","@SimenB do you think this implementation makes sense for the official Jest? I guess that the original author of Circus had some vision about describe-level hooks vs. test-level hooks, and this change would discard the notion of describe-level hooks. What are your thoughts on what the correct behavior has to be?","I think we'd need a new option to `retryTimes` (maybe `entireDescribe: true` or some such) which attached it to the current `describe` rather than only rerunning failing tests."],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"Mocking more than one .svg file in a test does not work when using moduleNameMapper","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nWhen I try and mock more than two images in a test having a `moduleNameMapper` entry for the mocked file extension the last mock overrides the first mock.\r\n\r\n## To Reproduce\r\n- Add a `moduleNameMapper` to your package.json \r\n- Add a key with the file extension you are trying to mock in a test.\r\n- Import more than one image with the specified file extension in your code.\r\n- Mock more than one image with the same extension in a test file\r\n\r\nSteps to reproduce the behavior:\r\n\r\n\r\n``` js\r\n\/\/ static-resource.js\r\nconst image1 = require('.\/image1.png');\r\nconst image2 = require('.\/image2.png');\r\n\r\nmodule.exports = {\r\n  image1,\r\n  image2\r\n};\r\n```\r\n\r\n``` js\r\n\/\/ static-resource.spec.js\r\njest.mock('.\/image1.png', () => 'mocked-image-1.png')\r\njest.mock('.\/image2.png', () => 'mocked-image-2.png')\r\n\r\nconst {image1, image2} = require('.\/static-resource');\r\n\r\ntest('image 1 is loaded', () => {\r\n  expect(image1).toBe('mocked-image-1.png');\r\n});\r\n\r\ntest('image 2 is loaded', () => {\r\n  expect(image2).toBe('mocked-image-2.png');\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nEach mocked module\/image should be mocked and not be overwritten by any other mocks in the same test file.\r\n\r\n```\r\n PASS  .\/static-resource.spec.js\r\n  \u2713 image 1 is loaded (6ms)\r\n  \u2713 image 2 is loaded (1ms)\r\n```\r\n\r\n## Actual behavior\r\n\r\n```\r\n FAIL  .\/static-resource.spec.js\r\n  \u2715 image 1 is loaded (57ms)\r\n  \u2713 image 2 is loaded\r\n\r\n  \u25cf image 1 is loaded\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: \"mocked-image-1.png\"\r\n    Received: \"mocked-image-2.png\"\r\n\r\n       5 | \r\n       6 | test('image 1 is loaded', () => {\r\n    >  7 |   expect(image1).toBe('mocked-image-1.png');\r\n         |                  ^\r\n       8 | });\r\n       9 | \r\n      10 | test('image 2 is loaded', () => {\r\n\r\n      at Object.<anonymous> (static-resource.spec.js:7:18)\r\n```\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/repls\/WorthlessInfantileOctal\r\nhttps:\/\/github.com\/tjaartvanderWalt\/jest-issue-10458\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\nSystem:\r\n    OS: macOS 10.15.6\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz\r\n  Binaries:\r\n    Node: 10.19.0 - ~\/.nvm\/versions\/node\/v10.19.0\/bin\/node\r\n    Yarn: 1.21.1 - ~\/wave\/src\/next-wave\/node_modules\/.bin\/yarn\r\n    npm: 6.13.4 - ~\/.nvm\/versions\/node\/v10.19.0\/bin\/npm\r\n  npmPackages:\r\n    jest: 25 => 25.1.0\r\n```\r\n","comments":["Ran into this exact same issue.  I don't even have to pass in a valid file name.  As long as it has a valid file extension, all mocks with that same file extension get overwritten.","Any updates on this one? Happening too with .webp","Any updates?"],"labels":["Needs Triage","Bug Report"]},{"title":"jest.resetAllMocks also resets manual mocks","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\nCalling jest.resetAllMocks() resets manual mocks created via a _ _ mocks _ _ folder. I'm calling this a bug because it means there is no way to return to the original, manually mocked implementation. The manual mock is wiped out by resetAllMocks(); It also means that you can't easily mix and match manual mocks and the mockResolvedValue, mockValue, mockImplementation, etc. methods.\r\n\r\n## To Reproduce\r\n\r\nUse a manual mock, and call `jest.resetAllMocks()`\r\n\r\n## Expected behavior\r\n\r\nI expect the manual mock to be restored to its manually mocked state, and not to a blank mock.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nI couldn't create a _ _ mocks _ _ folder in repl.it, can upload a repo later if required.\r\n\r\n## envinfo\r\n\r\n```\r\nSystem:\r\n    OS: macOS 10.15.5\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-5287U CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 12.18.1 - ~\/.nvm\/versions\/node\/v12.18.1\/bin\/node\r\n    npm: 6.14.7 - ~\/.nvm\/versions\/node\/v12.18.1\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.2.2 => 26.3.0 \r\n```\r\n","comments":["Your sentence *\"there is no way to return to the original, manually mocked implementation\"* sums it all. I've spent hours playing with clearAllMocks, resetAllMocks, restoreAllMocks, resetModules trying to find a clean solution. There are none.\r\n\r\nIn my opinion this is what you would expect from restoreAllMocks instead of [\"only works when the mock was created with jest.spyOn\"](https:\/\/jestjs.io\/docs\/en\/26.5\/jest-object#jestrestoreallmocks).\r\n\r\nWhat's the point of having `__mocks__` if restoreAllMocks does not use it?\r\n\r\n```JavaScript\r\n\/\/ __mocks__\/npm-package.js\r\n\r\nexport const foo = jest.fn(() => 'original');\r\n```\r\n\r\n```JavaScript\r\n\/\/ mytest.test.js\r\n\r\nimport { foo } from 'npm-package';\r\n\r\n\/\/beforeEach(jest.restoreAllMocks);\r\n\r\ntest('original', () => {\r\n  expect(foo()).toEqual('original');\r\n});\r\n\r\ntest('override', () => {\r\n  foo.mockReturnValue('override');\r\n  expect(foo()).toEqual('override');\r\n});\r\n\r\ntest('original', () => {\r\n  jest.restoreAllMocks();\r\n  \/\/ FAIL\r\n  \/\/ restoreAllMocks\/resetAllMocks assigns jest.fn() to foo instead of using __mocks__\/npm-package.js\r\n  expect(foo()).toEqual('original');\r\n});\r\n```\r\n\r\nRelated:\r\n- https:\/\/stackoverflow.com\/questions\/49494744\/how-to-reset-manual-mocks-in-jest\r\n- https:\/\/github.com\/facebook\/jest\/issues\/5969#issuecomment-400161210\r\n- https:\/\/github.com\/facebook\/jest\/issues\/7068\r\n- https:\/\/stackoverflow.com\/a\/59792748","I agree with this sentiment. I could definitely use a way to reset back to the original mock. In my case I'm trying to mock the knex module. Currently I'm doing the following:\r\n\r\n```\r\n\/\/ __mocks__\/knex.js\r\nexport default {\r\n    select: jest.fn().mockReturnThis(),\r\n    from: jest.fn().mockReturnThis(),\r\n    where: jest.fn().mockReturnThis(),\r\n    whereNotNull: jest.fn().mockReturnThis(),\r\n    del: jest.fn().mockReturnThis(),\r\n    insert: jest.fn().mockReturnThis(),\r\n    into: jest.fn().mockReturnThis(),\r\n    orderBy: jest.fn().mockReturnThis(),\r\n    limit: jest.fn().mockReturnThis(),\r\n    first: jest.fn().mockReturnThis(),\r\n    then: jest.fn(function (done) {\r\n        done(null)\r\n    })\r\n}\r\n```\r\n\r\nWhen i override one of the properties to provide a specific value for my test I then cant reset it back to the original mock as iv lost the context of `this`.","see also https:\/\/github.com\/facebook\/jest\/issues\/7573 that's similar.\r\nStill no answer to this issue, I bumped into it again today :\/","I just wasted hours trying to figure out why my `__mocks__` weren't working... Turns out it was `resetMocks: true` in my `jest.config.js`...\r\n\r\nWhy would you ever want to reset manual mocks to essentially be an empty `jest.fn()`? I would expect resetting a manual mock would set it back to the state defined in the `__mocks__` module.\r\n\r\nAlso, this only seems to apply to manual mocks of user modules. Manual mocks of node modules seem to work fine with `resetMocks: true` in my Jest config... \ud83d\ude43","Just ran into this today. I can't find any function that would reset `jest.spyOn`, but restore the original manual `__mocks__`. It always just returns to default `jest.fn()`.\r\n\r\nI can work around by ordering the tests differently (yuck). This is just nasty.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Please don't close \ud83d\ude4f (I hate those bots)"],"labels":["Needs Triage","Bug Report"]},{"title":"Import should be case sensitive","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report :\r\nlet's say we have a module named: `Autosuggest`. and we want to mock it.\r\n```\r\nimport AutoSuggest from '.\/AutoSuggest' \/\/ the filename is Autosuggest.js (lower s)\r\njest.mock('.\/AutoSuggest', () => ({get : jest.fn(() => 1000)}));\r\n```\r\nif we import it with camel cases, like: `AutoSuggest`, it doesn't throw any error. it just let us to do it, and it allow us to mock it. but the mocking actually doesn't work this way.\r\n\r\nWhy it's important to fix :\r\nAfter one day of debugging about why mocking doesn't work, i fixed it with fixing the cases. so the problem is : it increases debug time.\r\n\r\n## Expected bahaviur :\r\n`jest.mock('.\/AutoSuggest')` should throw an error when there is a module called `.\/Autosuggest`, but there isn't any module called `.\/AutoSuggest`.\r\n","comments":["Agreed. I think it works on mac and windows since the FS is case insensitive but breaks correctly on linux. I haven't verified, tho!\r\n\r\nThis should be fixed somewhere in `jest-resolve`","I'm on a mac and I don't get an error for case errors","I'm on windows . so it doesn't throw error (the bug exists) on mac and windows. not sure about linux.\r\n( Just searched it and it seems some mac versions are case-sensitive, some are case-insensitive:\r\nhttps:\/\/qr.ae\/pN2IZB )","I've seen this before... In Window and MacOS are case-insensitive and Linux is case-sensitive.","@SimenB Can I work on this issue?","@SimenB is this issue avaliable can i give it a shot","Sure! All help is very much welcome \ud83d\ude42","@SimenB   I noticed the `ModuleMockerClass` in the jest-mock package handles mocking but how can i access the module-path `jest.mock(module-path)` in the class. If I am getting it wrong please guide me through\r\n","You shouldn't have to change anything in `jest-mock`, I think you'll want to change stuff in https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-resolve\/src\/index.ts","@SimenB after so much trial , i could not find a way to solve this issue, tried some technique and also tried installing some packages, still didn't work , i think this is not a jest issue but an issue with macOS and window due to its case insensitivity, but i'm still currently open to any suggestion ","Hi, I'd like to look into this too :)","I'm looking at `jest-resolve`'s `resolveModuleFromDirIfExists` (https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-resolve\/src\/index.ts#L136), which is called externally in the runtime's `_requireResolve` (https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-resolve\/src\/index.ts#L136). \r\n\r\nThat looks to me like the spot that resolves the path for any given module. Internally in `jest-resolve`, most functions talk about resolving Node modules... or is it a \"node\" in the more general sense? \ud83e\udd14 \r\n\r\n`jest-resolve`'s `resolve.test.ts` doesn't have any tests covering `resolveModuleFromDirIfExists` so OS case sensitivity isn't tested. I think that `resolveModuleFromDirIfExists` is the culprit so going to try to fix it and add appropriate tests. ","@ya3ya6 how did Jest behave when you had the incorrect casing? Unfortunately neither of the 2 machines available to me are case-sensitive","After I made my PR, I realized that while it helps out people on case-insensitive machines, it doesn't address anything for people on case-sensitive machines. So I'm looking at it again. \r\n\r\nI've been trying to mock `graceful-fs` so that I can mock returns from each type of file system, but the mocking isn't working. I tried to set it up like the test for `nodeModulesPaths` (https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-resolve\/src\/__tests__\/resolve.test.ts#L273) but I just found out that one doesn't work either, it still loads the real `graceful-fs`, so maybe it hasn't worked for a while and has been giving false positives in the tests? \r\n* EDIT: funnily enough there's a mistake in casing in the mock for the `nodeModulesPaths` test, it was creating a mock for `realPathSync` instead of `realpathSync`. Once that's corrected, it correctly goes into the mock, and the tests still pass. I'll commit that in my changes. \r\n\r\nI also tried mocking ~~`tryRealPath`~~`tryRealpath` itself, but no luck there either. I set it up the same way as the watch tests (https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-core\/src\/__tests__\/watch.test.js#L115). \r\n\r\nAny suggestions at this point are welcome. As long as I can get to mock the behavior of both case-sensitive and -insensitive file systems, the bug shouldn't be too hard to fix. \r\n\r\n@SimenB do you have any ideas? Thank you!\r\n\r\n* EDIT 2: I've tried several ways to mock either `graceful-fs` or `tryRealpath`, but no luck. Here is what I've tried: \r\n  * resolve.test.ts\r\n    * mock `graceful-fs`. But it can't be mocked correctly because the compiled JS caches its data the first time it fetches it, and when running the `resolveModule()` test, it happens to get called some other times, resulting in the real `graceful-fs` module being cached within the JS one.\r\n    * mock `jest-util`, overwriting just `tryRealpath`. No go.\r\n    * mock `jest-util\/build\/tryRealpath`. I couldn't find a way to call either the TS or JS version of `tryRealpath`. \r\n    * mock `graceful-fs` but in a `beforeEach` that executes just for my new tests. Still nothing.\r\n  * resolve.test.js\r\n    * mock `graceful-fs`. But same issue\r\n    * mock `jest-util`, no luck\r\n    * mock `jest-util\/build\/tryRealpath`. Same problem :(\r\n    * mock `graceful-fs` but in a `beforeEach` that executes just for my new tests. Same nothing\r\n  * Sort of at my wit's end at this point... if only the compiled JS of `tryRealpath` didn't cache the result of the pre-mock `require('graceful-fs')`. ","Set up a Linux VM and tested the case of trying to mock a module but with incorrect casing, so that I could see how Jest behaved. It throws the `Cannot find module '${moduleName}' from '${relativePath}'` error.\r\n\r\nI've made some changes in my local branch so that in this scenario, it still throws this error but also appends a list of similarly named modules. In the OP's case, it would look like this: \r\n```\r\nCannot find module 'AutoSuggest' from 'src'. Did you mean to import one of: Autosuggest.js?\r\n```\r\n\r\nFeel free to suggest a better messaging :)\r\n\r\nI still don't have a way of unit testing it though. Ideas on how to do so are welcome!\r\n\r\nEDIT: lol... suddenly remembered that you can mock anything and everything. Wrote some tests that simulate the behavior of case-sensitive and case-insensitive file systems and pushed my changes. ","I think the PR is in a good state now (https:\/\/github.com\/facebook\/jest\/pull\/10794), and the tests are all passing :)\r\n\r\nSummarizing what I've implemented in the PR, here is what you see on a case-sensitive file system: \r\n![image](https:\/\/user-images.githubusercontent.com\/1223518\/99099803-f334f680-25a8-11eb-8f88-ac6e6fad93b3.png)\r\n\r\nAnd on a case-insensitive file system: \r\n![image](https:\/\/user-images.githubusercontent.com\/1223518\/98459810-4bfd2d00-216c-11eb-9144-da8a0f3d2f22.png)\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","We have hit this issue in one of our projects. We had files called `Priority.tsx` and `priority.ts` in the same directory, that lead to Jest crashing with a cryptic error. Renaming one of the files did the trick.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":bug: Bug","Help Wanted","Pinned"]},{"title":"Jest mocks calls are not recording object parameters as copies, but references, which results in bad assertions, when the object mutates later.","body":"#10373  \ud83d\udc1b Bug Report\r\n\r\nWhen asserting multiple calls to the same mock function using objects as parameters to the mock function, Jest will not record the values of the object as they were at the moment of the call, but only the reference to the object.\r\n\r\nWhen tested code mutates the object after the call, it will also mutate the recorded calls within Jest, resulting in failing tests, that should be green.\r\n\r\n## To Reproduce\r\n\r\nUsing Jest 26.2.2, consider this test:\r\n```\r\nlet doingSomething = jest.fn();\r\n\r\nfunction myFunction() {\r\n    let myParam = { myField: 'testValue' };\r\n    doingSomething(myParam);\r\n    myParam.myField = 'differentValue';\r\n    doingSomething(myParam);\r\n}\r\n\r\ndescribe('something', () => {\r\n    test('should work',  () => {\r\n        myFunction();\r\n        expect(doingSomething).toBeCalledTimes(2);\r\n\r\n        \/\/ this assert will fail, because myField == 'differentValue', even though it shouldn't:\r\n        expect(doingSomething).toHaveBeenNthCalledWith(1, { myField: 'testValue' }); \r\n\r\n        \/\/ this is okay:\r\n        expect(doingSomething).toHaveBeenNthCalledWith(2, { myField: 'differentValue' });\r\n    });\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nBoth expects should be green, since the object parameter was correct at the time of the first call.\r\n","comments":["Hello @marcelb \r\n\r\nI don't think it's a bug. This is how JavaScript programming language works with object and other mutable objects.\r\n\r\nHere you can find other approach to the same problem: https:\/\/codesandbox.io\/s\/practical-water-26cf0x?file=\/main.test.js \r\n\r\n```js\r\nlet doingSomething = jest.fn();\r\n\r\nfunction myFunction() {\r\n  let myParam = { myField: \"testValue\" };\r\n  doingSomething(myParam);\r\n  myParam.myField = \"differentValue\";\r\n  doingSomething(myParam);\r\n}\r\n\r\ndescribe(\"something\", () => {\r\n  beforeEach(() => {\r\n    doingSomething.mockReset();\r\n  });\r\n\r\n  test(\"should realy work\", () => {\r\n    let calledTimes = 0;\r\n    doingSomething.mockImplementation((myParam) => {\r\n      calledTimes++;\r\n      switch (calledTimes) {\r\n        case 1:\r\n          expect(myParam).toEqual({ myField: \"testValue\" });\r\n          break;\r\n        case 2:\r\n          expect(myParam).toEqual({ myField: \"differentValue\" });\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n    });\r\n\r\n    myFunction();\r\n    expect(doingSomething).toBeCalledTimes(2);\r\n  });\r\n\r\n  test(\"should NOT work\", () => {\r\n    myFunction();\r\n    expect(doingSomething).toBeCalledTimes(2);\r\n\r\n    \/\/ this assert will fail, because myField == 'differentValue', even though it shouldn't:\r\n    expect(doingSomething).toHaveBeenNthCalledWith(1, { myField: \"testValue\" });\r\n\r\n    \/\/ this is okay:\r\n    expect(doingSomething).toHaveBeenNthCalledWith(2, {\r\n      myField: \"differentValue\"\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n\r\nTo better understand this problem you can imagine what is happening in similar pure js example:\r\n\r\n```js\r\n\r\n\/\/ VERY simple ala jest.fn\r\nfunction makeMockFn () {\r\n  const callHistory = []\r\n\r\n  const mockedFn = (...args) => {\r\n    callHistory.push(args)\r\n  }\r\n\r\n  \/\/ helper to get function call history\r\n  mockedFn.getCallHistory = () => callHistory\r\n\r\n  return mockedFn\r\n}\r\n\r\n\/\/ creating ala jest.fn()\r\nconst fn = makeMockFn()\r\n\r\n\/\/ create params to pass to fn\r\nconst myParams = { a: 1, b: 2 }\r\n\r\n\/\/ running fn\r\nfn(myParams)\r\nfn('string')\r\nfn(123456)\r\n\r\n\/\/ check what we have in call history\r\nconsole.log(fn.getCallHistory())\r\n\r\n\/\/ lets mutate myParams\r\nmyParams.a = 'CHANGED a key'\r\n\r\n\/\/ try to run fn\r\nfn(myParams)\r\n\r\n\/\/ check what happen with first and last position of history array\r\nconsole.log(fn.getCallHistory())\r\n```","There are earlier reference to the same underlying issue in #434 and #429.\r\n\r\nA simple approach would be to support cloning the parameters for specific calls where this is a known issue due to the implementation (called out here: https:\/\/github.com\/jestjs\/jest\/issues\/434#issuecomment-416859519)\r\n\r\nSome other comments have said that its not good practice to mutate the objects in the code, however, I think a testing framework shouldn't be pushing a particular coding practice.\r\n\r\nAn overall better approach IMHO is that of sinon where the mock is set to expect certain values, or support for conditional mocking could be used also."],"labels":["Needs Triage","Bug Report"]},{"title":"Expose matchers in expect.extend","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nExpose existing matchers inside `expect.extend`.\r\n\r\n## Motivation\r\n\r\nSometimes you want the existing functionality of a matcher but you want to it to transform the input before doing so, for instance, to ignore some specific keys of an object.\r\n\r\nWriting a custom matcher is extremely verbose and requires importing additional packages to maintain the same quality of the core matchers (diff in messages).\r\n\r\nFor example, if I want a matcher that performs `toEqual` on two objects but ignores a single property on those objects:\r\n\r\n```js\r\nexpect.extend({\r\n  toEqualDesign(recieved, expected, extraMatchers = []) {\r\n    const recievedDesign = { ...recieved, change: null };\r\n    const expectedDesign = { ...expected, change: null };\r\n    const pass = this.equals(recievedDesign, expectedDesign, extraMatchers);\r\n\r\n    \/\/ Duplicated from jest.\r\n    \/\/ https:\/\/github.com\/facebook\/jest\/blob\/f3dab7\/packages\/expect\r\n    \/\/ \/src\/matchers.ts#L538-L569\r\n    \/* eslint-disable *\/\r\n    const matcherName = 'toEqualDesign';\r\n    const options = {\r\n      comment: 'design equality',\r\n      isNot: this.isNot,\r\n      promise: this.promise,\r\n    };\r\n    const message = pass\r\n      ? () =>\r\n          matcherHint(matcherName, undefined, undefined, options) +\r\n          '\\n\\n' +\r\n          `Expected: ${printExpected(expectedDesign)}\\n` +\r\n          `Received: ${printReceived(recievedDesign)}`\r\n      : () => {\r\n          const difference = diff(expectedDesign, recievedDesign, {\r\n            expand: this.expand,\r\n          });\r\n\r\n          return (\r\n            matcherHint(matcherName, undefined, undefined, options) +\r\n            '\\n\\n' +\r\n            (difference && difference.includes('- Expect')\r\n              ? `Difference:\\n\\n${difference}`\r\n              : `Expected: ${printExpected(expectedDesign)}\\n` +\r\n                `Received: ${printReceived(recievedDesign)}`)\r\n          );\r\n        };\r\n\r\n    return {\r\n      actual: recievedDesign,\r\n      expected: expectedDesign,\r\n      message,\r\n      name: matcherName,\r\n      pass,\r\n    };\r\n  },\r\n});\r\n```\r\n\r\n## Example\r\n\r\n```js\r\nreturn expect.extend({\r\n  toEqualDesign(recieved, expected, ...args) {\r\n    const recievedDesign = { ...recieved, change: null };\r\n    const expectedDesign = { ...expected, change: null };\r\n    return {\r\n      ...this.matchers.toEqual(recievedDesign, expectedDesign, ...args)\r\n      name: 'toEqualDesign',\r\n    };\r\n  },\r\n});\r\n```\r\n\r\nand then:\r\n\r\n```js\r\nexpect(a).toEqualDesign(b);\r\nexpect(a).not.toEqualDesign(b);\r\n```\r\n\r\n## Pitch\r\n\r\nI am aware this has been asked for before:\r\n- https:\/\/github.com\/facebook\/jest\/issues\/2547\r\n\r\nThe response was to use `expect.extend` and I do not think it considers these cases where using `expect.extend` as it stands is not only massively inconvenient upfront for such a simple comparison but creates longer term debt having to maintain the matcher, whereas leveraging the return value of a core matcher allows your matcher to benefit from the continued maintenance of it in the jest core, e.g., if it gets improved messages or the already very verbose matcher return API changes.\r\n\r\nThis proposal is to enable the ability to write matchers that don't want to introduce new matching behaviour but want to transform their inputs before matching.\r\n\r\nOther alternatives include:\r\n\r\n```js\r\nexpectToEqualDesign(a, b) {\r\n   expect({ ...a, change: null }).toEqual({ ...b, change: null });\r\n}\r\n```\r\n\r\nYou then have to handle `not` yourself by either making separate functions or flagging it:\r\n\r\n```js\r\nexpectToEqualDesign(a, b, { not: false } = {}) {\r\n   let expectation = expect({ ...a, change: null });\r\n   if (not) {\r\n       expectation = expectation.not;\r\n   }\r\n   expectation.toEqual({ ...b, change: null });\r\n}\r\n```\r\n\r\nWhich will work, but now requires you to know an entirely different syntax because of a slight difference to the matcher.","comments":["I ended up here from #2547, and @SimenB you'd asked for use cases in that one (...admittedly ~3 years ago :-D), but similar to @georeith I want to make a custom matcher that a) accepts args, b) does some pre-processing, and then c) hands off to an existing matcher, in my case `toMatchObject` to leverage it's great out-of-the-box formatting\/diffing\/etc capabilities.\r\n\r\nBasically, in our project, the `actual` instance that is passed to my `expect(actual).toMatchObject({ ... })` has ugly implementation details that I want to clean up (almost like a `.toJSON` to get it to be \"just data\") for the `toMatchObject`.\r\n\r\nIn my case I'm using a `require` hack for now:\r\n\r\n```typescript\r\nexport async function toMatchEntity<T>(actual: Entity, expected: MatchedEntity<T>): Promise<CustomMatcherResult> {\r\n  \/\/ Clean up `actual` to be \"just data\"\r\n  const copy = ...project specific stuff...\r\n\r\n  \/\/ Blatantly grab `toMatchObject` from the guts of expect\r\n  const { getMatchers } = require(\"expect\/build\/jestMatchersObject\");\r\n\r\n  \/\/ Now use `toMatchObject` but with our \"just data\" version of `actual`\r\n  return getMatchers().toMatchObject.call(this, copy, expected);\r\n}\r\n```\r\n\r\nWith @georeith 's proposal, the `require` hack would go away and this could become:\r\n\r\n```typescript\r\nreturn expect.extend({\r\n  toMatchEntity(actual, expected) {\r\n    const copy = ...same clean up...;\r\n    return this.matchers.toMatchObject(copy, expected);\r\n  },\r\n});\r\n```\r\n\r\n","@stephenh This works great, I have been using a similar code for some time now and it's \ud83d\udcaf . However recently I have tried to do the same with `expect.objectContaining` have you had any success doing the same with these asymmetric matchers?","@bpinto hm, no, I haven't tried to re-use `objectContaining` yet, so I'm not sure how\/if it would be different.","Another vote for the core matchers to be exposed for use within custom matchers.\r\n\r\nIn my use case I'd like to write a db-based custom matcher `expect(original).toHaveBeenUpdatedTo({\u2026})`.\r\n\r\nInternally this would be\r\n\r\n```javascript\r\n\r\nimport { toMatchObject } from 'somewhere'\r\n\r\nexport const toHaveBeenUpdatedTo = async (original, match) => {\r\n  const updated = await getUpdatedFromDatabase(original)\r\n  return toMatchObject(updated, match)\r\n}\r\n```","that would be extremely helpful to be able to re-use existing matchers in custom matchers. ","This no longer works, and breaks with the error message:\r\n> `Cannot find module 'expect\/build\/jestMatchersObject' from '__tests__\/extend-expect.ts'`","See this PR: https:\/\/github.com\/facebook\/jest\/pull\/13375","This should be merged then ;)"," @mrazauskas until the PR is merged, I'd like to understand why the import does not work anymore. The file is there, why can't it be resolved?","Perhaps newer version of Node is taking into account `exports` while resolving paths?\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/836157f4807893bb23a4758a60998fbd61cb184c\/packages\/expect\/package.json#L12-L20","I also need this, I found these hacks to be working\r\n\r\n```js\r\nconst { matchers } = globalThis[Symbol.for('$$jest-matchers-object')];\r\n\r\n\/\/ or\r\nimport matchers from 'expect\/build\/matchers';\r\n\r\n\/\/ or\r\nconst matchers = require('expect\/build\/matchers').default;\r\n```\r\n","Ah wow, I'm trying out Jest v30.0.0-alpha.2 and the `import from expect\/build\/matchers` doesn't work anymore, but @davispuh 's `globalThis[$$jest-matchers-object]` does work! In both Jest v29 and Jest v30 :tada: . Thanks @davispuh ! \r\n\r\n"],"labels":[":rocket: Feature Request"]},{"title":"RunInBand as an object option. It exists as a CLI option","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nRunInBand as an object option.\r\n```\r\n{\r\n    runInBand: true\r\n}\r\n```\r\n## Motivation\r\n\r\nBecause its useful and provided for on the CLI as an option `--runInBand`, it makes sense that there would be an equivalent in the object specifier as well.\r\n \r\n## Example\r\n\r\nUses the existing `jest --config <configpath>`\r\n\r\n## Pitch\r\n\r\nBecause it is part of the CLI option set and very useful.\r\n\r\n","comments":["`runInBand` is especially useful to offer via `jest.config.js` and `jest.config.ts` since it helps prevent out-of-memory errors in CI environments, which can often be detected in a dynamic config file (e.g., via `process.env.CI == \"true\"`).","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I still think this is a good idea.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Ditto."],"labels":[":rocket: Feature Request"]},{"title":"Mock property descriptors\/values","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nProvide a mechanism for mocking non-function properties similarly to function mocking and handle them similarly to spies, particularly restoring:\r\n\r\n* `mockProperty` for restorable mocks of property descriptors\r\n\r\n* `mockPropertyValue` for transparent mocks with `value` or `get` descriptors, depending on original property\r\n\r\n## Motivation\r\n\r\n`jest.spyOn` provides a subset of functionality only for get\/set accessor descriptors, while making no distinction between accessors and regular values is a more common scenario for mocking. This is the case for third-party objects that require to be very aware of their implementation to mock them correctly, e.g. JSDOM implementation isn't tied to specs and may change with time, relying on internals makes tests unnecessarily fragile.\r\n\r\nFor properties that are known to not have exotic descriptors, although it may be safer to restore their descriptors regardless:\r\n\r\n```js\r\nlet origProperty;\r\n\r\nbeforeEach(() => {\r\n   origProperty = process.env.NODE_ENV;\r\n   process.env.NODE_ENV = 'prod';\r\n});\r\n\r\nafterEach(() => {\r\n   process.env.NODE_ENV = origProperty;\r\n});\r\n```\r\n\r\nFor properties that have descriptors with undetermined prototype chain:\r\n\r\n```js\r\nlet origDescriptor;\r\n\r\nbeforeEach(() => {\r\n    origDescriptor = Object.getOwnPropertyDescriptor(foo, 'bar');\r\n    \/\/ TODO: inherit from proto descriptor because it can matter\r\n    Object.defineProperty(foo, 'bar, { value: 'bar', configurable: true });\r\n});\r\n\r\nafterEach(() => {\r\n  if (!origDescriptor)\r\n    \/\/ own property\r\n    delete foo.bar;\r\n  else\r\n    \/\/ proto\r\n    Object.defineProperty(foo, 'bar', origDescriptor);\r\n});\r\n```\r\n\r\n## Example\r\n\r\nThis could be simplified to:\r\n\r\n```js\r\nbeforeEach(() => {\r\n  jest.mockPropertyValue(process.env, 'NODE_ENV', 'prod');\r\n  jest.mockProperty(foo, bar, { value: 'bar' });\r\n});\r\n\r\nafterEach(() => {\r\n   jest.restoreAllMocks();\r\n});\r\n```\r\n\r\n## Pitch\r\n\r\nFunction properties and property accessors are a special case that can be mocked with `spyOn` while the general case is not handled by the framework. Both are cumbersome to be handled manually and can benefit from being supported by the framework.\r\n\r\nProviding this feature as third-party library is not viable because it requires to monkey-patch Jest rather than extend it to support mock restoration via `jest.restoreAllMocks`. ","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","@github-actions It's not stale, bot","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","@github-actions It's not stale, bot","Did you try [`jest.replaceProperty()`](https:\/\/jestjs.io\/docs\/jest-object#jestreplacepropertyobject-propertykey-value)?","@mrazauskas That's a recent and timely addition I wasn't aware of, thanks for the notification. I'll check how it works with descriptors and prototypes","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"Make restoreMocks, resetMocks, clearMocks default","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nThe `restoreMocks`, `resetMocks`, and `clearMocks` settings should be enabled by default.\r\n\r\n## Motivation\r\n\r\nWe've spent a lot of time debugging tests due to mocks leaking behavior between tests. We added `jest.resetAllMocks()` to our test helper file a while back and that made a huge difference. But recently I discovered a lingering test spy was causing false positives in other tests that followed it. I also needed to add `jest.restoreAllMocks()`.\r\n\r\nI noticed there [are config options](https:\/\/jestjs.io\/docs\/en\/configuration.html#restoremocks-boolean), so then I moved them to our jest config. (Per #7068, `restoreAllMocks()` does *not* also `resetAllMocks()` as [the docs suggest](https:\/\/jestjs.io\/docs\/en\/mock-function-api#mockfnmockrestore).)\r\n\r\n## Pitch\r\n\r\nI think the common case would be for people to expect clean state between tests, and not having that by default might be causing a lot of confusion and false positives in tests. I'm not aware of a valid use case for *not* clearing\/restoring all mock state after each test. If there is, it seems like it's probably pretty rare, and could potentially be configured as needed.","comments":["I think it makes sense to set those to `true` by default. Super breaking, but as long as we call it out in the blog post I think that's fine.\r\n\r\n@jeysal @thymikee thoughts?","Not sure `true` is a good default. As soon as you have one test that needs to retain state, you need to set it to `false` again and change all other tests to manually reset. Also, mocks lose their initial implementations so you will need to do `mockImplementation` etc in a `beforeEach` hook or get highly confused why your `jest.fn().mockImplementation()` is being lost.",">  As soon as you have one test that needs to retain state\r\n\r\nWhat sort of state do you need to retain between tests? If anything, this seems like an anti-pattern to me. But if it's the sort of thing you know you're going to need, it seems like you're already going to have to deal with the issue of manually resetting as things are now.\r\n\r\n> mocks lose their initial implementations so you will need to do `mockImplementation` etc in a `beforeEach` hook\r\n\r\nThis actually seems like a good restriction to me. I don't know if it is information that can be inferred, but it would be super helpful if Jest were to warn or throw an error when something like `mockImplementation` was called outside of a test context like `it` or `beforeEach`.\r\n\r\n> highly confused why your `jest.fn().mockImplementation()` is being lost.\r\n\r\nWe've actually seen the inverse of this a lot, so changing the default is probably a wash at worst. Right now, when somebody overrides the `mockImplementation` in one of the tests they can lose a lot of time trying to figure out why a change in one test is suddenly causing a lot of later tests to act strangely.\r\n\r\nBottom line for me is that tests should be independent of each other and not have some persistent state between them that could impact whether they pass or fail. As much as possible, the test framework should ideally be configured in such a way to strongly encourage this. I'm still not sure if there are valid cases for persisting state across tests, but if there are, it seems like that should be the longer road to step around framework defaults.","I expected them to be Jest defaults when it emerged, at least clearMocks and restoreMocks. But now it seems a bit late to enable them. I agree this would be \"super breaking\". My suggestion is to make a soft transition, officially recommend `restoreMocks` and `clearMocks` and set them to `true` in newly generated `jest --init` configs, with default values remaining `false`. Not `resetMocks` for certain, it's destructive.\r\n\r\nclearMocks is a good thing that prevents tests from contaminating each other. This will break tests that were already badly written.\r\n\r\nrestoreMocks makes mocks in `beforeAll` and top-level spies invalid (that Jest favoured them for a long time is the sad reality):\r\n\r\n```\r\n\/\/ fetch accidentally starts to do real requests after first test\r\nspyOn(global, 'fetch').mockResolvedValue(...)\r\n\r\nbeforeAll(() => {\r\n  \/\/ same here\r\n  spyOn(global, 'fetch').mockResolvedValue(...)\r\n});\r\n```\r\n\r\nIt may be good but only for old-fashioned style with mandatory beforeEach (beforeAll wasn't initially available in Jasmine):\r\n\r\n```\r\nbeforeEach(() => {\r\n  spyOn(global, 'fetch').mockResolvedValue(...)\r\n});\r\n```\r\n\r\nAs for default resetMocks, it's worse. A big show stopper is that resetMocks ruins `___mocks___` that are supposed to provide reusable module mocks:\r\n\r\n```\r\nmodule.exports = {\r\n  \/\/ I don't want reset them, ever\r\n  foo: jest.fn().mockReturnValue('foo'),\r\n  bar: jest.fn(() => 'bar')\r\n};\r\n```","For reasons `bisubus` explained, `restoreMocks` and `resetMocks` can be quite destructive and I don't see them becoming a default.\r\nAs for `clearMocks`, which is somewhat widely used, while enabling it by default is very breaking, and even breakages with prior warning we want to keep to a minimum, I could imagine nudging people towards considering it for their project. This could be more hints to the config option where we're talking about mocks (I believe the `mockClear` docs already have this). It could also be a `--init` suggestion as suggested by @bisubus. Also given Simen's comment, I think that this kind of change would be pretty uncontroversial, so I think we'd welcome PRs for that.","I agree with making `clearMocks: true` the default, but it would also be nice to add the ability to override that for a given test suite, something like `jest.clearMocks(false)` at the top of a test suite, or inside a `describe` block. That would let it remain turned on even when a rare use-cases arises for not clearing mocks in a given suite\/decribe. This would address @jeysal's [comment](https:\/\/github.com\/facebook\/jest\/issues\/10242#issuecomment-653884274).","It would be really fantastic if `clearMocks` returned the mock to the state found after it was first configured. This seems like an achievable thing for manual mocks from `__mocks__`, and I burned a solid amount of time trying to figure out why the mock implementation I was setting wasn't around to be used when my test started running.","so are you saying @vcarl that `clearMocks` removes all implementation from mocks in __mocks__? That does not make any sense, those mocks should be protected. Only mocks modified inside tests should be reset.","That was 6 months ago, I don't recall the specifics of the situation anymore","Anyway, implementations done inside __mocks__ should **not** be reset under any circumstance.\r\n\r\nI fear there are a lot of seriously broken tests out there because of all of this strange default mock leaking behaviour of jest.","Maintaining mock state between tests is a footgun. So making `clearMocks` default to `true` makes a lot of sense to me \u2013 despite this being a breaking change. \r\n\r\n@SimenB are you still in favour of changing this?","Yes, this is a very breaking change, but I personally believe there is a fundamental issue here that warrants the change. IMO, it is far too easy to write buggy tests that give a false assurance of working _and tested_ software, due to subtle mock leakage between tests.\r\n\r\nEver had to modify unit tests and have to spend hours debugging why things broke when you made some chages, only to discover something was leaking, and a change of order or the existence of a new test was the cause? I have worked on dozens of codebases in the past several years and had this problem. It's a nightmare to debug and I wouldn't expect a trusted tool such as Jest to let me do slightly wild stuff like that, by default.\r\n\r\nI want to have high confidence that my tests are passing because they're testing what I expected it to, using the input and mocks I expected it to use. Even if my test code is more verbose and explicit.\r\n\r\nI hope @SimenB and @mrazauskas will consider this change once again","This change needs to happen to fix all the broken jest tests out there. The fallout may be massive but people currently don't know their tests, and by that, their code, is potentially broken. +1 for changing the defaults. Should increase major version for that to stay true to semver though.","Is there any further plan for this issue? It has been opened awhile"],"labels":[":rocket: Feature Request"]},{"title":"feat: Name test callbacks for profiling","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nAssign the test name to the test callback if the test callback is not named.\r\n\r\nNaively add before https:\/\/github.com\/facebook\/jest\/blob\/eff3eaaad2bde223365da6522cfac7960267fb46\/packages\/jest-circus\/src\/index.ts#L182\r\n\r\n```js\r\nlet actualName = testName;\r\nif (fn.name === \"\") {\r\n    Object.defineProperty(fn, 'name', {\r\n        get() {\r\n            return actualName\r\n        },\r\n        set(name) {\r\n            actualName = name\r\n        }\r\n    })\r\n}\r\n```\r\n## Motivation\r\n\r\nThe passed callback to e.g. `test('my test description', () => { \/* the callback *\/ })` is hard to find when profiling tests. Right now we have to explicitly name them via `test('my test description', function mySlowTest() { \/* the callback *\/ })`.\r\n\r\n## Example\r\n\r\n@kentcdodds encountered the same issue and made a video explaining the issue: https:\/\/www.youtube.com\/watch?v=RB2g-o39upo. \r\n\r\n## Pitch\r\n\r\nReduces barrier to entry into profiling jest tests. While I would consider naming functions a tool you should know about for profiling, I would always prefer to not change code when profiling\/debugging.","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Comment","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump","Yeah, I don't think this would hurt anything - happy to take a PR \ud83d\udc4d "],"labels":[":rocket: Feature Request"]},{"title":"Add ability to compare \"deep\" with precision","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nAdd the ability to compare two objects with a precision check.\r\nhttps:\/\/github.com\/maasencioh\/jest-matcher-deep-close-to This extension does the job but lacks a lot of the visibility that jest has when showing diffs. It would also just be cleaner if jest had this built in since this is a conceivably common issue.\r\n\r\n## Motivation\r\n\r\nOften times one will need to compare two objects that contain data. Because of floating point imprecision in Node.js, numbers don't always add up exactly as you expect them to (with ~e-13 points of precision difference). Tests will sometimes need to compare objects for equality but allow for some margin of error.\r\n\r\n## Example\r\n\r\nhttps:\/\/github.com\/maasencioh\/jest-matcher-deep-close-to does a good job showing this in the README","comments":["Bump on this, this would be huge","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump","Bump on this"],"labels":[":rocket: Feature Request"]},{"title":"Add test.result(testName) to get results","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nThis is a more concrete version of #5823, with a working prototype. I'm opening it to increase visibility; if this stil counts as a duplicate I apologize, please close but please consider this option.\r\n\r\n## Motivation\r\n\r\nIt is hard to write tests for an expensive operation that requires many steps. It would be great if individual steps could be written as tests and a dependency on other tests expressed.\r\n\r\n## Example\r\n\r\nI'd like to propose this API, getting a return value from `test` and friends which can be called to get the test result; as a side effect it can await Promises:\r\n\r\n```js\r\n\/\/ this test is synchronous\r\ntest('gets config', () => {\r\n  const config = readConfig()\r\n  expect(config).toHaveProperty('enabled', true)\r\n  return config\r\n})\r\n\r\n\/\/ this test is asynchronous\r\ntest('can create', async () => {\r\n  const config = test.result('gets config')  \/\/ sync\r\n  const thing = await makeThing()\r\n  expect(thing).toBeTruthy()\r\n  return thing\r\n})\r\n\r\ntest('can doFoo', async () => {\r\n  const thing = await test.result('can create') \/\/ async\r\n  await thing.doFoo()\r\n  expect(thing.didFoo).toBeTruthy()\r\n})\r\n\r\ntest('can doBar', async () => {\r\n  const thing = await test.result('can create')\r\n  await thing.doBar()\r\n  expect(thing.didBar).toBeTruthy()\r\n})\r\n```\r\n\r\nNow, if you only run the `'can doBar'` test, it will actually run `'gets config'` and then `'can create'` first, and error out if those fail.\r\n\r\n## Pitch\r\n\r\nIt's a very intuitive interface fitting right in with the rest of the API. It makes it easy to express dependencies, and if you don't use it, there's no change.\r\n\r\n## Prototype\r\n\r\nI put this in a file and import it at the beginning of a test file. It works great, but it won't detect dependency loops, and if you only run a single test, then the tests it runs for dependencies won't count as the tests that ran. To fix those, it would need integration into Jest.\r\n\r\n```js\r\n\/\/ https:\/\/github.com\/facebook\/jest\/issues\/5823\r\nclass TestError extends Error {\r\n\tconstructor(title, error) {\r\n\t\tsuper(title)\r\n\t\tif (error instanceof TestError) {\r\n\t\t\t\/\/ A dependency threw this\r\n\t\t\tthis.message = error.deep\r\n\t\t\t\t? error.message\r\n\t\t\t\t: `Dependency \"${error.title}\" failed`\r\n\t\t\tthis.stack = null\r\n\t\t\tthis.deep = true\r\n\t\t} else {\r\n\t\t\tthis.message = `test \"${title}\" failed: ${error.message}`\r\n\t\t\tthis.stack = error.stack\r\n\t\t\tthis.title = title\r\n\t\t}\r\n\t}\r\n}\r\nconst origTest = global.test\r\nconst origDescribe = global.describe\r\nconst runners = {}\r\nlet prefix = ''\r\nglobal.describe = (name, fn) => {\r\n\tconst prev = prefix\r\n\tprefix = `${prefix}${name} | `\r\n\torigDescribe(name, fn)\r\n\tprefix = prev\r\n}\r\n\r\nglobal.test = (title, fn) => {\r\n\tconst name = `${prefix}${title}`\r\n\tlet alreadyRan = false\r\n\tlet result = undefined\r\n\tlet fnError = undefined\r\n\tconst handleError = (error, saveError) => {\r\n\t\tconst newError = new TestError(name, error)\r\n\t\tif (saveError) fnError = newError\r\n\t\tthrow newError\r\n\t}\r\n\r\n\tconst runFnOnce = () => {\r\n\t\tif (alreadyRan) {\r\n\t\t\tif (fnError) throw fnError\r\n\t\t\telse return result\r\n\t\t}\r\n\t\talreadyRan = true\r\n\t\ttry {\r\n\t\t\tresult = fn()\r\n\t\t} catch (err) {\r\n\t\t\t\/\/ synchronous error\r\n\t\t\thandleError(err, true)\r\n\t\t}\r\n\t\t\/\/ async error\r\n\t\tif (result?.catch) result = result.catch(err => handleError(err, false))\r\n\t\treturn result\r\n\t}\r\n\trunners[name] = runFnOnce\r\n\torigTest(title, runFnOnce)\r\n\treturn runFnOnce\r\n}\r\n\/\/ add .each etc\r\nObject.assign(test, origTest)\r\ntest.result = title => {\r\n\tif (runners[title]) return runners[title]()\r\n\telse {\r\n\t\tconst msg = `test.result(title): unknown test \"${title}\". Known:\\n${Object.keys(\r\n\t\t\trunners\r\n\t\t).join('\\n')}`\r\n\t\tthrow new Error(msg)\r\n\t}\r\n}\r\n```","comments":["@SimenB if I were to make a PR that implements this, would it have a chance of being merged?","Hi!\r\n\r\nI think marking a dependency _inside_ of another test would mean we'd still have to run it, then bail with a special error. Some API where the dependency is marked as part of the test declaration is needed, I think...\r\n\r\nAlso, how would this work with concurrent tests? Still experimental, but still","Hi @SimenB :)\r\n\r\nthe dependency is handled the way you describe and it should work correctly with concurrent tests. Here's my latest version:\r\n\r\n```js\r\n\/\/ https:\/\/github.com\/facebook\/jest\/issues\/5823\r\nclass TestError extends Error {\r\n\tconstructor(title, error) {\r\n\t\tsuper(title)\r\n\t\tif (error instanceof TestError) {\r\n\t\t\t\/\/ A dependency threw this\r\n\t\t\tthis.message = error.deep\r\n\t\t\t\t? error.message\r\n\t\t\t\t: `Dependency \"${error.title}\" failed`\r\n\t\t\tthis.stack = ' ' \/\/ truthy empty error\r\n\t\t\tthis.deep = true\r\n\t\t} else {\r\n\t\t\tthis.message = `test \"${title}\" failed: ${error.message}`\r\n\t\t\tthis.stack = error.stack\r\n\t\t\tthis.title = title\r\n\t\t}\r\n\t}\r\n}\r\nconst origTest = global.test\r\nconst origDescribe = global.describe\r\nconst runners = {}\r\nlet prefix = ''\r\nglobal.describe = (name, fn) => {\r\n\tconst prev = prefix\r\n\t\/\/ Note, using async local storage, this could be used automatically\r\n\tprefix = `${prefix}${name} | `\r\n\torigDescribe(name, fn)\r\n\tprefix = prev\r\n}\r\n\r\nglobal.test = (title, fn) => {\r\n\tconst name = `${prefix}${title}`\r\n\tlet alreadyRan = false\r\n\tlet result = undefined\r\n\tlet fnError = undefined\r\n\tconst handleError = (error, saveError) => {\r\n\t\tconst newError = new TestError(name, error)\r\n\t\tif (saveError) fnError = newError\r\n\t\tthrow newError\r\n\t}\r\n\r\n\tconst runFnOnce = () => {\r\n\t\tif (alreadyRan) {\r\n\t\t\tif (fnError) throw fnError\r\n\t\t\telse return result\r\n\t\t}\r\n\t\talreadyRan = true\r\n\t\ttry {\r\n\t\t\tresult = fn()\r\n\t\t} catch (err) {\r\n\t\t\t\/\/ synchronous error\r\n\t\t\thandleError(err, true)\r\n\t\t}\r\n\t\t\/\/ async error\r\n\t\tif (result?.catch) result = result.catch(err => handleError(err, false))\r\n\t\treturn result\r\n\t}\r\n\trunners[name] = runFnOnce\r\n\torigTest(title, runFnOnce)\r\n\treturn runFnOnce\r\n}\r\n\/\/ add .each etc\r\nObject.assign(test, origTest)\r\ntest.result = title => {\r\n\tif (runners[title]) return runners[title]()\r\n\telse {\r\n\t\tconst msg = `test.result(title): unknown test \"${title}\". Known:\\n${Object.keys(\r\n\t\t\trunners\r\n\t\t).join('\\n')}`\r\n\t\tthrow new Error(msg)\r\n\t}\r\n}\r\n```\r\n\r\nand a types.d.ts file to match:\r\n```js\r\ndeclare namespace jest {\r\n\tinterface It {\r\n\t\tresult: (testName: string) => any\r\n\t}\r\n}\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still interested in this","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","@SimenB any chance of this?"],"labels":[":rocket: Feature Request"]},{"title":"jest.mock does not mock an ES module without Babel","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nIn an ES module Node project, with no Babel, `jest.mock` works when the mocked module is a `node_modules` package that exports CommonJS, but it isn't working for me mocking an ES module exported from a file in the same project.\r\n\r\n(It's possible that an NPM package that only exports ES modules has the same issue. I didn't try that case.)\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nClick Run in the repl, or here's a simple example:\r\n\r\n```js\r\n\/\/ main.js\r\nimport secondary from \".\/secondary.js\";\r\n\r\nexport default function main() {\r\n  return secondary();\r\n}\r\n\r\n\/\/ secondary.js\r\nexport default function secondary() {\r\n  return true;\r\n}\r\n\r\n\/\/ test.js\r\nimport { jest } from \"@jest\/globals\";\r\n\r\njest.mock(\".\/secondary.js\");\r\n\r\nlet main;\r\nlet secondary;\r\nbeforeAll(async () => {\r\n  ({ default: main } = await import(\".\/main.js\"));\r\n  ({ default: secondary } = await import(\".\/secondary.js\"));\r\n});\r\n\r\ntest(\"works\", () => {\r\n  secondary.mockReturnValueOnce(false); \/\/ TypeError: Cannot read property 'mockReturnValueOnce' of undefined\r\n  expect(main()).toBe(false);\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\n`jest.mock(filename)` should mock the exports from `filename` when the test file and the Node project are both ES modules (`type: \"module\"`)\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/repls\/VerifiableOfficialZettabyte\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: macOS 10.15.4\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-4278U CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 12.16.3 - ~\/.nvm\/versions\/node\/v12.16.3\/bin\/node\r\n    Yarn: 1.21.1 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.4 - ~\/DevProjects\/reaction\/api-utils\/node_modules\/.bin\/npm\r\n  npmPackages:\r\n    jest: ^26.0.1 => 26.0.1 \r\n```\r\n","comments":["Copied from https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-625418195 at the request of @SimenB. Thanks!","I respectfully disagree with this being labeled a feature request. It's entirely blocking of any effort to move to Jest native ES module support if any files have mocks in them, and there is no workaround that I know of (other than to continue using CommonJS through Babel, which means that ES module support is broken, hence bug).","I started working on this, and I think it makes sense to leave `.mock` and `.doMock` for CJS, and introduce a new `.mockModule` or something for ESM. It will require users to be explicit, and allow the factory to be async. Both of which I think are good things.\r\n\r\nAlso need to figure out `isolateModules`. Unfortunately it uses the `module` name while not being for ES modules.\r\n\r\n@thymikee @jeysal thoughts?","@aldeed @SimenB Hello, I'm also having the same problem, but when I try to use jest with babel instead, I'm running into `SyntaxError: Cannot use import statement outside a module` (it throws inside an imported module), which is basically what #9430 is all about I guess.\r\n\r\nIs there any workaround to mock modules from the same project? Or to prevent the `SyntaxError` from occurring when using babel .","@guilhermetelles It can be a pain to do, but you'll likely get more help if you create a public minimal reproduction repo for your issue and create a new GH issue that references this one. There are about a dozen things that could cause this issue, from using an older Node version to Babel config issues, and being able to see all the project files is the best way for someone to help you solve it.\r\n\r\n@SimenB You mentioned above that you had a start on this and it looks like everyone \ud83d\udc4d your proposal. Is there any update?","One thing to note is that it will be impossible to mock `import` statements as they are evaluated before any code is executed - which means it's not possible to setup any mocks before we load the dependency. So you'll need to do something like this using `import` expressions.\r\n\r\n```js\r\nimport { jest } from '@jest\/globals';\r\n\r\njest.mockModule('someModule', async () => ({ foo: 'bar' }));\r\n\r\nlet someModule;\r\n\r\nbeforeAll(async () => {\r\n  someModule = await import('someModule');\r\n});\r\n\r\ntest('some test', () => {\r\n  expect(someModule.foo).toBe('bar');\r\n});\r\n```\r\n\r\nIt will be a bit cleaner with top-level `await`\r\n\r\n```js\r\nimport { jest } from '@jest\/globals';\r\n\r\njest.mockModule('someModule', async () => ({ foo: 'bar' }));\r\n\r\nconst someModule = await import('someModule');\r\n\r\ntest('some test', () => {\r\n  expect(someModule.foo).toBe('bar');\r\n});\r\n```\r\n\r\nAny modules loaded by `someModule` via `import` statements would work though as we'd have time to setup our mocks before that code is evaluated.\r\n\r\n---\r\n\r\nThe example in the OP follows this pattern, I'm just pointing it out \ud83d\udc4d ","@SimenB this is my first comment in this repo, so the first words unambiguously look like - **great work**!\r\n\r\nWe're in one step from transitioning of our infrastructure into ESM. The only things left are tests. We're planning to actively use top level await in our code base and there is an obstacle because we're ready to compile our code to ESNext (in terms of TS) but most of our tests use `jest.mock()` somehow and I want to understand the current state of affairs.\r\n\r\nAfter closing #9860 by #10823 there is one important topic left considering original list in #9430 - support of `jest.(do|un)mock` (OK, to be honest, probably there is another one - Package Exports support).\r\n\r\nCan You explain the current status of the issue?! I mean:\r\n- Do we have a mechanism to use `jest.mock` (`jest.mockModule`?) with ESM now? (probably using `27.0.0-next.x`?) And if so - can you provide a short working example?\r\n- If not - do you plan to release this or similar functionality in 27.0? And do you have a proposal? (`jest.mockModule` or ...?)\r\n\r\nThanks in advance.","I want to add `jest.mockModule`, but since that's a new API and not a breaking change it might not go into Jest 27 at release. A PR would be very much welcome, but it's getting into some of the nitty gritty of `jest-runtime` so I understand if people are a bit hesitant to attempt it \ud83d\ude42 ","As a status update, I've opened up a PR here: #10976","@SimenB before your PR gets merged, what is the work-around solution here?","@anshulsahni no workaround, apart from rewriting your code to not use mocking for the moment with the esm modules","yeah, there is not workaround if you wanna use native ESM until that lands","right now I'm using babel & it's configured to only convert esm modules. So the whole app runs in esm modules but tests run with commonjs module system","yep, that'll keep working","I'm looking forward for this feature \ud83d\udc4d ","> right now I'm using babel & it's configured to only convert esm modules. So the whole app runs in esm modules but tests run with commonjs module system\r\n\r\nyou can show me your config please? my apps runs in esm modules and I need run my test with commonjs modules","> @anshulsahni no workaround, apart from rewriting your code to not use mocking for the moment with the esm modules\r\n\r\none quasi work around is to use rushstack's heft tool to compile your ts. They allow a secondary emit target so you can emit cjs and esm but with only one compiler pass. pretty slick way to handle it until this is supported if you ask me.\r\n\r\nhttps:\/\/rushstack.io\/pages\/heft_configs\/typescript_json\/","marked","There **IS** (sometimes) a workaround, but it requires you to go about things in a very specific way:\r\n\r\n<details>\r\n<summary>outdated: there's a better way (below)<\/summary>\r\n\r\n```js\r\n\/\/ babyMaker.mjs\r\n\r\nimport * as cp from 'child_process';\r\n\r\nexport default function babyMaker() {\r\n  cp.default.fork(\/* \u2026 *\/);\r\n}\r\n```\r\n\r\n```js\r\n\/\/ babyMaker.test.js\r\n\r\nimport babyMaker from '.\/implementation.mjs';\r\nimport * as cp from 'child_process';\r\n\r\nbeforeAll(() => {\r\n  cp.default.fork = jest.fn(() => ({});\r\n});\r\n```\r\n\r\nIn the above, `cp.default.fork` is a mock that returns an empty object.\r\n\r\nNote that `cp.fork` cannot be mocked this way because it is a direct export (which ESM protects), and even when `cp.default.fork` _is_ mocked, `cp.fork` still is NOT because `cp.default.fork` has been re-assigned to the mock; its original value  (the named export `fork`) is unaffected. Under the hood, the child_process module is doing something like\r\n\r\n```js\r\nexport function fork() {}\r\n\r\nexport default {\r\n  fork,\r\n  \/\/ \u2026others\r\n};\r\n```\r\n\r\nNote that child_process _is_ CJS under the hood, but that doesn't matter: `export default {\u2026}` works from ESM because the default export is an object whose properties are not protected.\r\n<\/details>\r\n\r\n```js\r\n\/\/ foo.mjs\r\n\r\nfunction bar() {\r\n  \/\/ \u2026\r\n}\r\n\r\nexport default {\r\n  bar,\r\n};\r\n```\r\n\r\n```js\r\n\/\/ qux.mjs\r\n\r\nimport foo from 'foo.mjs';\r\n\r\nexport default qux() {\r\n  const something = foo.bar();\r\n\r\n  \/\/ \u2026\r\n}\r\n```\r\n\r\n```js\r\n\/\/ qux.test.mjs\r\n\r\nimport { jest } from '@jest\/global';\r\n\r\n \/\/ MUST be imported BEFORE qux\r\nconst foo = await import('foo.mjs')\r\n  .then(({ default: foo }) => Object.defineProperties(foo, {\r\n    bar: { value: jest.fn() }, \/\/ overwrite foo's `default.bar` with the mock\r\n  }));\r\n\r\n\/\/ MUST be after any\/all mocks\r\nconst qux = await import('qux.mjs')\r\n  .then(({ default: d }) => d);\r\n```\r\n\r\nThis works because ESM does not protect properties of exported objects, only the export itself.\r\n\r\nFor the mock to be present in the top-level scope (eg when imported), you must use `await import` in the test file to enforce sequence (including the qux import!).","I have mocked node-fetch and import it to a test file with `import * as fetch from 'node-fetch';` - but the functions I have set in the mock such as `fetch.setMockJsonResponse` cannot be found in the test file. Is that the same issue as this?","@thernstig probably yes. See my comment above for a potential workaround.","If anyone is interested in giving `jest.mockModule` from this PR \u2014 https:\/\/github.com\/facebook\/jest\/pull\/10976 \u2014 a try right now, here is a small example using it: https:\/\/github.com\/yurijmikhalevich\/esm-project-with-working-jest-mock.","@yurijmikhalevich is that going to be merged anytime soon?","@yurijmikhalevich do you have any update, please?","https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-915109139","so is it safe to say, that the _ONLY_ way you can actually do this: https:\/\/jestjs.io\/docs\/mock-functions#mocking-modules is by using babel to convert everything back to CommonJS?  I'm _so_ against having to involve babel in my relatively small project, i think it would just be easier to convert the entire project back to CommonJS and just wait for the testing frameworks to catch up.\r\n\r\nplease correct me if I'm wrong in my understanding....\r\n\r\nalso, as an aside, it would be _really_ helpful to have a disclaimer on https:\/\/jestjs.io\/docs\/mock-functions#mocking-modules that you'll _still_ need babel for your pure Node project before you build the whole thing and then see this:\r\n\r\nhttps:\/\/jestjs.io\/docs\/ecmascript-modules","@jasonrberk  Fact is, if you use jest, you use babel already: https:\/\/jestjs.io\/docs\/next\/code-transformation#defaults.\r\n\r\nDepending on your complete stack, it can be not that hard to mock modules. With typescript, `ts-jest` includes presets that requires just a bit of config for allow it to handle node_modules if required. Then, to work with the hoisting mechanism of `babel-jest` that is broken with ESM (since static imports are resolved before running the script for what I've seen), you just have to use top-level await to import files importing the modules to mock.\r\n\r\n> Mock before async imports and **do not import statically anything that may import `some-dep` statically**\r\n\r\n<details>\r\n<summary><b>Example plagiating @SimenB above:<\/b><\/summary>\r\n\r\nYou have the following structure:\r\n* src\r\n  * foo.ts\r\n  * foo.spec.ts\r\n* node_modules\r\n  * some-dep\r\n\r\nIn `src\/foo.ts`:\r\n\r\n```ts\r\nimport { depFn } from 'some-dep';\r\n\r\nexport const doStuff = (...args: any[]) => depFn(...args);\r\n```\r\n\r\nIn `src\/foo.spec.ts`:\r\n\r\n```ts\r\nimport { jest } from '@jest\/globals';\r\n\r\n\/\/ Order is important.\r\njest.mock('some-dep', () => ({\r\n  depFn: jest.fn()\r\n});\r\n\r\nconst { doStuff } = await import('.\/foo');\r\nconst { depFn } = await import('some-dep');\r\n\r\nit('should pass args to `depFn`', () => {\r\n  doStuff('a', 'b');\r\n  expect(depFn).toHaveBeenCalledWith('a', 'b');\r\n});\r\n```\r\n\r\n<\/details>\r\n\r\nLong story short: you use jest, you use babel if you don't explicitly disable transforms, AFAIK. It does most of the heavy lifting out of the box already.","@GerkinDev  - \ud83e\udd2f \r\n\r\nfirst off, thanks for the info.....\r\n\r\nso if follow, you guys are working to fix the babel that jest is using under the covers to support using ESM in our own code, instead of just stuff imported from node_modules?\r\n\r\nIn the meantime, I could\r\n\r\nA) do some babel stuff myself (which would happen in place of the transform Jest is doing) and convert all my js files to CommonJS via custom babel?\r\n\r\nB) just use CommonJS for now in my source and switch it all to ESM later, once the guys with the big brain fix the issue(s)\r\n\r\nthanks for helping me out.....been a _long_ time since I did anything in node \/ js\r\n\r\n","@GerkinDev \r\n\r\nI still can't get the provided [complete example](https:\/\/jestjs.io\/docs\/es6-class-mocks#complete-example) working\r\n\r\nhttps:\/\/github.com\/jasonrberk\/jest-mocking-esm\r\n\r\nand I still don't get if I'm responsible for doing something with Babel, or if that's all buried behind jest????\r\n\r\nwhat am I doing wrong here: https:\/\/github.com\/jasonrberk\/jest-mocking-esm\r\n","As I mentioned above, it depends on your setup: some other preprocessors, like `ts-jest`, makes the thing much easier somehow (I just tried to dig in and didn't found a reason. Maybe somebody else here knows how it does it almost like magic).\r\n\r\nIn your case, in pure ESM, you can replace the beginning of your test file like the following:\r\n\r\n```js\r\nimport { jest } from '@jest\/globals';\r\n\r\nconst mockPlaySoundFile = jest.fn();\r\njest.unstable_mockModule('.\/sound-player', () => {\r\n    return {default: jest.fn().mockImplementation(() => {\r\n        return { playSoundFile: mockPlaySoundFile };\r\n    })};\r\n});\r\nconst {default: SoundPlayer} = await import('.\/sound-player');\r\nconst {default: SoundPlayerConsumer} = await import('.\/sound-player-consumer');\r\n\r\nbeforeEach(() => {\r\n  SoundPlayer.mockClear();\r\n  mockPlaySoundFile.mockClear();\r\n});\r\n```\r\n\r\nSorry for the confusion, I was confused by ts-jest doing stuff I didn't expect it to do, that made things work in my tests here.","Hi all, great work on the ESM implementation so far. Only took a couple of hours to get up and running with a project that uses node natively, with no code transforms\r\n\r\nI've found an issue with `jest.unstable_mockModule` where the factory function is called once _per import of mocked module_ found in the code.\r\n\r\nSo if I have two files, both importing the mocked module, they'll each get a separate instance. And then this can cause issues if importing the mocked module into the test case, it's not guaranteed which of the instances you will get. In my case, the instance imported into my test file is not the one that contains the right data in `.mock.calls`\r\n\r\nSo far the workaround is to reorder a few `imports` in my source code, such that the module making the call to the mocked module is imported last.","out of my view the mock implementation of jest simply needs a diffrent api for esm as it needs to address shared linked modules also!\r\n\r\n```\r\nimport('.\/my-module.mjs').then(moduleToMock => mock(moduleToMock.get))\r\nimport('.\/my-module.cjs').then(moduleToMock => mock(moduleToMock.default))\r\n```\r\n\r\ni think the mock implementation that now trys to find a object via a string mock('moduleToMock') is confusing anyway\r\n\r\nsimply taking a object and returning a proxy for it is enough to implement mocking.","@GerkinDev Hello, I'm experimenting with using pure ESM for testing, and find myself in the same situation as @jasonrberk. However, your suggestion isn't working for me to mock a module (`fs` in this case) that's being loaded by the module being tested.\r\n\r\nHere's a minimal example:\r\n\r\n```js\r\nimport { jest } from '@jest\/globals'\r\n\r\nconst mockReadFileSync = jest.fn().mockImplementation(() => {\r\n  return { version: '1.0' }\r\n})\r\n\r\njest.unstable_mockModule('fs', () => {\r\n  return {\r\n    default: jest.fn().mockImplementation(() => {\r\n      return { readFileSync: mockReadFileSync }\r\n    })\r\n  }\r\n})\r\n\r\nimport { getVersion } from 'utils.js'\r\n\r\nit('gets the app\\'s version', () => {\r\n  expect(getVersion()).toBe('1.0')\r\n})\r\n```\r\n\r\nThis test fails - the real `fs` gets used, not the mock. Do you have any idea why that might be the case? Thanks!\r\n\r\nEdit:\r\nI dug around a bit more and see that [this PR](https:\/\/github.com\/facebook\/jest\/pull\/10976) is supposed to have replaced `jest.unstable_mockModule` with `jest.mockModule` in 27.1.1. However, if I try to use that in my test with 27.4.7, I get \"jest.mockModule is not a function\", which is confusing. It feels like that probably relates to this problem, though.","I was unable to get TypeScript + ESM + mocks to work and ended up transpiling to CJS with Babel for tests.\r\n\r\n### For anyone still trying to have testable code with an ESM codebase (i.e., `{ \"type\": \"module\" }` in `package.json`), maybe my config will work for you too.\r\n\r\nInstall the dependencies:\r\n```\r\nnpm i -D @babel\/core @babel\/plugin-transform-runtime @babel\/preset-env @babel\/preset-typescript babel-jest babel-plugin-transform-import-meta\r\n```\r\n\r\n> If you aren't using TypeScript, then you of course don't need to install `@babel\/preset-typescript`.\r\n\r\njest.config.json:\r\n```json\r\n{\r\n  \"roots\": [\r\n    \"<rootDir>\/src\/\"\r\n  ],\r\n  \"setupFiles\": [\r\n    \"<rootDir>\/src\/environment.ts\"\r\n  ],\r\n  \"moduleNameMapper\": {\r\n    \"^(\\\\.{1,2}\/.*)\\\\.jsx?$\": \"$1\"\r\n  }\r\n}\r\n```\r\n\r\nThe `setupFiles` are specific to my setup. You can probably remove or update that for your own.\r\n\r\n`moduleNameMapper` strips the `.js` and `.jsx` extensions from module names, which is necessary because ESM `import` statements need the file extension, while the `require` statements produced by Babel do not.\r\n\r\nbabel.config.json:\r\n```json\r\n{\r\n  \"presets\": [\r\n    \"@babel\/preset-env\",\r\n    \"@babel\/preset-typescript\"\r\n  ],\r\n  \"plugins\": [\r\n    \"@babel\/transform-runtime\",\r\n    \"babel-plugin-transform-import-meta\"\r\n  ]\r\n}\r\n```\r\n\r\n> If you aren't using TypeScript, then you of course don't need `@babel\/preset-typescript`.\r\n\r\nIf you're using ESM, you'll probably use `import.meta.url` at some point, which is unavailable in CJS code. The two Babel plugins above transform `import.meta.url` statements into something CJS can use.\r\n\r\nFor example, maybe you need `__dirname`, which is unavailable in ESM:\r\n```ts\r\nimport { fileURLToPath } from 'url'\r\nimport path from 'path'\r\n\r\nconst __dirname = fileURLToPath(path.dirname(import.meta.url))\r\n```\r\n\r\nOr maybe you want to check if the module was the entry point for the Node process:\r\n```ts\r\nimport process from 'process'\r\nimport { fileURLToPath } from 'url'\r\n\r\nif (process.argv[1] === fileURLToPath(import.meta.url)) {\r\n  \/\/ This module was the entry point.\r\n}\r\n```","Following some advice I saw somewhere (hard to know... I've had so many tabs open today chasing this) I installed `@babel\/plugin-transform-modules-commonjs` to turn ESM into CommonJS in the test environment, but it doesn't work - it dies with `SyntaxError: The requested module 'whatever.js' does not provide an export named 'someFunction'`. Someone's filed a bug for that as #12120. I'm considering my options at this point.","@scottdotjs Have you tried the setup I described above?","@vialoh None of that was relevant to my situation. Also this is incorrect:\r\n> `moduleNameMapper` strips the `.js` and `.jsx` extensions from module names, which is necessary...\r\n\r\nJest is able to see the modules without mapping the file names, as my comment above would suggest. ","@scottdotjs What is different about your setup?\r\n\r\nAlso, regarding the `moduleNameMapper`, does your code `import someModule from '.\/someModule.js'` (with the `.js` extension) or does it `import someModule from '.\/someModule` (without the extension)? If it's the latter then it isn't actually following the ES modules spec.","@vialoh sorry your wrong \"string\" specifier are part of the spec they get resolved via the importMap proposal in  userland ESM Code and else its up to the Environment to resolve string module Specifiers\r\n\r\nthey are also implemented in NodeJS via packagejson import fild replacing partial importMaps","@frank-dspeed Can you show me how to do what you're talking about in Node without needing to map every local import? Is there something that can natively automatically add `.js` (and possibly other extensions) to extensionless local imports? I was unable to find a way to do this natively but maybe I wasn't looking hard enough.\r\n\r\nTo quickly try what I'm talking about:\r\n```sh\r\nmkdir esm-import-example\r\ncd esm-import-example\r\nnpm init\r\n```\r\n\r\nAdd [`\"type\": \"module\"`](https:\/\/nodejs.org\/api\/packages.html#packagejson-and-file-extensions) to `package.json`.\r\n\r\nCreate `foo.js`:\r\n```js\r\nexport const foo = 'bar'\r\n```\r\n\r\nCreate `index.js`:\r\n```js\r\nimport { foo } from '.\/foo'\r\n\r\nconsole.log(foo)\r\n```\r\n\r\nRun `node index.js` and you'll be met with the following error:\r\n```\r\n$ node index.js\r\nnode:internal\/process\/esm_loader:94\r\n    internalBinding('errors').triggerUncaughtException(\r\n                              ^\r\n\r\nError [ERR_MODULE_NOT_FOUND]: Cannot find module 'esm-import-example\/foo' imported from esm-import-example\/index.js\r\nDid you mean to import ..\/foo.js?\r\n\u2190[90m    at new NodeError (node:internal\/errors:371:5)\u2190[39m\r\n\u2190[90m    at finalizeResolution (node:internal\/modules\/esm\/resolve:416:11)\u2190[39m\r\n\u2190[90m    at moduleResolve (node:internal\/modules\/esm\/resolve:932:10)\u2190[39m\r\n\u2190[90m    at defaultResolve (node:internal\/modules\/esm\/resolve:1044:11)\u2190[39m\r\n\u2190[90m    at ESMLoader.resolve (node:internal\/modules\/esm\/loader:422:30)\u2190[39m\r\n\u2190[90m    at ESMLoader.getModuleJob (node:internal\/modules\/esm\/loader:222:40)\u2190[39m\r\n\u2190[90m    at ModuleWrap.<anonymous> (node:internal\/modules\/esm\/module_job:76:40)\u2190[39m\r\n\u2190[90m    at link (node:internal\/modules\/esm\/module_job:75:36)\u2190[39m {\r\n  code: \u2190[32m'ERR_MODULE_NOT_FOUND'\u2190[39m\r\n}\r\n```","@vialoh sure here you go\r\nfrom https:\/\/nodejs.org\/api\/packages.html#subpath-patterns\r\n\r\n```js\r\n\/\/ .\/node_modules\/es-module-package\/package.json\r\n{\r\n  \"exports\": {\r\n    \".\/features\/*\": \".\/src\/features\/*.js\"\r\n  },\r\n  \"imports\": {\r\n    \"#internal\/*\": \".\/src\/internal\/*.js\"\r\n  }\r\n}\r\n```\r\n\r\n* maps expose nested subpaths as it is a string replacement syntax only.\r\n\r\nAll instances of * on the right hand side will then be replaced with this value, including if it contains any \/ separators.\r\n```js\r\nimport featureX from 'es-module-package\/features\/x';\r\n\/\/ Loads .\/node_modules\/es-module-package\/src\/features\/x.js\r\n\r\nimport featureY from 'es-module-package\/features\/y\/y';\r\n\/\/ Loads .\/node_modules\/es-module-package\/src\/features\/y\/y.js\r\n\r\nimport internalZ from '#internal\/z';\r\n\/\/ Loads .\/node_modules\/es-module-package\/src\/internal\/z.js\r\n```","@frank-dspeed Interesting, thanks!\r\n\r\nI was able to get your suggestion to work with the following...\r\n\r\nsrc\/foo.js:\r\n```js\r\nexport const foo = 'bar'\r\n```\r\n\r\nsrc\/index.js:\r\n```js\r\nimport { foo } from '#foo'\r\n\r\nconsole.log(foo)\r\n```\r\n\r\npackage.json:\r\n```json\r\n{\r\n  \"name\": \"esm-import-example\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"type\": \"module\",\r\n  \"scripts\": {\r\n    \"start\": \"node src\/index.js\",\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"imports\": {\r\n    \"#*\": \".\/src\/*.js\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"MIT\"\r\n}\r\n```\r\n\r\nI'm not sure how I feel about it though. It feels sort of wrong, maybe from too many years of using relative imports. Although this may actually prove to be better for modularity in the long term.\r\n\r\nI am still curious though. Is it possible to import using a relative path (e.g., `import .\/foo`) instead of needing the path prefixed with `#`?\r\n\r\nFor example...\r\n\r\nsrc\/index.js:\r\n```js\r\nimport { foo } from '.\/foo'\r\n\r\nconsole.log(foo)\r\n```\r\n\r\npackage.json:\r\n```json\r\n{\r\n  \"imports\": {\r\n    \".\/*\": \".\/*.js\"\r\n  }\r\n}\r\n```","the prefix # was fully optional i showed both the # is a internal convention to easy parse and find such imports without much trouble\r\n\r\nand about your other question It is fully environment dependent the NPM way works only for NodeJS as it is from the same People. The Cross Platform way is ImportMaps you can use them in many environments today \r\n\r\nand the offical shim PoillyPony Fill for that is systemjs a cross platform module system that offers everything that ESM Specs try to enforce on environments.\r\n\r\nfor example the nodejs modules will now get referenced like that in future\r\n\r\n```js\r\nimport { writeFile } from 'node:fs\/promises'\r\n```\r\n","@frank-dspeed I used SystemJS a while back, but I'm trying to avoid relying on any fills or transpilation.\r\n\r\nIf I have `src\/foo.js` and `src\/index.js` and want to `import { foo } from '.\/foo'` (exactly as written here) from within `src\/index.js`, what would the `package.json` configuration be?","Is a fix for this still on the roadmap?","Hey all, here is what I decided to do, in case anyone finds it useful... I'm allowing manual dependency injection into my module functions via arguments, to allow for mocks, but setting default argument value to the normally imported dependency. I personally feel like this is reasonable given the circumstances. Example:\r\n\r\n```\r\n\/\/my-module.js\r\nimport { myDependency } from '.\/dependencies';\r\nexport function doStuff(arg1, arg2, dep_myDependency = myDependency) {\r\n    \/\/ TODO: Use dep_myDependency()\r\n}\r\n\r\n\/\/my-module.test.js\r\nimport { jest, expect } from '@jest\/globals';\r\nimport { doStuff } from '.\/my-module.js';\r\ntest('Does stuff', () => {\r\n    const mockMyDependency = jest.fn();\r\n    doStuff('foo', 'bar', mockMyDependency);\r\n    \/\/ Regular app usage: doStuff('foo', 'bar')\r\n    \/\/ Expect, etc...\r\n}\r\n```","Yeah! The true C# way. But automocking was soooooo convenient \ud83d\ude03","@PeterKDex exactly that is what you should do it is always a good pattern to allow your module dependencies to be inject able.","Has this been fixed in v28.0.0?","> I was unable to get TypeScript + ESM + mocks to work and ended up transpiling to CJS with Babel for tests.\r\n> \r\n> ### For anyone still trying to have testable code with an ESM codebase (i.e., `{ \"type\": \"module\" }` in `package.json`), maybe my config will work for you too.\r\n> Install the dependencies:\r\n> \r\n> ```\r\n> npm i -D @babel\/core @babel\/plugin-transform-runtime @babel\/preset-env @babel\/preset-typescript babel-jest babel-plugin-transform-import-meta\r\n> ```\r\n> \r\n> > If you aren't using TypeScript, then you of course don't need to install `@babel\/preset-typescript`.\r\n> \r\n> jest.config.json:\r\n> \r\n> ```json\r\n> {\r\n>   \"roots\": [\r\n>     \"<rootDir>\/src\/\"\r\n>   ],\r\n>   \"setupFiles\": [\r\n>     \"<rootDir>\/src\/environment.ts\"\r\n>   ],\r\n>   \"moduleNameMapper\": {\r\n>     \"^(\\\\.{1,2}\/.*)\\\\.jsx?$\": \"$1\"\r\n>   }\r\n> }\r\n> ```\r\n> \r\n> The `setupFiles` are specific to my setup. You can probably remove or update that for your own.\r\n> \r\n> `moduleNameMapper` strips the `.js` and `.jsx` extensions from module names, which is necessary because ESM `import` statements need the file extension, while the `require` statements produced by Babel do not.\r\n> \r\n> babel.config.json:\r\n> \r\n> ```json\r\n> {\r\n>   \"presets\": [\r\n>     \"@babel\/preset-env\",\r\n>     \"@babel\/preset-typescript\"\r\n>   ],\r\n>   \"plugins\": [\r\n>     \"@babel\/transform-runtime\",\r\n>     \"babel-plugin-transform-import-meta\"\r\n>   ]\r\n> }\r\n> ```\r\n> \r\n> > If you aren't using TypeScript, then you of course don't need `@babel\/preset-typescript`.\r\n> \r\n> If you're using ESM, you'll probably use `import.meta.url` at some point, which is unavailable in CJS code. The two Babel plugins above transform `import.meta.url` statements into something CJS can use.\r\n> \r\n> For example, maybe you need `__dirname`, which is unavailable in ESM:\r\n> \r\n> ```ts\r\n> import { fileURLToPath } from 'url'\r\n> import path from 'path'\r\n> \r\n> const __dirname = fileURLToPath(path.dirname(import.meta.url))\r\n> ```\r\n> \r\n> Or maybe you want to check if the module was the entry point for the Node process:\r\n> \r\n> ```ts\r\n> import process from 'process'\r\n> import { fileURLToPath } from 'url'\r\n> \r\n> if (process.argv[1] === fileURLToPath(import.meta.url)) {\r\n>   \/\/ This module was the entry point.\r\n> }\r\n> ```\r\n\r\n@vialoh I went with your approach to get around the lack of mocking. It looks like it worked out just fine. I will report back if I find any issues. I think this is the simplest approach until there is some kind of official solution from the Jest team.","Not sure when it landed but `jest.unstable_mockModule` and dynamic import works as expected\r\n```ts\r\nimport { jest } from '@jest\/globals';\r\n\r\njest.unstable_mockModule('@googleapis\/dataflow', () => {\r\n  return {\r\n    dataflow: () => ({\r\n      projects: { locations: { jobs: { list: jest.fn(), }, }, },\r\n    }),\r\n  };\r\n});\r\n\r\n\/\/ module importing @googleapis\/dataflow\r\nconst { DataflowHealthCheckService } = await import(\r\n  '.\/dataflow-health-check.service.js'\r\n);\r\n```","> Not sure when it landed but `jest.unstable_mockModule` and dynamic import works as expected\r\n> \r\n> ```ts\r\n> import { jest } from '@jest\/globals';\r\n> \r\n> jest.unstable_mockModule('@googleapis\/dataflow', () => {\r\n>   return {\r\n>     dataflow: () => ({\r\n>       projects: { locations: { jobs: { list: jest.fn(), }, }, },\r\n>     }),\r\n>   };\r\n> });\r\n> \r\n> \/\/ module importing @googleapis\/dataflow\r\n> const { DataflowHealthCheckService } = await import(\r\n>   '.\/dataflow-health-check.service.js'\r\n> );\r\n> ```\r\n\r\nDoes not work for me :( \r\nRaised #12946 ","@neophyt3 if you want to test something fresh check out the new nodejs vm api it allows shiming ESModules\r\n\r\nmost of the vm.<methods> got now a importModuleDynamically parameter that allows you to set a callback for import()\r\n\r\nhope that helps\r\n\r\n## Background\r\nthe vm module in nodejs got build to implement custom userland module systems :)\r\n\r\nhttps:\/\/nodejs.org\/api\/vm.html#vmrunincontextcode-contextifiedobject-options\r\n\r\nis what your looking for may god be with you ","I am trying to find workaround for Jest ESM support without Babel.\r\n\r\nBased on the [Jest examples\/manual-mocks](https:\/\/github.com\/facebook\/jest\/tree\/main\/examples\/manual-mocks),\r\nI modified the source and configuration files, and found the follows:\r\n\r\n1. I fix some bugs for test userMocked.test.js, but test fails due to the result is not match to the mock's object.\r\n2. I fix some bugs for test file_summarizer.test.js, and test pass.\r\n\r\nI can not find how to use jest.mock for ES Modules import.\r\n\r\nMy example project is [juggernautjp\/jest-manual-mocks-example](https:\/\/github.com\/juggernautjp\/jest-manual-mocks-example), so you can modify and verify by downloading from my repository.\r\n\r\nIf someone has any idea to fix my bugs, will you please let me know?","My previous post is not good enough to understand, so I rewrite and post about it again.\r\n\r\nAs you know, the Jest example of [manual-mocks](https:\/\/github.com\/facebook\/jest\/tree\/main\/examples\/manual-mocks) work correctly with Babel.\r\nI have tried modifying to work that example without Babel, and I found the follows:\r\n\r\n1. `jest.mock()` works: when ES Module require CommonJS module with Node.js [`module.createRequire(filename)`](https:\/\/nodejs.org\/api\/module.html#modulecreaterequirefilename) method\r\n  - e.g., FileSummarizer.cjs `require` Manual mock CommonJS module of fs.cjs.\r\n2. `jest.mock()` dose **not** work: when MS Module `import` ES Module.\r\n  - e.g., when userMocked.test.js `import` Manual mock ES Module of `models\/user.mjs`, `user.getAuthenticated()` return the value of `model\/user.mjs` instead of that of `model\/__mocks__\/user.mjs`.\r\n\r\nAfter the above the 2nd problem would be fixed, I could use `jest.mock` with Manual Mocks of `import('node:fs\/promise')`.\r\n\r\nFor further information, see [my repository](https:\/\/github.com\/juggernautjp\/jest-manual-mocks-example).\r\n","```ts\r\nimport { jest } from '@jest\/globals';\r\nimport { BrowserWindow } from 'electron';\r\n\r\njest.mock('electron', () => ({\r\n  app: {\r\n    on: jest.fn(),\r\n    whenReady: jest.fn(() => Promise.resolve()),\r\n  },\r\n  ipcMain: { on: jest.fn() },\r\n  BrowserWindow: jest.fn().mockImplementation(() => ({\r\n    loadFile: jest.fn(() => Promise.resolve()),\r\n    on: jest.fn(),\r\n  })),\r\n}));\r\n```\r\n\r\nHere's the import section of my test file. Jest reports `SyntaxError: The requested module 'electron' does not provide an export named 'BrowserWindow'` if I have `ts-jest` configured `useESM: true` and run jest with `NODE_OPTIONS=--experimental-vm-modules`.\r\n\r\nTried different syntax and workaround but no luck at all. It's clear to me that something in Jest is broken with ESM support enabled. Frustrated as I've converted all other code to native ESM syntax but can't get Jest to work properly with it. Would be very happy to know if there's any update on this issue.","@iamWing If you see the same problem without using `ts-jest`, please open a separate issue with minimal reproduction repo. It is hard to say what is going on otherwise.","> @iamWing If you see the same problem without using `ts-jest`, please open a separate issue with minimal reproduction repo. It is hard to say what is going on otherwise.\r\n\r\n@mrazauskas Okay, will do. There're some other issues with ESM support enabled, will have them included in that repo as well.","I switched to using td.js. It pretty much worked ootb\n\nOn Sun, Aug 14, 2022, 3:04 AM Wing Chau ***@***.***> wrote:\n\n> @iamWing <https:\/\/github.com\/iamWing> If you see the same problem without\n> using ts-jest, please open a separate issue with minimal reproduction\n> repo. It is hard to say what is going on otherwise.\n>\n> @mrazauskas <https:\/\/github.com\/mrazauskas> Okay, will do. There're some\n> other issues with ESM support enabled, will have them included in that repo\n> as well.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/10025#issuecomment-1214299010>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AHSZMNKDXHF7PR4LNWLTBOLVZCLATANCNFSM4M6JSMOA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n","@jasonrberk Hi, can you further explain what's it? I googled td.js but couldn't found anything likely to be related to Jest and the ESM issue.","not related to Jest.  TestDouble.js is an entirely different ES6 testing\nframework:\n\nhttps:\/\/github.com\/testdouble\/testdouble.js\/\n\nhttps:\/\/github.com\/testdouble\/testdouble.js\/tree\/main\/examples\n\n\nThanks,\n\nJason Berk\n***@***.***\n\n\nOn Sun, Aug 14, 2022 at 3:53 PM Wing Chau ***@***.***> wrote:\n\n> @jasonrberk <https:\/\/github.com\/jasonrberk> Hi, can you further explain\n> what's it? I googled td.js but couldn't found anything likely to be related\n> to Jest and the ESM issue.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/10025#issuecomment-1214438642>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AHSZMNPXYYZCSCC4XVAOANTVZFFEHANCNFSM4M6JSMOA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n","> not related to Jest. TestDouble.js is an entirely different ES6 testing framework: https:\/\/github.com\/testdouble\/testdouble.js\/ https:\/\/github.com\/testdouble\/testdouble.js\/tree\/main\/examples Thanks, Jason Berk ***@***.***\r\n> [\u2026](#)\r\n\r\nThanks buddy. Not exactly what I'm looking for as I'm maintaining a boilerplate that I do need a very good enough reason to introduce yet another framework into that project, but will keep an eye on it and see if it's gonna be useful on my other projects.","Does `__mocks__` in the root directory also not work for mocking node modules? I'm trying to do that but the file I'm testing doesn't import the mock.","For anyone wanting to use this functionality I created a demo repo here (including TS support via `ts-jest`)\r\n\r\nhttps:\/\/github.com\/connorjburton\/js-ts-jest-esm-mock","Thanks @connorjburton !\r\nThe key is to await import your SUT (**after** `jest.unstable_mockModule`) and not just import it.\r\n`const index = await import(\".\/index\");`\r\nThen you are mocking things that are imported inside your SUT (index in case of example above)\r\n\r\nI think the documentation is lacking the this information and it is not really obvious https:\/\/jestjs.io\/docs\/ecmascript-modules  \r\n","> Thanks @connorjburton ! The key is to await import your SUT (**after** `jest.unstable_mockModule`) and not just import it. `const index = await import(\".\/index\");` Then you are mocking things that are imported inside your SUT (index in case of example above)\r\n> \r\n> I think the documentation is lacking the this information and it is not really obvious https:\/\/jestjs.io\/docs\/ecmascript-modules\r\n\r\nAfter trying the approach from the docs, and every combination suggested in this post and other posts online for several hours, I can conclude that this is the key to getting this to work.","@kevinhooke but isn't that conclusion logical in general i mean the basics of the engine are the event loops so it is total clear that import() is a async operation and it will not be ready in the same cpu cycle that is a total expect able result.\r\n\r\nIf you as a ECMAScript dev get stuck on issues like that you need to learn the fundamentals about the JS Loop and the stack handling else you will shoot your self in the foot later anyway.\r\n\r\n![img](https:\/\/miro.medium.com\/max\/4800\/1*G-LmVEGXlj-UqyARy7wNjg.webp)\r\n\r\n![img](https:\/\/miro.medium.com\/max\/720\/1*IMjsDjLbnTApVUCGIvfJHg.webp)\r\n\r\n\r\nout of the above pictures the conclusion is clear as soon as i await something it is there after that. not before that. \r\nso import will only enqueue it while await will wait for the result hope that makes sense.","@frank-dspeed I agree with your explanation but I disagree with your statement that is it 'logical in general'. Coming from other languages, if I import a dependent module I would expect it to already be loaded by the time I reference it in the following code, and not that it may or may not be loaded and introduce random behavior into my code. I'm nitpicking at how ECMAScript imports work within an event loop based architecture, but 'logical in general', no, it is not.","> @kevinhooke I would expect it to already be loaded by the time I reference it in the following code, and not that it may or may not be loaded and introduce random behavior into my code.\r\n\r\nThat's exactly what happens when you use static `import`, the dependency is guaranteed to be loaded before your code runs. For example...\r\n\r\n```js\r\nimport foo from \"some-module\";\r\n\r\n\/\/ It's guaranteed that \"some-module\" is loaded and you can use `foo`\r\n```\r\n\r\nBut if you use `import(\"some-module\")` then you are doing [dynamic runtime loading](https:\/\/en.wikipedia.org\/wiki\/Dynamic_loading), so you need to use `await` or `.then` in order to wait for the module to finish loading.\r\n\r\nMost JS code *should* use static `import`, dynamic `import()` is a niche feature that is useful in some situations, but it is not the norm. Unit tests are one of those niche situations where `import()` is useful.","So basically I don't see here any other solution except for using babel or not using esm at all? Or did I miss something?","> So basically I don't see here any other solution except for using babel or not using esm at all? Or did I miss something?\r\n\r\nYou don't need `babel`, [see my example repo here](https:\/\/github.com\/connorjburton\/js-ts-jest-esm-mock), you only need `jest`","Lately I have migrated a medium project to ESM. And use 'unstable_mockModule'.\r\n\r\nThe order in the spec file is:\r\n\r\n- import stuff from jest\r\n- import other stuff from testing helpers if needed\r\n- unstable_mockModule\r\n- await import() sut\r\n- await import transitive deps for mock control.\r\n\r\nFor me it very intuitive. No hoisting no black magic. Just works. \ud83d\udc4d\ud83d\ude01","@connorjburton \r\nFor some reason it doesn't want to mock the imported class, maybe it's my stupidity, I am sitting on this issue for 2 days already haha\r\n\r\nI tried your example, this is what I did:\r\n\r\n*myclass.spec.js*\r\n```js\r\nimport { jest } from '@jest\/globals';\r\nimport MyClass from '.\/MyClass';\r\n\r\njest.unstable_mockModule('.\/MyClass', () => ({\r\n  isWorking: jest.fn(() => false),\r\n}));\r\n\r\ndescribe('MyClass', () => {\r\n  it('should be working', () => {\r\n    const myClass = new MyClass();\r\n    expect(myClass.isWorking()).toBe(false);\r\n  });\r\n});\r\n```\r\n\r\n*MyClass.js*\r\n```js\r\nexport default class MyClass {\r\n  constructor() {\r\n    this.works = true;\r\n  }\r\n\r\n  isWorking() {\r\n    return this.works;\r\n  }\r\n}\r\n```\r\n\r\n*package.json*\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"test\": \"node --experimental-vm-modules node_modules\/jest\/bin\/jest.js\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"jest\": \"^29.3.1\"\r\n  },\r\n  \"type\": \"module\"\r\n}\r\n```\r\n\r\n*jest.config.js*\r\n\r\n```js\r\nexport default {\r\n  transform: {},\r\n};\r\n```\r\n\r\nnode version: v18.2.0\r\n","Replace \r\n\r\nimport MyClass from '.\/MyClass';\r\n\r\nWith \r\n\r\nconst MyClass = await import(\".\/MyClass\");\r\n\r\nAfter! Unstable mockmodule","I think it should be `const MyClass = (await import('.\/MyClass')).default;`","considering to use vitest, mock esm the same way mocking cjs in jest","> Replace\r\n> \r\n> import MyClass from '.\/MyClass';\r\n> \r\n> With\r\n> \r\n> const MyClass = await import(\".\/MyClass\");\r\n> \r\n> After! Unstable mockmodule\r\n\r\nThank you! @jurijzahn8019 That works!\r\nThank you for the help!\r\n\r\n@Pauan I am exporting the class as a es module, so no need to use default, it's undefined\r\n\r\nAnother problem with the unstable mock module, it doesn't want to mock it as a constructor:\r\n\r\n```js\r\nimport { jest } from '@jest\/globals';\r\n\r\njest.unstable_mockModule('.\/MyClass', () => {\r\n  return function () {\r\n    return {\r\n      isWorking: () => false,\r\n    };\r\n  };\r\n});\r\n\r\nconst MyClass = await import('.\/MyClass');\r\n\r\ndescribe('MyClass', () => {\r\n  beforeAll(() => {});\r\n  it('should be working', () => {\r\n    const myClass = new MyClass();\r\n    expect(myClass.isWorking()).toBe(false);\r\n  });\r\n});\r\n```\r\n\r\nError:\r\n```\r\nTypeError: MyClass is not a constructor\r\n\r\n      15 |   beforeAll(() => {});\r\n      16 |   it('should be working', () => {\r\n    > 17 |     const myClass = new MyClass();\r\n         |                     ^\r\n      18 |     expect(myClass.isWorking()).toBe(false);\r\n      19 |   });\r\n      20 | });\r\n```","You\u2018re returning a function in your mock instead of a class, so that error makes sense","You can wrap the constructor mock into jest.fn().","@swissspidy I was following [this answer](https:\/\/stackoverflow.com\/questions\/47402005\/jest-mock-how-to-mock-es6-class-default-import-using-factory-parameter) by \"stone\"\r\n\r\nRegardless using \"new\" on a function should work\r\n\r\n```js\r\nfunction Bla(){\r\n    return {\r\n        lol: ()=>'ops'\r\n    }\r\n}\r\nnew Bla() \/\/ > {lol: \u0192}\r\n```\r\n\r\nHowever the mocking doesn't return the function, it returns:\r\n```Module {Symbol(Symbol.toStringTag): 'Module'}```\r\nThat's the reason it fails, but not sure why it's returning the symbol","Then this may be a \"default\" issue. This is the reason I always  prefer named exports \ud83d\ude01","> Then this may be a \"default\" issue. This is the reason I always prefer named exports \ud83d\ude01\r\n\r\nTried named export, that worked, thanks @jurijzahn8019 I wonder why tho?","Alright I've figured out how to mock the default as well\r\n\r\n```js\r\nimport { jest } from '@jest\/globals';\r\n\r\njest.unstable_mockModule('.\/MyClass', () => {\r\n  return {\r\n    default: function () {\r\n      return {\r\n        isWorking: () => false,\r\n      };\r\n    },\r\n  };\r\n});\r\n\r\nconst MyClass = (await import('.\/MyClass')).default;\r\n\r\ndescribe('MyClass', () => {\r\n  beforeAll(() => {});\r\n  it('should be working', () => {\r\n    const myClass = new MyClass();\r\n    expect(myClass.isWorking()).toBe(false);\r\n  });\r\n});\r\n```\r\n\r\nTurns out @Pauan was right all along, just needed to do some extra fixes\r\n\r\nThanks everyone for the help! <3","@8o8inCodes When you do `await import(\"foo\")` it gives you the ES6 module, not the default export. The ES6 module is an object that contains all the things which are exported from the module.\r\n\r\nSo if the module is exporting something called `bar` then you need to use `(await import(\"foo\")).bar` to access it.\r\n\r\nAnd if the module does `export default` then you have to access it with `(await import(\"foo\")).default`.\r\n\r\nThe default export isn't special, it's just an ordinary export called `default`. When you do this...\r\n\r\n```js\r\nimport MyClass from \".\/MyClass\";\r\n```\r\n\r\nThat is exactly the same as doing this:\r\n\r\n```js\r\nimport { default as MyClass } from \".\/MyClass\";\r\n```\r\n\r\nSo you see that the default really is just an ordinary export called `default`.","I'm trying this out im did't find anyway of doing partial mocking, using `requireActual` gives `Must use import to load ES Module`\r\n\r\nAnd trying to do a partial import before \"breaks\" the mock is the module is already imported","Hello, I'm having a problem with dynamic import of my service, it throws:\r\n` TypeError: Cannot convert undefined or null to object\r\n        at Function.keys (<anonymous>)\r\n        at Runtime.importMock\r\n        at importModuleDynamically\r\n        at importModuleDynamicallyWrapper`\r\n       \r\n```\r\nThat's the code inside my user.spec.ts file:\r\nimport { createServer } from 'src\/utils\/server';\r\nimport { jest } from '@jest\/globals';\r\nimport { userInput, userPayload } from '.\/mocks\/mocks';\r\nimport supertest from 'supertest';\r\n\r\njest.unstable_mockModule('..\/services\/user.service', async () => {\r\n  createUser: jest.fn();\r\n});\r\n\r\nconst mocked = await import('..\/services\/user.service');\r\n```\r\n\r\n\r\nAny ideas? Maybe some issues I don't know about? Help will be much appreciated.\r\n ","Could you open a separate issue with minimal reproduction repo, please?","Problem solved, thanks for help","Your callback inside of `jest.unstable_mockModule` does not return anything. If the intention is to return an object, you should wrap it in parenthesis:\r\n\r\n```js\r\njest.unstable_mockModule(\"..\/services\/user.service.js\", async () => ({\r\n  createUser: jest.fn(),\r\n}));\r\n```","Are there any updates on mocking ESM without the factory function?\r\nFor example, vitest supports creating mocks for ESM automatically.\r\n\r\nIs there a roadmap which shows when jest will fully support ESM?","> Are there any updates on mocking ESM without the factory function?\r\n> For example, vitest supports creating mocks for ESM automatically.\r\n\r\nPRs welcome!\r\n\r\n> Is there a roadmap which shows when jest will fully support ESM?\r\n\r\nThe pinned #9430","I cant see any ticket for unmocking, is there any PR i should look for, or should i start my own?","Hello,\r\n\r\nMy colleague and I have a problem with mocking default helper function.\r\n\r\nWe tried follow example:\r\nimport { jest } from '@jest\/globals';\r\n\r\njest.unstable_mockModule('\/helpers\/exampleFunction.js', () => ({\r\n  __esModule: true,\r\n  default: jest.fn().mockReturnValue(mockValue)\r\n}))\r\n\r\nBehavior is not mocked, the function still call original helper function, does not consider the mock data.\r\n\r\nDo you have some suggestions?\r\nCommunity, tnx in advance!","> Do you have some suggestions?\n\nCreate a minimal reproduction repo and open an issue. It is hard to say something useful looking at the snipped you provided.","> Hello,\r\n> \r\n> My colleague and I have a problem with mocking default helper function.\r\n> \r\n> We tried follow example: import { jest } from '@jest\/globals';\r\n> \r\n> jest.unstable_mockModule('\/helpers\/exampleFunction.js', () => ({ __esModule: true, default: jest.fn().mockReturnValue(mockValue) }))\r\n> \r\n> Behavior is not mocked, the function still call original helper function, does not consider the mock data.\r\n> \r\n> Do you have some suggestions? Community, tnx in advance!\r\n\r\nSo, what I see here is that your default entry is not an object, it's a key pointing directly to the function, can you try doing it like this:\r\n`default: {\r\n  nameOfFunc: jest.mockReturnValue(mockValue)\r\n  }\r\n`\r\nThat's how I mocked all my modules, because default export is actually an object\r\n\r\nAlso, for it to work, you need to than import this function with await statement after the mock was done, not using the normal import statement at the top of the file\r\nso for instance: const logger = await import('src\/utils\/logger');\r\nAnd put this line after the mock is registered","@Nexi77 \r\nYes, I exported function from helper like `export default functionName;` \r\n\r\nCode:\r\n```\r\njest.unstable_mockModule('\/helpers\/fileName.js', () => ({\r\n  __esModule: true,\r\n  default: { functionName: jest.fn().mockReturnValue(mockValue) }\r\n}))\r\nconst functionName = await import('\/helpers\/fileName.js');\r\n```\r\n\r\nAnd still call original helper function which call 3rd party, instead to use `mockValue`","@IgorBezanovic I just experienced the same issue you had; here's how I fixed it.\r\n\r\n`src.ts`\r\n```\r\nimport axios from 'axios'\r\n\r\nconst handler = async () => { \r\n  const result = await axios.request({ url: 'https:\/\/example.com })\r\n  console.log({ result })\r\n}\r\n```\r\n\r\n`test.ts`\r\n```\r\njest.unstable_mockModule('axios', () => ({\r\n  default: { request: jest.fn() },\r\n}));\r\n\r\nconst src = await import('src');\r\n\r\ndescribe('...', () => {\r\n  it('axios is mocked', () => {\r\n    const actual = await src.handler()\r\n\r\n     expect(actual).toBeUndefined() \/\/ correct; if unmocked it would have been an AxiosResponse\r\n  })\r\n})\r\n```\r\n\r\nthe trick was in `test.ts`\r\n\r\nbefore:\r\n\r\n```\r\nimport * as src from 'src'\r\n\r\njest.unstable_mockModule('axios', () => ({\r\n  default: { request: jest.fn() },\r\n}));\r\n\r\n...\r\n```\r\n\r\nafter:\r\n\r\n```\r\n\/\/ import * as src from 'src' \/\/ removed\r\n\r\njest.unstable_mockModule('axios', () => ({\r\n  default: { request: jest.fn() },\r\n}));\r\n\r\nconst src = await import('src'); \/\/ no longer `import * as src from 'src'`; and placed after `unstable_mockModule`\r\n```","@skilbjo\r\n\r\nI've been banging my head against a wall, and I'm hoping that maybe you can help!\r\n\r\nI am trying to mock the [ora](https:\/\/www.npmjs.com\/package\/ora) library. \r\n\r\nThese are the libraries installed:\r\n\r\n```json\r\n{\r\n  \"name\": \"demo\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"devDependencies\": {\r\n    \"jest\": \"^29.7.0\"\r\n  },\r\n  \"dependencies\": {\r\n    \"ora\": \"^8.0.1\"\r\n  }\r\n}\r\n```\r\n\r\nI've set up a barebones project to try and get this to work. The directory structure is:\r\n\r\n```\r\npackage.json\r\npackage-lock.json\r\nconfig\/\r\n\u251c\u2500 config.js\r\n\u251c\u2500 __tests__\/\r\n\u2502  \u251c\u2500 config.test.js\r\n```\r\n\r\n`config\/config.js`\r\n\r\n```js\r\nimport ora from 'ora';\r\n\r\nexport default (options) => {\r\n  const spinner = !options.raw ? ora('Reading Environment Variables').start() : undefined;\r\n  spinner.succeed(`Environment Variables Retrieved`);\r\n  return true;\r\n};\r\n```\r\n\r\n`config\/__tests__\/config.test.js`\r\n```js\r\njest.unstable_mockModule('ora', () => ({\r\n  default: { start: jest.fn(), succeed: jest.fn() },\r\n}));\r\n\r\nconst src = import('..\/config');\r\n\r\ndescribe('...', () => {\r\n  it('ora is mocked', () => {\r\n    const actual = config({})\r\n\r\n    expect(actual).toBeUndefined() \/\/ Yes, I realize this is a terrible and incorrect unit test.\r\n  })\r\n})\r\n```\r\n\r\nWhen I run `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js`, I get the following:\r\n\r\n```\r\n\/demo\/config\/config.js:1\r\n({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest){import ora from 'ora';\r\n                                                                                  ^^^^^^\r\n\r\nSyntaxError: Cannot use import statement outside a module\r\n    at new Script (node:vm:99:7)\r\n    at Runtime.createScriptFromCode (\/demo\/node_modules\/jest-runtime\/build\/index.js:1505:14)\r\n    at Runtime._execModule (\/demo\/node_modules\/jest-runtime\/build\/index.js:1399:25)\r\n    at Runtime._loadModule (\/demo\/node_modules\/jest-runtime\/build\/index.js:1022:12)\r\n    at Runtime.requireModule (\/demo\/node_modules\/jest-runtime\/build\/index.js:882:12)\r\n    at Runtime.requireModuleOrMock (\/demo\/node_modules\/jest-runtime\/build\/index.js:1048:21)\r\n    at Runtime.loadCjsAsEsm (\/demo\/node_modules\/jest-runtime\/build\/index.js:726:22)\r\n    at Runtime.resolveModule (\/demo\/node_modules\/jest-runtime\/build\/index.js:684:17)\r\n    at importModuleDynamically (\/demo\/node_modules\/jest-runtime\/build\/index.js:1520:26)\r\n    at importModuleDynamicallyWrapper (node:internal\/vm\/module:430:15)\r\n\r\nNode.js v21.5.0\r\n```","@mike-weiner what happens if you add type: module in your package.json ?","> @mike-weiner what happens if you add type: module in your package.json ?\r\n\r\nInteresting. I do get a slightly different error:\r\n\r\n```\r\nReferenceError: jest is not defined\r\n\r\n    > 1 | jest.unstable_mockModule('ora', () => ({\r\n        | ^\r\n      2 |   default: { start: jest.fn(), succeed: jest.fn() },\r\n      3 | }));\r\n      4 |\r\n\r\n      at jest (config\/__tests__\/config.test.js:1:1)\r\n```","> @mike-weiner what happens if you add type: module in your package.json ?\r\n\r\nA few additional tweaks to `config\/__tests__\/config.test.js` did the trick!\r\n\r\n```\r\nimport {jest} from '@jest\/globals'\r\n\r\njest.unstable_mockModule('ora', () => ({\r\n  default: { start: jest.fn(), succeed: jest.fn() },\r\n}));\r\n\r\nconst config = await import('..\/config').default;\r\n\r\ndescribe('...', () => {\r\n  it('ora is mocked', () => {\r\n    const actual = config\r\n\r\n    expect(actual).toBeUndefined() \/\/ Yes, I realize this is a terrible and incorrect unit test.\r\n  })\r\n})\r\n```\r\n\r\n@skilbjo - You are a life saver. Don't event want to say how many hours I've been wrangling with this.","cool, you\u2019re almost there.\r\nadd \r\nimport { jest } from \u2018@jest\/globals\u2019 \r\n\r\nto the top of your config.test.js file, as documented in the ESMAScript modules jest docs page","@skilbjo \r\n\r\nOne last follow up for you.\r\n\r\nThe following results in `TypeError: config is not a function`:\r\n\r\n```\r\nimport {jest} from '@jest\/globals'\r\n\r\njest.unstable_mockModule('ora', () => ({\r\n  default: { start: jest.fn(), succeed: jest.fn() },\r\n}));\r\n\r\nconst config = await import('..\/config').default;\r\n\r\ndescribe('...', () => {\r\n  it('ora is mocked', () => {\r\n    const actual = config({})\r\n\r\n    expect(actual).toBeUndefined() \/\/ Yes, I realize this is a terrible and incorrect unit test.\r\n  })\r\n})\r\n```\r\n\r\nHowever, this works fine:\r\n```\r\nimport {jest} from '@jest\/globals'\r\n\r\njest.unstable_mockModule('ora', () => ({\r\n  default: { start: jest.fn(), succeed: jest.fn() },\r\n}));\r\n\r\nconst config = await import('..\/config').default;\r\n\r\ndescribe('...', () => {\r\n  it('ora is mocked', () => {\r\n    const actual = config\r\n\r\n    expect(actual).toBeUndefined() \/\/ Yes, I realize this is a terrible and incorrect unit test.\r\n  })\r\n})\r\n```\r\n\r\nI should be able to call my `config` function with it's parameters, correct?","@skilbjo \r\n\r\n`config\/config.js` is currently:\r\n\r\n```\r\nimport ora from 'ora';\r\n\r\nexport default (options) => {\r\n  const spinner = !options.raw ? ora('Reading Environment Variables').start() : undefined;\r\n  spinner.succeed(`Environment Variables Retrieved`);\r\n  return true;\r\n};\r\n```\r\n\r\n`config\/__test__\/config.test.js` is:\r\n\r\n```\r\nimport {jest} from '@jest\/globals'\r\n\r\nconst oraStartMock = jest.fn();\r\nconst oraSucceedMock = jest.fn();\r\n\r\njest.unstable_mockModule('ora', () => ({\r\n  default: {\r\n    start: oraStartMock, \r\n    succeed: oraSucceedMock,\r\n  }\r\n}));\r\n\r\nconst { default: config } = await import('..\/config.js');\r\n\r\ndescribe('Mock Ora', () => {\r\n  it('ora is mocked', async () => {\r\n    \r\n    const actual = config({})\r\n\r\n    expect(oraStartMock).toHaveBeenCalled();\r\n    expect(actual).toBe(true);\r\n  })\r\n})\r\n```\r\n\r\nI am hitting the following error:\r\n```\r\nTypeError: ora is not a function\r\n\r\n      2 |\r\n      3 | export default (options) => {\r\n    > 4 |   const spinner = !options.raw ? ora('Reading Environment Variables').start() : undefined;\r\n        |                                  ^\r\n      5 |   spinner.succeed(`Environment Variables Retrieved`);\r\n      6 |   return true;\r\n      7 | };\r\n\r\n      at ora (config\/config.js:4:34)\r\n      at Object.config (config\/__tests__\/config.test.js:18:20)\r\n```","i think we need `requireModule` or `requireActual` ... i'm only just figuring this out myself as well. here's one way to debug:\r\n\r\n`config\/config.js`\r\n```\r\nimport ora from 'ora';\r\n\r\nexport default (options) => {\r\n  console.log({ ora });\r\n  \/*\r\n  const spinner = !options.raw ? ora('Reading Environment Variables').start() : undefined;\r\n  spinner.succeed(`Environment Variables Retrieved`);\r\n  return true;\r\n  *\/\r\n};\r\n```\r\n\r\nrun that both in normal mode `node config\/config.js` and with jest `npm test -- config\/__test__\/config.test.js` and compare the outputs - that will tell you how you need to mock ora.\r\n\r\nbut i think what is needed to get it to work for you is something like:\r\n\r\n```\r\nimport {jest} from '@jest\/globals'\r\n\r\nconst oraStartMock = jest.fn();\r\nconst oraSucceedMock = jest.fn();\r\n\r\njest.unstable_mockModule('ora', () => ({\r\n  ...jest.requireActual('ora'), \/\/ <----- ????\r\n  default: {\r\n      ...jest.requireActual('ora'), \/\/ <------ ????\r\n    start: oraStartMock, \r\n    succeed: oraSucceedMock,\r\n  }\r\n}));\r\n\r\nconst { default: config } = await import('..\/config.js');\r\n\r\ndescribe('Mock Ora', () => {\r\n  it('ora is mocked', async () => {\r\n    \r\n    const actual = config({})\r\n\r\n    expect(oraStartMock).toHaveBeenCalled();\r\n    expect(actual).toBe(true);\r\n  })\r\n})\r\n```\r\n\r\nyou can fill _me_ in with what you find, i have just got it working for myself today and am not sure all the workarounds etc yet. do let me know ...","The `ora`-package exports a function that when called with its parameters returns an object that has a `succeed` and a `start` function (among others). What you currently return is what the aforementioned function returns instead of the function.  It should be something like this:\r\n\r\n```js\r\njest.unstable_mockModule('ora', () => ({\r\n  default: () => ({\r\n    start: oraStartMock, \r\n    succeed: oraSucceedMock,\r\n  })\r\n}));\r\n```\r\n\r\nBut I don't think issues on how to mock specific libraries is something that should be discussed in this issue tracker.","@mx-bernhard - Yes, my bad. Is there a community page that is better suited for general questions?","> @mx-bernhard - Yes, my bad. Is there a community page that is better suited for general questions?\r\n\r\n@mike-weiner I don't know anything else other than Discord \/ SO, as mentioned here: https:\/\/jestjs.io\/help","Is there a way to unmock modules set up with `unstable_mockModule`?\r\n\r\nI've tried `jest.resetModules()` and `jest.restoreAllMocks()` with no success, but also re-mocking the same module with another call to `unstable_mockModule` except with passing the original implementation. Wrapping with `jest.isolateModulesAsync(...)` isn't possible due to a separate bug (`Error: Module cache already has entry puppeteer-core\/lib\/esm\/puppeteer\/common\/Puppeteer.js. This is a bug in Jest, please report it!`) so I've ended up working around the issue with:\r\n\r\n```js\r\nconst actualModule = await import('something');\r\njest.unstable_mockModule('something', () => {...});\r\n\/\/ Do tests, then \"restore\" the implementation\r\nconst mockedModule = await import('something');\r\nmockedModule.default.mockImplementation(actualModule.default);\r\n```\r\n","Try upgrading Jest. There was an issue with `.resetModules()`, but it must be fixed. Also consider opening new issue with a minimal reproduction. The problem you are talking about is not related with the OP.","@mrazauskas Thanks - I'm currently on the latest `v29.7.0` so I'll look at creating a separate issue. I'd commented here because this issue is linked from https:\/\/jestjs.io\/docs\/ecmascript-modules#module-mocking-in-esm, suggesting this issue is where work on `jest.unstable_mockModule` is taking place.","I am upgrading the jests using es module.\r\nIt is mocking well with unstable_mockModule. but no way to reset or unmock the module.\r\nI have to unmock or reset after each case is tested.\r\n```\r\nafterEach(async () => {\r\n    jest.resetModules();\r\n  });\r\n```\r\nI tried to use above code, but getting timeout issue.\r\nAnyone resolved this issue?","@akdev5 - I don't think you need the `async` call. As an example, here is what I'm doing to unmock the module: https:\/\/github.com\/mike-weiner\/wlbot\/blob\/main\/tests\/commands\/weather\/current.test.js#L35-L41","I tried to call without async. but seems not working.","@akdev5 - Let's take this conversation somewhere else since it's not related to this issue. Maybe open a Stack Overflow issue and include as much detail and code snippets as you can and others might be able to help too!"],"labels":[":rocket: Feature Request","ES Modules"]},{"title":"Use cross browser stack trace utils","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nIt'd be awesome and fairly simple (I hope) to swap out `stack-utils` for https:\/\/github.com\/stacktracejs\/error-stack-parser which would give you the same metadata about stacks but work for non v8 stack traces\r\n\r\n## Motivation\r\n\r\nWe want to use `jest-message-util` to format errors from multiple browsers\r\n\r\n## Pitch\r\n\r\nWe are using a lot of jest in https:\/\/github.com\/4Catalyzer\/karma-jest which is a multi-browser environment via karma. Jest's excellent error formatting utils from `jest-message-util` work great (after mapping browser stacks to correct ones via source maps), but the formatting utils assume V8 based stack traces, which means FF and safari traces don't get nicely printed and call-site files are incorrectly parsed. This is due to some bad regexs and `stack-utils` which is designed for node.\r\n\r\nIf this seems like a good idea i can problem send a PR for it","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","This issue was closed because it has been stalled for 7 days with no activity. Please open a new issue if the issue is still relevant, linking to this one.","This issue has been automatically locked since there has not been any recent activity after it was closed. Please open a new issue for related bugs.\nPlease note this issue tracker is not a help forum. We recommend using [StackOverflow](https:\/\/stackoverflow.com\/questions\/tagged\/jestjs) or our [discord channel](https:\/\/discord.gg\/j6FKKQQrW9) for questions.","@jquense we should deffo do this. Wanna send a PR?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"JavaScript heap out of memory after upgrade to Jest 26","body":"## \ud83d\udc1b Bug Report\r\nI upgraded from 24.X to 26.0.0 but now test that was passing is not\r\nRunning test takes long time to complete then I get this error \r\n![image](https:\/\/user-images.githubusercontent.com\/5871660\/81113114-8d1e3700-8ed4-11ea-981b-d94b03b891fa.png)\r\n\r\n\r\n## To Reproduce\r\n\r\nMy test: \r\n\r\n```\r\n  describe('when item ids are in sessionStorage', () => {\r\n    const itemIds = [333, 222, 111];\r\n\r\n    beforeEach(() => {\r\n      parseLocationToQueries.mockImplementation(() => ({\r\n        queue_id: testQueueId\r\n      }));\r\n      isAdHocReviewByItemId.mockReturnValue(false);\r\n      isAdHocReviewByObjId.mockReturnValue(false);\r\n      setItemsToBeReviewed(itemIds);\r\n    });\r\n\r\n    it('initial fetch', () => {\r\n      const wrapper = tf.render();\r\n      expect(wrapper.state('itemIds')).toEqual([]);\r\n      expect(axios.post).toBeCalledWith('\/review\/items', { item_ids: itemIds });\r\n    });\r\n\r\n    it('fetch more while no more', () => {\r\n      const wrapper = tf.render();\r\n      axios.post.mockClear();\r\n      wrapper.instance().fetchMoreItems();\r\n      expect(axios.post).not.toBeCalled();\r\n    });\r\n\r\n    it('fetch more while more', () => {\r\n      const wrapper = tf.render();\r\n      axios.post.mockClear();\r\n      wrapper.setState({ itemIds: [555] });\r\n      wrapper.instance().fetchMoreItems();\r\n      expect(axios.post).toBeCalledWith('\/review\/items', { item_ids: [555] });\r\n    });\r\n  });\r\n```\r\ncode: \r\n\r\n```\r\nexport function setItemsToBeReviewed(itemIds) {\r\n  sessionStorage.setItem(ITEMS_TO_BE_REVIEWED_KEY, JSON.stringify(itemIds));\r\n}\r\n\r\n\r\n  fetchMoreItems = () => {\r\n    this.setState({ loadingMoreItems: true });\r\n    return this.fetchItems(true)\r\n      .then(res => {\r\n        this.loadData(res.data);\r\n      })\r\n      .catch(error => {\r\n        console.log('FetchmoreError', error);\r\n      });\r\n  };\r\n\r\n  fetchItems = (excludeAssigned: boolean = false) => {\r\n    let request;\r\n    if (this.state.itemIds) {\r\n      request = this.fetchItemsByIds();\r\n    } else {\r\n      request = this.fetchItemsFIFO(excludeAssigned);\r\n    }\r\n    return request;\r\n  };\r\n\r\n  fetchItemsFIFO = (excludeAssigned: boolean = false) => {\r\n    const { isAlignment, queueIdFromURL } = this.state;\r\n    const url = '\/review\/assign';\r\n    const params = {\r\n      alignment: isAlignment,\r\n      queue_id: queueIdFromURL,\r\n      exclude_assigned: excludeAssigned\r\n    };\r\n    return axios.get<any>(url, { params });\r\n  };\r\n\r\n  fetchItemsByIds = () => {\r\n    if (_.isEmpty(this.state.itemIds)) {\r\n      return Promise.resolve({ data: [] });\r\n    }\r\n    const url = '\/review\/items';\r\n    const data = {\r\n      item_ids: _.slice(this.state.itemIds, 0, FETCH_BATCH_SIZE)\r\n    };\r\n    this.setState(state => ({\r\n      itemIds: _.slice(state.itemIds, FETCH_BATCH_SIZE)\r\n    }));\r\n    return axios.post<any, any>(url, data);\r\n  };\r\n```\r\n\r\njest.config: \r\n\r\n```\r\nmodule.exports = {\r\n  timers: 'fake',\r\n  moduleDirectories: ['node_modules'],\r\n  moduleFileExtensions: ['js', 'jsx'],\r\n  moduleNameMapper: {\r\n    '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':\r\n      '<rootDir>\/__mocks__\/fileMock.js',\r\n    '\\\\.(css|less)$': '<rootDir>\/__mocks__\/styleMock.js',\r\n    '^Root(.*)$': '<rootDir>$1',\r\n    '^Utils(.*)$': '<rootDir>\/src\/utils$1',\r\n    '^Hoc(.*)$': '<rootDir>\/src\/hoc$1',\r\n    '^Components(.*)$': '<rootDir>\/src\/components$1'\r\n  },\r\n  testRegex: 'test\\\\.jsx?$',\r\n  testURL: 'http:\/\/localhost:3000',\r\n  collectCoverageFrom: [\r\n    'src\/**\/*.js',\r\n    'src\/**\/*.jsx',\r\n    '!**\/node_modules\/**',\r\n    '!src\/components\/bulk_review\/columns\/**',\r\n    '!src\/components\/v2\/**'\r\n  ],\r\n  coverageReporters: ['html', 'text'],\r\n  coverageThreshold: {\r\n    global: {\r\n      branches: 90,\r\n      functions: 90,\r\n      lines: 90,\r\n      statements: 90\r\n    }\r\n  },\r\n  coverageDirectory: 'coverage',\r\n  snapshotSerializers: ['enzyme-to-json\/serializer'],\r\n  testEnvironment: '<rootDir>\/jest-environment.js',\r\n  setupFilesAfterEnv: ['<rootDir>\/enzyme.setup.js'],\r\n  setupFiles: [\r\n    '<rootDir>\/__mocks__\/localStorageMock.js',\r\n    '<rootDir>\/__mocks__\/consoleMock.js'\r\n  ],\r\n  globals: {\r\n    ENVIRONMENT: 'TESTING'\r\n  },\r\n  testPathIgnorePatterns: ['<rootDir>\/src\/components\/v2'],\r\n  reporters: [\r\n    'default',\r\n    [\r\n      'jest-html-reporter',\r\n      {\r\n        pageTitle: 'Test Report',\r\n        statusIgnoreFilter: 'passed',\r\n        includeFailureMsg: 'true'\r\n      }\r\n    ]\r\n  ]\r\n};\r\n\r\n```\r\n\r\n\r\n## envinfo\r\n\r\n System:\r\n    OS: Linux 4.15 Ubuntu 18.04.4 LTS (Bionic Beaver)\r\n    CPU: (36) x64 Intel(R) Xeon(R) Platinum 8124M CPU @ 3.00GHz\r\n  Binaries:\r\n    Node: 14.1.0 - ~\/.nvm\/versions\/node\/v14.1.0\/bin\/node\r\n    Yarn: 1.22.4 - \/usr\/bin\/yarn\r\n    npm: 6.14.4 - ~\/.nvm\/versions\/node\/v14.1.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.0.0 => 26.0.0","comments":["We will need a repro that can be downloaded and analyzed. \r\nAlso, please make sure to clear cache just in case, e.g with `jest --clear-cache`","Oh `--clear-cache` fixed it. ","Thanks, that's good to know. Still weird","I spoke too soon, it seems like the issue is this helper function: \r\n\r\n```\r\nexport function setItemsToBeReviewed(itemIds) {\r\n  sessionStorage.setItem(ITEMS_TO_BE_REVIEWED_KEY, JSON.stringify(itemIds));\r\n}\r\n```",">We will need a repro that can be downloaded and analyzed.\r\n\r\nThis is still the case \ud83d\ude42 ","Also sounds like JSDOM leaking","Not sure if it is related. But I get heap leak for simple expect:\r\n```\r\n  let items = tree.root.findAllByProps({ testID: 'CrewItem.Employee' })\r\n\r\n  expect(items).toHaveLength(8) \/\/ stacked and throws leak in 30-60 seconds\r\n  expect(items.length).toEqual(8) \/\/ works ok\r\n```\r\n\r\n\r\nClearing cache doesn't help","I am facing similar issues ","Same issue here as well. (using ts-jest)","I got it during a full run in which some tests failed. I spent some time debugging and taking memory snapshots and comparing.. I couldn\u2019t find any leaks.\r\nI ran it with inspect in watch mode, run in band, took a snapshot after the first run, then ran again and took another. Is that the best way to find leaks?","I think I'm running into the same issue. Created a new app recently with Jest 26. Using Enzyme for snapshot testing. Updated a test to use `mount` instead of `shallow` and now it gets out of memory errors everytime I run it even if it's the only test running. Node's out there using something like 1.5GB. This is with or without coverage and I've tried clearing cache as well. I can provide my repo as an example if needed. \r\n\r\nI posted an issue to Enzyme https:\/\/github.com\/enzymejs\/enzyme\/issues\/2405#issuecomment-646957124\r\n\r\nBelow is the error I get on this test\r\n```\r\nTest suite failed to run\r\n\r\n    Call retries were exceeded\r\n\r\n      at ChildProcessWorker.initialize (node_modules\/jest-runner\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:191:21)\r\n\r\n\r\n<--- Last few GCs --->\r\n\r\n[3466:0x39d1050]    32366 ms: Mark-sweep 1390.7 (1425.4) -> 1390.2 (1425.9) MB, 714.3 \/ 0.0 ms  (average mu = 0.110, current mu = 0.013) allocation failure scavenge might not succeed\r\n[3466:0x39d1050]    33470 ms: Mark-sweep 1391.0 (1425.9) -> 1390.5 (1426.4) MB, 1091.8 \/ 0.0 ms  (average mu = 0.053, current mu = 0.010) allocation failure scavenge might not succeed\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x23bdb465be1d]\r\n    1: StubFrame [pc: 0x23bdb465d1df]\r\nSecurity context: 0x1e8e53f9e6c1 <JSObject>\r\n    2: printBasicValue(aka printBasicValue) [0x2c6a1c7d28e1] [<root>\/node_modules\/jest-snapshot\/node_modules\/pretty-format\/build\/index.js:~108] [pc=0x23bdb4dcdac1](this=0x00329d2826f1 <undefined>,val=0x3125160c22e1 <String[14]: onSubMenuClick>,printFunctionName=0x00329...\r\n```","I tried removing random test suites from my tests but still jest memory leaks. So there is no particular test causing the leak.","I had a similar problem where I used to run into `Out of Memory `error when Jest started to do coverage on \"untested files\".\r\nUsing **v8** as **coverage provider** solved the issue for me.\r\nHowever, its an experimental feature (as per documentation) -\r\nhttps:\/\/jestjs.io\/blog\/2020\/01\/21\/jest-25#v8-code-coverage","After doing some research, it seems this memory leak has been an ongoing issue since 2019 (Jest 22) so wanted to consolidate some notes here for posterity.  Past issues have been related to graceful-fs and I think some have solved it via a hack\/workaround that removes graceful-fs and then re-adds graceful-js after running jest.  One troubleshooting thread was looking at compileFunction in the `vm` package as a potential cause.  It seems that jest, webpack-dev-server, babel, and create-react-app are using graceful-js as a dependency.  The memory leak issue was supposed to be fixed in a newer release of Jest but there may have been a regression since it is popping up again.  I can confirm everything was working fine until a substantial amount of Jest tests were created in our environment and then the heap overflows on our CI machine after the heap size grows larger than the allocated memory due to the leak.  I've tried using 1 worker, runInBand, etc. without success.\r\n\r\nThe common cause of the issues I've seen is collecting coverage via collecting coverage and graceful-fs.  I haven't done an in-depth analysis of those issues but seeing that they are both filesystem-related and having solved my own issue which was related to file imports I suspect they are some version of the same issue I was having.\r\n\r\nWanted to provide the **solution I found** so others may reap benefits:\r\n\r\n**The cause**: \r\n\r\nUsing imports of the format `import * from 'whatever'`\r\n\r\n**The solution**:\r\n\r\nUsing the format `import { whatINeed } from 'whatever'` instead dramatically reduced the memory accumulation","Often times when this happens, I delete the src folder (provided it's on version control) and run \r\n`git checkout .`\r\n and \r\n`jest --clearCache`\r\nand now running the tests again works as before. In my case, not sure it has anything to do with upgrade  but since it has occurred a few times over the last 6 months i thought to share","+1 @alexfromapex solution did not worked for me.\r\n\r\nJest 26.6.3\r\nNode 14.15.4\r\n\r\nDump: https:\/\/pastebin.com\/Mfwi2iiA\r\n\r\nIt happens after some re-runs on any CI server (my runners are docker containers). Always after a fresh boot it works normally, and after some runs, it breaks again, only comming back after a new reboot. I tried with 1GB RAM and 2GB RAM machines, same result. It seems not happening with 8GB+ RAM hardware (my local machine).\r\n\r\nSome other info I've gathered, it happens always after ~5m running, everytime the test log has the same size (it might be happening at same spot).","i have the same issue","I have very similar issue,\r\n\r\nMy test:\r\n``` js\r\nconst first = [ div_obj, p_obj, a_obj ]; \/\/ array with three DOM elements\r\nconst second = [ div_obj, p_obj, a_obj ]; \/\/ array with same DOM elements\r\nsecond.push( pre_obj ); \/\/ add new obj\r\n\r\nexpect(first).toEqual(second); \/\/ compare two arrays one 3 elements other 4 elements\r\n```\r\ntest should fail within 250 ms (timeout), but it takes 40 sec and it spits out message:\r\n```\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n...\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x55e78ec781b9]\r\nSecurity context: 0x086b49dc08d1 <JSObject>\r\n    1: toString [0x2cb560879521](this=0x1a95f0796eb1 <Object map = 0x2b3cdd5e4839>)\r\n    2: printComplexValue(aka printComplexValue) [0x329610605059] [\/home\/joe\/..\/node_modules\/pretty-format\/build\/index.js:~198] [pc=0x1413a8b0e5ac](this=0x059db4cc04b1 <undefined>,0x1a95f0796eb1 <Object map = 0x2b3cdd5...\r\n```\r\nSomehow I believe stack trace points to `printComplexValue`. I also tried `toMatchObject`, but exactly the same.\r\n\r\nJest: v26.6.3","I have a similar issue with:\r\n\r\nNode: 15.5.1\r\nJest: 25.5.4","> It seems not happening with 8GB+ RAM hardware (my local machine).\r\n\r\nUpdate: It just happened in my local host with 8GB ram, but this time in watch mode and outside docker, running a single test, after consecutive file saves (without waiting tests to finish).\r\n\r\nHere is the dump: https:\/\/pastebin.com\/jrDkCYiH\r\n\r\nIDK if this help, but here is the memory status when it happened:\r\n\r\n```bash\r\n[klarkc@ssdarch ~]$ free -m\r\n              total        used        free      shared  buff\/cache   available\r\nMem:           7738        3731        2621         473        1385        3226\r\nSwap:          8191        2133        6058\r\n```","I had this same error on my Gitlab CI and I just temporary added the `-clearCache` jest option and it works well.","We see this regularly on our tests at https:\/\/github.com\/renovatebot\/renovate","We see this regularly on our tests -- the first one succeeds then the second fails.","Have no idea why this worked for me but I had accidentally removed `'js'` from `moduleFileExtensions` in my `jest.config.ts` and then that's when my heap issues started going wild. But when I added it back, my heap issues went away.\r\n\r\nSo now I have `moduleFileExtensions: ['js', 'ts']`. Hopefully this helps someone!","This also happened to me: https:\/\/github.com\/icecream17\/solver\/runs\/2562701426?check_suite_focus=true in https:\/\/github.com\/icecream17\/solver\/actions\/runs\/834149179\r\n\r\nFailing commit: https:\/\/github.com\/icecream17\/solver\/commit\/7956c084b9dbbdfb721a2c56b7bea66eb83cc555, fixed commit: https:\/\/github.com\/icecream17\/solver\/commit\/06064acf014a0adb73d918cff3ea18657b3b2feb\r\nUpdate: I managed to use typescript again: https:\/\/github.com\/icecream17\/solver\/commit\/1b9f406ef14ece14c14ce6f14ccacac7f7b247ad\r\n\r\n(Sorry for the unhelpful links)","Since this is a heap issue, maybe triggering garbage collection and de-referencing unused or global variables will also help fix?  Look out for things that are leaving lots of memory hanging around in the heap.","I was facing the same error on GitHub actions. I was able to pin down the problem in my case to the currently experimental ESM support #9430.\r\n\r\nFor comparison here are two profiling screenshots (I followed [this article](https:\/\/making.close.com\/posts\/finding-the-cause-of-a-memory-leak-in-jest) for instructions):\r\n\r\n## CJS (leaked ~20mb)\r\n\r\n![CleanShot 2021-06-23 at 19 36 59](https:\/\/user-images.githubusercontent.com\/1567498\/123143116-7d580e00-d45a-11eb-98be-64853f6f6bb2.png)\r\n\r\n## ESM (leaked ~1gb \ud83d\ude31 )\r\n\r\n![CleanShot 2021-06-23 at 19 39 12](https:\/\/user-images.githubusercontent.com\/1567498\/123143357-cad47b00-d45a-11eb-8af9-4c42db462fe6.png)\r\n","I can prevent this error by using fake timers:\r\n\r\njest.test.setup.js:\r\n\r\n``\r\njest.useFakeTimers();\r\n``\r\n","i was running into this issue and it appears that upgrading to jest 27 fixed it","Upgrading from Jest 23 to 24 is triggering this for me. Are folks who are on Jest 27 relieved from this issue?","Trying to migrate from 26.6.3 to 27.2.5 and got the same issue.","I think I managed to reproduce it by trying to add 1000000 `PureSudoku` to an array in global scope (not in a test block)","I had what I thought may be a similar error.  \r\n\r\nUsing `--coverage`  while running inside a container like the node:alpine docker image was a problem for me. I really didn't need to be running tests in a container so maybe my comment\/solution here https:\/\/github.com\/facebook\/jest\/issues\/5837#issuecomment-1002239562 may help someone.","I had the same problem (also while collecting coverage data, on GitHub Actions\/CI) and fixed it by limiting the number of workers:\r\n- `maxWorkers: 2` in `jest.config.js`\r\n- or `--w 2` as a command line parameter.","I suspect that this issue might be related to the way that the objects that are being compared are being printed.\r\nFiled an issue with a minimal reproduction here: https:\/\/github.com\/facebook\/jest\/issues\/12364\r\n\r\nIn effect, Jest will stop short if it's trying to print a very deeply nested object, but doesn't account for \"total nodes\" so for objects that are fairly shallow but very wide (such as many React\/Enzyme elements) it will try to print the whole object and will run out of memory while constructing the string.","I was having a similar issue where random tests would timeout. I added three arguments to my jest.config.js file and it seems to have helped. Seems to have been happening on both windows, mac, and in our gitlab pipeline.\r\n\r\ntestTimeout: 10000,\r\nmaxConcurrency: 3,\r\nmaxWorkers: '50%',\r\n\r\nSurprisingly the tests execute faster as well. By ~15-20%.","Hi,\r\n\r\nI'm running tests on Ubuntu 20.04 with jest 28.1.3 and I'm seeing jest allocating 13gb of ram by running 75 tests. I also ran tests on macbook m1 and there is no such issue, it takes only 1gb or ram.\r\n\r\nMy guess is that each worker is very inefficiently allocated. Also using @rstock08 maxWorkers and maxConcurrency helps to mitigate the issue.","I also had this issue, and I had to change my collectCoverageFrom array.\r\n\r\nBefore I had: \r\n\r\n`\r\n\"collectCoverageFrom\": [\r\n      \"**\/*.{js,jsx}\",\r\n      \"!**\/node_modules\/**\",\r\n      ...\r\n    ]\r\n`\r\nBut for some reason it seemed to still be running over the node_modules folder.  I changed this by taking away the exclude node_modules and changing my patterns to include just the directories I needed:\r\n\r\n`\r\n\"collectCoverageFrom\": [\r\n      \"<rootDir>\/*.js\",\r\n      \"<rootDir>\/components\/**\",\r\n`\r\nI don't like having to do this, because it may be easy to miss future coverage, but all attempts to exclude the node_modules folder either had other errors or reintroduced the \"out of memory\" issue.","I had this issue happen even with Jest 29. This issue was caused by an unexpected infinite loop within my code.\r\n\r\nThis might be why it's hard to track down.","Issue happening with jest v29 inside docker container.\r\nTests run fine on host machine.","We are also struggling with this issue on Jest 26. Upgrading to Jest 29 didn't work.","Specifying \r\nNODE_OPTIONS=\"--max-old-space-size=2048\"\r\nhelped us to solve the issue","> \r\n\r\nSadly, this didn't solve our issues however, I can run our unit tests in two sessions which solves the issue for now","> I had the same problem (also while collecting coverage data, on GitHub Actions\/CI) and fixed it by limiting the number of workers:\r\n> \r\n> * `maxWorkers: 2` in `jest.config.js`\r\n> * or `--w 2` as a command line parameter.\r\n\r\nThis solved my issue:\r\nhttps:\/\/stackoverflow.com\/a\/68307839\/9331978","For me this happened only on CI.\r\nTurns out it was because on CI the default is `runInBand`, so adding this locally helped me replicate the issue on a local machine.\r\nFor me it happened when an exception was thrown inside the callback given to a `useLayoutEffect()`.\r\nIt just ran for ever, consuming more and more memory.\r\nHope this helps someone in this thread \ud83d\ude4f ","Updating my `jest.config.ts` with `coverageProvider: 'v8'` and `maxWorkers: 2` did the trick for me!","I tried a few different solutions that **didn't** work for me:\r\n\r\n* increasing `--max-old-space-size`\r\n* using the node flag: node `--no-compilation-cache`\r\n* use  `--runInBand`\r\n* use `--expose-gc`\r\n* limiting the number of workers\r\n\r\nWhat **did** work for me:\r\n\r\n[Limiting the idle memory per worker](https:\/\/jestjs.io\/docs\/configuration#workeridlememorylimit-numberstring) using the flag `workerIdleMemoryLimit`\r\n\r\nI'm also limiting the number of workers so maybe it was a combination of the solutions.","> testTimeout: 10000,\r\n> maxConcurrency: 3,\r\n> maxWorkers: '50%',\r\n\r\nDoesn't help in my case. still stuck in the test.","Jest `29.4.2` here, happening with a single, rather simple test and it boils down to:\r\n\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Bucket: IMAGES_BUCKET,\r\n      Key: `${a}\/${b}\/info.json`,\r\n      Body: expect.jsonMatching(infoFile),\r\n      ContentType: \"application\/json\",\r\n    });\r\n```\r\n\r\nThe s3 client is `import { mockClient } from \"aws-sdk-client-mock\";`\r\n```json\r\n\"aws-sdk-client-mock\": \"2.2.0\", \/\/ hapens with 3.0.0 as well\r\n\"aws-sdk-client-mock-jest\": \"2.2.0\",\r\n\"@aws-sdk\/client-s3\": \"3.414.0\",\r\n```\r\n\r\nThere's nothing fancy in there; `IMAGES_BUCKET` is actually `undefined`, `a` and `b` some constant strings, and `infoFile` is:\r\n\r\n```ts\r\n    const infoFile: SomeType = {\r\n      imageKeys: [imageObject1.Key!, imageObject2.Key!], \/\/ strings\r\n      taskToken, \/\/ string\r\n      location, \/\/ shallow dict\r\n    };\r\n```\r\n\r\nCommenting out parts of it does not help, but as soon as I comment out the whole expectation my test turns green. With it I constantly get:\r\n\r\n```\r\n<--- Last few GCs --->\r\n\r\n[186230:0x758f6a0]    55581 ms: Scavenge 2044.5 (2081.3) -> 2043.6 (2085.5) MB, 6.0 \/ 0.0 ms  (average mu = 0.244, current mu = 0.218) allocation failure; \r\n[186230:0x758f6a0]    56400 ms: Mark-sweep (reduce) 2045.6 (2085.5) -> 2044.3 (2079.8) MB, 465.3 \/ 0.0 ms  (+ 154.6 ms in 32 steps since start of marking, biggest step 6.9 ms, walltime since start of marking 638 ms) (average mu = 0.255, current mu = 0.268\r\n\r\n<--- JS stacktrace --->\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0xb85bc0 node::Abort() [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 2: 0xa94834  [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 3: 0xd667f0 v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 4: 0xd66b97 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 5: 0xf442a5  [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 6: 0xf451a8 v8::internal::Heap::RecomputeLimits(v8::internal::GarbageCollector) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 7: 0xf556b3  [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 8: 0xf56528 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n 9: 0xf30e8e v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n10: 0xf32257 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n11: 0xf1342a v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n12: 0x12d878f v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n13: 0x17055f9  [\/home\/xxx\/.nvm\/versions\/node\/v18.18.1\/bin\/node]\r\n```\r\n\r\nI tried `maxWorkers`, `runInBand`, `workerIdleMemoryLimit`, and more but to no avail.  \r\nRunning on Win11 inside WSL 2 Ubuntu LTS, node 18.18.1. Runs \"fine\" on colleagues' M2 Macs (except it's grilling it).\r\n\r\nWhat's also interesting, I use similar expectations right before and after the problematic one and they run just fine.","Have you tried node 21.1+?\n\nEDIT: oh, a specific assertion - that's weird. Could you out together a minimal reproduction?","Hi @SimenB , I'll give it a try.\r\n\r\nWhat's rather silly - this is my expectation:\r\n\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Bucket: IMAGES_BUCKET,\r\n      Key: `${a}\/${b}\/info.json`,\r\n      Body: expect.jsonMatching(infoFile),\r\n      ContentType: \"application\/json\",\r\n    });\r\n```\r\n\r\nAnd this follows _right after_ that and runs fine:\r\n\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Bucket: IMAGES_BUCKET,\r\n      Key: `${a}\/${IMAGES_DOCUMENT_NAME}`,\r\n      Body: expect.anything(),\r\n      ContentType: \"application\/pdf\",\r\n    });\r\n```\r\n\r\nBut it ain't seem to matter what the actual body of the first is, still runs oom even if I turn it into:\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Bucket: \"b\",\r\n      Key: `a`,\r\n      Body: \"\",\r\n      ContentType: \"application\/json\",\r\n    });\r\n```\r\n\r\nThis is driving me crazy. It's the same thing ...","When I strip it down to the size where I can almoste share it it starts working again -.-'\r\n\r\nBut another fun fact I forgot to mention: As soon as I attach the debugger (IntelliJ IDEA) it, too, works. Still blows up the RAM and takes forever but he can step over it. I see that IDEA comes with some \"fixes\" `jest-intellij-stdin-fix.js` and it might do other non-obvious things.\r\n\r\n---\r\n\r\n\/edit\r\n\r\nI was, however, able to boil it down further.\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Body: expect.anything(),\r\n    \/\/ ...\r\n```\r\n\r\nworks, whereas\r\n\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Body: expect.jsonMatching({}), \/\/ or jsonMatchin(1)\r\n    \/\/ ...\r\n```\r\n\r\nor even\r\n\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Body: expect.any(Number),\r\n    \/\/ ...\r\n```\r\n\r\nblows up.\r\n\r\n@SimenB is there any way I can profile the jest worker? When I `--inspect-brk` jest I only seem to get some coordinating process and not the actual runner, that blows up.\r\n\r\n\/edit2: tried node 20, same behaviour\r\n\r\n\/edit3: `expect.anything()` was a red herring - it, too, takes >2GB of RAM - sometimes the GC is just lucky enough - the tests seems to live right on the edge of my `heap_size_limit: 2197815296`.","This started happening to us this week. Affects previously passing builds.","I tried in on pure Windows and Mac and it's basically the same behaviour. The single test, which virtually does nothing, takes up about 2.5 GB of RAM. For some reasons that's too much for my WSL, in PS and Mac the max heap seems to be higher for some reason. With `--max-old-space-size=4096` everything is \"fine\", it just take 2.5 GB of RAM. But ofc, that's an absurd amount.  \r\nIn Windows, jest launches as many workers as I have virtual cores (I think), but each one takes up at least 500 MB, even though there's nothing to do for them (I run **1** test).\r\n\r\nMaybe related: https:\/\/github.com\/jestjs\/jest\/issues\/11956\r\n\r\nMy stripped-down sample only seems to use aroud 350MB:\r\n> [130094:0x71dd830]     3764 ms: Scavenge 389.2 (415.0) -> 381.8 (418.8) MB, 3.80 \/ 0.00 ms  (average mu = 0.973, current mu = 0.975) task;\r\n\r\nIt does the same thing, there's just less code not being executed.","> Trying to migrate from 26.6.3 to 27.2.5 and got the same issue.\r\n\r\n@mike-4040 I'm facing the same problem. Did you solve it?","Alright, I drilled further down into jest and here's what I've found:\r\n\r\nThere's some map-reduce equality check, counting if any invocation matched the given args (and swallowing any exception). In my test, one input was a \"larger\" image and for some reason that equality check took 2+ GB of RAM for the 4 MB image. I don't know what Jest does down there in order to compare the 4 MB buffer to a 4 byte string, but I circumvented the issue by reducing the image to 1x1 pixels (for the actual contents don't matter for now).","@pedrohamarques \r\n\r\n> I'm facing the same problem. Did you solve it?\r\n\r\nYes, by migrating to mocha + chai + sinon :)","@black-snow would you be able to share that image (perhaps privately?)","@SimenB the concrete image doesn't seem to be the issue, jest hangs in the matcher `toHaveReceivedCommandWith`, especially in the try block in\r\n\r\n```js\r\n            check: ({ commandCalls }) => {\r\n                const matchCount = commandCalls\r\n                    .map(call => call.args[0].input) \/\/ eslint-disable-line @typescript-eslint\/no-unsafe-return\r\n                    .map(received => {\r\n                    try {\r\n                        expect(received).toEqual(expect.objectContaining(input)); \/\/ here\r\n                        return true;\r\n                    }\r\n                    catch (e) {\r\n                        return false;\r\n                    }\r\n                })\r\n                    .reduce((acc, val) => acc + Number(val), 0);\r\n                return { pass: matchCount > 0, data: { matchCount } };\r\n            }\r\n```\r\n\r\nJest iterates over all the things it received and does some comparison. When it hits my\r\n\r\n```ts\r\n    expect(s3.client).toHaveReceivedCommandWith(PutObjectCommand, {\r\n      Bucket: IMAGES_BUCKET,\r\n      Key: `${a}\/${b}\/info.json`,\r\n      Body: expect.jsonMatching(infoFile),\r\n      ContentType: \"application\/json\",\r\n    });\r\n```\r\n\r\nit compares a 4 MB buffer, probably containing the jpeg with some 4 byte values and for some reason this blows up the heap and takes forever.\r\n\r\nP.S.: Why not return 0\/1 instead of booleans, which get cast to Number right after?","> > I had the same problem (also while collecting coverage data, on GitHub Actions\/CI) and fixed it by limiting the number of workers:\r\n> > \r\n> > * `maxWorkers: 2` in `jest.config.js`\r\n> > * or `--w 2` as a command line parameter.\r\n> \r\n> This solved my issue: https:\/\/stackoverflow.com\/a\/68307839\/9331978\r\n\r\nThis solved mine too thanks!","I ran into the issue with Node 16.19.0 and Jest 29.7.0.\r\n\r\nWhat did not work for me:\r\n\r\n- Clearing cache\r\n- Limiting maxWorkers to 2 or to 1, or runInBand\r\n- Not currently able to upgrade Node or downgrade it to 16.10.0 (as per https:\/\/github.com\/jestjs\/jest\/issues\/11956)\r\n\r\nWhat did work for me:\r\n\r\n- Setting `workerIdleMemoryLimit` to `1 GB`\r\n","Same problem in Node 16.20.2 and Jest 29.7.0\r\n\r\nWhat did not work for me:\r\n\r\n* Clearing cache\r\n* Limiting maxWorkers to 2 or to 1, or runInBand\r\n* Setting workerIdleMemoryLimit to 1 GB, to 50%, or to 0.2\r\n* Changing Node version is not an option.\r\n\r\nThis worked:\r\n\r\n* Setting NODE_OPTIONS max_old_space_size before running jest: \r\n      \r\n```\r\nexport NODE_OPTIONS=--max_old_space_size=8192\r\njest\r\n```\r\n\r\nor \r\n\r\n```\r\nNODE_OPTIONS='--max_old_space_size=8192' jest\r\n```\r\n\r\n\r\n"],"labels":["Needs Triage","Bug Report"]},{"title":"[jest-circus] remove DescribeBlock.tests","body":"See also #9973","comments":["for posterity, should be a matter of reverting a8052935cd4d767ee2f47abea434db393207885b"],"labels":[":rocket: Feature Request"]},{"title":"[jest-circus] DescribeBlock.tests deprecation warnings","body":"Can be implemented using a getter calling `console.warn`","comments":["@jeysal we need to write some clear migration guides, `tests` has been there for years. Warning could link to it (fine as just an issue I think, not necessarily something for the website)\r\n\r\nFYI @noomorph for detox","Yeah I can add that to the code comments in circus, so that when maintainers look into how to get rid of the warnings they see how to do it.\r\nI'll can take care of this issue soon-ish","@SimenB, I might be not in the context, do you mean you wanted to remove something from `event` or `state` internals, like `currentDescribeBlock.tests`? I can't really guess by the description, sorry.\r\n![Screenshot from 2020-05-05 16-00-03](https:\/\/user-images.githubusercontent.com\/1962469\/81068739-8948df80-8ee9-11ea-9272-7c57aae230cc.png)\r\n","Yeah shame we don't have the documentation yet, we are removing the `tests` property in the state; instead the `children` property of the describe block will have both child describe blocks and child tests, which can be distunguished by their `type` (`describeBlock` or `test`).","We initially removed it in 26.0, but noticed that it breaks some packages like Detox, added it back, and now want to give them time to stop using it and we'll remove it in 27.0"],"labels":[":rocket: Feature Request"]},{"title":"ESM Modules implementations leak memory","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nThe new experimental implementation leaks memory.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nUsing node 13 or 14 (for unflagged ESM)\r\n\r\n```sh-session\r\n$ git clone git@github.com:facebook\/jest.git\r\n$ cd jest\r\n$ yarn\r\n$ cd e2e\/native-esm\r\n$ node --experimental-vm-modules ..\/..\/packages\/jest\/bin\/jest.js --detect-leaks\r\n```\r\n\r\n## Expected behavior\r\n\r\nIt should not leak\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nThis repo","comments":["I had a look and it seems that the issue is with Node. The references to SourceTextModule are not cleaned up properly.  I will look into it more, but 90% that's it. I will open an issue in Node if it's true and will mention this issue.","SourceTextModule never get collected by GC and thus everything they hold reference too.\r\nHere is the issue: https:\/\/github.com\/nodejs\/node\/issues\/33439","Thanks @grosto!","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days."],"labels":[":bug: Bug","Help Wanted","Upstream Bug","ES Modules","Pinned"]},{"title":"Jest should avoid printing the individual tests if beforeAll fails","body":"## \ud83d\udc1b Bug Report\r\n\r\nWhen beforeAll fails, none of the other tests actually execute, but they all fail with the same reason, and they all print the same error.\r\n\r\nJest should avoid printing the individual tests if beforeAll fails. Right now the implementation just checks if there is an error and if yes, print it and fail the test without actually executing it.\r\n\r\nNote that @SimenB asked me to create this https:\/\/github.com\/facebook\/jest\/issues\/6695#issuecomment-619405847.\r\n\r\n## To Reproduce\r\n\r\nRun a beforeAll() that fails where a couple of tests are executed after. This is the failure received (with the supplied repro below):\r\n\r\n```sh\r\n FAIL   src\/test.unit.test.js\r\n  test that a 3rd party API remains consistent\r\n    \u2715 API function 1\r\n    \u2715 API function 2\r\n    \u2715 API function 3\r\n\r\n  \u25cf test that a 3rd party API remains consistent \u203a API function 1\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: \"successful\"\r\n    Received: \"login\"\r\n\r\n      1 | describe('test that a 3rd party API remains consistent', () => {\r\n    > 2 |   beforeAll(() => expect('login').toBe('successful')); \/\/ this will fail\r\n        |                                   ^\r\n      3 |   test('API function 1', () => expect(1).toBe(1)); \/\/ each...\r\n      4 |   test('API function 2', () => expect(2).toBe(2)); \/\/ ...of these...\r\n      5 |   test('API function 3', () => expect(3).toBe(3)); \/\/ ...will fail too\r\n\r\n      at src\/test.unit.test.js:2:35\r\n\r\n  \u25cf test that a 3rd party API remains consistent \u203a API function 2\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: \"successful\"\r\n    Received: \"login\"\r\n\r\n      1 | describe('test that a 3rd party API remains consistent', () => {\r\n    > 2 |   beforeAll(() => expect('login').toBe('successful')); \/\/ this will fail\r\n        |                                   ^\r\n      3 |   test('API function 1', () => expect(1).toBe(1)); \/\/ each...\r\n      4 |   test('API function 2', () => expect(2).toBe(2)); \/\/ ...of these...\r\n      5 |   test('API function 3', () => expect(3).toBe(3)); \/\/ ...will fail too\r\n\r\n      at src\/test.unit.test.js:2:35\r\n\r\n  \u25cf test that a 3rd party API remains consistent \u203a API function 3\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: \"successful\"\r\n    Received: \"login\"\r\n\r\n      1 | describe('test that a 3rd party API remains consistent', () => {\r\n    > 2 |   beforeAll(() => expect('login').toBe('successful')); \/\/ this will fail\r\n        |                                   ^\r\n      3 |   test('API function 1', () => expect(1).toBe(1)); \/\/ each...\r\n      4 |   test('API function 2', () => expect(2).toBe(2)); \/\/ ...of these...\r\n      5 |   test('API function 3', () => expect(3).toBe(3)); \/\/ ...will fail too\r\n\r\n      at src\/test.unit.test.js:2:35\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       3 failed, 3 total\r\nSnapshots:   0 total\r\nTime:        1.037s\r\n```\r\n\r\n## Expected behavior\r\n\r\nJest should avoid printing the individual tests if beforeAll fails. It is highly confusing for users.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n```javascript\r\ndescribe('test that a 3rd party API remains consistent', () => {\r\n  beforeAll(() => expect('login').toBe('successful')); \/\/ this will fail\r\n  test('API function 1', () => expect(1).toBe(1)); \/\/ each...\r\n  test('API function 2', () => expect(2).toBe(2)); \/\/ ...of these...\r\n  test('API function 3', () => expect(3).toBe(3)); \/\/ ...will be reported as failed too\r\n});\r\n\r\n```\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: Linux 4.15 Ubuntu 18.04.4 LTS (Bionic Beaver)\r\n    CPU: (4) x64 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 12.15.0 - ~\/.config\/nvm\/12.15.0\/bin\/node\r\n    npm: 6.13.4 - ~\/.config\/nvm\/12.15.0\/bin\/npm\r\n  npmPackages:\r\n    jest: 25.1.0 => 25.1.0\r\n```\r\n","comments":["Hi \ud83d\udc4b \r\n\r\nCan I work on this issue?","Yeah, that'd be lovely! Feel free to ask questions if you get stuck or want a pointer \ud83d\ude42 \r\n\r\nI'd start in `jest-circus` (`jest-jasmine` is soft-deprecated, so unless you want to you can ignore it). Maybe the approach in #7201 might help you get started?","When `beforeAll` fails, it also ignores `it.only` and logs all tests as failing: https:\/\/repl.it\/repls\/MobileBaggyLearning \r\n\r\nWasn't sure if this bug will already be fixed by #10004 so please let me know if you'd like me to file a new issue!","Hi! Has there been any progress on this issue? :)","@vldmrkl Looking forward to you working on this issue \ud83d\ude04 ","Sorry, can't continue working on this issue.\r\nMy latest progress could be found at #10004\r\nI apologize for miscommunication.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","I think this change still makes sense and the issue should remain open.","Hey, I'd like to work on this issue. :)","@itaizelther I'd say go for it and push a PR, continuing on the one already started.","@thernstig I have no write permissions to the existing PR, so I have created a new one: #13273 \r\nIt is done, you may review it","I am not a maintainer here, just meant that I don't think anyone minds if you start a new PR. Great that you did!","@itaizelther thank you \ud83d\ude4f\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Since there is a PR at https:\/\/github.com\/jestjs\/jest\/pull\/13273 I am bumping this"],"labels":[":bug: Bug","Help Wanted"]},{"title":"ESM should require file extensions","body":"## \ud83d\udc1b Bug Report\r\n\r\n```js\r\nimport t from '.\/file';\r\nimport d from '.\/directory\/'\r\n```\r\n\r\nThese should both fail to resolve, but since we use the same resolver as for CJS, it doesn't, and the import will work while it would have failed at runtime. This is also the case for dynamic imports.\r\n\r\nThis might need some support in [`resolve`](https:\/\/github.com\/browserify\/resolve) whenever they add support for ESM? https:\/\/github.com\/browserify\/resolve\/issues\/222\r\n\r\nPlace where we call resolve in jest: https:\/\/github.com\/facebook\/jest\/blob\/c024dec130d9914dcc3418ea74c26f667db3dbfa\/packages\/jest-runtime\/src\/index.ts#L395-L398\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/c024dec130d9914dcc3418ea74c26f667db3dbfa\/packages\/jest-runtime\/src\/index.ts#L423\r\n\r\nNode docs: https:\/\/nodejs.org\/api\/esm.html#esm_mandatory_file_extensions\r\nNode issue for better errors: https:\/\/github.com\/nodejs\/node\/issues\/30603","comments":["Would this change fail also when `--es-module-specifier-resolution=node` is used?","`--experimental-specifier-resolution=node` is the flag. And yeah, we'd need to keep the logic around for that case... Not sure how to best detect if it has been passed. It's not present in `process.argv` so we might need to have our own option for this \ud83d\ude41 ","Maybe you can get it from `process.execArgv`.","For what it's worth, `ts-node` is doing this today.  We check both positional args and also the `NODE_OPTIONS` environment variable.  If you would like, I'll point you at our implementation.  We could also expose it via our API surface.\r\n\r\nThere's probably going to be a fair bit of overlap here, both for this and for mapping between `rootDir` and `outDir` and between file extensions.  Let me know if collaborating on a shared module to handle this stuff makes sense to you.","I'm using `eslint-plugin-import` with ` \"import\/extensions\": [\"error\", \"ignorePackages\"]` rule to make sure all imports have extensions","OK, now that TS has announced they'll be forcing Node ESM to use extensions (https:\/\/devblogs.microsoft.com\/typescript\/announcing-typescript-4-5-beta\/#new-file-extensions, https:\/\/twitter.com\/orta\/status\/1444958295865937920) we need to figure this out (preferably releasing a few weeks before 4.5 goes stable to get ahead of all the people who will complain that Jest doesn't work).\r\n\r\n---\r\n\r\nCurrent plan is to enforce file extensions for ESM resolution (`import` and `import()`), but allow some sort of opt-in to the current (i.e. CJS) behavior (like `--experimental-specifier-resolution` mentioned above does). I don't think I'd like to auto-detect the presence of that flag.\r\n\r\nThis also impacts https:\/\/jestjs.io\/docs\/configuration#extensionstotreatasesm-arraystring - we might have to start throwing on that and tell people to use `type`...\r\n\r\n\/cc @ahnpnl ","@cspotcode I'd be very interested to hear how this impacts `ts-node` \ud83d\ude42 ","The file extensions behaviour shouldn't affect ts-node much.  We already align with TS and node as far as file extensions go, and we resolve correctly.\r\n\r\n`import` statements should point to the emitted js (that's what you want to import, after all) and we resolve that to the source `.ts`, since it's our job to essential emit in-memory, not on the filesystem.  For production you can pre-compile to the filesystem and get rid of `ts-node` and everything works.\r\n\r\n`ts-node` matches node's behavior regarding `--experimental-specifier-resolution`, which is to say, if you omit that flag, then file extensions are required.  If you pass that flag via `NODE_OPTIONS` or whatever, then you get the behavior of that flag.","Currently, `ts-jest` logic follows what Jest asks for. IIRC `extensiosToTreatAsESM` is a short-term solution to adopt ESM? If we can switch to use `type` instead, it would be better that we can remove one Jest config option.\r\n\r\nIn general, for transformer, I think we should just stick to the current approach that transformer should give what Jest needs. Maybe small changes from `ts-jest` side.","I don't think we can remove `extensionsToTreatAsESM`, if nothing else since TS doesn't have any plans (I asked Orta) for enforcing extensions when outputting ESM for non-node (even though it's technically invalid ESM, they cannot break everybody outputting it and then consumed by bundlers). So Jest shouldn't force people to use extensions if they don't want. `extensionsToTreatAsESM` is a nice escape hatch for those cases.\r\n\r\nBut we should probably expand our current handling to first check `extensionsToTreatAsESM`, then look at `type` also for `.ts` and `.tsx`.\r\n\r\nBut defaulting to requiring the extension for ESM mode seems sensible to me. Then maybe some way of specifying you want CJS resolution mode (I don't wanna sniff out options passed to node, I'd rather have a CLI options ourselves - people can toggle that on or off via looking at node flags if they want)","> even though it's technically invalid ESM\r\n\r\nIsn't the format of module specifiers host-defined, so it's valid ESM?  According to the spec.","Sure, but it's invalid in node (without experimental flag) and browsers, which should cover (completely made up number) 99% of hosts running the code natively, no?","Bundlers are effectively a runtime target.  I simply mean that, in terms of the TS team's decision-making, it is *technically* valid ESM, which is why they're supporting it.  It's not merely a backwards-compat issue.  A lot of the ecosystem's problems tend to get blamed on TS, when it's actually TS playing along with the ecosystem's desire to be custom at every turn.","Ah right. Fair enough \ud83d\ude42 "],"labels":[":bug: Bug","ES Modules","Pinned"]},{"title":"Add a failing test for printSnapshotAndReceived incorrectly recognizing sometimes indented lines as changed","body":"## Summary\r\n\r\nIt has been reported to Emotion that each printed style property is being shown as changed in Jest 25 when anything changes between snapshots & received: https:\/\/github.com\/emotion-js\/emotion\/issues\/1847\r\n\r\nIt turned out that we currently ignore `indentation` because we use `OldPlugin` interface and we just print retrieved styles with always indented. We plan to fix this soon, but I believe the issue is still worth fixing in Jest itself - especially that the comment here:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/32aaff83f02c347ccd591727544002490fb4ee9a\/packages\/jest-snapshot\/src\/printSnapshot.ts#L316-L317\r\nsuggests that this was supposed to be handled.\r\n\r\nSo far I've just added a failing test and would like to first check-in if there is an interest in fixing this before I dive into this further. I've also actually tried to fix this quickly by calling `dedentLines` on this:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/32aaff83f02c347ccd591727544002490fb4ee9a\/packages\/jest-snapshot\/src\/printSnapshot.ts#L324\r\nbut while it has fixed my issue it has changed 2 other tests and it would require further investigation why this is happening and how the fix could be improved.","comments":["Thanks @Andarist, failing tests are the best bug reports ever! \ud83d\ude00 \r\n\r\n@pedrottimark @jeysal any ideas here?","Just an additional note because it might not be super clear while skimming through my original post - this **has changed** between Jest 24 and Jest 25. Jest 24 did not report those false positives.\r\n\r\n","Either I messed up the merge or this is fixed. @Andarist any idea? \ud83d\ude00 ","# [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) Report\n> Merging [#9863](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (1e57d0e) into [main](https:\/\/codecov.io\/gh\/facebook\/jest\/commit\/e3c84b54d6e87d46362ef2145676404b48d670a2?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) (e3c84b5) will **increase** coverage by `0.00%`.\n> The diff coverage is `n\/a`.\n\n[![Impacted file tree graph](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863\/graphs\/tree.svg?width=650&height=150&src=pr&token=oaWHH63dBr&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n\n```diff\n@@           Coverage Diff           @@\n##             main    #9863   +\/-   ##\n=======================================\n  Coverage   68.47%   68.48%           \n=======================================\n  Files         324      324           \n  Lines       16968    16968           \n  Branches     5060     5060           \n=======================================\n+ Hits        11619    11620    +1     \n+ Misses       5317     5316    -1     \n  Partials       32       32           \n```\n\n\n| [Impacted Files](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook) | Coverage \u0394 | |\n|---|---|---|\n| [packages\/jest-snapshot\/src\/plugins.ts](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863\/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook#diff-cGFja2FnZXMvamVzdC1zbmFwc2hvdC9zcmMvcGx1Z2lucy50cw==) | `100.00% <0.00%> (+20.00%)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n> **Legend** - [Click here to learn more](https:\/\/docs.codecov.io\/docs\/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook)\n> `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n> Powered by [Codecov](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Last update [e3c84b5...1e57d0e](https:\/\/codecov.io\/gh\/facebook\/jest\/pull\/9863?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook). Read the [comment docs](https:\/\/docs.codecov.io\/docs\/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=facebook).\n","@SimenB This PR was sent quite some time ago - there is a high chance of this being fixed now so perhaps this can be closed. I would probably recommend trying to check if there is already a test for this because if there is not then maybe it's still worth landing this PR so this test could act as a regression test for the future.\r\n\r\nI'm afraid that I won't have enough time to look into this myself though.","I'm happy to land this as a regression test \ud83d\ude42 ","Ah wait no, the test demonstrates the error, it wasn't a _failing_ test. Makes sense! Ref https:\/\/github.com\/facebook\/jest\/pull\/9863#discussion_r413071029","Ah, so the problem is still here - I just didn't make it a failing test case back then but rather a test showcasing an invalid behavior, did I get this right (I'm refreshing my own memory about this issue)?","yeah, seems like it to me \ud83d\ude42 ","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump for stale bot","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump for stale bot"],"labels":["cla signed"]},{"title":"Is jest fully scanning node_modules and then ignoring its content by default ?","body":"## \u26a1 Performance improvement ?\r\n\r\nJest has been slow to start on my computer, which has a relatively slow filesystem (windows ntfs and a few layers of encryption).\r\n\r\nReading the default configuration, I'm wondering whether jest scans every file in the `<rootDir>` and then ignores the ones in node_modules. I replaced my roots with `<rootDir>\/src\/` instead of `<rootDir>` and it feels faster.\r\n\r\n## To Reproduce\r\n\r\n - Develop a javascript project with a lot of npm dependencies with many files on a slow filesystem.\r\n - Run jest with no config.\r\n - Run jest with `roots: ['<rootDir>\/src\/']` in its config.\r\n\r\n## Expected behavior\r\n\r\nJest should scan the files to find the tests relatively fast. But by default I'm not sure it's the case.\r\n\r\n## envinfo\r\n\r\n```\r\nSystem:\r\n    OS: Windows 10 10.0.18363\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz\r\n  Binaries:\r\n    Node: 12.13.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 6.12.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^25.4.0 => 25.4.0\r\n```\r\n","comments":["https:\/\/github.com\/facebook\/jest\/blob\/32aaff83f02c347ccd591727544002490fb4ee9a\/packages\/jest-core\/src\/SearchSource.ts#L139-L144\r\n\r\nI'm wondering whether `this._context.hasteFS.getAllFiles()` returns all files in `<rootDir>` including the files from node_modules.\r\n","what is the right configuration in monorepo to improve this?","I'm certain this is what I'm seeing right now.\r\n\r\n`ps aux` gives me the following file scan (docker linux):\r\n\r\n```log\r\nfind \/app -type f ( -iname *.snap -o -iname *.js -o -iname *.json -o -iname *.jsx -o -iname *.ts -o -iname *.tsx -o -iname *.node )\r\n```\r\n\r\nThis is causing around a 30s run for a single test file in `\/app\/src\/test\/simple.test.js`:\r\n\r\n```javascript\r\ndescribe('simple', () => {\r\n  it('should be sane', () => {\r\n    expect(false).not.toBe(true);\r\n  });\r\n});\r\n```","Just figured out how it works and it's a sad story.. \ud83d\ude1e \r\n\r\nFirst it checks if you have `watchman` installed..\r\n \r\nhttps:\/\/github.com\/facebook\/jest\/blob\/ac73de8989ca06675858b4c8b4f3e6f864a071f0\/packages\/jest-haste-map\/src\/index.ts#L738\r\n\r\n**and if not...**\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/ac73de8989ca06675858b4c8b4f3e6f864a071f0\/packages\/jest-haste-map\/src\/crawlers\/node.ts#L233\r\n\r\nit either uses native find (your usecase @jufemaiz ) for **all files** in `rootDir`!!!\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/ac73de8989ca06675858b4c8b4f3e6f864a071f0\/packages\/jest-haste-map\/src\/crawlers\/node.ts#L236\r\n\r\nor if `find` is not available, on Windows for example if I understand correctly, then it travers recursively all directories in Node.js code.. Seems like @fungiboletus case ","And the worst part is that all this Jest do completely silently.. No message like \"Hey install watchman\" or \"Warning: Native find is not available on your system\".. ","is it much faster using watchman?","In our project, with watchman, startup time is almost instantaneous. \r\nIn comparison without watchman, it takes 10s to start first test - `find` output includes even files from node_modules so in our case it is more than 8MB just this file list..","Sounds like having a warning on the console output would be a good improvement.","Definitely @fungiboletus !","Also worth mentioning that last saved index must be available in jest cache and cache key must be valid otherwise it builds index again.\r\n\r\nAnd completely agree that it should be evident from CLI that indexing is happening and in documentation I think it should be stated how to avoid it. \r\n\r\nFrom `jest-haste-map` code:\r\n```\r\n * The HasteMap is created as follows:\r\n *  1. read data from the cache or create an empty structure.\r\n *\r\n *  2. crawl the file system.\r\n *     * empty cache: crawl the entire file system.\r\n *     * cache available:\r\n *       * if watchman is available: get file system delta changes.\r\n *       * if watchman is unavailable: crawl the entire file system.\r\n```","Is the startup time going only up when you are actually running in watch mode or is it sufficient to have watchman installed?\r\n\r\nWe have a quite big mono repo with > 3k tests and quite some dependencies. It takes 20-40s for jest to actually start a test run.\r\nTests itself have expected speed.","See also this config change for watchman so that it ignores node_modules. That speeds up the initial run significantly: https:\/\/github.com\/facebook\/jest\/issues\/10833#issuecomment-741748347","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","> This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\nDear GitHub bot, please hear my plea,\r\nDon't close my issue, let it be free.\r\nYour automated ways are fine,\r\nBut human touch is more divine.\r\n\r\nSo please ask the one who set you up,\r\nTo disable your auto-close cup.\r\nLet's work together, you and I,\r\nAnd keep this issue open, high and dry.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","."],"labels":["Needs Triage","Bug Report"]},{"title":"Refactor TestRunner interface","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nSee: https:\/\/github.com\/facebook\/jest\/pull\/9819#discussion_r409399788.\r\n","comments":[],"labels":[":rocket: Feature Request"]},{"title":"LCOV reporter changed from Absolute file paths to Relative","body":"#9742  \ud83d\udca5 Regression Report\r\nAfter upgrading to the 25.2.7, we saw that our reported lcov.info file is not showing the absolute file paths anymore. This is causing a problem when reporting to sonarQube.\r\n\r\nBefore on 24.8.0:\r\nSF:\/Users\/jose.sousa\/git\/project\/webapp\/common\/App.js\r\n\r\nNow on 25.2.7:\r\nSF:common\/App.js\r\n\r\n## Last working version\r\n24.9.0\r\n\r\nStopped working in version:\r\n25.1.0\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n- run jest with coverage and lcov reporter.\r\n- check lcov file generated and compare with the previous.\r\n\r\n","comments":["It seems that for version 25.2.0, we need to configure the projectRoot to fix the relative path.\r\n\r\n```\r\n\"coverageReporters\": [\r\n      [\"lcov\", {\"projectRoot\": \"..\/\"}],\r\n      \"text-summary\"\r\n    ]\r\n```","Interesting... Did any Istanbul dependencies change during your upgrade? I didn't think any changes we made would affect this","Yes, I did further analises and it seems it stop working after 24.9.0. The version 25.1.0 does have some updates to istanbul dependencies.","Right. That's expected. Essentially https:\/\/github.com\/istanbuljs\/istanbuljs\/issues\/529 and the linked PR to jest which allows you to set `projectRoot` is the \"fix\" on our side","@jcdesousa Thank's a lot. Works fine!","After setting to\r\n```\r\n [\"lcov\", {\"projectRoot\": \"\/\"}]\r\n```\r\n\r\nThe path is \r\n```\r\nSF:Users\/jose.sousa\/git\/project\/webapp\/common\/App.js\r\n```\r\nIt is still not an absolute path\r\n","@randing89  that's even a wrong path. \r\n@jcdesousa Actually, we can solve this by using the `sed` command to correct the path in `lcov.info`, even though, you still need to take care of the path may different with the `test-report.xml`","After upgrading to Jest 27.0.6, still facing the SF path issue in coverage reports. \r\n\r\nwithout coverageReporters:\r\n\r\nSF:app1\/common\/App.js\r\n\r\nwith coverageReporters `[\"lcov\", {\"projectRoot\": \"\/\"}] `:\r\n\r\nSF:Users\/<user>\/git\/project\/webapp\/app1\/common\/App.js\r\n\r\nwith coverageReporters `[\"lcov\", {\"projectRoot\": \"__dirname\"}] `:\r\n\r\nSF:..app1\/common\/App.js\r\n\r\nJest-config present in webapp folder\r\n\r\nAm expecting the following:\r\n\r\nAbsolute SF Path: \/Users\/<user>\/git\/project\/webapp\/app1\/common\/App.js\r\nRelative SF path: common\/App.js\r\n\r\nRight now using `sed` command to get it work.\r\n\r\nIs there any workaround to fix it up in jest config level? \r\n\r\n","Same problem, I am expecting absolute path. Anyone made any progress on this (except for the sed usage)","I have simple project where I use jest v29.4.3. I run `npm test` as `jest --coverage` without jest config. I get correct coverage report in console, the HTML report and XML files are correct.\r\n\r\nWhen I run the `jest --coverage` locally on Windows or macOS system, the `coverage\/lcov.info` contains correct path to `app\/index.js` file:\r\n\r\n```\r\nTN:\r\nSF:app\\index.js\r\nFN:19,(anonymous_0)\r\nFN:81,(anonymous_1)\r\n```\r\n\r\nWhen I run the same project in GitHub Action in `ubuntu-22.04` the path in `lcov.info` is incorrect. All the other files - HTML, XML reports, contain correct paths (eg. ):\r\n\r\n```\r\nTN:\r\nSF:..\/..\/home\/runner\/work\/generator-license\/generator-license\/app\/index.js\r\nFN:19,(anonymous_0)\r\nFN:81,(anonymous_1)\r\n``` \r\n\r\nFrom `clover.xml`:\r\n\r\n```xml\r\n<file name=\"index.js\" path=\"\/home\/runner\/work\/generator-license\/generator-license\/app\/index.js\">\r\n```","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":boom: Regression","Stale"]},{"title":"Config 'testTimeout' not working inside 'projects' config","body":"## \ud83d\udc1b Bug Report\r\n\r\nThe configuration `testTimeout` (https:\/\/jestjs.io\/docs\/en\/configuration#testtimeout-number) does not work in `projects` (https:\/\/jestjs.io\/docs\/en\/configuration#projects-arraystring--projectconfig)\r\n\r\n## To Reproduce\r\n\r\nUse this config and write a test taking more than 1 ms.\r\n\r\n```javascript\r\nmodule.exports = {\r\n  projects: [\r\n    {\r\n      testEnvironment: 'node',\r\n      testTimeout: 1,\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n## Expected behavior\r\n\r\nI expect each `it()`, `beforeEach()` etc. to time out after 1 ms.\r\n\r\nNote that if you move the `testTimeout: 1,` outside of the `projects` array the config does kick in. I.e. this works:\r\n\r\n```javascript\r\nmodule.exports = {\r\n  testTimeout: 1,\r\n  projects: [\r\n    {\r\n      testEnvironment: 'node',\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\nOriginal implementation: https:\/\/github.com\/facebook\/jest\/issues\/6216\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n```javascript\r\nconst { promisify } = require('util');\r\n\r\nconst sleep = promisify(setTimeout);\r\n\r\ndescribe('suite A', () => {\r\n  it('1', async () => {\r\n    await sleep(2000);\r\n    expect(true).toBeTruthy();\r\n  });\r\n});\r\n```\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: Linux 4.4 Ubuntu 16.04.5 LTS (Xenial Xerus)\r\n    CPU: (4) x64 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 12.13.0 - ~\/.config\/nvm\/12.13.0\/bin\/node\r\n    npm: 6.12.0 - ~\/.config\/nvm\/12.13.0\/bin\/npm\r\n  npmPackages:\r\n    jest: 25.1.0 => 25.1.0\r\n```\r\n","comments":["Also, just for curiosity, I assume the config `testTimeout()` works the same way as setting `jest.setTimeout()` i.e. they both do exactly the same thing?","I don't think this is fixed... We encountered the same issue on version 26.4.2.","Yep, not fixed. Also encountering the same :-)","Encountering this in 26.6.3, the workaround I use is to pass it as a flag `jest --selectProjects foo --testTimeout 60000`. ","see also https:\/\/github.com\/facebook\/jest\/issues\/9696, which suggests hoisting the testTimeout setting up a level out of the project config as a workaround (provided you're OK with the same timeout across all test projects).","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Unstale as I think this is valid","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","\ud83d\ude4c"],"labels":["Needs Triage","Bug Report"]},{"title":"missing docs for getMockImplementation of the mock api","body":"## \ud83d\udc1b Bug Report\r\n\r\ngetMockImplementation is a public method of the mock function api:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/244f7dc7310de24b4892fac55113f8a06f24d947\/packages\/jest-mock\/src\/index.ts#L103\r\nBut it is nod documented at \r\nhttps:\/\/github.com\/jwbay\/jest\/blob\/master\/docs\/MockFunctionAPI.md\r\n\r\nAlso, I believe we can better type it as we know the possible return types\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","It is still undocumented.","But it has somewhat better types. I think it should be marked `@internal` as well.\r\n\r\nReference: https:\/\/github.com\/facebook\/jest\/issues\/9061#issuecomment-543371483","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"FakeTimers don't work with nested promises","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n## To Reproduce\r\n\r\n```js\r\n test(\"jest bug\", async () => {\r\n    jest.useFakeTimers();\r\n    const fn = jest.fn();\r\n    const mainPromise = Promise.resolve(5);\r\n    const waitPromise = new Promise(resolve => setTimeout(() => resolve(mainPromise), 100));\r\n    waitPromise.then(fn); \/\/ this must be called after 100ms timeout is finished\r\n\r\n    expect(setTimeout).toBeCalled(); \/\/ it works\r\n    jest.advanceTimersToNextTimer();\r\n    await Promise.resolve(); \/\/ wait for previous promiseThen execution\r\n    expect(fn).toBeCalled(); \/\/ it doesn't work\r\n  });\r\n```\r\n\r\n## Expected behavior\r\n\r\nThe **fn** to be called\r\n\r\n## envinfo\r\n System:\r\n    OS: Windows 10 10.0.18363\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz\r\n  Binaries:\r\n    Node: 13.10.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 6.13.7 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^25.2.0 => 25.2.0\r\n\r\n## Notes\r\nThe similar behavior without nested setTimeout-promise works fine\r\n``` js\r\n test(\"jest no bug\", async () => {\r\n    jest.useFakeTimers();\r\n    const fn = jest.fn();\r\n    const waitPromise = new Promise(resolve => setTimeout(() => resolve(5), 100)).then(fn);\r\n    waitPromise.then(fn);\r\n\r\n    expect(setTimeout).toBeCalled(); \/\/ it works\r\n    jest.advanceTimersToNextTimer();\r\n    await Promise.resolve(); \/\/ wait for previous promiseThen exectution\r\n    expect(fn).toBeCalled(); \/\/ it works!!!\r\n  });\r\n```\r\n```","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Ping","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Stupid bot. Ping again :)"],"labels":["Needs Triage","Bug Report"]},{"title":"Document element and its descendants are invisible...","body":"## \ud83d\udcac Questions and Help\r\nI have in the test before section the following code, creating the div, but it seem it is created invisible since the height get methods return \"0\", and offsetParent method returns \"null\". It concerns the body and document element itself also. The code is:\r\n \r\n     beforeEach(() => {\r\n       document.body.innerHTML = '<div id=\"navbar\" style=\"height:70px;\" > navbar1 <\/div>'\r\n       let e = document.getElementById('navbar')\r\n       console.log(\"INFO:\", e.offsetHeight, e.scrollHeight, e.getBoundingClientRect().height, e.offsetParent)\r\n     })\r\n\r\nand result:\r\n\r\n     INFO: 0 0 0 null\r\n\r\nenv:\r\n\r\n     jest = 25.1.0\r\n\r\nQ: How to make the document visible in the contest of the jest?","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","@znarf ping?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","@znarf ping?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Stale"]},{"title":"When tests are stopped by timeout, pending promises continue execution","body":"## \ud83d\udc1b Bug Report\r\nWhen tests are stopped by timeout, pending promises continue execution\r\n\r\n## To Reproduce\r\nRun the following test: \r\n```\r\njest.setTimeout(3000);\r\n\r\nbeforeAll(async () => {\r\n  await longFunction(); \r\n});\r\n\r\ntest(\"Test name\", async () => {\r\n  expect(1).toBeTruthy();\r\n});\r\n\r\nafterAll(async () => {\r\n  await sleep(5000);\r\n  console.log(3)\r\n});\r\n\r\nasync function longFunction() {\r\n  console.log(1);\r\n  await sleep(5000)\r\n  console.log(2);  \r\n}\r\n\r\nfunction sleep(ms: number) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n```\r\n## Actual behavior\r\n'2' is written in console \r\n![image](https:\/\/user-images.githubusercontent.com\/38757986\/77064305-4b066800-69f0-11ea-8fd1-7d77d314b0bd.png)\r\n\r\n\r\n## Expected behavior\r\nlongFunction execution is stopped after 3 sec, therefore '2' is not written in console.\r\n\r\n## envinfo\r\n\r\n```\r\n\u03bb npx envinfo --preset jest\r\nnpx: installed 1 in 1.668s\r\n\r\n  System:\r\n    OS: Windows 10 10.0.18362\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-8300H CPU @ 2.30GHz\r\n  Binaries:\r\n    Node: 10.16.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.17.3 - ~\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.9.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: 25.1.0 => 25.1.0\r\n```\r\n","comments":["This often leads to `Jest did not exit one second after the test run has completed.` behavior and various errors. F.e., I close my logger in afterAll function and if longFunction tries to log something in this moment, network error will occur. ","@4ekki You missed the `jest.setTimeout(3000);` in the pasted example, which kind of makes it harder to understand your example since the default is 5000. Would be good if you update. I noticed that by looking at the image. Also, are you using `jest-circus`?","@thernstig, thank you for pointing this out. For some reason, github hides everything in the same line, where triple-quote code macro starts. Added new line and it was ok=)\r\n\r\nYes, I use jest-circus.  ","@4ekki No worries. Also, if you add this to the start triple single-quote it looks even nicer. Like this.\r\n\r\n```javascript\r\n```javascript\r\n```\r\n\r\nThat is why it was hidden for you, since it is actually a feature.\r\n\r\nI also found these, do you recon this is a duplicate?\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/8442\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/8688\r\nhttps:\/\/github.com\/facebook\/jest\/pull\/8654 (someone trying to fix it?)\r\n\r\nAlthough I like your simple repro better even with an image.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale ","I'm running into this issue also"],"labels":["Needs Triage","Bug Report"]},{"title":"Module loaded twice when jest.mock gets called","body":"## \ud83d\udc1b Bug Report\r\n\r\nWell, I'm not 100% sure if this is a bug or is it intended for some reason, but it leads to unexpected behavior.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n```\r\ngit clone https:\/\/github.com\/bmvantunes\/emotion-v11-bug-jest.git\r\ncd emotion-v11-bug-jest\r\nnpm test\r\n```\r\n\r\nAn issue is described in more detail [here](https:\/\/github.com\/emotion-js\/emotion\/issues\/1727#issue-551052803). The problem is that a module gets loaded\/evaluated twice - losing its identity and causing global side effects twice **when** `jest.mock` gets called on one of the intermediate modules.\r\n\r\n## Expected behavior\r\n\r\nA module should\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\ngit clone https:\/\/github.com\/bmvantunes\/emotion-v11-bug-jest.git\r\n\r\n## envinfo\r\n\r\n```\r\n  System:\r\n    OS: macOS Mojave 10.14.5\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-6920HQ CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 12.7.0 - ~\/.nvm\/versions\/node\/v12.7.0\/bin\/node\r\n    Yarn: 1.19.1 - ~\/.nvm\/versions\/node\/v12.7.0\/bin\/yarn\r\n    npm: 6.10.0 - ~\/.nvm\/versions\/node\/v12.7.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^25.1.0 => 25.1.0 \r\n```\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","bump for stale bot","Hooray! I just fell into this when using styled-components today. It's so surprising that no other one had interest in this for years... \ud83e\udd72\r\n\r\n### Workaround\r\n\r\nA workaround that worked is to create an intermediate module that caches the `styled-component` module without depending on jest's module cache. This should work for any module that must not be loaded twice.\r\n\r\n```js\r\n\/\/ jest config\r\nmoduleNameWrapper: {\r\n  \"^styled-components$\": \"<rootDir>\/testing\/styled-components.cjs\",\r\n  \"^real-styled-components$\": require.resolve(\"styled-components\"),\r\n},\r\n```\r\n\r\n```js\r\n\/\/ testing\/styled-components.js\r\nconst cacheKey = Symbol.for(\"styled-components-cache-key\");\r\nglobalThis[cacheKey] ??= require(\"real-styled-components\");\r\nmodule.exports = globalThis[cacheKey];\r\n```","a reproduction without CRA would be nice \ud83d\ude05  there's so much extra stuff in those setups (and using very dated version of Jest)","@SimenB Here's a repro using the latest Jest! I believe this is not necessarily a bug, but more like a bad consequence of how Jest module mocking works. Anyways I hope this is helpful.\r\n\r\nhttps:\/\/github.com\/uhyo\/jest-module-load-twice\r\n\r\nNote: I used `jest-environment-jsdom` and `styled-components` etc. to get a kinda realistic example. If you need a truly minimal repro, I can cract one although it would look very artificial."],"labels":["Needs Triage","Bug Report","Pinned"]},{"title":"projects and collectCoverageFrom do not work together","body":"## \ud83d\udc1b Bug Report\r\n\r\nWe're using using Jest's [`projects`](https:\/\/jestjs.io\/docs\/en\/configuration.html#projects-arraystring--projectconfig) feature to run tests in all packages of a monorepo concurrently. It's blazingly fast, and especially useful in CI \u2764\ufe0f .\r\n\r\nThe problem is that some packages need to exclude a pattern (e.g, `\/index.js`) from test coverage. Other packages need to include the same pattern in their test coverage.\r\n\r\nSpecifying [`collectCoverageFrom`](https:\/\/jestjs.io\/docs\/en\/configuration.html#collectcoveragefrom-array) in each package's config works when running Jest at the specific package. When running at the repo root (using `projects`), the individual `collectCoverageFrom` props are ignored.\r\n\r\nSpecifying `collectCoverageFrom` at the root config does not work: The package path is not included in the tested path\/glob, and so you cannot include `package1\/index.js` while excluding `package2\/index.js`.\r\n\r\n## To Reproduce\r\n\r\n- Have two packages with the same relative source filename, (e.g, `index.js` at the package root).\r\n\r\n- Try to include only one package's file in coverage, while excluding the other package's file.\r\n\r\n## Expected behavior\r\n\r\nTo keep things DRY, I would prefer if `collectCoverageFrom` at the root config would be inherited from the individual project's config.\r\n\r\nAnother option is specifying the project's path in `collectCoverageFrom` at the root:\r\n\r\n```JSON\r\n{\r\n  \"collectCoverageFrom\": [\r\n    \"packages\/package1\/index.js\",\r\n    \"!packages\/package2\/index.js\"\r\n  ]\r\n}\r\n```\r\n\r\n## Link to repo\r\n\r\nhttps:\/\/github.com\/salto-io\/jest_projects_coverage_issue\r\n\r\n## envinfo\r\n\r\n```\r\n System:\r\n    OS: macOS 10.15.3\r\n  Binaries:\r\n    Node: 12.14.1 - ~\/.nvm\/versions\/node\/v12.14.1\/bin\/node\r\n    Yarn: 1.22.0 - ~\/.nvm\/versions\/node\/v12.14.1\/bin\/yarn\r\n    npm: 6.13.4 - ~\/.nvm\/versions\/node\/v12.14.1\/bin\/npm\r\n```\r\n\r\nJest version: `25.1.0`\r\n(Also tried with `24.9`)\r\n","comments":["Added PR #9633 which implements the DRY solution described above.","The problem still exists, any solution?","The solution in my case was to add the `collectCoverageFrom` to the root config (not inside projects)","I'm facing the same problem too.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Ping","We're hacking around this by dynamically including `coverageThreshold` values in our `jest.config.ts`:\r\n\r\n```ts\r\nconst selectIndex = process.argv.indexOf('--selectProjects');\r\nconst endIndex = process.argv.findIndex((arg, i) => arg.startsWith('--') && i > selectIndex);\r\nconst projects = process.argv.slice(selectIndex + 1, endIndex > -1 ? endIndex : undefined);\r\n\r\nconst coverageThresholds: Record<string, CoverageThresholdValue> = {\r\n  'apps\/my-app': {\r\n    lines: 25,\r\n    statements: 25,\r\n    branches: 17,\r\n    functions: 20,\r\n  },\r\n};\r\n\r\nconst isSelectedProject = (path: string) =>\r\n  projects.some((project) => path.split('\/').includes(project));\r\n\r\nexport default {\r\n   ...\r\n   coverageThresholds: {\r\n      global: {\r\n        lines: 80,\r\n        statements: 80,\r\n        branches: 70,\r\n        functions: 80,\r\n      },\r\n      ...Object.entries(coverageThresholds).reduce(\r\n        (out, [path, value]) => ({ ...out, ...(isSelectedProject(path) ? { [path]: value } : {}) }),\r\n        {},\r\n      ),\r\n   }\r\n   ...\r\n}\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"automock is crashing","body":"## \ud83d\udc1b Bug Report\r\n\r\nWhen setting in `jest.config.js` property `automock: true` the tests run is crashing with error\r\n```\r\n>npx jest\r\n FAIL  .\/index.test.js\r\n  \u00d7  (30ms)\r\n\r\n  \u25cf \r\n\r\n    TypeError: Cannot destructure property 'formatters' of 'module.exports' as it is undefined.\r\n\r\n    > 1 | require('dotenv-parse-variables')\r\n        | ^\r\n      2 | \r\n\r\n      at Object.<anonymous> (node_modules\/debug\/src\/node.js:238:8)\r\n      at Object.<anonymous> (index.js:1:1)\r\n      at Object.<anonymous> (index.test.js:4:3)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 total\r\nSnapshots:   0 total\r\nTime:        2.893s, estimated 4s\r\nRan all test suites.\r\n\r\n```\r\n\r\n## To Reproduce\r\n\r\nConsider two files:\r\n`index.js`\r\n```javascript\r\nrequire('dotenv-parse-variables')\r\n```\r\n\r\n`index.test.js`\r\n```\r\njest.unmock('.\/index')\r\n\r\ntest('', () => {\r\n  require('.\/index')\r\n})\r\n```\r\n\r\nSteps to reproduce the behavior:\r\nrun `npx jest`\r\n\r\n## Expected behavior\r\n\r\nJest should not crash\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/Alexsey\/jest-automock-crash\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n>npx envinfo --preset jest\r\nnpx: installed 1 in 2.334s\r\n\r\n  System:\r\n    OS: Windows 10 10.0.18362\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 13.7.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 6.13.6 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^25.1.0 => 25.1.0\r\n```\r\n","comments":["I was able to reproduce this issue and appears the problem is with mocking modules that return a method.\r\n\r\nHere is a simple example:\r\n\r\n```js\r\n\/\/my-module\r\nfunction setup() {\r\n    return {\r\n        stuff: 'it'\r\n    };\r\n}\r\n\r\nmodule.exports = setup;\r\n```\r\n\r\nWith mocking, `require('.\/my-module')()` will return `undefined`.\r\n\r\nThat specific issue is from the `debug` package internally expecting a specific object after calling the method from the export.","I'm also seeing this issue from the `debug` package. Do you know of any fix or workaround?","I'm having the same error when using automock true. \r\nIs this still an unresolved issue?","this is actually a major issue - i've just been spending hours trying to figure out why automocking is failing using jest.mock('my_node_module_name');\r\n\r\nwhen automocking a class accessing `ClassName.mock.instances[0]` returns an empty object.\r\n\r\nI tried debugging by creating a custom mock in __mocks__ with the same name as the node_modules library and im receiving `TypeError: Cannot destructure property 'formatters' of 'module.exports' as it is undefined.` error.\r\n\r\nIt seems that these might be related?\r\n\r\n","i didnt receive this error until I added `automock: true` to jest config json file as files in __mocks__ werent creating an automock - they were failing silently.\r\n\r\nThis hasnt been picked up in months and renders this package pretty defunct for our integration tests. Any news on an update or fix?","looks like this links to #6127 ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant"],"labels":["Needs Triage","Bug Report"]},{"title":"Jest spends half its time importing jest-snapshot even when it isn\u2019t used","body":"## \ud83d\udc1b Bug Report\r\n\r\nI did some profiling on a directory of 500 empty tests and discovered that Jest is spending 50% of its time importing `jest-snapshot` into every test environment. Then I wrote a quick and dirty [patch](https:\/\/github.com\/andersk\/jest\/commit\/remove-snapshot) that rips `jest-snapshot` out of `jest-jasmine2` and `jest-runtime`, and observed that it makes my tests run twice as fast (39.706s \u2192 19.941s)!\r\n\r\nObviously we can\u2019t actually rip `jest-snapshot` out, but if we could import it lazily, we could get a large speedup on projects with many small test files that don\u2019t use snapshot testing.\r\n\r\n## To Reproduce\r\n\r\nIn an empty directory:\r\n```sh\r\nmkdir __tests__\r\nfor i in {000..499}; do echo \"test(\\\"test $i\\\", () => {});\" > __tests__\/test$i.js; done\r\necho '{ \"testEnvironment\": \"node\" }' > jest.config.json\r\njest --runInBand\r\n```\r\n\r\n(Running tests serially with `--runInBand` gave me much more stable benchmark results.)\r\n\r\n## Expected behavior\r\n\r\nJest should be faster! :slightly_smiling_face:\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/andersk\/500-empty-jest-tests\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n  System:\r\n    OS: Linux 5.5 NixOS 20.03 (Markhor) 20.03pre212208.8130f3c1c2b (Markhor)\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-10710U CPU @ 1.10GHz\r\n  Binaries:\r\n    Node: 12.15.0 - ~\/.nix-profile\/bin\/node\r\n    Yarn: 1.22.0 - ~\/.yarn\/bin\/yarn\r\n    npm: 6.13.4 - ~\/.nix-profile\/bin\/npm\r\n  npmPackages:\r\n    jest: ^25.1.0 => 25.1.0 \r\n```\r\n","comments":["Hey @andersk, thanks for digging into this! We do most of our importing lazily, but the modules that are evaluated inside the user's sandbox (like `jest-snapshot`) are explicitly blacklisted from this:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/017264f6730d7e99fe0f054d799574e47a802c08\/scripts\/build.js#L43\r\n\r\nFor some background, you can read through #3786, tl;dr being that users might mess with the globals (like `Array.prototype`) and that should never affect Jest's internals. And we need to evaluate these modules in the user's sandbox so `instanceof` works correctly etc.\r\n\r\n---\r\n\r\nThat said, the speedup you're seeing is _very_ tempting, so I think we should definitely investigate this. I wonder if making the implementations of the matchers and snapshot state lazy would help - e.g. only setting up serializers, state etc if snapshot matchers are actually called. I'll try to find some time digging into this, thank you for a short and sweet reproduction!","Yeah, ignoring the blacklist for `@babel\/plugin-transform-modules-commonjs` similarly halves the running time on this benchmark:\r\n\r\n```udiff\r\n--- a\/scripts\/build.js\r\n+++ b\/scripts\/build.js\r\n@@ -143,7 +143,8 @@ function buildFile(file, silent) {\r\n       options.plugins.push(\r\n         require.resolve('.\/babel-plugin-jest-native-globals')\r\n       );\r\n-    } else {\r\n+    }\r\n+    {\r\n       options.plugins = options.plugins.map(plugin => {\r\n         if (\r\n           Array.isArray(plugin) &&\r\n```\r\n\r\nSo now I\u2019m curious, what exactly does this blacklist accomplish in the way of preventing test code from messing with Jest internals? It means that lots of Jest code gets loaded before the test code has a chance to run\u2014but the loaded code still refers to globals that the test code could interfere with, so how does that help?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Still an issue in current `main` (1bbe6fb7f9545ec690c9f9db1156138366fb1d00). Ignoring the lazy-loading blacklist speeds up the run by 2\u00d7 (21.9 s \u2192 11.8 s).","Would you be able to look into what specifically is slow when loading `jest-snapshot`? I.e. is it loading dependencies or is it some other setup it does? If other setup, we can probably make that lazy","@SimenB I got a chance to take a look at this issue and it seems that the largest source of slowdown is the babel packages inside the `packages\/jest-snapshot\/src\/InlineSnapshots.ts` file. I tried very basic profiling, if I lazy load all the babel packages inside that file then the `jest-snapshot` package takes ~5.4% of the total \r\ntime. Without lazy loading the `jest-snapshot` takes ~28.2% of the total time.\r\n\r\nThe screenshots below are comparing `InlineSnapshots.js` file\r\n\r\nWithout Lazy Loading:\r\n<img width=\"1779\" alt=\"Screenshot 2022-03-11 at 12 19 13 AM\" src=\"https:\/\/user-images.githubusercontent.com\/33136628\/157798568-a731ad2a-71bc-4f0a-b687-2dea7e6095f4.png\">\r\n\r\nWith Lazy Loading:\r\n<img width=\"1779\" alt=\"Screenshot 2022-03-11 at 12 21 26 AM\" src=\"https:\/\/user-images.githubusercontent.com\/33136628\/157798709-3aad70d1-9023-4fd5-88f1-a549efd5cc79.png\">\r\n\r\n","`jest-snapshot` tries to load e.g. `prettier` and `chalk` outside of the sandbox, maybe we should do the same for babel?\r\n\r\nEDIT: No, we already try to: https:\/\/github.com\/facebook\/jest\/blob\/199f9811ae68b15879cbe18b7ef7ebd61eefcf23\/packages\/jest-snapshot\/src\/InlineSnapshots.ts#L20-L37","@SimenB I tried doing it this way (snippet below), since my test case was very singular in just trying to figure out what was causing the slowdown I haven't considered any other side effects from this change. Such as users messing with globals like you mentioned.\r\n\r\n```js\r\nvar _types = () => {\r\n  const data = require('@babel\/types');\r\n\r\n  _types = function () {\r\n    return data;\r\n  };\r\n\r\n  return data;\r\n}\r\n```","This seems to still be pretty slow. But it looks like at this point, the toplevel import is okay as long as it's a `requireOutside` (which can be cached across test cases); the issue is that there's also a [regular import](https:\/\/github.com\/facebook\/jest\/blob\/6e5b1d60a1214e792b5229993b5475445e9c1a6e\/packages\/jest-snapshot\/src\/InlineSnapshots.ts#L10). Removing that gets the original repro (with `--runInBand`) from ~40s to ~25s on my laptop, which is almost as much as ripping out jest-snapshot entirely. If we could do the same for a bunch of other plausibly-stateless packages used by jest itself [1], that can get us down to at least 13s, although I'm not certain how safe that is.\r\n\r\n[1] I'm testing with `'expect', 'semver', 'picomatch', 'micromatch', 'jest-diff', 'source-map-support', 'jest-matcher-utils', '@jest\/expect', 'jest-snapshot'` (`'chalk'` is already required outside the VM).\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still an issue in current `main` (e54c0ebb048e10331345dbe99f8ec07654a43f1c). Something now breaks if you ignore the lazy-loading exclude list completely, but reducing it speeds up the run from 38.564 s to 22.439 s:\r\n\r\n```diff\r\n--- a\/scripts\/buildUtils.mjs\r\n+++ b\/scripts\/buildUtils.mjs\r\n@@ -138,8 +138,7 @@ export function getPackagesWithTsConfig() {\r\n   );\r\n }\r\n \r\n-export const INLINE_REQUIRE_EXCLUDE_LIST =\r\n-  \/packages\\\/expect|(jest-(circus|diff|get-type|jasmine2|matcher-utils|message-util|regex-util|snapshot))|pretty-format\\\/\/;\r\n+export const INLINE_REQUIRE_EXCLUDE_LIST = \/jest-circus\/;\r\n \r\n export const copyrightSnippet = `\r\n \/**\r\n```\r\n"],"labels":[":bug: Bug","Confirmed","Help Wanted"]},{"title":"Allow mocking `require.resolve`","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nThe `require.resolve` function is re-created for every file: this is needed so that it starts resolving from the correct location.\r\n\r\nHowever, this makes it impossible to mock it: `require.resolve = jest.fn()` doesn't work.\r\nI propose adding an API similar to `jest.mock` specifically for `require.resolve`'s behavior.\r\n\r\n## Motivation\r\n\r\nWe have different tests in `@babel\/core` that test plugins\/presets aliasing ([ref](https:\/\/github.com\/babel\/babel\/blob\/master\/packages\/babel-core\/test\/resolution.js)). For example, we test that when someone uses `@babel\/env` in their config Babel tries to resolve `@babel\/preset-env`.\r\n\r\nWe currently rely on \"fake\" `node_modules` folders, however:\r\n1. We don't want to test node's resolution algorithm, we should only test what we are asking node to resolve.\r\n2. Using real FS just to check plugins\/presets aliasing makes our tests slower.\r\n3. This approach doesn't work with Yarn PnP, because it changes the resolution behavior (and it shouldn't affect our tests).\r\n\r\n## Example\r\n\r\nMaybe something like this?\r\n\r\n```js\r\njest.mockResolution(\"@babel\/env\", __dirname + \"\/fake\/@babel\/preset-env\");\r\n\r\n\/\/ test\r\n\r\njest.unmockResolution(\"@babel\/env\");\r\n```\r\n\r\n## Pitch\r\n\r\nMocks are already handled by the Jest core platform :grin: \r\n","comments":["Oooh, I like it! It would essentially be `jest.mock` but only instead of providing the inline implementation, you provide the path it should resolve to? Would allow people to easily reuse mock modules without putting a file in `__mocks__\/` directories as well.\r\n\r\nNot a huge fan of needing to replicate all of `.mock`, `doMock`, `unmock` and `dontMock` though... Would overloading be confusing to people? So if a function is provided it's a inline mock, if it's a string, it's the resolution that's mocked? I generally hate overloaded APIs, but in this case I think it might make sense?","Somehow I didn't realize that my proposal could be directly related to `jest.mock` :joy: I think that your proposed overload makes sense, and might even be more intuitive than having to use a parallel API.\r\n\r\nDo you think that `require.resolve` should check if the mocked path exists? I'd say no, but then we would need something to mock a file as non-existing.","We have `jest.mock('thing', factory, {virtual: true})` if you don't want the thing you're mocking to exist. I think that should work with `require.resolve` as well, no?\r\n\r\n\/cc @jeysal @thymikee @cpojer thoughts on this one?","Oh, I didn't know about `virtual`.\r\n\r\nIf no one from the team has concerns with this feature request, I could start working on an implementation next week.","I think virtual mocks should cover your use case. Let's try that first before adding more APIs to Jest. I do not think that mocking `require.resolve` is desirable, there are too many ways to shoot yourself in the foot :D","Since Babel internally directly calls `require.resolve`, I don't see how virtual mocks could cover my use case :thinking: ","You should be able to create virtual mocks to ensure that `require.resolve` doesn't throw. If it throws, you know Babel did something unexpected.\r\n\r\nYou can also require the module after calling `require.resolve` and then verify that the mock module function was called etc.","It doesn't seem to work:\r\n\r\n```js\r\ndescribe.only(\"virtual mocks\", function() {\r\n  it(\"finds preset\", () => {\r\n    try {\r\n      const preset = () => ({});\r\n\r\n      \/\/ also tested with \"..\/..\/..\/node_modules\/babel-preset-test-1234\"\r\n      jest.doMock(\"babel-preset-test-1234\", () => preset, { virtual: true });\r\n\r\n      expect(() =>\r\n        babel.transformSync(\"code;\", {\r\n          presets: [\"babel-preset-test-1234\"],\r\n          configFile: false,\r\n        }),\r\n      ).not.toThrow();\r\n    } finally {\r\n      jest.dontMock(\"babel-preset-test-1234\");\r\n    }\r\n  });\r\n});\r\n```\r\n\r\nreports\r\n\r\n```\r\n  \u25cf virtual mocks \u203a finds preset\r\n\r\n    expect(received).not.toThrow()\r\n\r\n    Error name:    \"Error\"\r\n    Error message: \"Cannot resolve module 'babel-preset-test-1234' from paths ['\/home\/nicolo\/Documenti\/dev\/babel\/babel'] from \/home\/nicolo\/Documenti\/dev\/babel\/babel\/packages\/babel-core\/lib\/config\/files\/plugins.js\"\r\n\r\n          89 | \r\n          90 |   try {\r\n        > 91 |     return require.resolve(standardizedName, {\r\n             |                    ^\r\n          92 |       paths: [dirname]\r\n          93 |     });\r\n          94 |   } catch (e) {\r\n\r\n          at Runtime._requireResolve (node_modules\/jest-runtime\/build\/index.js:892:13)\r\n          at resolveStandardizedName (packages\/babel-core\/lib\/config\/files\/plugins.js:91:20)\r\n          at resolvePreset (packages\/babel-core\/lib\/config\/files\/plugins.js:48:10)\r\n          at loadPreset (packages\/babel-core\/lib\/config\/files\/plugins.js:67:20)\r\n          at createDescriptor (packages\/babel-core\/lib\/config\/config-descriptors.js:154:9)\r\n          at packages\/babel-core\/lib\/config\/config-descriptors.js:109:50\r\n              at Array.map (<anonymous>)\r\n          at createDescriptors (packages\/babel-core\/lib\/config\/config-descriptors.js:109:29)\r\n          at createPresetDescriptors (packages\/babel-core\/lib\/config\/config-descriptors.js:101:10)\r\n\r\n      14 |           configFile: false,\r\n      15 |         }),\r\n    > 16 |       ).not.toThrow();\r\n         |             ^\r\n      17 |     } finally {\r\n      18 |       jest.dontMock(\"babel-preset-test-1234\");\r\n      19 |     }\r\n\r\n      at Object.<anonymous> (packages\/babel-core\/test\/resolution.js:16:13)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 40 skipped, 41 total\r\nSnapshots:   0 total\r\nTime:        0.634s\r\n\r\n```\r\n\r\nIt doesn't work because the jest replacement for `require` [checks for mocks](https:\/\/github.com\/facebook\/jest\/blob\/017264f6730d7e99fe0f054d799574e47a802c08\/packages\/jest-runtime\/src\/index.ts#L513), but the replacement for `require.resolve` [doesn't](https:\/\/github.com\/facebook\/jest\/blob\/017264f6730d7e99fe0f054d799574e47a802c08\/packages\/jest-runtime\/src\/index.ts#L690).\r\n\r\nAlso, I don't know what `require.resolve` would be currently expected to return with mocks, because it must return a string which we aren't providing to `jest.mock`.","Thanks for trying it out and checking. That's a good observation that I missed. Now the question is: should `require.resolve` consider mocks and give a fake temporary file-path or should we allow mocking `require.resolve`?","If `require.resolve(\"foo\")` returned something like `\"\/tmp\/jest-virtual-mocks\/node_modules\/foo\"` _if an only if_ `foo` is a mocked module, then it would probably cover our use case. However, Jest should make calls to `require(\"\/tmp\/jest-virtual-mocks\/node_modules\/foo\")` return the mocked implementation otherwise `require(require.resolve(\"foo\"))` won't work.\r\n\r\nI still think that explicitly specifying to Jest what to return when `require.resolve`ing a mocked module would be better. Maybe something like this?\r\n```js\r\njest.mock(\"foo\", () => {}, { virtual: true, resolve: \"\/tmp\/node_modules\/foo\" });\r\n```\r\n\r\nAlso, I realized that my original proposal doesn't cover a use case we would need in half of our resolution-related tests: checking that the correct error message is thrown when `require.resolve`ing a module that doesn't exist ([ref](https:\/\/github.com\/babel\/babel\/blob\/865d5155c2ec91f1122e94b88e04ee902dfd6677\/packages\/babel-core\/test\/resolution.js#L346)). This currently already works, but it checks every folder up to the root of the real FS because it uses the \"real\" algorithm.\r\n\r\nIt probably would need a separate option, which makes a mock throw whenever `require` or `require.resolve` are called:\r\n```js\r\njest.mock(\"foo\", () => {}, { virtual: true, missing: true });\r\n```","I'm a bit hesitant of adding new APIs to Jest because you are running into a very limited use case that not many people are encountering. I think I would prefer simply making it so you can overwrite require.resolve, then you can do whatever you like with it.","What I like about expanding jests API is that you can have reusable mocks (possibly distributed through npm) without `__mocks__` directory. Also, it's weird that `jest.mock` affects `require` but not `require.resolve`.","> I'm a bit hesitant of adding new APIs to Jest because you are running into a very limited use case that not many people are encountering.\r\n\r\nI agree with this sentiment. However, I don't think that mine is a limited use case:\r\n- https:\/\/stackoverflow.com\/questions\/47907454\/mocking-and-testing-require-resolve-calls-in-jest\r\n- https:\/\/stackoverflow.com\/questions\/60107539\/jest-mock-require-resolve-calls\r\n- https:\/\/blog.zfanw.com\/how-to-mock-require-resolve-under-jest\/ (not in english)\r\n- Currently GitHub search gives more results for [`require.resolve`](https:\/\/github.com\/search?l=JavaScript&q=%22require.resolve%22+-path%3Anode_modules+-path%3Alib&type=Code) than for [`jest.mock`](https:\/\/github.com\/search?l=JavaScript&q=%22jest.mock%22&type=Code)\r\n\r\nHowever, I didn't find anyone else asking how to mark a mocked module as not existing. Let's keep the discussion focused only on the original proposal.\r\nAlso, it could probably be worked around with @SimenB's original proposal (https:\/\/github.com\/facebook\/jest\/issues\/9543#issuecomment-583879010).\r\n\r\n> What I like about expanding jests API is that you can have reusable mocks (possibly distributed through npm) without `__mocks__` directory.\r\n\r\nThis is something I personally don't need, but I definitely see how it would be useful for the rest of the community!\r\n\r\n> Also, it's weird that `jest.mock` affects `require` but not `require.resolve`.\r\n\r\n:100: The `require` and `require.resolve` node APIs are designed to be symmetrical (I _think_ that `require` itself uses `require.resolve` internally). Currently, this simmetry is broken when using `jest.mock`.","I'm down with adding a `resolve` option next to `virtual`. I think almost all of the code changes needed in `jest-runtime` will be the exact same regardless of where the signal comes from (a separate option, `string` as `factory` or an entirely new API, or something else we haven't thought of), and the bulk of the work will remain the same no matter what API we land on.\r\n\r\nOne challenge with overloading is that `babel-plugin-jest` does some checking on the type provided. You're probably the most qualified person around to make the changes to the Babel plugin, though \ud83d\ude1b \r\nhttps:\/\/github.com\/facebook\/jest\/blob\/47b8aaec0a6bb80b96f7641d68c76587d86abe23\/packages\/babel-plugin-jest-hoist\/src\/index.ts#L97-L102\r\nShould probably be noted though that we might need to validate `resolve` in a similar way, since hoisting will make it so that e.g. `jest.mock('.\/thing', () => {}, {resolve: findSomeUrl()})` can behave differently. Right now we force you to have everything in scope of the mock factory, be a global or be named `mock*Something*`. _Something_ like it probably makes sense for whatever we end up adding to allow mocking `require.resolve` as well","Sure, I will prepare a draft PR in the next days!\r\nI think that I will try to implement both the `resolve` option and the `jest.fn(name, path)` overload, because I'm not sure yet about which approach could be more valuable, or would add more complexity to the code.\r\nWe can then decide which is better by looking at the real implementations\/tests :wink:","Hey, sorry all for the super long time without any response.\r\n\r\nI tried implementing it (I wanted to implement both the proposals, to check which one was better), but didn't manage to figure out how the `require`\/`resolve` code works.\r\n\r\nIf anyone wants to implement it it would be highly appreciated, but I can still work on updating the Babel plugin if needed. ","Hey guys !\r\nI know that's not exactly what you're looking for, but here's my workaround to be able to \"mock\" `require.resolve`.\r\nThere's an interesting feature in jest allowing you to define your own module resolver:\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#resolver-string\r\n\r\nHaving that in mind, here is, basically, what I've done:\r\n\r\n- I created my own resolver like so:\r\n```js\r\nconst glob = require('glob');\r\n\r\nlet mapping = {};\r\n\r\n\/\/ Looks for \"module-resolution.json\" files in all the `__tests__` directories\r\nglob\r\n  .sync(`${__dirname}\/..\/..\/packages\/**\/src\/**\/__tests__\/modules-resolution.json`)\r\n  .forEach((file) => {\r\n    \/\/ For each of them, merges them in the \"mapping\" object\r\n    mapping = { ...mapping, ...require(file) };\r\n  });\r\n\r\nfunction resolver(path, options) {\r\n  \/\/ If the path corresponds to a key in the mapping object, returns the fakely resolved path\r\n  \/\/ otherwise it calls the Jest's default resolver\r\n  return mapping[path] || options.defaultResolver(path, options);\r\n}\r\n\r\nmodule.exports = resolver;\r\n```\r\n- Then, I configured it in my jest config file:\r\n```js\r\nmodule.exports = {\r\n  roots: ['<rootDir>'],\r\n  testMatch: ['<rootDir>\/packages\/**\/__tests__\/**\/*.test.js'],\r\n  collectCoverageFrom: ['packages\/**\/src\/**\/*.js', '!packages\/**\/src\/__tests__\/**'],\r\n  resolver: '<rootDir>\/test-utils\/resolver',\r\n};\r\n```\r\n- Finally, I can create `modules-resolution.json` files in my test folders that look like this:\r\n```json\r\n{\r\n  \"fake-module\": \"\/path\/to\/fake-module\"\r\n}\r\n```\r\n\r\nThis do the job for me so far and I think that, starting from this example, we could do something more complex but more developer friendly !\r\nOf course, that would be even better if this feature could be directly included in jest !\r\nAnyway, I hope this will help some of you \ud83d\ude09 ","> I'm a bit hesitant of adding new APIs to Jest because you are running into a very limited use case that not many people are encountering. I think I would prefer simply making it so you can overwrite require.resolve, then you can do whatever you like with it.\r\n\r\n@cpojer I think any project that has optional peer dependencies and alters its behaviours based on the existence of those dependencies likely cannot implement full test coverage because `require.resolve` is not mockable. Such codebases almost certainly have their optional peer dependencies installed as development dependencies, so any `require.resolve()` call wrapped in a `try ... catch` will have an untested codepath in the `catch` block, unless they resort to something hacky like temporarily removing the module from the filesystem, which likely requires consecutive runs of `jest` and therefore coverage-merging.","Would love to have this functionality too!\r\n\r\nMy usecase specifically is checking if a directory exists for example `require.resolve(\"@packageName\/some-dir\/\")`","The feature has been accepted, so no need to try to convince us \ud83d\ude42 PR very much welcome!","Hey @SimenB \r\n\r\nI read\r\n\r\n> We have jest.mock('thing', factory, {virtual: true}) if you don't want the thing you're mocking to exist. I think that should work with require.resolve as well, no?\r\n\r\nAm I to understand that `jest.mock('some-node_module-dep', () => {}, { virtual: true })` should make `'some-node_module-dep'` fail to resolve in my source code? I'm trying to add tests to assert that we warn users when we're trying to resolve a peerDep they don't have, and that doesn't seem to be working :(","Correct, that's part of what this issue is about. `jest.mock` does not affect `require.resolve`","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","This limitation still exists in Jest where it's not possible to mock `require.resolve` or `require.resolve.paths`. I vote to keep this issue open.","I'm trying to use `moduleNameMapper` for `require.resolve`, and not quite sure to understand why it does not work.","I found relative problem with @fastify\/swagger-ui. This library is using \"require.resolve('.\/static\/logo.svg')\" and as result test broken with moduleNameMapper configuration"],"labels":["Help Wanted",":rocket: Feature Request","Pinned"]},{"title":"beforeAll() executed in parallel with test case in case of timeout","body":"## \ud83d\udc1b Bug Report\r\n\r\nTest case is executed even if beforeAll did not finish.\r\n\r\n## To Reproduce\r\n\r\nThis test file:\r\n```js\r\nbeforeAll(async () => new Promise((resolve, reject) => {\r\n  \/\/ Never resolves\r\n}));\r\n\r\ntest('test case', async () => {\r\n  console.log('should never be executed');\r\n});\r\n```\r\nDisplays this:\r\n```\r\n% npx jest t.spec.js\r\n FAIL  .\/t.spec.js (5.415s)\r\n  \u2715 test case (8ms)\r\n\r\n  \u25cf test case\r\n\r\n    Timeout - Async callback was not invoked within the 5000ms timeout specified by jes\r\nt.setTimeout.Error: Timeout - Async callback was not invoked within the 5000ms timeout \r\nspecified by jest.setTimeout.\r\n\r\n      at mapper (node_modules\/jest-jasmine2\/build\/queueRunner.js:25:45)\r\n\r\n  console.log t.spec.js:6\r\n    should never be executed\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 total\r\nSnapshots:   0 total\r\nTime:        5.436s, estimated 6s\r\nRan all test suites matching \/t.spec.js\/i.\r\n```\r\n## Expected behavior\r\n\r\nTest case code should never be executed because beforeAll() did not finish. The error message should be at the beforeAll level and not at the test case level. This is very confusing as you may  think that the test case itself failed when in reality it has nothing to do with the test case.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/repls\/KindlyAutomaticLocation\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```\r\n% npx envinfo --preset jest\r\nnpx: installed 1 in 0.645s\r\n\r\n  System:\r\n    OS: Linux 5.3 Manjaro Linux\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 13.7.0 - \/usr\/bin\/node\r\n    Yarn: 1.21.1 - \/usr\/bin\/yarn\r\n    npm: 6.13.6 - \/usr\/bin\/npm\r\n  npmPackages:\r\n    jest: ^24.9.0 => 24.9.0 \r\n```\r\n","comments":["Still occuring with jest 25.1.0.\r\nI'm starting a http server and waiting the `server.listen()` callback to be called to resolve the promise and ensure the server is able to receive requests. However, the testcase is running before the server is up and running because the runner isn't waiting `beforeAll` finish their job, just like @aalexgabi reported.","Seems I've found a workaround here. Since I wrapped my test case and hooks with a `describe` function, seems that jest is now respecting the async `beforeAll`.","@dfleury I do not observe the same behaviour:\r\n```shell\r\n% cat test\/t.spec.js \r\ndescribe('main', () => {\r\n  beforeAll(async () => new Promise((resolve, reject) => {\r\n    \/\/ Never resolves\r\n  }));\r\n\r\n  test('test case', async () => {\r\n    console.log('should never be executed');\r\n  });\r\n});\r\n\r\n% npx jest test\/t.spec.js \r\n FAIL  test\/t.spec.js (5.296s)\r\n  main\r\n    \u2715 test case (5ms)\r\n\r\n  \u25cf main \u203a test case\r\n\r\n    Timeout - Async callback was not invoked within the 5000ms timeout specified by jest.setTimeout.Error: Timeout - Async callback was not invoked within the 5000ms timeout specified by jest.setTimeout.\r\n\r\n      at mapper (node_modules\/jest-jasmine2\/build\/queueRunner.js:25:45)\r\n\r\n  console.log test\/t.spec.js:7\r\n    should never be executed\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 total\r\nSnapshots:   0 total\r\nTime:        5.646s, estimated 6s\r\nRan all test suites matching \/test\\\/t.spec.js\/i.\r\n\r\n% npx envinfo --preset jest\r\nnpx: installed 1 in 0.727s\r\n\r\n  System:\r\n    OS: Linux 5.3 Manjaro Linux\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 13.7.0 - \/usr\/bin\/node\r\n    Yarn: 1.22.0 - \/usr\/bin\/yarn\r\n    npm: 6.13.6 - \/usr\/bin\/npm\r\n  npmPackages:\r\n    jest: ^25.1.0 => 25.1.0 \r\n\r\n\r\n```","I guess the problem in your example is you're never resolving the promise and the global timeout is firing because of that.\r\nWhat I've catched here is similar but different since my test case was running in parallel with `beforeAll` even I'm respecting the 5s limit and, a variable that might be defined by `beforeAll` was being used before it was ready. That way, my test case failed saying that variable X wasn't defined.\r\nIn a tweet, I think the issue here is jest isn't respecting the execution order of a global `beforeAll` (out of any scope).","We have been bitten by this unexpected behaviour as well, here is a simple repro case where the log output will show the improper sequencing\r\n\r\n```\r\n\/\/Keeping default jest timeout of 5s\r\n\r\nbeforeAll(async () => {\r\n  console.log(\"In beforeAll, starting sleep\");\r\n  await sleep(12);\r\n  console.log(\"beforeAll finally finished sleeping\");\r\n});\r\n\r\ndescribe(\"outerDescribe\", () => {\r\n  beforeEach(async () => {\r\n    console.log(\"In beforeEach, starting sleep\");\r\n    await sleep(6);\r\n    console.log(\"beforeEach finally finished sleeping\");\r\n  });\r\n  describe(\"innerDescribe\", () => {\r\n    it(\"Does absolutely nothing useful\", () => {\r\n      console.log(\"Executing testcase 1\");\r\n    });\r\n    it(\"Also does nothing useful\", () => {\r\n      console.log(\"Executing testcase 2\");\r\n    });\r\n  });\r\n});\r\n\r\nfunction sleep(seconds) {\r\n  return new Promise(resolve => setTimeout(resolve, seconds * 1000));\r\n}\r\n\r\n```\r\nOutput:\r\n    In beforeAll, starting sleep\r\n    In beforeEach, starting sleep\r\n    Executing testcase 1\r\nError: Timeout - Async callback was not invoked within the 5000ms timeout specified by jest.setTimeout.\r\n console.log app\/__tests__\/test.js:9\r\n    In beforeEach, starting sleep\r\n    beforeEach finally finished sleeping\r\n    beforeAll finally finished sleeping\r\n    Executing testcase 2\r\nError: Timeout - Async callback was not invoked within the 5000ms timeout specified by ","Same with using `beforeEach()`.","I have the same issue. Planned on using a `deleteAllEntries()` function to clean my collection in db before tests and placed the function in `beforeAll()`, but apparently other test functions are already adding entries to the db, while  `deleteAllEntries()` has not yet finished.\r\n\r\nThe parallel execution of `beforeAll()` and `afterAll()` with the tests somehow defies their inherent purpose?\r\n\r\nAnyone found a good solution to this?","I'm facing this issue.\r\nAgree with @albert-schilling. There is no point in testing being run before preparation (`beforeAll` and `beforeEach`) is complete.","Am I understanding this correctly that jest is basically telling that you shouldn't share context between tests at all? For example, with puppeteer\/playwright it's commonly documented to do \r\n\r\n```js\r\ndescribe.each([\"chromium\", \"firefox\"])(\"%s\", (browserType) => {\r\n\tlet browser;\r\n\tlet page;\r\n\r\n\tbeforeAll(async () => {\r\n\t\tbrowser = await playwright[browserType].launch();\r\n\t});\r\n\r\n\tafterAll(async () => {\r\n\t\tawait browser.close();\r\n\t});\r\n\r\n\tbeforeEach(async () => {\r\n\t\tpage = await browser.newPage();\r\n\t});\r\n\r\n\tafterEach(async () => {\r\n\t\tawait page.close();\r\n\t});\r\n\r\n  it('first test', async () => {\r\n    \/\/  do something with `page`\r\n  });\r\n\r\n  it('second test', () => {\r\n    \/\/ do something with a new `page` that doesn't interfere with the first test\r\n  });\r\n});\r\n```\r\n\r\nWith `jest` that doesn't seem possible since an `afterEach` which closes the page could run during one of the test because `jest` doesn't wait for before*\/after* to finish?\r\n\r\nIt's not a blocker since I can create a new browser and page per test but then what is the point of `before*` and `after` hooks?","Our company lost 4 man-days of development because of this bug. Please fix this so others don't suffer the same fate. Return proper error for this and don't run test if `beforeAll` etc timeouts. So they know that they need to put bigger timeout as second argument for `beforeAll` and `afterAll` etc.","Anyone found any workaround for this?\r\nAt least until it will be fixed? \r\n\r\nI'm facing the same issue in beforEach() when running playwright tests","@hananmalka Use bigger timeout. beforeEach should also support timeout in milliseconds as second argument. So example `beforeEach(function {...}, 60000);` for 1 minute timeout.","@wanton7 I tried this one but it didn't work.\r\nLooks like it ignores the timeout I set... ","@hananmalka very odd because it works for `beforeAll` at least worked for our company and docs https:\/\/jestjs.io\/docs\/en\/api#beforeeachfn-timeout say it supports timeout. Another bug?","@wanton7 \r\nNot sure. \r\nThis is my code:\r\n\r\n```\r\nbeforeEach(async () => {\r\n    await page.goto(\"https:\/\/www.google.com\");\r\n    await page.reload();\r\n  }, 60000);\r\n\r\n  it(\"test\", async () => {\r\n    await page.goto(\"some_other_site\");\r\n  });\r\n```\r\n\r\nAnd this is the error I get:\r\n  ```\r\nCannot log after tests are done. Did you forget to wait for something async in your test?\r\n    Attempted to log \"[2021-01-18 20:15:12.076] [INFO] console - page.goto: Navigation failed because page was closed!\r\n```\r\n\r\nAccording to this error it looks like it tries to do the actions inside the \"it\" before the \"beforeEach\" ends...\r\nI have no idea what is this about. \r\n\r\nI'm using playwright and testRunner: \"jasmine2\"\r\nWhen I removing this testRunner from jest.config.js - all works as expected. \r\nSeems like it's an issue with the testRunner - but unfortunately I don't know what.\r\n\r\n","@hananmalka from looks if it, I don't think you even have this issue. I think Promise from `await page.goto(\"https:\/\/www.google.com\");` is rejected. Looks to me **www.google.com** closes connection before your `page.goto` call completes.","For anyone else having trouble with this, the problematic behavior comes from the default Jasmine2 test runner.  Specifying [jest-circus](https:\/\/www.npmjs.com\/package\/jest-circus) as your test runner will stop tests from running when a `before` hook fails, and yields a more intelligible error.  To run your tests with `jest-circus`, from the root of your project run `yarn add jest-circus`, and pass in the appropriate CLI option whenever you invoke jest:\r\n```javascript\r\nyarn jest --testRunner=jest-circus\/runner [...other options]\r\n```\r\nAlternatively, add the following to your jest config file:\r\n```javascript\r\n{\r\n\/\/...your other config options\r\n\"testRunner\": \"jest-circus\/runner\"\r\n}","@Rossh87 Hmm I was using `jest-circus` when I had this trouble, I am pretty certain. Maybe they fixed it. Can you confirm it works when a `beforeEach()` fails too?","@thernstig Beforeeach and beforeAll work how I would expect, at least in my testing environment.  [Here's the repo](https:\/\/github.com\/Rossh87\/jest_9527) I was using--maybe see if it gives you the same results?  \r\n\r\nI dug through the commit history a bit looking for this specific change to jest-circus without finding anything conclusive, but I didn't spend a ton of effort on it.","@Rossh87 is right. This can\/should be closed now. Using `jest-circus` it works fine, and that is what you should use anyway. For reference there is still problems with *reporting* if a `beforeAll()` fails, but that is a separate issue https:\/\/github.com\/facebook\/jest\/issues\/6695 (especially this https:\/\/github.com\/facebook\/jest\/issues\/6695#issuecomment-489536977).\r\n\r\nThis is what I did to confirm that the scenario describe in this issue does bail if `beforeAll()` or `beforeEach()` fails in case of timeout:\r\n\r\n**Code**\r\n\r\n```js\r\nbeforeAll( \/\/ or beforeEach\r\n  async () =>\r\n    new Promise((resolve, reject) => {\r\n      \/\/ Never resolves\r\n    })\r\n);\r\n\r\ntest('case', async () => {\r\n  console.log('should never be executed');\r\n});\r\n```\r\n\r\n**Failure with `beforeAll()`**\r\n\r\n```sh\r\nFAIL   UNIT:SERVER  server\/util\/__tests__\/test1.unit.test.js (6.838 s)\r\n  \u2715 case\r\n\r\n  \u25cf case\r\n\r\n    thrown: \"Exceeded timeout of 5000 ms for a hook.\r\n    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.\"\r\n\r\n      15 | \/\/ });\r\n      16 | \r\n    > 17 | beforeAll(\r\n         | ^\r\n      18 |   async () =>\r\n      19 |     new Promise((resolve, reject) => {\r\n      20 |       \/\/ Never resolves\r\n\r\n      at Object.<anonymous> (util\/__tests__\/test1.unit.test.js:17:1)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 total\r\nSnapshots:   0 total\r\nTime:        6.868 s\r\n```\r\n\r\n**Failure with `beforeEach()`**\r\n\r\n```sh\r\n FAIL   UNIT:SERVER  server\/util\/__tests__\/test1.unit.test.js (6.831 s)\r\n  \u2715 case (5002 ms)\r\n\r\n  \u25cf case\r\n\r\n    thrown: \"Exceeded timeout of 5000 ms for a hook.\r\n    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.\"\r\n\r\n      15 | \/\/ });\r\n      16 | \r\n    > 17 | beforeEach(\r\n         | ^\r\n      18 |   async () =>\r\n      19 |     new Promise((resolve, reject) => {\r\n      20 |       \/\/ Never resolves\r\n\r\n      at Object.<anonymous> (util\/__tests__\/test1.unit.test.js:17:1)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 total\r\nSnapshots:   0 total\r\nTime:        6.859 s, estimated 7 s\r\n```","@aalexgabi maybe you can close this?","> jest-circus\r\n\r\nDoesn't work for me","> > jest-circus\r\n> \r\n> Doesn't work for me\r\n\r\nI think showing your code, a minimum repro would be nice since it seems to work for some of us.","> > > jest-circus\r\n> > \r\n> > \r\n> > Doesn't work for me\r\n> \r\n> I think showing your code, a minimum repro would be nice since it seems to work for some of us.\r\n\r\n@thernstig \r\n\r\nI'm using jest-cucumber to run my tests. In definition of feature, I call `setup()` method that will set `beforeAll`, `beforeEach` and `afterEach` callbacks. The `beforeAll` callback will execute `startInTestMode` method, which will get up the server application that will be used in tests. When I run the tests, things that should be defined in `startInTestMode` are not defined yet. When I debug de code, the `beforeAll` is executed after tests begins. \r\n\r\n```typescript\r\nconst feature = loadFeature(__dirname + '\/..\/features\/create_redirect_url.feature')\r\n\r\ndefineFeature(feature, test => {\r\n\r\n    setup()\r\n\r\n    test('Successfully create a url for new user', ({ given, when, then }) => {\r\n\r\n        given('user is logged in', userIsLoggedIn())\r\n\r\n        [...]\r\n```\r\n\r\n```typescript\r\nexport default function setup() {\r\n    beforeAll(async () => {\r\n        await startInTestMode()    })\r\n    beforeEach(async () => {\r\n        await Cart.deleteMany({})\r\n        nock.cleanAll()\r\n    })\r\n    afterAll(async () => {\r\n        await MongoDbMock.stopDbMock()\r\n    })\r\n}\r\n\r\nexport async function startInTestMode() {\r\n    DotenvConfig.configure()\r\n    InversifyConfig.configure()\r\n    ExpressConfig.configure()\r\n    ApplicationConfig.configure()\r\n\r\n    await MongoDbMock.initDbMock()\r\n}\r\n```","Sorry I thought you used plain jest with jest-circus, I have no idea how cucumber works and maybe it is related to that then? Maybe if you try with plain jest and jest-circus, you can instead then redirect your question to the cucumber repo. In addition I assume you are configuring jest-circus like explained here https:\/\/www.npmjs.com\/package\/jest-circus#configure","I write an issue to the **jest-cucumber** repository. If someone is having the same problem with **jest-cucumber** there is the thread: https:\/\/github.com\/bencompton\/jest-cucumber\/issues\/124","i change de mongoose version to:  \"mongoose\": \"5.13.5\", and works!! \ud83e\udd14","@SimenB I believe this can be closed, see https:\/\/github.com\/facebook\/jest\/issues\/9527#issuecomment-777489217","@SimenB this should be able to be closed, see my comment above.","Just FYI, this issue also may have to do with running an older version of Mongo, or that it's running slowly on your local machine.\r\n\r\nIf it's passing in CI, try upgrading and running Mongo with the Docker extension in VSCode to get your tests to pass locally.","Our company doesn't use Mongo. We use PostgreSQL and we where effected by this until we increased default test timeout about 3 months ago.","I'm getting tired of all this shit I'ma just start doin shit anyway kind of\nway\n\nOn Fri, 22 Apr 2022, 2:27 am wanton7, ***@***.***> wrote:\n\n> Our company doesn't use Mongo. We use PostgreSQL and we where effected by\n> this until we increased default test timeout about 6 months ago.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/9527#issuecomment-1106237725>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AXSL3Z5P7VW6SAUHCAOPGYLVGJWGJANCNFSM4KQ5YSXQ>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n","We're seeing a related problem even with jest-circus (but maybe that's intentional, not sure). If beforeAll times out, then afterEach \/ afterAll get invoked. afterAll I could maybe see making some sense but running afterEach is weird.\r\n\r\nJest version 27.4.1 which uses jest-circus by default:\r\n\r\n```\r\nbeforeAll(async () => {\r\n    console.log('beforeAll start')\r\n    await new Promise()\r\n    console.log('beforeAll should not hit')\r\n})\r\n\r\nbeforeEach(async () => {\r\n    console.log('beforeEach start')\r\n    await new Promise()\r\n    console.log('beforeEach should not hit')\r\n})\r\n\r\nafterEach(() => {\r\n    console.error('afterEach')\r\n})\r\n\r\nafterAll(() => {\r\n    console.error('afterAll')\r\n})\r\n\r\ntest('test', () => {\r\n    console.error('test body')\r\n})\r\n```\r\nprints\r\n```\r\n  console.log\r\n    beforeAll start\r\n\r\n      at test.js:2:13\r\n\r\n  console.error\r\n    afterEach\r\n\r\n      12 |\r\n      13 | afterEach(() => {\r\n    > 14 |     console.error('afterEach')\r\n         |             ^\r\n      15 | })\r\n      16 |\r\n      17 | afterAll(() => {\r\n\r\n      at Object.<anonymous> (test.js:14:13)\r\n\r\n  console.error\r\n    afterAll\r\n\r\n      16 |\r\n      17 | afterAll(() => {\r\n    > 18 |     console.error('afterAll')\r\n         |             ^\r\n      19 | })\r\n      20 |\r\n      21 | test('test', () => {\r\n\r\n      at test.js:18:13\r\n\r\n FAIL  .\/test.js (5.517 s)\r\n  \u2715 test (23 ms)\r\n\r\n  \u25cf test\r\n\r\n    thrown: \"Exceeded timeout of 5000 ms for a hook.\r\n    Use jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.\"\r\n\r\n    > 1 | beforeAll(async () => {\r\n        | ^\r\n      2 |     console.log('beforeAll start')\r\n      3 |     await new Promise((resolver) => {})\r\n      4 |     console.log('beforeAll should not hit')\r\n\r\n      at Object.<anonymous> (test.js:1:1)\r\n      at TestScheduler.scheduleTests (node_modules\/@jest\/core\/build\/TestScheduler.js:333:13)\r\n      at runJest (node_modules\/@jest\/core\/build\/runJest.js:404:19)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 total\r\nSnapshots:   0 total\r\nTime:        5.579 s\r\n```\r\n\r\nA similar pattern occurs if `beforeAll` throws an exception (i.e. `afterEach` is still invoked).\r\n\r\nI would posit that `after` methods running in the case of a timeout \/ exception in a `before` is a non-intuitive design choice that should at least have lots of warning signs about it in the docs. Ideally it's the user's responsibility to cleanup any resources if `beforeEach` fails. It's as simple as something like:\r\n\r\n```\r\nbeforeEach((async () => {\r\n}).catch((e) => {\r\n   \/\/ cleanup indeterminate state\r\n   if (resource1 !== undefined) {\r\n      await resource1.shutdown()\r\n   }\r\n   throw e\r\n}))\r\n```\r\n\r\nThat way `afterEach` can be more of a happy path cleanup that doesn't have to account for cleaning up state because the matching `before` had a problem.","beforeEach is fundamentally flawed.  it should have a return value that returns isolated resources that are made available to tests as arguments.  setting describe-scoped variables kills parallelization.   as it stands, it forces serialization, or a million describe blocks, which need to roll their own fixture architecture\r\n"],"labels":["Needs Triage","Bug Report"]},{"title":"Use Yarn PnP","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md in the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\n#10188 landed yarn v2 with `node-modules` linker. I wanna play with PnP - even if we don't land it for whatever reason, any errors raised by it is likely things we should fix on master.\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nGreen CI at some point.\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["Unrelated note,\r\n\r\nAm I the only one who still doesn't understand fully all these yarn and zero-install, and pnp stuff?\r\n\r\nI am so confused, I hope I learn from this PR what I suppose kind of do \ud83d\ude2d ","@SimenB I also noticed when you use jest in your project, you don't fullfil the requirement of yarn2 to have resolve@1.9+: https:\/\/next.yarnpkg.com\/advanced\/migration#make-sure-you-use-resolve19\r\n\r\njest uses jest-resolve which uses browser-resolve which itself uses resolve@1.1.7\r\n\r\nbrowser-resolve itself seems to be unmaintained and should probably be removed\r\n","You should be able to use `resolutions` to work around it.\nAnd yeah, we'll probably ditch the browser resolve","> You should be able to use `resolutions` to work around it.\r\n> And yeah, we'll probably ditch the browser resolve\r\n\r\ncool, i also just saw that you are already planning of doing this: https:\/\/github.com\/facebook\/jest\/issues\/2925#issuecomment-582344445","As a workaround for https:\/\/github.com\/babel\/babel\/pull\/11118, you can use [`packageExtensions`](https:\/\/yarnpkg.com\/configuration\/yarnrc#packageExtensions).","thanks @nicolo-ribaudo, did that and also (tried to) fix all the other errors we get from the tsc build.","Landed a bit of this in #9545, all the things `yarn install` complained about and the ones I noticed when running tests. Still a bunch of failures, will need to look more later again","Reviving this now that we've landed Yarn v2 with node-modules linker on master. I'll try to get PnP working here. As before, any changes not strictly related to PnP stuff should land on master","Can remove the packageExtensions as yarn does it automatically: https:\/\/github.com\/yarnpkg\/berry\/pull\/1847\/files","@merceyz hey, happy new year! \ud83d\ude00 Would you be able to take a look at the error with lint and typescript?\r\n\r\n- https:\/\/github.com\/facebook\/jest\/actions\/runs\/3818199835\/jobs\/6494956216\r\n  - there's a weird require: https:\/\/github.com\/taskworld\/eslint-plugin-local\/blob\/master\/index.js#L1\r\n  - trying to load https:\/\/github.com\/facebook\/jest\/tree\/main\/.eslintplugin\r\n- https:\/\/github.com\/facebook\/jest\/actions\/runs\/3818199835\/jobs\/6494956501\r\n  - `WebAssembly` is not defined, but AFAICT it should be part of TS proper?\r\n- Also seeing an error loading the test env, but I haven't dug into that one yet","Hey, happy (late) new year! \ud83d\ude04 \r\n\r\n> there's a weird require\r\n\r\nIt's something alright, fixed in https:\/\/github.com\/facebook\/jest\/pull\/13836.\r\n\r\n> WebAssembly is not defined, but AFAICT it should be part of TS proper?\r\n\r\nIt's in the DOM types so you need to either add `\/\/\/ <reference lib=\"dom\" \/>` to the file or `DOM` to the `tsconfig.json` `compilerOptions.lib` option.\r\nThe reason it works with `node_modules` is most likely because `@types\/jsdom` is hoisted to the root and contains `\/\/\/ <reference lib=\"dom\" \/>`.\r\n\r\n> Also seeing an error loading the test env, but I haven't dug into that one yet\r\n\r\nSome of the examples aren't declaring `jest-environment-jsdom` as a dependency.\r\n\r\n```diff\r\ndiff --git a\/examples\/angular\/package.json b\/examples\/angular\/package.json\r\nindex cb64e7476e..5c9fa12e7b 100644\r\n--- a\/examples\/angular\/package.json\r\n+++ b\/examples\/angular\/package.json\r\n@@ -27,6 +27,7 @@\r\n     \"babel-jest\": \"workspace:^\",\r\n     \"babel-plugin-transform-typescript-metadata\": \"*\",\r\n     \"jest\": \"workspace:^\",\r\n+    \"jest-environment-jsdom\": \"workspace:^\",\r\n     \"jest-zone-patch\": \"*\"\r\n   }\r\n }\r\ndiff --git a\/examples\/jquery\/package.json b\/examples\/jquery\/package.json\r\nindex c7808e236c..7952a710b6 100644\r\n--- a\/examples\/jquery\/package.json\r\n+++ b\/examples\/jquery\/package.json\r\n@@ -6,7 +6,8 @@\r\n     \"@babel\/core\": \"^7.11.6\",\r\n     \"@babel\/preset-env\": \"^7.1.0\",\r\n     \"babel-jest\": \"workspace:^\",\r\n-    \"jest\": \"workspace:^\"\r\n+    \"jest\": \"workspace:^\",\r\n+    \"jest-environment-jsdom\": \"workspace:^\"\r\n   },\r\n   \"dependencies\": {\r\n     \"jquery\": \"^3.2.1\"\r\ndiff --git a\/examples\/react-testing-library\/package.json b\/examples\/react-testing-library\/package.json\r\nindex 9caf65477a..478ed69447 100644\r\n--- a\/examples\/react-testing-library\/package.json\r\n+++ b\/examples\/react-testing-library\/package.json\r\n@@ -12,7 +12,8 @@\r\n     \"@babel\/preset-react\": \"^7.12.1\",\r\n     \"@testing-library\/react\": \"^12.1.5\",\r\n     \"babel-jest\": \"workspace:^\",\r\n-    \"jest\": \"workspace:^\"\r\n+    \"jest\": \"workspace:^\",\r\n+    \"jest-environment-jsdom\": \"workspace:^\"\r\n   },\r\n   \"scripts\": {\r\n     \"test\": \"jest\"\r\ndiff --git a\/examples\/react\/package.json b\/examples\/react\/package.json\r\nindex f100ce09fc..a1c2e80e72 100644\r\n--- a\/examples\/react\/package.json\r\n+++ b\/examples\/react\/package.json\r\n@@ -11,7 +11,8 @@\r\n     \"@babel\/preset-env\": \"^7.1.0\",\r\n     \"@babel\/preset-react\": \"^7.12.1\",\r\n     \"babel-jest\": \"workspace:^\",\r\n-    \"jest\": \"workspace:^\"\r\n+    \"jest\": \"workspace:^\",\r\n+    \"jest-environment-jsdom\": \"workspace:^\"\r\n   },\r\n   \"scripts\": {\r\n     \"test\": \"jest\"\r\ndiff --git a\/examples\/typescript\/package.json b\/examples\/typescript\/package.json\r\nindex 3ca4c4463c..22cf5abfa7 100644\r\n--- a\/examples\/typescript\/package.json\r\n+++ b\/examples\/typescript\/package.json\r\n@@ -14,7 +14,8 @@\r\n     \"@babel\/preset-typescript\": \"^7.0.0\",\r\n     \"@jest\/globals\": \"workspace:^\",\r\n     \"babel-jest\": \"workspace:^\",\r\n-    \"jest\": \"workspace:^\"\r\n+    \"jest\": \"workspace:^\",\r\n+    \"jest-environment-jsdom\": \"workspace:^\"\r\n   },\r\n   \"scripts\": {\r\n     \"test\": \"jest\"\r\n\r\n```","Thanks for taking a look!\r\n\r\n---\r\n\r\nThe `WebAssembly` issue seems to be an old one: https:\/\/github.com\/microsoft\/TypeScript-DOM-lib-generator\/issues\/826","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","This PR was closed because it has been stalled for 30 days with no activity. Please open a new PR if the issue is still relevant, linking to this one."],"labels":["Help Wanted","cla signed","Pinned"]},{"title":"doMock doesn't fake modules required from NodeJS Worker Thread","body":"## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nModule faked with `jest.doMock` would not be faked for code executed in [NodeJS Worker Thread](https:\/\/nodejs.org\/api\/worker_threads.html)\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nMain file `index.js`\r\n```javascript\r\nconst {Worker} = require('worker_threads')\r\n\r\n\/\/ mocked module outside of Worker Thread. Mocked as expected\r\nconst foo = require('.\/foo')\r\n\r\nmodule.exports = async () => {\r\n  return new Promise(resolve => {\r\n    const worker = new Worker('.\/worker.js')\r\n    const outOfWorkerFoo = foo()\r\n    worker.on('message', workerFoo =>\r\n      resolve({outOfWorkerFoo, workerFoo})\r\n    )\r\n  })\r\n}\r\n```\r\n\r\nWorker code `worker.js`\r\n```javascript\r\nconst {parentPort} = require('worker_threads')\r\n\r\n\/\/ mocked module inside of Worker Thread. Failed to be mocked\r\nconst foo = require('.\/foo')\r\n\r\nparentPort.postMessage(foo())\r\n```\r\n\r\nThe faked module. It's faked version would be executed for non-worker code and its real version would be executed for worker code\r\n```javascript\r\nmodule.exports = () => 'real foo'\r\n```\r\n\r\nThe test file `index.test.js`\r\n```javascript\r\nconst foo = jest.fn()\r\n\r\njest.doMock('.\/foo', () => foo)\r\n\r\nconst main = require('.\/index')\r\n\r\ntest('test', async () => {\r\n  foo.mockImplementation(() => 'mock foo')\r\n\r\n  const mockResult = await main()\r\n\r\n  expect(mockResult).toEqual({ \/\/ this check would failed\r\n    outOfWorkerFoo: 'mock foo', \/\/ value would be as expected: 'mock foo'\r\n    workerFoo: 'mock foo'   \/\/ value would NOT be as expected: 'real foo'\r\n  })\r\n})\r\n```\r\n\r\n## Expected behavior\r\n\r\nFaked scripts should be faked no matter whether they had been required inside of Worker Thread or not. And there should definitely never exist faked and real version of the same script at the same time\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/Alexsey\/jest-worker-threads-bug\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```bash\r\nnpx: installed 1 in 13.891s\r\n\r\n  System:\r\n    OS: Windows 10 10.0.18362\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 13.7.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    npm: 6.13.6 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^24.9.0 => 24.9.0\r\n```\r\n\r\nThank you","comments":["Yeah, we don't support `worker_threads` (or `child_process`). Sorta related to #5274, but that issue is just about coverage, which would be solved at the same time.\r\n\r\nI haven't spent much time digging into what we would need to change in order to support it...","@SimenB I have the same problem with `moduleNameMapper` - it does not apply to `worker_threads`. This issue needs to be reclassified, is not a bug report and it doesn't need repro - it is a feature request.\r\nIsn't there some simple way to call jest from the worker thread to make it install its handlers? All that is needed is its `require` interceptor. This would be a very good temporary solution.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Still relevant","I came up with this workaround - i'm able to get away with it because i'm doing more of an integration test where i'm using a test helper and loading it with `worker_threads` to reproduce a race condition, but hey, it might help someone:\r\n\r\nin my test helper thread worker, at the top:\r\n```js\r\nconst mockedModules = new Map(\r\n  ['dependency-1', 'dependency-2'].map((id) => [require.resolve(id), id]),\r\n);\r\nconst originalJsHandler = require.extensions['.js'];\r\nconst hijackedExtensionHandler = (mod, filename) => {\r\n  const mockedModule = mockedModules.get(filename);\r\n  if (mockedModule) {\r\n    const mockId = `..\/__mocks__\/${mockedModule}`;\r\n    filename = require.resolve(mockId);\r\n  }\r\n  return originalJsHandler(mod, filename);\r\n};\r\nrequire.extensions['.js'] = hijackedExtensionHandler;\r\n```"],"labels":["Needs Triage","Bug Report"]},{"title":"jest 25 performance","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udca5 Regression Report\r\nwe upgraded jest from 24 to 25 and saw our unit tests go from taking 5min 23sec in jenkins to now over 11 minutes.  only a few snapshot tests broke in the upgrade, we `-u`'d them, but this is a severe regression imo.  please help me understand how we can fix this.  We clear cache in CI to ensure we always run the latest.  \r\n\r\nA clear and concise description of what the regression is.\r\nrun time went from 5:23, to 11:00 \r\n## Last working version\r\n24.8.0\r\nWorked up to version:\r\n24.8.0\r\nStopped working in version:\r\n25.1.0\r\n## To Reproduce\r\nsorry can't share our codebase \r\nSteps to reproduce the behavior:\r\n\r\n## Expected behavior\r\n\r\nA clear and concise description of what you expected to happen.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\n\r\nIssues without a reproduction link are likely to stall.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\n  System:\r\n    OS: macOS Mojave 10.14.6\r\n    CPU: (12) x64 Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 10.16.0 - ~\/.nvm\/versions\/node\/v10.16.0\/bin\/node\r\n    Yarn: 1.19.0 - ~\/.nvm\/versions\/node\/v10.16.0\/bin\/yarn\r\n    npm: 6.13.6 - ~\/.nvm\/versions\/node\/v10.16.0\/bin\/npm\r\n```\r\n","comments":["Sorry about the regression but\r\n\r\n>sorry can't share our codebase\r\n\r\nmeans we can do absolutely nothing. This is the first I've heard of performance regressing, everywhere else I've heard from 10-40% _improvement_ in performance going from 24 to 25. You need to provide some sort of reproduction, otherwise we'll have to close this issue as it's not actionable at all as it stands.\r\n\r\nIf you want to see this adressed, you'll need to spend some time putting together a reproduction case, or hope somebody else does so.","ok i will see if i can pull our 10 slowest tests maybe, then try to run them in 24 vs 25.  in the meantime, what do you recommend with regards to clearing cache before running tests in CI? do it? don't do it?  ","Your configuration, especially `transforms` and setup files are probably relevant as well\r\n\r\n>what do you recommend with regards to clearing cache before running tests in CI\r\n\r\nI personally think it's a good idea just to be sure there's nothing stale laying around giving false negative or positives. Does it make a huge difference to the runtime of your tests to _not_ clear the cache?","it appears to be quite a bit slower when run after clearing cache. thanks for the tips i'll look into it and see if i can attempt a repro","FWIW, I've also noticed that v25 is either slightly slower or right on par with v24. Have not seen anywhere near 10-40% improvement.","I saw a significant speedup over jest 24 as noted here: https:\/\/github.com\/facebook\/jest\/issues\/7811#issuecomment-577057189\r\n\r\nThe above was tested on osx. \r\n\r\nHowever, the exact same setup runs much, much slower on our CI which runs CentOS. \r\n\r\nLinux specific issue? I\/O related issues when writing cache files? Is it possible to turn off cache generation altogether to rule this out? ","I think I found the culprit in our case, it's the `--collectCoverage ` flag. When it is removed for both Jest 24 and 25, our tests run roughly twice as fast under 25. When it is enabled, our tests under 25 are almost 4 times as slow as the same ones under 24.\r\n\r\nThis is reproducible both on OSX and CentOS, so contrary to my previous comment the issue does not appear Linux-specific.","Interesting! We've updated Istanbul to v3, maybe something in there has regressed. We've added support for v8 code coverage, so I might also have messed up the refactoring when doing so","Yes!  That's consistent with what I'm seeing as well.  We are running with coverage in CI where it's 2x slower.  And when I run locally without covg is quite fast.  @SimenB is there any config option to use the older Istanbul? :)","Echoing what @csvan said it would be nice to turn off cache generation in CI if that is in fact a culprit since we delete it prior to building anyway","I'm unable to reproduce this - the repos I test have about the same performance with `--coverage` between v24 and v25. Would somebody be able to put together a repository with jest 24 and jest 25 where switching between them shows a difference?","just ran our CI build w\/ coverage disabled, I think @csvan is on to something.  The tests run in 4:00 w\/ coverage turned off vs 11 min w\/ coverage turned on.  I will try to see if i can create repro this weekend at some point.\r\n\r\nour exinfo from the build agent:\r\n```bash\r\n00:03:31.992   System:\r\n00:03:31.992     OS: Linux 3.10 CentOS Linux 7 (Core)\r\n00:03:31.992     CPU: (8) x64 Intel Core Processor (Skylake, IBRS)\r\n00:03:31.992   Binaries:\r\n00:03:31.992     Node: 10.16.0 - ~\/workspace\/grocery-electrode\/tools\/nix_64\/nodejs-10.16.0\/bin\/node\r\n00:03:31.992     npm: 6.9.0 - ~\/workspace\/grocery-electrode\/tools\/nix_64\/npm-6.9.0\/node_modules\/.bin\/npm\r\n00:03:31.993   npmPackages:\r\n00:03:31.993     jest: 25.1.0 => 25.1.0 \r\n```\r\n\r\n","We're seeing a similar issue. Upgrading Jest 25 made our tests slower when using coverage (166s with Jest 24 vs. 381s with Jest 25). With Jest 25 displaying many of these errors while running the checks:\r\n\r\n```\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0xb9c575dbe3d \r\n13: 0xb9c57ab091a \r\n14: 0xb9c579e7d65 \r\n15: 0xb9c579ebaf3 \r\n\r\n<--- Last few GCs --->\r\n\r\n[733:0x102804000]    84639 ms: Mark-sweep 1335.2 (1449.6) -> 1325.4 (1452.1) MB, 1443.2 \/ 0.0 ms  (average mu = 0.135, current mu = 0.076) allocation failure scavenge might not succeed\r\n[733:0x102804000]    85872 ms: Mark-sweep 1338.3 (1452.1) -> 1327.8 (1455.1) MB, 1159.4 \/ 0.0 ms  (average mu = 0.101, current mu = 0.059) allocation failure scavenge might not succeed\r\n\r\n\r\n<--- JS stacktrace --->\r\n```\r\n\r\nDowngrading to Jest 24 makes those errors go away. \r\n\r\nI also noticed Jest 25 handles the `collectCoverageFrom` differently as it seems to collect coverage from files we have explicitly disabled in that configuration. Did support for the glob syntax change there?","Any JS traces at all? Would be interesting to see where it died.\r\n\r\n>I also noticed Jest 25 handles the collectCoverageFrom differently as it seems to collect coverage from files we have explicitly disabled in that configuration. Did support for the glob syntax change there?\r\n\r\nWe upgraded to Micromatch 4, it might've changed something. No changes to it on purpose, though. Could you open up a separate issue with a reproduction?","> Any JS traces at all?\r\n\r\nThis was printed:\r\n\r\n```\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x521cca5be3d]\r\nSecurity context: 0x0ebfa799e6e9 <JSObject>\r\n    1: _clearMemoizedQueries [0xebf2a5aba99] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-jsdom\/node_modules\/jsdom\/lib\/jsdom\/living\/nodes\/Node-impl.js:~208] [pc=0x521cd0d9a4e](this=0x0ebf5bee2aa9 <EventTargetImpl map = 0xebf7963d039>)\r\n    2: _clearMemoizedQueries [0xebf2a5aba99] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-...\r\n```\r\n\r\n**EDIT**: Actually, I'm seeing heap errors even with coverage disabled.\r\n\r\n> We upgraded to Micromatch 4, it might've changed something. No changes to it on purpose, though. Could you open up a separate issue with a reproduction?\r\n\r\nWill do.","Chiming in again. Coverage is definitely slower, and seems to be spurious. Here's the timings for OSX.\r\n\r\n```\r\nv24\r\n46.69\r\n41.77\r\n45.06\r\n\r\nv24 coverage\r\n78.60\r\n75.79\r\n80.38\r\n\r\nv25\r\n45.93\r\n52.49\r\n53.36\r\n\r\nv25 circus\r\n61.27\r\n52.08\r\n\r\nv25 coverage\r\n310.98\r\n227.15\r\n153.81\r\n```\r\n\r\nTimings for CI (travis).\r\n\r\n```\r\nv24 coverage -w 4\r\n101.634s\r\n\r\nv25 coverage -w 4\r\n178.306s\r\n```","@milesj what is v25 circus?","It's jests new runner, which is supposed to be faster, but it never is from what I've seen. https:\/\/www.npmjs.com\/package\/jest-circus","@EvHaus Traces from JSDOM is interesting (might also be completely coincidental, of course). Could you try installing `jest-environment-jsdom@24` and using that? We upgraded from 11 to 15, so something in there might have changed. Seems like a longshot, but who knows","@SimenB Rolling back just `jest-environment-jsdom` to `<24.0.0` in my `package.json` definitely made an impact. The `heap out of memory` errors are gone and Jest seems to complete its runs without any issue.","Interesting! If you have time, it'd be lovely if you could test\r\n\r\n- https:\/\/www.npmjs.com\/package\/jest-environment-jsdom-twelve\r\n- https:\/\/www.npmjs.com\/package\/jest-environment-jsdom-thirteen\r\n- https:\/\/www.npmjs.com\/package\/jest-environment-jsdom-fourteen\r\n\r\nOr just link in `jsdom` and bisect. I'll do that tomorrow, but I don't really have a good reproduction yet","For the following tests I don't have coverage enabled.\r\n\r\n- With `jest-environment-jsdom-twelve@0.0.4`\r\n    - 143s to run tests\r\n    - No issues\r\n- With `jest-environment-jsdom-thirteen@1.0.0`\r\n    - 154s to run tests\r\n    - No issues\r\n- With `jest-environment-jsdom-fourteen@1.0.0`\r\n    - 228s to run tests\r\n    - \ud83d\udea8Many `JavaScript heap out of memory` errors\r\n\r\n## Stack traces\r\n\r\nThese are some of the stack traces from the `jest-environment-jsdom-fourteen` run:\r\n\r\n```\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x20deef6dbe3d]\r\nSecurity context: 0x36ee8219e6e9 <JSObject>\r\n    1: _modified [0x36ee35982ec1] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-jsdom-fourteen\/node_modules\/jsdom\/lib\/jsdom\/living\/nodes\/Node-impl.js:~189] [pc=0x20deefba6433](this=0x36eef3246e99 <EventTargetImpl map = 0x36ee99264ee9>)\r\n    2: _insert [0x36eeb41f1e41] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-jsdom-fourte...\r\n```\r\n\r\n```\r\n    0: ExitFrame [pc: 0x2aa5df5be3d]\r\nSecurity context: 0x116a8d49e6e9 <JSObject>\r\n    1: _clearMemoizedQueries [0x116a365133d1] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-jsdom-fourteen\/node_modules\/jsdom\/lib\/jsdom\/living\/nodes\/Node-impl.js:~208] [pc=0x2aa5dfe7dae](this=0x116a8f16cd11 <EventTargetImpl map = 0x116ae7cc9b61>)\r\n    2: _clearMemoizedQueries [0x116a365133d1] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0x20deef6dbe3d \r\n13: 0x20deefba6433 \r\n```\r\n\r\n```\r\n    0: ExitFrame [pc: 0xb8909f5be3d]\r\nSecurity context: 0x09e628d9e6e9 <JSObject>\r\n    1: childrenIterator [0x9e612e1d581] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/symbol-tree\/lib\/SymbolTree.js:~367] [pc=0xb890a41010e](this=0x09e612e3eb01 <SymbolTree map = 0x9e6a7f56c09>,parent=0x09e685ca27d1 <EventTargetImpl map = 0x9e6061f36f1>,options=0x09e67b6026f1 <undefined>)\r\n    2: arguments adaptor frame: 1->2\r\n    3: _detach [0x9e65c4ae341] [\/U...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0x2aa5df5be3d \r\n```\r\n\r\n```\r\n    0: ExitFrame [pc: 0x180d6e95be3d]\r\nSecurity context: 0x02052079e6e9 <JSObject>\r\n    1: _modified [0x205b86c1861] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-jsdom-fourteen\/node_modules\/jsdom\/lib\/jsdom\/living\/nodes\/Node-impl.js:~189] [pc=0x180d6ede24fa](this=0x0205c8284411 <EventTargetImpl map = 0x205c1ea9769>)\r\n    2: _attrModified [0x205b86ba771] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jest-environment-jsdom-fou...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0xb8909f5be3d \r\n```\r\n\r\nHope this helps","I don't know if this will help, but my organization had a massive slow down from Jest 24 to Jest 25 (18 minutes to 28 minutes) that went away after turning off coverage collection (down to 10 minutes).","@rosasynstylae  out of curiosity, does your code have a lot of snapshot tests?","@benmonro It does, yes.","So does ours!  @SimenB  do you think lots of snapshots in a repo could cause this?","We are having the performance issues with no snapshots. We are collecting coverage though. Significant slowdown from 24 -> 25. 2 different projects. It varies but the slowdown is significant and consistent. \r\n\r\nI can run the tests over and over with no changes and the tests are 10 times slower on average then they were with 24. \r\n\r\nI switch back to 24 and the runs are back to the speed we were used to. \r\n\r\nI can provide more info if needed. I wanted to make sure to mention our 2 projects with no snapshot tests. ","From all the comments here, it definitely sounds like coverage is the problem, and probably a regression in istanbul?","> From all the comments here, it definitely sounds like coverage is the problem, and probably a regression in istanbul?\r\n\r\nI wouldn't be so fast to point the finger at istanbul. In my case, even with coverage disabled, I'm seeing significant performance and stability issues in Jest 25. See https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-579423330\r\n\r\nIt's possible there are two separate issues:\r\n\r\n1) Issues with jest-environment-jsdom-fourteen, and\r\n2) Issues with istanbul coverage","I downgraded `micromatch` to `^3.0.0` and saw a massive speedup using `--coverage`, more or less back to the performance we saw under Jest 24. Can anybody reproduce?\r\n\r\nUPDATE: However, now running without `--coverage` is also back to Jest 24 levels of performance - twice as slow :-\/","@EvHaus thanks for checking, very interesting! I'm still unable to reproduce this, unfortunately. So a reproduction would still be awesome, that way I can try to debug this.\r\n\r\n> I downgraded `micromatch` to `^3.0.0` and saw a massive speedup using `--coverage`, more or less back to the performance we saw under Jest 24. Can anybody reproduce?\r\n> \r\n> UPDATE: However, now running without `--coverage` is also back to Jest 24 levels of performance - twice as slow :-\/\r\n\r\nWhat in the world... As far as I can see nothing in istanbul depends on micromatch, so why it should impact coverage is beyond me \ud83d\ude41 ","The whole micromatch performance thing is getting a bit absurd, with coverage v3 is faster than v4, without v4 is faster than v3? \ud83d\ude05 ","@SimenB yep, ran it through our CI as well just to confirm. Changing nothing apart from adding\r\n```\r\n  \"resolutions\": {\r\n    \"micromatch\": \"^3.0.0\"\r\n  }\r\n```\r\nto our package.json shaved a solid 6 minutes off the run when using `--coverage`, bringing it roughly back to what we saw under Jest 24.","> As far as I can see nothing in istanbul depends on micromatch\r\n\r\nFound this comment in another thread which may be related to this: \r\n\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/9464#issuecomment-579733243","Just confirmed nothing in istanbul pulls in `micromatch` (they use `minimatch` in the babel plugin).\r\n\r\nIt might be something about exclusions not working properly, definitely. We use it to check what we should instrument: https:\/\/github.com\/facebook\/jest\/blob\/28f6da44cc58d41438bddfa9fcd741fd01b02ded\/packages\/jest-transform\/src\/shouldInstrument.ts. Could you perhaps stick some logging in there and see if we return `true` anywhere with `micromatch@4` that we don't for `micromatch@3`?\r\n\r\nDefinitely feels like 2 separate issues though, one about jsdom and one about coverage","I can confirm it is back to normal speed for us in CI when we resolve micromatch@3 as well.","Jest + typescript + react codebase here. Seeing this issue and using npm-force-resolutions to force micromatch ^3.0.0 seemed to fix the crazy slowdown.","Do you have custom test file patterns  pr coverage patterns in your config?","@EvHaus I'm super interested in if you see a difference by downgrading Micromatch as well, seeing as you saw a big difference with jsdom versions","If this is what you mean, then yes.\r\n```\r\n  collectCoverage: true,\r\n  collectCoverageFrom: [\r\n    'src\/**\/*.ts',\r\n    'src\/**\/*.tsx',\r\n    'src\/**\/*.js',\r\n    'src\/**\/*.jsx',\r\n    '!src\/themes\/**',\r\n    '!src\/**\/Styled*.tsx',\r\n    '!src\/**\/Styled*.ts',\r\n    '!src\/**\/*Actions.ts',\r\n    '!src\/mainStore.ts',\r\n    '!src\/App.tsx',\r\n    '!src\/AppView.tsx',\r\n    '!src\/AppError.tsx',\r\n    '!src\/StyledAppComponents.tsx',\r\n    '!src\/index.tsx',\r\n    'src\/utility\/redux\/*.ts',\r\n    '!src\/testingUtils\/*',\r\n    '!src\/**\/index.ts',\r\n    '!docs\/**\/**',\r\n  ],\r\n```","we also have that and ours looks quite similar in length\/values ","@Ancient123 yeah, exactly. Seems related to the Micromatch regression for negated patterns. Thanks!","> Seems related to the Micromatch regression for negated patterns. Thanks!\r\n\r\nNoted, I'll look into it ASAP. \r\n\r\n> The whole micromatch performance thing is getting a bit absurd\r\n\r\nSorry about the performance degradation. Generating regular expressions for globbing is a lot harder to do than it looks. Especially when it needs to handle negation and be cross-platform.  I'm looking into this now. ","@jonschlinkert it was not meant accusatory at all, the work you're putting into Micromatch and related libraries are extremely appreciated! :heart: ","yes!  what @SimenB said.  nothing but \u2764\ufe0f ","> @EvHaus I'm super interested in if you see a difference by downgrading Micromatch as well, seeing as you saw a big difference with jsdom versions\r\n\r\nIn my `package.json` i set:\r\n\r\n```\r\n\"resolutions\": {\r\n    \"micromatch\": \"^3.0.0\"\r\n}\r\n```\r\n\r\nRe-ran `npm install`, and then manually deleted `node_modules\/jest\/micromatch` (which was at version 4). Then re-ran my tests.\r\n\r\nUnfortunately, I'm still seeing many \"JavaScript heap out of memory\" errors.\r\n\r\nAm I doing the downgrade correctly?","`resolutions` needs `yarn`, `npm` hasn't implemented it yet (it's on the roadmap for v7: https:\/\/blog.npmjs.org\/post\/186983646370\/npm-cli-roadmap-summer-2019)","@EvHaus until npm v7 comes out you can use resolutions in npm w\/ this package: https:\/\/www.npmjs.com\/package\/npm-force-resolutions","Sorry for the delay. Used `npm-force-resolutions` (which is doing the right thing) to lock `micromatch` to v3. Unfortunately, it didn't make my heap errors go away.\r\n\r\nSo for me, it's still `jest-environment-jsdom-fourteen@1.0.0` to blame, as mentioned here: https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-579423330\r\n\r\nResolving jsdom to `thirteen` is what fixes it.","Does anyone who have experienced a performance degradation in 25 have issues that are not fixed by either using jsdom@13 or micromatch@3? Memory leak in JSDOM is being fixed (https:\/\/github.com\/jsdom\/jsdom\/pull\/2840 and various issues\/PRs linked from it) and the regression in micromatch has been reported and is being worked on: https:\/\/github.com\/micromatch\/micromatch\/issues\/179.","Fixed version of JSDOM has been released, you can use it by installing `jest-environment-jsdom-sixteen`. @EvHaus could you verify it fixes your issue?","@SimenB my issue is probably not related, but I tried `jest-environment-jsdom-sixteen` vs using the default, and saw a 20s increase in runtime for the same test suite over repeated runs.","over using v15 (which is what ships with jest by default) and no other changes? Could you test with 16.1.0 as well (although that leaks memory, so might be harder to test). JSDOM just landed with custom element support, there _might_ be some regression in there? Not sure","> Fixed version of JSDOM has been released, you can use it by installing jest-environment-jsdom-sixteen. @EvHaus could you verify it fixes your issue?\r\n\r\nUnfortunately still getting heap errors with `jest-environment-jsdom-sixteen`. The last stable working version of JSDom for me is  `jest-environment-jsdom-thirteen`.","> Fixed version of JSDOM has been released, you can use it by installing `jest-environment-jsdom-sixteen`. @EvHaus could you verify it fixes your issue?\r\n\r\nThe environment works with our codebase, but we're still seeing an almost 100% regression in runtime. Anecdotally `jest-environment-jsdom-sixteen` seems to improve runs time performance by 10%ish only when using `25.1` vs `24.9`\r\n","Hi @SimenB,\r\n\r\nI've made the reproducible case here https:\/\/github.com\/olebedev\/jest-perf-issue. Please take a look. Below result to compare. \/cc @joscha \r\n\r\n> ### Results\r\n> \r\n> Benchmarks were run on `MBP 2019, 32Gb RAM, i9-8950HK CPU @ 2.90GHz`.\r\n>\r\n> | jest version  | branch |      time |\r\n> |:--------------|:------:|----------:|\r\n> | `24.9.0`      |`master`| `348.077s`|\r\n> | `25.1.0`      |`jest25`|  `591.33s`|","In our case, where jest v25.1 were ~50% slower compared to v24.9, now the latest jest v25.2.0 is even further 20% slower compared to v25.1 \ud83d\ude48","@olebedev Woah, that's painful \ud83d\ude2c \r\n\r\nI'm getting similar numbers to you. If it's based on a real project I recommend using v8 coverage. It takes the runtime from 600s to 35s on my machine in your reproduction. The reason for the huge diff is probably that we don't try to instrument non-covered files with v8 coverage (we just say every byte is uncovered, which works with v8).\r\n\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#coverageprovider-string\r\n\r\nNot sure why it's so slow... I'll try to find some time to look into it (won't be anytime soon though). It should at least not be any slower on v25 than v24","Do I understand the docs correctly that we can use v8 coverage together\nwith the `...-sixteen` environment?\n\nCheers,\nJ\n\nOn Wed, 8 Apr 2020, 22:33 Simen Bekkhus, <notifications@github.com> wrote:\n\n> @olebedev <https:\/\/github.com\/olebedev> Woah, that's painful \ud83d\ude2c\n>\n> I'm getting similar numbers to you. If it's based on a real project I\n> recommend using v8 coverage. It takes the runtime from 600s to 35s on my\n> machine in your reproduction. The reason for the huge diff is probably that\n> we don't try to instrument non-covered files with v8 coverage.\n>\n> https:\/\/jestjs.io\/docs\/en\/configuration#coverageprovider-string\n>\n> Not sure why it's so slow... I'll try to find some time to look into it.\n> It should at least not be any slower on v25 than v24\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-610931770>, or\n> unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AABN5BW6R45SS5Z5GXGFGF3RLRVJLANCNFSM4KK67LOA>\n> .\n>\n","Yes, either `jest-environment-jsdom-sixteen`, or the bundled `jest-environment-node`. Also note that it's only supported on node 10+, not node 8.\r\n\r\n(I've ever only tested this with the Node env, but if it doesn't works with the jsdom env that's a bug - please open up a separate issue \ud83d\ude42)","jest-environment-jsdom-sixteen + v8 as coverage provider was worse by about 20% for us on jest 25.3.0, node 12.16. We're also trying to debug why our test performance got worse by about 80% going from jest 24 to 25. ","@joual did you try the micromatch workaround (downgrade to 3.x)?","Having a similar experience here, test times (_without_ coverage) double on v25 from 35-40 seconds to 80-90 and sometimes more. Tried locking micromatch on v3, no measurable difference. Fwiw, we have around 3k tests of which 58 are snapshot tests.\r\nAttempted to downgrade jsdom but this seems to introduce lots of test breakage due to recent features we've been using. WIll see if I can get around this somehow and report back.","@SimenB The coverage collect job on prettier project is also very slow, can you check it? https:\/\/github.com\/prettier\/prettier\/runs\/579497097 `Node.js 12 on ubuntu-latest` collects coverage, other job don't.","> Having a similar experience here, test times (_without_ coverage) double on v25 from 35-40 seconds to 80-90 and sometimes more. Tried locking micromatch on v3, no measurable difference. Fwiw, we have around 3k tests of which 58 are snapshot tests.\r\n> Attempted to downgrade jsdom but this seems to introduce lots of test breakage due to recent features we've been using. WIll see if I can get around this somehow and report back.\r\n\r\nWas experimenting with different jsdom versions today on jest@24 (which is v11 by default). Up to v14 everything seems to work fine, but as of v15 test runs take consistently 50-60% longer. Same story in v16. Will see if I can get similar perf on jest@25 by downgrading jsdom to v14.","JSDOM@16.2.2 has some memory fixes, @EvHaus could you try it out? Jest's own `--detect-leaks` finds leaks in previous versions, but not 16.2.2.\r\n\r\nI've also landed some other improvements if you have lots of symlinks (which is super slow on windows), so if people could try out jest@25.5.3 that would be lovely \ud83d\ude42 ","@SimenB What's the easiest way to test that? If I add `jsdom@16.2.2` directly as a devDependency Jest ignores that and uses whatever is bundled with `jest-environment-jsdom` which is 15.2.1 today.\r\n\r\nHow can I trick `npm` to ensure it's using the jsdom version I want?","Install jest-environment-jsdom-sixteen and use it https:\/\/jestjs.io\/docs\/en\/configuration#testenvironment-string","Alpha published, so you can try `jest@next` - it comes with jsdom 16 out of the box","@SimenB Sorry, not much luck with `jest@6.0.0-alpha.0` and its `jsdom@16.2.2`. Still getting many of these errors:\r\n\r\n```\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n```\r\n\r\nAnd eventually the runner dies. \r\n\r\nMy details:\r\n\r\n```\r\n> npx envinfo --preset jest\r\n\r\n  System:\r\n    OS: macOS 10.15.4\r\n    CPU: (8) x64 Intel(R) Core(TM) i5-8279U CPU @ 2.40GHz\r\n  Binaries:\r\n    Node: 10.17.0 - ~\/.nvm\/versions\/node\/v10.17.0\/bin\/node\r\n    Yarn: 1.22.4 - \/usr\/local\/bin\/yarn\r\n    npm: 6.14.4 - ~\/.nvm\/versions\/node\/v10.17.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.0.0-alpha.0 => 26.0.0-alpha.0 \r\n```\r\n\r\nHere are some of the full stacks returned from those:\r\n\r\n```\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0x3f82f50dbe3d \r\n13: 0x3f82f5c630de \r\n14: 0x3f82f5c94431 \r\n15: 0x3f82f5c7d3be \r\n16: 0x3f82f5c4e98b \r\n17: 0x3f82f5c3c38e \r\n\r\n<--- Last few GCs --->\r\n\r\n[50818:0x102804000]   189738 ms: Mark-sweep 1288.8 (1450.6) -> 1280.2 (1454.1) MB, 890.1 \/ 0.1 ms  (average mu = 0.181, current mu = 0.061) allocation failure scavenge might not succeed\r\n[50818:0x102804000]   190673 ms: Mark-sweep 1292.8 (1454.1) -> 1282.9 (1457.6) MB, 856.2 \/ 0.2 ms  (average mu = 0.136, current mu = 0.084) allocation failure scavenge might not succeed\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x3f82f50dbe3d]\r\nSecurity context: 0x274d67c9e6e9 <JSObject>\r\n    1: createImpl [0x274d6d9ba1b9] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jsdom\/lib\/jsdom\/living\/generated\/HTMLInputElement.js:~47] [pc=0x3f82f5c630de](this=0x274d51911261 <Object map = 0x274dd51fe489>,globalObject=0x274d89d38609 <Window map = 0x274d2fe6c211>,constructorArgs=0x274d832134b1 <JSArray[0]>,privateData=0x274d832134d1 <Object map = 0x274d69...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0x2cea552dbe3d \r\n13: 0x2cea55937c04 \r\n14: 0x2cea5592618b \r\n\r\n<--- Last few GCs --->\r\n\r\n[51263:0x102804000]    34292 ms: Mark-sweep 1332.4 (1452.5) -> 1320.5 (1453.5) MB, 902.6 \/ 0.0 ms  (average mu = 0.149, current mu = 0.104) allocation failure scavenge might not succeed\r\n[51263:0x102804000]    35480 ms: Mark-sweep 1332.6 (1453.5) -> 1323.6 (1457.5) MB, 1049.3 \/ 0.0 ms  (average mu = 0.131, current mu = 0.116) allocation failure scavenge might not succeed\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x2cea552dbe3d]\r\nSecurity context: 0x1a4cb371e6e9 <JSObject>\r\n    1: next [0x1a4ca627dcd1] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/symbol-tree\/lib\/TreeIterator.js:~16] [pc=0x2cea55937c04](this=0x1a4c807c75b1 <TreeIterator map = 0x1a4c38b8a9c9>)\r\n    2: shadowIncludingInclusiveDescendantsIterator(aka shadowIncludingInclusiveDescendantsIterator) [0x1a4ca627a641] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jsdom\/li...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0x3e0d8aedbe3d \r\n13: 0x3e0d8b35eedc \r\n\r\n<--- Last few GCs --->\r\n\r\n[51519:0x102804000]    28074 ms: Mark-sweep 1324.5 (1445.0) -> 1315.7 (1449.0) MB, 760.4 \/ 0.0 ms  (average mu = 0.182, current mu = 0.080) allocation failure scavenge might not succeed\r\n[51519:0x102804000]    28906 ms: Mark-sweep 1328.5 (1449.0) -> 1317.7 (1452.0) MB, 770.4 \/ 0.0 ms  (average mu = 0.129, current mu = 0.074) allocation failure scavenge might not succeed\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x3e0d8aedbe3d]\r\nSecurity context: 0x3611d141e6e9 <JSObject>\r\n    1: queueMutationRecord(aka queueMutationRecord) [0x361185f32321] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jsdom\/lib\/jsdom\/living\/helpers\/mutation-observers.js:~33] [pc=0x3e0d8b35eedc](this=0x361116e826f1 <undefined>,type=0x3611aa0a3681 <String[9]: childList>,target=0x36110b275a91 <EventTargetImpl map = 0x3611a254a2f1>,name=0x361116e822b1 <null>,name...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003d041 node::Abort() [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 2: 0x10003d24b node::OnFatalError(char const*, char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 3: 0x1001b8e25 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 4: 0x100586d82 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 5: 0x100589855 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 6: 0x1005856ff v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 7: 0x1005838d4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 8: 0x10059016c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n 9: 0x1005901ef v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n10: 0x10055fb34 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n11: 0x1007e7e14 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/evhaus\/.nvm\/versions\/node\/v10.17.0\/bin\/node]\r\n12: 0x8d8aedbe3d \r\n<--- Last few GCs --->\r\n\r\n[51526:0x102804000]    33125 ms: Mark-sweep 1318.6 (1425.0) -> 1317.7 (1424.0) MB, 874.8 \/ 0.0 ms  (average mu = 0.126, current mu = 0.038) allocation failure scavenge might not succeed\r\n[51526:0x102804000]    33136 ms: Scavenge 1318.5 (1424.0) -> 1318.0 (1424.5) MB, 3.8 \/ 0.0 ms  (average mu = 0.126, current mu = 0.038) allocation failure \r\n[51526:0x102804000]    33148 ms: Scavenge 1318.7 (1424.5) -> 1318.2 (1425.0) MB, 4.2 \/ 0.0 ms  (average mu = 0.126, current mu = 0.038) allocation failure \r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x8d8aedbe3d]\r\n    1: StubFrame [pc: 0x8d8ae8d40b]\r\n    2: ConstructFrame [pc: 0x8d8ae8cfa3]\r\nSecurity context: 0x3324ecd9e6e9 <JSObject>\r\n    3: new NodeImpl(aka NodeImpl) [0x3324c2083e11] [\/Users\/evhaus\/Git\/zenhub\/client\/node_modules\/jsdom\/lib\/jsdom\/living\/nodes\/Node-impl.js:~125] [pc=0x8d8b357fd4](this=0x332437582801 <the_hole>,globalObject=0x3324b10f98e9 <Window map = 0x3324649cf0a1>,args=0x3324b1841471 <JSArray[0]>,...\r\n```","Too bad \ud83d\ude1e Is that with or without coverage?","That was without coverage. Should have clarified.\r\n\r\nDo you think that I'm running a fairly old version of Node (v10) would be factor in this?","You can try using newer versions, if nothing else it'd be an interesting data point. Other things to try is to try to make a heap dump right before it dies. What's on the heap?","It's interesting that nobody mentioned that micromatch@4 doesn't cache regexps anymore (see https:\/\/github.com\/micromatch\/micromatch\/pull\/151 and https:\/\/github.com\/facebook\/jest\/pull\/10131 introduces missing caching on jest side.\r\n\r\nFor me downgrade to micromatch@3 and upgrade to `jest-environment-jsdom-sixteen` saved 50% of time.\r\nBut with jest 26 and built-in jsdom I'm still getting leaks error when run jest with --detectLeaks in my case. Tried fresh repo and all works well.","https:\/\/github.com\/facebook\/jest\/pull\/10131 is merged!! <3 ","Released in 26.1.0, very interested in hearing if it helps folks","@SimenB thanks a lot for the release! unfortunately on our side we're still facing a huge difference:\r\n\r\ncurrent:\r\n```\r\nos: osx\r\nnode: 12.6.1\r\njest: 24.9\r\n-----------------\r\n174 test suites\r\n823 tests\r\n322 snapshots\r\n-----------------\r\ndone in 23.569s\r\n```\r\n\r\non every version higher than 24.9\r\n```\r\nos: osx\r\nnode: 12.6.1\r\njest: 26.1.0\r\n-----------------\r\n174 test suites\r\n823 tests\r\n322 snapshots\r\n-----------------\r\ndone in 133.763s\r\n```\r\n\r\nboth with fresh caches and after a complete reinstall of all node modules. untouched configs.\r\nrunning tests on watch mode it takes more than 3min on my machine to determine which tests to run. i can't really isolate the issue for a reproduction but if you give me some advices what to test, i'd be very interested. thanks for all the work you put into that!","@SimenB \r\n\r\nFor `prettier` project, still slow than `v24` when collecting coverage.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/172584\/85495188-a5751d00-b60c-11ea-999c-557645210b53.png)\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/172584\/85495908-00f3da80-b60e-11ea-9993-30f7f26ab57d.png)\r\n\r\n\r\nhttps:\/\/github.com\/prettier\/prettier\/pull\/8636","I can confirm that versions 25 and 26 performances are lower than 24 on Bitbucket Pipeline. I've also noticed that the slowness increases with coverage enabled. Version 25 gets even worse compared to 26 and the pipeline crashes due the memory consume.","@SimenB I did a `git bisect` to find out where the performance regression between 24.9 and 25.1 was introduced. I used the prettier tests because they run without modification all the way from 24.9 to 26.1.\r\n\r\nI compared the accumulated runtime of three runs of the js subset (to safe some time) with disabled cache. More specially the command I use was (`yarn run jest --no-cache tests\/js\/`) with node 10.19. because node 10 was the recommended version for 24.9.\r\n\r\nResults:\r\n```\r\n24.9.0-dev 3cdbd556948b4974b2cc23178977eb159d343df8 151.84s <- Good\r\n25.1.0-dev 5dcc48075f22d581864f381f20bc8b257d2a73cd 223.29s <- Bad\r\n24.9.0-dev bf6109591365a2b71c7b642fa33ed06d3db6cb26 122.58s\r\n24.9.0-dev 77c3ceedfd61ddc841e11fec7b76e540924d3e60 120.42s\r\n24.9.0-dev 30e08e9ae7d7d78f40df757c2ec4b49357285eda 221.28s\r\n24.9.0-dev ad5377333daf6716af3465bba39f86b7db485e2b 222.33s\r\n24.9.0-dev 8ddadfca76eb3fb979df81033d3d0ff564c415d6 120.32s\r\n24.9.0-dev 966f22f2a08d9ac9300b6964ab91c4e75dba4761 120.46s\r\n24.9.0-dev b9084101189639524863e15ef7557ea6bc6704b9 119.87s\r\n24.9.0-dev 1d8245d77d47b4198d51e55da87893d7dfe1a759 129.93s\r\n\r\nad5377333daf6716af3465bba39f86b7db485e2b is the first bad commit\r\ncommit ad5377333daf6716af3465bba39f86b7db485e2b\r\nAuthor: Simen Bekkhus <sbekkhus91@gmail.com>\r\nDate:   Mon Dec 2 23:20:16 2019 +0100\r\n\r\n    feat: add support for `compileFunction` allowing us to avoid the module wrapper (#9252)\r\n```\r\n\r\nSince there is a fallback if `compileFunction` is not defined I removed the `compileFunction` branch from ad5377333daf6716af3465bba39f86b7db485e2b which restored the performance.\r\n\r\nLooking at 26.1 the code has moved around a bit but `compileFunction` and the fallback are still there. So:\r\n```\r\n26.1.0-dev 817d8b6aca845dd4fcfd7f8316293e69f3a116c5 242.99s <- with compileFunction\r\n26.1.0-dev 817d8b6aca845dd4fcfd7f8316293e69f3a116c5 151.61s <- without compileFunction\r\n```\r\ni.e. removing the `compileFunction` branch ([patch](https:\/\/github.com\/facebook\/jest\/files\/4943649\/dont-use-compile-function.patch.txt)) brings 26.1 back to the runtime of 24.9. I\u2019m sure that is not the solution, but at least we have something to work with.\r\n\r\n","As another data point, our jest suite currently takes around 2767 seconds with jest@24.8.0 and [in our update MR](https:\/\/gitlab.com\/gitlab-org\/gitlab\/-\/merge_requests\/33252) it takes around 3497 seconds, an increase around 27%.\r\n\r\nThanks for all the great work, jest team, I hope that the detective skills of @wurstbonbon can help you fixing that regression!","@wurstbonbon thanks for taking the time to dig! Very interesting that `compileFunction` is slower... That should mean that you can just use a custom test environment instead of applying a patch.\r\n\r\n```ts\r\nconst NodeEnv = require('jest-environment-node');\r\n\r\nclass MyNodeEnv extends NodeEnv {}\r\n\r\ndelete MyNodeEnv.prototype.compileFunction;\r\n\r\nmodule.exports = MyNodeEnv;\r\n```\r\n\r\n(and the same for jsdom env). Can you confirm?\r\n\r\n---\r\n\r\nIt being such a bottleneck sounds weird though - Node itself switched to using it 18 months ago: https:\/\/github.com\/nodejs\/node\/pull\/21573. So it's probably something weird we're doing on our side. The linked https:\/\/github.com\/nodejs\/node\/issues\/26229 is very interesting though - maybe we need to do some more caching on our side?","@SimenB i just tried something similar to that custom env and it looks like it was a little better (but still slower than jest 24).\r\n\r\nI had to do `MyNodeEnv.prototype.getVmContext = null;`, though, because I'm testing with jest 26, and it looks like it checks for `if (typeof this._environment.getVmContext === 'function') {` [now](https:\/\/github.com\/facebook\/jest\/blob\/7723ae221a220f385ef4711589648611b7015045\/packages\/jest-runtime\/src\/index.ts#L1006). Not sure if this could cause other issues, though.\r\n\r\nThese are the results i'm seeing after a few runs:\r\n\r\nJest 26 w\/testEnvironment: \"node\" => ~280s\r\nJest 26 w\/custom test environment => ~210s\r\nJest 24 => ~160s\r\n\r\n\r\nLet me know if i can help with any other information or something else!","As expected the custom env results in the same speedup for prettier.\r\n\r\nI've also tried it on our codebase where the difference is ~270s vs ~200s so only about 25% and not 40% reduction. Unfortunately I can't run our tests with jest 24 because we rely on the new modern timers mocking.","I missed a `delete` in my example above, sorry about that.\r\n\r\n---\r\n\r\nI wonder if it's enough to just cache the compiled functions manually - could you try to apply this patch? (both transpiled JS and the TS source included here)\r\n\r\n\r\n<details>\r\n\r\n```diff\r\ndiff --git i\/packages\/jest-runtime\/build\/index.js w\/packages\/jest-runtime\/build\/index.js\r\nindex 1d094a6dc0..f6d059caa3 100644\r\n--- i\/packages\/jest-runtime\/build\/index.js\r\n+++ w\/packages\/jest-runtime\/build\/index.js\r\n@@ -267,6 +267,7 @@ const getModuleNameMapper = config => {\r\n const unmockRegExpCache = new WeakMap();\r\n const EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\r\n const runtimeSupportsVmModules = typeof _vm().SyntheticModule === 'function';\r\n+const compiledFunctionCache = new Map();\r\n \/* eslint-disable-next-line no-redeclare *\/\r\n \r\n class Runtime {\r\n@@ -1169,23 +1170,30 @@ class Runtime {\r\n       value: this._createRequireImplementation(localModule, options)\r\n     });\r\n     const transformedCode = this.transformFile(filename, options);\r\n-    let compiledFunction = null; \/\/ Use this if available instead of deprecated `JestEnvironment.runScript`\r\n+    let compiledFunction = undefined; \/\/ Use this if available instead of deprecated `JestEnvironment.runScript`\r\n \r\n     if (typeof this._environment.getVmContext === 'function') {\r\n       const vmContext = this._environment.getVmContext();\r\n \r\n       if (vmContext) {\r\n-        try {\r\n-          compiledFunction = (0, _vm().compileFunction)(\r\n-            transformedCode,\r\n-            this.constructInjectedModuleParameters(),\r\n-            {\r\n-              filename,\r\n-              parsingContext: vmContext\r\n-            }\r\n-          );\r\n-        } catch (e) {\r\n-          throw (0, _transform().handlePotentialSyntaxError)(e);\r\n+        const params = this.constructInjectedModuleParameters();\r\n+        const cacheKey = transformedCode + params;\r\n+        compiledFunction = compiledFunctionCache.get(cacheKey);\r\n+\r\n+        if (!compiledFunction) {\r\n+          try {\r\n+            compiledFunction = (0, _vm().compileFunction)(\r\n+              transformedCode,\r\n+              params,\r\n+              {\r\n+                filename,\r\n+                parsingContext: vmContext\r\n+              }\r\n+            );\r\n+            compiledFunctionCache.set(cacheKey, compiledFunction);\r\n+          } catch (e) {\r\n+            throw (0, _transform().handlePotentialSyntaxError)(e);\r\n+          }\r\n         }\r\n       }\r\n     } else {\r\n@@ -1194,13 +1202,13 @@ class Runtime {\r\n       const runScript = this._environment.runScript(script);\r\n \r\n       if (runScript === null) {\r\n-        compiledFunction = null;\r\n+        compiledFunction = undefined;\r\n       } else {\r\n         compiledFunction = runScript[EVAL_RESULT_VARIABLE];\r\n       }\r\n     }\r\n \r\n-    if (compiledFunction === null) {\r\n+    if (!compiledFunction) {\r\n       this._logFormattedReferenceError(\r\n         'You are trying to `import` a file after the Jest environment has been torn down.'\r\n       );\r\ndiff --git i\/packages\/jest-runtime\/src\/index.ts w\/packages\/jest-runtime\/src\/index.ts\r\nindex 522adabd1e..8958a4cef8 100644\r\n--- i\/packages\/jest-runtime\/src\/index.ts\r\n+++ w\/packages\/jest-runtime\/src\/index.ts\r\n@@ -137,6 +137,8 @@ type RunScriptEvalResult = {[EVAL_RESULT_VARIABLE]: ModuleWrapper};\r\n \r\n const runtimeSupportsVmModules = typeof SyntheticModule === 'function';\r\n \r\n+const compiledFunctionCache = new Map<string, ModuleWrapper>();\r\n+\r\n \/* eslint-disable-next-line no-redeclare *\/\r\n class Runtime {\r\n   private _cacheFS: StringMap;\r\n@@ -1000,24 +1002,29 @@ class Runtime {\r\n \r\n     const transformedCode = this.transformFile(filename, options);\r\n \r\n-    let compiledFunction: ModuleWrapper | null = null;\r\n+    let compiledFunction: ModuleWrapper | undefined = undefined;\r\n \r\n     \/\/ Use this if available instead of deprecated `JestEnvironment.runScript`\r\n     if (typeof this._environment.getVmContext === 'function') {\r\n       const vmContext = this._environment.getVmContext();\r\n \r\n       if (vmContext) {\r\n-        try {\r\n-          compiledFunction = compileFunction(\r\n-            transformedCode,\r\n-            this.constructInjectedModuleParameters(),\r\n-            {\r\n+        const params = this.constructInjectedModuleParameters();\r\n+\r\n+        const cacheKey = transformedCode + params;\r\n+\r\n+        compiledFunction = compiledFunctionCache.get(cacheKey);\r\n+\r\n+        if (!compiledFunction) {\r\n+          try {\r\n+            compiledFunction = compileFunction(transformedCode, params, {\r\n               filename,\r\n               parsingContext: vmContext,\r\n-            },\r\n-          ) as ModuleWrapper;\r\n-        } catch (e) {\r\n-          throw handlePotentialSyntaxError(e);\r\n+            }) as ModuleWrapper;\r\n+            compiledFunctionCache.set(cacheKey, compiledFunction);\r\n+          } catch (e) {\r\n+            throw handlePotentialSyntaxError(e);\r\n+          }\r\n         }\r\n       }\r\n     } else {\r\n@@ -1028,13 +1035,13 @@ class Runtime {\r\n       );\r\n \r\n       if (runScript === null) {\r\n-        compiledFunction = null;\r\n+        compiledFunction = undefined;\r\n       } else {\r\n         compiledFunction = runScript[EVAL_RESULT_VARIABLE];\r\n       }\r\n     }\r\n \r\n-    if (compiledFunction === null) {\r\n+    if (!compiledFunction) {\r\n       this._logFormattedReferenceError(\r\n         'You are trying to `import` a file after the Jest environment has been torn down.',\r\n       );\r\n```\r\n<\/details>\r\n\r\nEDIT: nope, this breaks horribly \ud83d\ude48 I've asked in the Node issue if it's possible to populate the compilation cache \ud83e\udd1e ","I thought this might do the trick.\r\n```js\r\nconst params = this.constructInjectedModuleParameters();\r\nconst cacheKey = transformedCode + params;\r\nconst cachedData = compileFunctionCache.get(cacheKey);\r\n\r\ntry {\r\n  compiledFunction = (0, _vm().compileFunction)(\r\n    transformedCode,\r\n    params,\r\n    {\r\n      filename,\r\n      parsingContext: vmContext,\r\n      cachedData,\r\n      produceCachedData: !cachedData,\r\n    },\r\n  );\r\n\r\n  if (compiledFunction.cachedDataProduced) {\r\n    compileFunctionCache.set(cacheKey, compiledFunction.cachedData);\r\n  } \r\n} catch (e) {\r\n  throw (0, _transform().handlePotentialSyntaxError)(e);\r\n}\r\n```\r\nIt improves performance a little but `Script` is still a lot faster.","Tried the recommendation from @SimenB: https:\/\/gitlab.com\/gitlab-org\/gitlab\/-\/merge_requests\/33252\/diffs?commit_id=6d633c88caf70f712fa0ccaac42d952976161ec6\r\n\r\nWhile it did improve performance a bit, it is still considerably slower than on jest 24.x:\r\n\r\n- Jest 24.x: 2580 seconds total runtime of our jest tests\r\n- Jest 26.x: 3166 seconds total runtime of our jest tests","@leipert Have you by any chance tried downgrading the jsdom environment to 14?\r\n\r\n`yarn add test-environment-jsdom-fourteen --dev` + `\"testEnvironment\": \"test-environment-jsdom-fourteen\"` in your jest config. This still seems to be responsible for the bulk of the duration increase for us (adds 40-50%) but it's starting to look like there's multiple regressions in play.","@pleunv With jest 24.x we are on jsdom 16 with `jest-environment-jsdom-sixteen`, we had to upgrade due to some issues with testing web components. So the only change we do: jest 24.x + `jest-environment-jsdom-sixteen` -> jest.26x + `jest-environment-jsdom`, so the jsdom version doesn't even change.","Opened up https:\/\/github.com\/nodejs\/node\/issues\/35375 upstream about the issue found by @wurstbonbon","@SimenB are you aware of any viable alternatives to micromatch? That repo has been silent for over half a year now, and major issues affecting Jest like https:\/\/github.com\/micromatch\/micromatch\/issues\/179 are still open.","Not really, it's what most libraries use. Could look at e.g. minimatch, but I doubt it'd be viable","@SimenB What makes micromatch better than all the alternatives?","Based on the feedback in the issue I've opened, I'm thinking we should revert to using `Script` for now as it seems it's gonna need a bit of work in Node to fix it there.\r\n\r\n@leipert @wurstbonbon or anyone else, can you try this patch in your `node_modules\/jest-runtime\/build\/index.js`?\r\n\r\n<details>\r\n\r\n```diff\r\ndiff --git i\/packages\/jest-runtime\/build\/index.js w\/packages\/jest-runtime\/build\/index.js\r\nindex 851d8e12cd..7235082546 100644\r\n--- i\/packages\/jest-runtime\/build\/index.js\r\n+++ w\/packages\/jest-runtime\/build\/index.js\r\n@@ -1170,35 +1170,24 @@ class Runtime {\r\n       value: this._createRequireImplementation(localModule, options)\r\n     });\r\n     const transformedCode = this.transformFile(filename, options);\r\n-    let compiledFunction = null; \/\/ Use this if available instead of deprecated `JestEnvironment.runScript`\r\n+    let compiledFunction = null;\r\n+    const script = this.createScriptFromCode(transformedCode, filename);\r\n+    let runScript = null; \/\/ Use this if available instead of deprecated `JestEnvironment.runScript`\r\n \r\n     if (typeof this._environment.getVmContext === 'function') {\r\n       const vmContext = this._environment.getVmContext();\r\n \r\n       if (vmContext) {\r\n-        try {\r\n-          compiledFunction = (0, _vm().compileFunction)(\r\n-            transformedCode,\r\n-            this.constructInjectedModuleParameters(),\r\n-            {\r\n-              filename,\r\n-              parsingContext: vmContext\r\n-            }\r\n-          );\r\n-        } catch (e) {\r\n-          throw (0, _transform().handlePotentialSyntaxError)(e);\r\n-        }\r\n+        runScript = script.runInContext(vmContext, {\r\n+          filename\r\n+        });\r\n       }\r\n     } else {\r\n-      const script = this.createScriptFromCode(transformedCode, filename);\r\n-\r\n-      const runScript = this._environment.runScript(script);\r\n+      runScript = this._environment.runScript(script);\r\n+    }\r\n \r\n-      if (runScript === null) {\r\n-        compiledFunction = null;\r\n-      } else {\r\n-        compiledFunction = runScript[EVAL_RESULT_VARIABLE];\r\n-      }\r\n+    if (runScript !== null) {\r\n+      compiledFunction = runScript[EVAL_RESULT_VARIABLE];\r\n     }\r\n \r\n     if (compiledFunction === null) {\r\n```\r\n<\/details>\r\n\r\nI'll need to tweak how v8 code coverage works, but I'll try to open a PR tomorrow or next week.","I tested out the patch to use `Script` on our test suites and here's the result I came to \r\nTime is in `min:sec`\r\n\r\nName | Suite 1 | Suite 2 | Suite 3 | Suite 4\r\n-- | -- | -- | -- | --\r\njest 24 | 3:25 | 3:30 | 3:29 | 0:53\r\njest 26 patched | 3:32 | 4:36 | 3:48 | 0:53\r\njest 26 unpatched | 5:10 | 6:12 | 5:11 | 1:07\r\n26 patched vs 24 | 4% | 31% | 9% | 1%\r\n26 unpatched vs 24 | 52% | 76% | 49% | 27%\r\n26 patched vs unpatched | 46% | 35% | 36% | 25%\r\n\r\n<details>\r\n\r\nIteration | Suite 1 | Suite 2 | Suite 3 | Suite 4\r\n-- | -- | -- | -- | --\r\njest 24 - 1 | 2:58 | 3:37 | 3:33 | 0:47\r\njest 24 - 2 | 3:18 | 3:34 | 3:32 | 0:51\r\njest 24 - 3 | 3:27 | 3:08 | 3:48 | 0:59\r\njest 24 - 4 | 3:37 | 3:44 | 3:38 | 0:53\r\njest 24 - 5 | 3:45 | 3:31 | 2:56 | 0:55\r\njest 26 patched - 1 | 3:42 | 4:31 | 4:08 | 0:57\r\njest 26 patched - 2 | 3:11 | 4:18 | 3:28 | 0:57\r\njest 26 patched - 3 | 3:55 | 5:12 | 3:19 | 0:55\r\njest 26 patched - 4 | 3:22 | 4:25 | 4:20 | 0:46\r\njest 26 unpatched - 1 | 4:30 | 6:12 | 4:28 | 1:08\r\njest 26 unpatched - 2 | 5:16 | 6:17 | 5:18 | 1:05\r\njest 26 unpatched - 3 | 5:46 | 6:07 | 5:49 | 1:09\r\n\r\n<\/details>\r\n\r\nAll tests ran on same commit & similar test environment (Azure DevOps Hosted Ubuntu 18)\r\nI only took the time taken for running jest on my test suites.\r\nMost of my suites are similar in nature (all backend unit tests)\r\n\r\nFrom what I can tell, the patch to use `Script` does make a huge difference on the perf. \r\nI can't tell if the slowdown on `Suite 2` is an outlier or a real regression (only did 4 runs).\r\nIt does look like there's still a perf regression, but not as bad","still interesting that v26 still doesn't improve on v24...","Thanks @Cellule! That's good enough for me - I'll put together a PR when I have some time","Awesome stuff! That leaves only the Micromatch issue then, hopefully that repo will come under active maintenance again.","BTW, there is also perf regression in JSDOM I assume. As I did such tests on a big web project.  No patches mentioned above are applied.\r\nAnd it looked like that.\r\n```\r\nJest 24  (testEnvironment: \"jsdom\") (no rewires latest CRA)\r\n144.014s\r\n\r\nJest 24 (testEnvironment: \"jest-environment-jsdom-sixteen\") (rewire latest CRA that changes testEnvironment)\r\n409.473s (also few failed tests)\r\n\r\nJest 26 (testEnvironment: \"jsdom\") (no rewires latest CRA) so old jsdom? Whatever is the default for Jest 26 I assume? (I used react-app-rewired to rewire jest config and pnpmfile.js to override what version of Jest was installed with `react-scripts` as it still ships Jest 24 (like resolutions in yarn))\r\n310.275s\r\n\r\nJest 26 (testEnvironment: \"jest-environment-jsdom-sixteen\") (rewire latest CRA that changes testEnvironment + pnpmfile.js)\r\nover 1200s+ (some tests failed plus test run just stuck forever)\r\n```\r\nSurely this is a super vague and unstable performance report I must stay, but I think every input helps :)","https:\/\/github.com\/facebook\/jest\/releases\/tag\/v26.5.0 has the `vm.Script` change discussed here","(Edit: updated after additional runs)\r\n\r\nPreliminary results on the same test suite:\r\n\r\nJest 26.5\r\nCold: 59.992\r\nHot: 43.976\r\n\r\nJest 26.4:\r\nCold:  90.213 \r\nHot: 47.408\r\n\r\nA very significant speedup on cold runs <3 ","And here are the results with my test suite:\r\n\r\nJest 26.5\r\nCold: 149s\r\n\r\nJest 26.4\r\nCold: 226s","Great news \ud83d\ude42 I think we're back to just the micromatch regression, then","If you guys are using `npm-force-resolutions` to forcely install micromatch 3. It may not work in `jest@26.5.0`\r\n\r\n```json\r\n\/\/ package.json\r\n  ...\r\n  \"preinstall\": \"npx npm-force-resolutions\",\r\n  ..\r\n  \"resolutions\": {\r\n    \"micromatch\": \"^3.0.0\"\r\n  }\r\n```\r\n\r\nError when run test:\r\n```\r\nTypeError: _micromatch(...).default.scan is not a function\r\n    at globs.map.glob (\/home\/travis\/build\/removed\/node_modules\/jest-util\/build\/globsToMatcher.js:65:47)\r\n    at Array.map (<anonymous>)\r\n    at globsToMatcher (\/home\/travis\/build\/removed\/node_modules\/jest-util\/build\/globsToMatcher.js:61:26)\r\n    at new SearchSource (\/home\/travis\/build\/removed\/node_modules\/@jest\/core\/build\/SearchSource.js:197:49)\r\n    at contexts.map.context (\/home\/travis\/build\/removed\/node_modules\/@jest\/core\/build\/runJest.js:265:16)\r\n    at Array.map (<anonymous>)\r\n    at runJest (\/home\/travis\/build\/removed\/node_modules\/@jest\/core\/build\/runJest.js:264:34)\r\n    at startRun (\/home\/travis\/build\/removed\/node_modules\/@jest\/core\/build\/cli\/index.js:479:35)\r\n    at runWithoutWatch (\/home\/travis\/build\/removed\/node_modules\/@jest\/core\/build\/cli\/index.js:494:10)\r\n    at _run10000 (\/home\/travis\/build\/removed\/node_modules\/@jest\/core\/build\/cli\/index.js:416:13)\r\nnpm ERR! Test failed.  See above for more details.\r\n```\r\n@SimenB Thank you very much for the update. It saves us 20% of running time on Travis after updating to `jest@26.5.0`\r\n","Our results:\r\n\r\nJest v26.5\r\n  - 323.98s\r\n  - 321.24s\r\n\r\nJest v24.9\r\n  - 262.17s\r\n  - 275.96s\r\n","Thanks @SimenB! This is amazing. Our results for our ~22000 tests in ~2000 suites:\r\n\r\n- Jest 24.x: 2864 s\r\n- Jest 26.5.2: 2967 s\r\n\r\nwhich is about 3% slower and thus in the margin of error, compared to the ~27% slowdown we saw before. Thank you, now we just need to merge: https:\/\/gitlab.com\/gitlab-org\/gitlab\/-\/merge_requests\/33252#note_425616404","Just wanted to note that all of the [\"heap out of memory\" issues](https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-579423330) that I was having before are gone after upgrading to Jest 26.5.2 and Node 14 (was on Node 10 before). Not sure how much of the problem was caused by Jest vs. by Node, but if others are seeing similar problems try upgrading to both.\r\n\r\n*UPDATE*: Nevermind. I've started getting OOM errors again. I guess it's right on the borderline of what my laptop can handle and the first few runs were good, but now it's dying again. Will have to still stick to 24.x.x. :(","If somebody is interested, I have created a DOM that has very good performance in comparison to JSDOM. It has support for Jest.\r\n\r\n\r\n| Operation                            | JSDOM   | Happy DOM |\r\n| ------------------------------------ | ------- | --------- |\r\n| Import \/ Require                     | 333 ms  | 45 ms     |\r\n| Parse HTML                           | 256 ms  | 26 ms     |\r\n| Serialize HTML                       | 65 ms   | 8 ms      |\r\n| Render custom element                | 214 ms  | 19 ms     |\r\n| querySelectorAll('tagname')          | 4.9 ms  | 0.7 ms    |\r\n| querySelectorAll('.class')           | 6.4 ms  | 3.7 ms    |\r\n| querySelectorAll('[attribute]')      | 4.0 ms  | 1.7 ms    |\r\n| querySelectorAll('[class~=\"name\"]')  | 5.5 ms  | 2.9 ms    |\r\n| querySelectorAll(':nth-child(2n+1)') | 10.4 ms | 3.8 ms    |\r\n\r\n\r\n\r\n**Link to project:**\r\nhttps:\/\/github.com\/capricorn86\/happy-dom\/","@capricorn86 Looks nice. Is it spec compliant?","> @capricorn86 Looks nice. Is it spec compliant?\r\n\r\nThank you @milesj!\r\n\r\nThe functionality that has been implemented has been implemented according to specs, but there is no detailed overview of which specs that are covered yet. I am thinking about adding that. However, all functionality is covered by unit tests.\r\n\r\nThe initial goal of the DOM was to be able to render web components server side with good performance, as I needed it for some other projects.","FWIW, I just tried bumping our project from `react-scripts@3` with Jest 24.9, to `@react-scripts@4` with Jest 26.6.\r\n\r\nOur server API test suite had previously been executing in about 180-190 seconds.  After switching to Jest 26.6, it was consistently taking about 220 seconds.  I even tried forcing resolution of `minimatch` to `4.0.2`.  Switching the test runner to `jest-circus` seemed to knock off a couple seconds, but overall, 26.6 seems noticeably slower.","`react-scripts@4` uses `jest-circus` by default, fwiw. It's also `micromatch` we use, not `minimatch`. Seems we've broken rolling back `micromatch` via #10131, however, so not as easy to test if that is the cause of the regression anymore","@SimenB : we've got a weird migration setup atm - it's a legacy MEAN \/ AngularJS app that [I converted to build using CRA](https:\/\/blog.isquaredsoftware.com\/2020\/03\/codebase-conversion-building-mean-with-cra\/).  The test config is all our own, vs the built-in CRA Jest config - we're just taking advantage of the fact that CRA comes with Jest as a dependency.\r\n\r\nI don't have my work box in front of me atm, so now I can't remember if I actually meant `micromatch` or if I really focused on the wrong package name there :)  I'll have to look at it again next week.","I just noticed that v26 runs _a lot_ slower in iTerm than in macOS's default terminal. On a set of 6500 tests I consistently get the following results:\r\n\r\n- v24, Terminal: ~90s\r\n- v24, iTerm2: ~90s\r\n- v26, Terminal: ~110s\r\n- v26, iTerm2: ~150s\r\n\r\nThis blew my mind a little bit after months of trying various things to sort out the slowdown. Any chance anyone else with perf issues on a mac can try this out? Mind you, this is with jsdom@14 on v26.","@pleunv I believe this may be related: https:\/\/github.com\/facebook\/jest\/pull\/9294. I noticed that hyperlinks slow down iTerm2 on my machine, making it choppy. But haven't investigated the overall speed of execution, nor found another person that had issues with it.","Eureka. Searching for \"iTerm\" brought me to [this PR](https:\/\/github.com\/facebook\/jest\/pull\/9294\/files). I had noticed these underlines before and didn't realize they were hyperlinks. After seeing that PR I disabled hyperlinks in iTerm which brought my runtime down to 130s. After applying the code from the PR and removing the hyperlinks I'm back down to 120s. Sanity slightly restored.\r\n\r\nAny chance that PR can get put back in?\r\n\r\nedit: @thymikee beat me to it \ud83d\ude04 ","@pleunv I'll try to find some time this week to bring it back. Although the real deal would be to fix this for iTerm, as other terminals e.g. on Linux have no issues with hyperlinks. Would you mind to file an issue to the iTerm project?","I just made this change and it gave me 1s for a single test file. And you can still click on the url, it's just no longer underlined.\r\n![image](https:\/\/user-images.githubusercontent.com\/3099581\/99946456-adc9b380-2d76-11eb-84cb-cb7eed9c3ca2.png)\r\n\r\nThis might be huge for larger runs. \u2764\ufe0f \r\n\r\n\/\/edit\r\nFunny thing it made no difference before if it was iterm or terminal. After the change iterm is faster for me.","> @pleunv I'll try to find some time this week to bring it back. Although the real deal would be to fix this for iTerm, as other terminals e.g. on Linux have no issues with hyperlinks. Would you mind to file an issue to the iTerm project?\r\n\r\nI've created an issue [here](https:\/\/gitlab.com\/gnachman\/iterm2\/-\/issues\/9296) (they're on GitLab). If anyone has additional details or a repro project, feel free to add.\r\n\r\nI was experimenting some more in the mean time and I found that, when only running it on a smaller subset of tests (couple dozen test files), hyperlinks generally don't make that much of a difference. When running it on our full set though (700 files) the impact is very much measurable.\r\n\r\nI also have the impression that on a long run jest's console output starts to get really glitchy\/flashy. The progress lines on the bottom for example are more hidden than visible.","I'm still seeing a 30% slowdown as well jumping from 23.6 to 26.6.\r\n\r\n```\r\n23.6.0\r\ncold 29.9\r\nwarm 15.4\r\n\r\n26.6.3\r\ncold 40.6\r\nwarm 24.0\r\n```\r\n\r\nIt seems like the setup is problematic; while it would take ~4 seconds for the first test to complete with 23.6, it'll now take ~10 seconds.\r\n\r\nNo obvious difference in speed between iTerm and Terminal, though I do notice the glitchy\/flashy output @pleunv mentioned on iTerm.\r\n\r\nIf this seems like something people still have an appetite for debugging I can try to put together a repro repo.","We recently updated to jest 26 + `jest-circus` so that we could add some light instrumentation to our test suite. We initially had individual transactions for each `runScript`, but it was being called hundreds (thousands?) of times and made it hard to read:\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/79684\/100684214-be59cb00-332e-11eb-8c6a-7b79da28403e.png)\r\n\r\nThe `Missing instrumentation` block is all of the `runScript` calls which amounts to more than 50% of the test suite duration. (Our tests may also be leaky as the test duration increases for each run).","I'm also getting heap errors since upgrading to jest@25 and up.\r\n\r\nI made a repo that contains a minimal reproduction of the error: https:\/\/github.com\/gjgd\/minimal-cipher-jest-bug\r\n\r\n```\r\ngit clone git@github.com:gjgd\/minimal-cipher-jest-bug.git\r\ncd minimal-cipher-jest-bug\r\ncd doesnt-work\r\nnpm i\r\nnpm t\r\n```\r\n\r\nThis is the full error: https:\/\/github.com\/gjgd\/minimal-cipher-jest-bug\/runs\/1506646882#step:5:15\r\n\r\nThe only solution that I found so far was to downgrade to jest@24","Hi, @billyvg ! What is a soft that you used to monitor tests? https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-736152077","@Lertis https:\/\/sentry.io","@billyvg already found it, but thanks for an answer. Cannot understand how to monitor tests there, any guides\/videos\/topics?","@Lertis It's a bit experimental, but here's what we did: https:\/\/github.com\/getsentry\/sentry\/pull\/22237","@SimenB Regression in micromatch was fixed in 4.0.4 (see https:\/\/github.com\/micromatch\/micromatch\/issues\/179), would it be possible to bump the dependency and see if it improves the performance in jest cases that regressed before?","It's in semver range, so you can update locally","@SimenB Yes, but considering that it's an important fix, wouldn't it make sense to force update globally?","I checked on my codebase and cannot see any performance difference with micromatch@4.0.4","@atsikov Thanks for checking! Guess it only makes difference when there is a significant amount of files excluded from collecting coverage.","@kibertoad you are right, I should have checked changes in micromatch before testing.\r\nI remember micromatch was mentioned in the discussion, so I had an impression that there was a performance fix, and not just a regression which likely caused https:\/\/github.com\/facebook\/jest\/issues\/9464","I'm not seeing an improvement with 4.0.4, but as has been discussed here and elsewhere that was probably not the cause of the regression in the first place.","My team upgraded Jest from 24 to 26 and ran into similar performance woes, regardless of whether we're collecting coverage (our tests were taking ~30-40% longer).  I've tried a few things mentioned in this thread:\r\n\r\n- `micromatch@4.04` - no perceivable change for us\r\n- `jest-environment-jsdom@24` - performance improved, in line with what we were experiencing with Jest 24\r\n- Trying the various `jest-environment-jsdom-{version}` packages as test environments\r\n\r\nBaseline performance with Jest 24:\r\n\r\n```\r\nTest Suites: 348 passed, 348 total\r\nTests:       3948 passed, 3948 total\r\nSnapshots:   0 total\r\nTime:        532.623s\r\nRan all test suites.\r\n```\r\n\r\nPerformance after upgrading to Jest 26 \ud83d\udca5:\r\n\r\n```\r\nTest Suites: 348 passed, 348 total\r\nTests:       3948 passed, 3948 total\r\nSnapshots:   0 total\r\nTime:        748.671 s\r\nRan all test suites.\r\n```\r\n\r\nPerformance with Jest 26 and `jest-environment-jsdom-fourteen`:\r\n\r\n```\r\nTest Suites: 348 passed, 348 total\r\nTests:       3948 passed, 3948 total\r\nSnapshots:   0 total\r\nTime:        493.382 s\r\nRan all test suites.\r\n```\r\n\r\nPerformance with Jest 26 and `jest-environment-jsdom-fifteen` \ud83d\udca5:\r\n\r\n```\r\nTest Suites: 348 passed, 348 total\r\nTests:       3948 passed, 3948 total\r\nSnapshots:   0 total\r\nTime:        757.684 s\r\nRan all test suites.\r\n```\r\n\r\nI'm not exactly sure what it is about JSDOM 15\/16 that is causing this for us, but it seems we don't have an issue with JSDOM 14.","I was able to fix and resolve the OOM errors [we were having](https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-578221837) by doing the following:\r\n\r\n- Adding a forced async timeout for tests which performed heavy DOM manipulation.\r\n```js\r\n\/\/ We have hundreds of tests that use this\r\nbeforeEach(async () => {\r\n    \/\/ Inject a giant HTML string into the DOM to simulate a real website\r\n    document.documentElement.innerHTML = TEST_SUITE.dom;\r\n\r\n    \/\/ THIS WAS THE MOST IMPORTANT FIX\r\n    \/\/ Without this, memory would never get released between test suites and would reach the Node memory ceiling\r\n    await new Promise((resolve) => {\r\n        setTimeout(() => resolve(), 1);\r\n    })\r\n});\r\n```\r\n- Cleaning up and fixing all \"Warning: An update to [...] inside a test was not wrapped in act(...).\" errors being reported in the tests\r\n- Cleaning up and fixing all \"Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\" errors being reported in the tests\r\n- Setting as many of our tests as possible to use `@jest-environment node`. Majority of our tests needed the DOM, but at least some of them could use the Node environment. This sped them up a lot.\r\n- Upgrading to the latest Jest 27+ version (we're on `jest-environment-jsdom@27.2.0`)\r\n\r\nAfter this, all the `JavaScript heap out of memory` went away and the run time of Jest 24 was comparable to Jest 27. Maybe even a little bit faster.\r\n\r\n2 big lesson for us were to:\r\n1) Stop ignoring all the warnings and errors reported in the Jest output. All devs are now asked to be extra mindful of this.\r\n2) Run `node --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage` periodically to check on how much memory is used in our test suites and ensure that it doesn't indicate constant growth\r\n\r\nHope this can help others who are having issues.","> I'm not exactly sure what it is about JSDOM 15\/16 that is causing this for us, but it seems we don't have an issue with JSDOM 14.\r\n\r\nA few weeks ago I played around with replacing babel with `@swc\/jest` just to see how it would impact test performance and it barely made a dent. I don't know what happened inside JSDOM after v14 but it's gotten *unbearably* slow. I suppose their goal is to be as feature-complete as possible while our goal is to have our tests run as fast as possible, and those 2 don't really match up. Not sure if JSDOM has a way to turn off certain features or something.","I tried https:\/\/github.com\/capricorn86\/happy-dom as JSDOM alternative, that was a few month ago. I did not support everything when need and I had no time to take a deeper look into it. However the tests which ran were **not** significantly faster. (Our setup is very complex.)\r\nDepending on your setup and needs it might be a viable alternative.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","As an addendum, I suppose we can say that Jest performance is pretty great as of Jest 29 (at least).","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Hello &#x27;github-actions[bot]&#x27;,\r\n\r\nThank you for contacting us!  The Notable office is currently closed in observance of the Presidents' Day holiday.\r\n\r\nWe will resume normal business hours on Tuesday, February 20th, from 9am to 9pm EST and look forward to assisting you at that time.\r\n\u200b\r\n\r\nBest Regards,\r\nThe Notable Team","Who knew that the achilles heel of ActionsBot was vacation auto-replies.","Hello &#x27;Christopher,\r\n\r\nThank you for contacting us!  The Notable office is currently closed in observance of the Presidents' Day holiday.\r\n\r\nWe will resume normal business hours on Tuesday, February 20th, from 9am to 9pm EST and look forward to assisting you at that time.\r\n\u200b\r\n\r\nBest Regards,\r\nThe Notable Team"],"labels":[":boom: Regression"]},{"title":"Meta: Native support for ES Modules","body":"EDIT: quick guide for getting started: https:\/\/jestjs.io\/docs\/ecmascript-modules\r\n\r\nESM support will be unflagged in a future release of Node 12 (maybe not before April https:\/\/github.com\/nodejs\/node\/pull\/29866#issuecomment-574055057) and it is already unflagged in Node 13.2, so I think it's time to evaluate how we can add native support in Jest. I'll try to list which features Jest currently provides that are impacted by ESM support, and how we can solve\/investigate them.\r\n\r\nThere is issue #4842, but I think that's more of a discussion issue, while this issue will be geared towards actually implementing support and more suitable to track for those who just want to get the current implementation status. Any comments added to this issue _not_ related to how we can implement support for the below enumerated features will be marked as spam - please direct any workarounds\/discussions to separate issues. Also feel free to tell us if anything related to ESM features is missing from the list!\r\n\r\nPlease note that Jest will use the `vm` API (https:\/\/nodejs.org\/api\/vm.html) and as of writing (node ~v13.6~ v16.10) the ESM parts of this API is still flagged (`--experimental-vm-modules`). So saying ESM is unflagged is a bit of a misnomer at the moment. But I think we should start experimenting and potentially provide feedback to the [Modules WG](https:\/\/github.com\/nodejs\/modules).\r\n\r\nEDIT: Tracking issue for stabilization in Node: https:\/\/github.com\/nodejs\/node\/issues\/37648\r\n\r\nLastly, I'm writing this issue mostly for people who will implement support, so it'll be somewhat low-level and specific to how Jest works. For people who _just_ want to know whether support has landed or not, I recommend using GH's wonderful \"custom notification\" and only subscribe to notifications on closing\/reopening.\r\n\r\n---\r\n\r\n- [x] Running the module in the correct context\r\n\r\nWe achieve sandboxes by running a script within a given `vm.Context` (either provided by JSDOM or node core APIs). We need to do the same for ESM, but we'll need access to the `context` during construction of the module, not just when executing the module. I've opened up #9428 which adds the necessary APIs to `JestEnvironment`.\r\n\r\n- [x] Globals\r\n\r\n`expect`, `test`, `beforeEach` etc will still be added as globals, nothing should change here. `jasmine` global will also still be here.\r\n\r\n- [x] `jest` \"global\" property\r\n\r\nThis is not really a global - it's injected into the module scope. Since the module scope is gone in ESM, we need to move it somewhere. Adding it to `import.meta` seems natural - there's an option called `initializeImportMeta` which we can use.\r\n\r\nEDIT: Solution here is to fetch it via `import {jest} from '@jest\/globals'`. We might still add it via `import.meta` in the future, but this should be enough for now.\r\n\r\n- [ ] `jest.(do|un)mock`\r\n\r\nSince ESM has different \"stages\" when evaluating a module, `jest.mock` will not work for static imports. It can work for dynamic imports though, so I think we just have to be clear in the docs about what it supports and what it doesn't.\r\n\r\n`jest.mock` calls are hoisted, but that doesn't help in ESM. We might consider transforming `import 'thing'` to `import('thing')` which should allow hoisting to work, but then it's async. Using top-level `await` is probably a necessity for such an approach. I also think it's invasive enough to warrant a separate option. Something to discuss - we don't need to support everything `jest.mock` can for  for an initial release.\r\n\r\nPR: #10976\r\n\r\n- [ ] `jest.requireActual`\r\n\r\nNot sure if how it should behave in ESM. Should we provide a `jest.importActual` and let `requireActual` evaluate in `CJS` always?\r\n\r\n- [x] `import.meta`\r\n\r\nNode has `url` as its only property (for now, at least). We need to make sure it's populated in Jest as well. We provide `identifier` instead of `filename` when constructing the module so I don't think it'll happen automatically, but `url` is essentially `filename` passed though [`pathToFileURL`](https:\/\/nodejs.org\/api\/url.html#url_url_pathtofileurl_path).\r\n\r\nThere's also an open PR for `import.meta.resolve`: https:\/\/github.com\/nodejs\/node\/pull\/31032\r\n\r\n- [x] `import thing from 'thing'`\r\n\r\nThis should actually be fairly straightforward, we just need to implement a [`linker`](https:\/\/nodejs.org\/api\/vm.html#vm_module_link_linker) where we can also transform the source before returning it, meaning we don't need the loader API (which doesn't exist yet). This allows us to return mocks as well (albeit they'll have to come from a `__mocks__` directory).\r\n\r\n- [x] `import('thing')`\r\n\r\nEssentially the same as above, but passed as `importModuleDynamically` when constructing the module. Will also support `jest.mock`, `jest.resetModules` etc more cleanly, so likely to be used quite a bit.\r\n\r\nThis can also be done for `vm.Script` via the same option.\r\n\r\n- [ ] Handling errors during evaluation\r\n\r\nRight now it's a runtime error (e.g. module not found), but that's not necessarily true with ESM. Does it matter for us? We should verify errors still look nice.\r\n\r\n- [x] `module.createRequire`\r\n\r\nWe need to deal with this for people wanting to use CJS from ESM. I've opened up #9426 to track this separately as implementing it is not really related to ESM support.\r\n\r\nEDIT: Implemented in #9469\r\n\r\n- [ ] `module.syncBuiltinESMExports`\r\n\r\nhttps:\/\/nodejs.org\/api\/modules.html#modules_module_syncbuiltinesmexports. Do we care about it, or is just making it a no-op enough? Not sure what the use case in Jest would be. Messing with the builtins is already breaking the sandbox and I don't think this should matter.\r\n\r\nEDIT: #9469 made this into a no-op. I think that's fine?\r\n\r\n- [x] Detect if a file is supposed to be ESM or CJS mode\r\n\r\nInspecting `type` field in a module's `package.json` seems reasonable: https:\/\/nodejs.org\/api\/esm.html#esm_enabling. Should we also have our own config flag? Also needs to respect file endings.\r\n\r\nhttps:\/\/github.com\/nodejs\/node\/issues\/49446\r\n\r\n- [x] `moduleNameMapper`\r\n\r\nNot sure if this impacts anything. I _think_ not since we'll be linking the modules together ourselves. Needs investigation, though.\r\n\r\nEDIT: This is all resolution logic, which we control. So no changes here.\r\n\r\n- [x] `jest.config.mjs`\r\n\r\nThrough #9291 we support `jest.config.cjs` - do we need to do anything special for `.mjs`? Probably use `import('path\/to\/configFile.mjs')` which means it'll have to be async. Is this an issue? Might be worth making config resolution `async` in Jest 25 so it's not a blocker for incremental support of ESM in Jest 25.\r\n\r\nEDIT: #9431\r\n\r\n- [x] Package Exports\r\n\r\nNode supports [package exports](https:\/\/nodejs.org\/dist\/latest-v12.x\/docs\/api\/esm.html#esm_package_exports), which sorta maps to Jest's `moduleNameMapper`, but also provides encapsulation features. Hopefully [`resolve`](https:\/\/github.com\/browserify\/resolve) will implement this, but if they do not we'll need to do something. Might be enough to use the `pathFilter` option? Unsure.\r\n\r\nEDIT: #9771\r\n\r\n- [ ] JSON\/WASM module\r\n\r\nhttps:\/\/nodejs.org\/api\/esm.html#esm_experimental_json_modules. Do we need to care? Probably, especially for `json`. It's trivial for us to support `import thing from '.\/package.json'` since we control the linking phase, but we probably shouldn't do it by default as it'll differ from default node. Should we force people to define a transform for it?\r\n\r\nWASM: #13505\r\n\r\n- [x] Code coverage\r\n\r\nDoes it matter? I don't think it's affected as we can still transform the source with babel (maybe it'll be confused by `import` statements, probably not) and V8 coverage definitely shouldn't care. We should verify though.\r\n\r\n- [x] Async code resolution\r\n\r\nThis is absolutely no blocker as sync resolution will work just fine. But we _can_ use async resolution now, which is great. I wonder if we should look into just using the `resolve` module off of npm again, as it already supports async. See #9505.\r\n\r\n- [x] Async code transformation\r\n\r\nSimilar to above, not blocking, but would be nice to support it. Might make `@jest\/transformer` more usable in other environments as well. See #9504.\r\n\r\nEDIT: #9889 & #11191\r\n\r\n- [ ] Bad performance when accessing globals\r\n\r\nDue to #5163 we have the `extraGlobals` option as a workaround - that workaround is no longer viable in ESM. I've opened up and issue with node here: https:\/\/github.com\/nodejs\/node\/issues\/31658\r\n\r\n- [x] Import assertions\r\n\r\nhttps:\/\/nodejs.org\/api\/esm.html#import-assertions","comments":["I've landed very basic support with #9772. I've only tested the simplest cases, and there are many known limitations (most notably no `jest` object support and broken semantics when mixing CJS and ESM), but at least it's _something_. It'll go out in the next release of Jest (hopefully soon, only blocked by #9806)","25.4.0 has been released with the first pieces of support. In addition to #9772 mentioned above, I've also included #9842. In _theory_ mixing CJS and ESM should work correctly now (\ud83e\udd1e).\r\n\r\nThe one main missing feature is supporting the `jest` object. I haven't decided if we should stick it to `import.meta` or require people to import it through `import {jest} from '@jest\/globals'`. Feedback appreciated!\r\n\r\nI haven't written docs for this yet, but to activate it you need to do 3 things\r\n\r\n1. make sure you don't run transform away `import` statements (set `transform: {}` in config or otherwise ensure `babel` doesn't transform the file to CJS, such as avoiding the `modules` option to preset-env)\r\n1. Run `node@^12.16.0 || >=13.2.0` with `--experimental-vm-modules` flag\r\n1. Run your test with `jest-environment-node` or `jest-environment-jsdom-sixteen`\r\n\r\nPlease try it out and provide feedback! If reporting bugs, it'd be wonderful if you can also include how running the same code (minus any test specific code) runs in Node. I've read https:\/\/nodejs.org\/api\/esm.html _a lot_ over the last few weeks, but I've probably missed something.","> The one main missing feature is supporting the jest object. I haven't decided if we should stick it to import.meta or require people to import it through import {jest} from '@jest\/globals'.\r\n\r\nFor the typescript use-case it is better to have an explicit import.","Yup, I've added (and the temporarily reverted) a `@jest\/globals` package that supports this, so that will be available regardless. I'm wondering if it makes sense to _also_ expose it on `import.meta`. Currently leaning towards not doing so, mainly since it's easier to add than remove later (and I'm personally no fan of globals)","+1 for the explicit import, it's a bit more verbose but simpler to understand","I'm getting this in Node 13.2 & Jest 25.4: `ES Modules are only supported if your test environment has the `getVmContext` function` What am I missing?","@zandaqo Oh sorry, forgot that point. Added above, but it's\r\n\r\n>Run your tests with `jest-environment-node` or `jest-environment-jsdom-sixteen`","`ReferenceError: jest is not defined` I'm guessing this is due to the missing `@jest\/globals`","Yes, as mentioned this will only work if you don't use the `jest` object.\r\nMocks are also probably broken, haven't tested them \ud83d\ude03","I've compiled a very basic project from what I see in e2e tests directory (`e2e\/native-esm\/__tests__\/native-esm.test.js`) and in this issue. And unfortunately I still can't make it work \ud83d\ude43Can anybody check it by any chance?\r\n\r\nhttps:\/\/drive.google.com\/file\/d\/1vyDZjsVKOTu6j55QA11GjO9E7kM5WX8_\/view?usp=sharing\r\n\r\n- [x] jest version 25.4.0\r\n- [x] node version v13.12.0\r\n- [x] package.json contains recommended jest options and no babel transformations seem to be in place\r\n\r\nRunning sample script (just importing `double` function and printing `double(2)`):\r\n```\r\nnpm run main\r\n\r\n> jest-esm@1.0.0 main \/Users\/ilya\/Projects\/jest-esm\r\n> node src\/main.js\r\n\r\n(node:16961) ExperimentalWarning: The ESM module loader is experimental.\r\n4\r\n```\r\n  \r\nRunning jest with just one test for double function:\r\n```\r\nnpm run test\r\n\r\n> jest-esm@1.0.0 test \/Users\/ilya\/Projects\/jest-esm\r\n> jest\r\n\r\n FAIL  __tests__\/native-esm.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest encountered an unexpected token\r\n\r\n    This usually means that you are trying to import a file which Jest cannot parse, e.g. it's not plain JavaScript.\r\n\r\n    By default, if Jest sees a Babel config, it will use that to transform your files, ignoring \"node_modules\".\r\n\r\n    Here's what you can do:\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/en\/configuration.html\r\n\r\n    Details:\r\n\r\n    \/Users\/ilya\/Projects\/jest-esm\/__tests__\/native-esm.test.js:8\r\n    import {double} from '..\/src\/index.js';\r\n    ^^^^^^\r\n\r\n    SyntaxError: Cannot use import statement outside a module\r\n\r\n      at Runtime._execModule (node_modules\/jest-runtime\/build\/index.js:1074:58)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.542s\r\nRan all test suites.\r\n```","You need to run node with `--experimental-vm-modules` and either name you file `.mjs` or `\"type\": \"module\"` in `package.json`.\r\n\r\nEDIT: You probably have the latter seeing as it works outside of Jest for you, just missing the experimental flag to Node","@SimenB oh wow there are `--experimental-vm-modules` AND `--experimental-modules`. I was confused by the fact that `--experimental-modules` is not required starting from some node 13 version. Thanks! \r\n\r\nTLDR: `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js` works for me","Yeah, from the OP\r\n\r\n>Please note that Jest will use the `vm` API (https:\/\/nodejs.org\/api\/vm.html) and as of writing (node v13.6) the ESM parts of this API is still flagged (`--experimental-vm-modules`). So saying ESM is unflagged is a bit of a misnomer at the moment.\r\n\r\nAwesome that it works for you, though!\r\n\r\n(I'll mark these comments as resolved)","@SimenB Thanks for this! Two issues I'm seeing so far.\r\n\r\n### Issue 1\r\n- ESM unit test file imports default from ESM file (fn being tested)\r\n- ESM file being tested imports default from a package, which exports CJS only\r\n- Results in error: `ReferenceError: module is not defined` in the CJS package file\r\n\r\nSo I'm thinking [this](https:\/\/nodejs.org\/api\/esm.html#esm_interoperability_with_commonjs) may not be correctly implemented? \r\n\r\n> An import statement can reference an ES module or a CommonJS module\r\n\r\nThis works fine when running the app. Named exports from CJS can only be imported by using createRequire, but default exports can just be imported.\r\n\r\n### Issue 2\r\nWhen I'm not hitting the above error, I'm hitting this one:\r\n\r\n```\r\nTypeError: _vm(...).SyntheticModule is not a constructor\r\n\r\n      at Runtime._importCoreModule (node_modules\/jest-runtime\/build\/index.js:1198:12)\r\n```\r\n\r\n### Project details\r\n- Node 12.14.1\r\n- Jest and babel-jest 25.4.0\r\n- Latest Babel with `targets: { node: 12 }` and 2 plugins: `babel-plugin-transform-import-meta` and `rewire-exports`. (Tried removing `import-meta` plugin but got an error saying to add it back.)\r\n- `testEnvironment: \"node\"` is pretty much the only config\r\n- `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js`\r\n\r\nIf a reproduction repo would be helpful, let me know.","Thanks @aldeed!\r\n\r\nI'll look into issue 1, that indeed looks like a bug. EDIT: Should be fixed via #9850\r\n\r\nIssue 2 needs node 12.16.0: https:\/\/nodejs.org\/docs\/latest-v12.x\/api\/vm.html#vm_class_vm_syntheticmodule\r\n\r\nI'll change the check in Jest (right now it checks for `vm.SourceTextModule` which is available in more versions, but we need `SyntheticModule` as well).","Confirmed that running with 12.16.0 fixes my issue 2. Will retest issue 1 after that fix is released. Otherwise waiting on the `jest` object for further testing, and I agree that it should need to be imported.","Awesome work, @SimenB! I'm trying this out on a small project but ran into issues with dynamic imports. This is the error I'm seeing:\r\n\r\n```\r\nModule status must not be unlinked or linkingError [ERR_VM_MODULE_STATUS]: Module status must not be unlinked or linking\r\n```\r\n\r\nIf I remove the dynamic imports then the test will run (but fail for other reasons, of course). The same test is currently working with Mocha (which shipped ESM support fairly recently).\r\n\r\nIf it helps, the dynamic imports in question can be seen here: https:\/\/github.com\/beejunk\/firn.js\/blob\/switch-to-jest\/lib\/renderPage.js#L43-L55\r\n\r\nThe test file is here: https:\/\/github.com\/beejunk\/firn.js\/blob\/switch-to-jest\/test\/build.test.js. The working Mocha version can be seen on the master branch.\r\n\r\nLet me know if there's any other info that my be useful.","Thanks @beejunk! I've been wondering if there could be race conditions between `import`s that import the same module before it's fully linked. It _seems_ like that's what your hitting here. I'll fix this today, thanks for the report!\r\n\r\nEDIT: Fixed in #9858. Copied the fix over to your repo: \r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/79952792-40ba0c80-847b-11ea-9720-b444a69f91a1.png)","Has anyone managed to get this to work with TypeScript? `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js` returns the same `SyntaxError: Cannot use import statement outside a module`, even though my `package.json` does have `\"type\": \"module\"`.\r\n\r\n**babel.config.cjs**\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    '@babel\/preset-typescript',\r\n  ],\r\n};\r\n```\r\n\r\n**jest.config.cjs**\r\n```js\r\nmodule.exports = {\r\n  testEnvironment: 'jest-environment-node',\r\n  transform: {},\r\n};\r\n```","@dandv You're essentially hitting this case: https:\/\/github.com\/facebook\/jest\/pull\/9772\/files#r407255029\r\n\r\nCould you open up a separate issue? Will need to figure out what to do with non-js extensions","@SimenB: #9860. Thanks for taking a look.","@aldeed @beejunk 25.5.0 has been released with fixes for your issues. Keep the bug reports coming \ud83d\ude00 ","Oh, additionally it includes support for `import { jest } from '@jest\/globals'` for those of you waiting for that \ud83d\udc4d ","Thanks for quick work on all this, @SimenB! I think I've run into another issue.\r\n\r\nI've been experimenting with using query params in an import path as a way of busting the module cache on a development server. The idea is to have a file watcher that detects changes in a component and then updates the import path with an arbitrary query param so that the new code is immediately pulled in on the next page load without having to restart the server. This works when running the dev server. However, Jest is throwing the following error:\r\n\r\n```\r\nCannot find module '\/path\/to\/project\/components\/BasePage.js?cache=0' from 'renderPage.js'\r\n```\r\n\r\nHere's an example of where the query params are being used: https:\/\/github.com\/beejunk\/firn.js\/blob\/switch-to-jest\/lib\/renderPage.js#L55-L56\r\n\r\nIf I remove the query params then the tests will pass, although not consistently. If I run a single suite (for example, `npm test -- test\/build.test.js`) the tests pass, but if I run all the tests at once they will fail most of the time with ambiguous errors. I'm still digging into the issue with the inconsistent tests, but I thought I'd report on the query param problem first.\r\n","Thanks for the report @beejunk. #6282 is supposed to deal with this, but that also wants to pass the query to transformers and stuff, that we don't need here. So it might make sense to just support the query internally in the runtime for now, and let #6282 just deal with passing that query on.\r\n\r\nI've added a bit of code to make the module cache vary by query: https:\/\/github.com\/facebook\/jest\/blob\/d425a49bd575e7167bc786f3c4f2833589091fa1\/packages\/jest-runtime\/src\/index.ts#L330-L334\r\n\r\nBut no code ever calls it with a query. I think we should be able to just do `resolvePath.split('?')` and all should work.\r\n\r\nRegarding inconsistent errors, I'll take a look if that repo reproduces it. I haven't tested the ESM code with tests in parallel, only a single test. I'm unsure why it would impact things, but who knows \ud83d\ude00 ","@beejunk query thing fixed in 25.5.1. I haven't had time to investigate the other issue yet","I have a problem that I think may be related  to this however  didn't get fix in `25.X`.\r\n\r\nI'll try to summarise the escenario below:\r\n\r\n- You have a  test with a setup script\r\n- That setup script will require a file dynamically, as in: \r\n`{ default: generator } = require(path.resolve(f))`\r\n- Everything inside `f`  is not transpiled causing the \"unexpected identifier import error\".\r\n\r\nThis also happens if I try with import()","Since you mention transpilation; if you have a setup that transpiles `import` to `require` this issue is not the correct place - this issue is about native support.\r\n\r\n---\r\n\r\nThat said - you cannot `require` ESM, and I haven't been able to add support for `import()` from CJS yet due to Node having no API for it. Support for that has landed on Node master, but not released yet: https:\/\/github.com\/nodejs\/node\/pull\/32985. As can be seen in the linked release PRs, it'll come in 13.14.0 and 14.1.0. At that point I'll implement support for it \ud83d\udc4d \r\n\r\nYou should be able to use a `.mjs` setup file though.","@SimenB This is great, it seems to be working in several test files now! It's a bit of a process to resolve the differences between Babel and Node imports in each file, add jest import, etc., so I may come across more issues as I do that across hundreds of test files.\r\n\r\nA few things that are more questions:\r\n- what you said in your previous comment about support for `import()` from cjs, will that also allow for the Jest config file to be named `jest.config.js`? It currently only works for me when named `jest.config.cjs` and using `module.exports =` (error is `TypeError [ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING]: A dynamic import callback was not specified`)\r\n- The name \"@jest\/globals\" fails the eslint rule `node\/no-extraneous-import` due to not being a package listed in `package-lock`. Is there some reason for this naming convention? Is it possible to use `jest` without the `@`? It's easy to ignore the rule but I'm just wondering.\r\n- Related question, why is `jest` global different from magic fns like `test`,`describe`, `before`, etc.? Should all of those be imported now, too?\r\n- When this is finalized will it be possible for Jest to set `--experimental-vm-modules` flag? It kind of makes this seem nonstandard if it doesn't just work with the `jest` command. If you're not able to directly pass flags, possibly you can set\/amend the `NODE_OPTIONS` env variable?\r\n- I now seem to get a slightly different error than before when trying this on older Node, but neither error was clear that minimum Node version was the problem. Is it easy to add a check for minimum version with a more helpful error message?",">will that also allow for the Jest config file to be named jest.config.js?\r\n\r\nIt can be named `.js` if its closest `package.json` has `type: 'module'`. Otherwise to use ESM in the config file, it needs to be named `.mjs`. See https:\/\/nodejs.org\/api\/esm.html#esm_enabling. Note that the config file runs outside of Jest, so there we don't have much control. At the moment, we don't support async config, but `await`ing an exported promise would be trivial, PR welcome \ud83d\ude42 #8357 has stalled.\r\n\r\nI'm very surprised you get `A dynamic import callback was not specified` though, we don't load the config file in a vm... Could you open up a separate issue?\r\n\r\n>The name \"@jest\/globals\" fails the eslint rule `node\/no-extraneous-import` due to not being a package listed in `package-lock`. Is there some reason for this naming convention? Is it possible to use `jest` without the `@`? It's easy to ignore the rule but I'm just wondering.\r\n\r\nYou should add a `devDependency` on `@jest\/globals`. The package itself is solely type definitions. It's a separate package from `jest` so that type definitions work correctly, and so we can throw an error if it's loaded outside of the Jest runtime.\r\n\r\nI don't currently have any plans to change that, but we could possibly deprecate that package and export the types from `jest`. That's a major breaking change though, so let's see later \ud83d\ude42 \r\n\r\n>Related question, why is `jest` global different from magic fns like `test`,`describe`, `before`, etc.? Should all of those be imported now, too?\r\n\r\n`jest` is like `require` or `module` object from CJS in that it's unique per file, it's not actually a global (i.e. `globalThis.jest === undefined`). That allows `jest.mock('..\/..\/file.js')` etc to work correctly relative to the file it was injected in. You can choose to also import the actual globals, but they are still available as `globalThis.expect` etc.\r\n\r\n>When this is finalized will it be possible for Jest to set `--experimental-vm-modules` flag?\r\n\r\nI think we'll wait for node to unflag them rather than silently set them - they're flagged for a reason, the API might change at some point. We could add an option that set `NODE_OPTIONS` I guess, not sure if that changes the current runtime? Regardless, no current plans for it.\r\n\r\n>I now seem to get a slightly different error than before when trying this on older Node, but neither error was clear that minimum Node version was the problem. Is it easy to add a check for minimum version with a more helpful error message?\r\n\r\nYeah, I'll be adding a better error message along with some documentation once the implementation stabilizes a bit. Seeing as the implementation is guarded by an experimental flag, I don't think anyone will stumble over it.","@SimenB , I updated Jest to 25.5.2 and now all tests are passing. Query params are working and the intermittent errors I was seeing earlier are no longer happening. Thanks again for all your work!","Okay, I saw the errors again on my last run of the tests, so that is still happening. I'll see if I can figure out a way to consistently reproduce and report back.","I believe I've found a consistent way to reproduce the issue. Here is the branch I am working from: https:\/\/github.com\/beejunk\/firn.js\/tree\/switch-to-jest\r\n\r\nTo reproduce:\r\n\r\n1. Delete the Jest cache if it exists. I just manually deleted `\/tmp\/jest_rs`.\r\n2. Run `npm test` three times. The first two runs should succeed. However, the third run should fail.\r\n\r\nThis is the stack trace I'm seeing when the error does occur:\r\n\r\n```\r\n    Error: \r\n        at invariant (\/home\/brian\/Projects\/firn.js\/node_modules\/jest-runtime\/build\/index.js:1866:11)\r\n        at Runtime.loadEsmModule (\/home\/brian\/Projects\/firn.js\/node_modules\/jest-runtime\/build\/index.js:480:7)\r\n        at Runtime.linkModules (\/home\/brian\/Projects\/firn.js\/node_modules\/jest-runtime\/build\/index.js:548:19)\r\n        at importModuleDynamicallyWrapper (internal\/vm\/module.js:397:21)\r\n        at htmPreactPath (internal\/process\/esm_loader.js:31:14)\r\n        at renderPage (\/home\/brian\/Projects\/firn.js\/lib\/renderPage.js:53:15)\r\n        at map (\/home\/brian\/Projects\/firn.js\/lib\/build.js:43:12)\r\n        at Array.map (<anonymous>)\r\n        at build (\/home\/brian\/Projects\/firn.js\/lib\/build.js:36:43)\r\n        at Object.<anonymous> (\/home\/brian\/Projects\/firn.js\/test\/build.test.js:57:5)\r\n```\r\nThe error does seem to be originating with the dynamic imports. There's no error message, so I'm not entirely sure what is happening.\r\n\r\nAn additional note: If I clear the Jest cache and update the test script by adding  `--no-cache`, then I am unable to reproduce the issue.","Heh, I was lazy there and didn't provide a proper error message. The issue is that the test environment has been torn down, so I'm guessing there's a missing `await` somewhere. Didn't see anything looking through your code though, so I'll have to dig some more","@SimenB Here is a reproduction of that ESM config issue: https:\/\/github.com\/facebook\/jest\/issues\/9935","@SimenB  I have created a minimal example for reproducing the Jest errors I mentioned above when using dynamic imports:\r\n\r\nhttps:\/\/github.com\/beejunk\/jest-esm-dynamic-import-error\r\n\r\n","Thanks for the great reproduction @beejunk! I've spent more hours that I care to admit here, without really understanding if it's a bug in Jest or in Node. I've reproduced the behavior using solely node core modules and reported it upstream, so let's see what they say: https:\/\/github.com\/nodejs\/node\/issues\/33216","Thanks for looking into it, @SimenB. The tests seem to consistently pass if I add the `--no-cache` flag, which is fine for my use case. I appreciate all the work!","Yeah, I noticed that as well. I think it's some sort of timing issue - with no cache things are slow enough that it works.","@SimenB Thanks for resolving #9935. I mentioned a second concern in there, which I think is still valid. When `type: \"module\"`, `jest --init` is still generating the config file with `module.exports` in it. This is relatively minor to change manually if you know what you're doing, but I think if ESM is unflagged in Node and lots of people start doing ESM projects, it will start to look more like a confusing bug (i.e., happy path of `jest --init && jest` on a new ESM project will throw an error). Should I submit a different issue specifically about improving the init logic?","@aldeed are you sure? Testing right now gives me a `mjs` file with `export default` in it. I guess we could generate `js` and not `mjs`, but still. It uses ESM syntax","@SimenB Well I was sure until you asked. \ud83d\ude04I tried it and you're correct. Maybe I initially did it with an older version of Node or Jest? Disregard.","This is awesome! Just reworked tests in one of my libraries to use ES Modules and ditched Babel. Thanks @SimenB!\r\n\r\n>Detect if a file is supposed to be ESM or CJS mode\r\n\r\nSpeaking of this, there are a lot of browser\/bundler-oriented packages out their using `\"module\":\"<path to es module>\"` syntax to denote their ES module exports. It might be prudent to have some way of specifying how to resolve a given package regardless of the package's own settings. Something like `moduleNameMapper` but to specify if it's CJS or ESM.","hi @SimenB , once this issue is closed, it means `ts-jest` can also unforce `commonjs` right ? Is file extension required to change from transformer side to work with esm ? \r\n\r\nFor example now `ts-jest` compiles `ts` to `js` for `commonjs`, does `esm` require file extension `mjs` when compiling from `ts` to `js` ?","@zandaqo we won't support `modules` field, we'll be following node's spec and use `exports`: #9771. You can plug in your own resolver to support `modules` if you want, though: https:\/\/jestjs.io\/docs\/en\/configuration#resolver-string. We might add some other option (`mainFields`, like webpack maybe?), but that'll come further down the line when the implementation stabilizes and we have less unknown unknowns \ud83d\ude42 \r\n\r\n---\r\n\r\n@ahnpnl #9860","Ciao guys!\r\nJust a question: the blog post mentions that, since ES6 modules are static, they cannot be mocked;  so, actually, there's no way to mock a module A imported by a module B in ES6?\r\n","@gabrieledarrigo I use `moduleNameMapper` for that, for example:\r\n\r\n```json\r\n    \"moduleNameMapper\": {\r\n      \"moduleA\": \"<rootDir>\/test\/moduleA-mock.js\"\r\n    },\r\n```","@gabrieledarrigo you can do\r\n\r\n```js\r\njest.mock('the-thing-i-want-to-mock', () => \/* do whatever in here *\/);\r\n\r\nlet importedThing;\r\n\r\nbeforeAll(async () => {\r\n  importedThing = await import('thing-that-imports-mocked-module');\r\n});\r\n```\r\n\r\nSo you just need to make the import non-static and mocking will work.\r\n\r\nI'm not sure it works now though, as I haven't wired up mock resolutions in the ESM code path yet. Will do so at some point soonish. But that is _probably_ going to be how we document module mocks for native ESM.\r\n\r\nAs mentioned in the blog pots, we'll be documenting these patterns at some point, we just have to figure them out \ud83d\ude42 \r\n\r\nOne idea we had was wait for top level await, then we could do this with a babel plugin.","@SimenB First of all, thank you for awesome job here :) \r\n\r\nI actually face a problem when I would like to create customEnvironment extended from `jest-environment-node`. I need to import my server implementation there, which is written as esm. But it looks like, environment has to be defined as `cjs`. \r\nMy question is, is there an option to define custom testEnvironment as esm to be able to import my server module? Thank you for any advice.","@kuka-radovan could you open up a separate feature request for that?","UPDATE: This issue is now tracked in https:\/\/github.com\/facebook\/jest\/issues\/10025\r\n\r\n@SimenB Thanks for the `jest.mock` advice above. As it happens I'm converting a few files that need that today. I can confirm that your example works when the mocked module is a `node_modules` package, but it isn't working for me mocking a module in the same project.\r\n\r\nHere's a simple example:\r\n\r\n```js\r\n\/\/ main.js\r\nimport secondary from \".\/secondary.js\";\r\n\r\nexport default function main() {\r\n  return secondary();\r\n}\r\n\r\n\/\/ secondary.js\r\nexport default function secondary() {\r\n  return true;\r\n}\r\n\r\n\/\/ test.js\r\nimport { jest } from \"@jest\/globals\";\r\n\r\njest.mock(\".\/secondary.js\");\r\n\r\nlet main;\r\nlet secondary;\r\nbeforeAll(async () => {\r\n  ({ default: main } = await import(\".\/main.js\"));\r\n  ({ default: secondary } = await import(\".\/secondary.js\"));\r\n});\r\n\r\ntest(\"works\", () => {\r\n  secondary.mockReturnValueOnce(false); \/\/ TypeError: Cannot read property 'mockReturnValueOnce' of undefined\r\n  expect(main()).toBe(false);\r\n});\r\n```\r\n\r\nExact same pattern works when `\".\/secondary.js\"` is a package name instead. (I think the package I tried with exports CommonJS, if that matters.)\r\n\r\nJest 26.0.1 w\/ Node 12.16.3\r\n\r\nAny ideas, or should I submit a full separate issue?\r\n\r\nEDIT: `transform: {}` in config, so no Babel at all\r\n\r\nEDIT 2: This doesn't work either:\r\n\r\n```js\r\njest.mock(\".\/secondary.js\", () => ({\r\n  default: jest.fn()\r\n}));\r\n```","Amazing work on this.\r\n\r\nHowever, unless I'm doing something wrong, it doesn't yet seem to be possible to use `import()` in a CJS test file.\r\n\r\nI'm running Jest with `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js` and have `testEnvironment: 'node', transform: {}` in `jest.config.js`. This is on Node 14.2.0.\r\n\r\nThe import expression produces error:\r\n\r\n```\r\nTypeError [ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING]:\r\nA dynamic import callback was not specified.\r\n```\r\n\r\nIs this a known limitation at present? I see https:\/\/github.com\/nodejs\/node\/pull\/32985 has now landed in Node 14.1.0.","Yeah, I haven't gotten to implementing it yet. I'll probably land it this weekend.\r\n\r\n@aldeed could you open up a separate issue? I need to go through and make sure mocks are part of the resolution, and your example seems like a good test case \ud83d\ude42 ","@SimenB Thanks for swift reply. I'll keep a look out for when it lands.","Seeing as `import` in scripts might be reverted due to a regression (https:\/\/github.com\/nodejs\/node\/issues\/33166), let's hold off until that settles","I'm having issues trying to use this with `.mjs` test files. If I have `__tests__\/my-test.mjs`, I get\r\n\r\n```\r\n$ yarn test\r\nyarn run v1.22.4\r\n$ node --experimental-vm-modules node_modules\/jest\/bin\/jest.js\r\nNo tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn C:\\Users\\Domenic\\Dropbox\\Programming\\WIP\\remember-to-eat\r\n  1 file checked.\r\n  testMatch: **\/__tests__\/**\/*.[jt]s?(x), **\/?(*.)+(spec|test).[tj]s?(x) - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 1 match\r\n  testRegex:  - 0 matches\r\nPattern:  - 0 matches\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nIf I add\r\n\r\n```\r\n\"testMatch\": [\"**\/__tests__\/**\/*.mjs\"]\r\n```\r\n\r\nto my package.json, I get\r\n\r\n```\r\n$ yarn test\r\nyarn run v1.22.4\r\n$ node --experimental-vm-modules node_modules\/jest\/bin\/jest.js\r\nNo tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn C:\\Users\\Domenic\\Dropbox\\Programming\\WIP\\remember-to-eat\r\n  1 file checked.\r\n  testMatch: **\/__tests__\/**\/*.mjs - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 1 match\r\n  testRegex:  - 0 matches\r\nPattern:  - 0 matches\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nHowever if I remove the `\"testMatch\"` and then rename my file to `__tests__\/my-test.js`, it works.\r\n\r\nI'd like to be able to consistently use .mjs extensions in my project. Is that possible with Jest?","@domenic I ran into this too. Solution is to add to config `\"moduleFileExtensions\": [\"js\", \"mjs\"]` (in addition to `\"testMatch\"`).","Took a look, and `moduleFileExtensions` is indeed necessary.\r\n\r\nJest gets a list of all files in the project by running `hasteFS.getAllFiles()` here:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/2460c059ad1dbf124466ac25c8d5ccfd74ae9f25\/packages\/jest-core\/src\/SearchSource.ts#L159-L164\r\n\r\n`hasteFS` is created as part of the `HasteMap` with the the following `extensions` config:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/2460c059ad1dbf124466ac25c8d5ccfd74ae9f25\/packages\/jest-runtime\/src\/index.ts#L291\r\n\r\n---\r\n\r\nHowever, I don't think it should be necessary to specify `moduleFileExtensions` in this case though. We already force `.snap` to be found, should we force well-known JS extensions as well? Those being (off the top of my head) `js`, `mjs`, `cjs`, `jsx`, `ts` and `tsx`? It'll make the crawl slower, but I wouldn't think it has a huge impact. I might be wrong though? As a default it shouldn't be much slower since only `cjs` and `mjs` is not part of default patterns already, but for people who have custom patterns it might slow things down?","Yeah, it would be ideal if, at least in ES modules mode, .mjs just worked, without having to add moduleFileExtensions or modify the default testMatch.\r\n\r\nIt would also be nice if I could exclude .js files; when I tried that I got\r\n\r\n```\r\n Validation Error:\r\n\r\n  moduleFileExtensions must include 'js':\r\n  but instead received:\r\n    [\"mjs\"]\r\n  Please change your configuration to include 'js'.\r\n```","I'm wondering if it makes sense to have some \"ESM mode\" which would add the node esm file extensions and also help with compile-to-js using esm to opt in (#9860).\r\n\r\n---\r\n\r\nWithout `js` some stuff internally breaks that we load inside the sandbox (as it uses the same `require` implementation etc). We should probably fix that so the user cannot break us.","Regarding slowing down, it's already quite slow on large projects, but I don't know that the number of extensions impacts that much. But I agree mjs and cjs should be added as defaults. Specifying `moduleFileExtensions: ['js']` would override the defaults and speed it up, right? So maybe just document that as a performance tweak.","Thanks for all of this work! It is certainly amazing. I followed the 3 steps (`\"type\": \"module\"` on my package.json, `\"testEnvironment\": \"jest-environment-node\"` in my jest config and `--experimental-vm-modules` on the CLI) and it seems too be working well \ud83c\udf89\r\n\r\nBut then I'm trying to read and use `import.meta` [as described in Node.js docs](https:\/\/nodejs.org\/api\/esm.html#esm_no_require_exports_module_exports_filename_dirname) (and which seems to be already implemented judging from the checkbox) to create `__dirname`, but it seems like `import.meta` is failing:\r\n\r\n```js\r\nconsole.log(import.meta);\r\n\r\nSyntaxError: [PATH]\/files.test.js: Support for the experimental syntax 'importMeta' isn't currently enabled (31:20):\r\n    Add @babel\/plugin-syntax-import-meta (https:\/\/git.io\/vbKK6) to the 'plugins' section of your Babel config to enable parsing.\r\n```\r\n\r\nI don't have any babel and I thought babel was being left behind with this work. I'll come back to report if I can fix it somehow without installing babel.\r\n\r\nNode.js v14.3.0, Jest v25.5.4","I found a workaround for now. Since I am running the script from the same directory where my file is [in my library](https:\/\/github.com\/franciscop\/files\/), I can just do:\r\n\r\n```js\r\nconst __dirname = process.cwd();\r\nconst __filename = __dirname + \"\/files.test.js\";\r\n```\r\n\r\nI'll follow this repo in case there's any update, thanks again for doing this!","You need to explicitly opt-out of Babel by using `transform: {}` as config","@SimenB I can confirm that adding `transform: {}` worked, thanks! I misunderstood that point as \"don't add transforms\" and not as \"take transforms away\" as intended.\r\n\r\nBTW, testing has gone from [2.4 seconds](https:\/\/github.com\/franciscop\/files\/runs\/688935427?check_suite_focus=true#step:5:124) to only [1.3 seconds](https:\/\/github.com\/franciscop\/files\/runs\/708814772?check_suite_focus=true#step:5:100) and they consistently feel faster.","Node 12 has been released with unflagged ESM (https:\/\/nodejs.org\/en\/blog\/release\/v12.17.0\/). As noted in the OP though, the APIs Jest use are _not_ unflagged","@SimenB I went over this thread several times but I am still stuck (using node 12.17).\r\n\r\nWhen running Jest 26.0.1 I get this error:\r\n```\r\nError [ERR_REQUIRE_ESM]: Must use import to load ES Module: \/app\/tests\/setup.js\r\nrequire() of ES modules is not supported.\r\nrequire() of \/app\/tests\/setup.js from \/app\/node_modules\/@jest\/transform\/build\/ScriptTransformer.js is an ES module file as it is a .js file whose nearest parent package.json contains \"type\": \"module\" which defines all .js files in that package scope as ES modules.\r\nInstead rename setup.js to end in .cjs, change the requiring code to use import(), or remove \"type\": \"module\" from \/app\/package.json.\r\n```\r\n\r\nI have `transform: {},` and running with `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js`.\r\n\r\nWhat am I missing?","@aldarund not sure, could you put together a minimal reproduction?","@SimenB here's a minimal repo to repro, just run `yarn test` https:\/\/github.com\/aledalgrande\/jest-example - I've tried with Node 13\/14 and it's the same outcome. It seems to me that the flow for the global setup has not been updated to work with ESM.\r\n\r\nalso, you mentioned someone else \ud83d\ude06 ","~Not @simenB, but @aledalgrande you seem to have everything correct here from what I tried, see [my project fully running on ESM](https:\/\/github.com\/franciscop\/files) for comparison (jest config in the `package.json`).~\r\n\r\n~To debug it if possible, I would suggest to simplify your jest config to _only_ have the two relevant properties, perhaps even in the `package.json` first. Then add each of the other properties you currently have to see which one works\/didn't work.~\r\n\r\nAh the second comment mentions `globalSetup` and not normal tests, nvm my comment then. If I remove the `globalSetup` key in Jest, then the test runs as expected in that example, but the `globalSetup` key doesn't work as you said.","Aha, I've forgotten about global setup and teardown. Can fix \ud83d\udc4d","Hi @SimenB , me again. Are named exports supported? With Node.js I can import and use a package like this:\r\n\r\n```js\r\nimport { customAlphabet } from \"nanoid\";\r\n```\r\n\r\nHowever, when trying to do a test that same code gives this error:\r\n\r\n```\r\nSyntaxError: The requested module 'nanoid' does not provide an export named 'customAlphabet'\r\n```\r\n\r\nFor the tests, I can change the code to this and it works:\r\n\r\n```js\r\nimport nanoid from \"nanoid\";\r\nconst { customAlphabet } = nanoid;\r\n```\r\n\r\nBut then the Node.js version stops working since there's actually no default sport (but for some reason the default export works with Jest):\r\n\r\n```\r\nSyntaxError: The requested module 'nanoid' does not provide an export named 'default'\r\n```\r\n\r\nThe published (the repo seems to be in flux right now) `nanoid` code ends like this, with no default export:\r\n\r\n```\r\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\r\n```","Jest consumes only \"main\" entry point. \"exports\" is not considered yet. You just import commonjs version which has only default export.","Ah I see, the `package.json` seems to include this:\r\n\r\n```js\r\n  \"main\": \"index.cjs\",\r\n  \"module\": \"index.js\",\r\n  \"exports\": {\r\n    \".\/package.json\": \".\/package.json\",\r\n    \".\": {\r\n      \"require\": \".\/index.cjs\",\r\n      \"import\": \".\/index.js\",\r\n      \"browser\": \".\/index.browser.js\"\r\n    },\r\n    ...\r\n  }\r\n  ...\r\n```\r\n\r\nSo probably Node.js is finding the module version, while Jest is using the CommonJS version that does not have a named export, right?\r\n\r\nI'll wait until `Package Exports` is checked and then test it, thanks for all the work again! Marking these 2 comments as resolved until then. The test I'm referring to [is this one](https:\/\/github.com\/franciscop\/backblaze\/blob\/master\/test.js).","I'm revisiting this to see how its working - upgraded to Jest 26.0.1 and node 14.4. Set package.json to module type, set transform to `{}`, env to `jest-environment-node` and running with `  node --experimental-vm-modules`. Now I get this new error: \r\n```\r\nES Modules are only supported if your test environment has the `getVmContext` function\r\n```\r\nI have been unable to find info on this except a changelog from Jest saying `getVmContext` had been added a while back.  \r\n\r\nAny ideas?","Could you share the relevant parts of your `package.json` please @cyberwombat ? Including the launching script that you are using for Jest.","For reference, this is how it looks for me [on a working project](https:\/\/github.com\/franciscop\/files\/blob\/master\/package.json):\r\n\r\n```json\r\n{\r\n  ...\r\n  \"type\": \"module\",\r\n  \"scripts\": {\r\n    ...\r\n    \"test\": \"node --experimental-vm-modules node_modules\/jest\/bin\/jest.js\",\r\n  },\r\n  \"jest\": {\r\n    \"transform\": {},\r\n    \"testEnvironment\": \"jest-environment-node\"\r\n  },\r\n  ...\r\n```\r\n\r\nThen launch it with `npm test`","@franciscop  Mine basically is the same. Node 14.4.0.  I can run yours fine. I will dive into things to see the diff. \r\npackage.json\r\n```\r\n{\r\n  \"type\": \"module\",\r\n  \"devDependencies\": {\r\n    \"jest\": \"^26.0.1\",\r\n  },\r\n}\r\n```\r\njest.config.js\r\n```\r\nexport default {\r\n  testEnvironment: 'jest-environment-node',\r\n  setupFilesAfterEnv: ['.\/test\/bootstrap.js'],\r\n  testPathIgnorePatterns: ['<rootDir>\/node_modules\/', '<rootDir>\/config\/', '\/<rootDir>\/src\/'],\r\n  testRegex: '(\\\\.|\/)(test|spec)\\\\.[jt]sx?$',\r\n  transform: {\r\n\/\/    '^.+\\\\.jsx?$': 'babel-jest' \/\/ esm someday\r\n  },\r\n  transformIgnorePatterns: [],\r\n  modulePaths: [\r\n    '<rootDir>\/test',\r\n    '<rootDir>\/src',\r\n    '<rootDir>'\r\n  ]\r\n}\r\n```\r\nScript:\r\n`node --experimental-vm-modules node_modules\/jest\/bin\/jest.js`","Not sure, but I'd try to  work the other way around. Remove everything except `transform: {}` and `testEnvironment: 'jest-environment-node'`, and start adding each of the options until you see which one triggers the previous error. I specially suspect `transformIgnorePatterns` _might_ be conflicting with `transform`, but I'm not that familiar with jest options.","Hello everyone! I ran into some issue while using Jest to test an Express application. More details [here](https:\/\/stackoverflow.com\/questions\/62164814\/cant-use-uuid-module-when-running-tests-with-jest\/). Not sure if that's useful for what you are doing\/tracking here :roll_eyes:","@x80486 I encountered [exactly the same issue yesterday](https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-638484858). I've [replied in StackOverflow](https:\/\/stackoverflow.com\/a\/62210156\/938236) with a longer explanation from my understanding.\r\n\r\nEdit: I unhided my previous comment since it seems it might be relevant, this `\"exports\"` seems to be popular, very likely [from this article on hybrid packages](https:\/\/2ality.com\/2019\/10\/hybrid-npm-packages.html).","`exports` is tracked in #9771","@franciscop ok problem solved - it turns out there is a conflict in packages - I had `serverless-bundle` installed which causes the `ES Modules are only supported if your test environment has the `getVmContext` function` error. I am not sure why - I would assume installing it would not cause a running conflict w Jest but evidently it does. ","@franciscop I think the reason why `pkg.exports` related issues start surfacing now is because that feature was unflagged in Node.js `14.x` and some package maintainers (like me for `uuid`) started adding `pkg.exports` fields. So while you needed a commandline flag to activate that feature in Node.js `12.x` you get that behavior by default now.\r\n\r\nIt will take a while for the whole ecosystem to adapt, so thanks for reporting issues around that topic!","For those posting about `exports`, in case it has been lost in the long thread of this issue, my closed issue about it (https:\/\/github.com\/facebook\/jest\/issues\/9565) has an example of the `moduleNameMapper` workaround in it.","The `globalSetup` problem reported in May is likely still there (Jest 26.1.0)? Getting the same errors as in the example repo  @aledalgrande provides:\r\n\r\n```\r\n$ git clone git@github.com:aledalgrande\/jest-example.git\r\n$ cd jest-example\r\n$ npm test\r\n\r\n> @ test \/Users\/asko\/Temp\/jest-example\r\n> node --experimental-vm-modules node_modules\/jest\/bin\/jest.js --config=.\/jest.config.js\r\n\r\nError [ERR_REQUIRE_ESM]: Must use import to load ES Module: \/Users\/asko\/Temp\/jest-example\/tests\/setup.js\r\nrequire() of ES modules is not supported.\r\nrequire() of \/Users\/asko\/Temp\/jest-example\/tests\/setup.js from \/Users\/asko\/Temp\/jest-example\/node_modules\/@jest\/transform\/build\/ScriptTransformer.js \r\n```\r\n\r\nNo rush. Checked `CHANGELOG` and it didn't mention a fix to globalSetup\/globalTeardown with ES6.\r\n\r\nNode.js 14.4.0, Jest 26.1.0\r\n\r\n---\r\n\r\nUpdate (13-Aug-20): \r\n\r\nStill not possible, Node.js 14.7.0, Jest 26.4.0","Side opinion but should this issue be a pinned issue since it\u2019s the focus for jest at the moment ?","Any thoughts on what needs to be done to consume test reporters written in ES modules?...\r\nwith the latest jest version, i am getting error which essentialy says testScheduler expects custom reporter in commonjs format.\r\n<details>\r\n  <summary>to see error<\/summary>\r\n  <pre>\r\n~\/projects\/esw-ts\/lib\/dist\/test\/testReporter.js:1\r\nimport os from 'os';\r\n^^^^^^\r\n\r\nSyntaxError: Cannot use import statement outside a module\r\n    at wrapSafe (internal\/modules\/cjs\/loader.js:1116:16)\r\n    at Module._compile (internal\/modules\/cjs\/loader.js:1164:27)\r\n    at Object.Module._extensions..js (internal\/modules\/cjs\/loader.js:1220:10)\r\n    at Module.load (internal\/modules\/cjs\/loader.js:1049:32)\r\n    at Function.Module._load (internal\/modules\/cjs\/loader.js:937:14)\r\n    at Module.require (internal\/modules\/cjs\/loader.js:1089:19)\r\n    at require (internal\/modules\/cjs\/helpers.js:73:18)\r\n    at \/Users\/manish.gowardipe\/Desktop\/projects\/esw-ts\/lib\/node_modules\/@jest\/core\/build\/TestScheduler.js:418:65\r\n    at Array.forEach (<anonymous>)\r\n    at TestScheduler._addCustomReporters (\/Users\/manish.gowardipe\/Desktop\/projects\/esw-ts\/lib\/node_modules\/@jest\/core\/build\/TestScheduler.js:411:15)\r\n<\/pre>\r\n<\/details>\r\n","Hi, I want to test Native support for ES Modules in my little project, but I'm new to NodeJS and I got lost in this Issue, I would love some guidance please.\r\n\r\n- `node --version`: v14.5.0\r\n- `yarn jest --version`: 26.1.0\r\n- I'm trying to test [this little project](https:\/\/github.com\/pepetorres1998\/markov-chain-sentence-generator), is very simple.\r\n- I have my files like this:\r\n\r\npackage.json\r\n\r\n```json\r\n{\r\n\"jest\": {\r\n    \"transform\": {},\r\n    \"testEnvironment\": \"jest-environment-node\"\r\n  }\r\n}\r\n```\r\nmarkov.test.js\r\n```js\r\nconst fs = require(\"fs\");\r\nconst Markov = require(\".\/markov.mjs\");\r\n\/\/ import fs from \"fs\";\r\n\/\/ import Markov from \".\/markov.mjs\";\r\n\r\nconst file = fs.readFileSync(\"text.txt\", \"utf8\");\r\nconst markov = new Markov(file.toString());\r\n\r\ntest(\"Generates sentence with especified words\", () => {\r\n  expect(markov.makeSentence(8).length).toBe(8);\r\n});\r\n```\r\n\r\n- I run `yarn jest .` and it gives me this error:\r\n<img width=\"573\" alt=\"imagen\" src=\"https:\/\/user-images.githubusercontent.com\/36722374\/86854193-95822200-c07d-11ea-87a9-8c073d7c5c12.png\">\r\n\r\n- I tried with `node node_modules\/jest\/bin\/jest.js .` and it gives me the same error.","@pepetorres1998 This thread is about running Jest with native esm modules which involves running things with certain flags\/options - see the [comment](https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-616232029) above for what to do (and set  \"type\": \"module\" in package.json). Honestly though at this point it's not quite ready for prime time so if you are needing your project to work I might stick with Babel. There are a number of unchecked issues that are real show stoppers. I gleefully tried to switch a couple of weeks ago and came back crying to Babel.","Is anyone else getting a `ReferenceError: jest is not defined` when trying to do things like `jest.setTimeout(...)` in a test file with this setup? Trying to figure out if this is related to es module environment, node version, jest version, or some combination of those things. (Currently using node v14.5.0, jest 26.1.0, environment jest-environment-node)\r\n\r\n**EDIT**\r\nI now see the unchecked checkbox in the issue description for the jest 'global' property. \ud83d\ude43 ","@bdentino I think you can try to import it explicitly `import {jest} from '@jest\/globals';`","> 25.4.0 has been released with the first pieces of support. In addition to #9772 mentioned above, I've also included #9842. In _theory_ mixing CJS and ESM should work correctly now (\ud83e\udd1e).\r\n> \r\n> The one main missing feature is supporting the `jest` object. I haven't decided if we should stick it to `import.meta` or require people to import it through `import {jest} from '@jest\/globals'`. Feedback appreciated!\r\n> \r\n> I haven't written docs for this yet, but to activate it you need to do 3 things\r\n> \r\n> 1. make sure you don't run transform away `import` statements (set `transform: {}` in config or otherwise ensure `babel` doesn't transform the file to CJS, such as avoiding the `modules` option to preset-env)\r\n> 2. Run `node@^12.16.0 || >=13.2.0` with `--experimental-vm-modules` flag\r\n> 3. Run your test with `jest-environment-node` or `jest-environment-jsdom-sixteen`\r\n> \r\n> Please try it out and provide feedback! If reporting bugs, it'd be wonderful if you can also include how running the same code (minus any test specific code) runs in Node. I've read https:\/\/nodejs.org\/api\/esm.html _a lot_ over the last few weeks, but I've probably missed something.\r\n\r\n@SimenB \r\nThis thread became enormous, and I think those who want to start with jest \/ use ES modules - will have difficulties finding and understanding the basic guidelines to start doing so.\r\nIs there a formal explanation in the docs about adding jest to an ES-modules project (or some 'quick start')?\r\n\r\n\r\n","@aldeed Regarding your problem with mocking modules from the same project, did you found a fix? I'm having the exact same problem\r\n\r\n(Btw, we also use reactioncommerce, so cheers to that haha)","@guilhermetelles no, and it's tracked in https:\/\/github.com\/facebook\/jest\/issues\/10025 now.","I'm using Jest 26.1.0, `node` version 14.6.0 with `--experimental-vm-modules`, but I'm still seeing `ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING` when using `import()` inside of CommonJS. Should I try to come up with a minimal repro and open a new issue?\r\n\r\nAs an aside, is there an easy way to `yarn link` a copy of `jest` packages into a project now that Jest uses yarn berry? I wanted to try the latest `master` just in case this was implemented by not yet released. I was trying to do something like `path\/to\/facebook\/jest\/.yarn\/releases\/yarn-sources.cjs link --all path\/to\/jest`, but it would fail. Manually running something like `cd node_modules; for p in jest*; do if [[ -d path\/to\/jest\/packages\/$p ]]; then rm -rf $p; ln -s path\/to\/jest\/packages\/$p; fi; done` was not working either, I'm not sure why.","@vvanpo `import()` in CJS was reverted in Node, you can follow https:\/\/github.com\/nodejs\/node\/issues\/31860\r\n\r\nAs for running local, I usually just uninstall `jest` from the project I wanna test and do `..\/jest\/jest`. Potentially `nose ..\/jest\/packages\/jest\/bin\/jest.js`. Just make sure to run `yarn` and `yarn build:js` first. If these instructions don't work (I'm writing from memory on a phone on a plane) please open up an issue (or PR) so we can properly write this into the `CONTRIBUTING.md` file","Do you plan to support cyclic imports?\r\n\r\nIf I have a dummy test file that only imports one of two files that only import each other, I get `RangeError: Maximum call stack size exceeded`. If I remove one of the imports, the test passes. [Repo that reproduces the issue](https:\/\/github.com\/mik-jozef\/jest-cyclic-imports).","Hey! I set this up in an empty node project and it worked really well, however in our production setting, I get the following error message when I'm trying to run tests:\r\n\r\n`ES Modules are only supported if your test environment has the 'getVmContext' function`\r\n\r\nI saw someone else having the some problem in an earlier reply (by @cyberwombat ), but the package they found to be the culprit is not present in our `package.json` file. How to deduce the package (or setting) that causes the problem? I have tried systematically removing every jest setting that is not necessary to make this work, but I had no success.\r\n\r\n**UPDATE**: I have managed to make progress by making a slight change in `jest-runtime`. I stopped the debugger at the line which tries to access the VM context and while the function really does not exist, `this.context` (which it should return) does, so I changed that line to access the property directly. I know this is probably not ideal, but maybe @SimenB this could give you an idea of what is going wrong?\r\n\r\nThank you in advance for any help",">Do you plan to support cyclic imports?\r\n\r\n\r\nDefinitely! Could you open up a separate issue?\r\n\r\n---\r\n\r\n@zsombro seems like you're running some old version of the test environment. If you run `jest --show-config`, what is displayed by `testEnvironment`?","> seems like you're running some old version of the test environment. If you run `jest --show-config`, what is displayed by `testEnvironment`?\r\n\r\n@SimenB it says the following:\r\n```\r\n\"testEnvironment\": \"\/Users\/zberki\/git\/project-name\/node_modules\/jest-environment-node\/build\/index.js\",\r\n\"testEnvironmentOptions\": {},\r\n```\r\nI just set it to `jest-environment-node` based on your instructions\r\n\r\nBefore I started this process, I upgraded jest using `yarn add jest@latest`. Do I have to upgrade the environment separately?\r\n\r\n**UPDATE:** It turns out I had to. I deleted `node_modules` and `yarn.lock` to do a clean install and it still didn't work. However, if I manually add it by using `yarn add -D jest-environment-node` it seems to work. Is there a better way to manage this? I did a minimalistic test project before doing this on our codebase and I didn't have to do this","`yarn list jest-environemnt-node` (or `npm list jest-environemnt-node`) will probably list multiple, is my guess","```\r\n\u251c\u2500 jest-config@24.9.0\r\n\u2502  \u2514\u2500 jest-environment-node@24.9.0\r\n\u2514\u2500 jest-environment-node@26.2.0\r\n```\r\n\r\nthe `26.2.0` version is probably what I installed manually (at least based on `package.json`, which means `jest-config` has installed a version which is apparently outdated?","You have something else pulling in an older version of `jest-config` (`react-scripts` perhaps (part of `create-react-app`)?). This issue is not the place to discuss it, tho \ud83d\ude42 ","Not being able to use ES modules in my `globalSetup` is beginning to hurt.\r\n\r\nTwo points: \r\n- should this be mentioned as a checkbox in the beginning of this issue (so it gets tracked)?\r\n- if there is an alpha\/beta I could try, willing to do so","I:\r\n\r\n* Ensured I'm running newest Jest version (26.4.0)\r\n* Added jest-environment-node to my project\r\n* Ensured it's not duplicated by inspecting the lockfile\r\n* Added `\"testEnvironment\": \"jest-environment-node\",` in jest.config.json\r\n* Added `import { jest } from '@jest\/globals';` wherever jest was used\r\n* Ran test command setting `--experimental-vm-modules` by running them with `NODE_OPTIONS='--experimental-vm-modules' yarn jest`\r\n\r\nAnd it crashes on the following code:\r\n\r\n```js\r\njest.mock('..\/..\/some\/other\/path', () => ({\r\n  someOtherMethod: jest.fn().mockImplementation(\u2026),\r\n}));\r\n```\r\n\r\nwith the following error (shortened - note \"Allowed objects\"!):\r\n\r\n```\r\nReferenceError: src\/foo\/bar.spec.js: The module factory of `jest.mock()` is not allowed to reference any out-of-scope variables.\r\nInvalid variable access: jest\r\nAllowed objects: Array, \u2026, jest, \u2026, unescape.\r\nNote: This is a precaution to guard against uninitialized mock variables. If it is ensured that the mock is required lazily, variable names prefixed with `mock` (case insensitive) are permitted.\r\n```\r\n\r\nI can't use Babel, because it improperly parses imports I fixed to run on Node 14 without Babel:\r\n\r\n```diff\r\n-import { map } from 'lodash';\r\n+import lodash from 'lodash';\r\n+const { map } = lodash;\r\n```\r\n\r\nWhich unfortunately gets [improperly parsed by `@babel\/preset-env`](https:\/\/babeljs.io\/repl#?browsers=Node%2014&code_lz=JYWwDg9gTgLgBAGwgEwIYGcAWcBmUIhwDkSaWRA3AFBUDGEAduvAN5wiphwC-cAvIhQZM1IA), resulting in` TypeError: Cannot destructure property 'map' of '_lodash.default' as it is undefined.`.\r\n\r\nCan someone please help me work around this issue?\r\n\r\n**Edit:** It seems like you _can_ use Jest+Babel on native ES modules-compatible code using CommonJS imports by doing this absolutely disgusting fix:\r\n\r\n```js\r\njest.mock('common-js-module', () => ({\r\n  __esModule: false,\r\n  ...jest.requireActual('common-js-module'),\r\n}));\r\n```\r\n\r\nThis way, \r\n\r\n```js\r\nimport lodash from 'lodash';\r\nconst { map } = lodash;\r\n```\r\n\r\nis perfectly consumed by Node 14, and the code resulting from running Jest+Babel,\r\n\r\n```js\r\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst {\r\n  map\r\n} = _lodash.default;\r\n```\r\n\r\nalso runs.","we've successfully converted all of our jest tests to use and import our ES6 code, but we got stuck on a few packages: namely `puppeteer` and `uuid`\r\n\r\nThe app only works if we import them into an object (like `import uuid from 'uuid'`), but the tests will not run this way. However, if we replace this import with the deconstruction syntax (such as `import { v4 } from 'uuid'`, then it's the other way around: the test works, but the app throws an exception.\r\n\r\noriginally, we followed the guide and turned off every transformation, but we also tried creating a yarn workspace where we installed babel with a minimal node configuration, but this did not solve (or worsen) this specific problem","> However, if we replace this import with the deconstruction syntax (such as import { v4 } from 'uuid', then it's the other way around: the test works, but the app throws an exception.\r\n\r\nThat sounds like your app is compiled to CommonJS and isn't using modules in practice. From \"real\" ESM `import uuid from 'uuid'` shouldn't work because [`uuid` has no default export](https:\/\/github.com\/uuidjs\/uuid\/blob\/7f1af044be4a21c5cc41e410b3bb86048be14093\/src\/index.js) and [exposes an ESM build for node](https:\/\/github.com\/uuidjs\/uuid\/blob\/7f1af044be4a21c5cc41e410b3bb86048be14093\/package.json#L22-L27).","Hey @SimenB, do you think some preliminary documentation on this would be a good idea?","@grantcarthew definitely! I had hoped I'd be able to spend more time on this and stabilize it for Jest 27, but I doubt I'll be able to do that. But writing up a doc page about what's there now (and that it's experimental) sounds like a good idea","@SimenB I don't know what is the current status of the issue and if Jest should already work with my case or not but maybe it can help you somehow.\r\n\r\nI'm trying to load a esm-only library (their extension is cjs but the type is module and node seems to be ok with that) but Jest fails to load it properly with error:\r\n\r\n```txt\r\n    C:\\dev\\codemirror-next-repro-cra\\test-in-jest-esm\\node_modules\\style-mod\\dist\\style-mod.cjs:15\r\n    export var StyleModule = function StyleModule(spec, options) {\r\n```\r\n\r\nHere the issue I originally opened https:\/\/github.com\/codemirror\/codemirror.next\/issues\/310. And a repro for Jest + ESM failing with node 14.13.1 https:\/\/github.com\/dubzzz\/codemirror-next-repro-cra\/tree\/main\/test-in-jest-esm\r\n","@dubzzz you can't have ESM in a `cjs` file. Node fails as well\r\n\r\n```sh-session\r\n$ node node_modules\/style-mod\/dist\/style-mod.cjs\r\n(node:48829) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n\/Users\/simen\/repos\/codemirror-next-repro-cra\/test-in-jest-esm\/node_modules\/style-mod\/dist\/style-mod.cjs:15\r\nexport var StyleModule = function StyleModule(spec, options) {\r\n^^^^^^\r\n\r\nSyntaxError: Unexpected token 'export'\r\n    at wrapSafe (internal\/modules\/cjs\/loader.js:1172:16)\r\n    at Module._compile (internal\/modules\/cjs\/loader.js:1220:27)\r\n    at Object.Module._extensions..js (internal\/modules\/cjs\/loader.js:1277:10)\r\n    at Module.load (internal\/modules\/cjs\/loader.js:1105:32)\r\n    at Function.Module._load (internal\/modules\/cjs\/loader.js:967:14)\r\n    at Function.executeUserEntryPoint [as runMain] (internal\/modules\/run_main.js:60:12)\r\n    at internal\/main\/run_main_module.js:17:47\r\n```","Oups so sorry, I tried too quickly on node side. @nicolo-ribaudo already notified the author of the lib about this problem.\r\nReally thanks a lot for your quick answer.","I opened up a PR for some (pretty much stub) docs here: #10611. I didn't bother enumerating missing features\/bugs as I think that'll be hard to keep in sync with reality, and looking at github issues is a better approach as they are (hopefully\u2026) up to date.","@Pomax as a new issue, please \ud83d\ude42 ","I just opened up #10620 which adds support for `import()` from CJS. Requested a few times are like https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-626054595","Hello. It's quite hard for me to quickly embrace the whole story behind ESM in node\/jest, so, probably, I'm asking something obvious or already answered. Do I understand it correctly that the following case is not supported yet? Or, I hope, I'm doing something not the correct way? I experience it like `import x from 'x'` works, but `import { sub } from 'x'` destructuring does not.\r\n\r\npackage.json:\r\n```\r\n{\r\n  \"name\": \"jest-uuid\",\r\n  \"version\": \"1.0.0\",\r\n  \"type\": \"module\",\r\n  \"scripts\": {\r\n    \"test\": \"node --experimental-vm-modules node_modules\/.bin\/jest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"jest\": \"26.5.2\"\r\n  },\r\n  \"dependencies\": {\r\n    \"uuid\": \"8.3.1\"\r\n  }\r\n}\r\n```\r\nf.spec.js\r\n```\r\nimport { v4 } from 'uuid';\r\ntest('', () => {});\r\n```\r\nnpm test\r\n```\r\n> npm test\r\n\r\n> jest-uuid@1.0.0 test \/Users\/igoro\/p\/tmp\/jest-uuid\r\n> node --experimental-vm-modules node_modules\/.bin\/jest\r\n\r\n FAIL  .\/f.spec.js\r\n  \u25cf Test suite failed to run\r\n\r\n    SyntaxError: The requested module 'uuid' does not provide an export named 'v4'\r\n\r\n      at jasmine2 (node_modules\/jest-jasmine2\/build\/index.js:228:5)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.879 s\r\nRan all test suites.\r\n(node:94492) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\nnpm ERR! Test failed.  See above for more details.\r\n\r\n```","You're waiting for #9771. Before that Jest doesn't know it's safe to load `uuid` as ESM (or rather, which file to load at which point it'd know it is ESM)","Will this be following Node's own convention, where CJS can only be loaded as namespace, or will this \"improve\" on that by allowing syntax that doesn't actually work in Node itself? (e.g. Node does not allow `import { readdirSync } from \"fs-extra\"` because that's a CJS package, but it does allow `import fs from \"fs-extra\";` which can then be unpacked using `const { readdirSync } = fs`). ","> (e.g. Node does not allow import { spawn } from \"child_process\" because that's a CJS package, but it does allow import child_process from \"child_process\"; which can then be unpacked using const { spawn } = child_process;).\r\n\r\nThis is an unfortunate example because node considers \"child_process\" to be a \"builtin\" (and not CJS) module, so named exports do work. The latest nodejs also uses a heuristic to make many named exports work for CJS modules. That may be the hardest part to emulate. ","example updated to use `fs-extra` instead. But if named export are on Node's roadmap to land either this or next major, then Jest preempting that makes sense.","That should already be implemented - Node core modules exposes named exports, \"normal\" CJS does not.\r\n\r\n>The latest nodejs also uses a heuristic to make many named exports work for CJS modules. That may be the hardest part to emulate.\r\n\r\nDo you have a link to the PR implementing it? We should try to emulate it at least \ud83d\ude42","The PR is here: https:\/\/github.com\/nodejs\/node\/pull\/35249\r\n\r\nThe heuristic behind it is published as `cjs-module-lexer` (https:\/\/github.com\/guybedford\/cjs-module-lexer) but @guybedford might know more about any potential deviations.","Just had a look at this and it appears like `fs-extra` is using an exports pattern like:\r\n\r\n```js\r\nmodule.exports = {\r\n  \/\/ Export promiseified graceful-fs:\r\n  ...require('.\/fs'),\r\n  \/\/ Export extra methods:\r\n  ...require('.\/copy-sync'),\r\n  ...require('.\/copy'),\r\n  ...require('.\/empty'),\r\n  ...require('.\/ensure'),\r\n  ...require('.\/json'),\r\n  ...require('.\/mkdirs'),\r\n  ...require('.\/move-sync'),\r\n  ...require('.\/move'),\r\n  ...require('.\/output'),\r\n  ...require('.\/path-exists'),\r\n  ...require('.\/remove')\r\n}\r\n```\r\n\r\nThis is not currently a reexports analysis case we detect, but it might be possible to add to cjs-module-lexer if this would be a useful case to handle named exports detection for.","Thanks @jkrems & @guybedford! I've opened up a PR now using that module: #10673","The exact fs-extra support described in https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-713204282 is now implemented in cjs-module-lexer@0.4.3, upstream tracking at https:\/\/github.com\/nodejs\/node\/pull\/35745.\r\n\r\n_Update: testing out this build, it correctly detects all the fs-extra functions, but unfortunately it doesn't detect the Node.js native functions as they are not statically analyzable due to being populated by a for loop._","> feat: support named exports from CJS as named ESM imports #10673\r\n\r\nI thought native ESM only supports importing a CommonJS module's `exports` as `default`?","@trusktr not anymore: https:\/\/github.com\/nodejs\/node\/pull\/35249","> Hello. It's quite hard for me to quickly embrace the whole story behind ESM in node\/jest, so, probably, I'm asking something obvious or already answered. Do I understand it correctly that the following case is not supported yet? Or, I hope, I'm doing something not the correct way? I experience it like `import x from 'x'` works, but `import { sub } from 'x'` destructuring does not.\r\n> \r\n...\r\n> import { v4 } from 'uuid';\r\n\r\nESM modules do not support destructuring imports, even though the syntax looks like it does.  For this to work, 'export v4' is needed.  'export default' will not match up.\r\n\r\nhttps:\/\/kentcdodds.com\/blog\/misunderstanding-es6-modules-upgrading-babel-tears-and-a-solution\r\n","@sdwlig `uuid` provides named exports and does not have default one. It should work but loading esm from packages with \"exports\" field is not supported by jest yet. Commonjs is loaded instead which is only available via default export.\r\nhttps:\/\/github.com\/uuidjs\/uuid\/blob\/master\/src\/index.js","Could we add package self-reference support (#10883) to this?","That indicates an infinite import loop.\u00a0 While circular imports are sometimes done in Javascript, they are a bad idea.\u00a0 Seems like \nJest can't handle them.\n\nStephen\n\nOn 12\/5\/20 7:52 AM, Damiano wrote:\n>\n> FYI, adding:\n>\n> import  {  asyncStorage  }  from  '..\/index.js';\n>\n> Explodes with:\n>\n> Exceptionin  PromiseRejectCallback:\n> internal\/vm\/module.js:341\n>      };\n>      ^\n>\n> RangeError: Maximum call stack size exceeded\n> Exceptionin  PromiseRejectCallback:\n> internal\/vm\/module.js:192\n>      await this[kLink](linker);\n>                       ^\n>\n> RangeError: Maximum call stack size exceeded\n> Exceptionin  PromiseRejectCallback:\n> internal\/vm\/module.js:328\n>          return  module[kWrap];\n>\n>\n> RangeError: Maximum call stack size exceeded\n> Exceptionin  PromiseRejectCallback:\n> \/Users\/damians\/Desktop\/webapp-be\/node_modules\/jest-runtime\/build\/index.js:586\n>      return  module;\n>\n>\n> RangeError: Maximum call stack size exceeded\n> Exceptionin  PromiseRejectCallback:\n> internal\/vm\/module.js:315\n>          const module = await linker(identifier, this);\n>                               ^\n>\n> RangeError: Maximum call stack size exceeded\n> Exceptionin  PromiseRejectCallback:\n> internal\/vm\/module.js:328\n>          return  module[kWrap];\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub <https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-739313294>, or \n> unsubscribe <https:\/\/github.com\/notifications\/unsubscribe-auth\/AAA3XLS4S34YSGW2UYLMJJLSTJJNNANCNFSM4KIZHGLQ>.\n>\n\n-- \n\t\n\t\n*Stephen D. Williams*\nFounder: VolksDroid, Blue Scholar Foundation\n650-450-8649 <tel:650-450-8649> | fax:703-995-0407 <fax:> | sdw@lg.net <mailto:sdw@lig.net> | https:\/\/VolksDroid.org \n<https:\/\/VolksDroid.org> | https:\/\/BlueScholar.org <https:\/\/BlueScholar.org> | https:\/\/sdw.st\/in\n\n","Status update:\r\n\r\n- `jest@next` ships with support for `extensionsToTreatAsEsm` allowing other extensions (like `.ts`) to use ESM. Docs: https:\/\/jestjs.io\/docs\/en\/next\/configuration#extensionstotreatasesm-arraystring\r\n- I've opened #10976 with support for mocking.\r\n\r\nOnce the latter lands I think the main missing feature is package exports","> Status update:\r\n> \r\n> * `jest@next` ships with support for `extensionsToTreatAsEsm` allowing other extensions (like `.ts`) to use ESM. Docs: https:\/\/jestjs.io\/docs\/en\/next\/configuration#extensionstotreatasesm-arraystring\r\n> * I've opened #10976 with support for mocking.\r\n> \r\n> Once the latter lands I think the main missing feature is package exports\r\n\r\n`ts-jest@next` already finished adopting for `isolatedModules: true`. Now working on adoption for `isolatedModules: false`","`ts-jest` and `jest-preset-angular` finished ESM support adoption in the newest version under `next` tag.","I've been [trying to get Jest ESM working on an angular project](https:\/\/github.com\/thymikee\/jest-preset-angular\/issues\/751), and am running into 2 issues:\r\n\r\n* UMD files are loaded for all dependencies - looks like I need #9771 for this to work correctly, but as a workaround I could use a custom resolver\r\n* In cases where non UMD files are used (easiest way is to configure `moduleNameMapper` to load ES2015 files), they are not identified as ESM files, and are loaded using `loadCjsAsEsm()`. Which seems to work, but doesn't seem correct. None of the angular packages or key dependencies (rxjs, zone.js) have \"type\": \"module\" in their `package.json`.\r\n\r\nRight now there is no way to customize the \"is this module an ESM module\" decision, and the current logic won't work in a lot of cases. It seems to me that it would be ideal for a resolver to also be able to specify the module type (since it's already looking at the files, and the name -> file and file -> module type functionality is coupled).\r\n\r\nCould you give resolvers the ability to specify the module format of the returned file? Lmk if you'd like a separate issue.","I tried using Jest ESM yesterday, with no luck. I could not get dependencies with `exports` fields to be correctly imported (as if Jest would not see the mapped files or something).\r\n\r\nI've been using Webpack 5, which strictly enforces Node ESM standard, and my app works, plus native Node ESM understands the import statements that otherwise fail in Jest. Only when I try to run Jest with ESM support (as per the ES Module doc page), do I experience a failure of module resolution regardless of which config permutations I try (or `import` causes a syntax error).\r\n\r\nWhat I ended up doing is avoiding import specifiers anywhere in my dependency graph that rely on package.json `exports` mappings, and instead use direct file imports while setting `transformIgnorePatterns: [],` to get everything including node_modules compiled to CommonJS (which thankfully worked).\r\n\r\nI had to change imports like\r\n\r\n```js\r\nimport {...} from 'solid-js\/html' \/\/ relies on package.json exports mapping\r\n```\r\n\r\nto\r\n\r\n```js\r\nimport {...} from 'solid-js\/html\/path\/to\/the\/file.js'\r\n```\r\n\r\nThis works in Jest by default, because now everything (even ES Module files in node_modules) will be converted to CommonJS.\r\n\r\nTo ensure things would still work in native Node ESM and Webpack, we needed to update `solid-js` so it exposes all its files in its package.json `exports` field, besides having only the top-level aliases, so that the direct-file import approach would work in both non-ESM environments like Jest, and in NodeESM\/Webpack.\r\n\r\nI don't have a reproduction to show at the moment, but the TLDR is that ESM in Jest doesn't seem to operate the same way as Node's native ESM does (or I could not find out how to make it do so). If Jest is relying on native ESM, then I don't see what the issue would be, but I could not get any permutation of configuration working except the above (coerce everything into CommonJS).\r\n\r\nI verified that my ESM setup works in both native Node (without Jest) and Webpack. Just no luck in Jest.\r\n\r\nWish I could be more helpful, but at the very least I hope this helps encourage the move towards making ESM the strict default in a breaking Jest release, like Webpack did with v5.\r\n\r\n---\r\n\r\n### Oh, thy ESM growing pains!\r\n\r\nCan't wait for the JS ecosystem to be mostly on ESM.","As mentioned in the OP, `exports` support has not landed, you can track #9771 (which is waiting for upstream support in the `resolve` package).\r\n\r\nYou can _probably_ implement your own `resolver` in Jest, but that's unlikely to be trivial","@trusktr Please see my comment https:\/\/github.com\/facebook\/jest\/issues\/9771#issuecomment-776666742 - may work for you.","Is there a way to resolve `import \".\/foo.js\";` as `.\/foo.ts`, reinterpreting the file extension? I want this because\r\n\r\n```javascript\r\nimport \".\/foo\";\r\n```\r\n\r\ndoesn't work with Node.js native ESM and\r\n\r\n```typescript\r\nimport \".\/foo.ts\";\r\n```\r\n\r\ndoesn't work with TypeScript (tsc).\r\n\r\nAt least tsc + Node.js and ts-node work well with `import \".\/foo.js\"`.","Have you tried `moduleNameMapper`?  https:\/\/jestjs.io\/docs\/en\/configuration#modulenamemapper-objectstring-string--arraystring","@SimenB the following config worked. Thanks!\r\n\r\n```javascript\r\n  moduleNameMapper: {\r\n    \"^(.*)\\\\.js$\": \"$1\",\r\n  },\r\n```","ESM stopped working in Jest starting from Node.js 15.9.0 https:\/\/github.com\/facebook\/jest\/issues\/11093\r\n\r\nDowngrade to 15.8 if you have an issue.","As an update, there is now a tracking issue for API stabilization in the Node repo: https:\/\/github.com\/nodejs\/node\/issues\/37648\r\n\r\nIt is blocked on some changes in V8, so it's not right around the corner unfortunately ","Hello, thank you for this work.\r\nI just found that `node:`-prefixed modules ([explainer](https:\/\/nodejs.org\/dist\/latest-v14.x\/docs\/api\/esm.html#esm_node_imports)) cannot be imported for now.\r\nAlbeit there is a workaround:\r\n\r\n```js\r\n  moduleNameMapper: {\r\n    \"^node:(.*)$\": \"$1\"\r\n  }\r\n```",":wave: I tried to test `next` and it worked for small test out of the box, amazing!\r\n\r\nUnfortunately when I tried to add some kind of snapshot testing with `@material-ui\/core`, I came across a problem with ESM definitions inside package.\r\n\r\nBasically there is `esm` folder inside package and `module` field is specified in package.json correctly, so I can benefit from it with tree-shaking. (from what I get Webpack automatically detects package.json value and resolves `import { Button } from '@material-ui\/core'` to `esm` subfolder).\r\n\r\nBut if I want to test some component in jest (same Button), obviously it will not work like this.\r\n\r\nI made some research and found that \r\n\r\n- there is no `type=\"module\"` in package.json (can it be added if library wants to deliver both cjs and esm?)\r\n- jest doesn't resolve esm correctly (no resolve from esm subfolder even if `\"module\": \".\/esm\/index.js\"` is specified)\r\n\r\nAny advice on it: should it be some change on library side to enable esm to work with jest or should it maybe be an `exports` config like described in node docs?\r\n\r\nI carefully tried to read the thread but didn't find an answer. \/cc @SimenB ","`module` field is non-standard and we don't support it. `exports` is what should be used, but Jest does not support it ([yet](https:\/\/github.com\/facebook\/jest\/issues\/9771)).\r\n\r\nYou can use a custom resolver to add support for `module` if you want. There an example in [the docs](https:\/\/jestjs.io\/docs\/configuration#resolver-string).\r\n\r\n> * there is no `type=\"module\"` in package.json (can it be added if library wants to deliver both cjs and esm?)\r\n\r\n`type=\"module\"` affects the type of `.js` files, you can use `.mjs` or `.cjs` to be explicit per file","> type=\"module\" affects the type of .js files, you can use .mjs or .cjs to be explicit per file\r\n\r\nTrue, but if library (material-ui) is delivered without `.mjs` or `.cjs` extensions, we can't force authors to do it I presume.\r\n\r\nCan `moduleNameMapper` work in this case?","We don't really support packages not following Node's rules on how to \"activate\" ESM mode. You'll probably need to wait for `exports` support or patch `material-ui`.\r\n\r\n`moduleNameMapper` is for `this specifier should be mapped to this one` and only affects resolution of files, not their mode","@SimenB re: https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-636055996 (`globalSetup`), is it tracked as a separate issue? I don't see it as a checkbox here. I am on latest stable Jest and still getting the same error. Thanks!","@aledalgrande: #11167","@SimenB I just got a working Babel ESM build, which means I can try stress-testing Jest's native ESM implementation! :stuck_out_tongue: \r\n\r\nCurrently Jest is failing in an infinite loop somewhere in the modules linker, I can open an issue in the next few days. If you are interested, you can check https:\/\/github.com\/nicolo-ribaudo\/babel\/tree\/native-esm-jest-range-error and run\r\n```bash\r\nmake bootstrap # If this fails at babel-standalone, ignore it\r\nNODE_OPTIONS=\"--experimental-vm-modules\" yarn jest babel-core\r\n```\r\n\r\n<details>\r\n<summary>Error example<\/summary>\r\n\r\n```\r\n\r\nRangeError: Maximum call stack size exceeded\r\nException in PromiseRejectCallback:\r\ninternal\/vm\/module.js:196\r\n    await this[kLink](linker);\r\n                     ^\r\n\r\nRangeError: Maximum call stack size exceeded\r\nException in PromiseRejectCallback:\r\ninternal\/vm\/module.js:337\r\n          await PromiseAll(promises);\r\n                ^\r\n\r\nRangeError: Maximum call stack size exceeded\r\nException in PromiseRejectCallback:\r\n\/home\/nicolo\/Documenti\/dev\/babel\/babel\/node_modules\/jest-runtime\/build\/index.js:586\r\n    return module;\r\n                  \r\n\r\nRangeError: Maximum call stack size exceeded\r\nException in PromiseRejectCallback:\r\ninternal\/vm\/module.js:319\r\n        const module = await linker(identifier, this);\r\n                             ^\r\n\r\nRangeError: Maximum call stack size exceeded\r\nException in PromiseRejectCallback:\r\ninternal\/vm\/module.js:332\r\n        return module[kWrap];\r\n```\r\n\r\n<\/details>","@nicolo-ribaudo that's both awesome news and terrifying at the same time \ud83d\ude00 \r\n\r\nThankfully, I can report that the particular bug you hit is fixed in Jest 27. I updated to `27.0.0-next.6` and the error went away (or rather, replaced by other errors \ud83d\ude48).\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/113265525-88285a00-92d4-11eb-90a5-07d69399a358.png)\r\n\r\nThis might of course expose some _other_ issue in Jest's implementation, I haven't checked.\r\n\r\n(you need to do `import {jest} from '@jest\/globals'` for the `jest` object)","Thanks! I'll try that version and report back \ud83d\ude04","I've hit this strange error when trying to use native ESM with Jest:\r\n\r\n```\r\n$ node --experimental-vm-modules node_modules\/.bin\/jest\r\n(node:84738) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n FAIL  src\/__tests__\/index.js\r\n  \u25cf Test suite failed to run\r\n\r\n    ReferenceError: global is not defined\r\n\r\n      at Object.<anonymous> (node_modules\/expect\/build\/index.js:3:14)\r\n      at TestScheduler.scheduleTests (node_modules\/@jest\/core\/build\/TestScheduler.js:337:13)\r\n      at runJest (node_modules\/@jest\/core\/build\/runJest.js:377:19)\r\n      at _run10000 (node_modules\/@jest\/core\/build\/cli\/index.js:406:7)\r\n      at runCLI (node_modules\/@jest\/core\/build\/cli\/index.js:261:3)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        0.516 s\r\nRan all test suites.\r\n```\r\n\r\nReproduction is in this PR: https:\/\/github.com\/kentcdodds\/mdx-bundler\/pull\/20\r\n\r\nI poked around a bit but have no idea why this could be happening. Didn't find anyone else with the same problem either \ud83d\ude05\r\n\r\nOh, and I only got that when I upgraded to `27.0.0-next.7`. The current version of jest I'm on is `26.6.3` and with that I get:\r\n\r\n```\r\n FAIL  src\/__tests__\/index.js\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest encountered an unexpected token\r\n\r\n    This usually means that you are trying to import a file which Jest cannot parse, e.g. it's not plain JavaScript.\r\n\r\n    By default, if Jest sees a Babel config, it will use that to transform your files, ignoring \"node_modules\".\r\n\r\n    Here's what you can do:\r\n     \u2022 If you are trying to use ECMAScript Modules, see https:\/\/jestjs.io\/docs\/en\/ecmascript-modules for how to enable it.\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/en\/configuration.html\r\n\r\n    Details:\r\n\r\n    \/Users\/kentcdodds\/code\/mdx-bundler\/node_modules\/remark-mdx-frontmatter\/node_modules\/js-yaml\/dist\/js-yaml.mjs:3831\r\n    export default jsYaml;\r\n    ^^^^^^\r\n\r\n    SyntaxError: Unexpected token 'export'\r\n\r\n      at Runtime.createScriptFromCode (node_modules\/jest-runtime\/build\/index.js:1350:14)\r\n      at Object.<anonymous> (node_modules\/remark-mdx-frontmatter\/dist\/index.js:6:19)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       0 total\r\nSnapshots:   0 total\r\nTime:        1.691 s\r\nRan all test suites.\r\n```\r\n\r\nI haven't had a chance to dig on that yet.","@kentcdodds I assume you're hitting #10644 (specifically https:\/\/github.com\/facebook\/jest\/pull\/10644#discussion_r507246533). Do you have a custom env or some env extending the JSDOM env you did not update to v27?\r\n\r\nYour error from v26 looks like you're using `require` to load ESM, that will still fail (although with a better error: #11260)","That was it. Thanks! I'll work out my v26 issues as well. Thanks for the tips and all the hard work on this. It's not easy and we all appreciate the effort! \ud83d\udc4d","Thanks @kentcdodds!\r\n\r\nNote that the v26 implementation of ESM is quite buggy (in particular around circular deps, and node v15 surfaced some other bugs), so for ESM usage I recommend using v27 (although that probably has a bunch of bugs as well \ud83d\ude00)","Heads up for fellow adventurous devs: using ESM and enabling `automock` in jest's config leads to bizarre and unexpected behaviour, wherein `import`ed dependencies are not mocked (currently expected\/known), BUT if that dependency is itself CJS and `require`s other dependencies, Jest will try and sometimes fail to mock them properly.\n\nFor instance, importing [sharp](https:\/\/github.com\/lovell\/sharp) with automock enabled will cause Jest (v27\u2026next-7) to incorrectly mock sharp's require of `semver` (causing a bizarre undefined error).","I am not sure if I should report it here or raise a new issue. I am trying to use ESM in TypeScript with jest next. \r\nTest are failing to resolve modules, most likely because of .js extension. \r\nI made minimal reproduction in https:\/\/github.com\/chyzwar\/jest-test-esm","@chyzwar same\/known issue. I looked into this extensively, and as far as I can tell, it's impossible to do this if babel is part of the equation because babel-jest blindly aborts on ESM (in certain circumstances, like `import.meta`). If you're able to disable babel entirely, it can work (but the configuration is extremely convoluted).","@chyzwar yeah, remove the extension from your import. Jest doesn't operate on the \"virtual\" .js file, but the `ts` file directly. You'll also need https:\/\/jestjs.io\/docs\/next\/configuration#extensionstotreatasesm-arraystring.\r\n\r\nFeel free to open up a new issue about resolving the `js` file, we'll probably need it (somehow) for proper interop with other tools (using the `.js` extension is what [`ts-node` says to do](https:\/\/github.com\/TypeStrong\/ts-node\/issues\/1007) even though the file does not exist)\r\n\r\n---\r\n\r\nUsing Babel along with Jest's ESM should be seamless as we provide the correct options to Babel about what we support (i.e. `import` statements etc). If you get syntax errors using `babel-jest`, please open up an issue with a reproduction (using `jest@next`), that is supposed to work.","A quick note, `ts-node` also supports extensionless imports as long as you've enabled the correct node flag [`--experimental-specifier-resolution=node`](https:\/\/nodejs.org\/api\/esm.html#esm_customizing_esm_specifier_resolution_algorithm)  This extensionless resolution behavior is implemented by node, so if you don't enable it, node will throw errors, and we can't stop that.  Even if `ts-node` papered over this wrinkle, pre-compiled code would fail outside of `ts-node`, so this would be counter-productive.\r\n\r\nWhen users do not want to enable this flag, we recommend adding the `.js` extension because otherwise TS's language service will raise an error in their code editor, outside of `ts-node`.  Even if `ts-node` supported .ts extensions, any typechecking outside of ts-node would throw errors, so this would be counter-productive.\r\n\r\ntl;dr; we recommend the options that will keep a project happy external to `ts-node`.","Thanks for chiming in @cspotcode! I think I currently wanna wait to see what `resolve` adds to its ESM API, then figure out how to hook that up. If it's a huge issue for people I recommend writing a babel plugin for Jest which removes the extension or something in the meantime","@SimenB sorry, I don't recall what specifically the issue was except that something babel was explicitly checking for and subsequently throwing on the presence of `import.meta` (or possibly something nested within, such is `import.meta.resolve()`); it threw even if that code is not reached.\n\nRE waiting to see what `resolve` adds to its ESM API, are you talking about NodeJS's `import.meta.resolve()`, the ESMLoader `resolve` hook, or something else entirely? If either of the first two, is there anything in particular you have in mind? (Happy to move that topic elsewhere\u2014we may already have an appropriate discussion going).","> @chyzwar yeah, remove the extension from your import. Jest doesn't operate on the \"virtual\" .js file, but the ts file directly. You'll also need https:\/\/jestjs.io\/docs\/next\/configuration#extensionstotreatasesm-arraystring.\r\n\r\nOnce is added extensionsToTreatAsEsm: [\".ts\"] I get diffrent error: \r\n```\r\n    ReferenceError: exports is not defined\r\n\r\n      1 | import { main } from \"..\/main.js\"\r\n    > 2 |\r\n        | ^\r\n      3 |\r\n      4 | describe('main', () => {\r\n      5 |     it(\"concat a and b\", () => {\r\n\r\n```\r\n\r\nFrom what I understand valid ESM would need to have .js extension unless TypeScript provide compile options, but this was already decided against. \r\n\r\n\r\n\r\n > quick note, ts-node also supports extensionless imports as long as you've enabled the correct node flag --experimental-specifier-resolution=node This extensionless resolution behavior is implemented by node, so if you don't enable it, node will throw errors, and we can't stop that. Even if ts-node papered over this wrinkle, pre-compiled code would fail outside of ts-node, so this would be counter-productive.\r\n\r\nAdding --experimental-specifier-resolution=node is working but all files in project need to be without js extension, otherwise mixed imports leads to another error:\r\n\r\n```\r\nFAIL  src\/__tests__\/main.test.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    Cannot find module '.\/a.js' from 'src\/main.ts'\r\n\r\n    Require stack:\r\n      src\/main.ts\r\n      src\/__tests__\/main.test.ts\r\n\r\n    > 1 | import { a } from \".\/a.js\";\r\n        | ^\r\n      2 | import { b } from \".\/b.js\";\r\n      3 |\r\n      4 |\r\n```\r\n\r\nI think --experimental-specifier-resolution=node is very brittle approach, one wrong import or external ESM dependency and things are broken. \r\n\r\nOther approach would be to compile code with typescript and run tests in outDir without any transpilation?","I just tested, jest work when running on transpiled code, see scripts-> test:js on above repo. It is tempting as a way to speed up tests in a large codebase. I will try tomorrow at work codebase 5k tests.","Using this as a script works for me. I'm using Node v16.2.0 and Jest v26.6.3 with `type` set to `module` in the package.json.\r\n```js\r\n\"test\": \"NODE_OPTIONS=--experimental-vm-modules jest\"\r\n```","Pin this? :) The same way https:\/\/github.com\/facebook\/jest\/issues\/11167 is pinned.","@chyzwar \r\n\r\n> Adding --experimental-specifier-resolution=node is working but all files in project need to be without js extension, otherwise mixed imports leads to another error:\r\n\r\n`--loader ts-node\/esm` is responsible for resolving from `.js` to `.ts` correctly.  I don't think jest's resolver is doing this.  In `ts-node` we use a customized copy of node's own resolver to accomplish this, but I think jest is using a third-party module and is waiting for some new features in that module.","After updating to jest v27 (and ts-jest v27), I no longer need `NODE_OPTIONS=--experimental-vm-modules` to run tests in a project with package.json `type` key set to `\"module\"`.","> After updating to jest v27 (and ts-jest v27), I no longer need `NODE_OPTIONS=--experimental-vm-modules` to run tests in a project with package.json `type` key set to `\"module\"`.\r\n\r\nYou gave me hope, but that is not true for my project (Jest 27.0.3, no ts-jest, Node.js 16.2.0, npm 7.13.0).\r\n\r\nThe only reason this matters is that I need to pass the guidance about such a flag to users of my library, and *they* need to set this flag.\r\n\r\nI think this is best tracked at the Node.js side, e.g. https:\/\/github.com\/nodejs\/modules\/issues\/564","@chyzwar I agree with you. Requiring `--experimental-specifier-resolution=node` to use ESM modules with TypeScript is really not a good idea.  Basically, just to get Jest to work, I have to remove all \".js\" extensions from all my `import` statements throughout my application then specify a special config when I start node for anything related to the project (i.e. testing, debugging, running etc).\r\n\r\nA test package should not require you to change the code of the application just to make this work.  The problem seems to be in `jest-resolve` as its unable to find any file when you append the \".js\". \r\n\r\nAnyone else?","> A test package should not require you to change the code of the application just to make this work. The problem seems to be in `jest-resolve` as its unable to find any file when you append the \".js\".\r\n>\r\n> Anyone else?\r\n\r\nI think so, too.","Experimental status of the `vm` APIs are tracked in https:\/\/github.com\/nodejs\/node\/issues\/37648. Up until that is resolved you will need to keep using the flag to run native ES modules.\r\n\r\n(I've hidden the comments related to that as this issue is already quite spammy).\r\n\r\nAlso please refrain from \"+1\" comments - use reactions instead.\r\n\r\n---\r\n\r\nExtension in import is tracked in #9885. I haven't considered \"not js that transpiles to real js\" there, feel free to discuss it over there.\r\n\r\nEven better would be to send a PR - just like all of you in this thread I am paid $0 to work on Jest, so the fastest way to get movement on issues like this is to send PRs.\r\n\r\n---\r\n\r\n> RE waiting to see what `resolve` adds to its ESM API, are you talking about NodeJS's `import.meta.resolve()`, the ESMLoader `resolve` hook, or something else entirely? If either of the first two, is there anything in particular you have in mind? (Happy to move that topic elsewhere\u2014we may already have an appropriate discussion going).\r\n\r\nhttps:\/\/github.com\/browserify\/resolve","Maybe I missed something, but shouldn't _node modules_ that are esm work out of the box? I have an NPM package that is module only (uses import\/export and has type \"module\"), but it fails to load within jest.\r\n\r\n```\r\n    aesthetic-react\/node_modules\/@aesthetic\/core\/esm\/index.js:9\r\n    import { ThemeRegistry } from '@aesthetic\/system';\r\n    ^^^^^^\r\n\r\n    SyntaxError: Cannot use import statement outside a module\r\n```","@milesj No, they don\u2019t.\r\n\r\nThe good news is you just need to introduce a resolver. See [here](https:\/\/github.com\/akauppi\/GroundLevel-firebase-es\/blob\/master\/packages\/backend\/jest.config.default.js#L12-L18) for an example.","@akauppi That is... unfortunate. But thank you, will take a look.","**mfurey** has contributed **$100.00** to [this issue](https:\/\/rysolv.com\/issues\/detail\/7b7aa06b-6e29-47d2-ad07-b7501fb07594) on Rysolv.<br\/><br\/>    The total bounty is now **$100.00**. Solve [this issue](https:\/\/rysolv.com\/issues\/detail\/7b7aa06b-6e29-47d2-ad07-b7501fb07594) on Rysolv to earn this bounty.<br\/>  ","Hey @SimenB, feel free to hide this if off topic. But I added a $100 bounty to the issue. And I think that anyone can chip in to bump that number up.\r\n\r\nI really appreciate the work, and I am sorely in need of this being implemented. ","An anonymous user has contributed **$50.00**\r\n\r\nAn anonymous user has contributed **$100.00**\r\n\r\nAn anonymous user has contributed **$20.00**\r\n\r\nThe total bounty is now **$270.00**. Solve [this issue](https:\/\/rysolv.com\/issues\/detail\/7b7aa06b-6e29-47d2-ad07-b7501fb07594) on Rysolv to earn this bounty.","Working sandbox with ES Modules, no typescript loader though.\r\n\r\n[CodeSandbox Jest-4-Life](https:\/\/codesandbox.io\/s\/jest-4-life-native-es-modules-ciqp9)  \r\n\r\n![Screenshot from 2021-07-09 05-04-55](https:\/\/user-images.githubusercontent.com\/876076\/125061967-814b7900-e073-11eb-8143-0a18eefd08d8.png)\r\n","Not sure if this has been mentioned already. My tests are running using ES Modules syntax. Adding an option such as `--runInBand` or `--maxWorkers 1` breaks and returns this:\r\n\r\n```\r\n Test suite failed to run\r\n\r\n    Jest encountered an unexpected token\r\n\r\n    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.\r\n\r\n    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.\r\n\r\n    By default \"node_modules\" folder is ignored by transformers.\r\n\r\n    Here's what you can do:\r\n     \u2022 If you are trying to use ECMAScript Modules, see https:\/\/jestjs.io\/docs\/ecmascript-modules for how to enable it.\r\n     \u2022 To have some of your \"node_modules\" files transformed, you can specify a custom \"transformIgnorePatterns\" in your config.\r\n     \u2022 If you need a custom transformation specify a \"transform\" option in your config.\r\n     \u2022 If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the \"moduleNameMapper\" config option.\r\n\r\n    You'll find more details and examples of these config options in the docs:\r\n    https:\/\/jestjs.io\/docs\/configuration\r\n    For information about custom transformations, see:\r\n    https:\/\/jestjs.io\/docs\/code-transformation\r\n\r\n    Details:\r\n\r\n    ...\/src\/institutions.spec.js:1\r\n    ({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest){import mongodb from 'mongodb';\r\n                                                                                      ^^^^^^\r\n\r\n    SyntaxError: Cannot use import statement outside a module\r\n\r\n      at Runtime.createScriptFromCode (node_modules\/jest-runtime\/build\/index.js:1479:14)\r\n```","@anonymousThey, bounty is a brilliant idea. @SimenB can you give us a target? \r\n\r\nFor the sake of the ecosystem, ESM mocking is desperately needed \ud83d\ude4f","@SimenB [resolve](https:\/\/github.com\/browserify\/resolve\/issues\/222) is just sitting. I think it's safe to assume that they are not committed to fixing their problems in the timeline that users on this thread would be hoping for. I'm going to try swapping `resolve` out for `enhanced-resolve` since it supports the needed features and we'll see what breaks. Maybe we can break the deadlock!","So my initial goal is to be able to build this as a non-breaking change, but I'm not sure yet if that will be possible.\r\n\r\nThe biggest problem is that `resolve` takes all its options as part of the call to `resolve()`, where `enhanced-resolve` expects to create a resolver from a factory. We'll want to avoid repeatedly creating new resolvers as it is presumably expensive, but the current API makes that quite difficult. The obvious choice is to store resolver options in a cache keyed on the options passed, but there's a problem: the options object includes `basedir`, which is to say the directory containing the file doing the resolution. This means the options object is always going to be different so that it can have a different basedir, making it useless for caching.\r\n\r\nI would change that API, but it's public and [documented](https:\/\/jestjs.io\/docs\/configuration#resolver-string)","In good news using `enhanced-resolve` makes jest a good bit simpler: jest currently has rolled its own fs caching and pnp resolution, where enhanced-resolve supports both out of the box.","@SimenB (and other maintainers) are you interested in making a breaking change to jest's API to support this? The breaking change would be to the custom resolver contract:\r\n```js\r\nresolver(path, { basedir: string, ...options })\r\n\/\/ would become\r\nresolver(path, basedir, options )\r\n\/\/ or even better:\r\nresolver(options)(path, basedir)\r\n```","@conartist6 Given that using `enhanced-resolve` at all is contrary to the maintainers' desire to continue with `resolve`, I'd suggest best way to make a convincing case that this is the way to go is to implement it in a way that doesn't require breaking changes, even if it's not super-performant to start with. i.e. prove it works first and worry about optimizing for performance later.\r\n\r\nJust my opinion...","I have no fear of breaking changes. They're often better than the alternative, and the alternative in this case is likely some hard-to-explain, hard-to-read, hard-to-document runtime hacking. We have the semver spec and changelogs and type systems to make dealing with properly introduced breaking changes relatively painless.","Personally I don't see much point in holding `resolve` out as an ideal either. Yes it has the shorter name and currently about 2x the NPM downloads. But on the flipside, browserify is basically a relic of the past at this point (and it's showing in maintenance), whereas webpack is a mainstay of the community and has kept up-to-date with new features like pnp and `exports`.","Largely the code just passes around options objects and then feeds them into static methods which feed those options into the configured resolver.  Right now the resolver configurations aren't centralized, but looking for usages of `findNodeModule` (through which all happy-path resolver logic appears to flow) sheds some light on what they are:\r\n\r\n- A static base resolver which never has any options: used for resolving module paths in the config\r\n- A static preset resolver which forces specific extensions, particularly `['.json', '.js', '.cjs', '.mjs']`\r\n- A configured resolver, which uses the options specified in the config coupled with some `paths` magic to support platform-specific imports.\r\n\r\nAm I missing any?\r\n\r\nWhat I'd like to see instead are actual instances of the `Resolver` class which could be initialized during config processing. It seems that creating an enhanced resolver is indeed [quite costly](https:\/\/github.com\/webpack\/enhanced-resolve\/blob\/main\/lib\/ResolverFactory.js) so jest would definitely want to do it as infrequently as possible.","OK I'm leaving this be for now until I get some feedback. My impression is that the `resolverFactory(options)(path, basename)` API is the way to go. Looking up resolver instances from options objects would be tremendously tricky as those objects are not identity-stable.","I am testing if a certain code throws an error, and weirdly if it throws an error the test fails and points out this is because of the thrown error. I would like to know, before I open a bug report, if this might be related to the use of this experimental feature, as it sounds very strange.\r\n\r\nHere's the piece of code where I am running the tests:\r\n![image](https:\/\/user-images.githubusercontent.com\/24969130\/131060022-6f93d5a6-c885-436c-bc7a-851af1f9dd62.png)\r\n`        test(\r\n            \"Getting \".concat(\r\n                \"coordinates from an abstract class must throw an error,\",\r\n                \" and GetUpdatedCoordinates() should update internal timer \",\r\n                \"and set to end case it's equal or beyond the end\"\r\n            ),\r\n            ()=>{\r\n                for (let curCase of testcases) {\r\n                    var curobj = Construct(curCase);\r\n                    curobj.Start(curCase.startDef); \/\/ start so all functions will get coordinate\r\n                    expect(curobj.GetMomentCoordinates).toThrow();\r\n                    curobj.Update(curCase.checkpoints[0]);\r\n                    expect(curobj.GetMomentCoordinates).toThrow();\r\n                    expect(curobj.GetUpdatedCoordinates(\r\n                        curCase.checkpoints[1]\r\n                    )).toThrow(TypeError);\r\n                    expect(curobj.currentTime).toBe(curCase.checkpoints[1]);\r\n                    curobj.Update(curCase.checkpoints[2]);\r\n                    expect(curobj.GetCoordinates()).toBe(curCase.checkpoints[2]);\r\n                    expect(\r\n                        function(){\r\n                            return curobj.GetUpdatedCoordinates(\r\n                                curCase.endpoint\r\n                            );\r\n                        }\r\n                    ).toThrow();\r\n                    expect(curobj.ended).toBe(true); \r\n                }\r\n            }\r\n        );`\r\n\r\nAnd here is the output I am receiving:\r\n![image](https:\/\/user-images.githubusercontent.com\/24969130\/131060153-c1250216-3b15-4236-9386-e7d1005d3749.png)\r\n\r\nAs I said, it is very strange and that's why I suspect it might be a bug, possibly related to the use of native ES module. Should I open a bug report? ","That's not a bug. Jest tests have always expressed failures as errors thrown from within the test case. That is why when you mean to check that some call throws an error you must make sure that the error is not thrown into your test case block, ending it in failure. That is what is happening to you, on line 185 as your stack trace notes. The correct pattern with a callback function is on line 192 of the code you shared, though it's more commonly written with an arrow function now.","> \r\n> \r\n> That's not a bug. Jest tests have always expressed failures as errors thrown from within the test case. That is why when you mean to check that some call throws an error you must make sure that the error is not thrown into your test case block, ending it in failure. That is what is happening to you, on line 185 as your stack trace notes. The correct pattern with a callback function is on line 192 of the code you shared, though it's more commonly written with an arrow function now.\r\n\r\n@conartist6 ohhh, now I see, thanks!!","@conartist6 happy to make changes to Jest's API to support cleanly plugging in `enhanced-resolve`. It should support `resolve` as well, but hopefully that's not an issue. Over time we might consider swapping out `resolve` again, but making it possible to run both in combination would be great regardless.","@SimenB thanks! I'll see what I can do.","https:\/\/github.com\/facebook\/jest\/releases\/tag\/v27.1.1 includes `jest.unstable_mockModule` which can be used to mock ESM. It is very limited for now (it only supports a mock factory), but hopefully it'll still be useful \ud83d\ude42 \r\n\r\nNote that they are not hoisted or such (it's more like `jest.doMock` than `jest.mock` in that regard), so to use it you need to use `import('thing')` rather than `import 'thing'`. Top-level await makes it a bit less painful, but it can be done in a `beforeAll` or some such \ud83d\ude42 ","> https:\/\/github.com\/facebook\/jest\/releases\/tag\/v27.1.1 includes `jest.unstable_mockModule` which can be used to mock ESM. It is very limited for now (it only supports a mock factory), but hopefully it'll still be useful \ud83d\ude42\r\n> \r\n> Note that they are not hoisted or such (it's more like `jest.doMock` than `jest.mock` in that regard), so to use it you need to use `import('thing')` rather than `import 'thing'`. Top-level await makes it a bit less painful, but it can be done in a `beforeAll` or some such \ud83d\ude42\r\n\r\nYou made my day!!!! \ud83d\udd7a\ud83c\udffb","Thanks a million @SimenB!\r\n\r\nThis is working pretty fine, and unlocks many new things.\r\n\r\nFor what it worth, it seems it _forces_ you to provide a default export, even if the mocked file does not have none:\r\n```js\r\n\/\/ src\/repositories\/index.js\r\nexport * from '.\/abstract-repository.js'\r\nexport * from '.\/games.js'\r\nexport * from '.\/players.js'\r\n```\r\n\r\n```js\r\n\/\/ tests\/server.test.js\r\njest.unstable_mockModule('..\/src\/repositories\/index.js', () => ({\r\n  default: {\r\n    games: { connect: jest.fn() },\r\n    players: { connect: jest.fn() }\r\n  }\r\n}))\r\n```\r\n\r\nNot providing `default` gives the following error:\r\n```shell\r\n FAIL  tests\/server.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    SyntaxError: The requested module '.\/repositories\/index.js' does not provide an export named 'default'\r\n\r\n      at Runtime.linkAndEvaluateModule (..\/..\/node_modules\/jest-runtime\/build\/index.js:726:5)\r\n```","Glad to hear it's helping out! That seems like a bug indeed. Could you open up a new issue with a small reproduction?","> * [x]  Code coverage\r\n> \r\n> Does it matter? I don't think it's affected as we can still transform the source with babel (maybe it'll be confused by `import` statements, probably not) and V8 coverage definitely shouldn't care. We should verify though.\r\n\r\nI was playing with native ESM and V8 coverage. All is perfect if Babel is involved, but there are issues with V8. If a file under test is transpilled (TS > EMS) and a source map is included, then resulting V8 coverage is 3 lines off. Without source map V8 coverage looked random.\r\n\r\nI was transpilling the source using different libraries. Same result. Also tried coverage using `c8` module directly on an ESM file (without involving Jest). All is good. Quick, nice and precise.\r\n\r\nMight be I messed up something. In the other hand, Babel based coverage worked well in all cases.\r\n\r\nGlad to provide a reproduction (if necessary) or to help fixing this. This library is huge, I would need some hints where to start?","The code for it can be seen in the PR implementing it: #8596.\r\n\r\nSpecifically, these are probably the parts that affect it:\r\n\r\n- https:\/\/github.com\/facebook\/jest\/blob\/da7c4a42840230ddaa7c101dbc86edb752787c64\/packages\/jest-reporters\/src\/CoverageReporter.ts#L456-L468\r\n- https:\/\/github.com\/facebook\/jest\/blob\/da7c4a42840230ddaa7c101dbc86edb752787c64\/packages\/jest-runtime\/src\/index.ts#L1113-L1130\r\n\r\n---\r\n\r\nBut let's track this in a separate issue - mind filing one? \ud83d\ude42 ","If you'll pardon the question: any idea when this can start being run without issuing the now rather legacy `NODE_OPTIONS=--experimental-vm-modules`? It would be quite nice to be able to just run an `npx jest ...` as needed without having to build node scripts with `cross-env` first =)","From the OP\r\n\r\n>Tracking issue for stabilization in Node: nodejs\/node#37648","I see, thank you. It looks like some of those issues have been outstanding for some time (I see two that were last active october\/december 2020), so hopefully progress on the others retriggers work on those.","Hi, I went quickly through the comments as well as Issue description but I didn\u2019t see the topic about: supporting custom Jest stuffs (resolver, transformer, etc\u2026) written in ESM. Does that topic belong to this one? If yes, sorry for the inconvenience:) If no, would you pls point me to the track issue for that? Thank you.","https:\/\/github.com\/facebook\/jest\/issues\/11167","Hi, I still do not get how to make tests passing if i have `import.meta.url` in the code. Webpack import workers this way, so i do not want to change my code in favor jest. Is there any workaround for ` SyntaxError: Cannot use 'import.meta' outside a module` ??","That means the file is not loaded as ESM - check your config. (And please don't ask usage questions in this issue - a _lot_ of people will get an email notification)","Hmm, I used `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js` but I see `supportsStaticESM` is `false` in transformer. Is it correct that, it is only `true` if I have `processAsync` in my transformer as stated here https:\/\/github.com\/facebook\/jest\/blob\/main\/packages\/jest-runtime\/src\/index.ts#L474 ?","@ahnpnl could you open up a separate issue with a reproduction?","If a transformer returns CJS codes while running with Jest ESM mode, is it ok or not recommended? I tested this scenario and Jest seems to be ok with it.","If `supportsStaticESM` (or whatever it's called, I'm afk) is `true`, CJS is not supported and will fail at runtime, otherwise it's fine. Both modes are supported regardless of the flags, it depends in the file in question","In package.json I have `\"type\": \"commonjs\"` with tests written as `my.test.mjs`. And test files are not found. Not even candidates for pattern matching. (i.e using `testRegex: \".\"`). Is this expected?\r\n\r\nI can PR a document update to clarify this if so.","@gomain this at least worked for me a few months ago. There are a few configuration options for specifying which files\/file extensions to look for. Is one of those perhaps conflicting? (I think some override rather than extend the default value, so you may be stomping the thing that makes it work)","@JakobJingleheimer thanks, I found the gotcha. `moduleFileExtensions` must include `\"js\"`. This validation should be lifted. It makes no sense that one must specify an extension that was not intended.","I was wondering, is there a way to turn the usage of `vm.SyntheticModule` off completely?\r\nI am trying to test that importing a module is working correctly, and this feature is really just getting in the way...\r\nWith this on, even if I add `NODE_OPTIONS=--experimental-vm-modules`, I'll still remain unable to test that the `exports` field works as expected, for example...\r\n\r\nEdit: related https:\/\/github.com\/remix-run\/react-router\/pull\/8268","Cross posting for visibility: https:\/\/github.com\/facebook\/jest\/pull\/11529#issuecomment-1027091448\r\n\r\n(Not at all to gather sympathy or any such thing (working on Jest has been a joy for the last few years), just for transparency as I assume many people subscribed to this issue are frustrated about the lack of progress.)","@SimenB I'm really sorry to hear and I hope you can get your mood back up at some point. I have to agree with the whole ESM\/Node situation, what a mess.","Of the points mentioned in the OP, Jest 28 will include support for [packages `exports`](https:\/\/nodejs.org\/api\/packages.html#package-entry-points), async module resolution and support for [data imports](https:\/\/nodejs.org\/api\/esm.html#data-imports) (not in OP, but still. ESM \ud83d\ude05).\r\n\r\nThere's been no further work on mocks (beyond `jest.unstable_mockModule`, which landed in Jest `27.1.1`).\r\n\r\nThat said, please give https:\/\/github.com\/facebook\/jest\/releases\/tag\/v28.0.0-alpha.4 a whirl \ud83d\ude42\r\n\r\n---\r\n\r\nIn general ESM support is, as mentioned a few times, blocked on https:\/\/github.com\/nodejs\/node\/issues\/37648.","I want to say that https:\/\/github.com\/nodejs\/node\/issues\/37648 seems blocked on https:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=10284 which in turn seems blocked on https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=1238312 (not sure how chromium can block a v8 issue \ud83e\udd37)\r\n\r\nSo if anything we can hope someone with powers can push those two last issues to be fixed.","Since there wasn't any notable activities on those chromium issues for more than 4 months, I just humbly [asked the chromium dev on twitter](https:\/\/twitter.com\/vajahath7\/status\/1498728252038283264). I hope they will keep the issues tracked.","I highly doubt you'll get a (constructive) answer, but \ud83e\udd1e\ud83e\udd1e","> In general ESM support is, as mentioned a few times, blocked on https:\/\/github.com\/nodejs\/node\/issues\/37648.\r\n\r\nWith all the respect for the efforts put in bringing the [current state of ESM support in Jest](https:\/\/jestjs.io\/docs\/ecmascript-modules), may I ask do we have any other ways to implement this without touching the blocking https:\/\/github.com\/nodejs\/node\/issues\/35889? Like an alternative route to support ESM (even without using the `vm`)?\r\n\r\nBecause https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=1238312 and https:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=10284 may not get fixed in any semi-near future (looking at the current pace). So do we have any other _wild_ options?","There are no real alternatives. I've heard from google engineers there is progress, but unfortunately there's not much we can do from our side","I have released https:\/\/github.com\/nicolo-ribaudo\/jest-light-runner, which is my utility to run Jest tests on the native Node.js implementation of ESM (which isn't affected by that V8 bug).\r\n\r\nIt disables most of Jest's features, but if you don't need them you might find that package useful.","@nicolo-ribaudo Great\r\n work! We(Prettier) already steal it \ud83d\ude04 https:\/\/github.com\/prettier\/prettier\/tree\/3cbee742a792413211eea1e4fe2d0dad26ff37ea\/tests\/config\/jest-light-runner","Great stuff \ud83d\udc4d Should link to it from our ESM docs ","Awesome runner, indeed! If only it supported typescript transpilation (dreaming...)\r\nAdded a feature request: https:\/\/github.com\/nicolo-ribaudo\/jest-light-runner\/issues\/1","@kirillgroshkov pretty sure you can get TS support via ts-node:\r\nhttps:\/\/github.com\/TypeStrong\/ts-node-repros\/tree\/jest-light-runner\/","> @kirillgroshkov pretty sure you can get TS support via ts-node: https:\/\/github.com\/TypeStrong\/ts-node-repros\/tree\/jest-light-runner\/\r\n\r\nYeah but unfortunately that requires using a --loader and if you also need some kind of module mocking, you cannot also use the loader for ts-node and esmock\r\n\r\nhttps:\/\/github.com\/iambumblehead\/esmock\/issues\/48\r\n\r\nThis is going to become a very serious problem sometime in the near future as package maintainers convert their packages to ESM only because of the push by the ESM community even though the ecosystem is simply not ready.\r\n\r\nI absolutely hate how the ESM community has strong armed this.\r\n\r\nhttps:\/\/github.com\/node-fetch\/node-fetch\/issues\/1263\r\nhttps:\/\/github.com\/sindresorhus\/meta\/discussions\/15\r\nhttps:\/\/gist.github.com\/joepie91\/bca2fda868c1e8b2c2caf76af7dfcad3\r\nhttps:\/\/news.ycombinator.com\/item?id=29137663\r\nhttps:\/\/www.reddit.com\/r\/node\/comments\/llzn11\/are_most_people_not_using_esm_importexport_syntax\/\r\nhttps:\/\/dev.to\/bcoe\/esm-doesn-t-need-to-break-the-ecosystem-4p8b\r\nhttps:\/\/redfin.engineering\/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\r\n\r\nThe only thing the ESM community seems to be interested in is strong arming everyone in the NodeJS community into using ESM, ignoring any comments they have, and providing complex workarounds that don't solve the problems proposed.\r\n","@yinzara I posted a solution to your problem here:\r\nhttps:\/\/github.com\/nicolo-ribaudo\/jest-light-runner\/issues\/1#issuecomment-1086899673\r\nIt allows combining multiple loaders.\r\n\r\nYou can also follow along with node's loaders team, who are adding loader chaining to node.  I am not a part of that team.  You can direct your feedback to them.\r\nhttps:\/\/github.com\/nodejs\/loaders\r\n\r\nI am not a part of this \"ESM community\" you refer to.  This is why I suggest talking to the node team directly.  I believe it will be more productive to express your frustrations there.","I appreciate the work around :-)\r\n\r\nI'm sorry, I wasn't intending to direct my comments at you in any way. I appreciate your jest-lite-runner package as an option.  If I didn't already have 1000s of test cases written using jest mocking, it would be an option for me.\r\n\r\nIt was more a general frustration of the entire push (mostly started by @sindresorhus) to force the whole community to move to ESM when there are still major issues with its support across the ecosystem.  He (and others like him like @herberthobregon) who use their control of the packages they maintain to try and force the entire community to change while completely ignoring the pleas and comments of the community that clearly is saying they don't want this. I believe this will be the downfall of the entire community if the NodeJS and Chromium teams don't take a serious look at correcting any issues that prevent full support of ESM.","@yinzara no problem, I was not offended.  I believe it is important to clarify -- for anyone else who reads this -- that I am not a proponent of ESM, even though I create and share solutions to ESM problems.  That is why I felt it necessary to point out that I'm not one of the people forcing ESM.","@nicolo-ribaudo Great job on the light runner. I finally got my tests running in the yeoman-environment. What do you think is needed to get coverage  (```--coverage```) supported?","> @yinzara It was more a general frustration of the entire push to force the whole community to move to ESM when there are still major issues with its support across the ecosystem. He (and others like him like @herberthobregon) who use their control of the packages they maintain to try and force the entire community to change while completely ignoring the pleas and comments of the community that clearly is saying they don't want this.\r\n\r\n_TLDR; This comment does not contribute to the conversation because I have not read all the context;_\r\nI understand your frustration but you have to move forward in the homogenization of the ecosystem. There are more for your listing `chalk`, `execa`, `slash`, `globby` packages that are migrating to ESM, it is a step that must be done, moving a project to ESM is not difficult if you work with TS. I understand the resistance to change but it is something that should be promoted\r\nMany packages that are ESM can be used in cjs. You can wrap it from import(). ESM is standard (BE-FE)\r\n\r\n","Please keep the discussion in this issue to Jest's support for ESM. I'm very happy with @nicolo-ribaudo's new package and hope it can be used by people who want a \"plain node\" runner, but every comment after that has been off topic. There's a _lot_ of people subscribed to this issue, and discussions about the merits of CJS vs ESM does not belong here. Feature requests and\/or bug reports  for the light runner belongs in its repo, not here.\r\n\r\nThank you!","Why is `jest` injected in module scope instead of being a global? Is it due to per-module settings?\r\n\r\nWould it be possible to use async localstorage so that `jest` can be a global and anything running under the module will be using that async localstorage?","similar to `import.meta` it is scoped per module, yes. It isn't injected in ESM though, you import via `import {jest} from '@jest\/globals'`. Regardless, it is not global (e.g. `jest.requireActual('.\/relative-path')` needs to work correctly from whatever file `jest` is imported)","Well, that could be achieved with async localstorage I think. Importing `jest` already works, and a global `jest` could be added that looks at a module-local storage that is created with [.run()](https:\/\/nodejs.org\/docs\/latest-v16.x\/api\/async_context.html#asynclocalstoragerunstore-callback-args) when the module is loaded.","I don't understand what you're asking for, but regardless it seems orthogonal to ESM support. Can you open up a separate feature request? Please include what you're trying to solve, not just your suggested solution (just \"use ALS\" doesn't give me much to go on \ud83d\ude00 https:\/\/xyproblem.info\/)","@SimenB sorry :) While switching to ESM I cursed that I had to import `jest` everywhere I use it, and it would not have been needed if it was a global like `expect` and friends.\r\n\r\nI assumed that you didn't make it a global because it's different per module, and I proposed a workaround for that, namely making a global `jest` that figures out which module it's in based on ALS that provides that information.\r\n\r\nSo it's not a separate issue, just an approach to making the conversion to ESM more seamless.","Ah, in that case the natural thing would be to stick it on `import.meta.jest`, which is per module.","Ah nice, TIL :) - and is there a reason this isn't done? ","It's literally the first discussion in this issue \ud83d\ude42\r\n\r\nThat said, it's trivial to do","Ah ok,sorry, I ready that when figuring out how ESM support is done but didn't register that it was a decision. Is providing `import.meta.jest` limiting allowing import of `jest`?\r\n\r\nNot everybody uses TS, and if both are possible why not provide both? \r\n\r\nAs more packages only exist as ESM, more codebases will have to be converted to ESM, and even small incompatibilities like a missing `jest` are roadblocks.","Nah, either works and is trivial to implement. Wanna send a PR? https:\/\/github.com\/facebook\/jest\/blob\/fe5f37038c3771aa9014bc351c0bddb04c35da7d\/packages\/jest-runtime\/src\/index.ts#L501-L503 & https:\/\/github.com\/facebook\/jest\/blob\/fe5f37038c3771aa9014bc351c0bddb04c35da7d\/packages\/jest-runtime\/src\/index.ts#L626-L628","@wmertens #12698","Thank you! I would have eventually come up with a PR, but I see now that I would have missed some bits.","Jest 28 is out with `import.meta.jest` (and [more](https:\/\/jestjs.io\/blog\/2022\/04\/25\/jest-28))","Thank you for the hard work on this! I'm eager to use this and to see what you've got in store for us in Jest 29 :)","The only thing (currently) planned is import assertions: #12755. I _hope_ to be able to tackle module mocking as well, but I doubt I'll drum up the energy for it \ud83d\ude05 ","@SimenB so `import.meta.jest` doesn't get added to the global like `expect` etc. does. Is that intentional?\r\n\r\nIt's not that hard to replace `jest.` with `import.meta.jest.` across the codebase, but it's nicer if that's not needed.","No, `jest` has never been global (just like `require` or `__filename` hasn't) - it's always been scoped to a single module (\"file\" in practice)","Uhm, ok, but in any case, previously, `jest.fn` just worked and now with esm it needs `import.meta.jest.fn`. Can the original behavior not be restored?","@wmertens My understand from the thread above is that no that old behavior is not possible in native ESM.\r\n\r\nOne difference between CommonJS and ESM is that CommonJS files have a wrapper which injects variables into each file. These variables (e.g. `require`) appear to be globals, but actually they're not - they're injected in the wrapper, so the value of `require` in one file is different from `require` in another file.\r\n\r\nIn CommonJS, the `jest` variable was injected in the same way, on a per-file basis.\r\n\r\nIn ESM, the CommonJS wrapper doesn't exist, so this isn't possible.\r\n\r\nRather than changing every incidence of `jest.fn` to `import.meta.jest.fn`, you could just add `const {jest} = import.meta;` to top of each test file.\r\n\r\nIf you *really* want to avoid making any changes to your test code, you could write a Babel plugin to do this for you. But it's probably easier just to do it by hand.\r\n\r\nHope this helps.","> Rather than changing every incidence of `jest.fn` to `import.meta.jest.fn`, you could just add `const {jest} = import.meta;` to top of each test file.\r\n\r\nOr, instead of relying on global variables, just import `jest` directly:\r\n\r\n```js\r\nimport { jest } from '@jest\/globals'\r\n```","@overlookmotel So this is why I was proposing using ALS earlier - since Jest calls the test scripts it can do so in an ALS scope that includes the proper `jest` implementation, and then the global `jest` just calls the `jest` from ALS scope.\r\n\r\nThat way, existing test scripts wouldn't have to be changed at all (except for mocks).\r\n\r\n@LinusU there's a huge install base of people being used to having `describe`, `test`, `expect` etc be in global, and IMHO if we should import `jest` then we should import everything.","@wmertens can you open up a separate issue for this? The reasoning for the current approach has been explained, and while you want a different approach, I don't think that fits into this issue (as there are two options available today in ESM)","EDIT: ignore this - it works fine standalone but not in the vscode debugger\r\n\r\nIs there a way to run the tests in a debugger now? It seems that `--experimental-vm-modules` makes it so `debugger` no longer works (using `NODE_OPTIONS=\"--experimental-vm-modules --inspect\"), I presume the VM is running outside the debugger?","@wmertens I have debugging working in the vscode debugger and I remember it was a pain to figure it out. Here's what I have in my launch configuration with a comment and link:\r\n\r\n```jsonc\r\n{\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    \/\/ This is the only way I've been able to get Jest debugging working so far. Not sure what made the difference but\r\n    \/\/ it's based on the example found here: https:\/\/github.com\/Microsoft\/vscode-recipes\/tree\/master\/debugging-jest-tests\r\n    {\r\n      \"name\": \"Debug Jest Tests\",\r\n      \"type\": \"node\",\r\n      \"request\": \"launch\",\r\n      \"env\": {\r\n        \"NODE_OPTIONS\": \"--experimental-vm-modules --es-module-specifier-resolution=node\"\r\n      },\r\n      \"program\": \"${workspaceFolder}\/node_modules\/.bin\/jest\",\r\n      \"args\": [\r\n        \"--runInBand\"\r\n      ],\r\n      \"console\": \"integratedTerminal\",\r\n      \"internalConsoleOptions\": \"neverOpen\",\r\n      \"disableOptimisticBPs\": true\r\n    },\r\n  ]\r\n}\r\n```\r\n\r\nHopefully that helps.","I'm noticing memory leaks in my ESM project (CI runs out of memory), and when I do heap snapshots most memory seems to be going to copies of the actual scripts being run. \r\n\r\nI run\r\n\r\n```\r\nnode --experimental-vm-modules --expose-gc .\/node_modules\/jest\/bin\/jest.js --runInBand --logHeapUsage\r\n```\r\n(Node 18)\r\n\r\nI have a bunch of test files, the first one has 54MB of heap and by the last one before it crashes it's 1.8GB.\r\n\r\n```\r\n PASS  src\/services\/ap\/formsModel.test.js (54 MB heap size)\r\n\r\n[...]\r\n\r\n PASS  src\/tapable.test.js (1774 MB heap size)\r\n PASS  .\/testPromise.test.js (1778 MB heap size)\r\n PASS  .\/testPromise-chaining.test.js (1781 MB heap size)\r\n\r\n<--- Last few GCs --->\r\n\r\n[709014:0x2aae0e0]   186965 ms: Scavenge 1909.1 (2072.8) -> 1903.2 (2072.8) MB, 11.1 \/ 0.0 ms  (average mu = 0.276, current mu = 0.223) allocation failure; \r\n[709014:0x2aae0e0]   187018 ms: Scavenge 1914.0 (2072.8) -> 1907.9 (2078.0) MB, 23.3 \/ 0.0 ms  (average mu = 0.276, current mu = 0.223) allocation failure; \r\n[709014:0x2aae0e0]   187064 ms: Scavenge 1918.7 (2078.0) -> 1912.5 (2082.8) MB, 15.3 \/ 0.0 ms  (average mu = 0.276, current mu = 0.223) allocation failure; \r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0xa9e188 node::Abort() [node]\r\n 2: 0x989ba0  [node]\r\n 3: 0xcb25f2 v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]\r\n 4: 0xcb298a v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]\r\n```\r\n\r\nIn fact, when I only have a simple test like this\r\n\r\n```js\r\ndescribe('test', () => {\r\n\ttest('create', () => {\r\n\t\texpect(true).toBeTruthy()\r\n\t})\r\n})\r\n```\r\n\r\nand run with detectLeaks:\r\n\r\n```\r\n$ node --experimental-vm-modules --expose-gc .\/node_modules\/jest\/bin\/jest.js --logHeapUsage --detectLeaks --detectOpenHandles leaks.test.js \r\n(node:766835) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time\r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\n FAIL  .\/leaks.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    EXPERIMENTAL FEATURE!\r\n    Your test suite is leaking memory. Please ensure all references are cleaned.\r\n\r\n    There is a number of things that can leak memory:\r\n      - Async operations that have not finished (e.g. fs.readFile).\r\n      - Timers not properly mocked (e.g. setInterval, setTimeout).\r\n      - Keeping references to the global scope.\r\n\r\n      at onResult (node_modules\/.pnpm\/@jest+core@28.1.0\/node_modules\/@jest\/core\/build\/TestScheduler.js:188:18)\r\n      at node_modules\/.pnpm\/@jest+core@28.1.0\/node_modules\/@jest\/core\/build\/TestScheduler.js:300:17\r\n      at node_modules\/.pnpm\/emittery@0.10.2\/node_modules\/emittery\/index.js:311:13\r\n          at Array.map (<anonymous>)\r\n      at Emittery.emit (node_modules\/.pnpm\/emittery@0.10.2\/node_modules\/emittery\/index.js:309:23)\r\n\r\nTest Suites: 1 failed, 1 total\r\n```\r\n","@wmertens either https:\/\/github.com\/nodejs\/node\/issues\/33439 or https:\/\/github.com\/nodejs\/node\/issues\/36351, in theory fixed by https:\/\/chromium-review.googlesource.com\/c\/v8\/v8\/+\/3172764 at some point","If anyone else encounters the same problem, running Jest under github CI auto-detected 1 CPU and caused `--ci` to run all tests in a single worker process, which ran out of memory.\r\n\r\nI worked around it by adding `-w3` which splits tests in 3 workers and that was enough in my case to prevent the leak from causing the tests to fail.","Another thing that you might want to add here is [`jest.createMockFromModule`](https:\/\/jestjs.io\/docs\/jest-object#jestcreatemockfrommodulemodulename). Both making sure it works with ESM, but also making sure it is easily usable when trying to use it a manual mock\/mock factory callback, to only override a part of a mocked module.\r\n\r\nThe problem with using it stems from ESM not allowing to easily just reexport the object as a module, as in `module.exports = mod`, or the TypeScript specific `export = mod`, which can make this very cumbersome\/impossible to use this function as it is in such a scenario.","So `unstable_mockModule` only mocks a function if its then tested directly but not if it's used as part of another function. \r\n\r\nGiven this mock code\r\n```\r\n\/\/ lib\/logUtils.js\r\nexport function sendErrorToLog(err) {\r\n console.log('ORIGINAL')\r\n}\r\n\r\nexport function logError(err) {\r\n  sendErrorToLog(err)\r\n}\r\n```\r\nAnd this test\r\n````\r\nconst mockLogger = jest.fn().mockImplementation(() => {\r\n  console.log('HERE')\r\n})\r\n\r\n\r\nbeforeAll(async () => {\r\n    jest.unstable_mockModule(`lib\/logUtils`,() =>  {\r\n    ...(await import('lib\/logUtils')),\r\n    sendErrorToLog: mockLogger\r\n  })\r\n})\r\n\r\n\r\nit('logError() sends errors to log', async () => {\r\n  const { logError } = await import('lib\/utils\/logUtils')\r\n  logError(new Error())\r\n  expect(mockLogger).toHaveBeenCalled()\r\n})\r\n````\r\n\r\nThe `logError` function does not call the mocked `sendErrorToLog`. If I dump the ` await import('lib\/utils\/logUtils')` to console I can see this is indeed partially mocked so what I think is happening is that when `logError` gets transpiled or whatever happens on load it includes the original `sendErrorToLog` within itself. Note that I am using TS which may mess things up. Note that I can test the mocked `sendErrorToLog` correctly - just not indirectly. \r\n\r\nAnyone experience this?","A bit hard to say without a more complete example. Could you open up a separate issue? The mocking is very untested, so I have no doubt there's lots of bugs with it \ud83d\ude42","@SimenB made a repo and added issue https:\/\/github.com\/facebook\/jest\/issues\/13258 - I think it revolves around how to import the unmocked functions into the `unstable_mockModule` call. I've tried a variety of approaches but no go.,","Found mistake: _virtualMocks instead of _virtualModuleMocks doesn't allow to use unstable_mockModule with virtual: true. Jest fails with 'Cannot find module...'\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/5e51a06ded2fee7ceb8b1f5ea29af6bcfccc7d1e\/packages\/jest-runtime\/src\/index.ts#L1827-L1838","I have tried every combination of things in this and many other writeups, and nothing works. I am trying to use ESM and Typescript, and they just all hate each other. Relevant TS Config:\r\n\r\n```\r\n    \"lib\": [\"ES2022\", \"DOM\"],\r\n    \"module\": \"ESNext\",\r\n    \"target\": \"ES2022\",\r\n    \"allowJs\": true,\r\n    \"declaration\": true,\r\n```\r\n\r\nJest config:\r\n```\r\nimport type { JestConfigWithTsJest } from 'ts-jest'\r\n\r\nconst jestConfig: JestConfigWithTsJest = {\r\n  preset: 'ts-jest\/presets\/js-with-ts-esm',\r\n  extensionsToTreatAsEsm: ['.ts'],\r\n  moduleNameMapper: {\r\n    '^(\\\\.{1,2}\/.*)\\\\.js$': '$1',\r\n  },\r\n  transform: {\r\n    '^.+\\\\.tsx?$': [\r\n      'ts-jest',\r\n      {\r\n        tsconfig: '.\/tsconfig.json',\r\n        useESM: true,\r\n      },\r\n    ],\r\n  },\r\n}\r\n\r\nexport default jestConfig;\r\n```\r\n\r\nFailure:\r\n```\r\n    \/Users\/my-project\/packages\/service\/build\/app.js:19\r\n        const filename = (0, url_1.fileURLToPath)(import.meta.url);\r\n                                                         ^^^^\r\n\r\n    SyntaxError: Cannot use 'import.meta' outside a module\r\n```\r\n\r\nI am testing in another module (foo-serv), and this error is in the service module, both of which are in a monorepo.","@djMax how do you run jest? --experimental-vm-modules is not a requirement, it's a flag to enable ESM.","I've tried a few ways. Plain jest and `yarn node --experimental-vm-modules $(yarn bin jest)`. The module that's having the trouble has this in package.json:\r\n\r\n```\r\n  \"type\": \"module\",\r\n  \"exports\": \".\/build\/index.js\",\r\n  \"engines\": {\r\n    \"node\": \">16\"\r\n  },\r\n  \"types\": \"build\/index.d.ts\",\r\n```\r\n\r\nJust in case that's related.","@djMax, there is my config (without reporters & co), it forks fine in PnP monorepo, all packages have 'type: module':\r\n```\r\nimport { createRequire } from \"node:module\";\r\nconst require = createRequire(import.meta.url);\r\n\r\nexport const config = {\r\n  extensionsToTreatAsEsm: [\".ts\"],\r\n  transform: {\r\n    \"\\\\.ts$\": require.resolve(\"@swc\/jest\"),\r\n  },\r\n  moduleNameMapper: {\r\n    \"^(\\\\.{1,2}\/.*)\\\\.js$\": \"$1\",\r\n  },\r\n};\r\n```\r\n\r\nThere is only one non-jest package without any specific setup.","I've made the repo public for now to try and figure this mess out.\r\n\r\nhttps:\/\/github.com\/gas-buddy\/gasbuddy\r\n\r\nShould be just `yarn && yarn build:all && yarn test` and boom failure. In your example above, the @swc\/jest bit is unrelated right?","@djMax , there is no ESM:\r\n<img width=\"716\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/20106607\/193171889-6657d502-688e-422e-a2cc-8de0f7aea3df.png\">\r\n\r\nWith ESM enabled, the issue a bit different, right?\r\n<img width=\"858\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/20106607\/193172056-aa7b8ad4-6f94-45bb-a35d-94e386215556.png\">\r\n","@djMax finally, it works ) Plain js config to exclude ts-node & ts-jest from chain:\r\n\r\n```\r\nimport { createRequire } from 'node:module';\r\n\r\nconst require = createRequire(import.meta.url);\r\n\r\nconst jestConfig = {\r\n  extensionsToTreatAsEsm: ['.ts'],\r\n  moduleNameMapper: {\r\n    '^(\\\\.{1,2}\/.*)\\\\.js$': '$1',\r\n  },\r\n  transform: {\r\n    '\\\\.ts$': require.resolve('@swc\/jest'),\r\n  },\r\n};\r\n\r\nexport default jestConfig;\r\n\r\n```\r\n\r\nAdded missed modules\r\n<img width=\"462\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/20106607\/193173157-4b02c1cf-370a-4568-a0d5-c25affb4fd3c.png\">\r\n\r\nAnd \"test\": \"node --experimental-vm-modules --no-warnings $(yarn bin jest)\" as well. \r\n\r\n<img width=\"495\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/20106607\/193173222-f54abb7f-f765-4dbe-84bd-715697bd3a00.png\">\r\n","Yeah, sorry, I pushed updates for the dep issues. I had tried to remove unnecessary ones to reduce noise, but of course I didn't run yarn to clean 'em up so \"works for me.\" Anyhow - first, thank you very much for your help. Going to try and reproduce it here. BTW, should I be able to put this jest config in the monorepo root? I wasn't able to get that to work before.","What is @swc\/jest and what does it have to do with all this?","> What is @swc\/jest and what does it have to do with all this?\r\n\r\n'yarn add @swc\/core @swc\/jest' in project root (a bit dirty but more than enough for POC)","Yeah, I did that, and it does indeed work, but I'd just never heard of it. It seems to be the key to unlocking the prize though, so I'm in!","Simpler working config:\r\n```\r\nconst jestConfig = {\r\n  extensionsToTreatAsEsm: ['.ts'],\r\n  moduleNameMapper: {\r\n    '^(\\\\.{1,2}\/.*)\\\\.js$': '$1',\r\n  },\r\n  transform: {\r\n    \"^.+\\\\.(t|j)sx?$\": [\"@swc\/jest\"],\r\n  },\r\n};\r\n\r\nexport default jestConfig;\r\n```","Sure, it will work without require.resolve... until you decided to use shared config and PnP which blocks loading of 'not your dependencies' for config consumers. PS: [\"@swc\/jest\"] -> \"@swc\/jest\", brackets is useless in simple configuration.","PnP... yeah. That was one step too deep on the bleeding edge for me. But noted, and thanks again. That was a day worth of headbanging.","@SimenB any chance to quick fix for https:\/\/github.com\/facebook\/jest\/issues\/9430#issuecomment-1260044784 in nearest releases? ","Has anyone succeed with use `spyOn` in .mts modules?\r\n\r\n```ts\r\nconst tokens = await import('..\/..\/..\/authentication\/tokens.mjs');\r\nconst spy: any = jest.spyOn(tokens, 'verifyToken').mockResolvedValue({\r\n  ...decoded,\r\n...\r\n```\r\n\r\n<img width=\"588\" alt=\"\u0421\u043d\u0438\u043c\u043e\u043a \u044d\u043a\u0440\u0430\u043d\u0430 2022-09-30 \u0432 20 03 21\" src=\"https:\/\/user-images.githubusercontent.com\/11130487\/193311270-7f6c2114-264b-4883-a9fc-c35d9b3b4bf5.png\">\r\n\r\n```bash\r\nTypeError: Cannot assign to read only property 'verifyToken' of object '[object Module]'\r\n\r\n  at ..\/node_modules\/jest-mock\/build\/index.js:843:33\r\n      at Set.forEach (<anonymous>)\r\n```\r\n","> Has anyone succeed with use `spyOn` in .mts modules?\r\n\r\nIt's impossible due to Module object nature provided by Node. Answered many times... https:\/\/github.com\/facebook\/jest\/issues\/12145#issuecomment-992662824\r\n\r\nBut you can try :)\r\n```\r\nnode --input-type=module -e 'import * as m from \"data:text\/javascript,export var y = 2;\"; m.y = 3;'\r\n```","Related to: https:\/\/github.com\/serverless-stack\/sst\/issues\/1752\r\n\r\nI've been tormented by this issue for a while now and I cannot get my tests to pass.\r\n\r\nI tried to use the solution from @koshic @djMax with `@swc\/jest` and `@swc\/core` with a minimal configuration and it's a no go.\r\n\r\nI'm running `Node 16.13` and the following dependencies:\r\n```\r\n    \"@types\/jest\": \"^29.1.2\",\r\n    \"jest\": \"^29.1.2\",\r\n    \"ts-jest\": \"^29.0.3\",\r\n    \"typescript\": \"^4.8.3\"\r\n```\r\n\r\nUsing this script:\r\n```\r\n    \"test\": \"cross-env node --experimental-vm-modules --no-warnings node_modules\/jest\/bin\/jest.js\",\r\n```\r\n\r\nI get the following error:\r\n<img alt=\"screenshot\" src=\"https:\/\/puu.sh\/Jp1SO\/733e7658b8.png\" \/>\r\n\r\nAnd this error when running `npx jest` without the `--experimental-vm-modules` flag:\r\n<img alt=\"screenshot\" src=\"https:\/\/puu.sh\/Jp1W2\/570c4991ad.png\" \/>\r\n\r\nPlease I'm begging you guys for help. What needs to be done to fix this?\r\n","@l0gicgate please create test repo. As an example, it works in minimal setup like that (yep, I'm too lazy to upload something to  github):\r\n<img width=\"1787\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/20106607\/195947936-c4850680-46d7-4685-be9f-3f288ba96df1.png\">\r\n","Hi, everyone!\r\n\r\nI have the same problem. I noticed that if I clear the jest cache before running the tests, this issue doesn't appear:\r\n`jest  --clearCache; node --experimental-vm-modules $(yarn bin jest)`\r\n\r\nOf course it's not a solution, but in case you are blocked -- maybe you can try this temporary solution. Lmk if it works for you!\r\n\r\n","Switched to `vitest` successfully that comes with built-in es modules support.","I notice that `presets` does not follow ESM module.\r\nEven if the preset package is an ESM module (with `type: module`),\r\n`jest` still try to look for the presets using file structure, and not the mapped exports fields.","Please open new issues for bugs","Hi all, I recently jumped into this issues too, especially on Node 19.x.\r\n\r\nI tried to investigate this, and as outcome extended current jest babel transformer. As this is *hot* topic, I would like to add it here, maybe it would be useful.\r\n\r\nThe approach I used is to convert static imports to dynamic imports and try with existing mocking functionality.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/pull\/13697","One key issue is that the resolver does not handle `imports` field. I have it working in [resolve.imports](https:\/\/github.com\/cyberuni\/resolve.imports) and used in [@repobuddy\/jest](https:\/\/github.com\/repobuddy\/jest). It would be great if `jest` can use it or try to solve the same problem. ","`imports` support landed in #13705. Note that it's orthogonal to ESM though","At least for me, node prevents using `import \/ export` if file is not loaded from module (`mjs` extension) or `--experimental-vm-modules` option is used. I'm more on backend side.\r\n\r\nI agree that adding new transformer (with presets, and so on) would be a better option. It will be easy to configure it by final users as someone could write only\r\n```\r\n  \"jest\": {\r\n    \"testEnvironment\": \"node\",\r\n    \"transform\": {\r\n      \"\\\\.mjs\": \"babel-jest-es6\"\r\n    },\r\n```\r\nStill, it would be possible to maintain a lot of options to fine tune tests, but basic, out-of-box, use case will be easy to configure.","Hi @okikio the conditions order does matter I think. It would lead to a different resolution. \n\n","@okikio @SimenB , the implementation based on `resolve.exports` does not work with file extensions. That's why I implemented it differently in `resolve.imports`. One thing I didn't do is throw error when there is a circular case","@unional could you open a new issue? As mentioned, `imports` (or `exports` for that matter) isn't really connected to ESM support (beyond conditions), and this thread is already super long.","Hi, I came across a search on google on how to properly import installed packages on jest transformed files. In particular, I made myself an npm package and installed it on a NodeJS project. My issue description is:\r\n\r\n1. Install `my_package` with `npm install my_package`\r\n2. Write the statement `import { implemented_function } from 'my_package'` on some jest-transformed file from current project;\r\n3. Receive a long log message mentioning [this page](https:\/\/jestjs.io\/docs\/ecmascript-modules).\r\n\r\nIt is very top-down and annoying not to be able to import an outer module inside a test file. It is weird to use the experimental flag along some node_modules jest reference.\r\n\r\n If I do something wrong or my comment does not fit this issue, I would appreciate you letting me know.","Please don't post questions in this issue - you should use [StackOverflow](https:\/\/stackoverflow.com\/questions\/tagged\/jestjs) or our [discord channel](https:\/\/discord.gg\/j6FKKQQrW9).","Stack overflow posters are mean to such \"how-to-use\" questions. May you please open a dedicated jest community on SO for such questions? It would redirect issues to a broader audience.","@SimenB please, I lost hope in anyone answering such a question or finding a simple answer to it.","@SimenB does this belong here or should be another issue?\r\n\r\nI tried to pass a `.mjs` file as a custom `resolver` and got an error, because `jest-resolve` tries to import it using `require`.\r\n\r\n```\r\nError [ERR_REQUIRE_ESM]: require() of ES Module \/Users\/work\/[REDACTED]\/[REDACTED]\/tools\/jest\/absolutePathResolver.mjs not supported.\r\nInstead change the require of \/Users\/work\/[REDACTED]\/[REDACTED]\/tools\/jest\/absolutePathResolver.mjs to a dynamic import() which is available in all CommonJS modules.\r\n    at loadResolver (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-resolve@29.3.1\/node_modules\/jest-resolve\/build\/resolver.js:773:26)\r\n    at Resolver.findNodeModule (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-resolve@29.3.1\/node_modules\/jest-resolve\/build\/resolver.js:150:28)\r\n    at resolve (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-config@29.3.1_@types+node@18.13.0\/node_modules\/jest-config\/build\/utils.js:107:41)\r\n    at \/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-config@29.3.1_@types+node@18.13.0\/node_modules\/jest-config\/build\/normalize.js:735:34\r\n    at Array.map (<anonymous>)\r\n    at \/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-config@29.3.1_@types+node@18.13.0\/node_modules\/jest-config\/build\/normalize.js:731:34\r\n    at Array.reduce (<anonymous>)\r\n    at normalize (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-config@29.3.1_@types+node@18.13.0\/node_modules\/jest-config\/build\/normalize.js:608:14)\r\n    at readConfig (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-config@29.3.1_@types+node@18.13.0\/node_modules\/jest-config\/build\/index.js:160:74)\r\n    at async readConfigs (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-config@29.3.1_@types+node@18.13.0\/node_modules\/jest-config\/build\/index.js:417:26)\r\n    at async runCLI (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/@jest+core@29.3.1\/node_modules\/@jest\/core\/build\/cli\/index.js:144:59)\r\n    at async Object.run (\/Users\/work\/[REDACTED]\/[REDACTED]\/node_modules\/.pnpm\/jest-cli@29.3.1_@types+node@18.13.0\/node_modules\/jest-cli\/build\/run.js:124:37)\r\n```","Are the points described in [this post](https:\/\/stackoverflow.com\/questions\/75519950\/is-there-a-better-way-to-mock-modules-with-jest-and-esm) being processed by this issue as well?","@Yehonal I had a great development experience with [Sinon](https:\/\/sinonjs.org\/) with this test pattern. It is jest-compatible. :-)","In light of this change, can someone provide more context as to why Jest+jsdom force browser module resolution (i.e. module lookup by its `browser` export)? That sounds incorrect but that's how Jest behaves at the moment. I thought this to be a jsdom issue initially but I don't suppose jsdom concerns itself with module resolution at all. \r\n\r\nA very simple setup to reproduce:\r\n\r\n```json\r\n\/\/ dependency\/package.json\r\n\/\/ Imagine a dual CJS\/ESM dependency meant to run exclusively in Node.js.\r\n{\r\n  \"exports\": { \".\": { \"require\": \".\/node.js\", \"browser\": null } }\r\n}\r\n```\r\n\r\n```js\r\n\/**\r\n * @jest-environment jsdom\r\n *\/\r\nimport X from '.\/dependency'\r\n\r\nit('.', () => {})\r\n```\r\n\r\nThe actual behavior is `Can't find module \"X\" in \".\/dependency\"`. Upon inspection, you see that Jest picks up the `browser` export despite remaining a Node.js process. Switching `@jest-environment` to `node` correctly picks up `exports['.'].require`. I believe Jest should always have the Node.js module resolution. ","@kettanaito I think it can be configured https:\/\/jestjs.io\/docs\/configuration#testenvironmentoptions-object. Vitest has indeed opted to not looking at browser even when using jsdom.","Thanks, @segevfiner. Do you happen to know what exact option controls this? I didn't find anything related to module resolution in jsdom's README. Going to check the source code in my spare time but wanted to ask you first. ","Hi, @kettanaito . I wrote a javascript recently where I used `jest`: take a look at the file [jest.config.js](https:\/\/github.com\/trouchet\/eulejs\/blob\/main\/jest.config.cjs)! As you can see, I set the key `testEnvironment` as   \"jsdom\". I do not know if it solves your issue, but it worked like a charm to me. :-)\r\n","@kettanaito Check the link I sent, it point exactly to where in the docs they tell you how to configure it. \ud83d\ude0a\r\n\r\nHere it is again, just in case: https:\/\/jestjs.io\/docs\/configuration#testenvironmentoptions-object","@kettanaito  \r\n\r\n> why Jest+jsdom force browser module resolution (i.e. module lookup by its browser export)?\r\n\r\nI think this is a project direction of Jest as long as looking such as PR https:\/\/github.com\/facebook\/jest\/pull\/11222\/files#diff-00cf53c43e8f725340be02865210a6db41ddb44626e81b7d2114c1ab3bcd9bc5L66-L70\r\n\r\nI guess they were wanted simulate browser runtime as possible as can in jsdom environment.  \r\nMight be I and almost people wanted \"Run test within Node.js environment + browser API polyfill(jsdom)\".\r\n","For anybody wondering how to opt-out from the browser module resolution in JSDOM, this is how:\r\n\r\n```js\r\n\/\/ jest.config.js\r\nmodule.exports = {\r\n  testEnvironmentOptions: {\r\n    customExportConditions: [''],\r\n  }\r\n}\r\n```\r\n\r\nThis is going to use node resolution with JSDOM. ","> This is going to use node resolution with JSDOM.\n\nNice. Another solution is to use happy-dom","> @Yehonal I had a great development experience with [Sinon](https:\/\/sinonjs.org\/) with this test pattern. It is jest-compatible. :-)\r\n\r\nI do not see how sinon is compatible with jest or can be integrated with it, they do not mention it anywhere.\r\n\r\nAlso, I still need to use jest and can't really migrate somewhere else. Am I the only one having the problem I described in [this post](https:\/\/stackoverflow.com\/questions\/75519950\/is-there-a-better-way-to-mock-modules-with-jest-and-esm)  or is it a known thing that is being processed in this Epic?","@SimenB would it be possible to update the original post with two sections headings. One for \"Already fixed\" and one for \"Still todo\" or something like that, so that the \"Still todo\" is at the top for an easy overview of what is left.\r\n\r\naside: I pray to the benevolent gods that Node.js steps up soon and fixes https:\/\/github.com\/nodejs\/node\/issues\/37648 and I feel your pain around this one :(","@thernstig could you translate these demands in layman terms with use cases? I am a humble man with humble use cases. :-P","@brunodOut it was not aimed at you, but @SimenB. Not sure how to say this nicely, but I recommend you unsubscribe from this issue and stop answering as you seem to mostly ask questions not related at all to the description of this issue. That is why previous comments from you were marked as spam. I understand you are a learner so no worries, but please try to not post more to this issue thread with unrelated questions.","I've got a weird issue. ESM module testing works fine however if I use the `--coverage` option I get the error `SyntaxError: The requested module 'XXX' does not provide an export named 'XXX'`","Please open a new issue with minimal reproduction repo.","> I've got a weird issue. ESM module testing works fine however if I use the `--coverage` option I get the error `SyntaxError: The requested module 'XXX' does not provide an export named 'XXX'`\r\n\r\nbtw, I recall something similar. Didn't create a ticket for it. I recall it's the istanbul can't process ESM, you need to switch to `c8`\r\n\r\nhttps:\/\/github.com\/istanbuljs\/nyc\/issues\/1287","Any idea when that will be completed?","Here is an issue our team had when using the experimental ES modules support and native addons: https:\/\/github.com\/jestjs\/jest\/issues\/14156","Sharing another case: https:\/\/github.com\/formatjs\/formatjs\/issues\/4128\r\n\r\nThe problem is with `TS` + ESM dependency.\r\nIn this case, the ESM dependency are `@formatjs` packages.\r\n\r\nTheir packages does not have `type: module` but through `ts-jest`, the file got resolved are the ESM variant (`exports\/.\/imports: \".\/lib\/index.js\"`).\r\nWhile the loader \"knows\" it is ESM files (as it uses `imports` field),\r\n`jest` doesn't know and rely on the logic:\r\n\r\n> Jest will run .mjs and .js files with nearest package.json's type field set to module as ECMAScript Modules.\r\n\r\nSince there is no `type: module`, the file is treated as CJS and fail.","@unional I'm facing the exact same issue with different dependencies. What's crazy is that, even after searching a whole day for it, I haven't been able to find a way to force Jest to recognize a dependency as ESM (I wish I could override the given logic on a case per case basis). It's really too bad since it's not feasible to wait for all dependencies to update their package.json files and add the type field....\r\nI also have a lot of dependencies that use the `\"module\"` field, with no `\"type\"` or `\"exports\"`\/`\"imports\"`. \r\nI would love for it if there was a way to specify dependencies that need to be resolved as ESM !","@pathiery I haven't yet converted my Jest setup to use modules, but you may be able to use a [custom resolver packageFilter](https:\/\/github.com\/microsoft\/accessibility-insights-web\/pull\/5421\/commits\/9ad4e618019298d82732d49d00aafb846fb6bac7) to force module resolution. That example deletes package.json fields to force packages to _not_ import as ESM, but you could probably use it to set `pkg.type = 'module'` and force packages to import as ESM.","@pathiery I have [@repobuddy\/jest](https:\/\/www.npmjs.com\/package\/@repobuddy\/jest) which configure to use [jest-esm-transformer-2](https:\/\/www.npmjs.com\/package\/jest-esm-transformer-2) to transform dependency code to CJS.\r\n\r\nIt marks those peer dependencies as optional, so you will need to install them directly.","I've started transitioning to ESM-only packages (typescript projects with swc as a transformer). I've got it all working. But I noticed that with jest, you always need this:\r\n\r\n```\r\n  moduleNameMapper: {\r\n    \"^(\\\\.{1,2}\/.*)\\\\.js$\": \"$1\",\r\n  },\r\n```\r\n\r\nOtherwise it's not possible for jest to load ESM modules within the `tests` directory.\r\n\r\nCan any one explain why this is necessary? Obviously it's removing the `.js` extension. Is there some part of Jest that doesn't like `.js` extensions?","You expect to import from `.ts` files, but ESM import specifiers are pointing to `.js` files. Jest resolver can not find `.js` files because those simply do not exist. Extension-less specifiers is what the resolver is used to handle and that is how it finds the `.ts` files for your. (The `moduleFileExtensions` option is part of the game, of course.)","It seems that ESM is causing snapshot path to not work for me when running in github action. Locally it works.","@louisgv Please open a new issue with minimal reproduction repo. By the, I am using snapshots in an ESM\/TS project without any troubles locally or with GHA.","I would appreciate stop-gap solutions to aid troubleshooting developers. I had gone over the ESM instructions for Jest and TS-Jest, but had overlooked how a particular test runner was starting Jest. If they were written to stdout, these things would have let me immediately figure out what was wrong:\r\n- process environment variables (for `NODE_OPTIONS`)\r\n- process command line (i.e. Node's command line)\r\n\r\nI stayed up all night troubleshooting the ol' \"SyntaxError: Cannot use import statement outside a module\".\r\nTurns out, an IDE extension (orta.vscode-jest) will use a default command line (e.g. `npx jest`) unless another one is specified via a new launch.json entry.\r\nP.S. My VSCode tasks and process launch configurations-in addition to my package.json scripts-had already been configured to use `node --experimental-vm-modules node_modules\/jest\/bin\/jest.js`. ESM support worked perfectly when Jest was run via one of those methods.","I'm stuck here as if I don't use transform: I get the error: Must use import to load ES Module (So I don't know if moisting would have happened)\r\nAnd if I use it, moisting doesn't occur (I think): as the stripe module I'm trying to mock is loaded. Which might be \"normal\" as described in the [docs](https:\/\/jestjs.io\/docs\/ecmascript-modules)\r\n\r\nSo I don't know how to configure that. If anybody could help I'd be very happy. The project is an open source, you can check the branch I struggled with [here](https:\/\/github.com\/ziedHamdi\/user-credits\/tree\/core-as-dependency):\r\nhttps:\/\/github.com\/ziedHamdi\/user-credits\/tree\/core-as-dependency (revision: 78270b1193d25c496f7cda1b2291b96ffa588a9a)\r\n\r\nI solved it by declaring the Stripe structure types in an interface and injecting that through ioc (putting mocks in tests). But that was a lot of work for a single module, so having mocks working easily would be a great advancement.\r\n\r\nMy jest config is as follows:\r\n```\r\nexport default {\r\n  extensionsToTreatAsEsm: [\".ts\"],\r\n\r\n  globalSetup: \"<rootDir>\/test\/config\/jest\/globalSetup.js\",\r\n\r\n  \/\/ Add this line\r\n  moduleFileExtensions: [\"ts\", \"tsx\", \"js\", \"jsx\"],\r\n\r\n  \/\/ Other Jest configuration options...\r\n  preset: \"ts-jest\",\r\n\r\n  \/\/ Specify your global setup file\r\n  setupFilesAfterEnv: [\"<rootDir>\/test\/config\/jest\/setupBeforeAll.js\"],\r\n\r\n  testEnvironment: \"node\",\r\n\r\n  testMatch: [\"**\/test\/**\/*.ts?(x)\", \"**\/?(*.)+(spec|test).ts?(x)\"],\r\n\r\n  testPathIgnorePatterns: [\"extend\", \"mock\", \"config\"],\r\n  transform: {\r\n    \".*\\\\.(j|t)sx?$\": [\"@swc\/jest\"],\r\n  },\r\n  transformIgnorePatterns: [],\r\n};\r\n\r\n```\r\n\r\n","Sorry if this is the wrong place to ask this, but it seems relevant to the point about the `jest` global.\r\n\r\nI'm finding that `import {jest} from '@jest\/globals'` has a different type for mock instances than the implicit one.\r\n\r\nGiven:\r\n```\r\n\/\/ package.json - note type:module and jest config for ts-jest's ESM support\r\n{\r\n  \"name\": \"jest-mock-unknown\",\r\n  \"version\": \"1.0.0\",\r\n  \"type\": \"module\",\r\n  \"scripts\": {\r\n    \"test\": \"node --experimental-vm-modules node_modules\/jest\/bin\/jest.js\"\r\n  },\r\n  \"license\": \"ISC\",\r\n  \"devDependencies\": {\r\n    \"@types\/jest\": \"^29.5.10\",\r\n    \"jest\": \"^29.7.0\",\r\n    \"ts-jest\": \"^29.1.1\",\r\n    \"typescript\": \"^5.3.2\"\r\n  },\r\n  \"jest\": {\r\n    \"extensionsToTreatAsEsm\": [\r\n      \".ts\"\r\n    ],\r\n    \"moduleNameMapper\": {\r\n      \"^(\\\\.{1,2}\/.*)\\\\.js$\": \"$1\"\r\n    },\r\n    \"transform\": {\r\n      \"^.+\\\\.tsx?$\": [\r\n        \"ts-jest\",\r\n        {\r\n          \"useESM\": true\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n```\r\n\/\/ tsconfig.json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ESNext\",\r\n    \"module\": \"NodeNext\",\r\n    \"esModuleInterop\": true,\r\n    \"strict\": true,\r\n    \"types\": [\"jest\"]\r\n  }\r\n}\r\n```\r\n```\r\n\/\/ __tests__\/mock.spec.ts\r\nimport {jest} from '@jest\/globals'\r\n\r\ntest('example', () => {\r\n    const fn = jest.fn()\r\n    fn({answer: 42})\r\n    expect(fn.mock.calls[0][0].answer).toBe(42)\r\n})\r\n```\r\n\r\n`npm run test` will succeed.  However, the IDE (WebStorm, VSCode) reports an error on the `expect` line that the type of `fn.mock.calls[0][0]` is unknown.  Casting `jest.fn() as any` circumvents the error, but this is not necessary in conventional use of jest with TypeScript.\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/803755\/e65e3861-d277-483f-a9c5-05710ccad18d)\r\n\r\nIf I remove the jest import, then the IDE error goes away, but the test fails because of the missing global.\r\n\r\n![image](https:\/\/github.com\/jestjs\/jest\/assets\/803755\/cd7ce2bc-e9b8-42f9-9219-37e7c534e762)\r\n","@nlwillia TS questions don't belong in this issue. But to answer; the implicit\/global one comes from `@types\/jest` in the DefinitelyTyped project - `@jest\/globals` comes from Jest itself (and are maintained by the Jest project instead of outside contributors) which is more strictly typed (in this case - defaulting to `unknown` instead of `any`).","After almost 4 years. What is still blocking this?","> After almost 4 years. What is still blocking this?\r\n\r\nQuite simply put: NodeJS. Since Jest is using the [`vm` module of NodeJS](https:\/\/nodejs.org\/docs\/latest\/api\/vm.html#vm-executing-javascript) for test isolation. That API itself is stable, but for ESM scripts it is not (see [here](https:\/\/nodejs.org\/docs\/latest\/api\/vm.html#class-vmmodule)).\r\n\r\nJest does support running native ESM as long as you do it with `NODE_OPTIONS=--experimental-vm-modules jest src`.\r\nIn order to remove that flag, NodeJS would have to stabilize its VM API for ESM scripts.","Thank you for the answer @ChristophP\r\nIt was a little annoying to have to set the flag manually every single time.\r\n\r\nDid we consider auto-adding the flag e,g when package.json has `type: 'module'`? Or is it too risky to auto-add flags even when we are confident enough?","> Thank you for the answer @ChristophP It was a little annoying to have to set the flag manually every single time.\r\n> \r\n> Did we consider auto-adding the flag e,g when package.json has `type: 'module'`? Or is it too risky to auto-add flags even when we are confident enough?\r\n\r\nThis is part of nodejs, not part of jest. Jest team can't do something there to enable that runtime feature without flag. \r\n\r\nBut i hope that vm.modules will be stable on a next nodejs release - i saw a lot of movements there by avoiding v8 runtime problem by node team ","> This is part of nodejs, not part of jest. Jest team can't do something there to enable that runtime feature without flag.\r\n\r\nProvided you are using jest via CLI and not `@jest\/core` directly jest could theoretically ship something like a `jest-esm` executable that sets this env var to a child Node process, right?\r\n\r\n> But i hope that vm.modules will be stable on a next nodejs release - i saw a lot of movements there by avoiding v8 runtime problem by node team\r\n\r\nThis is good news","@SimenB fyi. the `import.meta.dirname` and `import.meta.filename` was backported to Node 20.11. Those should be added to jest as well as right now, jest is missing those.\r\nhttps:\/\/nodejs.org\/docs\/latest-v20.x\/api\/esm.html#importmetadirname","Can we add to Jest support for \"main\/module\" fields in package.json?\r\n\r\nFor example `overlayscroolbars-react` doesn't have `type` field in package.json but has `module` and `main` fields\r\n\r\n","The module field is non-standard. Many bundlers (parcel, vite, etc) respect it but NodeJs for example completely ignores it.\r\nSince Jest is running in Node I assume this is why the `module` field is ignored.\r\n\r\nThe new standard way of defining CJS and ESM endpoints is the `exports` field. Newer Node versions respect it and prefer over `main` if `exports` is present.\r\nhttps:\/\/nodejs.org\/api\/packages.html#exports\r\n\r\n(Note however that neither the `exports` or `module` field would replace the `type` field. Since the first two control which file is loaded, while `type` the controls whether files with a `.js` extensions are treated as ESM or CJS. Using `.cjs` or `.mjs` forces CJS\/ESM treatment regardless of the value of the `type` field)","@ChristophP Thank you for your answer, we discovered that Jest, despite the presence of \"exports\" field, does not understand the `overlayscrollbars-react` package in Node.js v20.11.0: https:\/\/github.com\/KingSora\/OverlayScrollbars\/issues\/604","Great sounds good. Sadly a bunch of packages do not specify the exports field correctly and need to update. :-\/"],"labels":["ES Modules","Pinned"]},{"title":"100% CPU usage on --bail & --coverage combination","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n- run a combination of `--bail` and `--covarage` with a failing test:\r\n```\r\n\"scripts\": {\r\n    \"test\": \"jest --ci --bail --silent --coverage\"\r\n}\r\n```\r\n\r\nIf there is a single failing test jest start running coverage of untested files and pretty soon eats up all the CPU, preventing any usage of the system, e.g. mouse becomes unresponsive. And it never releases to the point I have to restart the machine, at least with Win10.\r\n\r\n## Expected behavior\r\n\r\nI don't expect my machine to hang, obviously.\r\nAlso it might make sense to bail out of the coverage on untested files in case of a bail out. BTW, is there a way to prevent --coverage in case there's a failed test and we bail out? Is there some way to configure it? If not, would that make sense as a feature? I mean, I don't really care for the coverage until I fix the failing test.\r\n\r\n<!-- A clear and concise description of what you expected to happen. -->\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\n<!--\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\nIssues without a reproduction link are likely to stall.\r\n-->\r\n\r\n## envinfo\r\n\r\n<!--\r\nRun npx envinfo --preset jest\r\nPaste the results here:\r\n-->\r\n\r\n```bash\r\nPS D:\\git\\TRI\\linsi-ui> npx envinfo --preset jest\r\nnpx: installed 1 in 3.33s\r\n\r\n  System:\r\n    OS: Windows 10 10.0.17763\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 12.14.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.13.0 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 6.8.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^24.8.0 => 24.8.0\r\n```\r\n\r\nIt kind of happens like this:\r\n```\r\n ...\r\n PASS  src\/services\/Library\/InstrumentUpdater\/CustomInstrumentUpdater.test.ts\r\n PASS  src\/components\/ProgressIndicator\/ProgressIndicator.component.test.tsx\r\n PASS  src\/services\/TemplateDataConvertor\/ConditionalConvertor.service.test.ts\r\n FAIL  src\/services\/Auth\/Auth.service.test.ts\r\n  \u25cf AuthService \u203a should remove token from storage and call login method on relogin\r\n\r\n    expect(jest.fn())[.not].toBeCalled()\r\n\r\n    Matcher error: received value must be a mock or spy function\r\n\r\n    Received has type:  function\r\n    Received has value: [Function anonymous]\r\n\r\n      55 |     sut.relogin()\r\n      56 |     expect(tokenServiceMock.remove).toBeCalled()\r\n    > 57 |     expect(sut.login).toBeCalled()\r\n         |                       ^\r\n      58 |   })\r\n      59 | })\r\n      60 |\r\n\r\n      at Object.<anonymous> (src\/services\/Auth\/Auth.service.test.ts:57:23)\r\n\r\nRunning coverage on untested files... PASS  src\/services\/ScheduleConvertor\/ParamsConvertors\/OnceScheduleParamsConvertor.test.ts\r\nRunning coverage on untested files... PASS  src\/validators\/validation-functions\/SameArgumentsValue.test.ts\r\nRunning coverage on untested files...\r\n```\r\ntests pass until one test fail, and then `coverage on untested files` follows, and that's where things get nasty very fast if you are not fast enough to hit `Ctrl+C`.","comments":["I think ditching the coverage if tests fail makes sense. @thymikee @jeysal thoughts? We can probably get that into Jest 25","Agree with @SimenB. I don't see a value in processing coverage for a failed test and related files (if not processed by other code). By doing so, we could also end up with a slightly faster feedback loop and less clutter to scroll through when identifying failed expectation.","It seems like it is conflating very different things, coverage to me does not even require test cases that can pass or fail, it can be done on any program execution.  This would also introduce an unintuitive half-coverage run where code is still run instrumented but no coverage output generated. Overall sounds like a lot of architectural complexity, not like \"do one thing\" \/ separation of concerns.\r\nI think maybe it's better to fix performance of the \"Collecting coverage from untested files\" step instead, which has always struck me as a problem, even on passed runs in many projects.","There is no performance issue in \"Collecting coverage from untested files\" (or, there _is_, but that's totally orthogonal to the issue reported here) - the issue here is that `bail` is broken and doesn't stop other tests before reporting the run as complete, meaning we're still running tests on a bunch of cores, then spawn new workers to collect coverage on uncovered files thus bombing the CPU with `(numberOfCores - 1) * 2` processes","Okay that's a nasty bug - rest still stands though I think it would be better to fix it than bailing out on coverage collection on failure.","Is there any plan to resolve this bug? Or maybe a known work around while there isn't a permanent solution?","any progress here? it will be almost two years from the last comment...","PR welcome \ud83d\ude42 ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","> This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\nYes, it's still a problem...","I noticed my RAM was being consumed and that my test suite seemed to be stalled while everything on my system started reported as being non-responsive. I noticed that there were a ton of node processes spawned each using 500-700MB+ of RAM. After killing the test running those processes went away and I got my RAM back.\r\n\r\nPart of me believes that if you're asking for coverage then it shouldn't matter if a test fails, but in our scenario we would like to halt our integration process on a failed test while trying to collect coverage, but we also do not want to run the suite twice (once for tests and again for coverage). This has seemed to never work as expected, and lately we've been running into some major resource consumption that seems to be related to this."],"labels":[":bug: Bug","Coverage"]},{"title":"JEST tests complete successfully but returns exit status 1","body":"I run JEST tests using `npm run test:jest` and the corresponding entry in package.json is \r\n\r\n`\"test:jest\": \"jest --config=.\/jest.config.js\",`\r\n\r\nAll tests run successfully, but returns with exit code 1\r\n\r\n```\r\nTest Suites: 1 skipped, 106 passed, 106 of 107 total\r\nTests:       10 skipped, 657 passed, 667 total\r\nSnapshots:   14 files obsolete, 0 total\r\nTime:        34.453s\r\nRan all test suites.\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! @vc\/toolchain@3.3.0 test:jest: `jest --config=.\/jest.config.js`\r\nnpm ERR! Exit status 1\r\nnpm ERR!\r\nnpm ERR! Failed at the @vc\/toolchain@3.3.0 test:jest script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     \/home\/.npm\/_logs\/2019-12-18T13_01_11_869Z-debug.log\r\n\r\n```\r\n\r\n```\r\n10 silly lifecycle @vc\/toolchain@3.3.0~test:jest: Args: [ '-c', 'jest --config=.\/jest.config.js' ]\r\n11 silly lifecycle @vc\/toolchain@3.3.0~test:jest: Returned: code: 1  signal: null\r\n12 info lifecycle @vc\/toolchain@3.3.0~test:jest: Failed to exec test:jest script\r\n13 verbose stack Error: @vc\/toolchain@3.3.0 test:jest: `jest --config=.\/jest.config.js`\r\n13 verbose stack Exit status 1\r\n13 verbose stack     at EventEmitter.<anonymous> (\/usr\/local\/lib\/node_modules\/npm\/node_modules\/npm-lifecycle\/index.js:332:16)\r\n13 verbose stack     at emitTwo (events.js:126:13)\r\n13 verbose stack     at EventEmitter.emit (events.js:214:7)\r\n13 verbose stack     at ChildProcess.<anonymous> (\/usr\/local\/lib\/node_modules\/npm\/node_modules\/npm-lifecycle\/lib\/spawn.js:55:14)\r\n13 verbose stack     at emitTwo (events.js:126:13)\r\n13 verbose stack     at ChildProcess.emit (events.js:214:7)\r\n13 verbose stack     at maybeClose (internal\/child_process.js:915:16)\r\n13 verbose stack     at Process.ChildProcess._handle.onexit (internal\/child_process.js:209:5)\r\n14 verbose pkgid @vc\/toolchain@3.3.0\r\n15 verbose cwd \/workspace\/vc.src\/vco\/src\/server\/node\r\n16 verbose Linux 3.13.0-163-generic\r\n17 verbose argv \"\/usr\/local\/bin\/node\" \"\/usr\/local\/bin\/npm\" \"run\" \"test:jest\"\r\n18 verbose node v8.17.0\r\n19 verbose npm  v6.13.4\r\n20 error code ELIFECYCLE\r\n21 error errno 1\r\n22 error @vc\/toolchain@3.3.0 test:jest: `jest --config=.\/jest.config.js`\r\n22 error Exit status 1\r\n23 error Failed at the @vc\/toolchain@3.3.0 test:jest script.\r\n23 error This is probably not a problem with npm. There is likely additional logging output above.\r\n24 verbose exit [ 1, true ]\r\n```\r\n\r\nI am not sure why the process exits with status code 1 even though all tests pass.","comments":["Repro please, or it didn't happen","Hi @thymikee \r\n\r\nThis happens in our repo and I am not able to create a reproducible sample repo. But what I could say is that the following command runs successfully, \r\n\r\n\r\n```\r\nnode \/workspace\/vc\/vco\/src\/server\/node\/node_modules\/.bin\/jest --config=.\/jest.config.js\r\n\r\n<Runs all the tests successfully >\r\n\r\nTest Suites: 1 skipped, 106 passed, 106 of 107 total\r\nTests:       10 skipped, 657 passed, 667 total\r\nSnapshots:   15 files obsolete, 0 total\r\nTime:        24.668s, estimated 33s\r\nRan all test suites.\r\n```\r\n\r\n\r\n\r\nwhereas when running JEST cases via `npm` is failing. \r\n\r\n```\r\n$ npm run test:jest\r\n\r\n<Runs all the tests successfully >\r\n\r\n\r\nTest Suites: 1 skipped, 106 passed, 106 of 107 total\r\nTests:       10 skipped, 657 passed, 667 total\r\nSnapshots:   19 files obsolete, 0 total\r\nTime:        25.982s\r\nRan all test suites.\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! @velocloud\/toolchain@3.3.0 test:jest: `jest --config=.\/jest.config.js`\r\nnpm ERR! Exit status 1\r\nnpm ERR!\r\nnpm ERR! Failed at the @velocloud\/toolchain@3.3.0 test:jest script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     \/home\/vagrant\/.npm\/_logs\/2019-12-18T15_15_30_620Z-debug.log\r\n```\r\n\r\n\r\njest.config.js \r\n\r\n```\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    \"projects\": [\r\n        {\r\n            name: \"vc-core\",\r\n            displayName: \"Jest - VC services\",\r\n            bail: false,\r\n            clearMocks: false,\r\n            collectCoverage: false,\r\n            collectCoverageFrom: [\r\n                '**\/lib\/sample\/getSample.js'\r\n                \r\n            ],\r\n            coverageDirectory: \"\/test-output\/coverage\",\r\n            coverageReporters: [\r\n                \"json\",\r\n                \"text-summary\",\r\n                \"cobertura\"\r\n            ],\r\n            reporters: [\r\n                \"default\",\r\n                \".\/common\/VcTestReporter\",\r\n                \"jest-junit\"\r\n            ],\r\n            setupFilesAfterEnv: [\".\/common\/setup.js\"],\r\n            testEnvironment: \".\/common\/VcTestEnv.js\",\r\n            testMatch: [\r\n                \"**\/__tests__\/**\/*.js\"\r\n            ],\r\n            testPathIgnorePatterns: [\r\n                \"__tests__\/aws.js\",\r\n               \r\n            ],\r\n            verbose: true,\r\n        }\r\n    ]\r\n};\r\n```\r\n","Can you try with `yarn` as well then? Maybe it's an issue with npm itself, try upgrading Node","I did a little more debugging and I could see that the exit code of the JEST execution (even when not run in `npm` context) is 1. \r\n```\r\n\r\n$node \/workspace\/vc\/vco\/src\/server\/node\/node_modules\/.bin\/jest --config=.\/jest.config.js\r\n\r\n<Runs all the tests successfully >\r\n\r\nTest Suites: 1 skipped, 106 passed, 106 of 107 total\r\nTests:       10 skipped, 657 passed, 667 total\r\nSnapshots:   15 files obsolete, 0 total\r\nTime:        24.668s, estimated 33s\r\nRan all test suites.\r\n\r\n\r\n$ echo $?\r\n1\r\n```","Anyway, without a repro there's nothing I can do. Please make sure you're on the latest version and try to come up with a minimal case by filtering out some tests until you get a correct exit code. ","I'm running into same issue, test passess successfully but jest returns status code 1 and npm errors.\r\n\r\n```\r\nPASS  src\/test\/restart.test.ts\r\n  \u221a restart (3438ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        5.298s, estimated 6s\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\n```\r\n\r\nNot sure if it's related but I'm using TypeScript and doing a async test with child processes and this seems so far to be the only case where I've encountered such behaviour. Though there seems to be no difference whether I'm running with ts-jest transform or directly against built js files. Oh and everything is updated to latest versions.","As an update to this, it also seems to fail with Yarn\r\n\r\n```\r\n PASS  src\/test\/restart.test.ts\r\n  \u221a restart (711ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        2.478s\r\nRan all test suites.\r\nerror Command failed with exit code 1.\r\n```\r\n\r\nSame thing happens to me as for OP, if I run Jest directly from `node_modules\/.bin\/jest` it run through successfully but when ran as npm script it returns exit code 1. Happens with both v24.x and v25.x.\r\n","Same issue here, any solutions?\r\n\r\n```\r\nTest Suites: 1 passed, 1 total\r\n--\r\n24-Mar-2020 18:09:46 | Tests:\u00a0 \u00a0 \u00a0 \u00a04 passed, 4 total\r\n24-Mar-2020 18:09:46 | Snapshots:\u00a0 \u00a01 obsolete, 1 passed, 1 total\r\n24-Mar-2020 18:09:46 | Time:\u00a0 \u00a0 \u00a0 \u00a0 4.2s\r\n24-Mar-2020 18:09:46 | Ran all test suites.\r\n24-Mar-2020 18:09:46 | npm ERR! code ELIFECYCLE\r\n24-Mar-2020 18:09:46 | npm ERR! errno 1\r\n24-Mar-2020 18:09:46 | npm ERR! @app\/front@ test:ci: `jest --ci`\r\n24-Mar-2020 18:09:46 | npm ERR! Exit status 1\r\n```\r\n\r\nEdit: Upgrading node to latest version solved the issue for me","Getting the same here pretty frequently when running in CI. It is intermittent but frequent enough to have started slowing things down.\r\n\r\n```\r\nTest Suites: 2 skipped, 233 passed, 233 of 235 total\r\nTests:       25 skipped, 1009 passed, 1034 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        721.58s\r\nRan all test suites.\r\nerror Command failed with exit code 1.\r\nerror Command failed with exit code 1.\r\nerror Command failed.\r\nExit code: 1\r\n```","Same issue here:\r\n\r\n```\r\nTest Suites: 14 passed, 14 total\r\nTests:       61 passed, 61 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        22.589s\r\nRan all test suites.\r\nerror Command failed with exit code 1. \r\n```\r\n\r\nDid you guys find a solution?\r\nThanks!","I'm seeing the same issue and now CI is failing all buddy builds.","Also getting this on our CI (Codeship):\r\n\r\n```\r\nTest Suites: 277 passed, 277 total\r\nTests:       1577 passed, 1577 total\r\nSnapshots:   206 passed, 206 total\r\nTime:        185.986s\r\nRan all test suites.\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! LeSalonApp@0.0.1 testNoCache: `jest --no-cache \"--maxWorkers=1\"`\r\nnpm ERR! Exit status 1\r\n```\r\n\r\nHere's the command being run:\r\n\r\n```\r\njest --no-cache \"--maxWorkers=1\"\r\n```\r\n\r\nJest 25.2.7\r\n\r\nWe are upgrading from React Native 59 to 61 which has brought a new Jest version with it.\r\n\r\nI'm going to try downgrading back to Jest 24 and see if tests pass again.","Same problem with yarn only v1.21.1 (jest v.25.2.3)","i fixed it changing `--runInBand` to `--maxWorkers=2` but i dont know the reason why it was failing.\r\n\r\nSolved: i needed to add `await` to `fireEvent` like `await fireEvent.press(button);`","I ran into this issue in two different ways while using ts-jest. I fixed both:\r\n\r\n1.) I left a `fit(` in my test suite. This for whatever reason was claiming that I had a pending test (rather than skipped). This caused npm to exit with an error code as 1.\r\n**Solution**: Removed the `f` that I accidentally left. This file was now fine and npm was exiting with exit code of 0.\r\n \r\n2.) I was using a nyan cat jest reporter (because why not?), while also having type-specific errors.\r\n**Solution**: I removed the nyan cat jest reporter and used the default reporter. This made the TypeScript related type errors show up. I specifically changed a `tsconfig.json` value (`noImplicitAny: true`) recently and had some errors but the nyan cat jest reporter was silencing these errors.","Got it. I had a couple of these:\r\n\r\n```\r\nReferenceError: You are trying to `import` a file after the Jest environment has been torn down.\r\n```\r\n\r\nwhich are probably down to bad mocks but I was just ignoring in previous versions of Jest.\r\n\r\nI narrowed down all my tests to a specific file and despite only 10 or so tests passing that log would appear and the tests would still exit with error.\r\n\r\nSo I guess the tests should be failing because of this bad error, but maybe a specific jest error would be better than just exit 1!\r\n\r\np.s. it was actually due to an old function using Promise.resolve().then() that was leaking out. The test was bad. I refactored to async\/await and made sure the test was also async","I was facing a similar issue using when I was running:\r\n\r\n```\r\njest --silent --runInBand --testPathPattern=index.spec\\\\.tsx$\r\n```\r\n\r\nWhich cause my tests to run, but the process was exiting with `exit code 1`. However, changing this to:\r\n\r\n```\r\njest --silent --maxWorkers=2 --testPathPattern=index.spec\\\\.tsx$\r\n```\r\n\r\n> i fixed it changing `--runInBand` to `--maxWorkers=2` but i dont know the reason why it was failing.\r\n> \r\n> Solved: i needed to add `await` to `fireEvent` like `await fireEvent.press(button);`\r\n\r\nAlso, possibly there is a misleading await on my code which can cause this problem. \ud83e\udd14 \r\n","This was a face palm moment, I was digging around the tests and code trying to find some sign of why our CI test script was not running. Then it hit me. We are using snapshot tests and maybe the test suite could not run due to not being able to execute the snapshots. After adding -u to our npm run test:ci script, this resolved the issue. \r\n\r\nI leave this here in case this saves someone some time in considering that maybe the script cannot execute the snapshots. ","@smith-xyz you should never run Jest with `-u` on CI. The generated snapshot may likely be wrong and your tests will still pass, giving you false sense of security.","@thymikee I was just looking at that and thinking the same thing after posting that comment. Is it best to only use snapshot tests outside of CI?","You can use snapshots on CI as well, but they need to be written to disk\/source control. When Jest runs next time (whether on dev machine or CI) it will recreate the snapshot and compare to the one that's supposed to be physically in the file system. The reason your CI may fail is because the files are not there (e.g. they were not added to source control, hence missing on CI).","I get the same error:\r\n\"jest\": \"^26.0.1\",\r\n\r\n```\r\nTest Suites: 17 passed, 17 total\r\nTests:       57 passed, 57 total\r\nSnapshots:   3 obsolete, 26 passed, 26 total\r\nTime:        13.062 s\r\nRan all test suites.\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! test@1.0.0 test: `jest`\r\nnpm ERR! Exit status 1\r\nnpm ERR!\r\nnpm ERR! Failed at the test@1.0.0 test script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\n```","I had the same problem, what worked for me was moving to an older build.\r\n\r\nI used jest@20.0.4 rather than current version\r\n\r\n`yarn add jest@20.0.4`\r\n\r\nLet me know if this works!","Yep downgrading to 20.0.4 worked for me as well.  Current version worked fine from the command line, but when run via NPM I got the ELIFECYCLE error. There where no tests created yet.\r\n\r\njest config from package.json\r\n\r\n```\r\n\"jest\": {\r\n        \"moduleFileExtensions\": [\r\n            \"js\",\r\n            \"json\",\r\n            \"ts\"\r\n        ],\r\n        \"rootDir\": \"src\",\r\n        \"testRegex\": \".spec.ts$\",\r\n        \"transform\": {\r\n            \"^.+\\\\.(t|j)s$\": \"ts-jest\"\r\n        },\r\n        \"coverageDirectory\": \"..\/coverage\",\r\n        \"testEnvironment\": \"node\"\r\n    }\r\n```\r\n\r\nNode v14.3.0\r\nNVM  0.35.3\r\nTypeScript 3.9.3\r\n","```Snapshots:   3 obsolete, 26 passed, 26 total```\r\n**obsolete** - are the cause of the error, after their removal, the error is gone.","I had a similar issue in my GH actions where all tests would pass but still exit 1.\r\n```\r\nTest Suites: 10 passed, 10 total\r\nTests:       38 passed, 38 total\r\nSnapshots:   0 total\r\nTime:        98.33s\r\nRan all test suites.\r\nnpm ERR! Test failed.  See above for more details.\r\n##[error]Process completed with exit code 1.\r\n```\r\nIt was all fine on my local machine.\r\nThe only thing I found that was different was the machine the test was running on in GH Actions.\r\nSo I changed my GH action `runs-on` from `ubuntu-latest` to `macos-latest` and no more exit code 1 \ud83c\udf89","> So I changed my GH action runs-on from ubuntu-latest to macos-latest and no more exit code 1 \ud83c\udf89\r\n\r\nAfter 3 hours of messing around I ended up using this.\r\n\r\n> Anyway, without a repro there's nothing I can do\r\n\r\nHappy to. Any criteria\/preferred structure? I can make a repo with a repro if that suits you.",">So I changed my GH action runs-on from ubuntu-latest to macos-latest and no more exit code 1\r\n\r\nSame experience on an Azure Pipeline build.","Same Here\r\nI've tested on:\r\nyarn: `1.22.4`\r\nnpm: `6.14.6`\r\nnode: `10.16.3`\r\nnode: `12.18.4`\r\nIn All Variantes, I've got exit code 1:\r\ncommand\r\n`.\/node_modules\/.bin\/jest --coverage`\r\n```\r\n    \"jest\": \"^25.5.4\",\r\n    \"jest-expo\": \"^38.0.2\",\r\n```\r\nalthough all test pass successfully:\r\n```\r\nTest Suites: 1 passed, 1 total\r\nTests:       10 passed, 10 total\r\nSnapshots:   0 total\r\nTime:        21.434s\r\n```\r\nWe've got some random errors from react-native packages, I think that some child process return errors and jest process follow the error.\r\n<details>\r\n<summary>Errors:<\/summary>\r\n<pre>\r\nReferenceError: You are trying to `import` a file after the Jest environment has been torn down.\r\n      at parseErrorStack (node_modules\/react-native\/Libraries\/Core\/Devtools\/parseErrorStack.js:52:26)\r\n      at Function.parse (node_modules\/react-native\/Libraries\/YellowBox\/Data\/YellowBoxWarning.js:40:16)\r\n      at registerError (node_modules\/react-native\/Libraries\/YellowBox\/YellowBox.js:206:60)\r\n      at errorImpl (node_modules\/react-native\/Libraries\/YellowBox\/YellowBox.js:96:25)\r\n      at CustomConsole.Object.<anonymous>.console.error (node_modules\/react-native\/Libraries\/YellowBox\/YellowBox.js:53:15)\r\n<\/pre>\r\n<\/details>","https:\/\/github.com\/facebook\/jest\/issues\/6434#issuecomment-647589824\r\n> I am using `react-native-testing-library` and what resolved this error for me was to simply make the callback of the test case `async` like\r\n> \r\n> ```ts\r\n> it('your test case', () => {...})\r\n> ```\r\n> \r\n> becomes:\r\n> \r\n> ```ts\r\n> it('your test case', async () => {...})\r\n> ```\r\n\r\nThis worked for me","I had the same issue.\r\nAfter debugging jest, i found a line in TestScheduler.js:\r\n```js\r\n  aggregatedResults.success = !(\r\n    anyTestFailures ||\r\n    aggregatedResults.snapshot.failure ||\r\n    anyReporterErrors\r\n  );\r\n```\r\n\r\nWhere `aggregatedResults.snapshot.failure` was true.\r\n\r\n**Deleting and recreating snapshots solved my problem** , because one of my snap files contained and unused entry.\r\n","In my case, it was a Typescript error, which was only alerted when I tried transpiling my project. Fixing it solved the problem.\r\n\r\nMore specifically, this was my error related to re-organizing some imports and modules:\r\n\r\n```console\r\nsrc\/api\/my_module.ts:3:10 - error TS2459: Module '\"..\/data\/another_module\"' declares 'SOME_VAR' locally, but it is not exported.\r\n\r\n3 import { SOME_VAR } from '..\/data\/another_module';\r\n           ~~~~~~~~\r\n\r\n  src\/data\/another_module.ts:4:10\r\n    4 import { SOME_VAR } from '..\/service\/actual_module_with_the_var';\r\n               ~~~~~~~~\r\n    'SOME_VAR' is declared here.\r\n```","Had this issue after upgrading RN to 0.63.3 from 0.61, it was actually caused by an outdated enzyme-adapter-react-16\r\nIt would seem that jest masks issues. that occur outside of individual tests.","@raldred how were you able to debug the issue with enzyme-adapter-react-16?\r\nI have the exact same problem also after upgrading from RN 0.61 to 0.63.3 but we don't have enzyme-adapter-react-16 in our node modules, it could be something else that is masked by Jest as well but we are struggling to find it.","my tests seem to fail if I have image snapshots (jest-screenshot) created on macos they fail inside docker. If I remove the snapshots and run the tests inside docker, no matter how many times I run the tests they will pass.","We are experiencing this too. Locally the tests are passing and the process is returning 0 (MacOS)\r\nBut on the GitLab CI (node:12.13.0) it is returning 1, even after all the tests passes with no diff in snapshots","In my case, it was due to not meeting the minimum coverage requirement. ","My tests are failing on CircleCI, same error... even though all tests are passing, I'm getting the same. Even trying to remove the `coverageThreshold`, it still fails \ud83e\udd14 \r\n\r\nI solved moving to Github Action and using `macos-latest` as described here: https:\/\/github.com\/facebook\/jest\/issues\/9324#issuecomment-643783847\r\n\r\nBut it's not feasible... running Github Actions with a macOS runner costs 10x than using the Linux runner. It's awesome there's a fix for this issue, but worth calling out the cost difference - you'll eat up your Github minutes much, much faster.\r\n\r\n**EDIT (Update):**\r\n\r\nSolved after bumping Node version on CircleCI to `circleci\/node:14-browsers`","I too ran into the same issue. But for me, it started working just after I removed the obsolete snapshot test. \r\nI removed the obsolete snapshot by running --updateSnapshot once in my local machine and then pushing the updated snapshot. \r\nPS: I am on ubuntu-latest ","maybe some error interrupt  the test case,  for example \r\n``` javascript\r\nexpect(current.value).toEqual(true)\r\n```\r\nif the ```current``` is undefined, will cause this problem\r\n\r\nto solve this problem, to make sure ```current``` is valid or use ```try...catch...```to wrap the ```expect``` statement","I was facing the same situation which - in my case - I could also pin down to this error: \r\n\r\n```\r\nReferenceError: You are trying to `import` a file after the Jest environment has been torn down.\r\n```\r\n\r\nFollowing the solution of [this StackOverflow thread](https:\/\/stackoverflow.com\/questions\/60781238\/referenceerror-you-are-trying-to-import-a-file-after-the-jest-environment-has) I was able to make the error disappear and as a result the exit code is now `0` - both locally as in CI\/CD by simply changing `testEnvironment: 'node'` to `testEnvironment: 'jsdom'`.\r\n\r\nNote using ``testEnvironment: 'jsdom'` comes with some other potential caveats so it might not be a workable solution for everyone. I feel there's still an underlying problem in Jest that needs be resolved.\r\n","> I had the same issue.\r\n> After debugging jest, i found a line in TestScheduler.js:\r\n> \r\n> ```js\r\n>   aggregatedResults.success = !(\r\n>     anyTestFailures ||\r\n>     aggregatedResults.snapshot.failure ||\r\n>     anyReporterErrors\r\n>   );\r\n> ```\r\n> \r\n> Where `aggregatedResults.snapshot.failure` was true.\r\n> \r\n> **Deleting and recreating snapshots solved my problem** , because one of my snap files contained and unused entry.\r\n\r\nYear, it works for me, thx.","I had this issue, and the fix was to remove unused snapshots.\r\n\r\nThe problem for me was that `jest-silent-reporter` is a little too silent; it doesn't print the \"obsolete snapshots\" message. :smile:","\r\n> It was all fine on my local machine. The only thing I found that was different was the machine the test was running on in GH Actions. So I changed my GH action `runs-on` from `ubuntu-latest` to `macos-latest` and no more exit code 1 \ud83c\udf89\r\n\r\nDid work for React Native project well. You lifesaver. Spend for this whole working day.","Hi everyone\r\n\r\nDid you use `forEach` + `async\/await` in your tests?\r\n\r\nI have resolved this issue, use `for await...of` instead `forEach`\r\n\r\n![CleanShot 2021-11-01 at 22 28 00@2x](https:\/\/user-images.githubusercontent.com\/17308201\/139679191-d4536a97-44e3-4ca3-82e5-2bf6c8c1b75a.jpg)\r\n\r\nref:\r\nhttps:\/\/stackoverflow.com\/a\/54751807\/5847276","I bumped into a similar issue today, and I had such a dumb setup mistake that I wanted to share how I fixed it.\r\n\r\n<img width=\"1097\" alt=\"Screen Shot 2021-12-15 at 12 37 31\" src=\"https:\/\/user-images.githubusercontent.com\/7268262\/146248215-3077ecbf-70cb-4b09-b255-105394a009f9.png\">\r\n\r\nMy project didn't hit the coverage benchmarks, and it broke the pipeline even without failing tests.","### \r\n\r\n> I bumped into a similar issue today, and I had such a dumb setup mistake that I wanted to share how I fixed it.\r\n> \r\n> <img alt=\"Screen Shot 2021-12-15 at 12 37 31\" width=\"1097\" src=\"https:\/\/user-images.githubusercontent.com\/7268262\/146248215-3077ecbf-70cb-4b09-b255-105394a009f9.png\">\r\n> \r\n> My project didn't hit the coverage benchmarks, and it broke the pipeline even without failing tests.\r\n\r\nJust use yarn instead of npm, and use --silent with yarn and it won't show the error","Another case I've found is that jest will return an exit code of 1 if any logging happens after teardown.","I found that run `npx jest --coverage` in the command line tool will be success without this exit code, but when I write `test: jest --coverage` into package.json and run command `npm run test`, this error happens. So could it be a problem of npm or somewhat the communication between jest and npm?\r\nIn my case, current npm version is 6.x.x, then I upgrade npm version one by one to test this error\u3002The error disappears since version @7.5.6 .","I got the same issue with jest and puppeteer, but I found the page error triggers the jest test empty error.\r\nThings like the follow:\r\n`message:'TypeError: $(...).tooltip is not a function\\n    at Object.init (http:\/\/x.x.x.x\/bg.js`","> So I changed my GH action runs-on from ubuntu-latest to macos-latest and no more exit code 1\r\n\r\nThanks! This solved my problems.\r\n\r\nI still don't know what caused the issue and I'd like to find out, but at least now I can move forward with using Github Actions. For what it's worth, I did not have this issue running the same specs using Bitbucket's pipelines.","> \r\n\r\nBe aware that the mac os image spends 10x more credits. Later I did revert to Ubuntu and it worked again. Still do not know what was causing this issue.","We still see this sometimes.   \r\nMost recently when we were changing EC2 instance types. for example...   \r\nRunning on a `c6i.large` (2vCPU) tests would complete successfully but jest exits with 1.  \r\nThe same running on a `c6i.xlarge` (4vCPU) would complete and exit correctly with 0.\r\n\r\n","I'm facing the same error. Both in local and in AWS EC2. Any definitive solution was identified?\r\n\r\n```bash\r\nnpm verb lifecycle my-package@1.0.0~test:local: unsafe-perm in lifecycle true\r\nnpm verb lifecycle my-package@1.0.0~test:local: PATH: \/Users\/me\/.nvm\/versions\/node\/v14.19.0\/lib\/node_modules\/npm\/node_modules\/npm-lifecycle\/node-gyp-bin:\/Users\/me\/my-repo\/node_modules\/.bin:\/Users\/me\/.sdkman\/candidates\/kotlin\/current\/bin:\/Users\/me\/.sdkman\/candidates\/java\/current\/bin:\/Users\/me\/.sdkman\/candidates\/gradle\/current\/bin:\/Users\/me\/.nvm\/versions\/node\/v14.19.0\/bin:\/opt\/homebrew\/bin\/:\/opt\/homebrew\/var\/mysql:\/opt\/homebrew\/opt\/mysql@5.7\/bin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/usr\/sbin:\/sbin\r\nnpm verb lifecycle my-package@1.0.0~test:local: CWD: \/Users\/me\/my-repo\r\nnpm info lifecycle my-package@1.0.0~test:local: Failed to exec test:local script\r\nnpm verb stack Error: my-package@1.0.0 test:local: `NODE_ENV=testlocal npx jest --runInBand --detectOpenHandles`\r\nnpm verb stack Exit status 1\r\nnpm verb stack     at EventEmitter.<anonymous> (\/Users\/me\/.nvm\/versions\/node\/v14.19.0\/lib\/node_modules\/npm\/node_modules\/npm-lifecycle\/index.js:332:16)\r\nnpm verb stack     at EventEmitter.emit (events.js:400:28)\r\nnpm verb stack     at ChildProcess.<anonymous> (\/Users\/me\/.nvm\/versions\/node\/v14.19.0\/lib\/node_modules\/npm\/node_modules\/npm-lifecycle\/lib\/spawn.js:55:14)\r\nnpm verb stack     at ChildProcess.emit (events.js:400:28)\r\nnpm verb stack     at maybeClose (internal\/child_process.js:1058:16)\r\nnpm verb stack     at Process.ChildProcess._handle.onexit (internal\/child_process.js:293:5)\r\nnpm verb pkgid my-package@1.0.0\r\nnpm verb cwd \/Users\/me\/my-repo\r\nnpm verb Darwin 21.3.0\r\nnpm verb argv \"\/Users\/me\/.nvm\/versions\/node\/v14.19.0\/bin\/node\" \"\/Users\/me\/.nvm\/versions\/node\/v14.19.0\/bin\/npm\" \"run\" \"test:local\" \"--verbose\"\r\nnpm verb node v14.19.0\r\nnpm verb npm  v6.14.16\r\nnpm ERR! code ELIFECYCLE\r\nnpm ERR! errno 1\r\nnpm ERR! my-package@1.0.0 test:local: `NODE_ENV=testlocal npx jest --runInBand --detectOpenHandles`\r\nnpm ERR! Exit status 1\r\nnpm ERR! \r\nnpm ERR! Failed at the my-package@1.0.0 test:local script.\r\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\r\nnpm verb exit [ 1, true ]\r\nnpm timing npm Completed in 76499ms\r\n```","In my case what happened was that I got `Cannot log after tests are done. Did you forget to wait for something async in your test?` errors, but that didn't cause Jest to exit with code 1 anywhere, except my CI. I finally realized that my CI is probably running on a single CPU so I ran locally with --runInBand and eureka, jest fails locally as well. Now I gave the error some meaning and indeed it was the one causing Jest to fail. The bug here was that when running non in bad, it does not cause a filaure... I will open a new bug for that","facing same issue, works locally but fails on gh actions\r\n![image](https:\/\/user-images.githubusercontent.com\/84702365\/167294342-a34f7a8b-1d74-4857-aa00-b1d9f06b1b52.png)\r\n","well fixed this by changing  `runs-on` to `macos-latest` and switching back to `ubuntu-latest` after one successful run","Experienced similar issue with Jest 27.1.0 on GitLab CI. \r\n\r\n    npx jest --ci --coverage --runInBand --colors\r\n\r\nFixed with adding `--silent` flag.\r\n\r\n    npx jest --ci --coverage --runInBand --colors --silent\r\n","I just run into this problem. My case was the coverage failed to generate but Jest didn't show the error. I added this to jest config:\r\n\r\n```json\r\n\"coverageReporters\": [\"lcov\"]\r\n```\r\n\r\nAnd it show me the file that it has trouble with.","I also get `ERR! Exit status 1` on `Jest: \"global\" coverage threshold for branches (XX%) not met: XX.X%`. So, for this case the solution is to increase the test coverage by implementing tests for the uncovered lines. Definitely using `--silent` doesn't seem to be a good solution. ","Hi there,\r\n\r\nNot a jest \/ node \/ npm expert here, but my contribution might help some folks following this issue.\r\n\r\nI ran into pretty much the same problem on my Gitlab CI environment (using docker executor and `node:18-bullseye` image).\r\n\r\nI noticed that clearing manually my runner cache before running the pipeline was fixing the issue. However, the error showed up again on the next pipeline execution (of course...)\r\nAfter trying to remove unsuccessfully everything related to npm\/jest cache, I finally set the `GIT_STRATEGY` GitlabCI variable to `clone` for my job : it worked.\r\n\r\nIt's seams to be related to the default gitlab clone strategy (`fetch`) which do not provide a sufficient clean environment for jest execution.","I met the same error, and then  the command `jest --detectOpenHandles` told me more details about failed reasom\r\n```\r\n# package.json\r\n{ \r\n scripts: {\r\n  \"test\": \"jest --detectOpenHandles \"\r\n}\r\n}\r\n\r\n```\r\nhttps:\/\/jestjs.io\/zh-Hans\/docs\/cli#--detectopenhandles","Reproduction: https:\/\/gitlab.com\/MatrixAI\/open-source\/typescript-demo-lib-native\/-\/jobs\/2733478190.\r\n\r\nThat shows all tests pass, but then the command fails. Only affects Windows systems.","I just spent a bunch of time debugging this. For me, this was caused by the `Cannot log after tests are done. Did you forget to wait for something async in your test?` error. Quite confusingly, this often didn't reproduce locally, but only on CI.\r\n\r\nMy working theory is that the last test in one of our suites kicks off a promise to make a request, but then the test completes before that promise executes. We're using MSW to mock requests, but MSW gets cleaned up because the suite is complete, so a real request is made to a real server rather than being intercepted.\r\n\r\nHere is the issue that's tracking this case. https:\/\/github.com\/facebook\/jest\/issues\/11132 IMO it's a very bad user experience to have no tests fail, but exit with a non-0 code. If logging after cleanup is really so bad that it constitutes a failing exit code, we should at least be able to link it back to the test that causes the problem and retroactively fail it. ","@chrisgarber I had a similar theory about this. But in this case, it only occurs on the windows platform in my CI\/CD. I looked into this https:\/\/nodejs.org\/api\/process.html#a-note-on-process-io, and made a note about it here in our logger https:\/\/github.com\/MatrixAI\/js-logger\/issues\/22.\r\n\r\nDo you think windows asynchronous logging could also introduce situations where logging is done after tests are done? Then maybe that could also cause non-0 exit codes.","@CMCDragonkai I don't know too much about the internals of logging in js, but certainly if you were writing to logs in a promise that wasn't awaited you would see this issue. I'd check the outputs from your CI to see if you get that message. Another thing to try, if you've managed to nail down the offending test(s) is to just await a few second timeout to let the async things resolve before the test completes. It goes without saying that such a thing is unacceptable in the long run, but I did manage to use this technique to isolate which test was giving me problems and get my tests green (if 2 seconds slower)","In my case it only occurring on windows: https:\/\/gitlab.com\/MatrixAI\/open-source\/typescript-demo-lib\/-\/jobs\/2793772454 (see that all tests pass, even coverage report is outputted, but it still says a failed job because of the exit code).\r\n\r\nI've done what you suggested added 2 second sleep.\r\n\r\nBut I still think windows async logging could be a possibility https:\/\/github.com\/MatrixAI\/js-logger\/issues\/22","I added the sleep in, and there you go https:\/\/gitlab.com\/MatrixAI\/open-source\/typescript-demo-lib\/-\/jobs\/2794872538 the tests pass now.\r\n\r\nI believe this has to do with the fact that `process.stdout.write` and `process.stderr.write` is asynchronous on Windows.\r\n\r\n---\r\n\r\nTo clarify I found out that during jest tests, the stdio is actually pipes, not TTYs. According to node core libraries, this would mean that stdio is actually blocking on Windows, while being non-blocking on Linux\/MacOS. See: https:\/\/github.com\/nodejs\/node\/discussions\/25691.\r\n\r\nSo at this point I'm not sure if this what is causing the weirdness.\r\n\r\nBut certainly at this point, with jest failing due to this, there just has to be a way to disable jest exiting with a non-exit status code just because logs are output later.","I also meet the problem. The jest show all tests is passed, however it return the exit code to 1 so it make my CI machine failed (this situation is appear mostly on CI machine and difficult to reproduce when running test on local). Also the error log can not help me to find the cause of the problem, I have no ideal how to handle this occasional fail test situation on my CI machine.\r\n\r\nP.S. The error message `Cannot log after tests are done. Did you forget to wait for something async in your test? ` show occasionally make the exit code return 1 and fail the CI machine process when running test.","My case:\r\n```\r\njest --all --bail --ci --watchAll=false --runInBand --collect-coverage\r\n```\r\n**Issue**:\r\n```diff\r\nTest Suites: 75 passed, 75 total\r\nTests:       338 passed, 338 total\r\nSnapshots:   77 passed, 77 total\r\nTime:        108.612 s\r\nRan all test suites.\r\nerror Command failed with exit code 1.\r\ninfo Visit https:\/\/yarnpkg.com\/en\/docs\/cli\/run for documentation about this command.\r\n-Error: Process completed with exit code 1.\r\n```\r\n**Solution:**\r\nAdding `jest.useFakeTimers()` solved my problem.\r\n","Like others in this thread, my exit code 1 was coming from the following error:\r\n\r\n`ReferenceError: You are trying to 'import' a file after the Jest environment has been torn down.`\r\n\r\nShouldn't a ReferenceError cause a test failure?  Other kinds of uncaught errors cause test failures, which is really nice, because then we know what test they're coming from.  Currently, the test registers as a `PASS`, which I don't think is accurate.\r\n\r\nIn our case, having hundreds of tests and a noisy console, this was time-consuming to diagnose.  Is there a test runner setting we can use to fail on this kind of throw?\r\n\r\nEDIT: okay I think I get this better now.  The test runs and passes, and then something in the component runs later, after the test has torn down.  That causes the suite to error out.\r\n\r\nNEW REQUEST: is there any way to make the error better?  It doesn't sound like it has anything to do with the imports.","For me worked by adding `--verbose` at the run command.","> So I changed my GH action runs-on from ubuntu-latest to macos-latest and no more exit code 1 \ud83c\udf89\r\n\r\nAfter couple of hours working on it this solution also worked for me.","A lot of people have already pointed out but let me summarize a quick answer to a new visitor on this thread.\r\n\r\n- Tests fail on the CI due to a single worker process (in GitHub Actions in my case) which is not the case in our local machines. Try adding `maxWorkers=2` to your test script and the tests will pass on the CI without changing the machine from `ubuntu-latest` to `macos-latest`.\r\n- To know the exact reason why the tests fail on the CI try adding `--runInBand` to your test script and you will see it locally returning an exit status code of 1 as well.","There is an additional issue when there's a obsolete snapshot just exits with code of 1.\r\n\r\nCould repetitively fail test build on CI, until I removed obsolete snapshot. There was already one issue reported before but without solution being **merged**. Can someone add at least an error message when an obsolete snapshot is the reason for just exiting with status of 1? - https:\/\/github.com\/facebook\/jest\/issues\/12564\r\n@domsli ","@DamianArado `maxWorkers=2` does the trick, thanks!","Hello! Same problem here!\r\n\r\nReact: 18.2.0\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@testing-library\/user-event\": \"13.5.0\",\r\n    \"react-scripts\": \"5.0.1\",\r\n  },\r\n  \"devDependencies\": {\r\n    \"@testing-library\/jest-dom\": \"5.16.5\",\r\n    \"@testing-library\/react\": \"13.4.0\",\r\n  }\r\n}\r\n```\r\n\r\nJust FYI: Solved after noticing that I was using an old version of Node and NPM (via NVM) that I was using for an ongoing project (Node 14). Switched to Node 18 LTS and it worked perfectly with the `react-scripts test --watchAll=false` script","I encountered the same issue. Tried to add and remove async-await in my code but it still didn't work. After reading the consoles that I put, I realized that the data that should contain something was empty. After some digging, it turned out that the mock data was written as `suborders` where it should be `subOrders`. After I fixed that, the build succeeded.....","For us, this issue presented after upgrading to Node.js 18 and adopting npm 8. A successful exit status code when run via `npm` was only found after disabling coverage reporting \ud83d\ude11\r\n\r\nI then identified that the `collectCoverageFrom` pattern was the cause. Not sure what was wrong with it, or why it'd stop working after a Node.js upgrade though \ud83e\udd37\ud83c\udffb\u200d\u2642\ufe0f\r\n\r\n```\r\ncollectCoverageFrom: ['<rootDir>\/src\/**\/*.ts'],\r\n```\r\n\r\nSimply removing this configuration resolved the issue. Coverage just includes some unnecessary files now. I couldn't figure out how to make it happy with a pattern specified.","I'm facing this issue also.\r\n\r\nNode 16.18.1\r\nYarn 1.22.4\r\nJest 27.4.3\r\n\r\n<img width=\"858\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/26110369\/202908657-80dbe5f0-c4c5-4327-9f79-aef1e2554813.png\">\r\n","It happens to me as well. You can look my actions and project on the URL below:\r\n\r\nhttps:\/\/github.com\/trouchet\/sappio\/actions","@tiennguyen1293 @brunolnetto you can run jest silently, save the output somewhere, read it and then exit 1 or 0 depending on the result.","I don't get it. It does not seem the proper approach. I will wait.","Adding async await inside the test solved this issue for me","...If we only knew, *where* to add async\/await","Getting exist status 1 on semaphore CI, OS ubuntu2004 every time on the first execution of the test.\r\n\r\nAll PASS, but the process finishes with error 1.\r\nThe tests run with coverage, otherwise all ok.\r\n\r\nThe second run is ok. \r\nMacOS local tests are ok.\r\n\r\nrunInBand\/maxWorkers don't help. ","During the research, I found that tests do succeed.\r\n\r\nThen, during coverage, there's no call of \"process.exit(1)\", but rather something inside jest returns 1 \"normally\".\r\n\r\nWhat can it be? How to debug it?","I am not the one who likes to point fingers, but it would be nice if you point out the code base fragment of this \ud83d\udd96\ud83c\udffd unlogic behavior.","I'm not deep enough in the code. The error doesn't reproduce on my local Mac, only on Semaphore CI testing.","Well, many languages have the expression: \r\n\r\nPortuguese: \"O que os olhos n\u00e3o v\u00eaem, o cora\u00e7\u00e3o n\u00e3o sente.\"\r\nSpanish: \"Ojos que no ven, coraz\u00f3n que no siente\"\r\nFrench: \"loin des yeux, loin du c\u0153ur\"\r\nEnglish: \"Out of sight, out of mind\"\r\nGerman: \"Was ich nicht wei\u00df, macht mich nicht hei\u00df\"\r\nRussian: \"\u0421 \u0433\u043b\u0430\u0437 \u0434\u043e\u043b\u043e\u0439, \u0438\u0437 \u0441\u0435\u0440\u0434\u0446\u0430 \u0432\u043e\u043d\"\r\n","If someone from jest team would like to take a deeper look, I can contribute and go deeper.\r\n\r\nI'm glad this error doesn't bother you any more, @brunolnetto .","I do not discard the hypothesis of mangled use case on jest library. My common debugging workflow is try to traceback working commits, understand the changes, reproduce locally, cut down accordingly to its dependencies and submit experimental commits. It worked for me sofar.","@shousper fixed my problem with [their comment](https:\/\/github.com\/facebook\/jest\/issues\/9324#issuecomment-1319514254)\r\n\r\nI was ignoring coverage from generated files, but there was a file being tested that included those other files. It spits out a more reasonable (thought not completely self-explanatory) error when you run it locally instead of in CI.","Solution in my case: \r\n\r\n1) Find an error in the log: \"Cannot log after tests are done. Did you forget to wait for something async in your test?\"\r\n2) Find a test which produce the error and change \"async await\" logic to \"Promise\" and finish the test by calling \"done()\" command.\r\n\r\nhttps:\/\/youtu.be\/m-v_cXLGhEg\r\nhttps:\/\/habr.com\/ru\/post\/710342\/](https:\/\/habr.com\/ru\/post\/710342\/","I have this same issue after upgrading from jest 27.5.1 to 28.1.1\r\nnode 18.12.1","My fix was by adding:\r\n`\"coverageReporters\": [\r\n            \"text-summary\",\r\n            \"lcov\"\r\n        ]`\r\nto my jest configuration","My recommendation with Jest based on my experience is: keep it on essentials and don't make more hypothesis than you can test. The latest jest version has many features which allows clean and short test cases without entering the library organization itself.","Just chiming in with my organization's own issue with this on a Create React App instance.\r\n\r\nAfter upgrading to React 18.x, and upgrading Jest correspondingly, our test suite running on GitHub Actions began failing with a non-zero exit code despite passing all tests.\r\n\r\nWe couldn't reproduce this locally, and were unable to get to the bottom of what the issue even was after hours of investigation. It wasn't even cleanly reproducible in CI: it _usually_ failed this way, but not always.\r\n\r\nGiven all of that, it might literally just be a GitHub Actions thing \u2013 but chiming in all the same.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/714017\/231866458-d249f2d8-fe29-4f5c-9b83-7940b27a1576.png)\r\n","I've encountered the same variation as @shousper above https:\/\/github.com\/jestjs\/jest\/issues\/9324#issuecomment-1319514254\r\n\r\nWe have two options to fix it:\r\n- remove `collectCoverageFrom` as suggested by @shousper\r\n- add `coverageProvider: 'v8'` - if you cannot afford to remove `collectCoverageFrom`","npm i --save-dev jest\r\nnpm ERR! code EJSONPARSE\r\nnpm ERR! file \/home\/coder\/project\/learn\/jest-testing\/package.json\r\nnpm ERR! JSON.parse Failed to parse json\r\nnpm ERR! JSON.parse Unexpected string in JSON at position 169 while parsing '{\r\nnpm ERR! JSON.parse   \"name\": \"jest-testing\",\r\nnpm ERR! JSON.parse   \"version\":'\r\nnpm ERR! JSON.parse Failed to parse package.json data.\r\nnpm ERR! JSON.parse package.json must be actual JSON, not just JavaScript.\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\nnpm ERR!     \/home\/coder\/.npm\/_logs\/2023-05-27T13_01_50_769Z-debug.log","Faced the same issue on GHA. Change the runner from `ubuntu-latest` to `macos-latest` worked. \r\nBut I am afraid to use this fix in the long run, because of the 10x cost.  ","In my case the problem was that it was logging outside of the test suite. https:\/\/github.com\/jestjs\/jest\/pull\/10728\r\n\r\nThe message was logged but it was in the middle of all the execution so it was hard to see.\r\n","New cause discovered today: TypeScript compilation errors aren't reported by `jest` (through `ts-jest` I guess?) but will report an exit status code of 1, even if all tests pass \ud83d\udc4d\ud83c\udffb","In my case, it was just related to code coverage falling under the defined thresholds in jest config. In our case, I just lowered those thresholds to the actual values and everything worked fine.","In my case it was also doing something after an environments was torn down. Worth noticing - test itself is `successful`\r\n<img width=\"1355\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/1764195\/b06849fd-4f16-4d95-a1e0-23b3c560ed62\">\r\n\r\nBut it is not clear that it is a problem since there is no message in the end with a Summary of all errors:\r\n<img width=\"803\" alt=\"image\" src=\"https:\/\/github.com\/jestjs\/jest\/assets\/1764195\/a5cba1d9-33b9-4278-9fdd-63602c6df789\">\r\n\r\nSolution - fix all instances where you perform actions after an environment is torn down. This finally allowed CircleCI to succeed in building the project.\r\n","**If you are using Node.js 20.x**, ensure nothing in your tested code is setting the `process.exitCode` property to non-zero.\r\n\r\nThis makes any version of Jest fail, even when all tests are passing. This is being tracked here: https:\/\/github.com\/jestjs\/jest\/issues\/14501","#14501 got closed...? What's the work around here? We cannot set the `exitCode`? We need to do this because we want to let the program finish gracefully while setting a custom exit code.","#14619 may fix this for a number of people who are hitting errors during the coverage step that are being silently swallowed today.","> Solution in my case:\r\n> \r\n> 1. Find an error in the log: \"Cannot log after tests are done. Did you forget to wait for something async in your test?\"\r\n> 2. Find a test which produce the error and change \"async await\" logic to \"Promise\" and finish the test by calling \"done()\" command.\r\n> \r\n> https:\/\/youtu.be\/m-v_cXLGhEg [https:\/\/habr.com\/ru\/post\/710342\/](https:\/\/habr.com\/ru\/post\/710342\/](https:\/\/habr.com\/ru\/post\/710342\/%5D(https:\/\/habr.com\/ru\/post\/710342\/)\r\n\r\nThank you. This is the actual issue. Found some async methods called without awaiting and got the same error. Same test suite worked in older versions and got this error after upgrading node, jest, typeorm to latest."],"labels":["Needs More Info :man_shrugging:"]},{"title":"Documentation in regards to Test Environment","body":"## \ud83d\ude80 Feature Proposal\r\n\r\n_(Possibly not a feature proposal, but also not a bug per se)_\r\n\r\nHaving recently invested time in understanding Jest properly, one of the hardest concepts to understand was the term \"test environment\". This was especially hard in relation to these configuration options:\r\n\r\n```javascript\r\nglobalSetup: '.\/globalSetup.js',\r\nglobalTeardown: '.\/globalTeardown.js',\r\ntestEnvironment: '.\/myTestEnvironment',\r\nsetupFiles: ['.\/setupFiles'],\r\nsetupFilesAfterEnv: ['.\/setupFilesAfterEnv'],\r\n```\r\n\r\nFor reference, it is good to explain some terminology:\r\n\r\n**test file** `testA.test.js`\r\n**test case** `test() # or it()`\r\n**test suite**  `describe()` (I am not sure this is true. Reason is that the documentation seems to use the word \"test file\" and \"test suite\" interchangeably but actually always mean \"test file\". Never seen describe() referred specifically to \"test suite\" in the Jest documentation, so maybe it isn't a test suite?)\r\n\r\n### The problem I had with the documentation\r\n\r\nIf we take these terms, together with the \"test environment\" term and the above configuration options, I found some parts of the documentation ambiguous.\r\n\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#setupfiles-array\r\n\r\n> Since every test runs in its own environment,\r\n\r\n**Concern:** It should probably say \"every test file\" instead of \"every test\". Refer to terminology above.\r\n\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#setupfilesafterenv-array\r\n\r\n> A list of paths to modules that run some code to configure or set up the testing framework before each test.\r\n\r\n**Concern:** It should probably say \"before each test file\" instead of \"before each test\". Refer to terminology above.\r\n\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#globalsetup-string\r\n\r\n> This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites.\r\n\r\n**Concern:** Not sure what to write here, but \"before all test suites\" can be interpreted in various ways as a test suite _can be considered_ a `describe()` block.\r\n\r\n### Solution proposal\r\n\r\nIt would be good to go through both the [Configuring Jest](https:\/\/jestjs.io\/docs\/en\/configuration) and [Jest CLI Options](https:\/\/jestjs.io\/docs\/en\/cli) documentation, and possible all other docs, to align this properly.\r\n\r\nI also think that in general, having a completely specific section (possibly as a guide) describing what a test environment is and how it relates to the above specified configuration options would be great. The way I learnt was to setup a project and testing all these files with a bunch of console.log to actually see what happened.\r\n\r\n## Motivation\r\n\r\nTo make it easier for newcomers to understand Jest and how to extend its functionality.\r\n\r\n## Pitch\r\n\r\nIt belongs in the main Jest documentation as that is what users refer to when learning Jest.\r\n","comments":["I think we should use the unambigious terms 'test file' and 'test case', and only those terms. 'Test suite' is way too ambigious. 'Describe block' would be fine if we need that terms somewhere as well.\r\nAlso happy to take PRs improving the test environment section of the configuration page - we could consider moving that into a \"Creating test environments\" guide as it's quite extensive already.","@jeysal Would you say 'test file' is equal to 'test environment'? It is kind of a rhetorical question from my side, as each test file does run in it's own environment. So they are 1-to-1 if I understood all this correctly. The documentation often use both terms, but I think that in some cases it is more correct to use one over the other, but I am not sure exactly where to distinguish there. I am not sure it is even possible to strictly define these two to know when to use which one.","Clear no on that, it's n test files to 1 test environment - [this](https:\/\/github.com\/facebook\/jest\/blob\/9ac2dcd55c0204960285498c590c1aa7860e6aa8\/packages\/jest-environment-jsdom\/src\/index.ts) is a test environment, and [this](https:\/\/github.com\/facebook\/jest\/blob\/9ac2dcd55c0204960285498c590c1aa7860e6aa8\/packages\/expect\/src\/__tests__\/toEqual-dom.test.js) is a test file running in that environment.","I am confused, how can multiple test files run in one environment? E.g. https:\/\/jestjs.io\/docs\/en\/configuration#setupfilesafterenv-array specifies that it is \"installed in the environment\" and the files specified there are definitely run once per test file. If what you are saying are true, then I must have misread the docs in multiple places. Also https:\/\/jestjs.io\/docs\/en\/configuration#testenvironment-string clearly states \"You can create your own module that will be used for setting up the test environment.\" which means it will be setup one per file i.e. creating one environment per file (even though that environment specifically can be a JSDom environment \"type\").\r\n\r\nI understand JSDom is one environment, but the environment is setup multiple times per test file i.e. creating \"one environment per test file\". What am I missing? ","I think you do get it right, it's just another case of wording ambiguity. The environment is indeed instantiated once per test file.","@jeysal Great, thanks for clarifying. Let's see if I or someone else steps in as a hero and tries to make it slightly less confusing in the docs.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","unstale","The bot runs every 10 minutes, doesn't react to the comment event \ud83d\ude42 \r\n\r\nBut yes, we should explain this better","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not sure if we should close this or not. The comments are relevant, but I don't have time to fix them and not sure others have either.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Help Wanted","Documentation :book:","Pinned"]},{"title":"Jest gives no indication that test fails because of unhandled promise rejection.","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nWhen Jest fails a test for what it thinks - wrongly - is an unhandled rejection, it does not indicate this at all.\r\n\r\n## To Reproduce\r\nThis code in a test module causes Jest to wrongly think a promise rejection isn't going to be handled.\r\n```\r\ndescribe(\"whatever\", () => {\r\n  it(\"fails for no reason\", async () => {\r\n    const p = Promise.reject(new Error(\"Shouldn't fail the test\"));\r\n    await new Promise(r => setTimeout(r, 100));\r\n    await expect(p).rejects.toMatchObject({\r\n      message: \"Shouldn't fail the test\",\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n FAIL  src\/test\/plugging-in.test.ts\r\n  DeviceManager - plugging and unplugging\r\n    \u25cb skipped becomes useful after being plugged in\r\n  whatever\r\n    \u00d7 fails for no reason (12ms)\r\n\r\n  \u25cf whatever \u203a fails for no reason\r\n\r\n    an error message\r\n\r\n      90 | describe(\"whatever\", () => {\r\n      91 |   it(\"fails for no reason\", async () => {\r\n    > 92 |     const p = Promise.reject(new Error(\"an error message\"));\r\n         |                              ^\r\n      93 |     await new Promise(r => setTimeout(r, 100));\r\n      94 |     await expect(p).rejects.toMatchObject({\r\n      95 |       message: \"an error message\",\r\n\r\n      at Object.it (src\/test\/plugging-in.test.ts:92:30)\r\n\r\nTest Suites: 1 failed, 1 total\r\nTests:       1 failed, 1 skipped, 2 total\r\nSnapshots:   0 total\r\nTime:        4.355s, estimated 6s\r\nRan all test suites matching \/plugging-in\/i with tests matching \"whatever\".\r\n\r\n```\r\nNote that nothing in the output conveys the real reason this test failed.\r\n\r\n## Expected behavior\r\n\r\nSomething in the output says that Jest failed the test because it can't guarantee that the promise rejection will be handled. For instance, instead of:\r\n\r\n```\r\n\r\n     an error message\r\n\r\n```\r\n\r\nsomething like:\r\n\r\n```\r\n    Unhandled Promise Rejection:\r\n    an error message\r\n```\r\n","comments":["A workaround for others encountering this problem, or rather, a work around for the difficulty of Jest not liking unhandled rejections:\r\n\r\n```\r\n\/**\r\n * A function to wrap the Promise constructor such that no rejections are considered unhandled\r\n * by either Node or Jest. Whatever handlers can still be attached and rejections turned into\r\n * thrown exceptions where ever the returned promise is awaited.\r\n *\/\r\nfunction makePromise(callback) {\r\n  const promise = new Promise(callback);\r\n  promise.catch(()=>{});\r\n  return promise;\r\n}\r\n","Oh wow ok I've just spent far too long trying to figure out *how* Jest was even seeing the error it was reporting. Really could do with jest saying *something*, anything, about how it caught the error. Unhandled error\/rejection bugs can be subtle and hard to track down, and often appear when you end up with the worst case async scenario where code is unintentionally executing in the background that can't be sequenced and errors can't be handled. Having just show the error without indicating how it found the error was very confusing, especially since it seems to override\/ignore any unhandled rejection\/exception handlers you add in test.","@JoeLangewayClear's workaround will suppress these errors, but it's kind of like disabling the _engine fault_ light in your car and claiming you \"fixed it\"\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/43438\/86831594-154fc280-c065-11ea-8413-4a62e14737ab.png)\r\n","I would also like to add that the problem here is not only \"no indication\", but also the fact that the test fails: I was writing a test for utility function and I need to test that this function handles both successful and failing callbacks passed to it.\r\nSeems like the \"negative\" test fails for me anyway, even with `expect(promise).rejects....`, try\/catch.\r\n\r\nP.S.\r\nAlso if I add `const promise = Promise.reject('aaaa')` to the top level in the file (outside `describe`) Jest will randomly fail first two tests. Very weird...","> I would also like to add that the problem here is not only \"no indication\", but also the fact that the test fails\r\n\r\nThis is intended, the test should fail on unhandled rejection. Short reasoning [here](https:\/\/github.com\/facebook\/jest\/issues\/8254#issuecomment-609066244). But nevertheless I agree a hint in the error would be great.","That sounds reasonable, but is \"unhandled rejection\" checked at the end of the test or immediately?\r\nMy use case was to have several promises in variables and only do something with them at the end of the test (wait for all and verify some are rejected).","Immediately, I believe this is using Node's native handling mechanism for rejected Promises. However note that this does not mean the test case will be aborted, it will be marked as failed but there is no way to stop the test case function execution early.","This issue seems related to https:\/\/github.com\/facebook\/jest\/issues\/5958","In node v16 the issue has gotten a lot worse. \r\n\r\n```\r\n[Nest] 36135  - 17\/01\/2022, 10:29:12   DEBUG Auto-corrected AuditLogServiceClient 'baseUrl' value: Removed \/api\/v1.\r\n[Nest] 36135  - 17\/01\/2022, 10:29:12   DEBUG Auto-corrected AuditLogServiceClient 'baseUrl' value: Removed \/api\/v1.\r\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"TypeError: promise.then is not a function\".] {\r\n  code: 'ERR_UNHANDLED_REJECTION'\r\n}\r\nend of process....\r\n```","Is there a way to understand what piece of code is throwing that particular error?\r\nStack:\r\nNodeJS v16.13.1\r\njest 26.6.0","Getting the same problem today:\r\n```bash\r\n\u276f node --trace-warnings node_modules\/.bin\/jest --passWithNoTests --no-cache --runInBand --detectOpenHandles --forceExit --coverage\r\n PASS  src\/application\/context.test.tsx\r\n PASS  src\/application\/provider.test.tsx\r\nRunning coverage on untested files...(node:27184) UnhandledPromiseRejectionWarning\r\n    at emitUnhandledRejectionWarning (internal\/process\/promises.js:168:15)\r\n    at processPromiseRejections (internal\/process\/promises.js:247:11)\r\n    at processTicksAndRejections (internal\/process\/task_queues.js:96:32)\r\n(node:27184) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https:\/\/nodejs.org\/api\/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)\r\n(node:27184) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\r\n    at emitDeprecationWarning (internal\/process\/promises.js:180:11)\r\n    at processPromiseRejections (internal\/process\/promises.js:249:13)\r\n    at processTicksAndRejections (internal\/process\/task_queues.js:96:32)\r\n```\r\n\r\nI'm not using any promise yet.\r\n\r\nMy setup:\r\n```json\r\n\r\n  \"devDependencies\": {\r\n    \"@hookform\/resolvers\": \"2.9.1\",\r\n    \"@testing-library\/dom\": \"8.13.0\",\r\n    \"@testing-library\/jest-dom\": \"5.16.4\",\r\n    \"@testing-library\/react\": \"13.3.0\",\r\n    \"@testing-library\/user-event\": \"14.2.0\",\r\n    \"@types\/jest\": \"28.1.1\",\r\n    \"@types\/leaflet\": \"^1.7.11\",\r\n    \"@types\/node\": \"17.0.42\",\r\n    \"@types\/react\": \"18.0.12\",\r\n    \"@types\/react-dom\": \"18.0.5\",\r\n    \"@typescript-eslint\/eslint-plugin\": \"5.27.1\",\r\n    \"@typescript-eslint\/parser\": \"5.27.1\",\r\n    \"@vitejs\/plugin-react\": \"1.3.2\",\r\n    \"eslint\": \"8.17.0\",\r\n    \"eslint-config-airbnb\": \"19.0.4\",\r\n    \"eslint-config-airbnb-typescript\": \"17.0.0\",\r\n    \"eslint-config-prettier\": \"8.5.0\",\r\n    \"eslint-import-resolver-typescript\": \"2.7.1\",\r\n    \"eslint-plugin-import\": \"2.26.0\",\r\n    \"eslint-plugin-jest\": \"26.5.3\",\r\n    \"eslint-plugin-jsx-a11y\": \"6.5.1\",\r\n    \"eslint-plugin-prettier\": \"4.0.0\",\r\n    \"eslint-plugin-react\": \"7.30.0\",\r\n    \"eslint-plugin-react-hooks\": \"4.5.0\",\r\n    \"eslint-plugin-testing-library\": \"5.5.1\",\r\n    \"husky\": \"8.0.1\",\r\n    \"jest\": \"28.1.1\",\r\n    \"jest-environment-jsdom\": \"28.1.1\",\r\n    \"jest-watch-typeahead\": \"1.1.0\",\r\n    \"lint-staged\": \"13.0.1\",\r\n    \"prettier\": \"2.6.2\",\r\n    \"ts-jest\": \"28.0.4\",\r\n    \"ts-node\": \"10.8.1\",\r\n    \"typescript\": \"4.7.3\",\r\n    \"vite\": \"2.9.12\",\r\n    \"yup\": \"0.32.11\"\r\n  }\r\n```\r\n\r\n`Node: v14.19.3`","Looks like it goes wrong in promises & async nesting only?\r\n```\r\nfunction _rejecting() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\treject(new Error('An error'));\r\n\t});\r\n}\r\n\r\ntest(\"this fails\", async () => {\r\n\tconst promise = (function _testMe() {\r\n\t\treturn new Promise(async () => {\r\n\t\t\tawait _rejecting();\r\n\t\t});\r\n\t})();\r\n\r\n\treturn expect(promise).rejects.toThrowError();\r\n});\r\n\r\ntest(\"this doesn't fail\", async () => {\r\n\tconst promise = (async function _testMe() {\r\n\t\tawait _rejecting();\r\n\t})();\r\n\r\n\treturn expect(promise).rejects.toThrowError();\r\n});\r\n\r\n```\r\nVery minimal reproduction case.\r\nIf the rejected promise is nested, it fails the test, if it isn't it won't.\r\nAnd the promise isn't exactly unhandled, as the async should be chaining them.\r\n\r\n\r\nThe code might look a bit weird like that, but it's sometimes needed to mix async & promises with things like manual timeouts. This is just a minimal repro.","Hitting this too. There should be a setting to disable this functionality.\r\n\r\nI tried editing jest-circus\/build\/globalErrorHandlers.js in place, commenting out the inject and restore, and then jest crashes at the site of the uncaught error that later gets caught.\r\n\r\nSo maybe it's actually a problem with node's detection being too eager?\r\n\r\nIn any case, the function `uncaught` could already log the full stack trace of the error, saying it's uncaught.","When I replace the uncaught function with the below, my tests pass, and my app works just fine. This should be a command line option.\r\n\r\n```js\r\nconst uncaught = error => {\r\n\tconsole.error(new Error(`uncaught (but ignoring): ${error.stack}`))\r\n\treturn\r\n\t;(0, _state.dispatchSync)({\r\n\t\terror,\r\n\t\tname: 'error',\r\n\t})\r\n}\r\n```","> When I replace the uncaught function with the below, my tests pass, and my app works just fine.\r\n\r\nSure, though this makes all uncaught rejections into acceptable behaviour, but at least it's giving some indication that the error was unhandled \ud83d\udc4d ","Well it's odd, I encounter the same situations in prod and there node doesn't complain about uncaught exceptions or rejections, and I have handlers for them.\r\n\r\nSo it seems that Jest somehow triggers node into not being ok with async catchers?","@wmertens ah that's an issue as well, jest replacing your own handlers","Well I'm my case that's not an issue, the handlers are only added in prod and they never fire.","I created a PR that at least marks uncaught errors with their reason, but it doesn't explain why I'm getting uncaught errors that are clearly caught.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Here is a comment to show, that this issue is still relevant. Very much so!","> Here is a comment to show, that this issue is still relevant. Very much so!\r\n\r\n\ud83d\udc4d\ud83c\udffd ","Given it's been 4 years since the initial opening of this ticket it may be good to create a reproduction of this in the current state-of-things, in terms of last node LTS and Jest version.","I've tested [the earlier mentioned reproduction case](https:\/\/github.com\/jestjs\/jest\/issues\/9210#issuecomment-1194071587) and it seems to still be an issue in Node v20.10.0, Jest v29.3.1."],"labels":["Needs Triage","Bug Report"]},{"title":"chore: update source-map-support","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md in the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nThis breaks breaks stack traces, not sure why. Seems to come from https:\/\/github.com\/evanw\/node-source-map-support\/pull\/253, but I don't know anything more than that\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\n\r\nEventually green CI\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["The snapshot should be updated, and this is exactly what has been fixed in source-map 0.5.14.\r\n\r\nLet's take this snapshot for an example\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/bbfef531f436a08698e2c4b289659d48265142c6\/e2e\/__tests__\/__snapshots__\/customMatcherStackTrace.test.ts.snap#L22-L47\r\nIt is produced by\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/bbfef531f436a08698e2c4b289659d48265142c6\/e2e\/custom-matcher-stack-trace\/__tests__\/sync.test.js#L41-L54\r\n\r\nIn the code above, the error is thrown _in_ the function `baz`, according to the [stack trace format](https:\/\/v8.dev\/docs\/stack-trace-api#appendix%3A-stack-trace-format), it should print on the first line the name of the function _called_, which is `baz`, instead of `Error`.\r\n\r\nsource-map v0.5.16 fixed this bug and one can see the snapshot difference on the CI log.\r\n```diff\r\n    - Snapshot  - 6\r\n    + Received  + 6\r\n\r\n    @@ -14,11 +14,11 @@\r\n               |             ^\r\n            46 |     };\r\n            47 | \r\n            48 |     \/\/ This expecation fails due to an error we throw (intentionally)\r\n\r\n    -       at Error (__tests__\/sync.test.js:45:13)\r\n    -       at baz (__tests__\/sync.test.js:43:23)\r\n    -       at bar (__tests__\/sync.test.js:42:23)\r\n    -       at foo (__tests__\/sync.test.js:52:7)\r\n    -       at Object.callback (__tests__\/sync.test.js:11:18)\r\n    -       at Object.toCustomMatch (__tests__\/sync.test.js:53:8)\r\n    +       at baz (__tests__\/sync.test.js:45:13)\r\n    +       at bar (__tests__\/sync.test.js:43:23)\r\n    +       at foo (__tests__\/sync.test.js:42:23)\r\n    +       at callback (__tests__\/sync.test.js:52:7)\r\n    +       at Object.toCustomMatch (__tests__\/sync.test.js:11:18)\r\n    +       at Object.<anonymous> (__tests__\/sync.test.js:53:8)\r\n```\r\n\r\nYou can also verify the correctness by running the following JavaScript program copy pasted from `__tests__\/sync.test.js`\r\n```js\r\nconst foo = () => bar(); \r\nconst bar = () => baz(); \r\nconst baz = () => { \r\n  throw Error('qux'); \r\n};\r\n\r\nfoo();\r\n```\r\n\r\nIt will print the following stack trace.\r\n```\r\n\/Users\/jh\/code\/babel\/test.js:4\r\n     throw Error('qux');\r\n     ^\r\n\r\nError: qux\r\n    at baz (\/Users\/jh\/code\/babel\/test.js:4:12)\r\n    at bar (\/Users\/jh\/code\/babel\/test.js:2:22)\r\n    at foo (\/Users\/jh\/code\/babel\/test.js:1:19)\r\n    at Object.<anonymous> (\/Users\/jh\/code\/babel\/test.js:7:1)\r\n    at Module._compile (internal\/modules\/cjs\/loader.js:956:30)\r\n    at Object.Module._extensions..js (internal\/modules\/cjs\/loader.js:973:10)\r\n    at Module.load (internal\/modules\/cjs\/loader.js:812:32)\r\n    at Function.Module._load (internal\/modules\/cjs\/loader.js:724:14)\r\n    at Function.Module.runMain (internal\/modules\/cjs\/loader.js:1025:10)\r\n    at internal\/main\/run_main_module.js:17:11\r\n```","Thanks for chiming in @JLHwung, and providing some details!\r\n\r\nIt seems to me it's now more _correct_, but provides a worse UX since the name of the assertion is not in the errors. We might have to do some juggling in order to restore the previous errors, as I think seeing `Object.toBe` when you called `expect().toBe` is nicer than `Object.<anonymous>.test` even though the latter is technically correct.\r\n\r\n---\r\n\r\nSo, doing some digging. If I stop filtering the stack trace, I currently get the following stack:\r\n\r\n```\r\n      at Object.<anonymous>.test (baaah.test.js:2:17)\r\n      at Object.asyncJestTest (packages\/jest-jasmine2\/build\/jasmineAsyncInstall.js:100:37)\r\n      at resolve (packages\/jest-jasmine2\/build\/queueRunner.js:43:12)\r\n          at new Promise (<anonymous>)\r\n      at mapper (packages\/jest-jasmine2\/build\/queueRunner.js:26:19)\r\n      at promise.then (packages\/jest-jasmine2\/build\/queueRunner.js:73:41)\r\n      at process._tickCallback (internal\/process\/next_tick.js:68:7)\r\n```\r\n\r\nIf I remove https:\/\/github.com\/facebook\/jest\/blob\/85789b5d050f483fc9b8f31876de30f965da3ba4\/packages\/expect\/src\/index.ts#L284\r\n\r\nI get\r\n\r\n```\r\n      at processResult (packages\/expect\/build\/index.js:337:19)\r\n      at Object.toBe (packages\/expect\/build\/index.js:387:16)\r\n      at Object.<anonymous>.test (baaah.test.js:2:17)\r\n      at Object.asyncJestTest (packages\/jest-jasmine2\/build\/jasmineAsyncInstall.js:100:37)\r\n      at resolve (packages\/jest-jasmine2\/build\/queueRunner.js:43:12)\r\n          at new Promise (<anonymous>)\r\n      at mapper (packages\/jest-jasmine2\/build\/queueRunner.js:26:19)\r\n      at promise.then (packages\/jest-jasmine2\/build\/queueRunner.js:73:41)\r\n      at process._tickCallback (internal\/process\/next_tick.js:68:7)\r\n```\r\n\r\nIf I pass `processResult` into `captureStackTrace` instead of `throwingMatcher`, I get this\r\n\r\n```\r\n      at Object.toBe (packages\/expect\/build\/index.js:387:16)\r\n      at Object.<anonymous>.test (baaah.test.js:2:17)\r\n      at Object.asyncJestTest (packages\/jest-jasmine2\/build\/jasmineAsyncInstall.js:100:37)\r\n      at resolve (packages\/jest-jasmine2\/build\/queueRunner.js:43:12)\r\n          at new Promise (<anonymous>)\r\n      at mapper (packages\/jest-jasmine2\/build\/queueRunner.js:26:19)\r\n      at promise.then (packages\/jest-jasmine2\/build\/queueRunner.js:73:41)\r\n      at process._tickCallback (internal\/process\/next_tick.js:68:7)\r\n```\r\n\r\nSo what I essentially want is to set the name of the function at the top frame as the name of `at Object.<anonymous>.test`. I'm not sure how easy that is, especially when we get to custom and (even harder) async errors. Might need to use  `callsites` or something similar rather than actual error objects and construct stack traces manually.\r\n\r\nThoughts?","We cannot land this until it does not mess up #10633"],"labels":["cla signed","Pinned"]},{"title":"Jest mock\/spy returns undefined even when set up","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nMocking spy return does nothing\r\n\r\nI'm about to lose my mind here; it seems the entire mock system is b0rked. I copy-paste the examples from the docs, and they don't work.\r\n\r\n## To Reproduce\r\n```js\r\n\/\/ __mocks__\/someUtil.js\r\nexport default {\r\n  m1: jest.fn(() => 42),\r\n}\r\n```\r\n\r\n```js\r\n\/\/ someUtil.test.js\r\nimport someUtil from '.\/someUtil';\r\n\r\njest.mock('.\/someUtil')\r\n\r\nconsole.log(someUtil.m1) \/\/ expected spy stuff\r\nconsole.log(someUtil.m1()) \/\/ undefined \ud83e\udd2f\r\n```\r\n\r\n<details>\r\n<summary>Other variations that also do nothing<\/summary>\r\n\r\n```js\r\n\/\/ __mocks__\/someUtil.js\r\n\r\nthrow; \/\/ does throw\r\n\r\nexport default {\r\n  m1: jest.fn(() => throw), \/\/ does NOT throw\r\n}\r\n\r\n\/\/ ---\r\n\r\nexport default {\r\n  m1: jest.fn().mockImplementation(() => 42),\r\n}\r\n\r\n\/\/ ---\r\n\r\nexport default {\r\n  m1: jest.fn().mockImplementation(() => throw), \/\/ does NOT throw\r\n}\r\n\r\n\/\/ ---\r\n\r\nexport default {\r\n  m1: jest.fn().mockReturnValue(42),\r\n}\r\n\r\n\/\/ ---\r\n\r\nexport default () => ({\r\n  m1: jest.fn().mockImplementation(() => 42),\r\n})\r\n\r\n\/\/ ---\r\n\r\nexport default () => ({\r\n  m1: jest.fn().mockReturnValue(42),\r\n})\r\n```\r\n<\/details>\r\n\r\n## Expected behavior\r\n\r\n[As documented](https:\/\/jestjs.io\/docs\/en\/mock-functions): it should return `42`\r\n\r\n## envinfo\r\n\r\njest version: `24.7.1`\r\n","comments":["I think you need to check something in your config, because everything is Ok.\r\nYou can check here your exemple:\r\n[https:\/\/repl.it\/repls\/GrossDapperLinuxkernel](https:\/\/repl.it\/repls\/GrossDapperLinuxkernel)\r\n\r\n* Need you import from `import someUtil from '.\/__mocks__\/someUtil'` ?","@joelbarbosa thanks for chiming it. The example you provided doesn't appear to actually be mocking anything: the actual implementation is itself just a mock:\r\n\r\n```js\r\n\/\/ someUtil.js\r\nmodule.exports = {m1: jest.fn(() => 42)}\r\n```\r\n\r\nNot sure if that matters, but I would guess it does.\r\n\r\nAlso not quite apples-to-apples: `module.exports` vs `export default`\r\n\r\nAs I understand it, you are not meant to import the mock: `jest.mock` handles that.","Yes it's mocking, you can check in the imagens:\r\n![image](https:\/\/user-images.githubusercontent.com\/1504007\/68330477-a1bf7500-00d3-11ea-8397-8e6a16ed3f1a.png)\r\n![image](https:\/\/user-images.githubusercontent.com\/1504007\/68330500-aab04680-00d3-11ea-8194-347d2ea6cb59.png)\r\n![image](https:\/\/user-images.githubusercontent.com\/1504007\/68330511-aedc6400-00d3-11ea-821b-dda73ad838b6.png)\r\n","I saw that it is logging a mock. I _think_ it's not the same because `jest.mock('someUtil)` is not actually doing anything: the real implementation is itself a spy.\r\n\r\nMy project's jest configuration is coming from react-scripts. The only thing I've done is a setupConfig where I globally add the enzyme adapter for react 16.","Yes, I think  `jest.mock('someUtil)` is working, jest is isolating it you can check more example here:\r\n[https:\/\/medium.com\/@rickhanlonii\/understanding-jest-mocks-f0046c68e53c](https:\/\/medium.com\/@rickhanlonii\/understanding-jest-mocks-f0046c68e53c)","In your repl example, if I remove the `jest.mock()`, the test behaves exactly the same with exactly the same output, so it's definitely not doing anything.","Oh yeah, of course it is doing.\r\nwhen you add `jest.mock('.\/someUtil')` you are reassign all the exported functions to the mock.\r\n\r\nas you can see, I'll change the behavior  of my function.\r\n\r\n```js\r\n\r\njest.mock('.\/someUtil', () => ({\r\n  m1: jest.fn(() => 'mock me again')\r\n}));\r\n\r\nconsole.log(someUtil.m1); \/\/ [Function: mockConstructor].....\r\nconsole.log(someUtil.m1()); \/\/ mock me again\r\n\r\n```","I created a representative example (https:\/\/repl.it\/repls\/GaseousAcrobaticMainframe), but it does not behave the same locally: Locally, calling the mocked `getItem()` in the actual implementation returns `undefined`, but calling it in the test returns the expected `Promise { { id: '29ed6982-3959-450e-b3cf-bf82b2fa14b1' } }`. When I log `getItem` (without calling it), it returns a mock object in both the implementation and the test.\r\n\r\nI'm using the same version of Jest (24.9.0). The only difference I can think of is my local was generated from `create-react-app`, so the Jest configuration comes from that.","@jacob-fueled have you fixed this issue?","@mateuszs Yes: I stopped using Jest. I could not figure out what the problem was; it quite possibly was coming from create-react-app, but I'd already sank far too many hours trying to get an out-of-the-box feature to work :(","A little late here, but I was just having this exact issue. I discovered that someone had added `resetMocks: true` to the `jest.config.js` file. This means that the _implementations_ of mock functions are reset before each test. So in our case, the mock function was being included in the mocked module at test runtime, but that mock had been reset, so it returned `undefined`.\r\n\r\nRegarding the original issue build environment, it looks like `react-scripts` does indeed add `resetMocks: true` into the jest config. (https:\/\/github.com\/facebook\/create-react-app\/blob\/master\/packages\/react-scripts\/scripts\/utils\/createJestConfig.js#L69) But you can override it on the `jest` key of your `package.json`. (https:\/\/github.com\/facebook\/create-react-app\/blob\/master\/packages\/react-scripts\/scripts\/utils\/createJestConfig.js#L74)","`resetMocks: true` was the culprite for me too.\r\n\r\nmock implementations can work with `resetMocks: true` if you setup the mocks in beforeEach, or directly inside the `test`\/`it` callbacks. \r\n\r\nIf you set up the mocks at the top level of the module, in the describe callback (but outside of any it\/test callback), or in beforeAll, they get overwritten by resetMocks AFAICT","@dstapleton92 Thank you so much, I sank a ton of time into google trying to find this answer!","In my case I wanted to mock a value that got evaluated upon loading the file:\r\n```js\r\nexport const store = createStore(...);\r\n```\r\nThis was always returning undefined, no `resetMocks` setting.\r\n\r\nInstead I had to do:\r\n```js\r\nexport const store = () => {\r\n  return createStore(...);\r\n}\r\n```","@dstapleton92 thank you! I've spent hours on this.\r\n\r\nCould we have something on this somewhere in the documentation ?","@dstapleton92 - thank you again! I've spent half a day on this and I'm glad I targetted for CRA as the culprit and not Jest!","Spent one day until I landed here and figured out that CRA is causing __mocks__ to be reset by default. That should definitely not be a default behaviour. ","This also caught me totally by surprise. We've been using `restoreMocks` in our `jest.config.js` to ensure all mocked spies are reverted to their original implementation between tests.\r\n\r\nBut I would have never have expected the restoration of mock functions to restore their original implementations to affect mock functions created on-the-fly with `jest.fn()` as well. Is there actually a use-case for resetting `jest.fn(() => 42)` to `jest.fn()`??\r\n\r\nI know (now) it's documented:\r\n![image](https:\/\/user-images.githubusercontent.com\/42995170\/116093875-5756fd00-a6a7-11eb-961b-c242cf11f155.png)\r\n\r\nAnd it's probably consistent as both `jest.fn(() => 42)` and `jest.spyOn(obj, 'method').mockReturnValue(42)` add mock implementations. But I'm sure it will keep tripping people up. ","For me it was `jest.resetAllMocks();`!","I have been having the same issue. The examples do not work. I get errors of \"cannot call .then of undefined\". I too am using react-scripts.\r\n\r\nputting \"resetMocks\": false into the \"jest\" portion of my package.json file fixed the problem immediately. \r\n\r\nI've been pulling my hair out over this for 2 days! I agree that this \"attribute\" should be more widely published. \r\n\r\nPerhaps, the jest.fn and jest.mock() documentation can mention that if the mocks get reset then the mocks set up in the top of the test file will no longer work. Lots of people create apps via react scripts and this has to be happening to lots more people.","Just lost a heap of hours on this also. I really feel like `resetMocks: true` shouldn't apply to global mock implementations.","Had a similar issue where I couldn't figure out why the import I was trying to mock was ending up `undefined`. I was trying\r\n```\r\nconst mockMyImport = jest.fn()\r\n\r\njest.mock('my-module', () => ({\r\n  ...jest.requireActual('my-module'),\r\n  myImport: mockMyImport,\r\n}));\r\n\r\ndescribe(`MyComponent test`, () => {\r\n  it('works', async () => {\r\n    mockMyImport.mockImplementation(() => {\r\n      console.log(\"in mocked implementation\")\r\n      return 42\r\n    })\r\n    const { toJSON } = render(<MyComponent \/>)\r\n    expect(toJSON()).toMatchSnapshot();\r\n  });\r\n});\r\n\r\n```\r\nbut in my component, logging `myImport` would show that it was always `undefined`. This, however, works:\r\n\r\n```\r\nimport { myImport } from 'my-module'\r\n\r\njest.mock('my-module', () => ({\r\n  ...jest.requireActual('my-module'),\r\n  myImport: jest.fn(),\r\n}));\r\n\r\ndescribe(`MyComponent test`, () => {\r\n  it('works', async () => {\r\n    (myImport as jest.Mock).mockImplementation(() => {\r\n      console.log(\"in mocked implementation\")\r\n      return 42\r\n    })\r\n    const { toJSON } = render(<MyComponent \/>)\r\n    expect(toJSON()).toMatchSnapshot();\r\n  });\r\n});\r\n\r\n```\r\nSo in other words, you have to access the mocked import by actually importing it in the test rather than using the variable that you assigned the import to be mocked by....\r\n","> `resetMocks: true` was the culprite for me too.\r\n> \r\n> mock implementations can work with `resetMocks: true` if you setup the mocks in beforeEach, or directly inside the `test`\/`it` callbacks.\r\n> \r\n> If you set up the mocks at the top level of the module, in the describe callback (but outside of any it\/test callback), or in beforeAll, they get overwritten by resetMocks AFAICT\r\n\r\n@HenryCharlesAnderson thanks for providing this information. I tried putting `jest.mock(...)` inside the `it` callback function and it's still not working. I tried putting it under `beforeEach()` function and that didn't work either. The only way I could get it working is to set `resetMocks` to false in package.json. Any ideas why this is the case?\r\n\r\nHere's some sample code I've written to test this for more context. In this example, `jest.resetMocks` in package.json is set to false and it works. The moment I set it to true, this fails. As mentioned above, moving `jest.mock()` block into the callback function of`it()` and `beforeEach()` functions do not work.\r\n```\r\n\/\/ simplefn.ts\r\nconst simplefn = (message: string): string => message;\r\nexport default simplefn;\r\n```\r\n```\r\n\/\/ simplefn.test.ts\r\nimport simplefn from '..\/simplefn';\r\n\r\njest.mock('..\/simplefn', () => ({\r\n  __esModule: true,\r\n  default: jest.fn((msg) => 'hello'),\r\n}));\r\n\r\nbeforeEach(() => {\r\n  jest.restoreAllMocks();  \/\/ Contrary to my expectation, this line does not cause jest.mock() to become reset\r\n});\r\n\r\ndescribe('test simplefn', () => {\r\n  it('works with jest.fn', () => {\r\n    const result = simplefn('test');\r\n    expect(result).toBe('hello');\r\n    expect(simplefn).toHaveBeenCalledTimes(1);\r\n  });\r\n});\r\n\r\n```","I had the same problem in my React project. Putting `resetMocks: false` into package.json did not fix it. I know that jest.mock is not broken but I can't get the simple examples to work either. The weird thing is that when I use VSS interactive debugger, it shows the `dummyPromise` implementation is my mocked implementation, but there is no evidence of mocked function support. `_isMockFunction` is undefined.\r\n\r\nI have found that I can implement the supposed jest.mock behavior by using jest.spyon, mockImplementation, and importing from __mocks__ directory.\r\n### Broken Code\r\n```es6\r\nimport {dummyPromise} from '..\/services\/DummyService';\r\n\r\njest.mock('..\/services\/DummyService');\r\n\r\ndescribe('grasping at straws why mocking service promises is not working', ()=>{\r\n    beforeEach(()=>{\r\n        \/\/jest.mock('..\/services\/DummyService.js'); \/\/ still does not work\r\n    })\r\n\r\n    test('can get a mock', ()=>{\r\n        \/\/jest.mock('..\/services\/DummyService.js'); \/\/ still does not work\r\n        expect(jest.isMockFunction(dummyPromise)).toBeTruthy();\r\n    })\r\n})\r\n```\r\nAs you can see, putting the `jest.mock()` into beforeEach or in the test has no change in behavior.\r\n\r\n### Working Code\r\n```es6\r\n\/* eslint-disable jest\/no-mocks-import *\/\r\nimport * as DummyService from '..\/services\/DummyService';\r\nimport * as DummyServiceMocks from '..\/services\/__mocks__\/DummyService';\r\n\r\nconst mockDummyPromise = jest.spyOn(DummyService, 'dummyPromise');\r\nmockDummyPromise.mockImplementation(DummyServiceMocks.dummyPromise);\r\n\r\ndescribe('grasping at straws why mocking service promises is not working', ()=>{\r\n\r\n    test('can get a mock', ()=>{\r\n        expect(jest.isMockFunction(mockDummyPromise)).toBeTruthy();\r\n    })\r\n    \r\n    test('can call the mock', async ()=>{\r\n        expect(jest.isMockFunction(mockDummyPromise)).toBeTruthy();\r\n        mockDummyPromise().then(data=>{\r\n            expect(data).not.toBeNull();\r\n            expect(data).toEqual('dummy dummy dummy');\r\n        })\r\n    })\r\n})\r\n```\r\n Yes, esLint complains about the import from `__mocks__` and also thinks that the `mockDummyPromise` isn't really a promise, but this code works.\r\n\r\n## services\/DummyService.js\r\n```es6\r\nexport const dummyPromise = () =>{\r\n    return new Promise((resolve)=>{\r\n        resolve('real dummy real dummy');\r\n    });\r\n}\r\n```\r\n\r\n## services\/__mocks__\/DummyService.js\r\n```es6\r\nexport const dummyPromise = () =>{\r\n    return new Promise( resolve => resolve('dummy dummy dummy'));\r\n}\r\n```","None of the above worked and in my case the problem was that I was adding a mock in a `__mocks__` directory next to the file, but the import used a 'scoped module'. I had to add a folder for the scoped module under the root mocks folder ie `__mocks__\/@module\/file.js`.\r\n\r\n[The documentation mentions it](https:\/\/jestjs.io\/docs\/manual-mocks#mocking-node-modules).","My issue was the `resetMocks` problem as well. WOW... Was never going to find that one lol. THANK YOU @dstapleton92!!","@thisismydesign your solution helped me! Thanks","_**Solution:**_\r\n\r\nAppend `--resetMocks=false` to your test script and re-run."],"labels":["Needs Triage","Bug Report"]},{"title":"Allow custom coverage reporters","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nAllow jest to use custom `coverageReporters`.\r\n\r\n## Motivation\r\n\r\nOnly [istanbuljs](https:\/\/github.com\/istanbuljs\/istanbuljs) coverage reporters can be used so far. But istanbuljs has limited number of reporters which can't cover all possible options. \r\n\r\nE.g. I've needed a coverage reports to be in `junit-xml` format which isn't present in istanbuljs library.\r\n\r\n## Example\r\n\r\nIt could be used just like test [`reporters`](https:\/\/jestjs.io\/docs\/en\/configuration#reporters-array-modulename-modulename-options).\r\n\r\n```\r\n\/\/ jest.config.js\r\n{\r\n  collectCoverage: true,\r\n  coverageReporters: [require.resolve('<path to appropriate node_module>')],\r\n  ...\r\n}\r\n\/\/\r\n{\r\n  collectCoverage: true,\r\n  coverageReporters: [\r\n    'json',\r\n    'text',\r\n    [\r\n      require.resolve('<path to appropriate node_module>'), { option: {}, ... }\r\n    ] \/\/ with options\r\n  ],\r\n  ...\r\n}\r\n```\r\n\r\n## Workaround\r\n\r\nDefine custom **test** (not coverage) reporter. Implement `onRunComplete` method and extract coverage results from `aggregatedResult`.\r\n\r\n```\r\nclass CustomCoverageReporter {\r\n  ...\r\n  onRunComplete(context: jest.Context, aggregatedResult: jest.AggregatedResult): void {\r\n    \/\/ extract coverage here\r\n  }\r\n}\r\n\r\nmodule.exports = CustomCoverageReporter;\r\n```\r\n\r\n```\r\n\/\/ jest.config.js\r\n{\r\n  ...\r\n  collectCoverage: true,\r\n  reporters: [require.resolve('<path to CustomCoverageReporter>')]\r\n}\r\n```\r\n\r\nBut you need be aware that it'll be invoked even if `collectCoverage` flag is set to `false`. So additional validations are required.\r\n\r\n## Pitch\r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nIt would be great to be able to export coverage reports in different desirable formats.\r\nThis enhancement would provide more flexibility.","comments":[":+1:\r\nAny hints on how would you extract the coverage summary for instance out of the aggregatedResult? The coverageMap is in some unknown format.","I think this one can be closed. Istanbul changed the way they integrate the reporter. You just need to export a class with a function execute(results) and then you receive the coverageMap","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","> I think this one can be closed. Istanbul changed the way they integrate the reporter. You just need to export a class with a function execute(results) and then you receive the coverageMap\r\n\r\nHi! Could you please share link for example about how to receive the coverageMap?\r\n\r\nI solved my case like this, but I think this is bad idea:\r\n```ts\r\nimport libCoverage from 'istanbul-lib-coverage';\r\nimport { CoverageReporter } from '@jest\/reporters';\r\n\r\nclass Reporter extends CoverageReporter {\r\n    async onRunComplete(): Promise<void> {\r\n        \/\/ @ts-ignore\r\n        const { map } = await super._getCoverageResult();\r\n        if (!map) return;\r\n\r\n        const coverageMap = libCoverage.createCoverageMap(map);\r\n       \/\/ ...\r\n       }\r\n}\r\n```","I think it changed again and I haven't worked on this a while.\r\nI guess this project does not help to understand internals or?\r\nhttps:\/\/github.com\/dkelosky\/jest-stare\/blob\/master\/src\/reporter\/Reporter.ts","This would be a great feature. Our team needs to upload test coverage reports from the pipelines but the reports are huge and take ~10min to upload. We would like to write our own coverage reporter to include only tests with missing coverage. So, we could reduce the time it takes to upload the files. ","There is a Jest custom reporter here that can adapt to the custom coverage reporter:\r\nhttps:\/\/github.com\/cenfun\/jest-monocart-coverage"],"labels":[":rocket: Feature Request"]},{"title":"Create Dockerfile for contributing","body":"Close #9105\r\n\r\n## To Do\r\n- [X] Create functional Dockerfile for contributing\r\n- [X] Add documentation for dockerfile _\\*Should be reviewed_\r\n- [X] Update CHANGELOG.md in the root of the project if you have not done so.\r\n- [X] Run `prettier` over `CONTRIBUTING.md`\r\n- [X] Fix change log to say `Chore && Maintainance`\r\n- [X] Verified `yarn` runs correctly\r\n- [ ] `yarn test` does NOT run correctly. Troubleshooting... \r\n\r\n## Summary\r\n\r\nThis PR adds a Dockerfile that contributors can use. This allows people to get Jest up and running without manual installation. See #9105 for more details.\r\n\r\nI am by no means a Docker or Jest expert. I'm sure there are improvements to this file that can be made. Feel free to let me know any changes that are requested! \ud83d\udc4d \r\n\r\n## Test plan\r\n\r\nSimply run the following commands to test this (Tested on Ubuntu 18.04):\r\n\r\n### Build Jest\r\n\r\n```sh\r\ndocker build -t jest .\r\n```\r\n\r\n### Run Jest\r\n* You may need to replace `$PWD` with the path to your Jest clone.\r\n\r\n```sh\r\ndocker run --volume=\"$PWD:\/usr\/src\/app\" --rm jest:latest\r\n```\r\n\r\n### Expected Results\r\n\r\n1. Jest builds successfully\r\n2. Jest runs successfully (in watch mode)\r\n3. When you modify && save a `.ts` file in `\/packages`, it should automatically re-compile.\r\n\r\n","comments":["Hi Alex-Cannon! Thank you for your pull request and welcome to our community. We require contributors to sign our Contributor License Agreement, and we don't seem to have you on file.In order for us to review and merge your code, please sign at <https:\/\/code.facebook.com\/cla>. **If you are contributing on behalf of someone else (eg your employer)**, the individual CLA may not be sufficient and your employer may need to sign the corporate CLA.\n\nIf you have received this in error or have any questions, please contact us at [cla@fb.com](mailto:cla@fb.com?subject=CLA%20for%20facebook%2Fjest%20%239109). Thanks!","Thank you for signing our Contributor License Agreement. We can now accept your code for this (and any) Facebook open source project. Thanks!","@SimenB thanks for the feedback. I'll work on these changes. I'll keep a log of my work on my top comment.","@SimenB looks like all the tests are green. However, I ran `yarn` and got this error:\r\n~Investigating now.~\r\n\r\n`Error: cannot find module '@babel\/plugins-transform-modules-commonjs'...`\r\n\r\nUpdate: The error went away when I changed my volume mount from this:\r\n\r\n1.  `--volume=\"$PWD:\/usr\/src\/app\"`\r\n1. To this: `--volume=\"$PWD\/packages:\/usr\/src\/app\/packages\"`\r\n\r\n@SimenB I looked over `scripts\/watch.js` and it _appears_ that Jest only watches `\/packages`? If this is the case, my solution will work, otherwise I'll have to troubleshoot more.\r\n\r\n## `yarn`\r\n\r\nI ran `yarn` in the Jest container. It completed and there were no errors.\r\n\r\n## `yarn test`\r\n\r\nI ran `yarn test` in the Jest container. There were several errors. \r\n\r\n### Inline snapshot errors\r\n\r\nThere were inline snapshot errors across the app. It looked like inline snapshots were broken. This may have been because I ran the command like so:\r\n\r\n1. Started a Jest container with `yarn watch`\r\n1. I opened a new CMD and ran `yarn test` in the Jest container\r\n\r\nThere also might be a missing package that is required? See the Dockerfile for more info. Below are two error logs for these errors:\r\n\r\n![watch error](https:\/\/user-images.githubusercontent.com\/28692645\/68156718-8ef94480-ff09-11e9-9277-d96182301ad9.png)\r\n![snapshot errors](https:\/\/user-images.githubusercontent.com\/28692645\/68156725-90c30800-ff09-11e9-9078-78c02d26062a.png)\r\n\r\n\r\n### Additional Errors\r\n\r\nI'm not sure what these errors mean or how to fix them. A possibility is that I didn't install the correct packages for Jest? For example, mercurial, etc.\r\n\r\n![more errors](https:\/\/user-images.githubusercontent.com\/28692645\/68156609-6b35fe80-ff09-11e9-8a70-fa2929e5dd6a.png)\r\n\r\n\r\n","I'm not sure if mounting the volume stuff will work properly at all since we need e.g. nested `node_modules` that differ between architectures... Will need to think that through a bit\r\n\r\nNot sure about the snapshot failure, possibly related to the mounted volume thing?\r\n\r\nThe mercurial errors are expected (for now), see #8653.","@SimenB got it. So mercurial errors are expected, but not the snapshot errors. I have an idea of what might be going wrong with the snapshots. Troubleshooting now...","@Alex-Cannon hey! are you still interested in working on this? \ud83d\ude42 ","This PR should be closed and the work should be continued on pr #13009.","@SimenB @Alex-Cannon ","This PR is stale because it has been open 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["cla signed","Stale"]},{"title":"Create a Dockerfile for contributing","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Dockerfile for contributing to Jest\r\n\r\nCreate a DockerFile to run jest.\r\n\r\n## Motivation\r\n\r\nIt would be nice to have a option to run Jest with a one-click command instead of having to do any manual setup.\r\n\r\n* I'd be happy to create a DockerFile for Jest and matching documentation.\r\n\r\n## Example\r\n\r\nI imagine something along the lines of this (may not be semantically correct):\r\n\r\n```sh\r\ndocker build . \/\r\ndocker run jest\r\n```\r\n\r\n## Pitch\r\n\r\n* Make contributing easier & faster by removing manual setup (installing, having to deal with differences between Node versions, yarn, OS differences, etc.)\r\n* Allow all contributors to develop Jest in the exact same environment to reduce the number of platform-specific bugs.","comments":["sure, no reason not to, methinks. feel free to open up a PR \ud83d\ude42 ","@SimenB I can do it.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","@SimenB Hi, is this issue still open? I see that there's been a PR open for a few years. Would love to take it on if it is.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Hi @SimenB, is anyone working on this issue? if no please assign it to me I can do it.","I would like to work on this issue ","hey can i work on this issue @Alex-Cannon ","I would like to work on this issue!","@Alex-Cannon if no one is working on this issue, I'd like to work on it","is this issue still open?\r\n","is it still open ?","I will like to work on this issue"],"labels":["good first issue","Help Wanted","Documentation :book:"]},{"title":"Snapshotting Arrays with Matchers","body":"## \ud83d\udc1b Bug Report\r\n\r\nCreating a snapshot with array + matchers is not possible without wrapping array into an object.\r\n\r\n## To Reproduce\r\n\r\n```typescript\r\nexpect(['foo']).toMatchInlineSnapshot([expect.any(String)]);\r\n```\r\n\r\n## Expected behavior\r\n\r\n```typescript\r\nexpect(['foo']).toMatchInlineSnapshot([expect.any(String)], `\r\n  Array [\r\n    Any<String>,\r\n  ]\r\n`);\r\n```\r\n\r\n## Actual behavior\r\n\r\n```typescript\r\nexpect(['foo']).toMatchInlineSnapshot([expect.any(String)], `\r\n  Object {\r\n    \"0\": \"foo\",\r\n  }\r\n`);\r\n```\r\n\r\nI'm able to get by by taking my result and placing it in an object then doing the snapshot, but I feel like I should be able to snapshot an actual array with matchers.\r\n","comments":["cc @pedrottimark noticed something when dealing with propertyMatchers in https:\/\/github.com\/facebook\/jest\/pull\/9049?","Sadly, snapshot testing with property matchers is unusable with arrays at the moment.","This also tripped me up, and I've confirmed it is still an issue on `26.2.2`. My use case involves nested objects in arrays. Specifically rows that come out of a testing database where there are columns that default to the current time (and are thus outside the control of mocking).\r\n\r\nA simple way to replicate the error:\r\n\r\n```js\r\nexpect([\r\n      { id: 1, createdAt: new Date() },\r\n      { id: 2, createdAt: new Date() },\r\n    ]).toMatchSnapshot([\r\n      { createdAt: new Date() },\r\n      { createdAt: new Date() },\r\n    ]);\r\n```\r\n\r\nThe snapshot I'd expect:\r\n\r\n```js\r\nObject {\r\n  \"0\": Object {\r\n    \"createdAt\": Any<Date>,\r\n    \"id\": 1,\r\n  },\r\n  \"1\": Object {\r\n    \"createdAt\": Any<Date>,\r\n    \"id\": 2,\r\n  },\r\n}\r\n```\r\n\r\nThe snapshot I get:\r\n\r\n```js\r\nObject {\r\n  \"0\": Object {\r\n    \"createdAt\": 2020-08-06T23:54:53.133Z,\r\n    \"id\": 1,\r\n  },\r\n  \"1\": Object {\r\n    \"createdAt\": 2020-08-06T23:54:53.133Z,\r\n    \"id\": 2,\r\n  },\r\n}\r\n```\r\n\r\nThe object wrapping approach @j suggested has worked:\r\n\r\n```js\r\nexpect({ data: [\r\n    { id: 1, createdAt: new Date() },\r\n    { id: 2, createdAt: new Date() },\r\n  ]}).toMatchSnapshot({ data: [\r\n    { createdAt: expect.any(Date) },\r\n    { createdAt: expect.any(Date) },\r\n  ]});\r\n```\r\n\r\nProduces a snapshot of:\r\n\r\n```js\r\nObject {\r\n  \"data\": Array [\r\n    Object {\r\n      \"createdAt\": Any<Date>,\r\n      \"id\": 1,\r\n    },\r\n    Object {\r\n      \"createdAt\": Any<Date>,\r\n      \"id\": 2,\r\n    },\r\n  ],\r\n}\r\n```","Any progress on this feature? ","Just ran into this issue, would love to see a fix.","Any updates?","Any updates?","Would love to see this feature implemented, just wanted to bump to keep the issue from getting stale","Any update?","Any updates on this?"],"labels":["Needs Triage","Bug Report"]},{"title":"Jest mock being ignored by `fetch`","body":"## \ud83d\udc1b Bug Report\r\n\r\nWhen you mock a module like `jest.mock('.\/my-api-helper')` and that module calls out to `fetch` there's often times where you'll get `TypeError: Network request failed` from your `fetch` lib (in my case `whatwg-fetch`)\r\n\r\n## To Reproduce\r\n\r\nThis is basically what I have in a project\r\n\r\n```js\r\n\/\/ my-api-helper.js\r\nexport default function getStuff() {\r\n  return fetch('http:\/\/example.org');\r\n}\r\n\r\n\/\/ setupFilesAfterEnv: ['.\/setup']\r\nimport 'whatwg-fetch'\r\n\r\n\/\/ my-dumb.test.js\r\nimport getStuff from '.\/my-api-helper';\r\njest.mock('.\/my-api-helper');\r\n\r\nbeforeEach(() => {\r\n  getStuff.mockClear();\r\n  getStuff.mockResolvedValue({ foo: 'some data that should always return because `fetch` is bypassed' });\r\n});\r\n\r\ntest('my helper does things', async () => {\r\n  const result = await getStuff(); \/\/ craps out here with stack trace leading to `whatwg-fetch`\r\n  expect(result).toMatchInlineSnapshot();\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nThat it uses the resolved mock  data I provide and not even remotely touch the real fetch that's wrapped up in a helper.","comments":["> \/\/ setupFilesAfterEnv: ['.\/setup']\r\n> import 'whatwg-fetch'\r\n\r\nIs this needed if you're mocking out that functionality anyway?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Having the same issue. The fetch is still called for some reason.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"Set resetMocks to true by default","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nAs described in the thread https:\/\/twitter.com\/kentcdodds\/status\/1182744387190607872, we should set resetMocks param to true by default. \r\n\r\n## Motivation\r\n\r\nIn order to make our tests isolated. \r\n\r\n## Example\r\n\r\nthanks to this new default value, we won't have to define afterAll method in our unit tests, in order to reset something. \r\n\r\n```\r\nafterEach(() => {\r\n  jest.clearAllMocks()\r\n})\r\n```\r\n\r\n## Pitch\r\n\r\nThis feature is part of the core project .  https:\/\/jestjs.io\/docs\/en\/configuration#resetmocks-boolean. This change will make de developer experience smoother when writing unit test with jest. \r\nAs writing isolated test is a good practice, we should make it easy to implement, without writing extra code. \r\n\r\nWhy does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nCommon feature proposals that do not typically make it to core:\r\n\r\n- New matchers (see [jest-extended](https:\/\/github.com\/jest-community\/jest-extended))\r\n- Changes to the default reporter (use custom reporters instead)\r\n- Changes to node\/jsdom test environments (use custom environments instead)\r\n","comments":["This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Note the proposal does not match the example.  `resetMocks` is **not equal** to `clearAllMocks`\r\n\r\n**clearAllMocks** clears calls, instances, and results (and this is a good thing to do!): https:\/\/jestjs.io\/docs\/jest-object#jestclearallmocks\r\n\r\n**resetAllMocks** is what is called by setting `resetMocks` to true; and this does what `clearAllMocks` does, but also removes implementations and mocked return values (and this is not a great thing to do!): https:\/\/jestjs.io\/docs\/configuration#resetmocks-boolean\r\n\r\nJustification: clearing all mocks is great, because tests should be isolated (thanks @kentcdodds).  Resetting all mocks is generally bad, because you will make [manual mocks](https:\/\/jestjs.io\/docs\/manual-mocks) useless (also see https:\/\/github.com\/facebook\/jest\/issues\/10419), and make useless any other mock implementation that a developer may have created for a test suite (solution to the latter is to re-implement it in a beforeEach, but there shouldn't be a need to do this)\r\n\r\nI would propose to close this ticket, and keep `resetMocks` default as `false`","Is there any viable solution to restore manual mocks?\r\n\r\nHaving reset on a beforeEach makes them look like they could be only used once. Looks like with this reset clearing the manual we have no use for manual mocks that can have a different implementation","@bozdoz @drFabio \r\nI made the following PR a long time ago, which unfortunately got stuck somewhere:\r\nhttps:\/\/github.com\/facebook\/jest\/pull\/9270\r\n\r\nIt makes each mock remember it's initial implementation and provides a way to restore the initial implementation.\r\n\r\nI believe it would be a very viable solution to restoring manual mocks, and that it would be a safer and better way to reset the state between tests than resetAllMocks or restoreAllMocks.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"jest-haste-map: TypeError: dupMap.get is not a function","body":"## \ud83d\udc1b Bug Report\r\n\r\nRunning a jest test results in a test build failure:\r\n```\r\nTypeError: dupMap.get is not a function\r\nat ModuleMap._getModuleMetadata (node_modules\/jest-haste-map\/build\/ModuleMap.js:231:14)\r\n```\r\nWhen console logging `dupMap` at the source location, `dupMap` is undefined. I don't see a control flow where this is possible because when dupMap is declared, it is set to EMPTY_MAP if it's value would be undefined. \r\n\r\nThe error is also bound to a material-ui style object, which doesn't make much sense.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\nI'm afraid I don't have a reproduction. I'm using `lerna` and `material-ui` in jest. The library I'm experiencing the issue with is dependent on another library in my mono repo. \r\n\r\n## Expected behavior\r\nThe test runs without problems\r\n\r\n## Link to repl or repo (highly encouraged)\r\nUnavailable, sorry\r\n\r\n## envinfo\r\n\r\n```npx: installed 1 in 1.515s\r\n\r\n  System:\r\n    OS: Linux 5.0 Ubuntu 18.04.2 LTS (Bionic Beaver)\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz\r\n  Binaries:\r\n    Node: 10.16.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.17.3 - \/usr\/bin\/yarn\r\n    npm: 6.9.0 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^24.9.0 => 24.9.0 \r\n```\r\nMy jest config:\r\n\r\n```\r\n\r\n  \"jest\": {\r\n    \"collectCoverageFrom\": [\r\n      \"packages\/**\/*.{js,jsx,mjs}\",\r\n      \"!packages\/**\/common\/icons\/components\/*\",\r\n      \"!packages\/**\/*.stories.{js,jsx,ts,tsx}\",\r\n      \"!packages\/**\/**\/story\/**\/*.{js,jsx,ts,tsx}\"\r\n    ],\r\n    \"moduleDirectories\": [\r\n      \"node_modules\"\r\n    ],\r\n    \"setupFilesAfterEnv\": [\r\n      \"<rootDir>\/config\/jest\/setup.js\"\r\n    ],\r\n    \"setupFiles\": [\r\n      \"<rootDir>\/config\/polyfills.js\"\r\n    ],\r\n    \"testMatch\": [\r\n      \"<rootDir>\/packages\/**\/?(*.)(spec|test).{js,jsx,mjs}\"\r\n    ],\r\n    \"testEnvironment\": \"jsdom\",\r\n    \"testURL\": \"http:\/\/localhost\",\r\n    \"transform\": {\r\n      \"^.+\\\\.(js|jsx|mjs)$\": \"<rootDir>\/node_modules\/babel-jest\",\r\n      \"^.+\\\\.css$\": \"<rootDir>\/config\/jest\/cssTransform.js\",\r\n      \"^(?!.*\\\\.(js|jsx|mjs|css|json)$)\": \"<rootDir>\/config\/jest\/fileTransform.js\"\r\n    },\r\n    \"transformIgnorePatterns\": [\r\n      \"[\/\\\\\\\\]node_modules[\/\\\\\\\\].+\\\\.(js|jsx|mjs)$\"\r\n    ],\r\n    \"moduleFileExtensions\": [\r\n      \"web.js\",\r\n      \"js\",\r\n      \"json\",\r\n      \"web.jsx\",\r\n      \"jsx\",\r\n      \"node\",\r\n      \"mjs\",\r\n      \"ts\",\r\n      \"tsx\"\r\n    ]\r\n```","comments":["Hi! I managed to figure it out by reading over your lovely example project :)\r\n\r\nI was missing these properties:\r\n\r\n```\r\n    \"modulePathIgnorePatterns\": [\r\n      \"packages\/.*\/build\"\r\n    ],\r\n    \"projects\": [\"<rootDir>\/packages\/*\"],\r\n```\r\n\r\nThanks!!\r\n","@CameronAckermanSEL  i'm getting this at the moment. Might you know why the solution above worked? and what might have caused this, this solution doesn't seem work for me. I'm on lerna v2","@CameronAckermanSEL I get that error too but it happens when I import a module from a custom library\r\n~~~\r\n> jest --no-cache\r\n\r\njest-haste-map: Haste module naming collision: my-lib\r\n  The following files share their name; please adjust your hasteImpl:\r\n    * <rootDir>\\dist\\my-lib\\package.json\r\n    * <rootDir>\\projects\\my-lib\\package.json\r\n\r\nPASS src\/app\/services\/test.service.spec.ts\r\nPASS projects\/my-lib\/src\/lib\/components\/button\/button.component.spec.ts\r\nFAIL src\/app\/app.component.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    TypeError: dupMap.get is not a function\r\n\r\n      3 | import { TestService } from '.\/services\/test.service';\r\n      4 | import { of } from 'rxjs';\r\n    > 5 | import { MyLibModule } from 'my-lib';\r\n        | ^\r\n      6 |\r\n      7 | jest.mock(\".\/services\/test.service\");\r\n      8 |\r\n\r\n      at ModuleMap._getModuleMetadata (node_modules\/jest-haste-map\/build\/ModuleMap.js:231:14)\r\n      at Object.<anonymous> (src\/app\/app.component.spec.ts:5:1)\r\n\r\nTest Suites: 1 failed, 2 passed, 3 total\r\nTests:       3 passed, 3 total\r\nSnapshots:   0 total\r\nTime:        6.013s\r\n\r\n\r\n~~~\r\n\r\nThis is the .spec.ts file\r\n~~~\r\nimport { async, ComponentFixture, TestBed } from '@angular\/core\/testing';\r\nimport { AppComponent } from '.\/app.component';\r\nimport { TestService } from '.\/services\/test.service';\r\nimport { of } from 'rxjs';\r\nimport { MyLibModule } from 'my-lib';\r\n\r\njest.mock(\".\/services\/test.service\");\r\n\r\ndescribe('AppComponent', () => {\r\n  let component: AppComponent;\r\n  let fixture: ComponentFixture<AppComponent>;\r\n  let testService: TestService;\r\n  \r\n  beforeEach(async(() => {\r\n    TestBed.configureTestingModule({\r\n      declarations: [AppComponent],\r\n      imports : [MyLibModule],\r\n      providers: [TestService]\r\n    })\r\n      .compileComponents();\r\n  }));\r\n\r\n  beforeEach(() => {\r\n    testService = TestBed.get(testService);\r\n\r\n    jest.spyOn(testService, \"getResource\").mockReturnValue(\r\n      of({\r\n        username: 'Brent'\r\n      })\r\n    );\r\n    \r\n    fixture = TestBed.createComponent(AppComponent);\r\n    component = fixture.componentInstance;\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n});\r\n~~~","Facing the same issue, I have my own custom library as shared project on angular. I have all necessary things like `moduleNameMapper` but still the issue is there. ","think i might have found what caused this. If you make any updates to package-lock this happens \ud83d\ude15 , when i removed any changes on my parent package lock. This error got resolved\r\n\r\n","We should never have `TypeError`s internally, no matter what your config is. Can anyone provide a full, minimal reproduction we can clone and run locally to see the error?","1. Create a library project along with normal angular application\r\n`ng new my-workspace --createApplication=\"false\"`\r\n`cd my-workspace`\r\n`ng generate application my-app`\r\n`ng generate library my-lib`\r\n\r\n2. Output path for library project will be `dist\/my-lib` and for application it should `dist\/my-app`\r\n\r\n3. In main tsconfig.json `\"paths\": {\r\n      \"@custom\/my-lib\": [\r\n        \"dist\/my-lib\"\r\n      ],\r\n      \"@custom\/my-lib\/*\": [\r\n        \"dist\/my-lib\/*\"\r\n      ]\r\n    }`\r\n\r\n4. In jest.config.js add configuration for path mapper as `moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths || {}, {\r\n  prefix: '<rootDir>\/'\r\n})`\r\n\r\n5. And in one of the spec\/test file use the library as `import { Something} from '@custom\/my-lib'`\r\n\r\nThis fails at the above import with the error as `dupMap.get is not a function`.\r\nPS: Jasmine framework works fine for same test","I have encountered this too in a mixed TypeScript and JavaScript project that uses Vue. As with the other posters, this happens when importing a class from another custom library that is included as a git submodule, referenced from `package.json` using `file:` syntax. The error occurs several layers deep in the import hierarchy, not from an import from the .spec file itself. So the import hierarchy is:\r\n\r\n - `thing.spec.ts`\r\n - --> `import { MyComponent } from 'MyComponent.vue'`\r\n - --> `import { SomeModel } from '@my-org\/package-name'`\r\n - --> `import { AnotherModel } from '.\/local_file'`\r\n - --> `import { Utility } from '@my-org\/another-package'`\r\n\r\nThe error is raised at the fourth level down, when importing `Utility` from `@my-org\/another-package`:\r\n\r\n```\r\nTypeError: dupMap.get is not a function\r\n\r\n> 1 | import { Utility } from '@my-org\/another-package'\r\n    | ^\r\n\r\nat ModuleMap._getModuleMetadata (node_modules\/jest-haste-map\/build\/ModuleMap.js:231:14)\r\nat Object.<anonymous> (--redacted local path--.js:1:1)\r\n```","@isumeetk thanks, but could you do those steps in a repo and publish that? I tried to follow your steps but step 3 is unclear (`paths` is already in the file - should I replace or add to it?), step 4 is unclear (should I create this file? What is `pathsToModuleNameMapper`?) and step 5 is unclear since I don't know which file to make the change.\r\n\r\nI could probably figure out these things if I spent some time on it, but it's a higher barrier than need be here. Either a repo I can clone, or a repl.it\/codesandbox would be ideal. Ideally I should be able to clone, install, and run to see the error\r\n\r\n>PS: Jasmine framework works fine for same test\r\n\r\nNot sure what this means - jasmine instead of jest, or using jest-jasmine (which is the default test runner within jest)?","Well this is interesting, while creating a repo to reproduce something made it work, both in reproducing repo and the my main repo. Still for people who want to go through the working structure here is the repo https:\/\/github.com\/isumeetk\/jest-angular-sample","I have the same issue when I import a module from a custom library, just like @franjpr.\r\nAny solution? ","For the umpteenth time, if you want it fixed somebody needs to put together a repository, or some other reproduction, where we can see the error.\r\n\r\nhttps:\/\/www.snoyman.com\/blog\/2017\/10\/effective-ways-help-from-maintainers","not sure if this will help, but i am seeing this issue on a lerna repo i'm setting up. it seems to be an issue with symlinks and copies (still figuring it out since i inherited the code). deleted some symlinks\/copies before running tests made this issue go away.\r\n\r\nmain issue is that the `dupMap` object is not a `Map` instance. here's what it looks like for me:\r\n\r\n```json\r\n[\r\n  [\r\n    \"g\",\r\n    [\r\n      [\r\n        \"packages\/components\/lib\/utils\/package.json\",\r\n        1\r\n      ],\r\n      [\r\n        \"packages\/utils\/package.json\",\r\n        1\r\n      ]\r\n    ]\r\n  ]\r\n]\r\n```\r\n\r\ni'm guessing something isn't creating a `Map` object in `this._raw.duplicates.get(name)` properly?","Hi all,\r\n\r\nHere is a minimal repository where this bug is reproduced: https:\/\/github.com\/WilliamChelman\/angular-jest-bug-repro\r\n\r\nHow-to:\r\n- `npm ci`\r\n- `npm t`\r\n  - This fails with something like this\r\n>  Cannot find module '@me\/lib-a' from 'lib-b.component.ts'\r\n>    Require stack:\r\n>      projects\/me\/lib-b\/src\/lib\/lib-b.component.ts\r\n>      projects\/me\/lib-b\/src\/lib\/lib-b.component.spec.ts\r\n  - This is expected since in our tsconfig.json we have the paths that point to a built version of the package in dist\/\r\n- `npm run build-all`\r\n- `npm t`\r\n  - This fails with\r\n>The name `@me\/lib-a` was looked up in the Haste module map. It cannot be resolved, because there exists several different files, or packages, that provide a module for that\r\nparticular name and platform. The platform is generic (no extension). You must delete or blacklist files until there remains only one of these:\r\n>      * `\/home\/william\/Dev\/other\/angular-jest-bug\/dist\/me\/lib-a\/package.json` (package)\r\n>      * `\/home\/william\/Dev\/other\/angular-jest-bug\/projects\/me\/lib-a\/package.json` (package)\r\n\r\nSome of the leads that were explored to fix this, but to no avail and usually end up with the \"dupMap.get is not a function\" error:\r\n- moduleDirectories: ['node_modules', 'dist']\r\n- modulePathIgnorePatterns: ['<rootDir>\/projects']\r\n- modyfing paths in tsconfig to point to src\/public-api of @me\/lib-a instead of built version in dist\r\n\r\nSolution that did work but felt dirty: change projects\/me\/lib-a\/ng-package.json to\r\n```json\r\n{\r\n  \"$schema\": \"..\/..\/..\/node_modules\/ng-packagr\/ng-package.schema.json\",\r\n  \"dest\": \"..\/..\/..\/node_modules\/@me\/lib-a\", \/\/ here\r\n  \"lib\": {\r\n    \"entryFile\": \"src\/public-api.ts\"\r\n  }\r\n}\r\n```\r\nSo that the build is put in the node_modules directly, so then it's considered as any other external lib when tests are launched.\r\n\r\nTo whoever read this, have a great day :smile: \r\n\r\n**EDIT**: doesn't really reproduce the dupMap.get error unfortunately, but leaving this at least for the ng-package.json hack that might help someone.","@WilliamChelman I'm unable to reproduce. I get the haste errors you note, but\r\n\r\n1. `moduleDirectories: ['node_modules', 'dist']` makes no difference\r\n1. `modulePathIgnorePatterns: ['\/projects']` makes it find no tests\r\n1. I don't know what `modyfing paths in tsconfig` entails so I didn't touch that part.\r\n\r\nI haven't done any angular since v1, so there might be some detail I'm missing.\r\n\r\nCould you add a commit to that repo so that I can run `npm cit` and get the `dupMap.get is not a function` error?","For some reason I'm currently unable to reproduce the dupMap.get error, even if it was that same error that brought me here... But now that I think of it (after sleeping a bit), it seems like the issue I have might be more for ts-jest in fact, since it looks like it is the tsconfig file that doesn't bode well with module resolution in this context. I'll see to create an issue on their side instead, thank you for your time @SimenB .","I still think this is a bug in Jest somehow, if nothing else we should provide a better error. So if you figure out why you get the error please report back so we can improve things \ud83d\udc4d","@SimenB just ran into this same problem, and it appears that I needed to ignore my output folders as @CameronAckermanSEL mentioned.\r\n`modulePathIgnorePatterns: [\"packages\/*\/dist\"]` for me, as I have a mono-repo where all package sources are in `packages\/**\/src\/*` and `packages\/**\/dist` is where they build to.\r\n\r\nHopefully someone else will find this helpful :)","I was able to get rid of this error by calling jest --clearCache, probably because I had fixed one of the other causes listed above, but the cache retained the error?","I'm working in an Angular CLI project with an application and a library.\r\nIt get it working by:\r\n1. Update the ng-package.json file like @WilliamChelman mentioned\r\n` ...\r\n \"dest\": \"..\/..\/node_modules\/@my-domain\/my-library\",\r\n...`\r\n2. In the tsconfig.spec.json of the application, I added a configuration entry for the path resolution such as:\r\n`\"paths\": {\r\n      \"@my-domain\/my-library\": [\r\n        \"..\/node_modules\/@my-domain\/my-library\"\r\n      ]\r\n    }`","I just resolved same problem with angular project by this config:\r\n```js\r\n\/\/ jest.config.js\r\nmodule.exports = {\r\n\tpreset: 'jest-preset-angular',\r\n\tsetupFilesAfterEnv: ['<rootDir>\/src\/setupJest.ts'],\r\n\ttestRegex: ...,\r\n\troots: ['<rootDir>\/src'],\r\n\tmodulePaths: ['<rootDir>\/dist'],\r\n};\r\n```\r\n\r\nMore at [Medium](https:\/\/medium.com\/angular-in-depth\/integrate-jest-into-an-angular-application-and-library-163b01d977ce)","I ran into this same issue today. For me the issue was related to using [yalc](https:\/\/www.npmjs.com\/package\/yalc) to develop multiple dependent repos.\r\n\r\nThe problem disappeared after I removed all yalc installations (`yalc remove --all` in every repo and then verified that `yalc installations show` was empty)","I have the same issue in my Angular project. For some reason, when I remove `package.json` in (`projects\/my-project`, not the one in my root), the error is gone.\r\n\r\nI got this error when I added a path mapping to my project from my `tsconfig.spec.json`:\r\n\r\n```json\r\n{\r\n    \"compilerOptions\": {\r\n        \"paths\": {\r\n            \"my-project\": [\"projects\/my-project\/src\/public-api.ts\"]\r\n        }\r\n    }\r\n}\r\n```\r\nAnd, my `jest.config.js`:\r\n```javascript\r\nmodule.exports = {\r\n    moduleNameMapper: {\r\n        \"my-project\": \"<rootDir>\/projects\/my-project\/src\/public-api.ts\"\r\n    },\r\n};\r\n```\r\n\r\nHowever, I need my `package.json` there because it is the one that gets packaged by Angular. \r\n\r\nMy workaround was to rename the path mapping of `my-project` to `my-project-api`, which fixed the issue.","Can you put together a reproduction? I'd like to fix this so people don't need any workarounds (or at least give a clearer\/actionable error)","I have found the issue. I will describe it here and post a reproducible demo in a bit. Here is what happens:\r\n\r\n<monorepo-root>\/my-app -> Installs @myproject\/my-library and mocks some of the functions of the library in tests\r\n<monorepo-root>\/my-library -> After building CJS and ESM modules, it copies package.json to build directory (e.g `dist\/`).\r\n\r\n**Case 1:** If I run `npm test` from root, everything will pass without issues. \r\n**Case 2:** Build library using `npm run build` in `<monorepo-root>\/my-library`. Then, run tests from root. This will give `dupMap.get` error.\r\n\r\nJest version: ^24.9.0\r\n","have the same issue","I encountered this issue today and packed it as a reproduction. I'm building my own typescript project template. I uses ts-jest. What I'm doing is trying to test the packed package. So my run script uses 'npm pack' to pack the package, extract it in a directory, 'npm link' from there, then install it back locally. Then I run a test that import my package using an absolute path as if from 'npm install'. \r\n\r\nTo reproduce the issue:\r\n\r\n```\r\ngit clone https:\/\/github.com\/bingtimren\/ts-proj-template.git\r\ncd ts-proj-template\/\r\ngit checkout jest-issue-9021 \r\nnpm install\r\nnpm run build\r\nnpm run test\r\n```\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/2824513\/109437236-dcdb7980-7a77-11eb-87e6-41b564038671.png)\r\n","After running into this issue myself, I encountered [this helpful PR](https:\/\/github.com\/isomorphic-git\/isomorphic-git\/pull\/1233) from the \"isomorphic git\" repo where they fixed this problem. While the PR doesn't contain much of an explanation, looking at it's very simple change was enough for me to identify the fix in my own repo. In my case, I have a monorepo using yarn workspaces and [lerna](https:\/\/lerna.js.org\/) where `package B` imported `package A`. I had failed to configure the jest `modulePathIgnorePatterns` to include the build output of `package A`. When I added the build output of `package A` to `modulePathIgnorePatterns`, this error goes away. If I remove the build output of `package A` from `modulePathIgnorePatterns`, this error re-appears.\r\n\r\nThe error only appears for `package B's` tests. My assumption is that, somehow, when a `package B` test is attempting to locally import `package A` (again, this is a monorepo using lerna),  jest is getting confused by the presence of the `package A` build in the `package A` source folder. I don't have a reproduction to share at this time, unfortunately.\r\n\r\nThe diff from the \"isomorphic git\" fix which helped me solve this issue looks like:\r\n\r\n```diff\r\nmodule.exports = {\r\n+  modulePathIgnorePatterns: ['<rootDir>\/website'],\r\n  testRegex: '\/__tests__\/(server-only\\\\.)?test-[^\\\\\/]+\\\\.js',\r\n  moduleNameMapper: {\r\n    '^isomorphic-git$': '<rootDir>\/src'\r\n```\r\n\r\ncc @SimenB ","Interesting stuff. Thanks for the reproduction @bingtimren, sorry I missed it when you posted it!\r\n\r\nIf I run the tests with `-i` (i.e. forcing not to use workers) we get the correct error\r\n\r\n```\r\n    The name `@bingsjs\/ts-proj-template` was looked up in the Haste module map. It cannot be resolved, because there exists several different files, or packages, that provide a module for that particular name and platform. The platform is generic (no extension). You must delete or exclude files until there remains only one of these:\r\n\r\n      * `\/Users\/simen\/repos\/ts-proj-template\/build\/pack\/package\/package.json` (package)\r\n      * `\/Users\/simen\/repos\/ts-proj-template\/package.json` (package)\r\n```\r\n\r\nSo there's something wrong with (de)serialization of the `Map`s between workers. Will dig some more into this, but for people encountering this - running with `-i` (short for `--run-in-band`) should help you debug","Reverting the `jest-runner` parts of #8237 fixes the issue","I currently have a lerna project, this issue went away for me after upgrading to jest version 27.4.5.","Error: \r\n```\r\nTypeError: dupMap.get is not a function\r\n\r\n       5 |\r\n       6 | import ua from '@searchfe\/user-agent';\r\n    >  7 | import compare from 'versions-compare';\r\n```\r\n\r\nFix: \r\n\r\ni output a log in this file ('node_modules\/jest-haste-map\/build\/ModuleMap.js:209:14')\r\n```\r\nname === 'versions-compare' && (console.log(name, ...dupMap));\r\nthis._assertNoDuplicates(\r\n  name,\r\n  _constants.default.GENERIC_PLATFORM,\r\n  `supportsNativePlatform,`\r\n  dupMap.get(_constants.default.GENERIC_PLATFORM)\r\n);\r\n```\r\nfound array\r\n```\r\nversions-compare [\r\n  'g',\r\n  [\r\n    [ 'dist\/modules\/versions-compare\/package.json', 1 ],\r\n    [ 'amd_modules\/versions-compare\/package.json', 1 ]\r\n  ]\r\n]\r\n```\r\n\r\nbecause it found 2 pacakges, The answer above give me clue https:\/\/github.com\/facebook\/jest\/issues\/9021#issuecomment-539369466  @[cameracker](https:\/\/github.com\/cameracker)\r\n\r\nFixed \ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80 \r\n```\r\nmodulePathIgnorePatterns: [\r\n    \"dist\"\r\n],\r\n```","Meet this problem on an Angular app with some Angular libs, problem solved after adding `moduleNameMapper` to root `jest.config.js`.\r\n> see: https:\/\/kulshekhar.github.io\/ts-jest\/docs\/getting-started\/paths-mapping\/\r\n\r\nLet's says we have a Angular lib placed at `projects\/my-lib`, your root `tsconfig` paths may look like this\r\n```json\r\n{\r\n  ...others\r\n  \"compilerOptions\": {\r\n    \"paths\": {\r\n      \"@my-scope\/my-lib\": [\r\n        \"dist\/my-lib\/my-scope-my-lib\",\r\n        \"dist\/my-lib\"\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nYour root `jest.config.js` will need to set\r\n- `roots` to `['<rootDir>\/src']`\r\n- `moduleNameMapper` to map `@my-scope\/my-lib` to `projects\/my-lib\/src\/public-api`\r\n```js\r\nmodule.exports = {\r\n  roots: ['<rootDir>\/src'],\r\n  moduleNameMapper: {\r\n    '@my-scope\/my-lib': '<rootDir>\/projects\/my-lib\/src\/public-api',\r\n  },\r\n};\r\n```\r\n\r\nAnd for my-lib `jest.config.js` set\r\n- `roots` to `['<rootDir>\/projects\/my-lib']`\r\n```js\r\nmodule.exports = {\r\n  roots: ['<rootDir>\/projects\/my-lib'],\r\n};\r\n```\r\n","Facing same issue. Anyone solved it?","> I have the same issue in my Angular project. For some reason, when I remove `package.json` in (`projects\/my-project`, not the one in my root), the error is gone.\r\n> \r\n> I got this error when I added a path mapping to my project from my `tsconfig.spec.json`:\r\n> \r\n> ```json\r\n> {\r\n>     \"compilerOptions\": {\r\n>         \"paths\": {\r\n>             \"my-project\": [\"projects\/my-project\/src\/public-api.ts\"]\r\n>         }\r\n>     }\r\n> }\r\n> ```\r\n> \r\n> And, my `jest.config.js`:\r\n> \r\n> ```js\r\n> module.exports = {\r\n>     moduleNameMapper: {\r\n>         \"my-project\": \"<rootDir>\/projects\/my-project\/src\/public-api.ts\"\r\n>     },\r\n> };\r\n> ```\r\n> \r\n> However, I need my `package.json` there because it is the one that gets packaged by Angular.\r\n> \r\n> My workaround was to rename the path mapping of `my-project` to `my-project-api`, which fixed the issue.\r\n\r\nI met the same problem and the error disappeared after I changed the packageJson.name of the root directory. But I need to keep this root packageJson.name. Any update about this issue?\r\n\r\nI'm using jest@29.5.0, and here is my tsconfg and jest config:\r\n\r\n```json\r\n\"compilerOptions\": {\r\n  \"baseUrl\": \".\",\r\n  \"paths\": {\r\n    \"my-root-package\": \".\"\r\n  }\r\n}\r\n```\r\n\r\n```js\r\nmodules.exports = {\r\n  rootDir: __dirname,\r\n  roots: [__dirname],\r\n  moduleNameMapper: {\r\n    '^my-root-package$': '<rootDir>'\r\n  }\r\n};\r\n````","> Error:\r\n> \r\n> ```\r\n> TypeError: dupMap.get is not a function\r\n> \r\n>        5 |\r\n>        6 | import ua from '@searchfe\/user-agent';\r\n>     >  7 | import compare from 'versions-compare';\r\n> ```\r\n> \r\n> Fix:\r\n> \r\n> i output a log in this file ('node_modules\/jest-haste-map\/build\/ModuleMap.js:209:14')\r\n> \r\n> ```\r\n> name === 'versions-compare' && (console.log(name, ...dupMap));\r\n> this._assertNoDuplicates(\r\n>   name,\r\n>   _constants.default.GENERIC_PLATFORM,\r\n>   `supportsNativePlatform,`\r\n>   dupMap.get(_constants.default.GENERIC_PLATFORM)\r\n> );\r\n> ```\r\n> \r\n> found array\r\n> \r\n> ```\r\n> versions-compare [\r\n>   'g',\r\n>   [\r\n>     [ 'dist\/modules\/versions-compare\/package.json', 1 ],\r\n>     [ 'amd_modules\/versions-compare\/package.json', 1 ]\r\n>   ]\r\n> ]\r\n> ```\r\n> \r\n> because it found 2 pacakges, The answer above give me clue [#9021 (comment)](https:\/\/github.com\/jestjs\/jest\/issues\/9021#issuecomment-539369466) @[cameracker](https:\/\/github.com\/cameracker)\r\n> \r\n> Fixed \ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\r\n> \r\n> ```\r\n> modulePathIgnorePatterns: [\r\n>     \"dist\"\r\n> ],\r\n> ```\r\n\r\non a `gatsbyjs` project, this worked for me","Hoiw about adding (for these who are using yalc):\r\n`\"modulePathIgnorePatterns\": [\"dist\", \".yalc\"],` ? \r\nThis solve the issue for me. If I use yalc remove --all like @vilvai mentioned, I'll loose the dependencies and my project won't run successfully anymore. \r\n","I was gonna look into fixing the error in this case now, but the reproduction from https:\/\/github.com\/jestjs\/jest\/issues\/9021#issuecomment-787544325 is unfortunately deleted. Does anybody else have a small reproduction I can test with?"],"labels":["Help Wanted",":boom: Regression"]},{"title":"Race condition on snapshots when a test timeouts","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nWhen I have two tests that use snapshots, if the first timeouts, the content of the first test will be in the snapshot of the second test\r\n\r\n## To Reproduce\r\n\r\nI have made a repository that reproduces the issue :\r\n* Repository : https:\/\/github.com\/onigoetz\/jest-race-condition-repro\r\n* Github Actions failed jest run : https:\/\/github.com\/onigoetz\/jest-race-condition-repro\/runs\/218697180\r\n\r\nThe code \r\n\r\n```javascript\r\n\/**\r\n * The Dummy code to test\r\n * Just a function that returns the first argument after 600ms\r\n * @param {*} content\r\n *\/\r\nfunction longRunningFunction(content) {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve(content);\r\n    }, 600);\r\n  });\r\n}\r\n\r\n\/\/ This is only needed in the test repro\r\n\/\/ If the snapshots don't exist, leave the time for them to be created\r\n\/\/ If they exist, fail the test on purpose\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst snapshotFile = `${path.basename(__filename)}.snap`;\r\nconst snapshotPath = path.dirname(process.cwd(), \"__snapshots__\", snapshotFile);\r\nif (fs.existsSync(snapshotPath)) {\r\n  jest.setTimeout(400);\r\n}\r\n\r\n\/\/ The tests\r\nit(\"Runs a first test\", async () => {\r\n  expect(\r\n    await longRunningFunction(\"Content of the first test\")\r\n  ).toMatchSnapshot();\r\n});\r\n\r\nit(\"Runs a second test\", async () => {\r\n  expect(\r\n    await longRunningFunction(\"Content of the second test\")\r\n  ).toMatchSnapshot();\r\n});\r\n```\r\n\r\nRun this code twice to see the error\r\n\r\nOutput\r\n\r\n```\r\n  \u25cf Runs a second test\r\n\r\n    expect(received).toMatchSnapshot()\r\n\r\n    Snapshot name: `Runs a second test 1`\r\n\r\n    Snapshot: \"Content of the second test\"\r\n    Received: \"Content of the first test\"\r\n\r\n      27 |   expect(\r\n      28 |     await longRunningFunction(\"Content of the first test\")\r\n    > 29 |   ).toMatchSnapshot();\r\n``` \r\n\r\nYou see that it's the call to snapshot from the first test that ends in the second test.\r\n\r\n## Expected behavior\r\n\r\nThe content of the first test should be in the second snapshot\r\nThe content of the second test should be in the second snapshot\r\n\r\n## Link to repro\r\n\r\n* Repository : https:\/\/github.com\/onigoetz\/jest-race-condition-repro\r\n* Github Actions failed jest run : https:\/\/github.com\/onigoetz\/jest-race-condition-repro\/runs\/218697180\r\n\r\n## envinfo\r\n\r\n```bash\r\n  System:\r\n    OS: Linux 4.15 Ubuntu 18.04.3 LTS (Bionic Beaver)\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz\r\n  Binaries:\r\n    Node: 8.16.0 - ~\/.nvm\/versions\/node\/v8.16.0\/bin\/node\r\n    Yarn: 1.17.3 - \/usr\/bin\/yarn\r\n    npm: 6.4.1 - ~\/.nvm\/versions\/node\/v8.16.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^24.9.0 => 24.9.0 \r\n```\r\nIt's also the same on GitHub actions on node 8, 10 and 12\r\n","comments":["I also see this behavior quite often -- would be nice if there's either a fix or a workaround","I'll take a stab at this. This'll be my first time contributing to Jest, so any pointers will be welcome.","I came across this a few days ago : https:\/\/itnext.io\/nodejs-logging-made-right-117a19e8b4ce\r\n\r\nContinuation Local Storage, allows to store data in the context of functions. maybe this could help to make sure we have the right name of current test even if going to another test.\r\n\r\nI didn't try it so I have no idea if that would help.","## Update 10-26-2019\r\n\r\nOkay, so a quick progress update:\r\n\r\n1. Confirmed that this issue does exist.\r\n2. I think it has to do with setTimeout or how queues work in `\/jest\/packages\/jest-jasmine2\/`.\r\n3. I'll keep working on this issue in the next few days.\r\n\r\nIt looks like this bug only occurs when multiple snapshots take longer than the setTimeout function. When these tests do pass, Jest fixes the snapshot file.\r\n\r\n### Creating a fix\r\n\r\nFrom what I understand the following are the **actual** results:\r\n\r\n1. expect(longRunningFunction()).toMatchSnapshot()\r\n2. Error! `longRunningFunction()` took too longer than setTimeout(400).\r\n3. Create 1 incorrect snapshot:\r\n\r\n```\r\n\/\/ Jest Snapshot v1, https:\/\/goo.gl\/fbAQLP\r\n\r\nexports[`Runs a second test 1`] = `\"Content of the first test\"`;\r\n```\r\n\r\nAnd below are the **expected** results:\r\n\r\n1. expect(longRunningFunction()).toMatchSnapshot()\r\n2. Error! `longRunningFunction()` took too longer than setTimeout(400).\r\n3. Create 2 correct snapshots:\r\n\r\n```\r\n\/\/ Jest Snapshot v1, https:\/\/goo.gl\/fbAQLP\r\n\r\nexports[`Runs a first test 1`] = `\"Content of the first test\"`;\r\nexports[`Runs a second test 1`] = `\"Content of the second test\"`;\r\n```","@Alex-Cannon thanks for investigating! My intuition would also be that this is because when the `longRunningFunction()` resolves and the snapshot assertion happens, the snapshot state already contains the next test, which has already started, as the current test.\r\nSide note: Might be interesting to try out how [jest-circus](https:\/\/github.com\/facebook\/jest\/tree\/master\/packages\/jest-circus), a newer replacement for jest-jasmine2 behaves here.\r\nUnfortunately, there is no way to stop the rest of the test that timed out from running, and we cannot know which test caused the async snapshot assertion. The only \"fix\" I can spontaneously think of is not writing any snapshots at all if one of the test cases timed out :|","@jeysal thanks for the background, definitely saved me hours of time. I think the best solution for now is to not write snapshots at all if a test case times out. We can modify this later if needed.","Faced this issue too. Passing 3rd argument to the longest test to increase timeout helped (https:\/\/jestjs.io\/docs\/en\/api#testname-fn-timeout) - actually, it prevents test both from failure by timeout and making mess in snapshots.\r\nI.e. in the example:\r\nit(\"Runs a first test\", async () => {\r\n  expect(\r\n    await longRunningFunction(\"Content of the first test\")\r\n  ).toMatchSnapshot();\r\n}, **800**);\r\nJust a plain workaround, but might be helpful for someone facing messy snapshots due to the issue.","Hi,\r\n\r\nI made some experimentation with continuation local storage to make this work (or at least have races detected)\r\n\r\nI won't do a PR with this, because it's pretty experimental and doesn't work with jest-circus, but it could provide the beginning of a solution: \r\n\r\n```bash\r\ngit clone https:\/\/github.com\/onigoetz\/jest-race-condition-repro\r\ncd jest-race-condition-repro\r\nyarn install\r\nyarn test\r\n```\r\n\r\nYou see here that the first test timeouts, and the second test has the wrong content (current state of the bug)\r\n\r\n```bash\r\npatch -p1 < experimental-fix.patch\r\nyarn test\r\n```\r\n\r\nYou can now see that both tests fail with a timeout but this time there is a console message : \r\n\r\n```\r\n  console.log\r\n    Trying to snapshot on a different test than the test running now { currentTestName: 'Runs a second test', cls: 'Runs a first test' }\r\n\r\n      at _toMatchSnapshot (node_modules\/jest-snapshot\/build\/index.js:322:15)\r\n```\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Stale maybe, but the bug is still present in Jest 27 : https:\/\/github.com\/onigoetz\/jest-race-condition-repro","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","We are encountering this problem on Jest 27.2.5, so it appears to have still not been resolved.\r\n\r\nThanks to everyone who has been looking at this issue so far!","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":bug: Bug","Stale"]},{"title":"Jest detects linux .snap package file as obsolete snapshot","body":"## Current behavior\r\nwhen running Jest, it's detecting a .snap package I built for Linux as an obsolete snapshot, and it's causing my tests to fail. I tried ignoring the folder with no success.\r\n\r\n#### Part of the test output:\r\n```bash\r\n[1] Snapshot Summary\r\n[1]  \u203a 1 snapshot file obsolete from 1 test suite. To remove it, run `yarn run test:main -u`.\r\n[1]    \u21b3   \u2022 release\/kafka-lens_2.0.0_amd64.snap\r\n[1] \r\n[1] Test Suites: 1 skipped, 2 passed, 2 of 3 total\r\n[1] Tests:       2 skipped, 6 passed, 8 total\r\n[1] Snapshots:   1 file obsolete, 1 passed, 1 total\r\n[1] Time:        4.173s\r\n[1] Ran all test suites matching \/main\/i.\r\n[0] Snapshot Summary\r\n[0]  \u203a 1 snapshot file obsolete from 1 test suite. To remove it, run `yarn run test:renderer -u`.\r\n[0]    \u21b3   \u2022 release\/kafka-lens_2.0.0_amd64.snap\r\n[0] \r\n[0] Test Suites: 10 passed, 10 total\r\n[0] Tests:       37 passed, 37 total\r\n[0] Snapshots:   1 file obsolete, 10 passed, 10 total\r\n[0] Time:        4.171s\r\n[0] Ran all test suites matching \/client\/i.\r\nerror Command failed with exit code 1.\r\ninfo Visit https:\/\/yarnpkg.com\/en\/docs\/cli\/run for documentation about this command.\r\nerror Command failed with exit code 1.\r\ninfo Visit https:\/\/yarnpkg.com\/en\/docs\/cli\/run for documentation about this command.\r\n[0] yarn test:renderer exited with code 1\r\n[1] yarn test:main exited with code 1\r\nerror Command failed with exit code 1.\r\ninfo Visit https:\/\/yarnpkg.com\/en\/docs\/cli\/run for documentation about this command.\r\n```\r\n#### package.json scripts:\r\n```\r\n\"test\": \"concurrently \\\"yarn test:renderer\\\" \\\"yarn test:main\\\"\",\r\n\"test:renderer\": \"jest client\",\r\n\"test:main\": \"jest main\"\r\n```\r\n\r\n#### Folder Structure\r\n```\r\nclient\r\n|--src\r\n   |--components\r\n   |--__tests__\r\n      |--__snapshots__\r\n         |--component.jsx.snap\r\n|--...\r\nmain\r\n|--...\r\nrelease\r\n|--kafka-lens_2.0.0_amd64.snap\r\n|--...\r\njest.config.js\r\npackage.json\r\n```\r\n\r\n#### jest.config.js\r\n```javascript\r\nmodule.exports = {\r\n  verbose: true,\r\n  snapshotSerializers: ['enzyme-to-json\/serializer'],\r\n  setupFiles: ['.\/setupTests.js'],\r\n  moduleNameMapper: {\r\n    '\\\\.(css|less|scss)$': '<rootDir>\/client\/src\/app\/__mocks__\/styleMock.js',\r\n    '\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':\r\n      '<rootDir>\/client\/src\/app\/__mocks__\/assetsTransformer.js',\r\n  },\r\n  moduleDirectories: ['node_modules'],\r\n  modulePaths: ['<rootDir>'],\r\n  testPathIgnorePatterns: ['<rootDir>\/release\/', '<rootDir>\/node_modules\/'],\r\n};\r\n```\r\n\r\n## Expected behavior\r\nBeing able to ignore the path to the release folder, so Jest doesn't try to parse any files inside it as a snapshot\r\n\r\n## envinfo\r\n\r\n```bash\r\nSystem:\r\n    OS: Linux 5.0 Ubuntu 18.04.3 LTS (Bionic Beaver)\r\n    CPU: (12) x64 Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\nBinaries:\r\n    Node: 10.16.2 - ~\/.nvm\/versions\/node\/v10.16.2\/bin\/node\r\n    Yarn: 1.17.3 - ~\/WebstormProjects\/kafka-lens\/node_modules\/.bin\/yarn\r\n    npm: 6.9.0 - ~\/.nvm\/versions\/node\/v10.16.2\/bin\/npm\r\nnpmPackages:\r\n    jest: ^24.1.0 => 24.9.0\r\n```\r\n","comments":["Could you provide a minimal repro, so it's easier to investigate?","The logic lives here: https:\/\/github.com\/facebook\/jest\/blob\/0935f7c2cd7780e47365511e35efc829ba359df4\/packages\/jest-snapshot\/src\/index.ts#L132-L133\r\n\r\nNot sure how to handle it... #8665 added the logic that if the resolved test file is ignored, then we ignore the snap file. Maybe we can tweak it to cover your use-case as well? Thoughts?","Thanks to both! I was trying to find the code which looked for the snap files, but I couldn't find it on my own. I'll give it a look and maybe I can think of a solution.\r\n\r\nWhy don't just ignore snap files inside `testPathIgnorePatterns`? \r\n\r\n```\r\nconst list = files.filter(snapshotFile => {\r\n   const testPath = snapshotResolver.resolveTestPath(snapshotFile);\r\n\r\n   \/\/ ignore snapshots of ignored tests\r\n   \/\/ here, instead of evaluating if the 'associated test file' is ignored (which makes no sense for a .snap file that's not a real snapshot) also ignore the snapshot if it falls under the testIgnorePatterns defined by the user.\r\n   if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\r\n     return false;\r\n   }\r\n   ...\r\n}\r\n```","I'm also running into this issue. Since I'm using CRA, I cannot add `testPathIgnorePatterns` without ejecting. However, I see that the Jest config in CRA has a `testMatch` configuration as follows:\r\n\r\n```javascript\r\n    testMatch: [\r\n      '<rootDir>\/src\/**\/__tests__\/**\/*.{js,jsx,ts,tsx}',\r\n      '<rootDir>\/src\/**\/*.{spec,test}.{js,jsx,ts,tsx}',\r\n    ],\r\n```\r\n\r\nThe file that is causing me headaches is in a `dist` folder and it's clearly not associated with a test with a name like `dist\/graasp-desktop_0.14.0_amd64.snap`.\r\n\r\nPerhaps it can be ignored if not within the `testMatch` pattern?","I just ran into this as well. I like @nahuelarjonadev's suggestion of ignoring snap files in `testPathIgnorePatterns`. This is actually the first thing that I tried as a workaround, and was sad that it didn't work.\r\n\r\nAny chance that this can be implemented?","Similar issue here, I got two types of test files (basically one unit, one much slower using storyshots) and as such I have a variable `testMatch` config.\r\n\r\nFor example: TestA has a snapshot, TestB has a snapshot\r\n\r\nWhen running TestA and TestB at the same time, no issue. But if I change the `testMatch` to only include TestA, Jest will complain that TestB's snapshot is obsolete as it's no longer used.\r\n\r\nWhat would fix it for me: when a .snap file is found, resolve it to the test file and _only_ report it as obsolete if that test file has been run. If the test file hasn't been run, it's either not a Jest snapshot file or it's not supposed to be included in this test run.","Similar issue -- Postgres creates `.snap` files, and so far I've found no combination of `roots`, `testPathIgnorePatterns` or other settings that will make jest ignore these files if they exist below the project root. These files are reported as obsolete snapshots and fail the jest test. Innocently running `jest -u` deletes the DB files. Bad surprise. \r\n\r\nWhat's needed:\r\n\r\n1 -- ignore files named `*.snap` unless they are Jest snapshots; don't show as obsolete; don't delete via `-u`; etc.\r\n\r\n2 -- respect the various path parameters (`testPathIgnorePatterns`, `modulePathIgnorePatterns`, `roots`, probably others I'm not aware of.\r\n\r\n3 -- provide a big-hammer config option `disableSnapshots` that if set, doesn't look for or operate on snapshots at all","I found a workaround that works fine for my case by using custom `snapshotResolver`. Basically you need that your `resolveTestPath` method returns a valid test file for given snapshotFile, then snapshot won't be considered obsolete.\r\n","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","still an issue"],"labels":["Needs Triage","Bug Report"]},{"title":"Configuration file equivalent for --passWithNoTests flag","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nAdd a `passWithNoTests` boolean support in the configuration file, to have the same effect as the `--passWithNoTests` CLI flag.\r\n\r\n## Motivation\r\n\r\nWe currently use a shared configuration file across our organization, so that every repo running Jest will have the same default configuration (we do the same for Prettier, TSLint, Webpack, etc.). This ensures consistency, avoids surprises, and lets our teams have a sort of internal \"zero conf\" set up with the preferences\/settings of the engineering organization.\r\n\r\nThis works really well with Jest, except we are now adding `--passWithNoTests` to all our new repos, where a configuration file equivalent would let us do it once.\r\n\r\n## Example\r\n\r\nIn `jest.config.js` (if using the JS format):\r\n\r\n```js\r\nmodule.exports = {\r\n  preset: 'ts-jest',\r\n  moduleFileExtensions: ['ts', 'tsx', 'js'],\r\n  globals: { 'ts-jest': { tsConfig: 'tsconfig.json' } },\r\n  testMatch: ['**\/test\/**\/*.test.(ts|tsx)'],\r\n  \/\/ ...\r\n  passWithNoTests: true,\r\n};\r\n```","comments":["@SimenB I can pick this up, if this feature is needed","Will this be added? @M4rk9696 Thanks!","So... That is not going to happen?","Any progress?","need this","+1\r\n","+1","+1","+1","+1","+1","+1","+1","Isn't this something which was addressed in Jest 22 in #4639 ?\r\nYou can even read:\r\n\r\n> This is a weird requirement to get CLI flags to pass through\r\n> _Originally posted by @SimenB in https:\/\/github.com\/facebook\/jest\/pull\/4639#r143555141_\r\n\r\n\r\nA quick test in Jest 27 just now seems to show this working properly.\r\nThis is via config file, CLI single `--config` argument, or separate arguments:\r\n```sh\r\n$> jest --version\r\n27.4.7\r\n\r\n$> jest\r\nNo tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn \\repos\\project\r\n  14 files checked.\r\n  testMatch: ['**\/__tests__\/**\/*.[jt]s?(x)', '**\/?(*.)+(spec|test).[tj]s?(x)'] - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 14 matches\r\n  testRegex:  - 0 matches\r\nPattern:  - 0 matches\r\n\r\n\r\n$> jest --config='{\\\"testMatch\\\":[\\\"*.js\\\"]}'\r\nNo tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn \\repos\\project\r\n  14 files checked.\r\n  testMatch: *.js - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 14 matches\r\n  testRegex:  - 0 matches\r\nPattern:  - 0 matches\r\n\r\n\r\n$> jest --config='{\\\"testMatch\\\":[\\\"*.js\\\"]}' --passWithNoTests\r\nNo tests found, exiting with code 0\r\n\r\n$> jest --config='{\\\"testMatch\\\":[\\\"*.js\\\"],\\\"passWithNoTests\\\":true}'\r\nNo tests found, exiting with code 0\r\n\r\n$> echo '{\"testMatch\": [\"*.js\"],\"passWithNoTests\": true}' > jest.config.json && jest\r\nNo tests found, exiting with code 0\r\n\r\n$> echo '{\"testMatch\": [\"*.js\"]}' > jest.config.json && jest\r\nNo tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn \\repos\\project\r\n  14 files checked.\r\n  testMatch: *.js - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 14 matches\r\n  testRegex:  - 0 matches\r\nPattern:  - 0 matches\r\n```\r\n\r\nAm I missing something ?","Quoting:\r\n\r\n```\r\n$> jest --config='{\\\"testMatch\\\":[\\\"*.js\\\"],\\\"passWithNoTests\\\":true}'\r\nNo tests found, exiting with code 0\r\n```\r\n\r\nHrm odd, actually using a config file with `passWithNoTests: true,`  fails with:\r\n\r\n```\r\n FAIL  src\/index.test.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    Your test suite must contain at least one test.\r\n```\r\n\r\n$ npx jest --version\r\n27.5.1\r\n","Needing this too!\r\n","Really needing this too!!!\r\n\r\n@Mark1626  any news?","I mean, I don't know, but I've just tested it and it's working.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/53980482\/215552854-5f8714ef-da6a-4110-af23-e6c9e674501d.png)\r\n\r\n### Before\r\n![image](https:\/\/user-images.githubusercontent.com\/53980482\/215552967-09a7d979-3a75-4042-9057-be8a0a0f8525.png)\r\n### After\r\n![image](https:\/\/user-images.githubusercontent.com\/53980482\/215552995-213d39c1-a93a-4b29-a627-01ce60102609.png)\r\n","Works for me as well (29.4.3). It seems it was just forgotten to add to the documentation.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","+1"],"labels":[":rocket: Feature Request"]},{"title":"Support transforming all modules which can be specified in config","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nCurrently transform only converts tests files and some of the configurable modules, allows all modules which can be configured to be transformed\r\n\r\nBased on a discussion in #8330 from @SimenB @G-Rath \r\n\r\nList pointed out be @G-Rath \r\n\r\nModules which are transformed:\r\n- snapshotSerializers \r\n- setupFiles\r\n- setupFilesAfterEnv\r\n- globalSetup\r\n- globalTeardown\r\n\r\nModules which not transformed:\r\n- runner #8854\r\n- resolver\r\n- snapshotResolver #8330 \r\n- dependencyExtractor\r\n- testEnvironment #8751 \r\n- testResultsProcessor\r\n- testRunner #8823 \r\n- testSequencer\r\n- reporters\r\n- coverageReporters\r\n\r\n## Motivation\r\n\r\nApproach will be similar to #8751 \r\n\r\nReference #8756 \r\n\r\n## Example\r\n\r\n```js\r\n\/\/ jest.config.js\r\nmodule.exports = {\r\n  testEnvironment: 'environment.ts',\r\n  runner: 'runner.ts',\r\n  transform: {\r\n    '^.+\\\\.ts?$':  'my-transform'\r\n  }\r\n}\r\n```\r\n","comments":["Some of the modules in the list might require #8808 to be merged","@M4rk9696 You've bet me to it XD\r\n\r\nI'm happy to tackle all of them, as I can sit down and knock them all out one after each other, but obviously won't steal any from you :P\r\n\r\n~@SimenB I' m also happy to help make things async where possible :)~\r\n\r\nI apparently forgot the whole \"make transformer sync\" PR, so ignore my async comments \ud83d\ude2c \r\n\r\nI've done some more checking, and the changes need to happen here:\r\n\r\n---- \r\n\r\n`resolver` via `jest-resolve`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-resolve\/src\/index.ts#L90-L92\r\n\r\n~@SimenB This'll need to be made async~\r\n\r\n-----\r\n\r\n`dependencyExtractor` via `jest-haste-map`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-haste-map\/src\/index.ts#L297-L302\r\n\r\n~@SimenB this'll need to be made async, and be tricky b\/c it's in the constructor~\r\n\r\n----\r\n\r\n`testSequencer` is an interesting one. It's done in `jest-config`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-config\/src\/utils.ts#L240-L250\r\n\r\nBut uses `findNodeModule`, so it'll need that to be made to somehow get a usable transformer ~async first.~\r\n\r\n~@SimenB also needs to be made async.~\r\n\r\n`testResultsProcessor` is in `jest-core`:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-core\/src\/runJest.ts#L99-L101\r\n\r\n~@SimonB it'll need to be made async too~\r\n\r\n(I'll find the other spots once I'm at work in an hour or so)","Picking up `runner`\r\n\r\n`runner` via `jest-core`\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/86e73f5b22e8a02b5233af78c68ef7318c59e1b3\/packages\/jest-core\/src\/TestScheduler.ts#L174\r\n\r\n`testRunner` via `jest-runner`\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-runner\/src\/runTest.ts#L111-L113\r\n\r\n@SimenB Types required for `test-runner` are not exported, noticed it when creating the `e2e` will raise a separate PR for that\r\n@G-Rath Think the other modules will also need types exported","On a side note; is `@jest\/types` the new `@types\/jest` (yet*)?\r\n\r\nI've not explored enough to compare the two, but they've got more types - `snapshotResolver` iirc isn't in `@types` for example.\r\n\r\nJust wondering if you've consumed that at some point.\r\n\r\n*: At some point they will for sure, so I mean right now","Also here's another spanner in the works: `ScriptTransformer` requires `config`, which typically most things don't have at point-of-`require`\r\n\r\nMaybe it's worth making a global `ScriptTransformer` somehow..?\r\n\r\nI'm just thinking of the fact that [`findNodeModule`](https:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-resolve\/src\/index.ts#L86) in `jest-resolve` is static and seems to be for general use, and doesn't get passed the entire `config`, so it'll be a pretty big change at this point.\r\n\r\nThat's required for at least two options to support transforming","`@jest\/types` has absolutely zero relation to `@types\/jest` and never will. When we start exporting types for consumers of jest, it'll be in the `jest` package.\r\n\r\n---\r\n\r\n> I'm just thinking of the fact that [`findNodeModule`](https:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-resolve\/src\/index.ts#L86) in `jest-resolve` is static and seems to be for general use, and doesn't get passed the entire `config`, so it'll be a pretty big change at this point.\r\n\r\nWhy? It just resolves a file path, it doesn't actually `require` anything\r\n\r\n> `testSequencer` is an interesting one. It's done in `jest-config`:\r\n\r\nSame as above that's just resolving a path, not actually doing `require`\r\n\r\n---\r\n\r\n> Also here's another spanner in the works: `ScriptTransformer` requires `config`, which typically most things don't have at point-of-`require`\r\n\r\nEverywhere we do `require` _should_ have it - if not just pass it in.\r\n\r\n> Maybe it's worth making a global `ScriptTransformer` somehow..?\r\n\r\nNo, we don't want to share state","> @jest\/types has absolutely zero relation to @types\/jest and never will.\r\n\r\nNoted - I'll make to put in a PR to `@types` so that this work can be useable :)\r\n\r\n> Why? It just resolves a file path, it doesn't actually require anything\r\n\r\nLine 91:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d9b43a88bf9c5d4eb3e12b88edad60ac1ee30609\/packages\/jest-resolve\/src\/index.ts#L86-L93\r\n\r\n> Everywhere we do require should have it - if not just pass it in.\r\n\r\nCool, just wanting to make sure I'm not overlooking anything, or that people will be surprised if suddenly a bunch of parameters change :)\r\n\r\n> No, we don't want to share state\r\n\r\nAgreed","Ah, the resolver itself. That might not be easy regardless of having access to `ProjectConfig` or not as it's done during bootstrap. We can just hold off on it","Working on `runner` right now, seems that I need to the type in the signature\r\n```js\r\nasync runTests(\r\n    tests: Array<Test>,\r\n    watcher: TestWatcher,\r\n    onStart: OnTestStart,\r\n    onResult: OnTestSuccess,\r\n    onFailure: OnTestFailure,\r\n    options: TestRunnerOptions,\r\n  ): Promise<void>\r\n```\r\n\r\nI'm planning on importing with a different alias and exporting it within the `namespace TestRunner`, similar to the following\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/abb760a2614d29a39a6dd062288c847a5776f493\/packages\/jest-runner\/src\/index.ts#L32-L34\r\n\r\nI'll raise the types as a separate PR\r\nAny comments?","I've added `{coverageR,r}eporters` to the list after https:\/\/github.com\/facebook\/jest\/issues\/10105 was opened. If there's any reason why those would not be included please do shout anyone :upside_down_face: ","@jeysal (or someone who can edit the issue): could you add `globalTeardown` to list?\r\n\r\nPlease & thank you :)","A possible workaround, point to a JS file that register transpiler and require the source file\r\n\r\n```\r\n\/\/ forSetupFilesAfterEnv.js\r\nconst tsNode = require('ts-node');\r\n\r\ntsNode.register({\r\n  transpileOnly: true,\r\n  compilerOptions: require('@testim\/root-cause-jest\/tsconfig').compilerOptions,\r\n});\r\n\r\ntry {\r\n  require('@testim\/root-cause-jest\/lib\/forSetupFilesAfterEnv');\r\n} catch (e) {\r\n  console.error(e);\r\n  throw e;\r\n}\r\n```","@G-Rath @Mark1626 I'll start landing these next week. So if you wanna send PRs for even more of them, now's a perfect time \ud83d\ude07 ","Thanks, going through all the conversation to revisit the context.\r\n\r\nI'm starting to look at the code for `test-sequencer`\r\n\r\nShould I wait for existing ones to be merged before landing new ones to reduce the effort of resolving merge conflicts?","@Mark1626 yeah, probably. I'll try to find the time to rebase and land the open ones tomorrow. If you have time to rebase them that'd be a great help \ud83d\udc4d ","@SimenB Rebased all the three open PRs `jest-env`, `jest-runner`, `jest-testrunner`, CI seems to be failing for macOS builds(not sure why seems to fail for me in master as well), in `test-runner` yarn lock needs to be updated as dependency on `@jest\/transform` has been added. ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","I believe I still saw some files the other day which don't get transformed but I don't recall which.","`resolver` is not, I'm not sure about others. If somebody could go through and verify the current state, that'd be awesome \ud83d\ude42 ","Does anyone have a workaround for a custom reporter? cc\/ @Xotabu4","It should be enough to use `ScriptTransformer#requireAndTranspileModule` here: https:\/\/github.com\/facebook\/jest\/blob\/a5f1ef43981b7426d61bcd7cbc59a79f548c075a\/packages\/jest-core\/src\/TestScheduler.ts#L406. See https:\/\/github.com\/facebook\/jest\/blob\/a5f1ef43981b7426d61bcd7cbc59a79f548c075a\/packages\/jest-core\/src\/runGlobalHook.ts#L41-L46 for how to create a transformer. Wanna send a PR?","> It should be enough to use `ScriptTransformer#requireAndTranspileModule` here:\r\n> \r\n> https:\/\/github.com\/facebook\/jest\/blob\/a5f1ef43981b7426d61bcd7cbc59a79f548c075a\/packages\/jest-core\/src\/TestScheduler.ts#L406\r\n> \r\n> . See\r\n> https:\/\/github.com\/facebook\/jest\/blob\/a5f1ef43981b7426d61bcd7cbc59a79f548c075a\/packages\/jest-core\/src\/runGlobalHook.ts#L41-L46\r\n> \r\n> for how to create a transformer. Wanna send a PR?\r\n\r\nI need this feature and was willing to take a stab at it, but it's not clear to me how I can access `allTests` from `TestScheduler.ts` for getting the correct config (or a fallback)."],"labels":[":rocket: Feature Request","Pinned"]},{"title":"Jest failing with \"Call retries were exceeded\", using --runInBand works-around issue","body":"## \ud83d\udc1b Bug Report\r\n\r\nI've got 2 test files. In the test, a WebAssembly object gets instantiated. This instantiation seems to stall for some reason when running the test in CI. Locally running jest passes the tests fine.\r\n\r\nIn CI they fail with this error:\r\n\r\n```\r\n  \u25cf Test suite failed to run\r\n\r\n    Call retries were exceeded\r\n\r\n      at ChildProcessWorker.initialize (..\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\n```\r\n\r\nWhen `-i` is used however, they pass as well in CI.\r\n\r\nJest: 24.8.0\r\nNode: 10.15.0\r\nLocal env: macOS, 10.14.6 (18G84))\r\nCI env: CircleCI, Docker Linux 6a7bd3b63625 4.15.0-1035-aws #37-Ubuntu SMP Mon Mar 18 16:15:14 UTC 2019 x86_64 GNU\/Linux\r\n\r\n## To Reproduce\r\n\r\nI don't have a concise repro repo at this moment.\r\n\r\n## Expected behavior\r\n\r\nI expect the tests to pass as well when not run in band.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nDon't have it at this moment.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\nCI:\r\n```bash\r\nnpx: installed 1 in 1.719s\r\n\r\n  System:\r\n    OS: Linux 4.15 Debian GNU\/Linux 9 (stretch) 9 (stretch)\r\n    CPU: (36) x64 Intel(R) Xeon(R) Platinum 8124M CPU @ 3.00GHz\r\n  Binaries:\r\n    Node: 10.15.0 - ~\/.nodenv\/versions\/10.15.0\/bin\/node\r\n    Yarn: 1.17.3 - \/usr\/bin\/yarn\r\n    npm: 6.4.1 - ~\/.nodenv\/versions\/10.15.0\/bin\/npm\r\n\r\n```\r\n\r\nLocal:\r\n```\r\nEnvironment:\r\n  OS:  macOS 10.14.6\r\n  Node:  10.15.0\r\n  Yarn:  1.17.3\r\n  npm:  6.4.1\r\n  Watchman:  Not Found\r\n  Xcode:  Xcode 10.3 Build version 10G8\r\n  Android Studio:  3.1 AI-173.4819257\r\n```\r\n","comments":["do you use `jest-worker`? Please provide more information about your use of it if available. or say more about the file that runs your test.","> do you use jest-worker?\r\n\r\nNot that I\u2019m aware of? I do see it as a dependency in my yarn.lock file.\r\nBut I didn\u2019t add any configuration in the jest.config.js for it.\r\n\r\nI will try to create a minimal repro example when I find some time.","Ok, do you provide a reproduce code?","> I will try to create a minimal repro example when I find some time.","Any lucky on this? I am having the same issue after upgrading to node v13.","I observed that the issue occurs with node v13.2.0, but not with v13.1.0. Looks like the issue with only the latest node version.","@antony2025 same here. After upgrading to node v13.2.0 my test suite which has many async test statements started to fail. Funny thing is that if I delete a few async tests from the test suite it works again. ","Same for me I have the same issue w\/ Node 10.17.0","I just faced the same issue in CI and was able to reproduce it in local by switching to the latest version of node. As suggested, only by downgrading fixes it for me, using `-i` didn't.","I have observed the same issue on Node 13.2.0 (where updating node is the only change since it was previously working reliably; package-lock.json has not changed, and I have tried before and after clearing out and rebuilding node_modules).\r\n\r\nFor me, running with `--runInBand` results in `8266 Segmentation fault: 11` at the same point where it otherwise fails with `Call retries were exceeded at ChildProcessWorker.initialize`. I am running on macOS 10.14.6 and installed node via Homebrew. After the crash it notes that it reached 33 passing test suites with 106 total tests. The codebase contains 34 test suites and 122 total tests (I don't know if these numbers are similar for other people hitting the issue?). I have many `async` tests in the rest of the code but the suite which hits this error contains only synchronous tests.\r\n\r\nSince it's segfaulting, I suspect this is a bug in Node itself (seemingly a regression since this was an issue before), but I have no idea where to begin looking!\r\n\r\n---\r\n\r\nIs it possible that this could be connected to https:\/\/github.com\/nodejs\/node\/pull\/26628 ? (seems to be the only entry in the Node 13.2.0 changelog which relates to workers)","Appears this issue has been reported upstream: nodejs\/node#30730","Hey guys! I was having this issue on CI only (CircleCI). So I changed the following value on CI config file and the issue has gone:\r\n\r\n**Before**\r\n```\r\nversion: 2\r\njobs:\r\n  build:\r\n    docker:\r\n      - image: circleci\/node:latest-browsers\r\n```\r\n\r\n**Then**\r\n```\r\nversion: 2\r\njobs:\r\n  build:\r\n    docker:\r\n      - image: circleci\/node:12-browsers\r\n```","_(note: not sure if this is the exact same error reason, but looks like it and I found this link when looking for a solution)_ \r\n\r\n## Error:\r\nTest suite failed to run Call retries were exceeded at ChildProcessWorker.initialize (node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\n\r\n\r\n\r\n## Confirmed fix: \r\nUpgrade from nodejs 13.2.0 to 13.3.0\r\n\r\n## Environment\r\nI had this error with \r\nWindows 10\r\n**nodejs 13.2.0**\r\nYarn 1.19.2\r\n\r\n### Package.json\r\n```json \r\n\"dependencies\":\u00a0{\r\n\u00a0\u00a0\u00a0\u00a0\"@testing-library\/jest-dom\":\u00a0\"^4.2.4\",\r\n\u00a0\u00a0\u00a0\u00a0\"@testing-library\/react\":\u00a0\"^9.3.2\",\r\n\u00a0\u00a0\u00a0\u00a0\"@testing-library\/user-event\":\u00a0\"^7.1.2\",\r\n\u00a0\u00a0\u00a0\u00a0\"react\":\u00a0\"^16.12.0\",\r\n\u00a0\u00a0\u00a0\u00a0\"react-dom\":\u00a0\"^16.12.0\",\r\n\u00a0\u00a0\u00a0\u00a0\"react-redux\":\u00a0\"^7.1.3\",\r\n\u00a0\u00a0\u00a0\u00a0\"react-scripts\":\u00a0\"3.3.0\",\r\n\u00a0\u00a0\u00a0\u00a0\"redux\":\u00a0\"^4.0.4\"\r\n\u00a0\u00a0},\r\n\"devDependencies\":\u00a0{\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/addon-actions\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/addon-docs\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/addon-knobs\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/addon-links\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/addon-storyshots\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/addons\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/preset-create-react-app\":\u00a0\"^1.3.2\",\r\n\u00a0\u00a0\u00a0\u00a0\"@storybook\/react\":\u00a0\"^5.3.0-beta.16\",\r\n\u00a0\u00a0\u00a0\u00a0\"babel-loader\":\u00a0\"^8.0.6\",\r\n\u00a0\u00a0\u00a0\u00a0\"react-test-renderer\":\u00a0\"^16.12.0\"\r\n\u00a0\u00a0}\r\n```\r\n\r\n## Storybook initStoryshots from '@storybook\/addon-storyshots'\r\nWhen following the tutorial in https:\/\/www.learnstorybook.com\/intro-to-storybook\/react\/en\/simple-component\/\r\n\r\n### The code below is where the error occured.\r\n```jsx\r\n\/\/ src\/storybook.test.js\r\nimport initStoryshots from '@storybook\/addon-storyshots';\r\ninitStoryshots();\r\n```","Believe got same issue on Node LTS 12.14.1:\r\n\r\n```\r\nERROR in main.affbaa778346b006d3f5.js from Terser\r\nError: Call retries were exceeded\r\n    at ChildProcessWorker.initialize (C:\\azagent\\A3\\_work\\1\\s\\Core\\Web\\NgApps\\node_modules\\jest-worker\\build\\workers\\ChildProcessWorker.js:193:21)\r\n    at ChildProcessWorker.onExit (C:\\azagent\\A3\\_work\\1\\s\\Core\\Web\\NgApps\\node_modules\\jest-worker\\build\\workers\\ChildProcessWorker.js:263:12)\r\n    at ChildProcess.emit (events.js:223:5)\r\n    at Process.ChildProcess._handle.onexit (internal\/child_process.js:272:12)\r\n\r\n```","What helped me was upgrading the runner machine to the one with more memory.","@mvasin how much memory has your machine now?","same with node 10.19.0, ubuntu 20.04","Working version for our builds: 12.16.3\r\nBroken when upgrading to 12.18.0\r\n\r\nRunning 16GB memory, 8cpu on circleCI with the following options\r\n\r\n```\r\nyarn --coverage --ci -w 6\r\n```","adding `--runInBand`, worked for me. I don't know why and I don't care as long as i see greens :green_circle: :see_no_evil: ","any solution on this? ","@justinlazaro-iselect you should probably check https:\/\/github.com\/nodejs\/node\/issues\/30730 since this is actually a NodeJS issue - I think the result is that this bug isn't fixed on Node 12 (yet? there seems to be talk about various dependencies on backporting things so it might be fixed eventually), but it is fixed in Node 13+","@davidje13  thanks for the info, will check right now I'm update to node v13.3.0 still having and issue call still having an issue `Call retries were exceeded` any workaround to react-script test for this? ","I don't know if it helps anyone, but I was getting this error when running in a docker container on macOS, and I fixed it by increasing the memory available in Docker Desktop for Mac preferences.","It is a bit embarassing for us node devs that 2 cpu and 4gb ram cannot run unit tests properly :disappointed: ","Well don't feel quite so bad, the default was 2gb ram and increasing to 4gb prevented this error \ud83d\ude42 ","Just spotted this in the docs:\r\n\r\n> For environments with variable CPUs available, you can use percentage based configuration: `--maxWorkers=50%`\r\n\r\nWe're going to use this for a while and see whether this issue still happens.\r\n\r\n**Update:** we've done a few builds since and haven't noticed any failures, so this looks like a good option.","This now produces actual errors and fails the test suite on Nodejs 15, where unhandled promise errors are treated as exceptions.","> This now produces actual errors and fails the test suite on Nodejs 15, where unhandled promise errors are treated as exceptions.\r\n\r\nYou save my time \ud83d\udc4d","I'm seeing this on Node 10 as well!","I'm also seeing this on Node 14, specifically 14.15.1. Running with `--runInBand` fails with a `SIGSEGV`.","Seeing this on 12.18.4\/12.20.0\/13.1.0 ","also seeing this on node 12.18.4\r\nwith jest 26.6.3 and angular 10.2.3.\r\n\r\nwhen running as the whole test suite, i experience the same problem that the original author listed (call retries exceeded in the `ChildProcessWorker.initialize()` method).\r\nwhen running via `npx jest .... some.spec.ts` i get a seg fault","seeing this on node 14.15.0","Still an issue using 14.14.0+","Still has an issue on NodeJS 15.5.1","I have tests that use a native node module (tree-sitter) that trigger this behavior. similarly, `--runInBand` triggers a segfault. `--maxWorkers=\"50%\"` had no effect. node 14.15.4","Having the same issue, using workers","@lamhieu-vk \r\nAnyone can easily reproduce this bug locally. Here's how:\r\n\r\n1. `yarn add -D segfault-handler`\r\n2. write this test:\r\n\r\n```js\r\nvar SegfaultHandler = require('segfault-handler');\r\n\r\ndescribe(\"segfault\", () => {\r\n  it(\"should segfault\", () => {\r\n    SegfaultHandler.causeSegfault();\r\n  });\r\n})\r\n```\r\n\r\n3. write at least 1 other test\r\n4. `yarn jest` (or whatever your test command is)\r\n\r\nOutput:\r\n\r\n```\r\n PASS  src\/utils\/mergeIndexDTs.test.js\r\n PASS  src\/utils\/getIndexEntries.test.js\r\n PASS  src\/drivers\/translationDriverTests.test.js\r\nNodeSegfaultHandlerNative: about to dereference NULL (will cause a SIGSEGV)\r\nNodeSegfaultHandlerNative: about to dereference NULL (will cause a SIGSEGV)\r\nNodeSegfaultHandlerNative: about to dereference NULL (will cause a SIGSEGV)\r\n FAIL  src\/drivers\/segfault.test.js\r\n  \u25cf Test suite failed to run\r\n\r\n    Call retries were exceeded\r\n\r\n      at ChildProcessWorker.initialize (..\/..\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\n\r\nTest Suites: 1 failed, 10 passed, 11 total\r\nTests:       60 passed, 60 total\r\nSnapshots:   36 passed, 36 total\r\nTime:        8.243 s\r\n```\r\n\r\nThe bug in jest is that it does NOT display \"your test caused a segfault in node.\"\r\n\r\nThis is a combination of 2 bugs. The more serious one is SOMETHING IN YOUR TEST CAUSES A SEGFAULT :). But Jest should still tell us that the process segfaulted.\r\n\r\nFortunately, I can tell you that ChildProcess does report the SIGSEGV in its internals because I stepped through a jest test with the chrome debugger to make sure, so it's just a question of Jest noticing this in `ChildProcessWorker.initialize()` when retrying, and reporting \"the test caused a segmentation fault in node, likely due to a serious bug in an internal module you are using.\" or some such language","[SOLVED]\r\n\r\njust use: jest.useFakeTimers()","Running the tests at **CircleCI**, I found that if I just run `jest`, the error that normally appears is: _\"Call retries were exceeded\"_.\r\n\r\nBut if I execute `jest --coverage` the first error that appears is _\"ENOMEM: not enough memory, read\"_ and then the error above appears.\r\n\r\n![2021-02-04_09-11](https:\/\/user-images.githubusercontent.com\/3621711\/106891278-3a72e500-66c9-11eb-88ce-d835ea57d76a.png)\r\n\r\nTo solve the problem I am now using `jest --maxWorkers=4` and `jest --coverage --maxWorkers=4`.","I'm facing this issue too, any update?","I updated my node version from 12.18 to 15.8 and that solved the problem for me.","This also seems to happen on our CI with 62G total memory of which 17G+ is free & 8 cores and only handful of tests. But I'm not able to repro this locally with smaller memory but more cores.","For us this actually happened due to uncaught promise rejection. The error message was pretty far from actionable :D So there is apparently far more reasons for this error to occur than just OOM.","\"react\": \"^17.0.1\"\r\n\"enzyme\": \"^3.11.0\"\r\n\"jest-enzyme\": \"^7.1.2\"\r\n\"@wojtekmaj\/enzyme-adapter-react-17\": \"^0.4.1\"\r\n\r\nWith any node version, still happening","Any updates on this one ? I am having the same issue.\r\nUbuntu : 20:04\r\nNode : 12.18.4\r\n- I did upgrade Node to 14.15.5, still facing the same issue.","@FahmyChaabane if You know which file is causing the error, try wrapping the tests into try catch (in an async function) and, see what kind of errors you get and try to fix those. That might help.","I've added 2 flags to my react-scripts test and removed some Lazy loadings when it's on test stage\r\n\r\n> cross-env NODE_ENV=test react-scripts test --**unhandled-rejections**=warn --**runInBand**\r\n\r\nAnd then in the code, im checking if it's in test stage env. Example:\r\n\r\n```\r\n  let ReactPlayer;\r\n  if (global.__TEST__) ReactPlayer = require('react-player').default;\r\n  else ReactPlayer = require('react-player\/lazy').default;\r\n```\r\n\r\nMy `jest.setup.js`\r\n\r\n```\r\n global.__TEST__ = true;\r\n```\r\n\r\nHope it helps someone.\r\n","In my case, this bug occurred only when a specific combination of props was passed to my component. I went through code commenting out different parts related to these props and found that if I remove (or mock out) my lazily loaded Dropzone sub-component then the problem goes away. To everyone experiencing this issue, try commenting out parts of your component to find your culprit.","Maybe it helps someone, but for me the problem was, that I had _process.env.NAME_ in the code and the same env variable was defined on my Mac, but not on the CI-Machine. This way all my tests were green, but on CI red.\r\n\r\n","For me, I have to uninstall watchman and reinstall using brew. After executing the below cmd the issue was resolved. Hope this helps.\r\n\r\nnpm r -g watchman \r\nbrew install watchman","Same issue node 16.0, also ERR_UNHANDLED_REJECTION","I get this error as well, I don't even know what jest-worker is, but I see it in package-lock.json. I don't know which module is implementing this, is there a way to just disable it completely?","> For us this actually happened due to uncaught promise rejection. The error message was pretty far from actionable :D So there is apparently far more reasons for this error to occur than just OOM.\r\n\r\nThis was the case for us, too. I suspect if anyone else out there is seeing test suites fail to run with the \"Call retries were exceeded\" message after upgrading to Node 15 and above, you might want to hunt down and fix any unhanded promise rejections in your codebase.\r\n\r\nI created a small reproducing repo in case it helps anyone on the Jest team: https:\/\/github.com\/scitech\/call-retries-repro\r\n\r\nI think the issue here is, Jest will spawn some number of workers which will each attempt to fork a process. If a worker's process dies it forks another one, but after 3 tries it will stop running tests, and subsequent test suites will fail with the rather obscure error message \"Call retries were exceeded\". So it's not specifically related to unhandled promise rejections or memory issues (as in the OP) -- the failure could be due to a worker encountering 3 Node exceptions of any kind.\r\n\r\nGiven that unhandled promise rejections are pretty common in application code, I wonder if there isn't a more informative way to presenting this information to the Jest user so they can track down the issue. Forgive the unsolicited suggestions but here are some ideas:\r\n1. Changing the error message text. \"Call retries exceeded\" is pretty opaque, maybe to something like \"Jest worker process exited 3 times due to Node process exceptions, exceeding retry limit.\"\r\n2. If a child process worker exceeds the retry limit, can it bail early, rather than run all the tests marking each as failed? It's harder to find the original source of the problem as is.\r\n3. Can the exit handler of the ChildProcessWorker collect the Node process exception messages and report them back out after exceeding the retry limit?","For me it happened with lazy imports...just repurposed them into normal imports and it worked.","I think I had the same error:\r\n\r\n> Failed to construct transformer: { Error: Call retries were exceeded\r\nat ChildProcessWorker.initialize (\/Users\/developer\/Documents\/dev\/docomondo\/app\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\nat ChildProcessWorker._onExit (\/Users\/developer\/Documents\/dev\/docomondo\/app\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:274:12)\r\nat ChildProcess.emit (events.js:198:13)\r\nat Process.ChildProcess._handle.onexit (internal\/child_process.js:248:12) type: 'WorkerError' }\r\n\r\nI updated node from _v10.19.0_ to _v14.17.0_ and it works now","I have the same issue , but locally it works fine the tests passes however in CI it give me this error too ! ","Solved with: `jest -w 1`, hope to help others.\r\n\r\nhttps:\/\/github.com\/zcorky\/moment\/issues\/26","I faced the same error when I was using node version 16.3. Changing the version from 16.3 to 12.6.3 resolved this issue.","> I think I had the same error:\r\n> \r\n> > Failed to construct transformer: { Error: Call retries were exceeded\r\n> > at ChildProcessWorker.initialize (\/Users\/developer\/Documents\/dev\/docomondo\/app\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\n> > at ChildProcessWorker._onExit (\/Users\/developer\/Documents\/dev\/docomondo\/app\/node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:274:12)\r\n> > at ChildProcess.emit (events.js:198:13)\r\n> > at Process.ChildProcess._handle.onexit (internal\/child_process.js:248:12) type: 'WorkerError' }\r\n> \r\n> I updated node from _v10.19.0_ to _v14.17.0_ and it works now\r\n\r\nThis worked for me","Meet the same issue when upgrade node from 12.13 to 16, any update on this?\r\n\"jest\": \"^25.5.4\",\r\n\"react\": \"^16.14.0\",\r\n\"node\": \"16\"\r\n\r\n```\r\nTest suite failed to run\r\n\r\n    Call retries were exceeded\r\n\r\n      at ChildProcessWorker.initialize (node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:191:21)\r\n      at ChildProcess.emit (node:events:394:28)\r\n      at Process.ChildProcess._handle.onexit (node:internal\/child_process:290:12)\r\n```","@jiaoqiqi I'm also still seeing this issue on node `16.9`. However, I've been able to mitigate this by pinning node to `16.8`.\r\n\r\nHopefully there is a longer term fix soon.","## Conclusion\n\nIf you are experiencing this issue on a CI environment, it's probably caused by a CPU limit that prevents Jest from creating as many child processes as it wants.\n\nTry setting [`--maxWorkers` option](https:\/\/jestjs.io\/docs\/cli#--maxworkersnumstring) to appropriate value to tell Jest how many child processes it can possibly request.\n\n## Original comment\n\nI'm experiencing this issue on GitLab CI on a k8s cluster after I set the CPU limit of the runner pod to 5 cores (while the cluster has 40 in total). \r\n\r\nI guess the Node.js told jest-runner that the system has 40 cores so jest-runner requested for according number of child processes, then the CPU limit caused the child process request to fail.\n\nSolved with setting `--maxWorkers` to lower than 5.","> @jiaoqiqi I'm also still seeing this issue on node `16.9`. However, I've been able to mitigate this by pinning node to `16.8`.\r\n> \r\n> Hopefully there is a longer term fix soon.\r\n\r\nI'm having this issue on 16.8.0\r\nI have a feeling that the node version is a red herring and the problem is getting fixed after upgrades\/downgrades because something else changes as a side effect.","For me the issue came when I used spyon on a api call.\r\nInitialy I was using \r\nspyOn(dataService, 'getData').and.returnValue({\r\n                paydown: 0,\r\n                 depAmount: null\r\n});\r\n\r\nThen it worked when I changed the code to callfake\r\n\r\nspyOn(dataService, 'getData').and.callFake(() => Promise.resolve({\r\n            paydown: 0,\r\n            depAmount: null\r\n        }));","Guys for me it was just the node version that i use in localhost is not the the same used in the pipeline to run tests !\r\n","I am seeing a similar issue with node v16.10.0. In my case, however, I am running locally and `--runInBand` causes the test to throw:\r\n```\r\nnode:internal\/process\/promises:246\r\n          triggerUncaughtException(err, true \/* fromPromise *\/);\r\n          ^\r\n\r\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error: For security reasons, `window.crypto` is required to run `auth0-spa-js`.\".] {\r\n  code: 'ERR_UNHANDLED_REJECTION'\r\n}\r\n```\r\n Reverting back to node 12.20.1 resolves the issue but it seems like more than just a node version problem.","Similir problem here! Not working on 14 and 16, but works on node 12.","I've run into this issue when updating a codebase from Node12 -> Node16 and in my digging I've found that in the bits that are *now* failing all seem to have the following in common when I run with a debugger attached.\r\n\r\n`[DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.`\r\n\r\nWhich would indicate to me that the behaviour it was relying on, unhandled promise rejections continue, now cause a termination in Node, which Jest is detecting, running the test an additional 3 times before declaring it as dead and marks it as a test suite that has failed to execute.\r\n\r\nWhat is interesting is that in Node12 those tests pass even when `unhandled promise rejection` is being fired as long as it's not actually impacting any of the bits that are being tested.\r\n\r\nWould it be possible to bubble up those `Unhandled promise rejection` errors so it's easier for people to spot rather than having to spelunk using the debugger to work out what is wrong?\r\n\r\nJest 27.2.3\r\nNode 12.18.2 - All tests work as expected\r\nNode 16.13.0 - Tests that contain an `Unhandled promise rejection` fail, even if it's not in the tests critical path ","Having the same problem\r\n\r\njest: 26.6.3\r\nnode: 15.5.1\r\n\r\n```\r\nnode:internal\/process\/promises:227\r\n          triggerUncaughtException(err, true \/* fromPromise *\/);\r\n\r\nCall retries were exceeded\r\n\r\n      at ChildProcessWorker.initialize (node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\n```","Same issue here","jamesRaybould's description matches the problem I have as well. Worked in node 14.17.16, fails in 16.13.0.","In my case we're missing an `await` before `wairFor` from `@testing-library\/react`\r\n```diff\r\n- waitFor(() => {\r\n\r\n+ await waitFor(() => {\r\n      expect(screen.getByTestId('my-button')).toBeInTheDocument();\r\n```\r\n\r\nIf we run with node 16, it does not complain at all. Node 14 yells `Call retries were exceeded` without any implicit error message and it's very difficult to spot the bug.","Same Problem here:\r\n```\r\n FAIL  __tests__\/homepage.test.tsx\r\n  \u25cf Test suite failed to run\r\n\r\n    Jest worker encountered 4 child process exceptions, exceeding retry limit\r\n\r\n      at ChildProcessWorker.initialize (node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:185:21)\r\n```\r\nNode version: `v16.13.0`\r\n\r\nDoes anyone got a fix?","From my understanding of the problem I think the best fix for this is probably to fix the problem at source, in my case it's a combination of us not mocking out dependencies properly and a couple of places where we don't actually handle the promise rejection (at all). So fixing those will get us to a place where it all works as expected.\r\n\r\nI'm not sure that there *is* a fix that can go in Jest other than to maybe better highlight where the `unhandledPromiseRejection` is being thrown.","I had the same problem with a VueJS app, with nodejs v16.13.0 and jest 25.5.4 so a bit older version of Jest.\r\n\r\n```\r\nnode:internal\/process\/promises:246\r\n          triggerUncaughtException(err, true \/* fromPromise *\/);\r\n          ^\r\n```\r\nand `Call retries were exceeded`\r\n\r\n\"Fixed\" it with the following changed. I prefer the former syntax than the latter.\r\n\r\n```\r\n    components: {\r\n      VueApexCharts: () => import('vue-apexcharts')\r\n    }\r\n```\r\n\r\nto \r\n```\r\n    import VueApexCharts from 'vue-apexcharts'\r\n...\r\n    components: {\r\n      VueApexCharts\r\n    }\r\n```\r\n","> In my case we're missing an `await` before `wairFor` from `@testing-library\/react`\r\n> \r\n> ```diff\r\n> - waitFor(() => {\r\n> \r\n> + await waitFor(() => {\r\n>       expect(screen.getByTestId('my-button')).toBeInTheDocument();\r\n> ```\r\n> \r\n> If we run with node 16, it does not complain at all. Node 14 yells `Call retries were exceeded` without any implicit error message and it's very difficult to spot the bug.\r\n\r\nDo not know why but this worked like charm.","For those having issues running on node 16, I found this link helpful, \r\nhttps:\/\/stackoverflow.com\/questions\/68368577\/react-tests-unhandledpromiserejection\r\n\r\nEssentially you need to ensure that any custom async functions being called from your tests need to implement a try\/catch.","We ran into this issue when upgrading from Node 14 to Node 16.  It appears that Node 15 introduced a breaking change to promise rejection handling, as @jamesRaybould indicated earlier.  I found https:\/\/developer.ibm.com\/blogs\/nodejs-15-release-blog\/ to be a helpful writeup of the change.\r\n\r\nWe saw the errors disappear after passing the `--unhandled-rejections=warn` flag to node when running tests, which likely confirms this diagnosis.\r\n\r\nPassing that flag may work as a short term workaround.","My problem was that a testing-library test was longer than the 5 seconds timeout of a test. There are multiples `waitFor` in it as it represent an E2E test.\r\n\r\nIn order to fix it, I simply needed to up the timeout of the test to an higher value:\r\n```\r\nit('should do a mega long process`, () => {\r\n  renderComponent();\r\n  \r\n  \/\/ all the process\r\n  \r\n  expect(true).toBeTruthy()\r\n}, 60 * 1000) \/\/ one minute to be sure it does not timeout again\r\n```\r\n\r\nHope it helps some of you!","> My problem was that a testing-library test was longer than the 5 seconds timeout of a test. There are multiples `waitFor` in it as it represent an E2E test.\r\n\r\n@arivestNexapp Another option is you can configure it globally, so you don't have to manually increase timeout for each test.\r\n```js\r\nimport { configure } from '@testing-library\/dom';\r\n\r\nconfigure({\r\n  asyncUtilTimeout: 2500,\r\n});\r\n```\r\n\r\nReference: https:\/\/testing-library.com\/docs\/dom-testing-library\/api-configuration#asyncutiltimeout","> > In my case we're missing an `await` before `wairFor` from `@testing-library\/react`\r\n> > ```diff\r\n> > - waitFor(() => {\r\n> > \r\n> > + await waitFor(() => {\r\n> >       expect(screen.getByTestId('my-button')).toBeInTheDocument();\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > If we run with node 16, it does not complain at all. Node 14 yells `Call retries were exceeded` without any implicit error message and it's very difficult to spot the bug.\r\n> \r\n> Do not know why but this worked like charm.\r\n\r\nIn my case, I was not awaiting a `findByText`. Switching to `getByText` fixed the issue for me.","Hi, for me this error was related to M1 processor. Run tests on a terminal with rosetta enabled and got it working.","> For those having issues running on node 16, I found this link helpful, https:\/\/stackoverflow.com\/questions\/68368577\/react-tests-unhandledpromiserejection\r\n> \r\n> Essentially you need to ensure that any custom async functions being called from your tests need to implement a try\/catch.\r\n\r\nIt makes sense that a try\/catch block solves the issue because it's a way of catching rejections. Essentially all Promises in tests should catch or handle reject.","mostly, If you met such type of problem you need to take an attention to asynchrous test, perhaps problem related with this","For me, my problem was with not mocking a dependency exhaustively when some components in the dependency were being used in the component I was testing. For instance\r\n\r\n```ts\r\nimport { A, B } from \"dependency\";\r\n\r\nMyComponent => ({condition}) => {\r\n  if (condition) \r\n    return <A \/> \r\n  else\r\n    return <B \/>\r\n}\r\n```\r\n\r\nin my test\r\n\r\n```ts\r\n\/\/ note B is not mocked, it will be undefined\r\njest.mock(\"dependency\", () => ({\r\n   A: (props) => Something\r\n}))\r\n\r\n\/\/ condition as false will require B to be defined\r\nit(\"shows something\", () => {\r\n   <MyComponent condition={false} \/>\r\n})\r\n```\r\n\r\nThis would throw this error until I fully mocked the dependency like this (to ensure B is not `undefined` in the mock):\r\n\r\n```ts\r\n\r\n\/\/ note B will now be defined as the unmocked version\r\njest.mock(\"dependency\", () => ({\r\n   ...jest.requireActual(\"dependency\"),\r\n   A: (props) => Something\r\n}))\r\n```\r\n\r\nWhile my component also had some async work, that was never the problem.\r\n\r\nTry to check if you have some things that are undefined possibly due to mocking.","\u5168\u4f53\u8d77\u7acb\uff01\r\n\u5728 `setupTests.js` \u6216\u8005\u51fa\u73b0\u95ee\u9898\u7684\u5355\u5143\u6d4b\u8bd5\u6587\u4ef6\u6dfb\u52a0\u4e0b\u9762\u7684\u4ee3\u7801\uff0c\u5b8c\u7f8e\u89e3\u51b3\uff01\uff01\uff01\r\n\r\n```js\r\nprocess.on('unhandledRejection', (reason) => {});\r\n```\r\n\r\n> \u53c2\u8003\uff1ahttps:\/\/2ality.com\/2016\/04\/unhandled-rejections.html","I was trying to run the craco tests and I got the error:\r\n\r\n```\r\nTest suite failed to run\r\nCall retries were exceeded\r\nat ChildProcessWorker.initialize (node_modules\/jest-worker\/build\/workers\/ChildProcessWorker.js:193:21)\r\n```\r\n\r\nI added the option for Node.js for `craco test` command:\r\n\r\n`NODE_OPTIONS=--unhandled-rejections=warn craco test`\r\n\r\nMy package.json:\r\n\r\n`\"scripts\": {`<br\/>`    \"test\": \"NODE_OPTIONS=--unhandled-rejections=warn craco test\" `\r\n`}`"],"labels":["Needs Triage","Bug Report"]},{"title":"Broken terminal after killing jest watcher with SIGTERM","body":"## \ud83d\udc1b Bug Report\r\n\r\nAfter running watcher programmatically and killing it with SIGTERM (which seems like an appropriate way of killing jest in such scenario) my terminal is broken with - its lflags are are different than normal. `stty` gives such result before running the script:\r\n```bash\r\nspeed 9600 baud;\r\nlflags: echoe echoke echoctl pendin\r\niflags: iutf8\r\noflags: -oxtabs\r\ncflags: cs8 -parenb\r\n```\r\nand such result after running it:\r\n```bash\r\nlflags: -icanon -isig -iexten -echo echoe echoke echoctl\r\niflags: -icrnl -ixon iutf8 -brkint\r\noflags: -oxtabs\r\ncflags: cs8 -parenb\r\n```\r\n\r\nNotice how i.e. `-echo` gets added to lflags.\r\n\r\n## To Reproduce\r\n\r\nRunning [such script](https:\/\/github.com\/Andarist\/jest-watcher-sigterm-repro\/blob\/00ea57fac171cf2bd4c5c9c12888069b5688b19b\/scripts\/dev.js) causes this:\r\n```js\r\nconst spawnCommand = require(\"spawn-command\")\r\n\r\nconst test = spawnCommand(\"yarn watch\", {\r\n  stdio: \"inherit\"\r\n})\r\n\r\nsetTimeout(() => {\r\n  test.kill(\"SIGTERM\")\r\n}, 3000)\r\n```\r\n\r\nI've managed to dig deeper and I've discovered that this is \"caused\" by using execa package to run different scripts (i.e. git one) which in turn uses signal-exit package internally. The latter one adds SIGTERM listener to the current process (jest) so it can call a callback before process exitting which execa listens to so it can clean up after itself (its spawned commands etc). This is all good and expected - also the listener in question gets removed appropriately, but somehow this breaks default SIGTERM handler and original terminal settings are not being restored.\r\n\r\nAfter analyzing this problem - I've managed to come up with a simplified [\"fake jest\"](https:\/\/github.com\/Andarist\/jest-watcher-sigterm-repro\/blob\/00ea57fac171cf2bd4c5c9c12888069b5688b19b\/scripts\/fake-jest.js) (those exact steps are executed by jest):\r\n```js\r\nprocess.stdin.setRawMode(true)\r\n\r\nconst handler = () => {}\r\n\r\nprocess.on('SIGTERM', handler)\r\nprocess.off('SIGTERM', handler)\r\n\r\nsetInterval(() => {\r\n    console.log('jest fake')\r\n}, 2000)\r\n```\r\n\r\nThe key culprits are:\r\n- using raw mode\r\n- adding & removing SIGTERM handler\r\n\r\n## Expected behavior\r\n\r\nFunctional, \"untouched\", terminal.\r\n\r\n## Link to repl or repo\r\n\r\nhttps:\/\/github.com\/Andarist\/jest-watcher-sigterm-repro\r\n\r\nJust install dependencies and run `yarn dev` or `yarn simplified`\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\n```bash\r\n  System:\r\n    OS: macOS Sierra 10.12.6\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-6920HQ CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 11.8.0 - ~\/.nvm\/versions\/node\/v11.8.0\/bin\/node\r\n    Yarn: 1.13.0 - ~\/.nvm\/versions\/node\/v11.8.0\/bin\/yarn\r\n    npm: 6.5.0 - ~\/.nvm\/versions\/node\/v11.8.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^24.8.0 => 24.8.0\r\n```\r\n\r\ncc @thymikee ","comments":["@rogeliog are you able to help here?","After thinking about it a little bit more this kinda seems like a node problem, but maybe something can be done in jest to overcome this. And even if it's node problem there is always a chance that we'd like to kill jest between adding custom SIGTERM handler and removing it, so when that happens and we receive SIGTERM we should be able to clean up. I haven't found a way to do it, but I'm not too familiar with node's APIs around this space.\r\n\r\nBTW. \"needs repro\" is not applicable anymore as I've presented the repro case \ud83d\ude09 ","Yes, I can help investigate this ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Since the issue was reproduced and downsized to a minimal repro - I think this is a problem, even if not a high priority one. It might very well not be a problem with jest itself - but it's not obvious how to overcome it and I lack the expertise to figure this out on my own.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Bump for stale bot","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Needs Triage","Bug Report","Stale"]},{"title":"Add playground to website","body":"## \ud83d\ude80 Feature Proposal\r\n@orta and myself have been [discussing](https:\/\/github.com\/kvendrik\/jest-lite\/issues\/4) adding a playground to the Jest website using an approach simular to what [Jest Lite](https:\/\/github.com\/kvendrik\/jest-lite\/blob\/master\/src\/core.ts) uses. I'm opening this issue as I'd like to get the team's thoughts on this (I have a feeling it has come up before \ud83d\ude04).\r\n\r\n## Motivation\r\nOn the [homepage](https:\/\/jestjs.io) we show a lot of output examples. A playground could show people how all these things work in practise and let them play around with it. Once we have that in place we could even [use it as a form of documentation by providing SEO-friendly examples](https:\/\/github.com\/kvendrik\/jest-lite\/issues\/4).\r\n\r\n## Example\r\n[TypeScript's playground](http:\/\/www.typescriptlang.org\/play\/) would be a good example I think. @orta also did some [rough mockups](https:\/\/github.com\/kvendrik\/jest-lite\/issues\/4#issue-469545090) for a Jest cookbook which is close to what we'd have in mind for this (simple editor + output).\r\n\r\n## Pitch\r\nI think @orta gave a pretty good explanation of the value this would add [here](https:\/\/github.com\/kvendrik\/jest-lite\/issues\/4#issuecomment-513844925):\r\n\r\n> The JS reference for Jest covers what all the pieces are, but doesn't necessarily cover how they come together\r\n\r\nAlso see the motivation section above.\r\n\r\ncc @SimenB tagging you on this as well considering you already have some context on Jest Lite \ud83d\ude04","comments":["@orta talked about this when we met up in March, and I think it's mostly in his head beyond the sketches he shared with you. I don't _think_ we have any other issue for this. But we are most definitely keen on getting something like this running. I suggested just embedding codesandboxes, but having it run natively would be super cool, especially for debugging.\r\n\r\n\/cc @cpojer @rickhanlonii ","What's wrong with repl.it?","nothing wrong with it, and I guess we could use it instead of code sandbox. This issue is about a version of jest running natively in the browser, though, and writing examples etc with that","I would prefer a full version of Jest over a simplified one that doesn't have the full feature set.","@cpojer yeah I agree, the usage should be the exact same as when you would install Jest yourself. What are your general thoughts on having a playground with examples? Anything apart from what @SimenB already mentioned?","I think that's a great idea but since Jest itself doesn't run in browsers the only way to run a full version of Jest is by running it in a remote VM, like repl.it is doing.","@cpojer Yeah think it would have to be a setup where we have something like repl.it embedded as the code editor. Embedding repl.it seems to [work pretty well](https:\/\/jsbin.com\/yezurarici\/1\/edit?output), I think even just simply embedding that onto a page with some common examples could be pretty great. From a UX standpoint I'm a little concerned about the noise in Repl.it's UI, feel like it might make the example harder to understand but we can explore it and see how far we get.","Yeah, I would love to use repl.it - it'd take quite a bit of UI work in repl.it to have it make sense when embedded inside the jest website as a playground though, and that's a bit out of our control\r\n\r\nJest lite is working, covers most cases (I assume `jest.mock` isn't covered?) and the design\/features can be fully controlled by the site","@orta yeah agreed, I do agree with @cpojer though that we don't want to give users the wrong impression in a case where they, say, try customizing the example and its missing features.\r\n\r\nHaving that said, Repl.it's UI could be a bit of an issue as there seems to be a good amount of clutter when embedded. I quickly embedded Repl.it onto a new playground page and this is what I got. How do we feel about this?\r\n\r\n<img width=\"1587\" alt=\"Screen Shot 2019-07-24 at 3 40 48 PM\" src=\"https:\/\/user-images.githubusercontent.com\/4029894\/61823299-892f9580-ae29-11e9-97ce-a004e6461324.png\">\r\n","I think it's a step forwards \ud83d\udc4d  - perhaps a sidebar that links to different repl.it examples?","Yeah I feel it might be okay in terms of clutter. As a next step I'll add a way to explore different examples.","Okay so this is going [pretty okay](https:\/\/github.com\/kvendrik\/jest\/compare\/master...feature\/playground) but hitting some roadblocks:\r\n\r\n1. In the [Jest Repl.it environment](https:\/\/repl.it\/@amasad\/try-jest) the `config.json` file is the first file and as I don't have control over what file Repl.it shows first when embedded every example starts with the config which isn't great. Any way we could change that @SimenB?\r\n\r\n1. Second this is that the website seems to strictly SSR React which means event handlers don't seem to work. Does anyone know if there's an easy way to get that to work?","1. I don't know. Maybe @amasad could help us? It'd be great to upgrade to Jest 24 as well\r\n2. Docusaurus 2 should support client side scripts, so we can wait for that to be more feature complete. https:\/\/v2.docusaurus.io\/","As someone who is working on learning testing with Jest, wanted to share some feedback on what's already been commented:\r\n\r\n> I would prefer a full version of Jest over a simplified one that doesn't have the full feature set.\r\n\r\n100% agree. Having everything allows me to look at projects that already use Jest and try to emulate the APIs they're using in addition to picking and choosing from the docs.\r\n\r\n>In the Jest Repl.it environment the config.json file is the first file and as I don't have control over what file Repl.it shows first when embedded every example starts with the config which isn't great. Any way we could change that @SimenB?\r\n\r\nI know that Glitch provides a lot of control over what you can\/can't see. I don't want to throw a wrench in this, but it may be an alternative worth considering. I'm sure they'd also be more than willing to help out \u2013 they've been very helpful with nodejs.dev so far!\r\n\r\nAdditionally, I wanted to give some feedback in general on what would be helpful for my experience so far:\r\n\r\n- getting clarity \/ examples on how to level-up from most basic example to more complex use cases\r\n- teaching things outside of just code \u2013 file setup, directory structure, etc. and how developers can approach that effectively\r\n- showing how to configure jest effectively ","Hey! Repl.it founder here, happy to help.\r\n\r\nSo the issues are:\r\n\r\n- Upgrade to v24\r\n- Customize entry point\r\n- Anything else?\r\n\r\n@kvendrik re the following, I'm curious what's the clutter in embedded mode? It's only header, editor, and console. What could be better?\r\n\r\n> Having that said, Repl.it's UI could be a bit of an issue as there seems to be a good amount of clutter when embedded. I quickly embedded Repl.it onto a new playground page and this is what I got. \r\n\r\n","Thanks @amasad!\r\n\r\n> Anything else?\r\n\r\nI think being able to install dependencies into the Jest repl is pretty crucial and being able to configure the Jest config.\r\n\r\nAs an example I'd love to write a repl for [jest-extended](https:\/\/github.com\/jest-community\/jest-extended) docs. To do that we'd need to install `jest-extended` and configure Jest to use `jest-extended` in the `setupFilesAfterEnv` option.","it would also be great to have the definitely typed [jest type definitions](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/blob\/master\/types\/jest\/index.d.ts) available inside the editor, then you get auto-complete and inline docs \ud83d\udc4d  ( it'd look [something like this](https:\/\/gitlab.com\/danger-systems\/danger.systems\/blob\/master\/static\/source\/js\/editor.html.slim#L104-107) )","Hey @amasad!\r\n\r\nTo break it down:\r\n\r\n## Must-have\r\n- Upgrade to Jest v24.\r\n- Being able to customize the entry point so users don't have to navigate files to see the example.\r\n\r\n## Nice-to-have\r\n- A way to hide everything except for the editor + output + run button would be nice for a more focussed view.\r\n- I'm also thinking it might be nice to auto-run examples or show a cached result initially so people don't have to press \"run\" first to get an idea of what will happen.\r\n\r\nThen, there's also, as @orta said, the ability to use types in the editor which is probably a nice-to-have.\r\n\r\nWhat @mattphillips said [seem to already be possible](https:\/\/repl.it\/repls\/UnderstatedDependableScreenscraper) (by opening a shell and manually installing the module) so think we're good there? @mattphillips would you be able to confirm?\r\n","Hey guys, sorry for the delay, I was waiting for some infrastructure upgrade to make this smoother. In the next couple of days, I'll be deploying a new version of the latest Jest and on top of that it will have:\r\n\r\n- packager support\r\n- LSP (autocomplete and Jest docs inline)\r\n- Overall more stable and configurable\r\n\r\nI'll get the new version up tomorrow or the day after.","hey @kvendrik\/everyone. The version has been updated and now and the file to be rendered first can be selected using the `fileName` query param like so: https:\/\/repl.it\/@amasad\/test-jest-file?fileName=add.js\r\n\r\nI'll let you know when the rest of the stuff I mentioned above has been deployed.","Hey everyone (hope y'all having a great holiday season)! \r\n\r\nNot sure if you saw our announcement about our [GitHub integration](https:\/\/repl.it\/blog\/github). A great side-effect is that the Repl.it environment became now much more [configurable](https:\/\/docs.repl.it\/repls\/dot-replit). You don't have to rely on us to create and maintain the image for you and you have a lot more flexibility in how to run and structure the code.\r\n\r\nI went ahead and created a new playground for jest: \r\n\r\n- repl: https:\/\/repl.it\/@amasad\/jest-playground \r\n- repo: https:\/\/github.com\/amasad\/jest-playground\r\n\r\nYou can have your users fork it for reproducing issues or what have you. As an example, here is a fork of that that configures Babel: https:\/\/repl.it\/@amasad\/jest-playground-babel\r\n\r\nThe only downside to this approach is the initial install time when loading up the repl. However, we have a solution for this coming very soon. A blazing fast dependency caching solution. \r\n\r\nI'd love to hear your feedback because I'd like to deprecate repl.it\/languages\/jest and redirect people to what I laid out above.","Wow @amasad that's a great update thanks!","@rickhanlonii thoughts on updating the issue template with it? It's probably best if you or whoever is going to maintain it fork it on your repl.it account. ","Here's the setup I'd propose:\r\n\r\n- Create a `@jest` repl.it account\r\n- Share credentials with the core team\r\n- Create a `@jest\/latest` playground\r\n- Create a `@jest\/version` for the last few version\r\n- Update template to link to latest and explain the other versions\r\n\r\nHow does that sound @amasad @thymikee @SimenB @orta \r\n","That sounds good. The Rollup team is doing something similar. cc @shellscape https:\/\/github.com\/rollup\/plugins\/commit\/3380920d7ed7cafafe442bb79f1d1c3559280380","Yes we've added a \"reproduction\" repl.it for users to provide repros on rollup plugin issues. The main Rollup REPL is great for core repros, but not for plugins. We're hoping this cuts down on code pasting in issues, and triage time for maintainers. ","Hey hey! I went ahead and created a `@jest` repl.it account and in it the base template y'all can use for this. Try it out: https:\/\/repl.it\/@jest\/jest-playground\r\n\r\nYou'll notice that:\r\n- it's faster (even dependencies are cached)\r\n- more customizable\r\n- and easier to maintain; updating jest is as easy as bumping the version in `package.json`\r\n\r\n![jest](https:\/\/user-images.githubusercontent.com\/587518\/73040375-3c476e80-3e0e-11ea-8039-708167883467.gif)\r\n\r\n@rickhanlonii @SimenB @thymikee Can one of you email me and I can give you access to the account? amjad@repl.it\r\n","Hey everyone! First of all apologies, I'm aware I'm jumping in late in the discussion; What I want to add to is was just not possible last year :) \r\n\r\nI also realize that the Repl.it folks have done great work to provide the best support possible and my intention is not to propose one solution over the other but to provide an alternative to discuss. Maybe, in the end, the choice for users?\r\n\r\nQuick background: I'm an engineer at StackBlitz and we've made it possible to run Node.js _directly_ in the browser. \r\n\r\nTL;DR for what that means:\r\n- it's not a connection to a remote VM \u2013 it really runs in a browser\r\n- so it spins up in less than a second\r\n- because it runs in a browser it's cheap in terms of server resources so each user can edit the code immediately\r\n- because it's a plain Node.js environment, you can configure your dependencies and files however you like\r\n- you can create the code the examples on the platform, or point it to a GitHub folder, so it's easy to maintain by the open-source community\r\n(it's how e.g. the Next.js team are [doing it](https:\/\/github.com\/vercel\/next.js\/tree\/canary\/examples\/with-emotion#preview), or [webpack](https:\/\/webpack.js.org\/guides\/getting-started\/))\r\n\r\nThis is how it works in practice: (this is a real-time recording of the production environment)\r\n![jest-in-sb](https:\/\/user-images.githubusercontent.com\/1511906\/126881954-4bed1dbe-dd5e-490e-93ed-a50b64c2d8ac.gif)\r\n\r\nAnd here's the link to the above example:\r\nhttps:\/\/stackblitz.com\/edit\/jest-example?file=sum.test.js&view=editor&terminal=test\r\n\r\nI'd love to hear your thoughts on this! @orta @SimenB @cpojer @rickhanlonii\r\nLet me know if you have any questions too!","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Most definitely still want this (like react beta docs have)","@mattphillips you're working on this? \ud83d\ude42 ","@SimenB kinda! My plan is to bring [SandpackTests](https:\/\/sandpack.codesandbox.io\/docs\/advanced-usage\/components#tests) over to the expect docs to give an inline playground like on: [jest-extended docs](https:\/\/jest-extended.jestcommunity.dev\/docs\/matchers). \n\nWhat is the actual goal of this issue? Feels more like a guide on testing with Jest. \n\nA few things to note with SandpackTests, the implementation is backed by codesandbox which exposes a jest-lite version of Jest. Is that sufficient for this issue? \n\nNote, based on a conversation on the Codesandbox discord I think there is work happening that could bring Node to the browser for Sandpack and\/or micro VMs to Sandpack either of which would enable running a full version of Jest via Sandpack. \n\nIn the meantime of that I think it would be good to do some work on making expect and jest-circus both work in the browser again so that codesandbox can run newer versions of both. "],"labels":[":rocket: Enhancement","Documentation :book:","Website","Pinned"]},{"title":"Per-worker setup\/teardown","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nJest provides _[once-global](https:\/\/jestjs.io\/docs\/en\/configuration#globalsetup-string)_ setup and teardown, and _[per-file](https:\/\/jestjs.io\/docs\/en\/api#beforeallfn-timeout)_ setup and teardown, but conspicuously absent is _per-worker_ setup and teardown.\r\n\r\n## Motivation\r\n\r\nOne worker's set of tests runs serially, and is ideally suited to reusing an exclusive resource like a database or redis connection.\r\n\r\n## Example\r\n\r\nSue has a test suite that uses a database.  She can create _multiple_ databases, but there is a time cost associated with spinning one up before it can be used.\r\n\r\nFrom her test suite she'd like to get maximum concurrency with minimum database setup time.\r\n\r\nCurrently possible approaches:\r\n1) One database, run all the tests serially.\r\n   * This is unacceptably slow. Concurrency is one of Jest's killer features and it's sad to lose it.\r\n2) Multiple databases, created on fly at runtime, per-file. (in e.g. `beforeAll()`)\r\n   * This pays the database setup cost many more times than is necessary, slowing down the test suite.\r\n3) Multiple databases, created upfront. (e.g., make 20 databases, once, in `globalSetup`)\r\n   * This requires you to choose a constant (e.g. **20**) according to how many workers you want to run. \r\n   * Choose the wrong number for `-w` (or get the wrong number inferred by your CPU core count), and it will either do too much work or not have enough databases.\r\n   * Also it's painful to wait on a large upfront cost when you're running, say, just one test.\r\n\r\nIdeally, instead:\r\n\r\n4) Multiple databases, created once per-worker\r\n   * This is the best-case for minimizing database setup and maximizing reuse, and doesn't require you to premeditate the number of databases. \r\n   * You can use whatever `-w` you want (or let Jest infer it), and you'd get the exact right number of databases.\r\n   * When you run just one test, you'll get just one database.\r\n\r\n## Pitch\r\n> Why does this feature belong in the [Jest core platform](https:\/\/www.youtube.com\/watch?v=NtjyeojAOBs)?\r\n\r\nI'm not sure where the boundary of _core platform_ is, but it stands to reason that `beforeWorker` and `afterWorker` should be provided by the same system that provides `beforeAll`, `beforeEach`, and `globalSetup`.\r\n\r\n## Alternatives\r\nI googled around but couldn't come up with another way to achieve this. Is there another (perhaps undocumented) way to hook into worker setup\/teardown?","comments":["https:\/\/jestjs.io\/docs\/en\/configuration#setupfilesafterenv-array\r\n\r\nBut AFAIK there's no option to run something before the worker is closed. I'd find such a feature useful, especially for generating database namespaces to run tests in isolation etc., like with Redis you mentioned.","For more complex use cases, a custom environment is probably more well suited. We do this e.g. for setting up and tearing down a database connection.","@jeysal by \"custom environment\", you mean the thing specified via [testEnvironment](https:\/\/jestjs.io\/docs\/en\/configuration#testenvironment-string), right? Does that give you an opportunity for setup\/teardown per-worker, or only per-file?","Well, not exactly per-worker. You can use `JEST_WORKER_ID` to distinguish between workers for using distinct databases, but I can see how that might not be enough in some use cases, performance-wise.","A big +1 for this \ud83d\udc4d\ud83c\udffb\r\n\r\nI'm from the core team maintaining [Detox](https:\/\/github.com\/wix\/Detox\/) (who have already introduced enhancements to `Jest`, in the past), and we would also really appreciate this kind of support. Our use case is effectively identical, up to the point that instead of databases, we have Android\/iOS emulators as the resource in question. We already have the means to bring up emulators on a per-worker basis, but we lack the ability to clean up efficiently (i.e. immediately when a worker is no longer required). Things become even more prominent when these emulators are _rented_ from external SaaS providers such as [Genymotion cloud](https:\/\/www.genymotion.com\/cloud\/): You literally pay for rent time, and hence must painfully optimize it.","Have any of you folks found a way to emulate this feature using the existing setup \/ teardown primitives?  ","@airhorns I've tried doing so by registering a `process.on('beforeExit', () => {...})` callback in a worker's context ([reference](https:\/\/nodejs.org\/api\/process.html#process_event_beforeexit)).\r\nUnfortunately, empirically it seems that Jest keeps all workers alive right until the last one is done, so there's no added value compared to subscribing a [global-teardown listener](https:\/\/jestjs.io\/docs\/en\/configuration#globalteardown-string) (which is the obvious alternative).\r\n\r\nIn addition, it seems Jest doesn't approve asynchronous work done past the time it expects everything to be torn down -- you get the famous warning saying Jest is still alive 1 second after it should have ended, and can't distinguish this cause for it from a real problem with your tests\/code. That is what happens at best, actually, and at worst - your callback is force-killed prematurely along with the worker itself.","@d4vidi that makes sense, thanks for the tip! Are you running without jest's module resetting stuff so that you keep a handle on your per-worker shared resource throughout the run? I have been trying to get the same thing going but struggling to keep any kind of persistent state between suites because of the module reset, which seems desirable for other reasons. ","Seems like it would help this person out a lot... also anyone who managed to get here from trying to figure out how to setup a DB per worker - this is a possible inelegant work around.\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/10552","> We already have the means to bring up emulators on a per-worker basis\r\n\r\n@d4vidi \u2013 I'm curious, how did you implement this?","I am pretty noob js developer but I made something up that ***solves\\**** this issue. *And please don't critize I just mean to present a solution for curious people by this comment.*\r\n\r\n`*` means solving with *my own test runner* ***not with*** *jest runner*.\r\n\r\n`flash` is my test runner I created few days back, to test this you need below setup:\r\n\r\n```bash\r\ngit clone https:\/\/github.com\/sahilrajput03\/flash\r\ncd flash && npm link\r\ncd ..\r\n\r\ngit clone https:\/\/github.com\/sahilrajput03\/learning-monogo-and-mongoosejs\r\ncd learning-monogo-and-mongoosejs\/mongoosejs-with-hot-flash\r\nnpm i && npm link flash\r\nnpm start\r\n```\r\n\r\nNow if you edit code in `code.js`, then you database connection won't be thrown away but reused thus giving you a lightning fast TDD experience with no connection loosing on running tests while in watch mode.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale.","@SimenB or other maintainers \u2013\u00a0would a PR implementing this proposal be welcome?","In our testcase we need to share a (non-serializable) `ts-morph` `Project` between test files, because the typescript API does several seconds of sync parsing whenever we use it.\r\n\r\nHaving one instance per worker would completely solve the performance problems we face.  And it's truly the only way we could get both good performance and file structure; TS API objects aren't serializable and having fully isolated test suites isn't giving us any worthwhile safety guarantees in this case."],"labels":[":rocket: Feature Request"]},{"title":"changedSince should run everything if the package.json changes","body":"## \ud83d\udc1b Bug Report\r\n\r\nIf the package.json changes, a dependency change like enzyme or jest itself might cause test failures. But changedSince ignores it. Our CI process runs tests changed since master (as a full run is nearly 10 minutes on our build servers) and we miss test failures.\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n1. change package.json to break tests\r\n2. run with changedSince master\r\n3. no test failures are reported\r\n\r\n## Expected behavior\r\n\r\nI'd expect if package.json changes, to give up changedSince and run all tests.\r\n\r\nMaybe instead of package.json you could use package-lock.json. Either work for us.\r\n","comments":["This is a feature request, not a bug. What do you think @SimenB @jeysal?","Not sure, there's lots of different things that *could* be added but we need a boundary where dependency detection for changes files ends and only supporting the Node resolution algorithm seems like a good one to me. So in that way, we could look at the `package.json` in a folder that is `require`d (because its `main` field might change), but I don't think more than that would be reasonable).","On second thought, it shouldn't be package.json but instead the package lock file (supporting both yarn and npm).\r\nI agree that detecting the exact dependencies used in a test (+jest itself) and seeing if that changed would be ideal, but adding support for a single file would be easier, at the cost of re-running everything when a dependency changes.","Also in very much need of this in a monorepo setup.\r\n\r\nI'd say implementing this over the `package.json` would be simpler, as if it's done checking the lockfile there will be so many different formats to take into account: NPM shrinkwrap, NPM package-lock, Yarn Classic, Yarn Berry (not sure, but I guess it changed), **pnpm** (please!).\r\n\r\nThe downside of not checking the lockfiles is that if just the lockfile is updated (e.g security upgrades from Dependabot) then again it could lead to things breaking unexpectedly.","I just saw that there's actually an option called `includePaths` in the code related to this diffing. Maybe we could expose it in the CLI and people can choose freely, it'll be less risky than trying to guess this package.json\/lockfile thing, will be non-breaking, and pretty flexible to whoever different needs anyone has.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/bc50e7f360ab1845abbaa0b3ad788caead0d3174\/packages\/jest-changed-files\/src\/index.ts#L36\r\n\r\n@SimenB what are your thoughts?\r\n\r\nSeems like that just passing `package.json` there wouldn't suffice though, probably we'd need to \"taint\" the whole package it controls.","Checking one year later on this, just had another use case that I think if it'd be helpful if we could instruct the `includePaths` option somehow. \r\n\r\nOn CI we want to run tests only for changed files and collect coverage only from them as well, thus we're using `--changedSince`, it works fine if there's at least one test file that was created\/modified, but if the changes only include untested files then `jest` finds no tests and doesn't report the coverage for the untested files\u2014which we want it to.\r\n\r\nMy workaround was to use `patch-package` to change `jest-changed-files` to always run a single dummy test file regardless of it being changed or not, so it generates the coverage report for all the untested files when no tests were created for them at all.\r\n\r\nCopying @stipsan just in case you have any suggestions on this, because I saw you worked on something somewhat related to this 4 years ago (https:\/\/github.com\/facebook\/jest\/pull\/5601).\r\n\r\nHappen to open another separate issue for this if it makes more sense, @SimenB.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale\u2026","Do You have any ETA for this?"],"labels":[":rocket: Feature Request"]},{"title":"toThrow should return the error","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\n`.toThrow` and `.rejects.toThrow` should return the error thrown.\r\n\r\n## Motivation\r\n\r\nWhen working with a project that uses ava I noticed their [`.throws`](https:\/\/github.com\/avajs\/ava\/blob\/master\/docs\/03-assertions.md#throwsfn-expected-message) and [`.throwsAsync`](https:\/\/github.com\/avajs\/ava\/blob\/master\/docs\/03-assertions.md#throwsasyncthrower-expected-message) return the original error. It is very convenient.\r\n\r\nThis would make it possible to never need the [`expect.hasAssertions()` + `try \/ catch`](https:\/\/github.com\/jest-community\/eslint-plugin-jest\/issues\/295#issuecomment-509974545) syntax.\r\n\r\n\r\n## Example\r\n\r\n```js\r\nfunction throwSyncError() {\r\n\tconst syncError = new Error('sync error');\r\n\tsyncError.code = 'SYNC';\r\n\tthrow syncError;\r\n}\r\n\r\nasync function throwAsyncError() {\r\n\tconst asyncError = new Error('sync error');\r\n\tasyncError.code = 'ASYNC';\r\n\tthrow asyncError;\r\n}\r\n\r\ntest('can get error message', async () => {\r\n\tconst syncError = expect(() => throwSyncError()).toThrow('sync error');\r\n\texpect(syncError.code).toEqual('SYNC');\r\n\r\n\tconst asyncError = await expect(throwAsyncError()).rejects.toThrow('sync error');\r\n\texpect(asyncError.code).toEqual('ASYNC');\r\n});\r\n```\r\n\r\n## Pitch\r\n\r\nBecause using `.toThrow` and `.rejects.toThrow` over `try\/catch` it prevents tests that don't fail because they no longer reject. https:\/\/github.com\/facebook\/jest\/issues\/3917\r\n","comments":["Sounds like a good idea to me. @SimenB @thymikee @pedrottimark wdyt?","While I agree the idea is sound (I love this part of Ava's API), I'm not sure we should do this. All matchers today return `void` (or `Promise<void>` in the case of `resolves` and `rejects`) - changing that is a pretty big change. I'd definitely like @cpojer's and\/or @scotthovestadt's thoughts on this before we do much work on it (sorry about not responding sooner, @chrisblossom!).\r\n\r\nNote that this change will also break things like https:\/\/github.com\/mattphillips\/jest-chain (\/cc @mattphillips who might have thoughts on this \ud83d\ude42)\r\n\r\n---\r\n\r\nAs for my own opinion - I think this is better solved by a custom matcher that takes  predicate rather than returning the error.\r\n\r\n```js\r\nexpect(() => { throw new Error('boom'); }).toThrowWithField(err => err.code === 'MODULE_NOT_FOUND');\r\n```\r\n\r\nor something like that. Such a matcher may or may not make sense to have in core, but that's a separate discussion","> As for my own opinion - I think this is better solved by a custom matcher that takes predicate rather than returning the error.\r\n\r\nPersonally I disagree. But I also think that 90% of the matchers should be removed and should just be expressed as plain javascript with `toEqual`. Less too learn, less to document.\r\n\r\nI'd prefer to use the existing matcher if anything:\r\n\r\n```js\r\ntest('example', () => {\r\n\tlet errorThrown;\r\n\texpect(() => {\r\n\t\tthrow new Error('boom');\r\n\t}).toThrow((error) => {\r\n\t\terrorThrown = error;\r\n\r\n\t\t\/\/ boolean return (true passes, false fails)\r\n\t\treturn error.message === 'boom';\r\n\t});\r\n\r\n\texpect(errorThrown.code).toEqual('MODULE_NOT_FOUND');\r\n});\r\n```\r\n\r\nBut I think the PR as is feels a lot more natural \/ expected. Also I think it is best to provide the tools to never need `try\/catch` considering how easy it is to shoot yourself in the foot with it.\r\n","> All matchers today return void (or Promise<void> in the case of resolves and rejects) - changing that is a pretty big change.\r\n\r\nJust curious, why is this considered a big change?","Note that you can do this today:\r\n\r\n```js\r\ntest('example', () => {\r\n  expect(() => {\r\n    throw new Error('boom');\r\n  }).toThrow(expect.objectContaining({ message: 'boom' }));\r\n});\r\n```\r\n\r\nFor `message` you can just add the string as `.toThrow('boom')`, but the asymmetric `expect.objectContaining` allows you to check any field (at any depth). And you can create your own custom asymmetric matchers if you want as well","Another big use case for this is dealing with aggregate errors. Examples: [`tc39\/proposal-promise-any`](https:\/\/github.com\/tc39\/proposal-promise-any) and [`aggregate-error`](https:\/\/github.com\/sindresorhus\/aggregate-error). Seems very difficult to deal with with the current matching api. With this PR you could set the error and run your own `expects`.","The type declarations say that matchers return the actual value.  Is that intended to be the case, or is it a mistake?\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/expect\/src\/types.ts#L118-L122\r\n\r\nI'm hitting the same issue where it's annoying to assert against thrown values.  I already know how to use `expect(valueGoesHere).<matchers that I already understand how to use>()`  It seems unnecessarily inconvenient that I have to use a different style of matching for thrown values.\r\n\r\n---\r\n\r\n`expect(promise).rejects.<matcher here>()` can be used to extract the rejection of a promise and match against it.  Can there be a sync variant?  `expect(fn).throws.toMatchObject({code: 'ENOENT'})`?\r\n\r\nIt's still not ideal because multiple assertions means multiple function invocations, which is not the case with the promise.  The assertion library should be giving the developer a straightforward way to assert that something throws and get a reference to the thrown value.","@SimenB  Is there any progress to this proposal? I really like it and would be greatly ease testing async functions.\r\n","Upvoting this feature as well. \ud83c\udf4c that it's been sitting for a year without action while other test suites support this.","> Note that you can do this today:\r\n> \r\n> ```js\r\n> test('example', () => {\r\n>   expect(() => {\r\n>     throw new Error('boom');\r\n>   }).toThrow(expect.objectContaining({ message: 'boom' }));\r\n> });\r\n> ```\r\n> \r\n> For `message` you can just add the string as `.toThrow('boom')`, but the asymmetric `expect.objectContaining` allows you to check any field (at any depth). And you can create your own custom asymmetric matchers if you want as well\r\n\r\n@SimenB Is this doced anywhere? I canot find.","> \r\n> \r\n> Note that you can do this today:\r\n> \r\n> ```js\r\n> test('example', () => {\r\n>   expect(() => {\r\n>     throw new Error('boom');\r\n>   }).toThrow(expect.objectContaining({ message: 'boom' }));\r\n> });\r\n> ```\r\n> \r\n> For `message` you can just add the string as `.toThrow('boom')`, but the asymmetric `expect.objectContaining` allows you to check any field (at any depth). And you can create your own custom asymmetric matchers if you want as well\r\n\r\nThis is great, but I'd like to be able to use expect(thing()).rejects.toBeInstanceOf(SomeErrorClass) and additionally check that the thrown error has the correct data added to it (ie constructed with the right message or value).","> This is great, but I'd like to be able to use expect(thing()).rejects.toBeInstanceOf(SomeErrorClass) and additionally check that the thrown error has the correct data added to it (ie constructed with the right message or value).\r\n\r\nCurrently I do\r\n\r\n```js\r\nconst promise = thing()\r\nawait expect(promise).rejects.toThrow(MyErrorClass)\r\nawait expect(promise).rejects.toThrow('Error message')\r\nawait expect(promise).rejects.toThrow(expect.objectContaining({ code: 'MY_CODE' }));\r\n```\r\n\r\nBut it only kind of works for async code if you want `thing()` to be evaluated only once. It's a bit clunky.","> As for my own opinion - I think this is better solved by a custom matcher that takes predicate rather than returning the error.\r\n> \r\n> ```js\r\n> expect(() => { throw new Error('boom'); }).toThrowWithField(err => err.code === 'MODULE_NOT_FOUND');\r\n> ```\r\n> \r\n> or something like that. Such a matcher may or may not make sense to have in core, but that's a separate discussion\r\n\r\nFor the sake of keeping Jest consistent, I'm actually fine with this approach. However, I think it would be useful for `toThrow` to accept a callback.\r\n\r\n```ts\r\nexpect(() => { throw new Error('boom'); }).toThrow((err: any): void => {\r\n  expect(err.code).toBe('MODULE_NOT_FOUND');\r\n});\r\n```\r\n\r\nIt's basically just a callback that enables the user to perform their own assertions on the thrown error.\r\n\r\n> And you can create your own custom asymmetric matchers if you want as well\r\n\r\nIdeally, users should be able to avoid making custom matchers. That's probably its own barrier to entry. I've been using Jest for years, and I've never had to make custom matchers. I imagine this is why A) `jest` has so many matchers out of the box to begin with and B) popular libraries often provide matchers that prevent their users from worrying about this. This is great. But for a typical user, it also makes the idea of creating matchers intimidating. I imagine such an approach is avoided for the average person.\r\n\r\nResorting to \"Make a custom matcher\" kind of defeats the point and raises a number of problems. Moreover, as chrisblossom, said, leaving the `try\/catch` in the user's hands increases the chance of making mistakes.\r\n\r\nThe current `toThrow` doesn't seem to expect a function. So it could easily be overloaded and given a `if (typeof input === 'function')` portion, I would presume. (I haven't read the code yet.) Thoughts? @SimenB @chrisblossom And\/or @cpojer and @scotthovestadt? since it seems Simen really wanted your opinions too.","Welp. For anyone who's interested, I had the (bad) idea of trying out matchers for the first time. I'm not sure whether or not people will find it useful, but I'm leaving it behind as an artifact just in case... while people are waiting to hear back from the Jest devs.\r\n\r\nMy solution should solve both sync and async use cases. @Janpot could you let me know if you find this useful? You still have to write a bit of code with my solution, but hopefully the approach looks less hackish to you.\r\n\r\n```ts\r\nconst promise = thing() \/\/ `thing` is an async function\r\n\r\nawait expect(promise).rejects.toThrowWithError((error: MyErrorClass) => {\r\n  expect(error).toBeInstanceOf(MyErrorClass);\r\n  expect(error.message).toBe(\"Error message\");\r\n  expect(error.code).toBe(\"MY_CODE\");\r\n});\r\n```\r\n\r\n## Jest Code (TypeScript)\r\n\r\nNote that I tested my code locally, and it works in all of the anticipated use cases. So if you use my code and it doesn't work, then either A) You have an outdated version of `jest` or `typescript` (or some other environment problem), or B) I copy-pasta'd wrong... in which case you should ping me. :slightly_smiling_face:\r\n\r\nExtend `jest` wherever you want -- in your test file, or in a file that you import:\r\n```ts\r\nexpect.extend({\r\n  toThrowWithError(received, expected) {\r\n    \/\/ Constants\r\n    const passErrorToUser = (err: unknown): jest.CustomMatcherResult => {\r\n      expected(err);\r\n      return { pass: true, message: () => \"\" };\r\n    };\r\n\r\n    \/* -------------------- Handle Promise Modifiers -------------------- *\/\r\n    if (this.promise === \"resolves\")\r\n      return {\r\n        pass: false,\r\n        message: () =>\r\n          this.utils.matcherErrorMessage(\r\n            this.utils.matcherHint(\"toThrowWithError\", undefined, undefined, {\r\n              promise: this.promise,\r\n            }),\r\n            `'${this.promise}' is an invalid modifier for 'toThrowWithError'`,\r\n            \"\"\r\n          ),\r\n      };\r\n\r\n    \/\/ Jest already takes care of validating `rejects`. We just need to pass the error along.\r\n    if (this.promise === \"rejects\") return passErrorToUser(received);\r\n\r\n    \/* -------------------- Argument Validation -------------------- *\/\r\n    if (typeof received !== \"function\")\r\n      return {\r\n        pass: false,\r\n        message: () =>\r\n          this.utils.matcherErrorMessage(\r\n            this.utils.matcherHint(\"toThrowWithError\"),\r\n            `${this.utils.RECEIVED_COLOR(\"received\")} value must be a function`,\r\n            `Received has value: ${this.utils.RECEIVED_COLOR(typeof received)}`\r\n          ),\r\n      };\r\n\r\n    if (typeof expected !== \"function\")\r\n      return {\r\n        pass: false,\r\n        message: () =>\r\n          this.utils.matcherErrorMessage(\r\n            this.utils.matcherHint(\"toThrowWithError\"),\r\n            `${this.utils.EXPECTED_COLOR(\"expected\")} value must be a function`,\r\n            `Expected has value: ${this.utils.EXPECTED_COLOR(typeof expected)}`\r\n          ),\r\n      };\r\n\r\n    \/* -------------------- Matcher Logic -------------------- *\/\r\n    try {\r\n      received();\r\n      const errorMessage = \"Received function did not throw\" as const; \/\/ copied from Jest's `toThrow` matcher.\r\n\r\n      return {\r\n        pass: false,\r\n        message: () =>\r\n          `${this.utils.matcherHint(\"toThrowWithError\", undefined, undefined)}\\n\\n${errorMessage}`,\r\n      };\r\n    } catch (err) {\r\n      return passErrorToUser(err);\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nFor TS users, you'll still have to update the types for Jest. In a type declaration file of your choosing, apply the following:\r\n```ts\r\n\/\/ Add custom jest matchers\r\ndeclare global {\r\n  namespace jest {\r\n    interface Matchers<R> {\r\n      \/**\r\n       * Used to test that a function throws when it is called. Allows\r\n       * assertions to be performed on the error that is generated.\r\n       *\/\r\n      \/\/ eslint-disable-next-line @typescript-eslint\/no-explicit-any\r\n      toThrowWithError(expected: (error: any) => void): R extends Promise<void> ? R : void;\r\n    }\r\n  }\r\n}\r\n```\r\n(Note that I use TS ESLint's recommended settings. So I have a comment for disabling a linter warning.)\r\n\r\n\r\nI would still love to hear from the Jest devs about updating their `toThrow` matcher.","Being able to analyze the error in the usual jest chained functional style feels like it should be part of the standard api, especially with the discouragement of try{} catch{}\r\n\r\n","> Currently I do\r\n> \r\n> ```js\r\n> const promise = thing()\r\n> await expect(promise).rejects.toThrow(MyErrorClass)\r\n> await expect(promise).rejects.toThrow('Error message')\r\n> await expect(promise).rejects.toThrow(expect.objectContaining({ code: 'MY_CODE' }));\r\n> ```\r\n> \r\n> But it only kind of works for async code if you want `thing()` to be evaluated only once. It's a bit clunky.\r\n\r\nI noticed that `jest` is normalizing errors, getting rid of some fields. So for example, I'm writing a CLI that I'm testing via `execa` and I want to inspect the `exitCode` for the expected error. But `await expect(promise).rejects.toThrow(expect.objectContaining({ exitCode: 'MY_CODE' }))` doesn't work as `jest` has omitted the `exitCode` from the `execa` error!\r\n\r\nI was able to workaround this an make a `getError` function that reliably returns the expected error unmodified:\r\n\r\nUsage:\r\n\r\n```ts\r\nit(\"checks an error\", async () => {\r\n  let error = await getError(doAsyncStuff(arg1, arg2));\r\n\r\n  \/\/ wrap in `async` function if you want to use a sync function or `await` keyword\r\n  \/\/ let error = await getError(async () => {...})\r\n\r\n  \/\/ typeguards for typescript to be happy, since `error` will be `unknown` just like in a `catch` clause\r\n  \/\/ if (!expectedErrorGuard(error)) throw error;\r\n  \/\/ for example:\r\n  \/\/ if (!(error instanceof Error)) throw error; \r\n\r\n  expect(error.message).toContain(\"my error message\")\r\n  expect(error.exitCode).toBe(1)\r\n})\r\n```\r\n\r\nImplementation:\r\n\r\n```ts\r\nclass NoErrorThrownError extends Error {}\r\nconst getError = async (\r\n  erroring: Promise<unknown> | (() => Promise<unknown>)\r\n) => {\r\n  try {\r\n    let promise = typeof erroring === \"function\" ? erroring() : erroring;\r\n    await promise;\r\n    throw new NoErrorThrownError();\r\n  } catch (error: unknown) {\r\n    if (error instanceof NoErrorThrownError) throw error;\r\n    return error;\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\nJust realized this is exactly what the [lint rule recommends](https:\/\/github.com\/jest-community\/eslint-plugin-jest\/blob\/v26.9.0\/docs\/rules\/no-conditional-expect.md#how-to-catch-a-thrown-error-for-testing-without-violating-this-rule) \ud83d\ude05 so not my idea\r\n\r\n","I wanted to add that implementing this (or the proposal to make `toThrow` accept a callback) would also make it easier to to deal with dynamic error messages. For example, if the error message was something like ``Error: This part of the error message is static but then there is ${someValueThatIDoNotWantJestToCareAbout}``, I would want my test to check whether the error message contained just the static part of the error.\r\n\r\nThe only ways to do that I'm currently aware of are by using a `try\/catch` block (which I don't want to do because it is discouraged for reasons that seem valid), or writing a custom matcher (which I don't want to do either because I would rather not have to learn how to just to accomplish something that seems like it ought to be fairly simple).\r\n\r\nI'll probably dig into writing a custom matcher, but FWIW I think the usability of Jest would be significantly improved if it was easier to make assertions about errors other than the message exactly matching a particular string."],"labels":[":rocket: Feature Request"]},{"title":"Allow asynchronously skipping tests","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nOther testing frameworks allow tests to asynchronously decide whether they should skip themselves.\r\n\r\nFor example, in Mocha:\r\n\r\n```js\r\nit('tests a remote service', async function() {\r\n  if (!(await remoteService.isActive())) {\r\n    return this.skip()\r\n  }\r\n  \u2026 test the remote service \u2026\r\n})\r\n```\r\n\r\nCurrently, however, it is impossible to asynchronously decide whether a test should be skipped in Jest.\r\n\r\nSee also: discussion here: https:\/\/github.com\/facebook\/jest\/issues\/7245\r\n\r\n\r\n## Motivation\r\n\r\nSome tests either depend on - or are explicitly testing - remote services which may or may not be available.\r\n\r\nWithout being able to programatically and asynchronously decide whether tests can be skipped, there are only three options for writing these sorts of tests:\r\n\r\n1. Decide that they will either always pass or always fail if the service is unavailable. In either case the result can be misleading (ie, because in many cases \"failure\" indicates \"the service is wrong\", not merely \"the service is unavailable\", and \"passing\" suggests that everything is okay, which is also not necessarily true).\r\n\r\n2. Keep them in a separate suite, one per remote service, which can be run with (for example), `npm run test:service-a`).\r\n\r\n3. Use a regular expression (or similar) to include \/ exclude these tests from a test run.\r\n\r\n## Example\r\n\r\nA complete, real-world (but anonymized) example from a Mocha-based test suite:\r\n\r\n```js\r\ndescribe('example.com', () => {\r\n  beforeAll(async function() {\r\n    try {\r\n      await fetch('https:\/\/example.com\/api\/whoami')\r\n    } catch (e) {\r\n      return this.skip(`Skipping tests for example.com: ${e}`)\r\n    }\r\n  })\r\n\r\n  it('returns the current user', async () => { \u2026 })\r\n  it('does the other thing', async () => { \u2026 })\r\n})\r\n```\r\n\r\n## Pitch\r\n\r\nThis belongs in Jest core because:\r\n\r\n1. It's currently supported by Mocha: https:\/\/mochajs.org\/ (search for `this.skip`)\r\n2. It's impossible to implement outside of core (see elaboration below)\r\n3. The related discussion on #7245 suggests that it's important to a number of people (see, ex, this comment, which as of this writing has 16 \ud83d\udc4d :  https:\/\/github.com\/facebook\/jest\/issues\/7245#issuecomment-432240159)\r\n\r\n## FAQ\r\n\r\n### Why can't you use an if-statement?\r\n\r\nA common suggestion in #7245 is to use an if-statement (or similar) to skip tests:\r\n\r\n```js\r\ndescribe('example.com', () => {\r\n  const isActive = remoteService.isActive()\r\n  if (isActive) it('returns the current user', async () => { \u2026 })\r\n})\r\n```\r\n\r\nHowever, this will not work for asynchronous tests, as tests must be declared synchronously, but the \"is a remote service active?\" check is necessarily asynchronous.\r\n \r\n### Wouldn't it be better if the tests failed\/succeeded\/retried\/did something else?\r\n\r\nThere are situations when this is true, but (as evidenced by discussion on #7245) there are also situations where \"skip tests when a remote service is not available\" is a reasonable business decision (ex: https:\/\/github.com\/facebook\/jest\/issues\/7245#issuecomment-474587219)","comments":["I struggle to see the value of this feature, you essentially want to be have support for a sort of pseudo false-positive state. When service `A` is unavailable then skip test `B`, what do you want to do with that information?\r\n\r\nBy skipping in a CI environment you will receive no notification of this state without explicitly going in and checking, what is the difference between just leaving the test as a pass when the service is unavailable?","My 2cents on this matter (quite an interesting thing to think about btw):\r\n\r\n@mattphillips I guess there might be no practical difference but the semantic difference is huge. This matters if you want to use the information produced by Jest to determine what happened during the build.\r\n\r\nA practical example: consider a test which depends on an external service. I push new code which would make that test fail and introduce a regression. When CI runs the checks on the code I\u2019ve pushed, the service was not available but the test is marked as `passed`, even though it didn\u2019t run. My code then fails in production but I have no way of determining whether it was because the test was flaky or if it was because it didn\u2019t run.\r\n\r\nThe false positive state, as you have described, would be to have a test which is actually not running but being marked as `passed`.\r\n\r\nNow, I can understand the appeal for this feature as it has a real world correlation, but one might argue that introducing it in would encourage \u2014 or at least acknowledge that it is common to write \u2014 tests that aren\u2019t deterministic (I.e. tests which rely on something you do not have control over). On the other hand, there doesn\u2019t seem to be any reasonable manner to implement this outside of the `core` and it might be a decision from Jest that it doesn\u2019t want to be prescriptive over what it\u2019s users should do. In the case described by @wolever, for example, it seems reasonable to have tests being asynchronously skipped.\r\n\r\nTo sum it up: I\u2019d say this is a valid feature, even though it\u2019s encouraged only for a minority of cases. Since in those cases there doesn\u2019t seem to be a workaround which is \u201cgood enough\u201d (or precise enough), I\u2019d say it would be ok to have it in.\r\n","What about some *cascading*?\r\nLike if precondition test will fail\r\nonly one error will be reported with count of skipped tests?\r\n\r\nIf i wrote test for 3rd party service availability\r\nonly this one fails and I can see real reason why other tests not run?\r\n\r\nFeels much better than seeing hundreds of failing tests. ","Thanks @lucasfcosta - that's a great summary of the problem.\r\n\r\nI would also add that the \"conditional skipping\" can also be environmentally aware. For example, in my environment, there are certain tests which are skipped only if they are running in a development environment (ex, tests which require a certain amount of local setup), but required in a CI environment:\r\n\r\n```js\r\ndescribe('some complicated service', () => {\r\n  beforeAll(async () => {\r\n    const shouldSkip = (\r\n      process.env.NODE_ENV == 'development' &&\r\n      await checkServiceAvailability()\r\n    )\r\n    if (shouldSkip)\r\n      return this.skip(`Skipping tests because ComplicatedService is not running (hint: run it with .\/complicated-service)`)\r\n  })\r\n\r\n  \u2026 rest of the tests \u2026\r\n})\r\n```","@mattphillips What would your solution be for platform specific tests?\r\n\r\nIt would be wildly inappropriate to falsely mark tests as passed or failed when it doesn't even make sense to run the test.\r\n \r\nThe questions we want our test frameworks to answer are: Can I run this test? Did the test pass? A boolean Pass\/Fail cannot answer both of those question. ","jest can mark tests as skipped, I'm using this hack, but it only works synchronously:\r\n```js\r\nconst haveDb = !!process.env.DB_CONNECTION_STRING;\r\nconst testDb = haveDb ? test : test.skip;\r\n```","Any update on this ?","To add to @langpavel's idea, you could have an asynchronous check in a custom [`testEnvironment`](https:\/\/jestjs.io\/docs\/en\/configuration.html#testenvironment-string) class.\r\n\r\n```javascript\r\nconst { connect } = require(\"amqplib\");\r\nconst { EventEmitter } = require(\"events\");\r\nconst NodeEnvironment = require(\"jest-environment-node\");\r\nconst { logger } = require(\"..\/src\/logging\");\r\n\r\nclass TestEnvironment extends NodeEnvironment {\r\n  constructor(config) {\r\n    super(config);\r\n  }\r\n\r\n  async setup() {\r\n    await super.setup();\r\n\r\n    \/\/ rabbit\r\n    try {\r\n      this.global.amqpConnection = await connect({\r\n        username: \"admin\",\r\n        password: \"admin\",\r\n      });\r\n      this.global.channel = await this.global.amqpConnection.createChannel();\r\n      this.global.hasAmqp = true;\r\n    } catch (err) {\r\n      logger.warn(\"AMQP is not available. Skipping relevant tests.\");\r\n      this.global.hasAmqp = false;\r\n    }\r\n  }\r\n\r\n  async teardown() {\r\n    if (this.global.amqpConnection) {\r\n      await this.global.amqpConnection.close();\r\n    }\r\n    await super.teardown();\r\n  }\r\n}\r\n\r\nmodule.exports = TestEnvironment;\r\n```\r\n\r\n```typescript\r\ndescribe(\"example\", () => {\r\n  const hasAmqp: boolean = (global as any).hasAmqp;\r\n  const channel: Channel = (global as any).channel;\r\n\r\n  it = hasAmqp ? test : test.skip;\r\n\r\n  it(\"should send\/receive\", async () => {\r\n    \/\/ ...\r\n  });\r\n});\r\n```","I want to add a use case for programmatically skipping tests:\r\nOur product runs on multiple platforms & uses the same Jest tests for each platform.  Sometimes a platform implementation is not yet complete, the product will report this dynamically via API (but only after setup in beforeAll()).\r\nOur tests also use snapshot matching.  What happens is, if a platform doesn't support a feature and the test bails out, Jest will complain about the unused snapshot, resulting in a test failure.\r\nOur current workaround is to use 'inline snapshots', but this is exceedingly cumbersome.\r\nA programmatic skip() API would allow our tests to skip when a feature is not available on a certain platform, and also avoid having the Jest engine complain about unused snapshots.","I created a proof of concept PR (#9944) that demonstrates how easy this is to implement in jest-circus. I think it is well worth adding this functionality to jest-circus as it allows to implement custom bailing behaviors (#6527) or stepped tests (#8387) in user land easily.","I found this issue because I'm writing a series of integration tests; I'd like to write my tests so that they can run against any deployment of the API, but only run certain tests if that deployment has a feature flag enabled, e.g.:\r\n\r\n**Works**\r\n```ts\r\ndescribe('feature available in some deployments but not others', () => {\r\n  const enabled = getFeatureFlag();\r\n  (enabled ? it : it.skip)('runs a test that is only sometimes applicable', () => { \/* ... *\/ });\r\n});\r\n```\r\n\r\n**Does not**\r\n```ts\r\ndescribe('feature available in some deployments but not others', async () => {\r\n  const enabled = await getFeatureFlag();\r\n  (enabled ? it : it.skip)('runs a test that is only sometimes applicable', () => { \/* ... *\/ });\r\n});\r\n```\r\n\r\nAn async describe, async setupFilesAfterEnv or a `jest.skip()` method I can call in the context of a test or before method would all work. In the meantime this sort of workaround feels doable, but ugly, because it leaves the developer wondering whether the test was run or not.\r\n\r\n```ts\r\ndescribe('feature available in some deployments but not others', () => {\r\n  it('runs a test that is only sometimes applicable', async () => {\r\n    const enabled = await getFeatureFlag();\r\n    if (!enabled) { return; }\r\n  });\r\n});\r\n```\r\n","I'd like to add another concrete use-case for the asynchronous, skip-from-within-a-test feature:\r\n\r\nI've created a package for use with Jest and Mocha that lets you create a sequence of tests which are dependent on each other. For example:\r\n\r\n```javascript\r\nlet { auth, createPost, createComment, getComments, logOut } = require(\"..\/examples\/TestApp\");\r\nlet { chainedTest } = require(\"@art-suite\/chained-test\");\r\n\r\n\/\/ NOTE: This file INTENTIONALLY fails in Mocha to demonstrate how failures are handled.\r\n\r\nconst aliceEmail = \"alice@test.com\";\r\nconst postBody = \"The quick brown fox jumped over the lazy dog.\";\r\nconst commentBody = \"Brilliant!\";\r\n\r\n\/\/ The return-result of this first test will be passed as the second argument\r\n\/\/ to all subsequent tests in the chain.\r\nchainedTest(\"Alice's user story\", () => auth(aliceEmail))\r\n\r\n\/\/ In \"then\" tests, the test's return value is passed to the next test.\r\n\/\/ skipped: if neither this nor any dependent tests are selected by test framework\r\n.thenIt(\"lets Alice create a post\", () =>\r\n  createPost(postBody)\r\n)\r\n\r\n.softTapIt(\"softTapIt failures don't skip following tests\", () => {\r\n  throw new Error(\"fake-failure in softTapIt\");\r\n})\r\n\r\n\/\/ \"tap\" tests: ignores the test's return value. Instead it passes lastTestValue through.\r\n\/\/ skipped: if neither this nor any dependent tests are selected by test framework\r\n.tapIt(\"lets Alice create a comment\", (post, alice) =>\r\n  createComment(post.id, commentBody)\r\n)\r\n\r\n.tapIt(\"tapIt or thenIt failures WILL skip remaining tests\", () => {\r\n  throw new Error(\"fake-failure in tapIt\");\r\n})\r\n\r\n.thenIt(\"can get the created comment from the post\", (post, alice) =>\r\n  getComments(post.id)\r\n)\r\n\r\n\/\/ In \"softTap\" tests, the test's return value is ignored.\r\n\/\/ Instead it passes lastTestValue through to the next test.\r\n\/\/ skipped: if not selected by test framework\r\n.softTapIt(\"should have only one comment by Alice\", (comments, alice) => {\r\n  expect(comments.length).toEqual(1);\r\n  expect(comments[0].userId).toEqual(alice.id);\r\n})\r\n\r\n.tapIt(\"should be able to logOut\", logOut)\r\n```\r\n\r\nIf one of these tests fail, the rest cannot succeed. Logically, they need to be skipped. However, we don't want to report them as \"passed\" since they were never run. Likewise, we don't want to report them as \"failed\" since they didn't actually fail.\r\n\r\nWhat we need is a 3rd option - report the test as \"skipped\" (or \"pending\" as Mocha does). Note that the first failure *will be reported* as a failure, so tests will properly fail and CI\/CD will fail. However, without \"skip\" there is no correct way to report what happened in Jest. i.e. There is no correct way to report the rest of the tests were not run.\r\n\r\nIn Mocha this works beautifully:\r\n\r\n```\r\n\u2713 Alice's user story\r\n\u2713 needs to create a post\r\n1) softTapIt failures don't skip following tests\r\n\u2713 lets Alice create a comment\r\n2) tapIt or thenIt failures WILL skip remaining tests\r\n- can get the created comment from the post\r\n- should have only one comment by Alice\r\n- should be able to logOut\r\n\r\n3 passing (11ms)\r\n3 pending\r\n2 failing\r\n\r\n1) softTapIt failures don't skip following tests:\r\n    Error: fake-failure in softTapIt\r\n    at ChainedTest.test (test\/api.js:23:11)\r\n\r\n2) tapIt or thenIt failures WILL skip remaining tests:\r\n    Error: fake-failure in tapIt\r\n    at ChainedTest.test (test\/api.js:33:11)\r\n```\r\n\r\nThank you @wolever for championing this feature-request. It's important, and I hope it makes it into Jest soon. Cheers! \r\n\r\n<edit: grammar>","I think the chances of this ever being added to jest are extremely low. I've had a PR out for months now and we haven't even gotten any feedback on this from jest maintainers. If you need this I'd suggest you look for jest alternatives. ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","I believe this is still a desired feature. Commenting to keep it open.","Another thing that I want to add to the conversation here, particularly in relation to the related request of `test.step` (and hopefully `test.optional` or `test.step.optional`) [#8387](https:\/\/github.com\/facebook\/jest\/issues\/8387), is that a use case for being able to skip from within a test that I have encountered a lot is: handling more complicated versions of steps that need more ad hoc logic. For example:\r\n\r\n```typescript\r\nconst thingsToCreate = [ ... ]\r\nconst createdThings = []\r\n\r\ntest.each(thingsToCreate)('create %s', async (thing) => {\r\n  await createThing(thing) \/\/ Might throw error\r\n  createdThings.push(thing)\r\n  ...\r\n})\r\n\r\ntest('process one thing', async () => {\r\n  if (createdThings.length < 1) {\r\n    skip() \/\/ We can't run this test\r\n  }\r\n  await processOneThing(createdThings[0])\r\n  ...\r\n})\r\n\r\ntest('process two things', async () => {\r\n  if (createdThings.length < 2) {\r\n    skip() \/\/ We can't run this test\r\n  }\r\n  await processTwoThings(createdThings[0], createdThings[1])\r\n  ...\r\n})\r\n\r\ntest('process three things', async () => {\r\n  if (createdThings.length < 3) {\r\n    skip() \/\/ We can't run this test\r\n  }\r\n  await processThreeThings(createdThings[0], createdThings[1], createdThings[2])\r\n  ...\r\n})\r\n```\r\n\r\nAnd of course, this is just one example. There are plenty of cases where you might have a test that needs some combination of previous tests to have succeeded to varying degrees in order for that test to be relevant. While `test.step` would handle simple cases of this, it would be difficult, and in many cases, slow, to make it work in all the different variations that come up regularly.\r\n\r\nOf course, as has already been discussed, you can always just pass or fail instead of skip, but failures clutter the results making it harder to see the actual problem that needs to be resolved, and passing gives the false impression of success.","Hey, jest maintainers! Any updates or feedback?","@palmerj3 @mattphillips Any chance it can be progressed? Especially since there's POC MR, which kind of really works.\r\n\r\nPersonally also used that behaviour a lot in mocha - to match test with conditions (multiple complex tests, multiple versions of code to be tested, not every test is viable for every version)\r\n","This should be an useful feature, specially for using Jest on integration tests, but after I read the comments of Jest contributors, I'm not confident this will move forward. As Node recently is putting some effort in providing its own built-in testing framework ([node:test](https:\/\/nodejs.org\/api\/test.html)), I most likely won't use nor recommend Jest for new backend projects. ","@gerardolima Jest has never been a good choice for backend projects. One could argue that Jest has always been the worst choice available for backend projects.\r\n\r\n","Btw you can use the undocumented Jest feature `pending` if you want to skip tests based on run-time information. It is not documented though, so who knows what's happening with it in the future:\r\n\r\n```ts\r\nlet a: string | undefined = undefined;\r\nit(\"test1\", async () => {\r\n  a = await myRequest();\r\n  expect(a).toEqual(\"myString\");\r\n});\r\n\r\nit(\"test2\", () => {\r\n  if (typeof a !== \"string\") return pending(\"Skipping test\");\r\n  expect(a.length).toBe(55);\r\n});\r\n```\r\n\r\n(I know that you don't write tests like this, but there are enough examples in this thread already)"],"labels":[":rocket: Feature Request"]},{"title":"Code Coverage doesn't fail with 0% cover.","body":"\r\n## \ud83d\udc1b Bug Report\r\n\r\nRunning JEST with code coverage enabled does not fail if the code coverage is 0%\r\n\r\n![Image showing code cover running](https:\/\/i.ibb.co\/602QBL3\/temp.png \"Image showing code cover running\")\r\n\r\n## To Reproduce\r\n\r\nEnable JEST with the following configuration file\r\n\r\n\"jest\": {\r\n    \"collectCoverage\": true,\r\n    \"coverageDirectory\": \"..\/coverage\",\r\n    \"testPathIgnorePatterns\": [\r\n      \"\/node_modules\/\"\r\n    ],\r\n    \"verbose\": true,\r\n    \"coverageThreshold\": {\r\n      \"global\": {\r\n        \"branches\": 50,\r\n        \"functions\": 50,\r\n        \"lines\": 50,\r\n        \"statements\": 50\r\n      }\r\n    }\r\n  },\r\n\r\nThen call your JEST script.\r\n\r\n## Expected behavior\r\n\r\nJEST should fail with exit code 1 as the coverage limits are set to 50% and the test returned 0%.\r\n\r\n","comments":["Please provide a repro somebody can download and triage.","Dear Michal,\n\nThe bug template says providing a repro is optional (not required).\n\nThis can be reproduced using ANY vanilla install of NodeJS with the\nattacked package.json file provided.\n\nRegards,\n\n*Nathan Parrott*\nMBA, BEng Mechatronics\n\nwww.nathanparrott.com\n+61 408 263 865\n\n\nOn Thu, 13 Jun 2019 at 10:59, Micha\u0142 Pierzcha\u0142a <notifications@github.com>\nwrote:\n\n> Please provide a repro somebody can download and triage.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/8562?email_source=notifications&email_token=ABGTWCEXAL47RPDULAS6QVLP2J4FNA5CNFSM4HX37ZK2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXULE4Q#issuecomment-501789298>,\n> or mute the thread\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/ABGTWCHTI36BSCEIICSE4ILP2J4FNANCNFSM4HX37ZKQ>\n> .\n>\n","It's optional, that's why I'm not closing this issue :) (however I could do it, because you removed quite some important information, like which version of Jest you use, which Node, which OS). But it will make it easier for us to triage this. \r\n\r\nFor example, without a repro project, there's like 1% chances I'm gonna look at it. It's dramatically higher with a repro. Your choice! \ud83d\ude42 ","Fair enough:\r\n\r\nJest Version: 24.8.0 (latest)\r\nOS: Confirmed to fail on windows, Mac & Linux\r\nNode :10.15.3\r\n\r\n\r\n","Hello. I am also having an issue. Here is a repro: https:\/\/github.com\/stonefruit\/repro-jest-coverage.\r\n```\r\nnpx create-react-app repro-jest-coverage\r\n\r\ncd repro-jest-coverage\r\n\r\nnpm test -- --coverage\r\n```\r\nThe above is used to create the repro. The coverage shown 'All files' with all 0s as described by @n8ores. \r\n```\r\nnpm test -- --coverage\r\n\r\n PASS  src\/App.test.js\r\n  \u2713 renders without crashing (22ms)\r\n\r\n----------|----------|----------|----------|----------|-------------------|\r\nFile      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n----------|----------|----------|----------|----------|-------------------|\r\nAll files |        0 |        0 |        0 |        0 |                   |\r\n----------|----------|----------|----------|----------|-------------------|\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        2.078s\r\nRan all test suites.\r\n```\r\nWhile the `--watchAll` flag shows the files.\r\n```\r\nnpm test -- --coverage --watchAll\r\n\r\n PASS  src\/App.test.js\r\n  \u2713 renders without crashing (23ms)\r\n\r\n------------------|----------|----------|----------|----------|-------------------|\r\nFile              |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n------------------|----------|----------|----------|----------|-------------------|\r\nAll files         |     2.44 |        0 |     6.25 |     2.44 |                   |\r\n App.js           |      100 |      100 |      100 |      100 |                   |\r\n index.js         |        0 |      100 |      100 |        0 |              7,12 |\r\n serviceWorker.js |        0 |        0 |        0 |        0 |... 23,130,131,132 |\r\n------------------|----------|----------|----------|----------|-------------------|\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        2.562s\r\nRan all test suites.\r\n```\r\nSince there is a test for App.test.js, I think we should be expecting something that looks like (not accurate):\r\n```\r\n------------------|----------|----------|----------|----------|-------------------|\r\nFile              |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n------------------|----------|----------|----------|----------|-------------------|\r\nAll files         |     2.44 |        0 |     6.25 |     2.44 |                   |\r\n App.js           |      100 |      100 |      100 |      100 |                   |\r\n------------------|----------|----------|----------|----------|-------------------|\r\n```","Any update on this issue?\r\n","I'm having the same issue here.\r\n\r\n- `\"jest\": \"^24.9.0\"`\r\n- `MBP 10.14.6`\r\n- `Nodejs 12.13.0`\r\n\r\njest settings inside `package.json`\r\n```json\r\n  \"scripts\": {\r\n    \"test\": \"jest\",\r\n    \"test:watch\": \"npm run test -- --watch\",\r\n    \"test:coverage\": \"npm run test -- --coverage --coverageDirectory=.jest\",\r\n    \"generate:docs\": \"jsdoc -c .\/jsdoc.conf.json\"\r\n  }\r\n\r\n...\r\n\r\n  \"jest\": {\r\n    \"rootDir\": \".\/\",\r\n    \"verbose\": true,\r\n    \"collectCoverageFrom\": [\r\n      \"**\/*.{js}\",\r\n      \"!**\/node_modules\/**\",\r\n      \"!**\/tools\/**\",\r\n      \"!**\/build\/**\",\r\n      \"!**\/docs\/**\"\r\n    ],\r\n    \"coverageThreshold\": {\r\n      \"global\": {\r\n        \"statements\": 100,\r\n        \"branches\": 100,\r\n        \"functions\": 100,\r\n        \"lines\": 100\r\n      }\r\n    }\r\n  },\r\n```\r\noutcome\r\n```\r\n----------|----------|----------|----------|----------|-------------------|\r\nFile      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n----------|----------|----------|----------|----------|-------------------|\r\nAll files |        0 |        0 |        0 |        0 |                   |\r\n----------|----------|----------|----------|----------|-------------------|\r\nTest Suites: 13 passed, 13 total\r\nTests:       66 passed, 66 total\r\nSnapshots:   0 total\r\nTime:        1.525s\r\nRan all test suites.\r\n```","> I'm having the same issue here.\r\n> \r\n> * `\"jest\": \"^24.9.0\"`\r\n> * `MBP 10.14.6`\r\n> * `Nodejs 12.13.0`\r\n> \r\n> jest settings inside `package.json`\r\n> \r\n> ```json\r\n>   \"scripts\": {\r\n>     \"test\": \"jest\",\r\n>     \"test:watch\": \"npm run test -- --watch\",\r\n>     \"test:coverage\": \"npm run test -- --coverage --coverageDirectory=.jest\",\r\n>     \"generate:docs\": \"jsdoc -c .\/jsdoc.conf.json\"\r\n>   }\r\n> \r\n> ...\r\n> \r\n>   \"jest\": {\r\n>     \"rootDir\": \".\/\",\r\n>     \"verbose\": true,\r\n>     \"collectCoverageFrom\": [\r\n>       \"**\/*.{js}\",\r\n>       \"!**\/node_modules\/**\",\r\n>       \"!**\/tools\/**\",\r\n>       \"!**\/build\/**\",\r\n>       \"!**\/docs\/**\"\r\n>     ],\r\n>     \"coverageThreshold\": {\r\n>       \"global\": {\r\n>         \"statements\": 100,\r\n>         \"branches\": 100,\r\n>         \"functions\": 100,\r\n>         \"lines\": 100\r\n>       }\r\n>     }\r\n>   },\r\n> ```\r\n> \r\n> outcome\r\n> \r\n> ```\r\n> ----------|----------|----------|----------|----------|-------------------|\r\n> File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n> ----------|----------|----------|----------|----------|-------------------|\r\n> All files |        0 |        0 |        0 |        0 |                   |\r\n> ----------|----------|----------|----------|----------|-------------------|\r\n> Test Suites: 13 passed, 13 total\r\n> Tests:       66 passed, 66 total\r\n> Snapshots:   0 total\r\n> Time:        1.525s\r\n> Ran all test suites.\r\n> ```\r\n\r\nI found the solution to the problem. In the `\"jest\": ...` part within `package.json` substitute the `.\/` root for `<rootDir>`.\r\n\r\n```\r\n  \"jest\": {\r\n    \"collectCoverageFrom\": [\r\n\r\n      \"<rootDir>\/test\/**\/*.js\"\r\n\r\n    ],\r\n    \"coveragePathIgnorePatterns\": [\r\n      \"<rootDir>\/node_modules\/\",\r\n      \"<rootDir>\/tools\/\",\r\n      \"<rootDir>\/build\/\",\r\n      \"<rootDir>\/docs\/\"\r\n    ]\r\n```","@diazgilberto that did not work for me unfortunately.","> @diazgilberto that did not work for me unfortunately.\r\n\r\n@cansin do you have your jest settings inside `package.json`?","Yes, I realized doing `jest --coverage` works, versus having `collectCoverage: true` inside `jest.config.js` does not.","> Yes, I realized doing `jest --coverage` works, versus having `collectCoverage: true` inside `jest.config.js` does not.\r\n\r\nInteresting is that even though I have all `jest` configuration inside `package.json` I still need an empty `jest.config.js` file in project root. If I remove that file, code coverage reports 0 again.\r\n\r\nNow I'm having a different issue where coverage is reporting wrong `%` stating that I'm missing to test a particular line of code.\r\n\r\nThis is the code that is reporting wrong coverage\r\n```\r\nif (value.length === 0 && defaultValue !== undefined) {\r\n  console.log('VALUE: ', value, ' DEFAULT: ', defaultValue)\r\n  return defaultValue\r\n}\r\n```\r\n`console.log()` inside the function that clearly shows that the function is getting tested.\r\n```\r\n  console.log lib\/validation\/validateString.js:38\r\n    VALUE:    DEFAULT:  test\r\n\r\n-------------------|----------|----------|----------|----------|-------------------|\r\nFile               |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n-------------------|----------|----------|----------|----------|-------------------|\r\nAll files          |      100 |    91.67 |      100 |      100 |                   |\r\n validateString.js |      100 |    91.67 |      100 |      100 |                37 |\r\n-------------------|----------|----------|----------|----------|-------------------|\r\nTest Suites: 1 passed, 1 total\r\nTests:       7 passed, 7 total\r\nSnapshots:   0 total\r\nTime:        0.791s, estimated 2s\r\nRan all test suites matching \/validateString\/i.\r\n```","Watch out for this warning:\r\n```\r\nts-jest[versions] (WARN) Version 24.9.0 of jest installed has not been tested with ts-jest. If you're experiencing issues, consider using a supported version (>=22.0.0 <24.0.0). Please do not report issues in ts-jest if you are using unsupported versions.\r\n```\r\n\r\nDowngrading jest fixed the bug for me without changing the command. I also did not add the `--watchAll` flag.","Hi, We can follow the below jest configuration...\r\n\r\n\"jest\": {\r\n    \"moduleFileExtensions\": [\r\n      \"js\",\r\n      \"json\",\r\n      \"ts\"\r\n    ],\r\n    \"rootDir\": \".\",\r\n    \"testRegex\": \".spec.ts$\",\r\n    \"transform\": {\r\n      \"^.+\\\\.(t|j)s$\": \"ts-jest\"\r\n    },\r\n    \"coverageDirectory\": \".\/coverage\",\r\n    \"testEnvironment\": \"node\",\r\n    \"collectCoverage\": true,\r\n    \"verbose\": true\r\n  }","> I'm having the same issue here.\r\n> \r\n> * `\"jest\": \"^24.9.0\"`\r\n> * `MBP 10.14.6`\r\n> * `Nodejs 12.13.0`\r\n> \r\n> jest settings inside `package.json`\r\n> \r\n> ```json\r\n>   \"scripts\": {\r\n>     \"test\": \"jest\",\r\n>     \"test:watch\": \"npm run test -- --watch\",\r\n>     \"test:coverage\": \"npm run test -- --coverage --coverageDirectory=.jest\",\r\n>     \"generate:docs\": \"jsdoc -c .\/jsdoc.conf.json\"\r\n>   }\r\n> \r\n> ...\r\n> \r\n>   \"jest\": {\r\n>     \"rootDir\": \".\/\",\r\n>     \"verbose\": true,\r\n>     \"collectCoverageFrom\": [\r\n>       \"**\/*.{js}\",\r\n>       \"!**\/node_modules\/**\",\r\n>       \"!**\/tools\/**\",\r\n>       \"!**\/build\/**\",\r\n>       \"!**\/docs\/**\"\r\n>     ],\r\n>     \"coverageThreshold\": {\r\n>       \"global\": {\r\n>         \"statements\": 100,\r\n>         \"branches\": 100,\r\n>         \"functions\": 100,\r\n>         \"lines\": 100\r\n>       }\r\n>     }\r\n>   },\r\n> ```\r\n> \r\n> outcome\r\n> \r\n> ```\r\n> ----------|----------|----------|----------|----------|-------------------|\r\n> File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n> ----------|----------|----------|----------|----------|-------------------|\r\n> All files |        0 |        0 |        0 |        0 |                   |\r\n> ----------|----------|----------|----------|----------|-------------------|\r\n> Test Suites: 13 passed, 13 total\r\n> Tests:       66 passed, 66 total\r\n> Snapshots:   0 total\r\n> Time:        1.525s\r\n> Ran all test suites.\r\n> ```\r\n\r\nI also had the similar issue before. My jest and ts-jest versions are:\r\n    \"ts-jest\": \"^26.3.0\",\r\n    \"jest\": \"^26.4.2\",\r\n\r\nHere is my solution:\r\n>     \"collectCoverageFrom\": [\r\n>       \"**\/*.{js}\", -> \"**\/*.js\"\r\n\r\nthis will show correct coverage.\r\n\r\nHope this helps.","I also had the 0% coverage problem when running jest with the [--config=<path> option](https:\/\/jestjs.io\/docs\/cli#--configpath). The problem was that jest assumes the `configPath` to be the root directory and thus doesn't find any files to check the coverage for.\r\n\r\nMy solution was simply to go higher in the directory tree:\r\n```json\r\n{\r\n  \"rootDir\": \"..\/.\",\r\n  ...\r\n}\r\n```","What is the final solution for this issue? My app provides a 0% coverage: https:\/\/github.com\/web-needle\/sappio","Not sure if this is separate issue or same issue:\r\n\r\n**Steps:**\r\n\r\n1. Have a file ( `http-error.ts` ) not covered by tests on main branch\r\n2. Change it and create new branch\r\n3. Run tests\r\n\r\nwith parameter: `--changedSince=main`\r\nwith config which forces scanning all files:\r\n```\r\n collectCoverageFrom: [\r\n        \"<rootDir>\/**\/*.js\",\r\n        \"<rootDir>\/**\/*.ts\",\r\n        \"<rootDir>\/**\/*.cjs\",\r\n    ],\r\n```\r\n**Result:**\r\n\r\nTests are not run and changed file will not be listed and jest will not fail: \r\n\r\n**Output**\r\n```\r\nNo tests found related to files changed since \"main\".\r\nRun Jest without `-o` or with `--all` to run all tests.\r\n----------|---------|----------|---------|---------|-------------------\r\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \r\n----------|---------|----------|---------|---------|-------------------\r\nAll files |       0 |        0 |       0 |       0 |                   \r\n----------|---------|----------|---------|---------|-------------------\r\n```\r\n\r\n**Recovery step:**\r\n\r\nChange any other file covered by tests. This will trigger test run -> proper report, including files with 0 coverage:\r\n\r\n```\r\n--------------------------------|---------|----------|---------|---------|-------------------\r\nFile                            | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \r\n--------------------------------|---------|----------|---------|---------|-------------------\r\nAll files                       |   45.45 |       50 |      50 |   45.45 |                   \r\n common                         |       0 |      100 |       0 |       0 |                   \r\n  http-error.ts                 |       0 |      100 |       0 |       0 | 5-14              \r\n converter\/html |     100 |       50 |     100 |     100 |                   \r\n  include.ts               |     100 |       50 |     100 |     100 | 6                 \r\n--------------------------------|---------|----------|---------|---------|-------------------\r\n```\r\n","> ## \ud83d\udc1b Bug Report\r\n> Running JEST with code coverage enabled does not fail if the code coverage is 0%\r\n> \r\n> ![Image showing code cover running](https:\/\/camo.githubusercontent.com\/026fbe59acc911a28277630ceea98d2d58000c37046045d7b5ce3abbb49245b4\/68747470733a2f2f692e6962622e636f2f36303251424c332f74656d702e706e67)\r\n> \r\n> ## To Reproduce\r\n> Enable JEST with the following configuration file\r\n> \r\n> \"jest\": { \"collectCoverage\": true, \"coverageDirectory\": \"..\/coverage\", \"testPathIgnorePatterns\": [ \"\/node_modules\/\" ], \"verbose\": true, \"coverageThreshold\": { \"global\": { \"branches\": 50, \"functions\": 50, \"lines\": 50, \"statements\": 50 } } },\r\n> \r\n> Then call your JEST script.\r\n> \r\n> ## Expected behavior\r\n> JEST should fail with exit code 1 as the coverage limits are set to 50% and the test returned 0%.\r\n\r\nStill having this problem on Jest 29.6.1","@reno Suggestion: Try:\r\n\r\n1. Removing tests and see if it is some syntax issue;\r\n2. Using configuration of a functioning app (examples: [sappio](https:\/\/github.com\/trouchet\/sappio), [prego](https:\/\/github.com\/quivero\/prego))\r\n\r\n","I'm having this same issue with:\r\n- Jest 29.7.0\r\n- Unbuntu 22.04.4\r\n\r\nWhen running: `jest --coverage --coverageThreshold='{\"global\":{\"statements\":\"70\"}}' --changedSince origin\/master` I get the same:\r\n```\r\nNo tests found related to files changed since \"origin\/master\".\r\nRun Jest without `-o` or with `--all` to run all tests.\r\n----------|---------|----------|---------|---------|-------------------\r\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \r\n----------|---------|----------|---------|---------|-------------------\r\nAll files |       0 |        0 |       0 |       0 |                   \r\n----------|---------|----------|---------|---------|-------------------\r\n```\r\nIn the commits that I made in my branch, I specifically modified .js files that don't have any tests. I should be able to somehow ask it to fail when 'No Tests are found'. Especially because I want this to fail in a GitHub Action to not let developers get a free pass on not writting any tests.\r\n\r\nThanks,\r\nC"],"labels":["Needs Triage","Bug Report"]},{"title":"\"Received: serializes to the same string\" on object equality checking","body":"## \ud83d\udc1b Bug Report\r\n\r\nUsing `.toMatchObject()` returns failing test with message `    Received: serializes to the same string`\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/4678102\/58015463-e78c7f00-7b2d-11e9-9f4e-038625c0c623.png)\r\n\r\n## To Reproduce\r\n\r\nI am trying to check the `users` object I receive against my `expectedUsers`. The received object coming back from MongoDB contains the fields `\"__v\"` and `\"_id\"` which I do not want to check for (they always change for every test). As such, I am using `.toMatchObject()` and cannot use something else like `.toEqual()`. My test snippet is below:\r\n\r\n```\r\ntest(\"should show all existing users\", async () => {\r\n  const expectedUsers = [\r\n    {\r\n      email: \"andy@example.com\",\r\n      friends: [],\r\n      followers: [],\r\n      following: [],\r\n      blocked: []\r\n    },\r\n    {\r\n      email: \"john@example.com\",\r\n      friends: [\"andy@example.com\", \"mary@example.com\"],\r\n      followers: [],\r\n      following: [],\r\n      blocked: []\r\n    },\r\n    {\r\n      email: \"mary@example.com\",\r\n      friends: [],\r\n      followers: [],\r\n      following: [],\r\n      blocked: [\"john@example.com\"]\r\n    }\r\n  ];\r\n  await request(app)\r\n    .get(route(path))\r\n    .expect(\"Content-Type\", \/json\/)\r\n    .expect(200);\r\n\r\n  const users = await User.find();\r\n\r\n  expect(users).toMatchObject(expectedUsers);\r\n});\r\n```\r\n(`request` is made with `supertest`)\r\n\r\n## Expected behavior\r\n\r\nAs documented [here](https:\/\/jestjs.io\/docs\/en\/expect.html#tomatchobjectobject),\r\n\r\n> Use .toMatchObject to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are not in the expected object.\r\n\r\nSince the `expected` objects is a subset of `received` objects, I expect my test to pass.\r\n\r\n\r\n## `npx envinfo --preset jest` result\r\n\r\n```bash\r\nSystem:\r\n  OS: macOS 10.14.4\r\n  CPU: (12) x64 Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz\r\nBinaries:\r\n  Node: 10.15.2 - ~\/.asdf\/shims\/node\r\n  npm: 6.9.0 - ~\/.asdf\/shims\/npm\r\nnpmPackages:\r\n  jest: ^24.8.0 => 24.8.0 \r\n```\r\n","comments":["cc @pedrottimark ","@sabriele Yes, your choice of `toMatchObject` makes sense. So we can trouble shoot:\r\n\r\n* Can you please paste the output from `console.log(users)`\r\n* Does the application use `mongoose`","@sabriele From reading Jest code and guessing about MongoDB, `users` array might have non-index properties which `toMatchObject` should (but does not) ignore.\r\n\r\nHere is a work-around to get rid of them:\r\n\r\n```js\r\nexpect([...users]).toMatchObject(expectedUsers)\r\n```\r\n\r\nIf you can paste the received `users` before work-around, we can make a realistic regression test.","I have the same issue. Here is the test for a react custom hook:\r\n\r\n```js\r\nimport {renderHook} from 'react-hooks-testing-library'\r\n\r\nimport useTheme, {DEFAULT_THEME} from 'components\/globalStyle\/useTheme'\r\n\r\nit('should set the global theme', () => {\r\n  const setTheme = () => {}\r\n  const expected = {...DEFAULT_THEME, setTheme}\r\n  const {result} = renderHook(useTheme)\r\n\r\n  expect(result.current).toMatchObject(expected)\r\n})\r\n```\r\n\r\nThis test returns the following error:\r\n\r\n```\r\nError: expect(received).toMatchObject(expected)\r\n\r\nExpected: {\"palette\": \"dark\", \"setTheme\": [Function setTheme], \"textSize\": \"normal\"}\r\nReceived: serializes to the same string\r\n```\r\n\r\nI tried the shallow copy trick that @pedrottimark suggested but it didn't work (same error). However, the following seems to work just fine:\r\n\r\n```js\r\nimport {renderHook} from 'react-hooks-testing-library'\r\n\r\nimport useTheme, {DEFAULT_THEME} from 'components\/globalStyle\/useTheme'\r\n\r\nit('should set the global theme', () => {\r\n  const Mock = jest.fn()\r\n  const setTheme = new Mock()\r\n  const {result} = renderHook(useTheme)\r\n  const expected = {...DEFAULT_THEME, setTheme}\r\n\r\n  expect(result.current).toMatchObject(expected)\r\n})\r\n```\r\n\r\nSetting `const setTheme = jest.fn()` didn't work \ud83e\udd37\u200d\u2642\ufe0f\r\n\r\n```diff\r\nError: expect(received).toMatchObject(expected)\r\n\r\n- Expected\r\n+ Received\r\n\r\n  Object {\r\n    \"palette\": \"dark\",\r\n-   \"setTheme\": [Function mockConstructor],\r\n+   \"setTheme\": [Function setTheme],\r\n    \"textSize\": \"normal\",\r\n  }\r\n```","@matchatype If the problem in your https:\/\/github.com\/facebook\/jest\/issues\/8475#issuecomment-495943549 is like #8166 that deep-equality matchers compare functions according to referential identity, then we recommend asymmetric matcher as expected value, see https:\/\/jestjs.io\/docs\/en\/expect#expectanyconstructor\r\n\r\n```js\r\nit('should set the global theme', () => {\r\n  const setTheme = expect.any(Function)\r\n  const expected = {...DEFAULT_THEME, setTheme}\r\n  const {result} = renderHook(useTheme)\r\n\r\n  expect(result.current).toMatchObject(expected)\r\n})\r\n```","That does indeed work! However, I'm still confused: all examples should result in the same behavior. Instead, each triggers a completely different response:\r\n\r\n- Received: serializes to the same string;\r\n- Test passing;\r\n- Error: expect(received).toMatchObject(expected).","The recent change to display `serializes to the same string` makes more obvious when there are inconsistencies between the comparison in the matcher and the feedback in the report.\r\n\r\n@matchatype In the case that you describe:\r\n\r\n* comparison is correct (although unexpected) that `() => {}` or `jest.fn()` as expected value are **not** referentially equal to (that is, not the same **instance** as) the function returned by the hook\r\n* report is confusing because unequal values can have the same serialization\r\n\r\nDeep-equality matchers compare **different instances** of functions:\r\n\r\n*  like symbols `Symbol()` is **not** equal to `Symbol()`\r\n* unlike arrays or objects: `[0]` is equal to `[0]` or `{key: 'value'}` is equal to `{key: 'value'}`\r\n\r\nIf you think of the returned data structure as a tree, there is a difference between asserting a primitive value as a leaf, and asserting a function or symbol (when the caller does not provide it as an argument).\r\n\r\nI am not sure why the work-around that you found solves the problem :)\r\n\r\nA long-term goal for Jest is to bridge gaps like this between the comparison and the report.","`serializes to the same string` is symptom of a different problem in the original https:\/\/github.com\/facebook\/jest\/issues\/8475#issue-446046819\r\n\r\n1. comparison is incorrect: `toMatchObject` matcher compares non-index properties (that is, symbols or non-numeric strings) of arrays same as `toEqual` matcher, instead of being able to ignore properties according to expected subset\r\n2. `getObjectSubset` helper ignores non-index properties in received value for report, even if they were in the expected subset\r\n3. `pretty-format` package ignores non-index properties, even if `getObjectSubset` included them\r\n\r\nThe difficulty to solve those problems: is 2. medium, 1. difficult, 3. breaking","Extremely helpful @pedrottimark Many thanks \ud83d\ude4fYes, the fact that work-around actually passed totally baffled me.","I have the same problem, for me the problem comes from the **function** I have in the object. \r\nThe solution for me is to mock function by ```jest.fn()``` and put it to input props and expected object.\r\n\r\n**toEqual** in jest can compare two object, it is cool (in js we can't compare directly by '=='), but if the object contains an function (like () => {}), it will have problem to compare.","Hi @pedrottimark, I apologise for the tardy reply; this was a weekend project and I simply got swamped with work.\r\n\r\nYes, I am using mongoose; I did a diff on the result of `console.log(users)` and `console.log([...users])` and they are exactly the same: \r\n\r\n```\r\n[ { friends: [],\r\n    followers: [],\r\n    following: [],\r\n    blocked: [],\r\n    _id: 5cfbb57e37912c8ff6d2f8b1,\r\n    email: 'andy@example.com',\r\n    __v: 0 },\r\n  { friends:\r\n      [ 'andy@example.com', 'mary@example.com' ],\r\n    followers: [],\r\n    following: [],\r\n    blocked: [],\r\n    _id: 5cfbb57e37912c8ff6d2f8b2,\r\n    email: 'john@example.com',\r\n    __v: 0 },\r\n  { friends: [],\r\n    followers: [],\r\n    following: [],\r\n    blocked: [ 'john@example.com' ],\r\n    _id: 5cfbb57e37912c8ff6d2f8b3,\r\n    email: 'mary@example.com',\r\n    __v: 0 } ]\r\n```\r\n\r\nJust like @matchatype I too tried the shallow copy trick but it gave me the same error.\r\n\r\nThank you for trying to help me troubleshoot this! I really appreciate it.","@sabriele Thank you for the output. When I copy and paste into a local test file, there is syntax error for values of `_id` properties like `5cfbb57e37912c8ff6d2f8b1` instead of `'5cfbb57e37912c8ff6d2f8b1'`\r\n\r\nThat confirms mongoose provides some methods on `user` object instances.\r\n\r\nEDIT: That is, a method that somehow \u201cimproved\u201d the default output from `console.log`\r\n\r\nIf shallow copy of the array did not help, then the next step is something like:\r\n\r\n```js\r\nexpect(users.map(user => user.toObject())).toMatchObject(expectedUsers);\r\n```\r\n\r\nSee https:\/\/mongoosejs.com\/docs\/api.html#document_Document-toObject\r\n\r\n> Converts this document into a plain javascript object, ready for storage in MongoDB.\r\n\r\nIf that is a solution, then I will have some follow-up questions to understand what is the problem.","The toObject works for me","@patran So I can understand the problem in `toMatchObject` if your test gets an array of objects from MongoDB with mongoose, can you add `console.log(\u2026)` for original array and first object:\r\n\r\n* `Object.getOwnPropertyDescriptors(array)` copy and then delete array index properties\r\n* `Object.getOwnPropertyDescriptors(array[0])` copy and then delete properties of the data\r\n\r\nPaste the results after editing to delete properties that are not added by mongoose. Thank you!","Have same problem","I have similar problem comparing Buffers.\r\n`expect(a).toEqual(b)` throws \"serializes to the same string\"\r\n`expect(a.equals(b)).toBe(true)` works fine\r\n\r\nI have tried to find any difference between these objects using `Object.getOwnPropertyDescriptors`, but looks like they are the same.","I run into the \"serializes to the same string\" issue when using toMatchObject. The objects had functions defined and was the reason toMatchObject failed. I worked around the issue by mocking them:\r\n\r\n```ts\r\nconst mockFunctions = <T extends Record<string, any>>(obj: T, mock: any): T => {\r\n  const copy = { ...obj };\r\n  Reflect.ownKeys(copy)\r\n    .filter(key => typeof Reflect.get(copy, key) === \"function\")\r\n    .forEach(key => Reflect.set(copy, key, mock));\r\n  return copy;\r\n};\r\n```\r\n\r\nFor toMatchObject to work as expected it was important to use the same jest mock on both objects.\r\n\r\n```ts\r\nconst objectToCompare = (name: string) => {\r\n  const nameAsFunc = (): string => name;\r\n\r\n  return {\r\n    name,\r\n    nameAsFunc\r\n  };\r\n};\r\n\r\ndescribe(\"toMatchObject tests\", () => {\r\n  it(\"can compare objects with functions\", () => {\r\n    const mock = jest.fn();\r\n\r\n    const first = objectToCompare(\"name\");\r\n    const second = objectToCompare(\"name\");\r\n\r\n    \/\/ Gives \"serializes to the same string\"\r\n    expect(first).toMatchObject(second);\r\n\r\n    \/\/ Works\r\n    expect(mockFunctions(first, mock)).toMatchObject(mockFunctions(second, mock));\r\n  });\r\n});\r\n```","> @matchatype If the problem in your [#8475 (comment)](https:\/\/github.com\/facebook\/jest\/issues\/8475#issuecomment-495943549) is like #8166 that deep-equality matchers compare functions according to referential identity, then we recommend asymmetric matcher as expected value, see https:\/\/jestjs.io\/docs\/en\/expect#expectanyconstructor\r\n> \r\n> ```js\r\n> it('should set the global theme', () => {\r\n>   const setTheme = expect.any(Function)\r\n>   const expected = {...DEFAULT_THEME, setTheme}\r\n>   const {result} = renderHook(useTheme)\r\n> \r\n>   expect(result.current).toMatchObject(expected)\r\n> })\r\n> ```\r\n\r\nThat worked for me too. Thanks !","I'm also experiencing this issue. This is my workaround:\r\n```js\r\nexpect(JSON.stringify(result.current)).toEqual(JSON.stringify(expected));\r\n```","@manhhailua Thank you so much!  This worked for me after hours of agony.\r\n\r\n> I'm also experiencing this issue. This is my workaround:\r\n> \r\n> ```js\r\n> expect(JSON.stringify(result.current)).toEqual(JSON.stringify(expected));\r\n> ```\r\n\r\n","@pedrottimark Are you guys planning to fix this any time soon? I am also using shallow rendering and experience bad test results. \ud83d\ude15\r\n\r\nHere is my test code:\r\n```\r\nexpect(shallowResult.props.children).toEqual(\r\n            [<Todo todo={fakeTodosData.data[0]} \/>,\r\n            <Todo todo={fakeTodosData.data[1]} \/>]\r\n        );\r\n```\r\n\r\nWhen `shallowResult.props.children` is the correct thing my test outs this:\r\n\r\n```\r\n  Expected: [<Todo todo={{\"description\": \"\", \"id\": 100, \"title\": \"Text!\"}} \/>, <Todo todo={{\"description\": \"More text...\", \"id\": 42, \"title\": \"Other Text\"}} \/>]\r\n    Received: serializes to the same string\r\n```\r\n^ (horrible output and really should be changed)\r\n\r\nWhen I change the matcher to \"toContainEqual\" is outputs this:\r\n\r\n```\r\n  Expected value: [<Todo todo={{\"description\": \"\", \"id\": 100, \"title\": \"Text!\"}} \/>, <Todo todo={{\"description\": \"More text...\", \"id\": 42, \"title\": \"Other Text\"}} \/>]\r\n    Received array: [<Todo todo={{\"description\": \"\", \"id\": 100, \"title\": \"Text!\"}} \/>, <Todo todo={{\"description\": \"More text...\", \"id\": 42, \"title\": \"Other Text\"}} \/>]\r\n```\r\n\r\n(^ a failing test showing that the results are exactly the same. This is **_super confusing_** and it also should really be changed)\r\n\r\nEven using the \"stringify-all-the-things\" hack from @manhhailua does not work for me. It seems that the \"key\" field that is necessary when rendering components in a loop is hidden away in the test output. Here is my stringified test failure:\r\n\r\n```\r\n    Expected: \"[{\\\"key\\\":null,\\\"ref\\\":null,\\\"props\\\":{\\\"todo\\\":{\\\"id\\\":100,\\\"title\\\":\\\"Text!\\\",\\\"description\\\":\\\"\\\"}},\\\"_owner\\\":null,\\\"_store\\\":{}},{\\\"key\\\":null,\\\"ref\\\":null,\\\"props\\\":{\\\"todo\\\":{\\\"id\\\":42,\\\"title\\\":\\\"Other Text\\\",\\\"description\\\":\\\"More text...\\\"}},\\\"_owner\\\":null,\\\"_store\\\":{}}]\"\r\n    Received: \"[{\\\"key\\\":\\\"key0\\\",\\\"ref\\\":null,\\\"props\\\":{\\\"todo\\\":{\\\"id\\\":100,\\\"title\\\":\\\"Text!\\\",\\\"description\\\":\\\"\\\"}},\\\"_owner\\\":null,\\\"_store\\\":{}},{\\\"key\\\":\\\"key1\\\",\\\"ref\\\":null,\\\"props\\\":{\\\"todo\\\":{\\\"id\\\":42,\\\"title\\\":\\\"Other Text\\\",\\\"description\\\":\\\"More text...\\\"}},\\\"_owner\\\":null,\\\"_store\\\":{}}]\"\r\n```\r\n\r\n\r\n@pedrottimark Are you the maintainer of this 'react-test-renderer\/shallow' project? I would very much like this to be fixed, and I have bandwidth to work on this right now if you need help. This is extremely disappointing to me as I do very much like the way 'react-test-renderer\/shallow' works (much nicer than enzyme imo). It would be even nicer though if it gave more insight into why the tests are not passing! \ud83d\ude04 \r\n\r\nThanks! ","In the end my test is passing with this (I was forgetting the \"key\" field and wasn't aware it was missing until doing the stringified comparison):\r\n```\r\n expect(JSON.stringify(shallowResult.props.children)).toEqual(\r\n            JSON.stringify(\r\n                [<Todo todo={fakeTodosData.data[0]} key={'key0'}\/>,\r\n                <Todo todo={fakeTodosData.data[1]} key={'key1'}\/>]\r\n            )\r\n        );\r\n```","fyi, swapping `.toBe` to `.toEqual` helped my case:)","Circular-structured JSONs proof:\r\n\r\n```\r\n\/\/ Workaround when Using .toMatchObject() returns failing test with message Received: serializes to the same string\r\n\/\/ https:\/\/github.com\/facebook\/jest\/issues\/8475\r\nconst getCircularReplacer = () => {\r\n    const seen = new WeakSet();\r\n    return (key, value) => {\r\n        if (typeof value === 'object' && value !== null) {\r\n            if (seen.has(value)) {\r\n                return;\r\n            }\r\n            seen.add(value);\r\n        }\r\n        return value;\r\n    };\r\n};\r\n\r\nconst isStringifiedComparisonEqual = (a: Object, b: Object): boolean =>\r\n    JSON.stringify(a, getCircularReplacer()) === JSON.stringify(b, getCircularReplacer());\r\n\r\n\r\n\r\nexpect(isStringifiedComparisonEqual(objectA, objectB));\r\n```","In my case I had:\r\n\r\n```js\r\nconst obj = { value: 'value', array: ['array'] };\r\nexpect(obj).toMatchObject({ ... });\r\n```\r\n\r\nAnd got the error, but was able to resolve that, by wrapping nested array with `expect.arrayContaining(['array'])` (inside `toMatchObject`). It is because Jest probably doesn't resolve nested array automatically in that case.","jumping onto this thread, when an object contains methods I run into this:\r\n\r\n```\r\n      const a = {\r\n        getSomething: () => ({\r\n          getSomethingElse: () => ({\r\n            something: 'I want',\r\n          }),\r\n        }),\r\n      };\r\n\r\n      const b = {\r\n        getSomething: () => ({\r\n          getSomethingElse: () => ({\r\n            something: 'I want',\r\n          }),\r\n        }),\r\n      };\r\n\r\n      expect(a).toMatchObject(b);  \/\/    _Expected: {\"getSomething\": [Function getSomething]} Received: serializes to the same string_\r\n```","Hello. Sorry if I missed some message that was describing the issue already, but I've created a sandbox with reproduction for you:\r\n\r\nhttps:\/\/codesandbox.io\/s\/nameless-violet-vk4gn\r\n\r\nSee the `src\/index.test.js` source and \"Tests\" tab for the results","@pedrottimark \r\n> Here is a work-around to get rid of [non-index properties]:\r\n> \r\n> ```js\r\n> expect([...users]).toMatchObject(expectedUsers)\r\n> ```\r\n\r\n`users.slice(0)` also gets rid of non-index properties. Might it be faster?","> `users.slice(0)` also gets rid of non-index properties. Might it be faster?\r\n\r\nThe difference is very minor https:\/\/jsperf.com\/slice-vs-spread-2","Is there a way to disable \"serializes to the same string\" so it could resolve positively? Maybe additional configuration for Jest? Quite annoying that we have to look for a workaround every time we need to compare deep nested objects, object methods, etc.","thx @manhhailua ","@DnEgorWeb to achieve this functionality you could serialize the objects yourself and compare the results. In my use case this behavior is a good thing because I need to make sure the objects are actually the same all the way through","I had this problem too but I found I could wrap an `expect` inside of an `expect` and catch the throw error:\r\n\r\n```js\r\n\texpect(() => {\r\n\t\texpect(toReact(children)).toEqual([\r\n\t\t\t\"Hello, \",\r\n\t\t\t<A href=\"https:\/\/google.com\">\r\n\t\t\t\tworld\r\n\t\t\t<\/A>,\r\n\t\t\t\"!\",\r\n\t\t])\r\n\t}).toThrow(\"serializes to the same string\")\r\n```\r\n\r\nI hope this helps someone. By the way you can actually test the throw message using regex: https:\/\/jestjs.io\/docs\/en\/expect#tothrowerror.","Maybe this will help somebody else. I had this error after introducing a circular dependency while writing tests. Removing the circular dependency resolved the issue.","Got the same issue with this assert:\r\n\r\n```typescript\r\nexpect(error.errors).toMatchObject(expectedErrors);\r\nexpect(Object.keys(error.errors)).toBe(Object.keys(expectedErrors));\r\n```\r\n\r\nThe goal is to ensure the errors numbers are equal because `toMatchObject` will not ensure that.\r\n\r\nI may compare array length, but the information is restricted to a simple number instead the error key diff.\r\n\r\nI finally found a workaround using `jest-extended` with the [`toContainAllKeys`](https:\/\/github.com\/jest-community\/jest-extended#tocontainallkeyskeys) method:\r\n\r\n```typescript\r\nexpect(error.errors).toContainAllKeys(Object.keys(expectedErrors));\r\n```\r\n\r\nHowever, having a strict-less built-in object comparison method would be a nice addition.","This was my solution:\r\n\r\n```\r\nexpect(JSON.parse(JSON.stringify(result.current))).toEqual(expected);\r\n```","> For toMatchObject to work as expected it was important to use the same jest mock on both objects.\r\n\r\nThis was my catch!  TY","Here's how I solved it. As I understand, in my case I was having a problem matching function names, because the matcher operates on the function identity, and not the name of the function. My solution was to mock the module when the function resided before running the test, the mocking ensured that all the functions have the same identity.\r\n\r\nBefore (causing the test to fail with \"Received: serializes to the same string\" on object equality checking\")\r\n\r\n```typescript\r\nimport { TheInputFormControl } from '..\/..\/components\/formControls';\r\n...\r\n  it('integrates successfully', () => {\r\n    const result = getField(0);\r\n    expect(result).toMatchObject([\r\n      {\r\n        Component: TheInputFormControl,\r\n        id: 'user_id',\r\n...\r\n```\r\n\r\nAfter (tests passing)\r\n\r\n```typescript\r\nimport { TheInputFormControl } from '..\/..\/components\/formControls';\r\n...\r\n  jest.mock('..\/..\/components\/formControls'); \/\/ <- this is the secret sauce\r\n  it('integrates successfully', () => {\r\n    const result = getField(0);\r\n    expect(result).toMatchObject([\r\n      {\r\n        Component: TheInputFormControl,\r\n        id: 'user_id',\r\n...\r\n```\r\n","Hello,\r\nMany of yours answer doesn't work for me... But that is my working test:\r\n\r\n```JS\r\nimport {mocked} from \"ts-jest\/utils\" \/\/ depreciated in Jest ^28.*\r\nimport {CKTable} from \".\/CKTable\"\r\n\r\njest.mock('..\/CKTable')\r\nconst mockedCKtable = mocked(CKTable, true)\r\n\r\n...\r\n\r\nconst expectedOptions = {\r\n        date: new Date(),\r\n        id: 0,\r\n       \/\/ etc ...\r\n      };\r\n\r\nconst mockEntries = Object.entries(mockedCKTable.mock.calls[0][0]);\r\n\r\nconst expectedEntries = Object.entries(expectedOptions);\r\n\r\nexpect(JSON.stringify(mockEntries)).toEqual(JSON.stringify(expectedEntries));\r\n```","Have the similar issue with the HTML comparison\r\n```\r\nit('the widget render 4 tooltips for the pie chart', () => {\r\n      const text1 = 'Fault Tolerance';\r\n      const text2 = ':';\r\n      const text3 = '1';\r\n      const tooltip = wrapper.find('Tooltip');\r\n      expect(tooltip).toHaveLength(4);\r\n      expect(tooltip.first().prop('content')).toEqual(\r\n        <snap>\r\n          {text1}\r\n          {text2}\r\n          {' '}\r\n          {text3}\r\n        <\/snap>,\r\n      );\r\n    });\r\n```","I have two nearly identical components that I'm testing (via react-native-testing-library), and oddly I get this error for one, but not the other, comparing SVG components. I don't have much else useful to contribute, I'd delve deeper if I knew how to debug further."],"labels":["Needs Triage","Bug Report"]},{"title":"Do not fail on 'Jest: Coverage data for ... was not found.' or make `coverageThreshold` configurable on the cli","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nWe are using one `jest.config.js` per application and using [Bazel](https:\/\/bazel.build\/) as the build\/testing tool. The setup there works that each test file will be invoked in isolation\/sandboxed via jest. So as soon as I have `coverageThreshold: { '.\/some\/path\/': {...} }` some of these test will fail with `Jest: Coverage data for ... was not found.` Now I could point them all to their individual config, but then I would have to create many many more file which all would be identical apart from the `coverageThreshold`.\r\n\r\nSo it would be great to either get a `passWithNoCoverage` flag or similar, or make `coverageThreshold` configurable on the cli, so I could just pass that in for each individual jest invocations\r\n\r\n## Motivation\r\n\r\nSo I do not have to have duplicate jest.config files\r\n\r\n## Example\r\n\r\neither:\r\n\r\n`jest --passWithNoCoverage --config=path\/to\/config.js --runTestsByPath=path\/to\/test.js`\r\n\r\nor \r\n\r\n`jest --coverageThreshold='{\\\"global\\\":{\\\"statements\\\":90}' --config=path\/to\/config.js --runTestsByPath=path\/to\/test.js`\r\n\r\n## Pitch\r\n\r\nOne of the proposals might even be a bug report, see: https:\/\/github.com\/facebook\/jest\/issues\/7509 and the addition of the new flag would imo be a good fit to complement the already existing `--passWithNoTests` flag.\r\n","comments":["It seems it is possible to set `--coverageThreshold` after all, just in a very specific way. While `--passWithNoCoverage` would still be a nice addition at least there is a reasonable workaround possible.","Have the same query! Trying to only run changed files and it'll fail with `Jest: Coverage data for ... was not found.` when there's a coverage threshold in the config. I'll look into `--coverageThreshold` although it'll be a very ugly script :P.\r\n\r\n[Edit]:\r\nMy solution is to have \r\n```bash\r\njest --coverage --changedSince=master --passWithNoTests --coverageThreshold='$(cat coverage.json)'\r\n```\r\n\r\nwith `coverage.json` being an object with my thresholds","Hey! I don't think adding a new config option is a good solution to that. You can run your tests without coverage using `--no-coverage` flag. \r\n\r\nSupporting coverageThreshold through CLI is definitely an option.\r\n\r\nI think it would make sense to pass the test with coverage if there's no coverage data found. We still need to keep the message though. cc @jeysal @SimenB ","The `--no-coverage` flag isn't an option for my use case because what I'm looking to do is be able to run a subset of my test suite, with coverage and the `coverageThresholds` set in the main configuration of the test framework, so that I can see if for my subset of tests in the suite, I am going to be decreasing or breaking coverage.\r\n\r\nI think this use case is completely valid in that locally you don't want to have to run the full test suite when you're developing in a specific area, and you also want your tests to run as close to CI as possible so that you aren't surprised if CI breaks when you push up to remote.","Our use case is: 1) coverage threshold set, and 2) prepush hook that runs Jest with `--changedSince=master` to reduce test execution time, since the prepush hook is about getting quick feedback before a full CI run, and 3) not an option for us to run with `--no-coverage` because meeting our coverage threshold is important *if* tests are run.\r\n\r\nHowever, I would expect `--passWithNoTests` to also imply that Jest should pass with no coverage, since there's no way that a coverage threshold could ever be met if no tests ran.","We split our test cases so we can parallelize and have faster test runs in CI using `--testPathPattern`. We've been forced to remove coverage during CI because we cannot specify coverage thresholds for the tests that we specify alone. It would be great to be able to specify coverage thresholds for a subset of tests so we can get coverage data from our CI runs again.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Absolutely still an issue.","Chiming in here, with different example. \r\n\r\nWhen using [Nx](https:\/\/nx.dev\/packages\/jest), it comes with a Jest preset in the root of the project where you can define thresholds for certain glob patterns (e.g. all files matching `'**\/*.effects.ts'`). That preset is then used by all the apps and libs Nx generated. But some of the apps and libs don't have files matching that pattern. \r\nWe work around that now, by setting `coverageThreshold: {},` in the `jest.config.ts` file of the specific app, but that would result in also losing all other patterns from the preset.\r\n\r\nHaving a configuration option to not error on missing coverage data for some of the patterns defined, would be very helpful for this.  ","I'd like this too. I have a threshold configuration that contains a few different globs, but those globs don't always have a match when I run tests on only staged files. I'd like it to be smart enough to say that if there aren't any staged files matching the glob, then the threshold should be ignored.","@thymikee you closed the PR looking for discussion, but there\u2019s been no response to the valid use cases here requesting to have a coverage report without failing tests. Any chance a discussion around this can be had? It seems that there are plenty of cases where gaining visibility with the coverage report is desired but failing the test run strictly because of missing coverage is not what\u2019s desired. This is why in most testing frameworks, coverage has been decoupled from the test framework itself, allowing the developers more control over what will fail a test run, and when a failure happens, if it was due to a failing test or missing coverage. ","100% this [PR](https:\/\/github.com\/facebook\/jest\/pull\/9019) is not that same thing as running with --no-coverage. arguably this should be the default behavior?? if i specify the tests down to a certain set i wouldn't expect untested files to still fail for coverage reasons.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Not stale, please fix this "],"labels":[":rocket: Feature Request"]},{"title":"Ability to skip rest test cases if one fails","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nProvide ability to skip rest test cases in a file or `describe` block if one test fails.\r\n\r\n## Motivation\r\n\r\nFor E2E testing, the test cases are usually written to be run sequentially, and a failed test should stop the rest from running.\r\n\r\n## Example\r\n\r\n```ts\r\ntest('should login', async () => {});\r\n\r\ntest('should edit profile', async () => {});\r\n\r\ntest('should render profile', async () => {});\r\n```\r\n\r\nOr with `describe`s:\r\n\r\n```ts\r\ndescribe('#1', () => {\r\n  test('should login', async () => {});\r\n\r\n  describe('#1.1', () => {\r\n    test('should edit profile', async () => {});\r\n\r\n    test('should render profile', async () => {});\r\n  });\r\n});\r\n```\r\n","comments":["keyword: step\r\nprior art: https:\/\/github.com\/rprieto\/mocha-steps","Duplicate of https:\/\/github.com\/facebook\/jest\/issues\/6527 (for hooks and tests)","No it's not a duplicate. We are requesting [mocha-steps](https:\/\/www.npmjs.com\/package\/mocha-steps) not [jasmine-fail-fast](https:\/\/www.npmjs.com\/package\/jasmine-fail-fast).\r\n\r\nTL;DR: skip (and auto fail) the following steps after the first failing step **within the current describe** (**not** exit on first failure)\r\n\r\n@jeysal please reopen.","Okay then, we can keep this open to track fail-fast within a describe block (although the OP does not explicitly request this).\r\nI think it's unlikely that this goes into Jest core though, while #6527 might as it's a logical extension of `bail`.","Personally I think this makes sense, and would love to see it in the jest core under `step`, as it lets you break tests into smaller parts (allowing you to describe them better, since they each have an `it`\/`step` message), and increase performance for when you're testing something that is dependent on prior tests.\r\n\r\nTake for example this test:\r\n\r\n```\r\ndescribe('.root', () => {\r\n  it('contains the root package.json', () => {\r\n    \/\/ eslint-disable-next-line @typescript-eslint\/no-require-imports\r\n    const requirePackageJson = () => require(path.join(pathTo.root, 'package.json'));\r\n\r\n    expect(() => requirePackageJson()).not.toThrow();\r\n    expect(requirePackageJson()).toStrictEqual(packageJson);\r\n  });\r\n});\r\n```\r\n\r\nIt's checking that `pathTo.root` points to a directory with a `package.json`, and that the `package.json` is the actual root `package.json` (by comparing the object returned by the `require` to one imported via the normal module loader).\r\n\r\nSince `require` throws an error if it can't find the file (the first `expect`), it makes no sense to test contents of the file (the second `expect`) if this happens.\r\n\r\nBut, since `it`s are independent of each other, I either will have two tests failing (which while technically correct means I've got pointless noise that adds nothing to the situation), or one \"big\" `it` that combines two tests.\r\n\r\nMeanwhile, if we had `step`:\r\n\r\n```\r\ndescribe('.root', () => {\r\n  \/\/ eslint-disable-next-line @typescript-eslint\/no-require-imports\r\n  const requirePackageJson = () => require(path.join(pathTo.root, 'package.json'));\r\n\r\n  step('has the root package.json', () => {\r\n    expect(() => requirePackageJson()).not.toThrow();\r\n  });\r\n  step('contains the root package.json', () => {\r\n    expect(requirePackageJson()).toStrictEqual(packageJson);\r\n  });\r\n});\r\n```\r\n\r\n----\r\n\r\nThis maybe be a result of me being relatively new to the testing game, but it seems to me that `step` would empower `jest` further, as it enables you to do feature-like testing letting you nicely test apps as a whole.\r\n\r\nI know that `step` is pretty self explanatory in its advantages, I felt like it could be valuable to put one to paper - I've got a lot of tests that are similar to that.\r\n\r\nI don't mind `step` not being in the jest core, just so long it's as easy to use as `it`, `describe`, `#each`, etc are today.\r\n\r\nI'm just really excited at the idea of having this feature in jest, as I've come across this problem a lot! \ud83d\ude04 ","Smoke tests in front of more substantial tests save people time. Without the ability to short circuit subsequent test, the time saving is mitigated.\r\n\r\nWhere does this functionality need to be added? Would this live in a test runner or is this a jest issue? (Many people don't even realize the distinction between jest and test runners...)","Here is my temporary solution.\r\n```\r\ndescribe(\"test\", () => {\r\n  let skipOther = false\r\n  test(\"check something\", async () => {\r\n    try {\r\n      await checkSomething()\r\n    } catch(e) {\r\n      skipOther = true\r\n      throw new Error(\"error\")\r\n    }\r\n  })\r\n\r\n  test(\"might be skipped\", async () => {\r\n    if(skipOther) throw new Error(\"error occured in previous tests.\")\r\n    console.log(\"display this, if there is no error before this.\")\r\n  })\r\n})\r\n```","I would be interested in implementing a test.step function in jest circus, I don't see a way to do this outside of the jest-circus core though, as it requires adding some flag to the state. ","I created a PR that implements asynchronously canceling tests as described in #8604. With that in place, one could implement this functionality through easy monkey patching in user land like this:\r\n\r\n```js\r\nlet prevFailed;\r\nconst _describe = global.describe;\r\nglobal.describe = (...args) => {\r\n  prevFailed = false;\r\n  return _describe(...args);\r\n};\r\nglobal.test.step = (name, fn, ...args) => {\r\n  test(name, async function(...fnArgs) {\r\n    if (prevFailed) {\r\n      return this.skip();\r\n    }\r\n    try {\r\n      return await fn(...fnArgs);\r\n    } catch (e) {\r\n      prevFailed = true;\r\n      throw e;\r\n    }\r\n  }, ...args);\r\n};\r\n```","@MrLoh where's the PR? I only see the issue","#9944 But I doubt it will ever be merged, I haven't heard back a single word from any contributor. ","My solution to skip rest tests after first failure  https:\/\/github.com\/facebook\/jest\/issues\/6527#issuecomment-760092817\r\n![image](https:\/\/user-images.githubusercontent.com\/194784\/104576448-7c73b280-5658-11eb-8a4d-2ecb0bf42a45.png)","Here is my solution [#7245](https:\/\/github.com\/facebook\/jest\/issues\/7245#issuecomment-791285252) to skip test programmatically and on run time after test began. the key is to call `pending()`","Playwright already provides a test.step https:\/\/playwright.dev\/docs\/api\/class-test\/#test-step\r\nAnd this would also make sense for jest specially for e2e tests.","I have created the Jest Environment for this usecase\r\n\r\nhttps:\/\/www.npmjs.com\/package\/jest-environment-steps","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","."],"labels":[":rocket: Feature Request"]},{"title":"toMatchObject  pass when comparing any object to a empty object ({})","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nit: \r\n```\r\n  expect({a:[{}]}).toMatchObject({a:{}})\r\n  expect({ a: undefined }).toMatchObject({ a: {} });\r\n  expect({ a: null }).toMatchObject({});\r\n  expect({ a: \"string\" }).toMatchObject({});\r\n  expect({ a: 1 }).toMatchObject({});\r\n```\r\n\r\nshould fail but pass\r\n\r\n## To Reproduce\r\n\r\n` expect({a:[{}]}).toMatchObject({a:{}})`\r\n\r\n## Expected behavior\r\n\r\nfail\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nPlease provide either a [repl.it demo](https:\/\/repl.it\/languages\/jest) or a minimal repository on GitHub.\r\n\r\nIssues without a reproduction link are likely to stall.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\n  System:\r\n    OS: macOS 10.14.4\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz\r\n  Binaries:\r\n    Node: 10.15.1 - ~\/.nvm\/versions\/node\/v10.15.1\/bin\/node\r\n    Yarn: 1.13.0 - \/usr\/local\/bin\/yarn\r\n    npm: 6.9.0 - ~\/.nvm\/versions\/node\/v10.15.1\/bin\/npm\r\n```\r\n","comments":["Can confirm this is a bug. cc @pedrottimark @mattphillips ","@thymikee Is it? IMO this is correct behavior. The match pattern is an empty object, so there are no constraints on what value the `a` property should have. A single-element array satisfies this, as does an empty array. It might be debatable whether e.g. a number or `undefined` as values for `a` should pass this, but an array seems correct to me.","If this is what we expect and makes sense in general, it should be documented, because it's definitely not obvious. I think we could do better though ","Yeah, I agree we can do better, because the reason is debatable in the words of Tim https:\/\/github.com\/facebook\/jest\/issues\/8308#issuecomment-482348139\r\n\r\nA similar positive test passes (bad) for non-object received value when expected object is empty:\r\n\r\n```js\r\n  test('toMatchObject without key', () => {\r\n    const expected = {a: {}};\r\n    const received = {a: 13};\r\n    expect(received).toMatchObject(expected);\r\n  });\r\n```\r\n\r\nBecause `Array.prototype.every` passes if expected object has no keys and the logic seems to **assume** an object as received value at:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/expect\/src\/utils.ts#L267-L281\r\n\r\nA similar negative test passes (good) if the object contains a property:\r\n\r\n```js\r\n  test('toMatchObject with key', () => {\r\n    const expected = {a: {key: 'value'}};\r\n    const received = {a: [{key: 'value'}]};\r\n    expect(received).not.toMatchObject(expected);\r\n  });\r\n```\r\n\r\nHere is a question about timing: Do y\u2019all think that a change for the better is breaking?","Since v25 is nearing, I'd stick it there, it's easier to justify breaking behavior (even though fixing bugs) in a major change.","Here is possibly another example of a related bug. When checking for whether the toMatchObject is equal to the expected object, there should not ONLY be a check for property values, but also for the case where there is no property values at all. Consider the following:\r\n\r\nThis works and fails as expected:\r\n<img width=\"1020\" alt=\"Screen Shot 2019-04-15 at 1 35 18 PM\" src=\"https:\/\/user-images.githubusercontent.com\/22015257\/56163791-15f1ca00-5f84-11e9-90cc-ab8ffa097f0c.png\">\r\n\r\nHowever, this will not fail and thus lead to a false positive:\r\n<img width=\"976\" alt=\"Screen Shot 2019-04-15 at 1 41 50 PM\" src=\"https:\/\/user-images.githubusercontent.com\/22015257\/56163842-3c176a00-5f84-11e9-9125-fa075aca025a.png\">\r\n\r\n\r\nBut ofcourse\r\n```\r\n{\r\n   color: '#006bb8',\r\n   backgroundColor: '#fdba21',\r\n};\r\n\r\nis !==\r\n\r\n{}\r\n```\r\n","@kmwarter Thank you for joining the discussion so we can understand the scope of the problem before deciding on a solution.\r\n\r\n\r\n\r\nIf I understand correctly for the second test that:\r\n\r\n* received value is object which has `color` and `backgroundColor` property\r\n* expected value is object which has no properties\r\n\r\nthen the assertion passes because `toMatchObject` means subset equality (the expected object is a subset of the received object) however it would fail for `toEqual` or `toStrictEqual` deep equality.\r\n\r\nFor the first test, an assertion will fail for all 3 matchers.\r\n\r\nDoes that make sense?","@pedrottimark yes this is a correct explanation and that does make sense. \r\n\r\nI do find it confusing that toMatchObject would not be able to detect that an empty object {}, does not match an object with something in it { hello: 'hello' }. \r\n\r\nIt sounds like you are saying this is expected though because toMatchObject is explicitly checking for whether all properties match, and whether a nested object contains some but not all properties?\r\n\r\nStill, isn't the absence of a property at the top level good enough validation that not all properties match?","@kmwarter Unlike `toStrictEqual` or `toEqual` for which the comparison is symmetric (same result if you swap received and expected values) for `toMatchObject`\r\n\r\n* non-empty received object like `{hello: 'hello'}` does match empty expected object\r\n* empty received object does not match non-empty expected object like `{hello: 'hello'}`\r\n\r\nThat is, received value must have all the expected properties, but can have additional properties.\r\n\r\nSo in your nice example, an empty expected object means the received value must be an object, but does not require specific properties. The problem that this issue reports is the assertion should fail if:\r\n* expected value is empty object\r\n* received value is not an object (for example, `null` or `undefined` as value of `style` property)\r\n\r\nWhether the \u201ctypes\u201d must match (for example, received array and expected plain object) is an important question that Tim asks https:\/\/github.com\/facebook\/jest\/issues\/8308#issuecomment-482348139","@cesarve77 @thymikee @jeysal Here is proposed change to solve this problem:\r\n\r\n```diff\r\n  const isObjectWithKeys = (a: any) =>\r\n    a !== null &&\r\n    typeof a === 'object' &&\r\n    !(a instanceof Error) &&\r\n    !(a instanceof Array) &&\r\n    !(a instanceof Date);\r\n\r\n  export const subsetEquality = (\r\n    object: any,\r\n    subset: any,\r\n  ): undefined | boolean => {\r\n-   if (!isObjectWithKeys(subset)) {\r\n+   if (!isObjectWithKeys(subset) || !isObjectWithKeys(object)) {\r\n      return undefined;\r\n    }\r\n\r\n    \/\/ return true or false;\r\n  }\r\n```\r\n\r\nMake `subsetEquality` tester apply when **both** expected and received are generic objects\r\n\r\n* similar to `toEqual` but lacks the special case for `RegExp` (probably by mistake)\r\n* not as strict as `toStrictEqual` because it does not compare object types\r\n\r\nFor anyone who wrote a subset equality test to compare received `Errror` or `Array` or `Date` to generic expected object:\r\n\r\n* quick and dirty solution: wrap property value `expect.objectContaining(expected)` because it has similar loophole as we are plugging here\r\n* because the property comparisons of `subsetEquality` and `objectContaining` are not exactly the same, a more precise solution is write an application-specific asymmetric matcher","IMO we should not change this for `Error|Array|Date`. The `typeof a === 'object'` limit makes sense (you can't put a property on a number), but I don't think we should go further with things that are objects like arrays, dates or errors. Putting extra properties on `Error`s is not even uncommon. If you want strictness, `toMatchObject` really isn't for you anyway.","You recommend a limited change:\r\n\r\n* Fix obvious bug that `{}` now matches any received value.\r\n* Allow `expect({a:[{}]}).toMatchObject({a:{}})` to pass instead of fail. To solve the problem of this issue that it is reasonable for a test to fail if the data structure changes from single object to array of objects, then the expected object must contain at least one property?\r\n","@pedrottimark Yeah I think so. You could also use `expect.any(Array)`? I'd also expect things like `expect([{a: 4}]).toMatchObject({0: {a: 4}})` to work. I think this is consistent with the docs, which talk about matching properties of an object. Arrays are objects and have properties.","@cesarve77 Can you please update the title of this bug to be more explicit? Asking because it shows in search results and it's unclear what the bug is.","> @cesarve77 Can you please update the title of this bug to be more explicit? Asking because it shows in search results and it's unclear what the bug is.\r\n\r\nBetter?, if not give me a suggestion.\r\n\r\nThanks!","@pedrottimark a bit late on this discussion, but as i see in the PR that was the product of this issue still accepts `{}` to be equal to any object. In that PR circular dependencies are handled.\r\n\r\nJust pointing to the fact that people should expect this still to happen. For me it was not clear that closing this issue did not make test with mentioned assertion fail.","I've also got something similar when trying to match an object like this:\r\n```\r\n[{a: \"a\", label: \"a\"}]\r\n``` \r\nmatching with:\r\n```\r\n[{a: \"a\"}]\r\n```"],"labels":[":bug: Bug"]},{"title":"Total assertion count expectations are inaccurate (with async expects)","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\n`expect.hasAssertions()` and `expect.assertions()` incorrectly count assertions as part of a test when they should not be.\r\n\r\n## To Reproduce\r\n\r\nThe most basic example I could create to demonstrate\r\n\r\n```js\r\ntest('hasAssertions should fail expects in promises', () => {\r\n  expect.hasAssertions();\r\n  \/\/ Note that the expect below does not \"count\" as a failed assertion for this\r\n  \/\/ test, but hasAssertions() also does not fail as it should!\r\n  Promise.resolve().then(() => expect(true).toBe(false));\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nThe test above should fail, the async assertion should be ignored towards the assertion count. The promise chain, where the expect is executing is not part of the test. We can tell that because the test is not marked as failing even with a blatantly broken assertion. When the expect runs the test is \"complete\" and should not be counted as part of `assertionCount` in Jest.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nI forked the repo and wrote an integration test to demonstrate the problem. [Branch](https:\/\/github.com\/ballercat\/jest\/tree\/has-assertions-ignore-missed-promisses)\r\n\r\n[Permalink to the spec itself](https:\/\/github.com\/ballercat\/jest\/blob\/4ffd163ad3b28df01e15c6ccaff1542afedb5209\/e2e\/has-assertions\/fail-with-promises\/__tests__\/index.js#L3)\r\n\r\nhttps:\/\/repl.it\/repls\/DramaticCuteAssignments\r\n\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\n```bash\r\n\u276f npx envinfo --preset jest\r\n\r\n  System:\r\n    OS: macOS High Sierra 10.13.6\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz\r\n  Binaries:\r\n    Node: 8.11.1 - ~\/.nvm\/versions\/node\/v8.11.1\/bin\/node\r\n    Yarn: 1.15.0 - \/usr\/local\/bin\/yarn\r\n    npm: 5.6.0 - ~\/.nvm\/versions\/node\/v8.11.1\/bin\/npm\r\n```\r\n\r\n### Notes\r\n\r\nI do realize that the test is _bad_, it's not very well written. But tests like these do happen IRL and assertion count matchers is what you would want to use to catch them. Currently they do not work for this scenario.\r\n\r\nThis was pretty interesting and I dug into it a bunch, trying to see if there is an easy fix. But I was unable to locate an obvious mistake. It seems like the `assertionCount` logic (`expect`) is separate from the logic marking tests as failures (`jest-jasmine2`?) so there isn't a simple way to marry the two.","comments":["This also has a negative effect on consecutive tests which use things like `setTimeout` to enqueue assertions in macrotasks. Leading to assertions being \"leaked\" across tests:\r\n\r\nExample:\r\n\r\n```js\r\ntest.only('assertions after done() callback - 1', done => {\r\n  setTimeout(() => {\r\n    done();\r\n    setTimeout(() => {\r\n      expect(1 + 2).toBe(2);\r\n    });\r\n  });\r\n});\r\n\r\ntest.only('assertions after done() callback - 2', done => {\r\n  expect.hasAssertions();\r\n  setTimeout(() => {\r\n    done();\r\n  });\r\n});\r\n```\r\n\r\nThis test setup leads to these results after tests complete:\r\n\r\n```bash\r\n FAIL  src\/__tests__\/index.js\r\n  \u2713 assertions after done() callback - 1 (31ms)\r\n  \u2715 assertions after done() callback - 2 (6ms)\r\n\r\n  \u25cf assertions after done() callback - 2\r\n\r\n    expect(received).toBe(expected) \/\/ Object.is equality\r\n\r\n    Expected: 2\r\n    Received: 3\r\n\r\n      28 |     done();\r\n      29 |     setTimeout(() => {\r\n    > 30 |       expect(1 + 2).toBe(2);\r\n         |                     ^\r\n      31 |     });\r\n      32 |   });\r\n      33 | });\r\n\r\n      at Timeout.toBe [as _onTimeout] (src\/__tests__\/index.js:30:21)\r\n```\r\n\r\nNote that the second spec did not fail due to missing assertions, but instead due to a broken assertion enqueued from spec #1. I get what's going on and I get that it's due to the global nature of the `expect` library, but this is pretty surprising to see.","Can reproduce this. IIRC at least for `jest-circus` at least one tick passes after the test until the result is evaluated because of internal `await`s.\r\nNot sure if this is easily fixable - you should at least see the unhandled rejection warning though to tell you there's something wrong with your test.\r\nNote that the example from your comment is currently pretty much impossible to detect. I have experimented with using things like [zone.js](https:\/\/github.com\/angular\/zone.js\/) to implement some sort of strict async or debug mode for Jest that could detect this mistake, but nothing really concrete yet.","Ooh, the zone.js library is very cool.\r\n\r\nHow I stumbled upon this is trying to write a [\"plugin\" for jest which would catch these type of runtime issues.](https:\/\/github.com\/ballercat\/jest-plugin-must-assert) I have incorporated zone.js library into it as a PoC, and it seems to be working rather well. I'm going to throw this at a few thousand tests I have available and report back. Thanks!","I have simillar issue.\r\n\r\nMy test:\r\n```js\r\ntest('should work', () => {\r\n        expect.assertions(1);\r\n\r\n        return getCoinInfo()\r\n            .then((coinInfo) => {\r\n                expect(coinInfo.id).toBeGreaterThan(0);\r\n            })\r\n            .catch((error) => {\r\n                logError(error);\r\n            });\r\n    });\r\n```\r\n\r\nIt should fail but it doesn't","Running into this as well.","I've just stumbled across this issue due to my own misunderstanding of the behaviour of `expect.hasAssertions` and `expect.assertions()`\r\n\r\nAFAICT, jest signals expectation failure by throwing, so when I run the initial example in my own code base, it fails, but the following test passes: \r\n\r\n```\r\ntest('expect.assertions(2) should pass when caught', () => {\r\n    expect.assertions(2)\r\n    Promise.resolve()\r\n      .then(() => {\r\n        \/\/ jest signals expectation failure by thowing, and the intial example has no .catch\r\n        expect(true).toBe(false)\r\n      })\r\n      .catch((e) => {\r\n        expect(true).toBe(true)\r\n      })\r\n  })\r\n```\r\n\r\n(ack. it's highly likely things have changed since the issue was raised)\r\n\r\nI'm unclear on why this works at all without returning or awaiting the promise \ud83d\ude04\r\n\r\n> You can chain as many Promises as you like and call expect at any time, **as long as you return a Promise at the end**.\r\n\r\nhttps:\/\/jestjs.io\/docs\/tutorial-async (emphasis mine)\r\n","Essentially same underlying issue here the solution I suggest in https:\/\/github.com\/facebook\/jest\/issues\/9881#issuecomment-1050671577 - `expect` is not bound to a single test, and maintains a global state. So async will confuse it. We need some way of binding an \"instance\" of `expect` to a single test, so we can reliably count assertions made in that specific test","@SimenB Thanks for the response and I agree 100% RE: the problem of global `expect` not being bound to a single test.\r\n\r\nIt's probably a bit too late in the lifecycle of Jest to expand\/change it's API in such a way but I for one would love to see an addition to the `test(string, fn)` API with something like `test.strict` that would directly provide the `expect` Fn as a variable instead of relying on the global. Similar ideas have worked for other test runners (ava comes to mind).\r\n\r\nEx:\r\n\r\n```js\r\ntest.strict('this test will fail assertions post test completion', (expect) => {\r\n   setTimeout(() => expect(true).toBe(true), 10000);\r\n});\r\n```","Yeah, I wanna add that type of API. Unfortunate we used the `test` name as just an alias for `it` instead of breaking teh API \ud83d\ude05 \r\n\r\nFWIW I'd me 100% open to a PR adding support for `test.strict`, `test.bound`, `test.isolated` or some such thing which binds\/isolates `expect`. The name isn't the hard part, just need to figure out how to make `expect` not rely on global state (but still keep it to not break back compat), then how to support a callback (probably having a second arg be an options bag with `{callback: boolean, timeout: number}` or something)","FYI: A fix for this is to use `done`. For example:\r\n```\r\n  test('calls the API and throws an error', async (done) => {\r\n    expect.assertions(2); \/\/ won't receive 3, because done() below prevents leaking\r\n    const component = mount('Component');\r\n    try {\r\n      await component.login('email', 'password');\r\n    } catch (error) {\r\n      expect(error.name).toEqual('Unauthorized');\r\n      expect(error.status).toEqual(401);\r\n    }\r\n    done();\r\n  });\r\n  test('calls the API and does not throw an error', async (done) => {\r\n    expect.assertions(1); \/\/ not 3, because done() in previous test prevents the leaking\r\n    const component = mount('Component');\r\n    try {\r\n      await component.login(user, password); \/\/ assuming these are set in the beforeEach()\r\n    } catch (error) {\r\n      \/\/ should not reach this -- user is magically known to be good\r\n      console.log(error.msg)\r\n    }\r\n    expect(component.user).toBe(user);\r\n    done();\r\n  });\r\n```","@EllaMolnar-FOX \r\n\r\nYou are correct in that there are ways to write good tests which do not leak assertions. The examples provided in this issue are intentionally stripped down to reproducible example of the behavior. They are not intended as an example of a \"good\" test that still breaks. \r\n\r\nAs a side-note, the example above is perfectly valid with just `async` test functions without the `done` callback. Async functions return a promise by default (even if they resolve to an `undefined` value). Jest will wait for these to resolve, so the `done` is superfluous. ","> \r\n\r\nUnfortunately @EllaMolnar-FOX 's fix won't work for me because I'm using TypeScript for my tests.  I can't use both `async` and `done` in the same test.\r\n\r\n```\r\n error TS2345: Argument of type '(done: DoneCallback) => Promise<void>' is not assignable to parameter of type 'ProvidesCallback | undefined'.\r\n      Type '(done: DoneCallback) => Promise<void>' is not assignable to type '(cb: DoneCallback) => void | undefined'.\r\n        Type 'Promise<void>' is not assignable to type 'void'.\r\n```"],"labels":["Confirmed","Bug Report"]},{"title":"coverageThreshold to support negative zero values","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nI understand that a [coverageThreshold](https:\/\/jestjs.io\/docs\/en\/configuration#coveragethreshold-object) of `0` translates into 0% and that's all fine and good, but seeing as negative values express uncovered lines, it stands to reason that a value of `-0` should relate to zero uncovered lines, which is the same as 100%.\r\n\r\n```\r\nObject.is(0, 0)\r\n\/\/ true\r\nObject.is(0, -0)\r\n\/\/ false\r\n```\r\n\r\n## Motivation\r\n\r\nIt was just unexpected behavior when I put a `-0` in there and expected it to mean \"zero uncovered lines.\"\r\n\r\n## Example\r\n\r\nIt makes a lot of sense if all your values are negatives.\r\n\r\n```json\r\n    \"coverageThreshold\": {\r\n      \"global\": {\r\n        \"statements\": -42,\r\n        \"branches\": -0,\r\n        \"lines\": -100,\r\n        \"functions\": -31\r\n      }\r\n    },\r\n```\r\n\r\n## Pitch\r\n\r\nUnexpected behavior is all I got. I wouldn't quite call it a \ud83d\udc1b, but it's kind of gray area here, I think.\r\n","comments":["I think that negative values could make sense if the thresholds were related to absolute numbers but they currently represent percentages. How would this look when codebases grow and you want to guarantee a percentage of code covered?","I think the request is about percentages as usual (not absolute numbers), just that if the threshold T is negative, it should become 100 + T (e.g. 100 + -42 = 58).\r\nNot sure if this provides that much value though. Things like this are already often handled differently (scale 0 to 1 or 0 to 100 etc.), so making it more complex is probably not a good idea.\r\nIf you configure Jest in JS, you can already make it `100 - 42` if you want to specify a percentage of lines *not* to be covered.","Perhaps I wasn't clear about the existing feature of negative values, which have nothing to do with percentages, but entities \"uncovered.\"\r\n\r\n> Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.\r\n\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#coveragethreshold-object\r\n\r\nNegative zero is just a way of telling Jest that we want a maximum number of zero uncovered entities allowed instead of 0% coverage, which is a totally different thing.","Oh wow, looks like neither @mattphillips or I knew that this feature existed \ud83d\ude05 ","I forgive you!","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","I still need this and run into this issue on a regular basis. I\u2019m forced to use -1 for now, which isn\u2019t ideal.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Commenting to remove the stale label. I still find this request relevant.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":[":rocket: Feature Request","Stale"]},{"title":"test.concurrent ignores beforeEach and afterEach","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nWhen using **test.concurrent** with tests, all the scenarios run first and then the beforeEach and afterEach blocks run next.\r\n\r\n## To Reproduce\r\n\r\nWrite a simple test suite with a beforeEach , 3 tests using test.concurrent, and afterEach.\r\n\r\n## Expected behavior\r\n\r\nI expect runner to execute beforeEach block, then the test, then afterEach block. \r\n\r\n## Link to repl or repo (highly encouraged)\r\n[test-concurrent bug demo](https:\/\/repl.it\/repls\/OnerlookedJampackedVerification)\r\n\r\nIssues without a reproduction link are likely to stall.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\nJest v22.1.2 node v7.4.0 linux\/amd64\r\n   \r\n PASS  .\/concurrent-test.js\r\n  try running parallel by scenario level\r\n    \u2713 First Test (3ms)\r\n    \u2713 Second Test\r\n    \u2713 Third Test (1ms)\r\n\r\n  console.log concurrent-test.js:8\r\n    Test 1\r\n\r\n  console.log concurrent-test.js:12\r\n    Test 2\r\n\r\n  console.log concurrent-test.js:16\r\n    Test 3\r\n\r\n  console.log concurrent-test.js:4\r\n    BEFORE\r\n\r\n  console.log concurrent-test.js:20\r\n    AFTER\r\n\r\n  console.log concurrent-test.js:4\r\n    BEFORE\r\n\r\n  console.log concurrent-test.js:20\r\n    AFTER\r\n\r\n  console.log concurrent-test.js:4\r\n    BEFORE\r\n\r\n  console.log concurrent-test.js:20\r\n    AFTER\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       3 passed, 3 total\r\nSnapshots:   0 total\r\nTime:        0.993s, estimated 1s\r\nRan all test suites.\r\n   \r\n```\r\n","comments":["https:\/\/github.com\/facebook\/jest\/issues\/4281 dupliacted issue\r\nit would be very nice if jest fix it","Think this is the RCA\r\n\r\n`jest-circus`\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/c9c8dba4dd8de34269bdb971173659399bcbfd55\/packages\/jest-circus\/src\/legacy-code-todo-rewrite\/jestAdapterInit.ts#L84-L90\r\n\r\n`jest-jasmine`\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/c9c8dba4dd8de34269bdb971173659399bcbfd55\/packages\/jest-jasmine2\/src\/jasmineAsyncInstall.ts#L172-L176\r\n\r\n","@SimenB It seems easy to change the workflow in `jest-circus` to fix this, I've made a POC. Let me know if this approach would be a good solution","But not sure if `Before` and `After` make sense for `test.concurrent`, if I perform a stateful operation in the hooks then the tests will be indeterministic ","@Mark1626 `beforeEach` and `afterEach` might not make a ton of sense for `test.concurrent`, but `beforeAll` and `afterAll` would I think.","@SimenB bump","Please fix.","Looks like adding an empty not concurrent test before concurrent ones fixes the issue. At least with `beforeAll`.\r\n\r\nUPD: no, this doesn't work :\/","> Looks like adding an empty not concurrent test before concurrent ones fixes the issue. At least with `beforeAll`.\r\n\r\nHow did you set up your test suite? I have something like the following which is not working:\r\n```ts\r\ndescribe('...', () => {\r\n  beforeAll(async () => {\r\n    \/\/ do some setup\r\n  });\r\n\r\n  afterAll(async () => {\r\n    \/\/ do teardown\r\n  });\r\n\r\n  it('noop', () => {\r\n    expect(2+2).toBe(4);\r\n  });\r\n\r\n  it.concurrent('...', async () => {\r\n    \/\/ runs before beforeAll\r\n  });\r\n\r\n  it.concurrent('...', async () => {\r\n    \/\/ runs before beforeAll\r\n  });\r\n});\r\n```","> > Looks like adding an empty not concurrent test before concurrent ones fixes the issue. At least with `beforeAll`.\r\n> \r\n> How did you set up your test suite? I have something like the following which is not working:\r\n\r\nI ended up just running the async preparation code in the test file before `describe` block. I guess this is not ideal, though. \r\n\r\n\r\nAnother workaround is to make a promise which resolves after setup is ready and await for it in every concurrent test:\r\n\r\n```js\r\nlet beforeAllResolve;\r\n\r\nconst beforeAllPromise = new Promise((resolve) => {\r\n  beforeAllResolve = resolve;\r\n});\r\n\r\ndescribe('...', () => {\r\n  beforeAll(async () => {\r\n    \/\/ do some setup\r\n    \/\/ RESOLVE\r\n    beforeAllResolve()\r\n  });\r\n\r\n  afterAll(async () => {\r\n    \/\/ do teardown\r\n  });\r\n\r\n  it.concurrent('...', async () => {\r\n     await beforeAllPromise;\r\n     \/\/ do stuff\r\n  });\r\n\r\n  it.concurrent('...', async () => {\r\n     await beforeAllPromise;\r\n     \/\/ do stuff\r\n  });\r\n});\r\n```","Has there been any progress on this? Would prefer not to rework hundreds of lines of tests \ud83d\ude05 ","The issue still persists. I regret I recommended our team to use Jest when `test.concurrent` does not support `.beforeAll()` and `.afterAll()` aren't working as expected.\r\nThis should be a high priority issue.","I found some workaround to execute `beforeAll` before `test.concurrent`. Seems like the problem is not with `test.concurrent` logic but with `describe`. If we move `beforeAll` out from `describe`, everything works as expected:\r\n\r\n```js\r\nlet str;\r\n\r\nbeforeAll(() => {\r\n   str = 'Some str with number 3';\r\n});\r\n\r\ndescribe('describe description', () => {\r\n   test.concurrent('concurrent tests', () => {\r\n      expect(str).toBe(`Some str with number ${Math.floor(Math.random() * 5) + 1}`);\r\n   });\r\n});\r\n```\r\n\r\nBut `beforeEach` and `afterEach` still are ignored. Even those, that are in `setupFiles` or `setupFilesAfterEnv` configuration files...","`afterEach` makes sense for us, because this is here we do screenshots for failed test. "],"labels":[":bug: Bug","Area: Concurrent"]},{"title":"jest fails to work when temp dir is on a RAM drive (Windows)","body":"## \ud83d\udc1b Bug Report\r\n\r\nJest fails on start with error `Error: EISDIR: illegal operation on a directory, realpath 'B:\\Temp'` when windows temp dir is set on a RAM drive\r\n\r\n## Last working version\r\nWorked in 23.6.0\r\nStopped working in 24.1.0\r\n\r\n## To Reproduce\r\n\r\n1. Follow the [Getting Started guide](https:\/\/jestjs.io\/docs\/en\/getting-started.html) and create a simple test suite\r\n2. Create RAM drive using [ImDisk](http:\/\/www.ltr-data.se\/opencode.html\/#ImDisk) tool (B: in my case)\r\n3. Point windows temporary directory (%TEMP% env variable) to a directory on RAM drive (B:\\Temp) (a reboot may be required)\r\n4. Open command line, go to where you created test suite and run `npm run test`\r\n\r\n## Actual behavior\r\nI get an error like this:\r\n```\r\nError: ENOENT: no such file or directory, realpath 'B:\\Temp'\r\n    at Function.realpathSync.native (fs.js:1514:3)\r\n    at realpathSync (D:\\Projects\\***\\node_modules\\realpath-native\\index.js:29:28)\r\n    ...\r\n```\r\n\r\n## Expected behavior\r\n\r\nI expect jest to run tests.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\n```bash\r\n  System:\r\n    OS: Windows 10\r\n    CPU: (4) x64 Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz\r\n  Binaries:\r\n    Node: 10.14.1 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.9.2 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 6.3.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n```\r\n","comments":["same here","in v24 it error, but in v23 it work\r\n\r\ni think need to check this\r\n\r\n```\r\nError: EISDIR: illegal operation on a directory, realpath 'T:\\TEMP'\r\n    at Function.realpathSync.native (fs.js:1513:3)\r\n    at realpathSync (\\node_modules\r\n\\realpath-native\\index.js:29:28)\r\n    at getCacheDirectory (\\node_mo\r\ndules\\jest-config\\build\\getCacheDirectory.js:53:32)\r\n    at Object.<anonymous> (\\node_m\r\nodules\\jest-config\\build\\Defaults.js:40:50)\r\n    at Module._compile (internal\/modules\/cjs\/loader.js:774:30)\r\n    at Object.Module._extensions..js (internal\/modules\/cjs\/loader.js:785:1\r\n0)\r\n    at Module.load (internal\/modules\/cjs\/loader.js:641:32)\r\n    at Function.Module._load (internal\/modules\/cjs\/loader.js:556:12)\r\n    at Module.require (internal\/modules\/cjs\/loader.js:681:19)\r\n","Hi,\r\nI still have this problem. anyone plan to push 'bluelovers' pr?","yes, i have the same problem, anyone can give a hand?","fs.realpathSync.native can't read ramdisk path.\r\nHere are the quick fix:\r\n\r\n\\node_modules\\jest-util\\build\\tryRealpath.js\r\n\r\n```\r\nfunction tryRealpath(path) {\r\n  try {\r\n\tif(path==='R:\\\\Temp'){ \/\/your temp folder path\r\n\t\treturn path;\r\n\t}\r\n    path = _gracefulFs().realpathSync.native(path);\r\n  } catch (error) {\r\n```\r\n\r\nbut may be use \"realpathSync\" replace \"realpathSync.native\" can solve it too, but it may make some new problem...","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","This can be fixed probably by reusing #6925 which solved the same problem in a different place."],"labels":[":bug: Bug","Help Wanted","Windows","Pinned"]},{"title":"Very poor performance on basic tests","body":"## \ud83d\udc1b Bug Report\r\n\r\nI've created a simple test with no configuration. You can find it [here](https:\/\/github.com\/cozmy\/jest-performance). It takes 7.6 seconds just to start jest, and then, on file change, it takes 5 seconds to re-run. \r\nThere's clearly something wrong here. \r\n\r\nMocha and Chai, for example, start in around 4 seconds, but afterward, the re-run is almost instant.\r\n\r\nIt's weird that Jest reports that the test takes 14ms but shows me the result in 5 seconds.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/5887290\/53284091-c519de00-3757-11e9-85c2-33fb4bd8eb33.png)\r\n\r\nOn top of this, if you add more basic tests, the time just seems to go up.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/5887290\/53284146-a9fb9e00-3758-11e9-9297-1a1bbc5e1184.png)\r\n\r\n## To Reproduce\r\n\r\nClone [my minimal repository](https:\/\/github.com\/cozmy\/jest-performance), `yarn install` and `yarn test`.\r\n\r\n## Expected behavior\r\n\r\nIt should be faster than this.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/cozmy\/jest-performance\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```\r\n  System:\r\n    OS: Windows 10\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz\r\n  Binaries:\r\n    Node: 8.12.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.13.0 - C:\\Users\\CosminCristian\\AppData\\Roaming\\npm\\yarn.CMD\r\n    npm: 6.8.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n```\r\n","comments":["Your repo takes way less time for me:\r\n4ms test case\r\n0.7s according to jest\r\n1.4s according to `time`\r\nReruns are pretty much instant.\r\n\r\nOn Windows, startup performance (of any Node process and especially if you do a lot of IO) will always be noticeably slower. You can try upgrading the Node version to 10 or 11 (8 is quite old), I'd expect a 10-20% speedup coming from that.\r\nI'd try to profile the performance issue a bit, but I can't reproduce the terrible performance on my systems :\/","Test: 8-10ms\r\nTotal: 2.4-2.8s\r\n\r\nReruns are very erratic if the rerun was triggered by a file change:\r\n\r\nTest: 2-14ms\r\nTotal: 0.8-3.3s (typically on the upper end though, <2.5s is uncommon).\r\n\r\nIf it was triggered manually then it is pretty consistent with the first run. Interestingly, if I run with `--no-cache` then the first run is similar, but reruns on file changes are 0.8-0.9s and manual reruns are <0.2s.  I think this might be because it throws away the timings of each run and causes Jest to run in-band (no extra workers). I usually run in-band on Windows because it's nearly always the fastest option, at least in watch mode. In WSL the performance is not quite as bad (though well short of native Linux) so I typically let Jest do whatever it wants.\r\n\r\nAs a side note, my runs seems to have been quite a bit faster than yours despite this machine having pretty dated hardware. That's pretty strange in itself.\r\n\r\n```\r\n  System:\r\n    OS: Windows 8.1\r\n    CPU: x64 Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz\r\n  Binaries:\r\n    Node: 8.11.3\r\n    Yarn: 1.7.0\r\n    npm: 5.6.0\r\n  npmPackages:\r\n    jest:\r\n      wanted: ^24.1.0\r\n      installed: 24.1.0\r\n```","To give you a bit of background, I was trying to set up the test environment on my work laptop and I noticed that my React tests were way to slow. That's when I've discovered the poor performance. I've also tested this on Linux and it's 2x as fast, but still, 3seconds on re-run for some basic tests it's too much.\r\n\r\nIt's weird that Jest reports that a test runs in 10ms but the reported time is 5seconds.\r\n\r\nEven on my work laptop, running the tests on create-react-app are slow, on re-run:\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/5887290\/53322147-ccb5c000-38da-11e9-9097-dd5da804d558.png)\r\n\r\nI guess this issue is a duplicate of https:\/\/github.com\/facebook\/jest\/issues\/7619 and https:\/\/github.com\/facebook\/jest\/issues\/6694 so most likely it can be closed.","Mocha doesn't take 4 seconds to initialise in this case. I changed your test to do `require('assert').equal(1, 112)` and it took less than 200ms:\r\n\r\n```\r\nfabio@fabio-thinkpad \u2665  time mocha index.spec.js \r\n\r\n\r\n  jest performance\r\n    1) should be fast\r\n\r\n\r\n  0 passing (6ms)\r\n  1 failing\r\n\r\n  1) jest performance\r\n       should be fast:\r\n\r\n      AssertionError [ERR_ASSERTION]: 1 == 112\r\n      + expected - actual\r\n\r\n      -1\r\n      +112\r\n      \r\n      at Context.<anonymous> (index.spec.js:3:23)\r\n\r\n\r\n\r\n\r\nreal    0m0.173s\r\nuser    0m0.153s\r\nsys     0m0.024s\r\n```\r\n\r\nWhich by the way, if you add another test it doesn't take 173ms * 2 to run.\r\n\r\nI've never seen a testing framework that takes more than 500ms to perform a single equality check. There must be some configuration option we can set here, and if there is, I would like to make the case for it to be in the defaults.","Just copied the original test 50 times to make sure. Results:\r\n\r\n```\r\nreal    0m0.193s\r\nuser    0m0.157s\r\nsys     0m0.040s\r\n```","Tests run fine for me. \r\n\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/18214059\/53694524-0e6acd00-3deb-11e9-9555-e7e73b3dc5cf.png)\r\n","I tried this out on my Mac and got run times of 3-4s, so a bit closer to what you are describing. There is nothing that takes way longer than expected in the profile though, as I said it's just that IO performance is very OS-dependent, most of this is `require` loading modules:\r\n![image](https:\/\/user-images.githubusercontent.com\/16069751\/53695319-2c6c0980-3dba-11e9-8d5b-1252fbe6248a.png)\r\nOne thing caught my eye in the flame chart though\r\n![image](https:\/\/user-images.githubusercontent.com\/16069751\/53695373-304c5b80-3dbb-11e9-99d2-a3eb60fb75b5.png)\r\nSetting up a JSDOM environment is very expensive (the middle part of the chart). Setting `testEnvironment` to `node` if the tests don't need it cut the test time in half for me. I find it a bit unfortunate that the default is `jsdom`. @SimenB has there been any discussion on the default `testEnvironment`?","Also, I noticed that watch mode is not running `inBand`, which I think it should in this case. After setting the test environment to node *and* passing `--watchAll --runInBand` reruns are pretty much instant. I'll try to find out by Jest doesn't decide to `runInBand` automatically in this case.",">@SimenB has there been any discussion on the default testEnvironment?\r\n\r\nYes, #5815. If you use `jest --init`, it defaults to `node` as well. I'd forgotten #5815 was accepted, would be nice to get done for 25.","After some investigation, the reason why Jest does not run the test `inBand` is the following:\r\n* On the first run, we do not know whether the one test will be fast, so we decide not to `runInBand` in order to keep the main thread unblocked and make sure the TTY remains responsive\r\n* Because this first run is not `inBand`, the overhead causes it to take about 2.2s on my device (even without JSDOM)\r\n* On rerun, Jest sees that the test took longer than 1s (the current `SLOW_TEST_TIME` threshold), so it again decides not to `runInBand`\r\n* You will never get out of this until you force `runInBand` once (and do one rerun, because the first `runInBand` execution also has to load everything which is slow), which causes the test time to go down to <100ms\r\n\r\nI don't have a good solution to this other than making the threshold more generous right now",">Because this first run is not inBand, the overhead causes it to take about 2.2s on my device (even without JSDOM)\r\n\r\nCan you test with node worker threads? Still some overhead, but maybe not so much","@SimenB no noticeable change. `jasmine2()` has 1.5s total time when it initially requires all the modules, it's not really the worker overhead itself. In band the modules will be loaded after the first run so subsequent runs are almost instant.","(`jest-circus` is not significantly faster to load either)","There's no mechanism in place to reuse workers across watch runs, is there? Would it be unsafe to do so in case there is some kind of leftover state in the worker?","Workers are always reused, do you mean the sandbox? If so, no - we want every test to run in isolation\r\n\r\nHowever, we want to lift jasmine\/circus out of the sandbox and inject some integration points. Might help?","> Workers are always reused\r\n\r\nThat's not what I'm seeing though, this is the first part of a rerun:\r\n![image](https:\/\/user-images.githubusercontent.com\/16069751\/53696942-fe8fc080-3dcb-11e9-90d5-b0e20f196de3.png)\r\n","This is (like some other issues mentioned) definitely a regression introduced in 23.0.0\r\nIn 22.4.4, `jasmine2()` only takes about 600ms (less than half the time)","That should be fixed - the worker pool should be reused.\r\n\r\nCould you bisect?","Will do, but it's not what causes the performance issue here. After quite a bit of profiling I've determined the culprit to be `micromatch@3`. I'll open a PR where we can discuss how to handle this.",">I've determined the culprit to be `micromatch@3`\r\n\r\nReally? Interesting! Looking forward to the analysis \ud83d\ude42 ","Still no conclusion? :( ","See #8032 \/ #8046 for the latest info","any updates now that `micromatch@4` has released?","Seeing as it's a major, we'll probably upgrade in Jest 25 to be on the safe side","@SimenB i took a look in diagonal to all the posts @jeysal posted. great work!!\r\n\r\nquestions\r\n1. Can we put this micromatch fix at the begginning of the work for jest25? so we can play with it and see if it cover the major problem present on windows machines or needs more investigations?\r\n\r\n2. You have a branch `next` for futur release or it's `master` to contain the micromatch fix ?","Assuming no breaking changes, you can use yarn resolutions to test yourself.\r\n\r\nhttps:\/\/yarnpkg.com\/lang\/en\/docs\/selective-version-resolutions\/","I've been using yarn resolutions + micromatch v4 with no issues.","@jeysal well done!\r\n\r\nA little followup my side with a repo test.\r\nhttps:\/\/github.com\/nasreddineskandrani\/benchmark_jest\r\nI took the initial code of this issue and did the test. It's working near jest@22 perf. if not better with micromatch4 and jest@24 so for me => it's conclusive. (check README(s)) \r\n\r\nwaiting for jest@25 to try it at the job with Angular and npm (no way to yarn for now...)we have more than 2000 utests :) it ll be quick to see the diff.\r\n\r\n-----------------------\r\n\r\n@SimenB an idea:\r\nyou should add an automated test to check the timing it takes in your CI with the previous released version vs the current branch of jest (or one run nightly against master). \r\nLet say if its more than 2x the previous time you fail it. I don't know if this way it will be a stable test => but jest needs a benchmark automation :)\r\n\r\n\r\n","would be nice to have the ability to see how long each test takes. ","Looks like `micromatch` was bumped to `4.x` in https:\/\/github.com\/facebook\/jest\/pull\/8852","Correct - you can install `jest@next` to test it out","Tried v25 with https:\/\/www.npmjs.com\/package\/@angular-builders\/jest. Didn't help.","The `next` version actually made tests run even longer in my case.","I'm still noticing a performance hit on both memory and execution time with `jest@next`.\r\n\r\n**Peak Memory Usage (jest@23.6.0)**\r\n<img width=\"541\" alt=\"jest-memory-23 6 0\" src=\"https:\/\/user-images.githubusercontent.com\/2489149\/64294335-63ff6e00-cf23-11e9-8917-907ba82503a0.png\">\r\n\r\n**Peak Memory Usage (jest@next)**\r\n<img width=\"540\" alt=\"jest-memory-next\" src=\"https:\/\/user-images.githubusercontent.com\/2489149\/64294344-6bbf1280-cf23-11e9-9c80-347a88f8d91a.png\">\r\n\r\n\r\n**Execution Time (jest@23.6.0)**\r\n```\r\nreal\t4m11.202s\r\nuser\t24m26.390s\r\nsys\t2m28.008s\r\n```\r\n\r\n**Execution Time (jest@next)**\r\n```\r\nreal\t7m29.054s\r\nuser\t38m46.197s\r\nsys\t6m17.779s\r\n```\r\n\r\nAny tips on profiling this further? Perhaps a dependency of `jest` is still using `micromatch@3.x` which is why the yarn `resolution` method fixed it for other people? The following `jest` dependencies are still tied to `micromatch@3.x`:\r\n\r\n- `test-exclude@5.2.3` (part of `@jest\/transform@25.0.0`)\r\n- `sane@4.0.3` (part of `jest-haste-map@^25.0.0`)\r\n\r\nFor added context, my upgrade from `23.6.0` to `next` requires a `jest.config.js` change that looks like:\r\n```\r\nsetupTestFrameworkScriptFile: '<rootDir>\/test-utils\/jest.setup.js',\r\n```\r\nto \r\n```\r\nsetupFilesAfterEnv: [\r\n    '<rootDir>\/node_modules\/regenerator-runtime\/runtime.js', \r\n    '<rootDir>\/test-utils\/jest.setup.js'\r\n],\r\n```\r\nSo it's also possible there are other factors in play with my performance numbers.","And just for more information, here is my run with `jest@next` and the `yarn` resolution for `micromatch@4.0.2`:\r\n\r\n**Peak Memory Usage (jest@next w\/ micromatch@4.0.2 resolution):**\r\n<img width=\"543\" alt=\"jest-memory-next-with-resolution\" src=\"https:\/\/user-images.githubusercontent.com\/2489149\/64296085-eee26780-cf27-11e9-84d8-3b5fa7f48176.png\">\r\nNote: Memory usage does go down and plateau around 600mb though.\r\n\r\n**Execution Time (jest@next w\/ micromatch@4.0.2 resolution):**\r\n```\r\nreal\t5m45.275s\r\nuser\t28m0.123s\r\nsys\t5m25.041s\r\n```","@j3tan one regression has been identified and fixed in #8890, diffs for `patch-package` can be found in https:\/\/github.com\/facebook\/jest\/issues\/7811#issuecomment-527107215. Could you test with those?\r\n\r\n`sane` has an issue for Micromatch 4 here: https:\/\/github.com\/amasad\/sane\/issues\/151\r\n`test-exclude` seems to have replaced `micromatch` with `minimatch` a year ago: https:\/\/github.com\/istanbuljs\/istanbuljs\/commit\/01096aedc7c6a2615028bfab6e86202290514861#diff-d812e77478dc2316c1698d88682d3b05R37\r\n\r\nYou can run `yarn why micromatch` in your project to identify where it comes from. Running it on a clean install of `jest@next` gives this output:\r\n\r\n```\r\n[1\/4] \ud83e\udd14  Why do we have the module \"micromatch\"...?\r\n[2\/4] \ud83d\ude9a  Initialising dependency graph...\r\n[3\/4] \ud83d\udd0d  Finding dependency...\r\n[4\/4] \ud83d\udea1  Calculating file sizes...\r\n=> Found \"micromatch@4.0.2\"\r\ninfo Has been hoisted to \"micromatch\"\r\ninfo Reasons this module exists\r\n   - Hoisted from \"jest#jest-cli#@jest#core#micromatch\"\r\n   - Hoisted from \"jest#jest-cli#jest-config#micromatch\"\r\n   - Hoisted from \"jest#jest-cli#@jest#core#@jest#transform#micromatch\"\r\n   - Hoisted from \"jest#jest-cli#@jest#core#jest-haste-map#micromatch\"\r\n   - Hoisted from \"jest#jest-cli#@jest#core#jest-message-util#micromatch\"\r\ninfo Disk size without dependencies: \"72KB\"\r\ninfo Disk size with unique dependencies: \"256KB\"\r\ninfo Disk size with transitive dependencies: \"404KB\"\r\ninfo Number of shared dependencies: 7\r\n=> Found \"sane#micromatch@3.1.10\"\r\ninfo Reasons this module exists\r\n   - \"jest#jest-cli#@jest#core#jest-haste-map#sane\" depends on it\r\n   - Hoisted from \"jest#jest-cli#@jest#core#jest-haste-map#sane#anymatch#micromatch\"\r\ninfo Disk size without dependencies: \"108KB\"\r\ninfo Disk size with unique dependencies: \"1.91MB\"\r\ninfo Disk size with transitive dependencies: \"4.48MB\"\r\ninfo Number of shared dependencies: 29\r\n```\r\n\r\nSo as soon as `sane` updates it should be gone from the dependency tree","Thanks for the feedback, I misread the diff in my upgrade for `test-exclude`\r\n\r\nHere is my `yarn why micromatch`:\r\n```\r\n=> Found \"micromatch@3.1.10\"\r\ninfo Has been hoisted to \"micromatch\"\r\ninfo Reasons this module exists\r\n   - Hoisted from \"readdirp#micromatch\"\r\n   - Hoisted from \"add-asset-html-webpack-plugin#micromatch\"\r\n   - Hoisted from \"anymatch#micromatch\"\r\n   - Hoisted from \"webpack#micromatch\"\r\n   - Hoisted from \"webpack-cli#findup-sync#micromatch\"\r\n   - Hoisted from \"globby#fast-glob#micromatch\"\r\n   - Hoisted from \"stylelint-config-rational-order#stylelint#micromatch\"\r\n   - Hoisted from \"jest#jest-cli#@jest#core#jest-haste-map#sane#micromatch\"\r\n```\r\nLooks like I'll have to wait for `sane` to upgrade to verify, though I may try out `https:\/\/yarnpkg.com\/lang\/en\/docs\/selective-version-resolutions\/` targeting `sane` if I have the chance","Running with the `patch-package` fix you mentioned yielded good results!\r\n```\r\nreal\t2m47.592s\r\nuser\t15m9.926s\r\nsys\t1m31.482s\r\n```\r\nMemory usage still peaked around 800MB per `node` process though.\r\n","And what to do for npm users?)","NPM users can still use https:\/\/www.npmjs.com\/package\/patch-package\r\n\r\nYou can either downgrade to `jest@23.6.0`, use `patch-package` with the diff found here https:\/\/github.com\/facebook\/jest\/issues\/7811#issuecomment-527107215, or wait for https:\/\/github.com\/facebook\/jest\/pull\/8890 to merge and use `jest@next`\r\n\r\nEdit: https:\/\/github.com\/facebook\/jest\/pull\/8890 is merged but has not been released yet, please wait for an official announcement before trying to use `jest@next`. Follow along in this issue instead (https:\/\/github.com\/facebook\/jest\/issues\/7811#issuecomment-529203848)","So #8890 was merged, but nothing has changed(","@romua it's merged, but not released yet. Patience.","Makes a lot of sense. Thanks for the answer) ","@thymikee any updates?)","\"jest\": \"^25.0.0\" still sooo slooooooow, subsequent save\/test 7.89s.\r\nOne file 4 simple asserts.\r\n\"test\": \"jest --watch -- calc.test.js\"\r\n--runInBand does not make significant difference. 4.29s \r\n\r\nTried also:  \"test\": \"jest --watch --runInBand --env=node -- calc.spec.js\"no change.\r\n\r\nIn comparison `jasmin` => 1s and `mocha` blazing fast => 50ms - 500ms ...\r\n\r\n","It takes a long time for very simple tests\r\n<img width=\"299\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/6115911\/73530537-8a8bdd00-43cd-11ea-9b89-926b0b89a81f.png\">\r\n\r\njest: v25.1.0\r\n\r\nIt is undeterministic though, sometime it completes within 2s.","experiencing the same issue with     \"jest\": \"^25.1.0\",","The main startup delay seems to come from require()-ing all the dependencies.\r\n\r\n`time-require` reports around 10 seconds worth of require() calls on my current system.\r\n\r\nMain culprits, according to that tool are:\r\n\r\n* babel - this might just be specific to my setup (`@babel\/preset-env` takes 3.6 seconds)\r\n* jsdom - 1.2 seconds in isolation\r\n* sane - 0.5 seconds in isolation, most of which is caused by micromatch 3.\r\n\r\nFor JSDOM, there is already some work for cutting down dependencies and thus improving load times. They also have an active issue regarding `request`, which takes my machine .25 seconds to load. \r\n\r\nAn actionable item for the jest team might be replacing `sane`. ","I'm trying to do some looking into this and when I profile a suite of 100 example tests (which takes a bit over 8s w\/ `jest --runInBand`, and about 1.5s w\/ mocha), I see that `vm`'s `compileFunction` is taking most of the time. \r\n\r\nAs far as I can tell, it's called for over 700 modules for *each* test file. Below is the list of files. Pretty much all of these are files I would not want to be loaded more than once.\r\n\r\nIs there a way to disable the registry isolation for tests? (I realize this will break mocking and I am quite okay with that).\r\n\r\nAlso timing and files compiled are pretty much identical w\/ and w\/o jest-circus.\r\n\r\n<details>\r\n<summary>files<\/summary>\r\n\r\n```\r\napp\/node_modules\/source-map-support\/source-map-support.js\r\napp\/node_modules\/source-map\/source-map.js\r\napp\/node_modules\/source-map\/lib\/source-map-generator.js\r\napp\/node_modules\/source-map\/lib\/base64-vlq.js\r\napp\/node_modules\/source-map\/lib\/base64.js\r\napp\/node_modules\/source-map\/lib\/util.js\r\napp\/node_modules\/source-map\/lib\/array-set.js\r\napp\/node_modules\/source-map\/lib\/mapping-list.js\r\napp\/node_modules\/source-map\/lib\/source-map-consumer.js\r\napp\/node_modules\/source-map\/lib\/binary-search.js\r\napp\/node_modules\/source-map\/lib\/quick-sort.js\r\napp\/node_modules\/source-map\/lib\/source-node.js\r\napp\/node_modules\/buffer-from\/index.js\r\napp\/node_modules\/jest-circus\/build\/legacy-code-todo-rewrite\/jestAdapterInit.js\r\napp\/node_modules\/@jest\/test-result\/build\/index.js\r\napp\/node_modules\/@jest\/test-result\/build\/formatTestResults.js\r\napp\/node_modules\/@jest\/test-result\/build\/helpers.js\r\napp\/node_modules\/expect\/build\/index.js\r\napp\/node_modules\/jest-matcher-utils\/build\/index.js\r\napp\/node_modules\/chalk\/source\/index.js\r\napp\/node_modules\/ansi-styles\/index.js\r\napp\/node_modules\/supports-color\/index.js\r\napp\/node_modules\/supports-color\/node_modules\/has-flag\/index.js\r\napp\/node_modules\/chalk\/source\/util.js\r\napp\/node_modules\/jest-diff\/build\/index.js\r\napp\/node_modules\/pretty-format\/build\/index.js\r\napp\/node_modules\/pretty-format\/build\/collections.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/AsymmetricMatcher.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/ConvertAnsi.js\r\napp\/node_modules\/pretty-format\/node_modules\/ansi-regex\/index.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/DOMCollection.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/DOMElement.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/lib\/markup.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/lib\/escapeHTML.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/Immutable.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/ReactElement.js\r\napp\/node_modules\/react-is\/index.js\r\napp\/node_modules\/react-is\/cjs\/react-is.development.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/ReactTestComponent.js\r\napp\/node_modules\/jest-get-type\/build\/index.js\r\napp\/node_modules\/jest-diff\/build\/cleanupSemantic.js\r\napp\/node_modules\/jest-diff\/build\/diffLines.js\r\napp\/node_modules\/diff-sequences\/build\/index.js\r\napp\/node_modules\/jest-diff\/build\/normalizeDiffOptions.js\r\napp\/node_modules\/jest-diff\/build\/printDiffs.js\r\napp\/node_modules\/jest-diff\/build\/diffStrings.js\r\napp\/node_modules\/jest-diff\/build\/getAlignedDiffs.js\r\napp\/node_modules\/jest-diff\/build\/joinAlignedDiffs.js\r\napp\/node_modules\/jest-diff\/build\/constants.js\r\napp\/node_modules\/jest-matcher-utils\/build\/Replaceable.js\r\napp\/node_modules\/jest-matcher-utils\/build\/deepCyclicCopyReplaceable.js\r\napp\/node_modules\/expect\/build\/utils.js\r\napp\/node_modules\/expect\/build\/jasmineUtils.js\r\napp\/node_modules\/expect\/build\/matchers.js\r\napp\/node_modules\/expect\/build\/print.js\r\napp\/node_modules\/expect\/build\/spyMatchers.js\r\napp\/node_modules\/expect\/build\/toThrowMatchers.js\r\napp\/node_modules\/jest-message-util\/build\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/micromatch\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/stringify.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/utils.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/compile.js\r\napp\/node_modules\/jest-message-util\/node_modules\/fill-range\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/to-regex-range\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/is-number\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/expand.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/parse.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/constants.js\r\napp\/node_modules\/picomatch\/index.js\r\napp\/node_modules\/picomatch\/lib\/picomatch.js\r\napp\/node_modules\/picomatch\/lib\/scan.js\r\napp\/node_modules\/picomatch\/lib\/utils.js\r\napp\/node_modules\/picomatch\/lib\/constants.js\r\napp\/node_modules\/picomatch\/lib\/parse.js\r\napp\/node_modules\/slash\/index.js\r\napp\/node_modules\/@babel\/code-frame\/lib\/index.js\r\napp\/node_modules\/@babel\/highlight\/lib\/index.js\r\napp\/node_modules\/js-tokens\/index.js\r\napp\/node_modules\/@babel\/helper-validator-identifier\/lib\/index.js\r\napp\/node_modules\/@babel\/helper-validator-identifier\/lib\/identifier.js\r\napp\/node_modules\/@babel\/helper-validator-identifier\/lib\/keyword.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/chalk\/index.js\r\napp\/node_modules\/escape-string-regexp\/index.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/ansi-styles\/index.js\r\napp\/node_modules\/color-convert\/index.js\r\napp\/node_modules\/color-convert\/conversions.js\r\napp\/node_modules\/color-convert\/node_modules\/color-name\/index.js\r\napp\/node_modules\/color-convert\/route.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/supports-color\/index.js\r\napp\/node_modules\/has-flag\/index.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/chalk\/templates.js\r\napp\/node_modules\/stack-utils\/index.js\r\napp\/node_modules\/expect\/build\/asymmetricMatchers.js\r\napp\/node_modules\/expect\/build\/jestMatchersObject.js\r\napp\/node_modules\/expect\/build\/extractExpectedAssertionsErrors.js\r\napp\/node_modules\/jest-snapshot\/build\/index.js\r\napp\/node_modules\/jest-snapshot\/build\/snapshot_resolver.js\r\napp\/node_modules\/jest-snapshot\/build\/State.js\r\napp\/node_modules\/jest-snapshot\/build\/utils.js\r\napp\/node_modules\/make-dir\/index.js\r\napp\/node_modules\/semver\/semver.js\r\napp\/node_modules\/natural-compare\/index.js\r\napp\/node_modules\/jest-snapshot\/build\/plugins.js\r\napp\/node_modules\/jest-snapshot\/build\/mock_serializer.js\r\napp\/node_modules\/jest-snapshot\/build\/inline_snapshots.js\r\napp\/node_modules\/@babel\/types\/lib\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/react\/isReactComponent.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/buildMatchMemberExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/matchesPattern.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/utils\/shallowEqual.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/react\/isCompatTag.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/react\/buildChildren.js\r\napp\/node_modules\/@babel\/types\/lib\/utils\/react\/cleanJSXElementLiteralChild.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/builder.js\r\napp\/node_modules\/lodash\/clone.js\r\napp\/node_modules\/lodash\/_baseClone.js\r\napp\/node_modules\/lodash\/_Stack.js\r\napp\/node_modules\/lodash\/_ListCache.js\r\napp\/node_modules\/lodash\/_listCacheClear.js\r\napp\/node_modules\/lodash\/_listCacheDelete.js\r\napp\/node_modules\/lodash\/_assocIndexOf.js\r\napp\/node_modules\/lodash\/eq.js\r\napp\/node_modules\/lodash\/_listCacheGet.js\r\napp\/node_modules\/lodash\/_listCacheHas.js\r\napp\/node_modules\/lodash\/_listCacheSet.js\r\napp\/node_modules\/lodash\/_stackClear.js\r\napp\/node_modules\/lodash\/_stackDelete.js\r\napp\/node_modules\/lodash\/_stackGet.js\r\napp\/node_modules\/lodash\/_stackHas.js\r\napp\/node_modules\/lodash\/_stackSet.js\r\napp\/node_modules\/lodash\/_Map.js\r\napp\/node_modules\/lodash\/_getNative.js\r\napp\/node_modules\/lodash\/_baseIsNative.js\r\napp\/node_modules\/lodash\/isFunction.js\r\napp\/node_modules\/lodash\/_baseGetTag.js\r\napp\/node_modules\/lodash\/_Symbol.js\r\napp\/node_modules\/lodash\/_root.js\r\napp\/node_modules\/lodash\/_freeGlobal.js\r\napp\/node_modules\/lodash\/_getRawTag.js\r\napp\/node_modules\/lodash\/_objectToString.js\r\napp\/node_modules\/lodash\/isObject.js\r\napp\/node_modules\/lodash\/_isMasked.js\r\napp\/node_modules\/lodash\/_coreJsData.js\r\napp\/node_modules\/lodash\/_toSource.js\r\napp\/node_modules\/lodash\/_getValue.js\r\napp\/node_modules\/lodash\/_MapCache.js\r\napp\/node_modules\/lodash\/_mapCacheClear.js\r\napp\/node_modules\/lodash\/_Hash.js\r\napp\/node_modules\/lodash\/_hashClear.js\r\napp\/node_modules\/lodash\/_nativeCreate.js\r\napp\/node_modules\/lodash\/_hashDelete.js\r\napp\/node_modules\/lodash\/_hashGet.js\r\napp\/node_modules\/lodash\/_hashHas.js\r\napp\/node_modules\/lodash\/_hashSet.js\r\napp\/node_modules\/lodash\/_mapCacheDelete.js\r\napp\/node_modules\/lodash\/_getMapData.js\r\napp\/node_modules\/lodash\/_isKeyable.js\r\napp\/node_modules\/lodash\/_mapCacheGet.js\r\napp\/node_modules\/lodash\/_mapCacheHas.js\r\napp\/node_modules\/lodash\/_mapCacheSet.js\r\napp\/node_modules\/lodash\/_arrayEach.js\r\napp\/node_modules\/lodash\/_assignValue.js\r\napp\/node_modules\/lodash\/_baseAssignValue.js\r\napp\/node_modules\/lodash\/_defineProperty.js\r\napp\/node_modules\/lodash\/_baseAssign.js\r\napp\/node_modules\/lodash\/_copyObject.js\r\napp\/node_modules\/lodash\/keys.js\r\napp\/node_modules\/lodash\/_arrayLikeKeys.js\r\napp\/node_modules\/lodash\/_baseTimes.js\r\napp\/node_modules\/lodash\/isArguments.js\r\napp\/node_modules\/lodash\/_baseIsArguments.js\r\napp\/node_modules\/lodash\/isObjectLike.js\r\napp\/node_modules\/lodash\/isArray.js\r\napp\/node_modules\/lodash\/isBuffer.js\r\napp\/node_modules\/lodash\/stubFalse.js\r\napp\/node_modules\/lodash\/_isIndex.js\r\napp\/node_modules\/lodash\/isTypedArray.js\r\napp\/node_modules\/lodash\/_baseIsTypedArray.js\r\napp\/node_modules\/lodash\/isLength.js\r\napp\/node_modules\/lodash\/_baseUnary.js\r\napp\/node_modules\/lodash\/_nodeUtil.js\r\napp\/node_modules\/lodash\/_baseKeys.js\r\napp\/node_modules\/lodash\/_isPrototype.js\r\napp\/node_modules\/lodash\/_nativeKeys.js\r\napp\/node_modules\/lodash\/_overArg.js\r\napp\/node_modules\/lodash\/isArrayLike.js\r\napp\/node_modules\/lodash\/_baseAssignIn.js\r\napp\/node_modules\/lodash\/keysIn.js\r\napp\/node_modules\/lodash\/_baseKeysIn.js\r\napp\/node_modules\/lodash\/_nativeKeysIn.js\r\napp\/node_modules\/lodash\/_cloneBuffer.js\r\napp\/node_modules\/lodash\/_copyArray.js\r\napp\/node_modules\/lodash\/_copySymbols.js\r\napp\/node_modules\/lodash\/_getSymbols.js\r\napp\/node_modules\/lodash\/_arrayFilter.js\r\napp\/node_modules\/lodash\/stubArray.js\r\napp\/node_modules\/lodash\/_copySymbolsIn.js\r\napp\/node_modules\/lodash\/_getSymbolsIn.js\r\napp\/node_modules\/lodash\/_arrayPush.js\r\napp\/node_modules\/lodash\/_getPrototype.js\r\napp\/node_modules\/lodash\/_getAllKeys.js\r\napp\/node_modules\/lodash\/_baseGetAllKeys.js\r\napp\/node_modules\/lodash\/_getAllKeysIn.js\r\napp\/node_modules\/lodash\/_getTag.js\r\napp\/node_modules\/lodash\/_DataView.js\r\napp\/node_modules\/lodash\/_Promise.js\r\napp\/node_modules\/lodash\/_Set.js\r\napp\/node_modules\/lodash\/_WeakMap.js\r\napp\/node_modules\/lodash\/_initCloneArray.js\r\napp\/node_modules\/lodash\/_initCloneByTag.js\r\napp\/node_modules\/lodash\/_cloneArrayBuffer.js\r\napp\/node_modules\/lodash\/_Uint8Array.js\r\napp\/node_modules\/lodash\/_cloneDataView.js\r\napp\/node_modules\/lodash\/_cloneRegExp.js\r\napp\/node_modules\/lodash\/_cloneSymbol.js\r\napp\/node_modules\/lodash\/_cloneTypedArray.js\r\napp\/node_modules\/lodash\/_initCloneObject.js\r\napp\/node_modules\/lodash\/_baseCreate.js\r\napp\/node_modules\/lodash\/isMap.js\r\napp\/node_modules\/lodash\/_baseIsMap.js\r\napp\/node_modules\/lodash\/isSet.js\r\napp\/node_modules\/lodash\/_baseIsSet.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/index.js\r\napp\/node_modules\/to-fast-properties\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/core.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/is.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isType.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isPlaceholderType.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isValidIdentifier.js\r\napp\/node_modules\/@babel\/types\/lib\/constants\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/utils.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/validate.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/es2015.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/flow.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/jsx.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/misc.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/placeholders.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/experimental.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/typescript.js\r\napp\/node_modules\/@babel\/types\/lib\/asserts\/assertNode.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isNode.js\r\napp\/node_modules\/@babel\/types\/lib\/asserts\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/flow\/createTypeAnnotationBasedOnTypeof.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/flow\/createUnionTypeAnnotation.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/flow\/removeTypeDuplicates.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneNode.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/clone.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneDeep.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneDeepWithoutLoc.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneWithoutLoc.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/addComment.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/addComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritInnerComments.js\r\napp\/node_modules\/@babel\/types\/lib\/utils\/inherit.js\r\napp\/node_modules\/lodash\/uniq.js\r\napp\/node_modules\/lodash\/_baseUniq.js\r\napp\/node_modules\/lodash\/_SetCache.js\r\napp\/node_modules\/lodash\/_setCacheAdd.js\r\napp\/node_modules\/lodash\/_setCacheHas.js\r\napp\/node_modules\/lodash\/_arrayIncludes.js\r\napp\/node_modules\/lodash\/_baseIndexOf.js\r\napp\/node_modules\/lodash\/_baseFindIndex.js\r\napp\/node_modules\/lodash\/_baseIsNaN.js\r\napp\/node_modules\/lodash\/_strictIndexOf.js\r\napp\/node_modules\/lodash\/_arrayIncludesWith.js\r\napp\/node_modules\/lodash\/_cacheHas.js\r\napp\/node_modules\/lodash\/_createSet.js\r\napp\/node_modules\/lodash\/noop.js\r\napp\/node_modules\/lodash\/_setToArray.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritLeadingComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritsComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritTrailingComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/removeComments.js\r\napp\/node_modules\/@babel\/types\/lib\/constants\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/ensureBlock.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toBlock.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toBindingIdentifierName.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toIdentifier.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toComputedKey.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toKeyAlias.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/removePropertiesDeep.js\r\napp\/node_modules\/@babel\/types\/lib\/traverse\/traverseFast.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/removeProperties.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toSequenceExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/gatherSequenceExpressions.js\r\napp\/node_modules\/@babel\/types\/lib\/retrievers\/getBindingIdentifiers.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toStatement.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/valueToNode.js\r\napp\/node_modules\/lodash\/isPlainObject.js\r\napp\/node_modules\/lodash\/isRegExp.js\r\napp\/node_modules\/lodash\/_baseIsRegExp.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/appendToMemberExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/inherits.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/prependToMemberExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/retrievers\/getOuterBindingIdentifiers.js\r\napp\/node_modules\/@babel\/types\/lib\/traverse\/traverse.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isBinding.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isBlockScoped.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isLet.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isImmutable.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isNodesEquivalent.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isReferenced.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isScope.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isSpecifierDefault.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isValidES3Identifier.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isVar.js\r\napp\/node_modules\/jest-snapshot\/build\/printSnapshot.js\r\napp\/node_modules\/jest-snapshot\/build\/colors.js\r\napp\/node_modules\/jest-snapshot\/build\/dedentLines.js\r\napp\/node_modules\/ansi-styles\/node_modules\/color-convert\/index.js\r\napp\/node_modules\/ansi-styles\/node_modules\/color-convert\/conversions.js\r\napp\/node_modules\/color-name\/index.js\r\napp\/node_modules\/ansi-styles\/node_modules\/color-convert\/route.js\r\napp\/node_modules\/throat\/index.js\r\napp\/node_modules\/jest-circus\/build\/state.js\r\napp\/node_modules\/jest-circus\/build\/types.js\r\napp\/node_modules\/jest-circus\/build\/utils.js\r\napp\/node_modules\/jest-util\/build\/index.js\r\napp\/node_modules\/jest-util\/build\/clearLine.js\r\napp\/node_modules\/jest-util\/build\/createDirectory.js\r\napp\/node_modules\/jest-util\/build\/ErrorWithStack.js\r\napp\/node_modules\/jest-util\/build\/installCommonGlobals.js\r\napp\/node_modules\/jest-util\/build\/createProcessObject.js\r\napp\/node_modules\/jest-util\/build\/deepCyclicCopy.js\r\napp\/node_modules\/jest-util\/build\/interopRequireDefault.js\r\napp\/node_modules\/jest-util\/build\/isInteractive.js\r\napp\/node_modules\/is-ci\/index.js\r\napp\/node_modules\/ci-info\/index.js\r\napp\/node_modules\/jest-util\/build\/isPromise.js\r\napp\/node_modules\/jest-util\/build\/setGlobal.js\r\napp\/node_modules\/jest-util\/build\/convertDescriptorToString.js\r\napp\/node_modules\/jest-util\/build\/specialChars.js\r\napp\/node_modules\/jest-util\/build\/replacePathSepForGlob.js\r\napp\/node_modules\/jest-util\/build\/testPathPatternToRegExp.js\r\napp\/node_modules\/jest-util\/build\/preRunMessage.js\r\napp\/node_modules\/jest-util\/build\/pluralize.js\r\napp\/node_modules\/is-generator-fn\/index.js\r\napp\/node_modules\/co\/index.js\r\napp\/node_modules\/jest-circus\/build\/eventHandler.js\r\napp\/node_modules\/jest-circus\/build\/globalErrorHandlers.js\r\napp\/node_modules\/jest-circus\/build\/formatNodeAssertErrors.js\r\napp\/node_modules\/jest-circus\/build\/run.js\r\napp\/node_modules\/jest-circus\/build\/index.js\r\napp\/node_modules\/jest-each\/build\/index.js\r\napp\/node_modules\/jest-each\/build\/bind.js\r\napp\/node_modules\/jest-each\/build\/table\/array.js\r\napp\/node_modules\/jest-each\/build\/table\/template.js\r\napp\/node_modules\/jest-each\/build\/validation.js\r\napp\/node_modules\/jest-circus\/build\/legacy-code-todo-rewrite\/jestExpect.js\r\napp\/test\/example-90.test.ts\r\napp\/node_modules\/source-map-support\/source-map-support.js\r\napp\/node_modules\/source-map\/source-map.js\r\napp\/node_modules\/source-map\/lib\/source-map-generator.js\r\napp\/node_modules\/source-map\/lib\/base64-vlq.js\r\napp\/node_modules\/source-map\/lib\/base64.js\r\napp\/node_modules\/source-map\/lib\/util.js\r\napp\/node_modules\/source-map\/lib\/array-set.js\r\napp\/node_modules\/source-map\/lib\/mapping-list.js\r\napp\/node_modules\/source-map\/lib\/source-map-consumer.js\r\napp\/node_modules\/source-map\/lib\/binary-search.js\r\napp\/node_modules\/source-map\/lib\/quick-sort.js\r\napp\/node_modules\/source-map\/lib\/source-node.js\r\napp\/node_modules\/buffer-from\/index.js\r\napp\/node_modules\/jest-circus\/build\/legacy-code-todo-rewrite\/jestAdapterInit.js\r\napp\/node_modules\/@jest\/test-result\/build\/index.js\r\napp\/node_modules\/@jest\/test-result\/build\/formatTestResults.js\r\napp\/node_modules\/@jest\/test-result\/build\/helpers.js\r\napp\/node_modules\/expect\/build\/index.js\r\napp\/node_modules\/jest-matcher-utils\/build\/index.js\r\napp\/node_modules\/chalk\/source\/index.js\r\napp\/node_modules\/ansi-styles\/index.js\r\napp\/node_modules\/supports-color\/index.js\r\napp\/node_modules\/supports-color\/node_modules\/has-flag\/index.js\r\napp\/node_modules\/chalk\/source\/util.js\r\napp\/node_modules\/jest-diff\/build\/index.js\r\napp\/node_modules\/pretty-format\/build\/index.js\r\napp\/node_modules\/pretty-format\/build\/collections.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/AsymmetricMatcher.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/ConvertAnsi.js\r\napp\/node_modules\/pretty-format\/node_modules\/ansi-regex\/index.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/DOMCollection.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/DOMElement.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/lib\/markup.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/lib\/escapeHTML.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/Immutable.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/ReactElement.js\r\napp\/node_modules\/react-is\/index.js\r\napp\/node_modules\/react-is\/cjs\/react-is.development.js\r\napp\/node_modules\/pretty-format\/build\/plugins\/ReactTestComponent.js\r\napp\/node_modules\/jest-get-type\/build\/index.js\r\napp\/node_modules\/jest-diff\/build\/cleanupSemantic.js\r\napp\/node_modules\/jest-diff\/build\/diffLines.js\r\napp\/node_modules\/diff-sequences\/build\/index.js\r\napp\/node_modules\/jest-diff\/build\/normalizeDiffOptions.js\r\napp\/node_modules\/jest-diff\/build\/printDiffs.js\r\napp\/node_modules\/jest-diff\/build\/diffStrings.js\r\napp\/node_modules\/jest-diff\/build\/getAlignedDiffs.js\r\napp\/node_modules\/jest-diff\/build\/joinAlignedDiffs.js\r\napp\/node_modules\/jest-diff\/build\/constants.js\r\napp\/node_modules\/jest-matcher-utils\/build\/Replaceable.js\r\napp\/node_modules\/jest-matcher-utils\/build\/deepCyclicCopyReplaceable.js\r\napp\/node_modules\/expect\/build\/utils.js\r\napp\/node_modules\/expect\/build\/jasmineUtils.js\r\napp\/node_modules\/expect\/build\/matchers.js\r\napp\/node_modules\/expect\/build\/print.js\r\napp\/node_modules\/expect\/build\/spyMatchers.js\r\napp\/node_modules\/expect\/build\/toThrowMatchers.js\r\napp\/node_modules\/jest-message-util\/build\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/micromatch\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/stringify.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/utils.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/compile.js\r\napp\/node_modules\/jest-message-util\/node_modules\/fill-range\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/to-regex-range\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/is-number\/index.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/expand.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/parse.js\r\napp\/node_modules\/jest-message-util\/node_modules\/braces\/lib\/constants.js\r\napp\/node_modules\/picomatch\/index.js\r\napp\/node_modules\/picomatch\/lib\/picomatch.js\r\napp\/node_modules\/picomatch\/lib\/scan.js\r\napp\/node_modules\/picomatch\/lib\/utils.js\r\napp\/node_modules\/picomatch\/lib\/constants.js\r\napp\/node_modules\/picomatch\/lib\/parse.js\r\napp\/node_modules\/slash\/index.js\r\napp\/node_modules\/@babel\/code-frame\/lib\/index.js\r\napp\/node_modules\/@babel\/highlight\/lib\/index.js\r\napp\/node_modules\/js-tokens\/index.js\r\napp\/node_modules\/@babel\/helper-validator-identifier\/lib\/index.js\r\napp\/node_modules\/@babel\/helper-validator-identifier\/lib\/identifier.js\r\napp\/node_modules\/@babel\/helper-validator-identifier\/lib\/keyword.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/chalk\/index.js\r\napp\/node_modules\/escape-string-regexp\/index.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/ansi-styles\/index.js\r\napp\/node_modules\/color-convert\/index.js\r\napp\/node_modules\/color-convert\/conversions.js\r\napp\/node_modules\/color-convert\/node_modules\/color-name\/index.js\r\napp\/node_modules\/color-convert\/route.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/supports-color\/index.js\r\napp\/node_modules\/has-flag\/index.js\r\napp\/node_modules\/@babel\/highlight\/node_modules\/chalk\/templates.js\r\napp\/node_modules\/stack-utils\/index.js\r\napp\/node_modules\/expect\/build\/asymmetricMatchers.js\r\napp\/node_modules\/expect\/build\/jestMatchersObject.js\r\napp\/node_modules\/expect\/build\/extractExpectedAssertionsErrors.js\r\napp\/node_modules\/jest-snapshot\/build\/index.js\r\napp\/node_modules\/jest-snapshot\/build\/snapshot_resolver.js\r\napp\/node_modules\/jest-snapshot\/build\/State.js\r\napp\/node_modules\/jest-snapshot\/build\/utils.js\r\napp\/node_modules\/make-dir\/index.js\r\napp\/node_modules\/semver\/semver.js\r\napp\/node_modules\/natural-compare\/index.js\r\napp\/node_modules\/jest-snapshot\/build\/plugins.js\r\napp\/node_modules\/jest-snapshot\/build\/mock_serializer.js\r\napp\/node_modules\/jest-snapshot\/build\/inline_snapshots.js\r\napp\/node_modules\/@babel\/types\/lib\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/react\/isReactComponent.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/buildMatchMemberExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/matchesPattern.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/utils\/shallowEqual.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/react\/isCompatTag.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/react\/buildChildren.js\r\napp\/node_modules\/@babel\/types\/lib\/utils\/react\/cleanJSXElementLiteralChild.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/builder.js\r\napp\/node_modules\/lodash\/clone.js\r\napp\/node_modules\/lodash\/_baseClone.js\r\napp\/node_modules\/lodash\/_Stack.js\r\napp\/node_modules\/lodash\/_ListCache.js\r\napp\/node_modules\/lodash\/_listCacheClear.js\r\napp\/node_modules\/lodash\/_listCacheDelete.js\r\napp\/node_modules\/lodash\/_assocIndexOf.js\r\napp\/node_modules\/lodash\/eq.js\r\napp\/node_modules\/lodash\/_listCacheGet.js\r\napp\/node_modules\/lodash\/_listCacheHas.js\r\napp\/node_modules\/lodash\/_listCacheSet.js\r\napp\/node_modules\/lodash\/_stackClear.js\r\napp\/node_modules\/lodash\/_stackDelete.js\r\napp\/node_modules\/lodash\/_stackGet.js\r\napp\/node_modules\/lodash\/_stackHas.js\r\napp\/node_modules\/lodash\/_stackSet.js\r\napp\/node_modules\/lodash\/_Map.js\r\napp\/node_modules\/lodash\/_getNative.js\r\napp\/node_modules\/lodash\/_baseIsNative.js\r\napp\/node_modules\/lodash\/isFunction.js\r\napp\/node_modules\/lodash\/_baseGetTag.js\r\napp\/node_modules\/lodash\/_Symbol.js\r\napp\/node_modules\/lodash\/_root.js\r\napp\/node_modules\/lodash\/_freeGlobal.js\r\napp\/node_modules\/lodash\/_getRawTag.js\r\napp\/node_modules\/lodash\/_objectToString.js\r\napp\/node_modules\/lodash\/isObject.js\r\napp\/node_modules\/lodash\/_isMasked.js\r\napp\/node_modules\/lodash\/_coreJsData.js\r\napp\/node_modules\/lodash\/_toSource.js\r\napp\/node_modules\/lodash\/_getValue.js\r\napp\/node_modules\/lodash\/_MapCache.js\r\napp\/node_modules\/lodash\/_mapCacheClear.js\r\napp\/node_modules\/lodash\/_Hash.js\r\napp\/node_modules\/lodash\/_hashClear.js\r\napp\/node_modules\/lodash\/_nativeCreate.js\r\napp\/node_modules\/lodash\/_hashDelete.js\r\napp\/node_modules\/lodash\/_hashGet.js\r\napp\/node_modules\/lodash\/_hashHas.js\r\napp\/node_modules\/lodash\/_hashSet.js\r\napp\/node_modules\/lodash\/_mapCacheDelete.js\r\napp\/node_modules\/lodash\/_getMapData.js\r\napp\/node_modules\/lodash\/_isKeyable.js\r\napp\/node_modules\/lodash\/_mapCacheGet.js\r\napp\/node_modules\/lodash\/_mapCacheHas.js\r\napp\/node_modules\/lodash\/_mapCacheSet.js\r\napp\/node_modules\/lodash\/_arrayEach.js\r\napp\/node_modules\/lodash\/_assignValue.js\r\napp\/node_modules\/lodash\/_baseAssignValue.js\r\napp\/node_modules\/lodash\/_defineProperty.js\r\napp\/node_modules\/lodash\/_baseAssign.js\r\napp\/node_modules\/lodash\/_copyObject.js\r\napp\/node_modules\/lodash\/keys.js\r\napp\/node_modules\/lodash\/_arrayLikeKeys.js\r\napp\/node_modules\/lodash\/_baseTimes.js\r\napp\/node_modules\/lodash\/isArguments.js\r\napp\/node_modules\/lodash\/_baseIsArguments.js\r\napp\/node_modules\/lodash\/isObjectLike.js\r\napp\/node_modules\/lodash\/isArray.js\r\napp\/node_modules\/lodash\/isBuffer.js\r\napp\/node_modules\/lodash\/stubFalse.js\r\napp\/node_modules\/lodash\/_isIndex.js\r\napp\/node_modules\/lodash\/isTypedArray.js\r\napp\/node_modules\/lodash\/_baseIsTypedArray.js\r\napp\/node_modules\/lodash\/isLength.js\r\napp\/node_modules\/lodash\/_baseUnary.js\r\napp\/node_modules\/lodash\/_nodeUtil.js\r\napp\/node_modules\/lodash\/_baseKeys.js\r\napp\/node_modules\/lodash\/_isPrototype.js\r\napp\/node_modules\/lodash\/_nativeKeys.js\r\napp\/node_modules\/lodash\/_overArg.js\r\napp\/node_modules\/lodash\/isArrayLike.js\r\napp\/node_modules\/lodash\/_baseAssignIn.js\r\napp\/node_modules\/lodash\/keysIn.js\r\napp\/node_modules\/lodash\/_baseKeysIn.js\r\napp\/node_modules\/lodash\/_nativeKeysIn.js\r\napp\/node_modules\/lodash\/_cloneBuffer.js\r\napp\/node_modules\/lodash\/_copyArray.js\r\napp\/node_modules\/lodash\/_copySymbols.js\r\napp\/node_modules\/lodash\/_getSymbols.js\r\napp\/node_modules\/lodash\/_arrayFilter.js\r\napp\/node_modules\/lodash\/stubArray.js\r\napp\/node_modules\/lodash\/_copySymbolsIn.js\r\napp\/node_modules\/lodash\/_getSymbolsIn.js\r\napp\/node_modules\/lodash\/_arrayPush.js\r\napp\/node_modules\/lodash\/_getPrototype.js\r\napp\/node_modules\/lodash\/_getAllKeys.js\r\napp\/node_modules\/lodash\/_baseGetAllKeys.js\r\napp\/node_modules\/lodash\/_getAllKeysIn.js\r\napp\/node_modules\/lodash\/_getTag.js\r\napp\/node_modules\/lodash\/_DataView.js\r\napp\/node_modules\/lodash\/_Promise.js\r\napp\/node_modules\/lodash\/_Set.js\r\napp\/node_modules\/lodash\/_WeakMap.js\r\napp\/node_modules\/lodash\/_initCloneArray.js\r\napp\/node_modules\/lodash\/_initCloneByTag.js\r\napp\/node_modules\/lodash\/_cloneArrayBuffer.js\r\napp\/node_modules\/lodash\/_Uint8Array.js\r\napp\/node_modules\/lodash\/_cloneDataView.js\r\napp\/node_modules\/lodash\/_cloneRegExp.js\r\napp\/node_modules\/lodash\/_cloneSymbol.js\r\napp\/node_modules\/lodash\/_cloneTypedArray.js\r\napp\/node_modules\/lodash\/_initCloneObject.js\r\napp\/node_modules\/lodash\/_baseCreate.js\r\napp\/node_modules\/lodash\/isMap.js\r\napp\/node_modules\/lodash\/_baseIsMap.js\r\napp\/node_modules\/lodash\/isSet.js\r\napp\/node_modules\/lodash\/_baseIsSet.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/index.js\r\napp\/node_modules\/to-fast-properties\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/core.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/is.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isType.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isPlaceholderType.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isValidIdentifier.js\r\napp\/node_modules\/@babel\/types\/lib\/constants\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/utils.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/validate.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/es2015.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/flow.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/jsx.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/misc.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/placeholders.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/experimental.js\r\napp\/node_modules\/@babel\/types\/lib\/definitions\/typescript.js\r\napp\/node_modules\/@babel\/types\/lib\/asserts\/assertNode.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isNode.js\r\napp\/node_modules\/@babel\/types\/lib\/asserts\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/flow\/createTypeAnnotationBasedOnTypeof.js\r\napp\/node_modules\/@babel\/types\/lib\/builders\/flow\/createUnionTypeAnnotation.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/flow\/removeTypeDuplicates.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneNode.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/clone.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneDeep.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneDeepWithoutLoc.js\r\napp\/node_modules\/@babel\/types\/lib\/clone\/cloneWithoutLoc.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/addComment.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/addComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritInnerComments.js\r\napp\/node_modules\/@babel\/types\/lib\/utils\/inherit.js\r\napp\/node_modules\/lodash\/uniq.js\r\napp\/node_modules\/lodash\/_baseUniq.js\r\napp\/node_modules\/lodash\/_SetCache.js\r\napp\/node_modules\/lodash\/_setCacheAdd.js\r\napp\/node_modules\/lodash\/_setCacheHas.js\r\napp\/node_modules\/lodash\/_arrayIncludes.js\r\napp\/node_modules\/lodash\/_baseIndexOf.js\r\napp\/node_modules\/lodash\/_baseFindIndex.js\r\napp\/node_modules\/lodash\/_baseIsNaN.js\r\napp\/node_modules\/lodash\/_strictIndexOf.js\r\napp\/node_modules\/lodash\/_arrayIncludesWith.js\r\napp\/node_modules\/lodash\/_cacheHas.js\r\napp\/node_modules\/lodash\/_createSet.js\r\napp\/node_modules\/lodash\/noop.js\r\napp\/node_modules\/lodash\/_setToArray.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritLeadingComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritsComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/inheritTrailingComments.js\r\napp\/node_modules\/@babel\/types\/lib\/comments\/removeComments.js\r\napp\/node_modules\/@babel\/types\/lib\/constants\/generated\/index.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/ensureBlock.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toBlock.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toBindingIdentifierName.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toIdentifier.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toComputedKey.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toKeyAlias.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/removePropertiesDeep.js\r\napp\/node_modules\/@babel\/types\/lib\/traverse\/traverseFast.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/removeProperties.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toSequenceExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/gatherSequenceExpressions.js\r\napp\/node_modules\/@babel\/types\/lib\/retrievers\/getBindingIdentifiers.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/toStatement.js\r\napp\/node_modules\/@babel\/types\/lib\/converters\/valueToNode.js\r\napp\/node_modules\/lodash\/isPlainObject.js\r\napp\/node_modules\/lodash\/isRegExp.js\r\napp\/node_modules\/lodash\/_baseIsRegExp.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/appendToMemberExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/inherits.js\r\napp\/node_modules\/@babel\/types\/lib\/modifications\/prependToMemberExpression.js\r\napp\/node_modules\/@babel\/types\/lib\/retrievers\/getOuterBindingIdentifiers.js\r\napp\/node_modules\/@babel\/types\/lib\/traverse\/traverse.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isBinding.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isBlockScoped.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isLet.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isImmutable.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isNodesEquivalent.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isReferenced.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isScope.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isSpecifierDefault.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isValidES3Identifier.js\r\napp\/node_modules\/@babel\/types\/lib\/validators\/isVar.js\r\napp\/node_modules\/jest-snapshot\/build\/printSnapshot.js\r\napp\/node_modules\/jest-snapshot\/build\/colors.js\r\napp\/node_modules\/jest-snapshot\/build\/dedentLines.js\r\napp\/node_modules\/ansi-styles\/node_modules\/color-convert\/index.js\r\napp\/node_modules\/ansi-styles\/node_modules\/color-convert\/conversions.js\r\napp\/node_modules\/color-name\/index.js\r\napp\/node_modules\/ansi-styles\/node_modules\/color-convert\/route.js\r\napp\/node_modules\/throat\/index.js\r\napp\/node_modules\/jest-circus\/build\/state.js\r\napp\/node_modules\/jest-circus\/build\/types.js\r\napp\/node_modules\/jest-circus\/build\/utils.js\r\napp\/node_modules\/jest-util\/build\/index.js\r\napp\/node_modules\/jest-util\/build\/clearLine.js\r\napp\/node_modules\/jest-util\/build\/createDirectory.js\r\napp\/node_modules\/jest-util\/build\/ErrorWithStack.js\r\napp\/node_modules\/jest-util\/build\/installCommonGlobals.js\r\napp\/node_modules\/jest-util\/build\/createProcessObject.js\r\napp\/node_modules\/jest-util\/build\/deepCyclicCopy.js\r\napp\/node_modules\/jest-util\/build\/interopRequireDefault.js\r\napp\/node_modules\/jest-util\/build\/isInteractive.js\r\napp\/node_modules\/is-ci\/index.js\r\napp\/node_modules\/ci-info\/index.js\r\napp\/node_modules\/jest-util\/build\/isPromise.js\r\napp\/node_modules\/jest-util\/build\/setGlobal.js\r\napp\/node_modules\/jest-util\/build\/convertDescriptorToString.js\r\napp\/node_modules\/jest-util\/build\/specialChars.js\r\napp\/node_modules\/jest-util\/build\/replacePathSepForGlob.js\r\napp\/node_modules\/jest-util\/build\/testPathPatternToRegExp.js\r\napp\/node_modules\/jest-util\/build\/preRunMessage.js\r\napp\/node_modules\/jest-util\/build\/pluralize.js\r\napp\/node_modules\/is-generator-fn\/index.js\r\napp\/node_modules\/co\/index.js\r\napp\/node_modules\/jest-circus\/build\/eventHandler.js\r\napp\/node_modules\/jest-circus\/build\/globalErrorHandlers.js\r\napp\/node_modules\/jest-circus\/build\/formatNodeAssertErrors.js\r\napp\/node_modules\/jest-circus\/build\/run.js\r\napp\/node_modules\/jest-circus\/build\/index.js\r\napp\/node_modules\/jest-each\/build\/index.js\r\napp\/node_modules\/jest-each\/build\/bind.js\r\napp\/node_modules\/jest-each\/build\/table\/array.js\r\napp\/node_modules\/jest-each\/build\/table\/template.js\r\napp\/node_modules\/jest-each\/build\/validation.js\r\napp\/node_modules\/jest-circus\/build\/legacy-code-todo-rewrite\/jestExpect.js\r\napp\/test\/example-42.test.ts\r\n```\r\n\r\n<\/details>","Adding `--runInBand` didn't help in my case. I have this in my package.json. Should I get an improvement?\r\n```\r\n  \"scripts\": {\r\n    \"test\": \"jest --runInBand\"\r\n  },\r\n```\r\nI was using Jasmine before when a frontend developer told me OMG you're not using Jest, you're so 2017! So I tried Jest and bam, now I wait 4 seconds for the simplest test.","> The main startup delay seems to come from require()-ing all the dependencies.\r\n> \r\n> `time-require` reports around 10 seconds worth of require() calls on my current system.\r\n> \r\n> Main culprits, according to that tool are:\r\n> \r\n> * babel - this might just be specific to my setup (`@babel\/preset-env` takes 3.6 seconds)\r\n> * jsdom - 1.2 seconds in isolation\r\n> * sane - 0.5 seconds in isolation, most of which is caused by micromatch 3.\r\n> \r\n> For JSDOM, there is already some work for cutting down dependencies and thus improving load times. They also have an active issue regarding `request`, which takes my machine .25 seconds to load.\r\n> \r\n> An actionable item for the jest team might be replacing `sane`.\r\n\r\nThis right here is the issue \u261d\ufe0f \r\n\r\nI really, _really_ wish Jest would provide an option not to reload the entire module tree on every single test suite. We write our code in a mostly pure style and do not use mutable global state so it is a complete waste for us to be reloading modules every time. And it is a _huge_ waste: a typical test suite in our code base takes 16 seconds to run, and < 1 second of that is running the actual test!","> > The main startup delay seems to come from require()-ing all the dependencies.\r\n> > `time-require` reports around 10 seconds worth of require() calls on my current system.\r\n> > Main culprits, according to that tool are:\r\n> > \r\n> > * babel - this might just be specific to my setup (`@babel\/preset-env` takes 3.6 seconds)\r\n> > * jsdom - 1.2 seconds in isolation\r\n> > * sane - 0.5 seconds in isolation, most of which is caused by micromatch 3.\r\n> > \r\n> > For JSDOM, there is already some work for cutting down dependencies and thus improving load times. They also have an active issue regarding `request`, which takes my machine .25 seconds to load.\r\n> > An actionable item for the jest team might be replacing `sane`.\r\n> \r\n> This right here is the issue \u261d\ufe0f\r\n> \r\n> I really, _really_ wish Jest would provide an option not to reload the entire module tree on every single test suite. We write our code in a mostly pure style and do not use mutable global state so it is a complete waste for us to be reloading modules every time. And it is a _huge_ waste: a typical test suite in our code base takes 16 seconds to run, and < 1 second of that is running the actual test!\r\n\r\nWhat are the team's intentions for moving forward? Will jest require minmum hardware specs or fix the issue?\r\n","I am wondering if it would cause any performance gain if we bundle Jest with all the dependencies in single file. For example using rollup. Will try to test this out using a `postinstall` script. Something similar Deno is doing when executing TypeScript code.","Back then, I was using Windows, and **I think the issue was from my Antivirus**. Running the same test again (the one from this repo: https:\/\/github.com\/cozmy\/jest-performance), on Ubuntu, I don't have any performance issues.","> Back then, I was using Windows, and **I think the issue was from my Antivirus**. Running the same test again (the one from this repo: https:\/\/github.com\/cozmy\/jest-performance), on Ubuntu, I don't have any performance issues.\r\n\r\nI experience this issue on a headless server and a macbook. The macbook is corporate property and does indeed have an antivirus, though i do not know to what extend that affects the performance, it certainly isn't an option for me to remove it.","@gtsop I'm experiencing the issue as well without anti-virus. For what it's worth, what @cozmy is referring to, if I'm not mistaken, is a slow-down related to applications that would suddenly create a ton of new files on disk (say, during a build process back in the days, with traditional C compilers creating hundreds or thousands of `.obj` files). The anti-virus would suddenly kick-in and attempt to scan them all for viruses, needlessly. The workaround, for example (and when possible), was to add an exception in the anti-virus for your build directory.","I know these kinds of numbers are not the gains many people here are looking for, but just to say that #7792 will (aside from the feature it introduces) improve speed by 1.05x~1.1x (benchmarked on 64 test files with a noop test case each, to measure overhead per test file) by loading `prettier` once per worker instead of once per test file. The numbers are on Linux and *could* be a bigger difference on Win\/macOS, but I haven't checked.\r\nI'm also looking at optimizing in other places using the same technique, perhaps I can achieve some other gains.\r\n\r\nAlso, switching from JSDOM to Node environment by default in Jest 27 will help a lot of people who were using JSDOM without realizing or needing it because JSDOM is still the biggest perf killer.","> JSDOM is still the biggest perf killer.\r\n\r\nThis is great insight, and I should know this because I've made some mad science with it in the past.\r\n\r\nDoes each test file get a `new JSDOM`, or is it require()d once for each?","> Does each test file get a `new JSDOM`, or is it require()d once for each?\r\n\r\nJust a `new JSDOM` per test file, `require('jsdom')` already happens only once per worker, so unfortunately no more room for optimization there.","I have significantly improved perfomance by:\r\n1. removing all enzyme imports (replaced by @testing-library\/react)\r\n2. switching default test environment to node (from jsdom)\r\n\r\nResults: from 50-60 secs to ~35 secs (with `-i` flag) \/ ~13 secs (without `-i` flag) ","> I have significantly improved perfomance by:\r\n> \r\n>     1. removing all enzyme imports (replaced by @testing-library\/react)\r\n> \r\n>     2. switching default test environment to node (from jsdom)\r\n> \r\n> \r\n> Results: from 50-60 secs to ~35 secs (with `-i` flag) \/ ~13 secs (without `-i` flag)\r\n\r\nVery interesting to explore if enzyme is significantly contributing to the performance penalty. In the project I have the biggest problem on I do use enzyme indeed, however I'm currently using testing-library and although faster, I still think it's not as fast as expected. So it could be the case that both jest and enzyme are contributing to this problem.","So I think apart from not using JSDOM if one does not need it (which will be a huge win to do by default for many people), there are two problems affecting this kind of test run that make it slow even on a warm cache.\r\nBoth of which are mostly down to the amount of I\/O operations done through `require`s, and both of which thus disproportionately affecting Windows and macOS users because I\/O is expensive there.\r\n\r\n1. Jest startup is slow, even when there are just a couple of files in the directory to scan (so I'm not talking about other issues people are having when scanning the directory takes a long time). This appears to be mostly due to the loading of all of Jest's modules and dependencies itself. Fortunately, this does not apply to reruns in watch mode.\r\nI think the main thing to explore to tackle this is shipping bundles of Jest+dependencies to reduce the number of I\/O operations needed. Unfortunately, for a project like Jest, I doubt this will be as trivial as writing a couple of lines of webpack config.\r\n\r\n2. Each test file introduces a lot of overhead, even when it does barely anything and does not run in JSDOM. This appears to be mostly due to the per-test file loading of some dependencies, like Babel, Prettier, Chalk, et cetera. This bit will become a lot better in Jest 27. I've now set up a Windows VM to benchmark in, and it seems `master` is already ~68% faster at this than `26.6.3`, mostly due to optimizations in #7792. Using the same kind of optimization applied elsewhere, after some quick hacks I think I can get it down to almost 100% faster than `26.6.3`. **Note that this you will almost certainly not see this amount of speedup on your tests.** For the repro at the top of this issue, I believe problem number 1) dominates. The changes in 27 will help you only if you have *a lot of very fast* test files. The benchmark was run on 500 almost-empty test files, to isolate the per-test file overhead impact.\r\nEdit: Looks like the numbers are more like `master` is ~50% faster at this than `26.6.3` and I expect to get it down to about ~70% faster at this than `26.6.3`.","I currently use Jest for integration testing (so each test file start a full server with a DB), after some profiling i notice that 50% of the test time is the require step.\r\n\r\n<img width=\"1684\" alt=\"Capture d\u2019e\u0301cran 2020-11-30 a\u0300 22 43 51\" src=\"https:\/\/user-images.githubusercontent.com\/27959372\/100669904-5fac4580-335e-11eb-8ad9-4c1f3e0e64a5.png\">\r\n\r\nFor integration testing, I only use the mock function for some specific packages (like `node-fetch`).\r\n\r\nIs there any way to optimize the `node_modules` resolution and may be get a massive speed improvement ?\r\n\r\nhere my jest config\r\n\r\n```js\r\nmodule.exports = {\r\n\ttestMatch: ['**\/*.test.ts'],\r\n\tmodulePathIgnorePatterns: ['<rootDir>\/node_modules\/'],\r\n\ttestTimeout: 60000,\r\n\tcoveragePathIgnorePatterns: ['\/node_modules\/', '.*.xtest.ts', '\/generated\/'],\r\n\tpreset: 'ts-jest',\r\n\ttestEnvironment: 'node',\r\n\tglobalSetup: '.\/jest\/setup.js',\r\n\tglobalTeardown: '.\/jest\/teardown.js',\r\n\tglobals: {\r\n\t\t'ts-jest': {\r\n\t\t\tbabelConfig: {\r\n\t\t\t\tcompact: false,\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n}\r\n```\r\n","this issue may come from ts-jest\r\n\r\ndepending on your use case, you can try different options for ts-jest (isolatedModules, run in band, etc.), upgrade ts-jest (perf improvement in last versions), or try an alternative loader, such as swc\r\n\r\n","@eltonio450 yeah At first I thought ts-jest was the source problem. \r\nBut thanks to TS, it's pretty simple to compile the project with tests ahead and then run jest without `ts-jest`.\r\nand unfortunately, the problem with the requireModule persists\r\n\r\nHere the profiler with pre compiled project\r\n<img width=\"1792\" alt=\"Capture d\u2019e\u0301cran 2020-12-01 a\u0300 08 31 06\" src=\"https:\/\/user-images.githubusercontent.com\/27959372\/100710660-4df38e00-33b0-11eb-9234-0dc7d8a01b7a.png\">\r\n","I tested the 27@next versions because I was curious about the performance work. I found a medium regression in a larger project (~30 to ~60 seconds slower) and decided to test it. I found a ~1 second regression in a very stripped down setup:\r\n\r\n| version    | average | median |\r\n|------------|---------|--------|\r\n| **26.6.3** |  8.90s   | 8.94s  |\r\n| 27-next.0  | 10.07s  | 9.98s  |\r\n| 27-next.1  | 10.03s  | 9.99s  |\r\n| 27-next.2  | 10.03s  | 9.99s  |\r\n\r\nMethodology:\r\n\r\n- Install the version of jest and babel-jest\r\n- Run `Measure-Command { npx jest benchmark }` 11 times\r\n- Discard the first run (inconsistently slower because caching)\r\n- Find average and median of the ten runs.\r\n\r\n\r\nSetup:\r\nOS: windows 10\r\nNode: 12.16.3\r\n\r\njest.config.js:\r\n```\r\nmodule.exports = {\r\n    transform: {\r\n        \"^.+\\\\.js$\": \"babel-jest\",\r\n    },\r\n    testEnvironment: \"node\",\r\n};\r\n```\r\n\r\nbenchmark.test.js:\r\n```\r\ndescribe(\"basic test\", () => {\r\n    it(\"asserts that A != B\", () => {\r\n        expect(\"A\").not.toBe(\"B\");\r\n    });\r\n});\r\n```\r\n\r\nI didn't run a full 10 samples for 27.0.0-next.3, but it didn't improve over next.2 in the 4 samples I ran.\r\n\r\n---\r\nEdit: I just tried to replicate this in a clean folder and there I found that not only does the test run significantly faster (~1 second instead of ~10 seconds), but also that jest 27 is slightly faster on average (5 - 10 %). The test runs above were made in an existing project folder, just restricting jest to the benchmark.test.js.","I tried upgrading from v24.9.0 to v26.6.3, and found a slight performance decrease (test suite went from about 17s to 20s).  Most of the extra time was at the beginning, there's still a solid 8 to 10 second delay before the first test starts running.  There was also an additional pause of about a second or two at the end, after reporting coverage stats, which wasn't there in the earlier version.\r\n\r\nI don't know much about profiling, but I read this thread with interest because I was hoping to get my front-end tests to run something closer to as fast as my backend (python) tests, which run in about 3s for an enormously larger and more complicated application.\r\n\r\nI run a Ubuntu VM on windows, node v12.20.0.","I too have been struggling with Jest performance on our production react app.  I have been working to try and implement a \"Red Green Refactor\" code workflow in our production code base, but the time taken to run tests severely impacts the ability to do this flow efficiently.\r\n\r\nI have created a repo to explore this further and try to find other options to improve the performance.  See https:\/\/github.com\/trenttobler\/ts-unit-test-loadtesting \r\n\r\nAlso in this project is second folder with identical tests, except using a mocha+chai+nyc setup to provide evidence that faster testing time should in theory be possible.\r\n\r\nI'm looking for any suggestions on strategies or approaches that can be applied to this project, specifically, to get the jest run time to somewhat closer to mocha.  This test repository \/ suite is large (~27K individual assertions), but simulates the scope and raw test counts I'm targeting in our production app.\r\n\r\n* jest takes ~15s to run the tests on my machine.\r\n* mocha+chai takes ~4s to run the tests on my machine.\r\n* our production app, with similar range of test suite size, takes 20+ s after all possible improvements I have been able to find online -- I started from a baseline 60+ s run time.\r\n\r\nNote: I created the jest test folder using `npx create-react-app . --template typescript`, followed by adding the stub file, and `loadtest` folders.  I did not remove the existing sample tests created by this template, but do not believe removing them would improve much the actual timings.  Also, the functionality demonstrated in this sample is useful, as well, since the production app will need similar features as demonstrated in the sample, to run correctly.\r\n\r\nI welcome any help, suggestions, or advice for strategies or techniques to improve the jest performance and get closer to the mocha+chai+nyc timings.\r\n\r\nUPDATE: using a '--watch' model, using git commits to control test coverage, got the original tests to almost acceptable rates (~10 seconds for test and coverage report)  I would prefer something on the order of 1-2 seconds, but I think this is something we can at least work with.","@Moumouls @jeysal Could you please tell me how you generate those flame charts from the jest workers ?","@mlarcher here an example: https:\/\/medium.com\/@paul_irish\/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27","@Moumouls thank you for the link ! \r\nI can debug the script with the method described there, but the \"profiler\" tab of chrome-devtools is empty, so I fail to see how to capture a cpuprofile.\r\n\r\nI managed to get a .cpuprofile file with \"node --cpu-prof .\/node_modules\/.bin\/react-scripts...\" but it only shows the calls up to \"spawnSync\", not what happens in the worker processes. \r\n\r\nCould you be more specific about how you got those flamegraphs ?","@mlarcher, I've fought with the exact same thing yesterday. There seems to be [a bug in Chrome](https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=1162948&q=profiler&can=2) right now. But I got it to work using the latest [Chrome Beta](https:\/\/www.google.com\/intl\/de\/chrome\/beta\/) version.","@nicolasschabram thanks for the tip, it really helps ! \ud83d\ude42\r\nI can now generate cpuprofile files directly from the chrome beta devtools, but I am facing the same issue : the profile doesn't show much, only a few levels deep until a spawnSync \ud83d\ude15\r\n\r\n![Capture d\u2019e\u0301cran 2021-01-08 a\u0300 17 16 19](https:\/\/user-images.githubusercontent.com\/1116431\/104038471-718ecd00-51d5-11eb-914b-c63bab13bb0f.png)\r\n\r\n","It appeared that create-react-app was making things harder than it should. After ejecting, I was able to run jest directly (with ` node --inspect scripts\/test.js --colors --watchAll=false --verbose`) and I was able to inspect the various workers using the logic described in https:\/\/indepth.dev\/posts\/1186\/how-to-debug-a-child-process-in-node-and-gatsby-js-with-chrome#patching-jest-workers-to-debug-child-process-in-node i.e. patching the child_process.fork call in `node_modules\\jest-worker\\build\\workers\\ChildProcessWorker.js` with something like \r\n```js\r\nconst execArgv = process.execArgv.filter(value=>!value.includes('inspect-brk'));\r\nconst randromNumber = Math.floor(Math.random() * 9 + 1);\r\nexecArgv.push(\"--inspect-brk=:700\" + randromNumber);\r\n``` \r\nand allowing those ports to be discovered by chrome devTools by declaring them in \"Discover network targets\"\r\n\r\nNow to dig into the output and try to figure out where the time is spent \ud83e\udd20","Add the possibility to run react as a BUILT VERSION instead as development version to avoid all the validations that react does when one do: NPM START","Any chance of this being fixed?\r\nI am struggling with slow jest on a Windows 10 + Webstorm + WSL2 Ubuntu node interpreter.\r\nFor me it takes more than 3 minutes to run a single test with \"isolatedModules\": true","2 years have gone since I created this issue https:\/\/github.com\/facebook\/jest\/issues\/7619 I believe the only way to fix this is just to use Mocha\/Chai\/Jasmine... or anything else but Jest!   :\/","I used --maxWorkers=1\n\n\n\nSaludos.\nIng. Rebeca L\u00f3pez Reynoso\ncel. 04455-\n3294-6671\n\n\n\n\nLe lun. 15 mars 2021 \u00e0 11:39, Nick ***@***.***> a \u00e9crit :\n\n> Any chance of this being fixed?\n> I am struggling with slow jest on a Windows 10 + Webstorm + WSL2 Ubuntu\n> node interpreter.\n> For me it takes more than 3 minutes to run a single test with\n> \"isolatedModules\": true\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/7963#issuecomment-799612686>, or\n> unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AAG5GYVBIGS4CY7P7OTGMN3TDZA5HANCNFSM4GZXKNIA>\n> .\n>\n","@RebecaLozrey I think this blog post covers the details better.\r\nhttps:\/\/dev.to\/vantanev\/make-your-jest-tests-up-to-20-faster-by-changing-a-single-setting-i36\r\n\r\nI set my config to\r\n```\r\n\"maxWorkers\": \"50%\"\r\n```\r\nGave me some improvement.","I have same problem with testing speed (time result in pic) i try to configure package.json to add:\r\n\"test\": \"jest --env=mode --color test ***--watch --runInBand***\" (two last options) and test time is bit better, but is not good, and in envinfo for VSC i check system and get this (in pic), but i use Windows 10 Pro N  x64 (20h2) and my pc is good, 16Gb RAM and GPU ir 2Gb, where is problem? Please help me, i tried what write @cozmy its helped a bit\r\n![time](https:\/\/user-images.githubusercontent.com\/89478349\/140655670-ee8226fc-3f23-42f4-b6ca-5d864e7cecfa.PNG)\r\n","We found the most improvement by using something like \r\n```\r\nimport fg from 'fast-glob';\r\n\r\ndescribe('all specs', () => {\r\n  const specs = fg.sync('src\/app\/**\/*.spec.ts');\r\n\r\n  specs.forEach(path => require(path));\r\n});\r\n```\r\nto run all the specs as one file on our CI environment. Naturally we had lots of tests leaking into one another using this method, but after cleaning that up and following the suggestion from this thead https:\/\/github.com\/facebook\/jest\/issues\/9457#issuecomment-926057477 in a beforeEach, we reduced our test time by a factor of about 5 (angular 12, >300 spec files and >3000 tests in total).","From me, when using jest to run my unittests, there are 2 problems I've faced with:\r\n- ts-jest takes lot of time for transform ts, tsx files\r\n- my code performs require other modules like a lot, even importing modules that not belong to the test that I've picked for the profiling.\r\n\r\nMy current approach are:\r\n- Use tsc command to check types of the code, switch to use swc-node\/jest to transform the test (reduce run time for the first time because jest does cache the transformed code after the first run)\r\n- Prevent huge import such as `import * as A from 'a';`, try best to import only what I need, this helped me to reduce the run time about 30%\r\n\r\nHope that jest will introduce us a way to cache imported modules to share access our tests, instead of require it again and again on each test file.","Same problem here with tests finishing in milliseconds, but the test file taking a very long time to finish.","Same problem... I tried to increase the number of workers but the high time keeps \ud83d\ude41","Read my post if is still there\n\nOn Fri, Jan 6, 2023, 1:41 PM Reinaldo Teixeira ***@***.***>\nwrote:\n\n> Same problem... I tried to increase the number of workers but the high\n> time keeps \ud83d\ude41\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/7963#issuecomment-1374047871>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AAG5GYTCIEOCYMBLQEDEBNDWRBYQDANCNFSM4GZXKNIA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n","any update on this issue :("],"labels":[":bug: Bug"]},{"title":"testMatch on Windows","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nThe following `testMatch` works on unix systems while does not on Windows machines. It is required to narrow the folders where to look for tests.\r\n\r\n```\r\n  testMatch: [\r\n    '<rootDir>\/src\/**\/?(*.)+(spec|test).(ts|tsx|mjs|js|jsx)',\r\n  ],\r\n```\r\nError on Windows:\r\n\r\n```\r\n  636 files checked.\r\n  testMatch: C:\/Users\/IEUser\/Fusion-UI\/packages\/infodesk\/src\/**\\?(*.)+(spec|test).(ts|tsx|mjs|js|jsx) - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 636 matches\r\n  testRegex:  - 636 matches\r\nPattern:  - 0 matches\r\nerror Command failed with exit code 1.\r\n```\r\n\r\n## To Reproduce\r\n\r\nSet a `testMatch` that starts with `<rootDir>\/src\/...` in place of the default `**\/*\/...`.\r\nSee in the error message `src\/**\\?(*.)` here the `\/` was replaced by `\\` and it is a lonely case.\r\n\r\n## Expected behavior\r\n\r\n`testMatch` should work cross OS as in v23.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nthis repro work in v22 while fails in v24 with Windows: https:\/\/repl.it\/@artola\/jest-bug\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\n  System:\r\n    OS: macOS 10.14.3\r\n    CPU: (4) x64 Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz\r\n  Binaries:\r\n    Node: 11.9.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.13.0 - \/usr\/local\/bin\/yarn\r\n    npm: 6.5.0 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: ^24.1.0 => 24.1.0 \r\n```\r\n","comments":["We moved to micromatch@3 and it seems like your glib is not valid anymore. You'll need to adjust it to be compliant. We're sorry this happens but it was announced as a breaking change ","I wonder if this is #7814? Seeing as OP says it works on unix","@thymikee I know about the breaking change and we changed the glob, mainly I just use the default one shown in `jest --init` with the prefix `<rootDir>\/src\/`. While this works on Mac\/Unix, does not on Windows.","Oh, that may be the case. Reopening then ","> I wonder if this is #7814? Seeing as OP says it works on unix\r\n\r\n@SimenB I am using v24.1 but if I add the `slash` wrapper as shown here (https:\/\/github.com\/facebook\/jest\/blob\/d81c4cb5443e529a5c0572e5b9e4f231249c3609\/packages\/jest-config\/src\/utils.js#L70) the `testMatch` works on unix and also on Windows.\r\n","@SimenB @thymikee When I create a config using `jest --init` shows this block:\r\n\r\n```\r\n  \/\/ The glob patterns Jest uses to detect test files\r\n  \/\/ testMatch: [\r\n  \/\/   \"**\/__tests__\/**\/*.[jt]s?(x)\",\r\n  \/\/   \"**\/?(*.)+(spec|test).[tj]s?(x)\"\r\n  \/\/ ],\r\n```\r\n\r\nThen I just uncommented this block and tweaked a bit to support `<rootDir>\/src\/`.\r\nThis change does not play well in Windows while in Unix is ok as reported above.\r\n\r\nNow what I did is slightly change the glob and works in both OS, following the doc in [micromatch](https:\/\/github.com\/micromatch\/micromatch#extglobs).\r\n\r\n```\r\n  \/\/ The glob patterns Jest uses to detect test files\r\n  testMatch: [\r\n     \"<rootDir>\/src\/**\/__tests__\/**\/*.[jt]s?(x)\",\r\n     \"<rootDir>\/src\/**\/*(*.)@(spec|test).[tj]s?(x)\"\r\n  ],\r\n```\r\nHere the more important changes:\r\n\r\n- `?(*.)` => `*(*.)` ... from **0 or 1 occurrence** to **0 or more occurrences**\r\n- `+(spec|test)` => `@(spec|test)` ... from **1 or more occurrences** to **matches 1**\r\n\r\nCould be that \"just\" the default for `testMatch` shown in the documentation need some update?","@artola That solves my issues after upgrading multiple of my projects to latest Jest. Befeorehand I had to add a bunch of ignore entries to stop it from picking up files that Jest thought had tests but didn't actually, resulting in fake fails. One such example is the Create React App's test.js script which actually executes Jest.","Can we count on fix?","Not sure what a fix would be? Is it a documentation or implementation issue? A PR for either is very much welcome as none on the core team uses windows. We do test windows on CI though, so if it's a code issue we can add a test as well","@SimenB It is a code issue, see my comment above, a solution is wrap this return with `slash`.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/16930281c466ef3ac7a07d9777d47b2d208ce16e\/packages\/jest-config\/src\/utils.ts#L66\r\n\r\nIt will be great if some Windows expert verifies and creates the PR.\r\n\r\nIn the meantime the solution was change the micromatch as explained.\r\n","Aight, fair enough! Looking forward to that PR \ud83d\ude0a","yup, the focus is the path `slash`\r\n\r\nIn windows default `slash` like `tests\\rules\\indent\\indent.test.ts`, but jest does not match this, must change like `tests\/rules\/indent\/indent.test.ts`","Hello!\r\nI'm not sure if it's the same bug, \r\nI've found the testMatch glob like `...__tests__\/+(unit|integration)...` is internally converted to `...__tests__\\+(unit|integration)...` on Windows so it does not match. Other slashes in my pattern are not converted. It works on linux.\r\nWorkaround for me was `...__tests__+(\/unit|\/integration)...`.","Hello!\r\n\r\nI encountered a similar issue. The following wildcard works on Unix machines but does not work on Windows machines:\r\n\r\n```\r\n'<rootDir>\/packages\/**\/(src|test)\/**\/*.(test|spec|e2e-spec).*'\r\n```\r\n\r\n@SimenB, after some debugging I found that there is `replacePathSepForGlob` function in `jest-utils` which is used in parsing of config files.\r\n\r\nHere is this function:\r\n\r\n```\r\n\/\/ node_modules\/jest-util\/build\/replacePathSepForGlob.js\r\n\r\nfunction replacePathSepForGlob(path) {\r\n  return path.replace(\/\\\\(?![{}()+?.^$])\/g, '\/');\r\n}\r\n```\r\n\r\nI changed it to log the result and path:\r\n\r\n```\r\nfunction replacePathSepForGlob(path) {\r\n  const result =  path.replace(\/\\\\(?![{}()+?.^$])\/g, '\/');\r\n  console.log('Replace sep for glob', {path, result})\r\n  return result\r\n}\r\n```\r\n\r\nSo, the issue happens because this function converts glob patents on Windows machines in the following way:\r\n\r\n```\r\nWildcard: '<rootDir>\/packages\/**\/(tests|src)\/**\/*.(test|spec|e2e-spec).*'\r\nPath: 'C:\\\\Users\\\\user\\\\Documents\\\\project\\\\packages\\\\**\\\\(src|test)\\\\**\\\\*.(test|spec|e2e-spec).*',\r\nReplaced path: 'C:\/Users\/user\/Documents\/project\/packages\/**\\\\(src|test)\/**\/*.(test|spec|e2e-spec).*'\r\n```\r\n\r\nThe issue is in this place (in replaced part) `...\/packages\/**\\\\(src|test)\/**\/...` - double slash is not replaced with a singular slash to be `...\/packages\/**\/(src|test)\/**\/...`.\r\n\r\nIt looks like ecranisation logic conflicts with double backslashes. So, if `\/` is followed by `(a|b)` wildcard on Windows then the replaced path is incorrect.\r\n\r\nAdditional notes:\r\n\r\n- `\/+(a|b)` wildcard (with modificator prefix) does not work\r\n- `\/(a|b)` wildcard (without modificator prefix) works well if you try it e.g. here: https:\/\/globster.xyz\/\r\n- `\/(a|b)` wildcard (without modificator prefix) works on Unix machines\r\n- `\/{a..b}` ([braces](https:\/\/github.com\/micromatch\/micromatch#braces-1)) does not work, e.g.:\r\n\r\n```\r\nWildcard: '<rootDir>\/packages\/**\/{1..3}\/**\/*.(test|spec|e2e-spec).*'\r\nPath: 'C:\\\\Users\\\\user\\\\Documents\\\\project\\\\packages\\\\**\\\\{1..3}\\\\**\\\\*.(test|spec|e2e-spec).*',\r\nReplaced path: 'C:\/Users\/user\/Documents\/project\/packages\/**\\\\{1..3}\/**\/*.(test|spec|e2e-spec).*'\r\n```\r\n\r\nAm I missing something? Or there is an issue?\r\n\r\n---\r\n\r\nIn my case, I found only one workaround for `\/(a|b)` wildcard. Such wildcard can be split into multiple wildcards:\r\n\r\n```\r\ntestMatch: [\r\n   '<rootDir>\/packages\/**\/(tests|src)\/**\/*.(test|spec|e2e-spec).*'\r\n  ],\r\n```\r\nchange to\r\n```\r\ntestMatch: [\r\n    '<rootDir>\/packages\/**\/tests\/**\/*.(test|spec|e2e-spec).*',\r\n    '<rootDir>\/packages\/**\/src\/**\/*.(test|spec|e2e-spec).*',\r\n  ],\r\n```","> We do test windows on CI though\r\n\r\n@SimenB correct me if I'm wrong, the test uses `path.posix` on Windows, so it doesn't behave the same as `require('path')` on Windows (should be `path.win32` on Windows by default).\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/abca0fe6c1d9fed884e4dc8bb911b3497db506ee\/packages\/jest-config\/src\/__tests__\/normalize.test.ts#L21\r\n\r\nI want to take a stab at fixing this, but writing a separate test suite for Windows seems like a lot of work to me.","edit: *sigh* I'm guessing I had some other botched config leading up to the issue I reported, as I've started over and am no longer experiencing the behavior I reported.","This issue persists. I was able to reproduce this issue on Jest version 28.1.3 installed on Windows Version 10.0.22621. My `testMatch` option is defined as, `testMatch: ['\/**\/*.test.*(\/ts|\/tsx)']` within `jest.config.js`.\r\n\r\nThe message I get when I run Jest is,\r\n```\r\nNo tests found, exiting with code 1\r\nRun with `--passWithNoTests` to exit with code 0\r\nIn C:\\Users\\jaitj\\Documents\\osc\\chapter\r\n  432 files checked.\r\n  testMatch: \/**\/*.test.(ts|tsx) - 0 matches\r\n  testPathIgnorePatterns: \\\\node_modules\\\\ - 432 matches\r\n  testRegex:  - 0 matches\r\nPattern:  - 0 matches\r\n```\r\nThe path separators for `testMatch` & `testPathIgnorePatterns` in the message above stand out to me. I wonder what makes Jest internally translate the path separator correctly for `testPathIgnorePatterns` but **NOT** for `testMatch`. The former option is defined as `watchPathIgnorePatterns: ['\/node_modules']` in `jest.config.js`. \r\n\r\n","+1 still experiencing issue in feb, 2023 \u2639\ufe0f\r\n\r\n","One possible workaround when trying to get a launch.json file to work on Windows is to use this VSCode extension:\r\nhttps:\/\/marketplace.visualstudio.com\/items?itemName=rioj7.command-variable\r\n\r\nI installed this, and then used the following launch.json configuration:\r\n```\r\n        {\r\n            \"name\": \"Debug One Test File\",\r\n            \"type\": \"node\",\r\n            \"request\": \"launch\",\r\n            \"runtimeArgs\": [\r\n                \"--inspect-brk\",\r\n                \"${workspaceRoot}\/node_modules\/jest\/bin\/jest.js\",\r\n                \"--runInBand\",\r\n                \"${command:extension.commandvariable.file.relativeFilePosix}\"\r\n            ],\r\n            \"console\": \"integratedTerminal\",\r\n            \"internalConsoleOptions\": \"neverOpen\",\r\n            \"env\": {\r\n                \"JEST_TEST_TIMEOUT\": \"2147483647\",\r\n            }\r\n        }\r\n\r\n```","> @SimenB @thymikee When I create a config using `jest --init` shows this block:\r\n> \r\n> ```\r\n>   \/\/ The glob patterns Jest uses to detect test files\r\n>   \/\/ testMatch: [\r\n>   \/\/   \"**\/__tests__\/**\/*.[jt]s?(x)\",\r\n>   \/\/   \"**\/?(*.)+(spec|test).[tj]s?(x)\"\r\n>   \/\/ ],\r\n> ```\r\n> \r\n> Then I just uncommented this block and tweaked a bit to support `<rootDir>\/src\/`. This change does not play well in Windows while in Unix is ok as reported above.\r\n> \r\n> Now what I did is slightly change the glob and works in both OS, following the doc in [micromatch](https:\/\/github.com\/micromatch\/micromatch#extglobs).\r\n> \r\n> ```\r\n>   \/\/ The glob patterns Jest uses to detect test files\r\n>   testMatch: [\r\n>      \"<rootDir>\/src\/**\/__tests__\/**\/*.[jt]s?(x)\",\r\n>      \"<rootDir>\/src\/**\/*(*.)@(spec|test).[tj]s?(x)\"\r\n>   ],\r\n> ```\r\n> \r\n> Here the more important changes:\r\n> \r\n> * `?(*.)` => `*(*.)` ... from **0 or 1 occurrence** to **0 or more occurrences**\r\n> * `+(spec|test)` => `@(spec|test)` ... from **1 or more occurrences** to **matches 1**\r\n> \r\n> Could be that \"just\" the default for `testMatch` shown in the documentation need some update?\r\n\r\nThanks, your workaround worked for me on Windows 11 \u2764\ufe0f !"],"labels":[":bug: Bug"]},{"title":"[RFC]: Rethinking reporters in Jest","body":"Reporters (that want to print to `stdout`) in Jest are pretty advanced as they have to replace existing text to show status (both per test and for the total run), they have to handle test results coming in out of order due to parallelized test execution and they have to print log output, assertion errors etc.. All of this has to look smooth with nice colors both on local machines and on CI.\r\n\r\nJest currently has 3 (4) built-in reporters: standard, verbose and coverage (the fourth being a Notify reporter, but that doesn't write to stdout). Those 3 reporters are implemented by a cool 2941 lines of code according to `cloc`. Source code lives [here](https:\/\/github.com\/facebook\/jest\/tree\/0c1d5f9ffffdb50758d087ded95d3a711243f518\/packages\/jest-cli\/src\/reporters).\r\n\r\nImplementation wise, a reporter currently have to implement an interface (documented [here](https:\/\/jestjs.io\/docs\/en\/24.0\/configuration#reporters-array-modulename-modulename-options)) where functions are called whenever an event happens (such as `onRunStart`, `onTestResult` etc.).\r\n\r\nThe problem with the current way reporters are implemented, is that they all have to print to `process.stdout` manually, dealing with whether or not it's interactive, clearing (or not) stale output. This is a hard thing to get right (e.g. #1781 is 2.5 years old). And you cannot really have multiple reporters working at the same time - they will trip each other up as there's no way to synchronize writes to the stream.\r\n\r\n---\r\n\r\nI'd love to be able to offload a lot of the work these reporters currently do to something better suited for building reactive UIs - React. We would then just re-render with new props whenever we have new state, React would give us how it's supposed to look, and we could offload to [`ink`](https:\/\/github.com\/vadimdemedes\/ink) to actually render the output in the terminal.\r\n\r\nJest itself could also expose all the different parts of its default reporter (a few quick screenshots below) as React components, making it easier to build a custom reporters.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/52804403-69c75c00-3084-11e9-8f7b-a91abd883624.png)\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/52804488-a004db80-3084-11e9-81dc-5443b84eb145.png)\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/52804511-ad21ca80-3084-11e9-9d52-bd4bf8c250ac.png)\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/52804380-5f0cc700-3084-11e9-8dd7-010f9dd8280b.png)\r\n\r\nWhat do people think?\r\n\r\nI currently have a working prototype implementation of Jest's current reporters using Ink [here](https:\/\/github.com\/SimenB\/jest\/tree\/ink-reporter).\r\n\r\n\/cc @vadimdemedes\r\n\r\nPS: Reporters that just want to write to a file and not `stdout` (e.g. [`jest-junit`](https:\/\/github.com\/jest-community\/jest-junit) or the built-in Notify reporter) would not be affected by this change.\r\n\r\nPPS: It might make sense to make it easier writing watch plugins in `ink` as well (if it's hard, I haven't tested), but that's out of scope.","comments":["I think this is one of the most exciting and necessary changes to improve UX, especially combined with your PPS. Would love to help work on this. Is there a good way to manage the transition phase? Using an ink and a legacy non-ink reporter at the same time seems like it would be hard to deal with.","If I'm not mistaken, Ink uses `log-update` under the hood, which has problems re-rendering content larger than the terminal height? This may be an issue with Jest's RUN\/PASS\/FAIL stack?\r\n\r\nOutside of that, I've ran into similar problems with [Boost's console](https:\/\/github.com\/milesj\/boost\/blob\/master\/packages\/core\/src\/Console.ts), where reporters all need to write to a stream in parallel. I believe I solved the problem by supporting 2 modes for writing:\r\n\r\n- Enqueuing an \"output block\", which triggers a render loop that continuously renders the block until the block is marked complete. Once all blocks are complete, the loop stops.\r\n\r\n- Writing to the stream directly. If the render loop is running, the stream is buffered until the next frame, otherwise the content is written immediately.\r\n\r\nThis requires all the writing logic to be handled in a single layer (the `Console`), instead of being handled in each reporter. From the looks of Jest's reporters, they all talk to `process.stdout` or `process.stderr` directly instead of through a unified layer.",">Is there a good way to manage the transition phase? Using an ink and a legacy non-ink reporter at the same time seems like it would be hard to deal with.\r\n\r\nYeah, I think it'd have to be opt-in (through config or just `reporter[0]` having some static property). Supporting both at once seems out of the question, tbh\r\n\r\n>If I'm not mistaken, Ink uses `log-update` under the hood\r\n\r\nCurrent version does, V2 (which is the one we'd use) does not: https:\/\/github.com\/vadimdemedes\/ink\/blob\/440b83140a8e16ddfc5ad1b01bdc156f09350aba\/package.json#L40-L52. Not to say it won't have issue of course. I did not encounter that when testing (IIRC, this was back in early November, might've just forgotten)","@SimenB Looks like they forked it: https:\/\/github.com\/vadimdemedes\/ink\/blob\/440b83140a8e16ddfc5ad1b01bdc156f09350aba\/src\/vendor\/log-update.js But if you haven't run into any issues, then hopefully it's fine.","Ah, fair enough! I'm not really married to the choice of ink (there's also e.g. [`react-slate`](http:\/\/react-slate.surge.sh\/) and [`react-blessed`](https:\/\/github.com\/Yomguithereal\/react-blessed)), it's just the one I've already played with, and (albeit with limited testing) it worked great. Hopefully the exact renderer won't really matter in the end, but we should make sure to test for edge cases such as that.\r\n\r\nThe goal (at least my goal) here is to make it easier to create beautiful interfaces with Jest, and I think migrating to a system that allows people to use React components unlocks some super exciting possibilities. The exact implementation of that is really fuzzy \ud83d\ude42 \r\n\r\nEDIT: webpack-dashboard migrated to `neo-blessed`: https:\/\/github.com\/FormidableLabs\/webpack-dashboard\/releases\/tag\/3.0.0","> Migrating to a system that allows people to use React components unlocks some super exciting possibilities.\r\n\r\nAgreed! Hopefully it works :P","@SimenB glad you were able to finish the PR, really happy to see it! As I've said before, let me know if you run into any issues!\r\n\r\n> If I'm not mistaken, Ink uses `log-update` under the hood, which has problems re-rendering content larger than the terminal height? This may be an issue with Jest's RUN\/PASS\/FAIL stack?\r\n\r\n@milesj That is correct, Ink uses `log-update` to render output, but truth is it's not `log-update`'s fault. It just seems that terminals are unable to properly erase last N lines of output if N is larger than terminal height (rows). What Jest actually does is it erases all session, including any previous output from other commands. I've tried doing that on every render in Ink, but rendering was lagging a lot if you have high frequency of renderings.\r\n\r\nTo work around this limitation, Ink has a `<Static>` component, which \"flushes\" all its children permanently, bypassing `log-update`. It means that `<Static>` is the perfect candidate for things like list of completed tests in Jest. But, once those components are written to stdout, that output can't be modified. I actually created a demo implementation of Jest's output with Ink as an example here - https:\/\/github.com\/vadimdemedes\/ink\/blob\/next\/examples\/jest\/jest.js#L40-L61. You can run it by cloning Ink's `next` branch, installing deps and running `node examples\/jest`.","Sorta related: #3160","@vadimdemedes Yup ran into similar issues when implementing my console. That Jest POC is pretty slick, love it \ud83d\udc4d ","The underlying `wrap-ansi` issues has been fixed \ud83c\udf89 \r\n\r\nIn celebration, I merged in master into my branch (almost worked \ud83d\ude05). Will be taking a look at this in a couple of weeks \ud83d\ude42 ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","I still want to do this, work is ongoing (albeit stalled \ud83d\ude05) in https:\/\/github.com\/jest-community\/jest-react-reporter. Any and all help welcome!","This is all very ambitions, but IMO want a *less* sophisticated reporter. Like one that just lets me console.log and have it appear.\r\n\r\nJest makes debugging slow tests\/infinite loops is really really hard. I haven't had that issue with other test frameworks, likely because they didn't get fancy about stdout.","I find that jest reporter is overwriting\/hiding STDERR output that comes from a native add on. This makes it hard to debug this I have to repeat the logs several times in the native addon to avoid jest reporter clobbering the stderr output."],"labels":[":rocket: Enhancement","Discussion","Pinned"]},{"title":"Memory Leak on ridiculously simple repo","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\nYou guys do an awesome job and we all appreciate it! \ud83c\udf89\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nOn a work project we discovered a memory leak choking our CI machines. Going down the rabbit hole, I was able to recreate the memory leak using `Jest` alone. \r\n\r\nRunning many test files causes a memory leak. I created a stupid simple repo with only `Jest` installed and 40 tautological test files.\r\n\r\n<img width=\"375\" alt=\"jest-memory-leak\" src=\"https:\/\/user-images.githubusercontent.com\/5766483\/52652668-3c00dc80-2ef7-11e9-931f-cd9ba050d26a.png\">\r\n\r\nI tried a number of solutions from https:\/\/github.com\/facebook\/jest\/issues\/7311 but to no avail. I couldn't find any solutions in the other memory related issues, and this seems like the most trivial repro I could find.\r\n\r\n## Workaround :'(\r\n\r\nWe run tests with `--expose-gc` flag and adding this to each test file:\r\n```\r\nafterAll(() => {\r\n  global.gc && global.gc()\r\n})\r\n```\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n```\r\ngit clone git@github.com:javinor\/jest-memory-leak.git\r\ncd jest-memory-leak\r\nnpm i\r\nnpm t\r\n```\r\n\r\n## Expected behavior\r\n\r\nEach test file should take the same amount of memory (give or take)\r\n\r\n\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/javinor\/jest-memory-leak\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\nSystem:\r\n    OS: macOS High Sierra 10.13.6\r\n    CPU: (4) x64 Intel(R) Core(TM) i7-5557U CPU @ 3.10GHz\r\n  Binaries:\r\n    Node: 10.15.0 - ~\/.nvm\/versions\/node\/v10.15.0\/bin\/node\r\n    Yarn: 1.12.3 - \/usr\/local\/bin\/yarn\r\n    npm: 6.4.1 - ~\/.nvm\/versions\/node\/v10.15.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^24.1.0 => 24.1.0\r\n```\r\n","comments":["I found this out recently but you can use the Chrome console to debug Node scripts! You can try using the Chrome console to profile Jest while it's running to try and dig into the issue.\r\n\r\nI believe the command is: `node --inspect .\/node_modules\/.bin\/jest --watch -i`. When running, open Chrome and go to `about:inspect`. You should then see the running Node script.","Do I understand correctly that using the workaround to force GC runs makes the heap size remain constant? In that case it's not really a memory leak, just v8 deciding not to run the GC because there is enough memory available. If I try running the repro with 50MB heap size\r\n```bash\r\nnode --max_old_space_size=50 node_modules\/.bin\/jest --logHeapUsage --runInBand --config=jest.config.js\r\n```\r\nthe tests still complete successfully, supporting this assumption.","@milesj I ran through some memory dumps, but couldn't make much sense of them, I'm not too experienced with pursuing leaks and I didn't want to point in the wrong direction without something solid to count on.\r\n\r\n@jeysal you are right of course! The thing is our tests freeze in the middle of running since (I assume and could be wrong) we run out of memory. After spending a lot of time trying to figure this out, I found https:\/\/github.com\/facebook\/jest\/issues\/7274. It seemed to me from the discussion that the behaviour I encountered here is not intended. wdyt @SimenB ?","Bueller?","My tests are also leaking massively on CI but the exact same setup locally doesn't really leak (much at least).\r\n\r\nIt's so bad, I'm considering disabling tests on CI until I can make sense of what the difference is beside the OS. ):","Hey guys!\r\n\r\nI simplified the memory leak case to a single file which runs tautological tests and eventually throws an exception due to a memory leak.\r\n\r\nI'm not sure how to move forward with this... help? @SimenB @jeysal @milesj \r\n\r\n```\r\njest_leak@1.0.0 test \/Users\/javinor\/workspace\/jest-memory-leak\r\n> jest --logHeapUsage --runInBand --config=jest.config.js\r\n\r\n\r\n RUNS  __test__\/repeat100.test.js\r\n\r\n<--- Last few GCs --->\r\n\r\n[82597:0x103800000]    79124 ms: Mark-sweep 1259.1 (1442.2) -> 1240.0 (1436.2) MB, 438.3 \/ 0.0 ms  (average mu = 0.310, current mu = 0.304) allocation failure scavenge might not succeed\r\n[82597:0x103800000]    79197 ms: Scavenge 1255.7 (1436.2) -> 1242.6 (1438.2) MB, 15.9 \/ 0.0 ms  (average mu = 0.310, current mu = 0.304) allocation failure\r\n[82597:0x103800000]    79256 ms: Scavenge 1256.5 (1438.2) -> 1244.7 (1441.7) MB, 11.0 \/ 0.0 ms  (average mu = 0.310, current mu = 0.304) allocation failure\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\n    0: ExitFrame [pc: 0x2440d84dbe3d]\r\nSecurity context: 0x30802859e6e9 <JSObject>\r\n    1: prepareStackTrace [0x3080c9459f79] [\/Users\/javinor\/workspace\/garbage\/jest_leak\/node_modules\/source-map-support\/source-map-support.js:~388] [pc=0x2440d854b545](this=0x308094d07b59 <JSFunction Error (sfi = 0x308018616e01)>,error=0x3080e18623f9 <Error map = 0x3080f3c619f9>,stack=0x3080e1862e91 <JSArray[23]>)\r\n    2: InternalFrame [pc: 0x2440d848ee75]\r\n    ...\r\n\r\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\r\n 1: 0x10003c597 node::Abort() [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 2: 0x10003c7a1 node::OnFatalError(char const*, char const*) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 3: 0x1001ad575 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 4: 0x100579242 v8::internal::Heap::FatalProcessOutOfMemory(char const*) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 5: 0x10057bd15 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 6: 0x100577bbf v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 7: 0x100575d94 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 8: 0x10058262c v8::internal::Heap::AllocateRawWithLigthRetry(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n 9: 0x1005826af v8::internal::Heap::AllocateRawWithRetryOrFail(int, v8::internal::AllocationSpace, v8::internal::AllocationAlignment) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n10: 0x100551ff4 v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n11: 0x1007da044 v8::internal::Runtime_AllocateInNewSpace(int, v8::internal::Object**, v8::internal::Isolate*) [\/Users\/javinor\/.nvm\/versions\/node\/v10.15.3\/bin\/node]\r\n12: 0x2440d84dbe3d\r\nAbort trap: 6\r\n```","Similar here, jest + ts-jest, simple tests get over 1GB of memory and eventually crash.","crashes for us too","@javinor For a test file containing a ridiculous number of tests, I'm not sure there's much we can do, we have to keep the test objects around until the test file is finished - this is the heap while the tests are running:\r\n![image](https:\/\/user-images.githubusercontent.com\/16069751\/55276381-767dd780-52f3-11e9-91a5-50fe7fc9a379.png)\r\nHundreds of MBs of test objects, so for the case shown in this repro we can't really help either :\/","FYI @scotthovestadt is currently working on holistically improving memory efficiency of Jest, so improvements are coming (some of them in the next minor version).","I wonder, why isn't it possible for Jest to spawn a process for each test file, which will guarantee that memory will be freed? Ok, it can be slower, of course, but in my case - it's **much** better to be slower rather than get a crash from out-of-memory and be blocked to use Jest alltogether...\r\n\r\nMaybe an option? Or a separate \"runner\" (not sure if I understand architecture and terminology right)?\r\n\r\nIs it architecturally possible?\r\n\r\nOr, will Node-experimental-workers solve it?..","I've made a few improvements to memory in the next release:\r\n#8234\r\n#8233 \r\n\r\nI have a future plan to improve memory in a couple of ways:\r\n- by not holding onto test results at all, which are currently held until the end. related: #8242\r\n- limiting number of modules that can exist in the require cache\r\n\r\nThe problem with your suggestion of just spawning a new worker for each test is that it would be _very_ slow. A better suggestion along the same lines would be to monitor the memory usage of the processes and auto-restart them at some threshold. I have some concerns about that in general, I'd rather always fix memory leaks than paper them over, but if a PR did that I would accept it.\r\n\r\nLet me know if the release next week helps with the problems you've been experiencing.","@scotthovestadt thanks for the info! I'll definitely check with the next release.\r\n\r\nMy actual issue is reported here: https:\/\/github.com\/facebook\/jest\/issues\/8247\r\nAnd there I'm dealing with much bigger leaks, +30Mb per each test file (~150 files in my project).\r\n","Thanks for the responses guys!\r\n\r\nI think I can break this down to different two problems:\r\n1. Memory consumption grows the more test files I have\r\n2. Memory consumption grows the more tests I have per file\r\n\r\nWe're running thousands of tests, each creating a relatively big setup so we get bitten twice. \r\n\r\nThe original screenshot showing the consumption growing from test file to test file, hinting to a leak between tests - I have a few guesses as to why this happens, but nothing solid yet.\r\n\r\nThe exception I referred to later, as far as I can tell, really has to do with what @jeysal pointed out - having a large number of tests in the file. In our case, we have only hundreds of tests but with a very large setup. I'll try to provide a better reproduction of this.\r\n\r\nI'll update after the next release, when I get to poke around a bit more and see the additional fixes in action. Thanks guys!","There must be something else wrong because I'm currently using Jest v23.6 and everything works fine, no memory leaks, no anything.\r\n\r\nIf I upgrade to latest Jest then the memory leaks start to happen, but only on the GiLab CI runner. Works fine locally.","New release is out: https:\/\/github.com\/facebook\/jest\/releases\/tag\/v24.6.0","Meh, it's still leaking in my setup ):\r\n\r\n```\r\n\u001b[0KRunning with gitlab-runner 11.8.0 (4745a6f3)\r\n\u001b[0;m\u001b[0K  on the-mill-ec2-gitlab-runner GvW8cLGR\r\n\u001b[0;m\u001b[0KUsing Docker executor with image cypress\/base:8 ...\r\n\u001b[0;m\u001b[0KUsing locally found image version due to if-not-present pull policy\r\n\u001b[0;m\u001b[0KUsing docker image sha256:2ad7a04a3a1d41fac2585d88e2dbd19ed3df9c57df2b27276c30e4f317c2c8e3 for cypress\/base:8 ...\r\n\u001b[0;msection_start:1554216455:prepare_script\r\n\u001b[0KRunning on runner-GvW8cLGR-project-10463077-concurrent-0 via runner-gvw8clgr-gitlab-runner-1554212599-0c63c2c8...\r\nsection_end:1554216456:prepare_script\r\n\u001b[0Ksection_start:1554216456:get_sources\r\n\u001b[0K\u001b[32;1mCloning repository...\u001b[0;m\r\nCloning into '\/builds\/the-mill\/lambda-gaming'...\r\n\u001b[32;1mChecking out a592f4d2 as update-fe-bo-packages...\u001b[0;m\r\n\u001b[32;1mSkipping Git submodules setup\u001b[0;m\r\nsection_end:1554216459:get_sources\r\n\u001b[0Ksection_start:1554216459:restore_cache\r\n\u001b[0Ksection_end:1554216460:restore_cache\r\n\u001b[0Ksection_start:1554216460:download_artifacts\r\n\u001b[0K\u001b[32;1mDownloading artifacts for nodeModulesFe (189107055)...\u001b[0;m\r\nDownloading artifacts from coordinator... ok      \u001b[0;m  id\u001b[0;m=189107055 responseStatus\u001b[0;m=200 OK token\u001b[0;m=iQz-3io7\r\nsection_end:1554216481:download_artifacts\r\n\u001b[0Ksection_start:1554216481:build_script\r\n\u001b[0K\u001b[32;1m$ cd .\/packages\/frontends\u001b[0;m\r\n\u001b[32;1m$ node --version\u001b[0;m\r\nv8.12.0\r\n\u001b[32;1m$ node --expose-gc .\/node_modules\/.bin\/ng test --ci --code-coverage=false --run-in-band\u001b[0;m\r\nPASS apps\/whitelabel\/src\/app\/app.component.spec.ts (195 MB heap size)\r\n  AppComponent\r\n    \u2713 should create the app (87ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        5.168s\r\nRan all test suites.\r\nPASS apps\/backoffice\/src\/app\/layout\/layout.component.spec.ts (294 MB heap size)\r\nPASS apps\/backoffice\/src\/app\/app.component.spec.ts (289 MB heap size)\r\n\r\nTest Suites: 2 passed, 2 total\r\nTests:       3 passed, 3 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        4.154s\r\nRan all test suites.\r\nPASS libs\/api\/src\/lib\/api.module.spec.ts (364 MB heap size)\r\n  ApiModule\r\n    \u2713 should create (69ms)\r\n\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        3.283s\r\nRan all test suites.\r\nPASS libs\/core\/src\/lib\/user.service.spec.ts (427 MB heap size)\r\nPASS libs\/core\/src\/lib\/auth.service.spec.ts (426 MB heap size)\r\nPASS libs\/core\/src\/lib\/wallet.service.spec.ts (426 MB heap size)\r\nPASS libs\/core\/src\/lib\/unauth.guard.spec.ts (428 MB heap size)\r\nPASS libs\/core\/src\/lib\/auth.guard.spec.ts (428 MB heap size)\r\nPASS libs\/core\/src\/lib\/route.service.spec.ts (426 MB heap size)\r\nPASS libs\/core\/src\/lib\/core.module.spec.ts (426 MB heap size)\r\n\r\nTest Suites: 7 passed, 7 total\r\nTests:       8 passed, 8 total\r\nSnapshots:   0 total\r\nTime:        6.945s\r\nRan all test suites.\r\nPASS libs\/ui\/src\/lib\/form-errors\/form-errors.component.spec.ts (507 MB heap size)\r\nPASS libs\/ui\/src\/lib\/loader\/loader.component.spec.ts (507 MB heap size)\r\nPASS libs\/ui\/src\/lib\/css-url.pipe.spec.ts (506 MB heap size)\r\nPASS libs\/ui\/src\/lib\/ui.module.spec.ts (526 MB heap size)\r\n\r\nTest Suites: 4 passed, 4 total\r\nTests:       6 passed, 6 total\r\nSnapshots:   2 passed, 2 total\r\nTime:        6.525s\r\nRan all test suites.\r\nPASS libs\/registration\/src\/lib\/registration-form\/registration-form.component.spec.ts (5.068s, 633 MB heap size)\r\nPASS libs\/registration\/src\/lib\/registration.module.spec.ts (628 MB heap size)\r\n\r\nTest Suites: 2 passed, 2 total\r\nTests:       3 passed, 3 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        7.861s\r\nRan all test suites.\r\nPASS libs\/casino-game\/src\/lib\/casino-game\/casino-game.component.spec.ts (687 MB heap size)\r\nPASS libs\/casino-game\/src\/lib\/casino-game.module.spec.ts (685 MB heap size)\r\n\r\nTest Suites: 2 passed, 2 total\r\nTests:       4 passed, 4 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        3.839s\r\nRan all test suites.\r\nPASS libs\/documents\/src\/lib\/document-upload-form\/document-upload-form.component.spec.ts (736 MB heap size)\r\nPASS libs\/documents\/src\/lib\/documents\/documents.component.spec.ts (736 MB heap size)\r\nPASS libs\/documents\/src\/lib\/documents.module.spec.ts (736 MB heap size)\r\n\r\nTest Suites: 3 passed, 3 total\r\nTests:       5 passed, 5 total\r\nSnapshots:   2 passed, 2 total\r\nTime:        4.32s\r\nRan all test suites.\r\nPASS libs\/forgot-password\/src\/lib\/forgot-password-form\/forgot-password-form.component.spec.ts (818 MB heap size)\r\nPASS libs\/forgot-password\/src\/lib\/forgot-password\/forgot-password.component.spec.ts (818 MB heap size)\r\nPASS libs\/forgot-password\/src\/lib\/forgot-password.module.spec.ts (837 MB heap size)\r\n\r\nTest Suites: 3 passed, 3 total\r\nTests:       5 passed, 5 total\r\nSnapshots:   2 passed, 2 total\r\nTime:        7.06s\r\nRan all test suites.\r\nPASS libs\/reset-password\/src\/lib\/reset-password-form\/reset-password-form.component.spec.ts (922 MB heap size)\r\nPASS libs\/reset-password\/src\/lib\/reset-password\/reset-password.component.spec.ts (919 MB heap size)\r\nPASS libs\/reset-password\/src\/lib\/reset-password.module.spec.ts (929 MB heap size)\r\n\r\nTest Suites: 3 passed, 3 total\r\nTests:       5 passed, 5 total\r\nSnapshots:   2 passed, 2 total\r\nTime:        7.922s\r\nRan all test suites.\r\nPASS libs\/payment\/src\/lib\/payment-process\/payment-process.component.spec.ts (1018 MB heap size)\r\nPASS libs\/payment\/src\/lib\/payment-option-list\/payment-option-list.component.spec.ts (1016 MB heap size)\r\nPASS libs\/payment\/src\/lib\/payment-option\/payment-option.component.spec.ts (1011 MB heap size)\r\nPASS libs\/payment\/src\/lib\/card-form\/card-form.component.spec.ts (1013 MB heap size)\r\nPASS libs\/payment\/src\/lib\/payment.service.spec.ts (1013 MB heap size)\r\nPASS libs\/payment\/src\/lib\/payment.module.spec.ts (1032 MB heap size)\r\nPASS libs\/payment\/src\/lib\/card-type-detector.directive.spec.ts (1023 MB heap size)\r\n\r\nTest Suites: 7 passed, 7 total\r\nTests:       11 passed, 11 total\r\nSnapshots:   4 passed, 4 total\r\nTime:        14.741s\r\nRan all test suites.\r\nPASS libs\/fluid-container\/src\/lib\/fluid-container\/fluid-container.component.spec.ts (1081 MB heap size)\r\nPASS libs\/fluid-container\/src\/lib\/fluid-container.module.spec.ts (1081 MB heap size)\r\n\r\nTest Suites: 2 passed, 2 total\r\nTests:       3 passed, 3 total\r\nSnapshots:   1 passed, 1 total\r\nTime:        4.164s\r\nRan all test suites.\r\nPASS libs\/layout\/src\/lib\/layout\/layout.component.spec.ts (6.025s, 1181 MB heap size)\r\nFAIL libs\/layout\/src\/lib\/sidebar\/sidebar.component.spec.ts\r\n  \u25cf Test suite failed to run\r\n\r\n    TypeScript diagnostics (customize using `[jest-config].globals.ts-jest.diagnostics` option):\r\n    \u001b[96mlibs\/layout\/src\/lib\/sidebar\/sidebar.component.spec.ts\u001b[0m:\u001b[93m26\u001b[0m:\u001b[93m7\u001b[0m - \u001b[91merror\u001b[0m\u001b[90m TS2739: \u001b[0mType '{ __typename: \"NavList\"; classes: string[]; navListItems: undefined[]; }' is missing the following properties from type 'NavList': horizontal, id\r\n\r\n    \u001b[7m26\u001b[0m       navList: {\r\n    \u001b[7m  \u001b[0m \u001b[91m      ~~~~~~~\u001b[0m\r\n\r\n      \u001b[96mlibs\/layout\/src\/lib\/sidebar\/sidebar.graphql.ts\u001b[0m:\u001b[93m8\u001b[0m:\u001b[93m3\u001b[0m\r\n        \u001b[7m8\u001b[0m   navList: NavList;\r\n        \u001b[7m \u001b[0m \u001b[96m  ~~~~~~~\u001b[0m\r\n        The expected type comes from property 'navList' which is declared here on type 'Sidebar'\r\n\r\nPASS libs\/layout\/src\/lib\/header\/header.component.spec.ts (1213 MB heap size)\r\nPASS libs\/layout\/src\/lib\/footer\/footer.component.spec.ts (1194 MB heap size)\r\nPASS libs\/layout\/src\/lib\/layout.module.spec.ts (5.055s, 1212 MB heap size)\r\n\r\nTest Suites: 1 failed, 4 passed, 5 total\r\nTests:       7 passed, 7 total\r\nSnapshots:   3 passed, 3 total\r\nTime:        19.157s\r\nRan all test suites.\r\nPASS libs\/cms\/src\/lib\/page\/page.component.spec.ts (7.531s, 1269 MB heap size)\r\nPASS libs\/cms\/src\/lib\/dialog-route\/dialog-route.component.spec.ts (1271 MB heap size)\r\nPASS libs\/cms\/src\/lib\/content-group\/content-group.component.spec.ts (1272 MB heap size)\r\nPASS libs\/cms\/src\/lib\/cms.service.spec.ts (1270 MB heap size)\r\nPASS libs\/cms\/src\/lib\/slot.directive.spec.ts (1268 MB heap size)\r\nPASS libs\/cms\/src\/lib\/cms.module.spec.ts (1270 MB heap size)\r\n\r\nTest Suites: 6 passed, 6 total\r\nTests:       9 passed, 9 total\r\nSnapshots:   3 passed, 3 total\r\nTime:        18.367s\r\nRan all test suites.\r\nFATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory\r\n\r\n<--- Last few GCs --->\r\n\r\n[10:0x2510510]   136242 ms: Mark-sweep 1362.8 (1460.0) -> 1362.8 (1460.0) MB, 1827.9 \/ 0.1 ms  allocation failure GC in old space requested\r\n[10:0x2510510]   137760 ms: Mark-sweep 1362.8 (1460.0) -> 1362.8 (1429.0) MB, 1518.2 \/ 0.1 ms  last resort GC in old space requested\r\n[10:0x2510510]   139285 ms: Mark-sweep 1362.8 (1429.0) -> 1362.8 (1429.0) MB, 1524.6 \/ 0.1 ms  last resort GC in old space requested\r\n\r\n\r\n<--- JS stacktrace --->\r\n\r\n==== JS stack trace =========================================\r\n\r\nSecurity context: 0xb1cf5fa5879 <JSObject>\r\n    1: stringSlice(aka stringSlice) [buffer.js:560] [bytecode=0x1e161b35dd29 offset=94](this=0x11a4d26822d1 <undefined>,buf=0x20928062d71 <Uint8Array map = 0x35a39b242941>,encoding=0xb1cf5fb5409 <String[4]: utf8>,start=0,end=1097377)\r\n    2: toString [buffer.js:633] [bytecode=0x1e161b35d979 offset=145](this=0x20928062d71 <Uint8Array map = 0x35a39b242941>,encoding=0xb1cf5fb5409 <String[4]: utf8>,st...\r\n\r\n 1: node::Abort() [ng test --ci --code-coverage=false --run-in-band]\r\n 2: 0x8cbf4c [ng test --ci --code-coverage=false --run-in-band]\r\n 3: v8::Utils::ReportOOMFailure(char const*, bool) [ng test --ci --code-coverage=false --run-in-band]\r\n 4: v8::internal::V8::FatalProcessOutOfMemory(char const*, bool) [ng test --ci --code-coverage=false --run-in-band]\r\n 5: v8::internal::Factory::NewRawTwoByteString(int, v8::internal::PretenureFlag) [ng test --ci --code-coverage=false --run-in-band]\r\n 6: v8::internal::Factory::NewStringFromUtf8(v8::internal::Vector<char const>, v8::internal::PretenureFlag) [ng test --ci --code-coverage=false --run-in-band]\r\n 7: v8::String::NewFromUtf8(v8::Isolate*, char const*, v8::NewStringType, int) [ng test --ci --code-coverage=false --run-in-band]\r\n 8: node::StringBytes::Encode(v8::Isolate*, char const*, unsigned long, node::encoding, v8::Local<v8::Value>*) [ng test --ci --code-coverage=false --run-in-band]\r\n 9: 0x8e4a76 [ng test --ci --code-coverage=false --run-in-band]\r\n10: v8::internal::FunctionCallbackArguments::Call(void (*)(v8::FunctionCallbackInfo<v8::Value> const&)) [ng test --ci --code-coverage=false --run-in-band]\r\n11: 0xb0bbec [ng test --ci --code-coverage=false --run-in-band]\r\n12: v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) [ng test --ci --code-coverage=false --run-in-band]\r\n13: 0x220bb08042fd\r\n\/bin\/bash: line 90:    10 Aborted                 (core dumped) node --expose-gc .\/node_modules\/.bin\/ng test --ci --code-coverage=false --run-in-band\r\nsection_end:1554216631:build_script\r\n\u001b[0Ksection_start:1554216631:after_script\r\n\u001b[0Ksection_end:1554216633:after_script\r\n\u001b[0Ksection_start:1554216633:upload_artifacts_on_failure\r\n\u001b[0K\u001b[32;1mUploading artifacts...\u001b[0;m\r\n\u001b[0;33mWARNING: .\/packages\/frontends\/junit\/*.xml: no matching files\u001b[0;m \r\n\u001b[31;1mERROR: No files to upload                         \u001b[0;m \r\nsection_end:1554216634:upload_artifacts_on_failure\r\n\u001b[0K\u001b[31;1mERROR: Job failed: exit code 1\r\n\u001b[0;m\r\n```","After updating to 24.6.0, we are seeing the similar issue running [our](https:\/\/github.com\/terascope\/teraslice) CI tests. When logging the heap usage, we see an increase of memory usage after each test file.","This should help: https:\/\/github.com\/facebook\/jest\/pull\/8282\r\n\r\nWill be released soon.","How soon? )':","For those reading along at home, this went out in [24.8.0](https:\/\/github.com\/facebook\/jest\/blob\/master\/CHANGELOG.md#2480).","> The problem with your suggestion of just spawning a new worker for each test is that it would be _very_ slow.\r\n\r\nThis would also be a huge breaking change.","> If I upgrade to latest Jest then the memory leaks start to happen, but only on the GiLab CI runner. Works fine locally.\r\n\r\nAlso encounter `out of memory` issue with `jest` + `ts-jest`:\r\nhttps:\/\/circleci.com\/gh\/unional\/standard-log\/382\r\n\r\nOriginally I thought it was some circular dependency on my source code, but may be `jest` related.\r\nSo throwing this into the mix. \ud83c\udf37 ","@unional if you're on Circle, make sure `maxWorkers` isn't higher than the CPU allotted you by Circle. \r\n\r\nEDIT: To be clear, you should proactively specify `maxWorkers` at or below the CPU allotted you Circle. ","@Supernats thanks. I think I did have that set during the failure, currently I'm running it with `--runInBand` \ud83d\ude22  \r\n\r\nBut it still fail once in a while:\r\nhttps:\/\/circleci.com\/gh\/unional\/standard-log\/448\r\n","I have Jest 24.8.0 and #8282 doesn't seem to help. Also `--runInBand` only helps a bit (4 GB instead of 10 GB \ud83d\ude2e).\r\n\r\nPleaaaaaaase fix this ...","Yes, following this thread for long since it still fails for us and in ~10% of the cases runs with \"out of memory\" for CircleCI 2Gb RAM instances.","Jest 25.1.0 has the same memory leak issue.","Found an article for how to use heap snapshot to debug jest memory leak here: https:\/\/chanind.github.io\/javascript\/2019\/10\/12\/jest-tests-memory-leak.html I tried to use the same method to debug but didn't find the root cause.\r\n\r\nEven `global.gc()` does not help for me, still seeing heap size keeps growing for each test.","> Found an article for how to use heap snapshot to debug jest memory leak here: https:\/\/chanind.github.io\/javascript\/2019\/10\/12\/jest-tests-memory-leak.html I tried to use the same method to debug but didn't find the root cause.\r\n> \r\n> Even `global.gc()` does not help for me, still seeing heap size keeps growing for each test.\r\n\r\nVery useful, thanks!","I have a very similar report: https:\/\/github.com\/jakutis\/ava-vs-jest\/blob\/master\/issue\/README.md\r\n\r\nTLDR: jest uses at least 2 times more memory than ava for same tests (jsdom\/node)","It seems `graceful-fs` has a potential memory leak issue, I mocked `graceful-fs` in my jest environment (with the trick suggested here https:\/\/github.com\/facebook\/jest\/issues\/6399#issuecomment-399888409), then the issue is resolved.   ","Is there any progress on this ? I still encouter this problem even with the most simple test suites (with and without ts-jest)","Having same issue with ts-jest, the graceful-fs tip didn't work for me","i have also repro'd this with https:\/\/github.com\/omgoshjosh\/jest-mem-leak-investigation \r\n![image](https:\/\/user-images.githubusercontent.com\/1960929\/80020520-0dcd4400-848e-11ea-8adc-dcd395d6ef7e.png)\r\n","strangely, running `node --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage` \"fixes\" the issue but running it with `npx jest --runInBand --logHeapUsage` or `.\/node_modules\/.bin\/jest --runInBand --logHeapUsage` produces a memory leak\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1960929\/80248473-d218b280-8624-11ea-928d-831395f3f293.png)\r\n\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1960929\/80248512-e9f03680-8624-11ea-8f85-e44953fcf8f2.png)\r\n","[jest-memory-leak-demo](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo)\r\n\r\nI've been experiencing memory leaks due to this library and it has made it unusable on one of the projects I'm working on. I've reproduced this in jest-memory-leak-demo, which ***only*** has jest as a dependency. I've reproduced this on macOS and within a Docker container using the `node:14.3.0` image.\r\n\r\n```\r\nnpx envinfo --preset jest\r\n\r\n  System:\r\n    OS: macOS 10.15.5\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-8569U CPU @ 2.80GHz\r\n  Binaries:\r\n    Node: 14.3.0 - \/usr\/local\/bin\/node\r\n    Yarn: 1.22.4 - ~\/.yarn\/bin\/yarn\r\n    npm: 6.13.7 - ~\/.npm-global\/bin\/npm\r\n  npmPackages:\r\n    jest: ^26.0.1 => 26.0.1\r\n```\r\n\r\nIn [jest-memory-leak-demo](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo), there are 50 test files with the following script:\r\n\r\n```javascript\r\nit('asserts 1 is 1', () => {\r\n  for (let i = 0; i < 1000; i++) {\r\n    expect(1).toBe(1);\r\n  }\r\n});\r\n```\r\nRunning a test yields 348 MB and 216 MB heap sizes in macOS and Docker, respectively.\r\n\r\nHowever, when I run with node's gc exposed:\r\n\r\n```\r\nnode --expose-gc .\/node_modules\/.bin\/jest --logHeapUsage --runInBand\r\n```\r\n\r\nit yields 38 MB and 36 MB heap sizes in macOS and Docker, respectively.\r\n\r\nLooking into the code, I see that `jest-leak-detector` is conditionally constructed based on the [config](https:\/\/github.com\/facebook\/jest\/blob\/790fe2aeee47c4d46b3836c368806e7971c2cf69\/packages\/jest-runner\/src\/runTest.ts#L142). So if I don't run jest with `--detectLeaks`, I expect exposing the gc to have no effect. I searched jest's dependencies to see if any package is abusing the gc, but I could not find any.\r\n\r\nIs there any progress on this issue?","This is a dummy post to report this issue is still present and makes TDD harder so I'll look forward to any solution","> strangely, running `node --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage` \"fixes\" the issue but running it with `npx jest --runInBand --logHeapUsage` or `.\/node_modules\/.bin\/jest --runInBand --logHeapUsage` produces a memory leak\r\n> \r\n> [...]\r\n\r\nWe are experiencing the same issue even for empty test files.\r\n\r\nI am starting to think that either `--logHeapUsage` is not working properly or that by using `--expose-gc` only the reports are changing.\r\n\r\nLeaks are really only gone when running the command below. Using `--expose-gc` just changes the report.\r\n\r\n```\r\nafterEach(() => {\r\n  if (global.gc) {\r\n    global.gc();\r\n  }\r\n});\r\n```","It is surprising that forcing GC seems to fix the issue for us as well (FYI, the jest test runner calls `gc()` if available when `--logHeapUsage` is enabled, hence the behavior @omgoshjosh saw). I'm assuming that actually leaked references wouldn't get marked by a forced GC any differently than they would during a normally scheduled GC. Forcing GC in test hooks is also a very poor workaround, because it can slow things down tremendously.\r\n\r\nAll in all, very peculiar behavior.","having the same issues here as well","+1","+1 \r\n","+1, same issue","a few colleagues who are on a mac don't seem to be able to replicate this bug. could it be linux specific?","> a few colleagues who are on a mac don't seem to be able to replicate this bug. could it be linux specific?\r\n\r\nDefinitely not, I'm also on OSX, and it happens left and right.","> a few colleagues who are on a mac don't seem to be able to replicate this bug. could it be linux specific?\r\n\r\nI noticed a significant difference in the heap size on OSX vs Docker Node image after exposing the node GC. While the heap kept around ~400MB on the OSX it still climbed to 1300MB in the Docker container. Without exposing the GC the difference is negligible. So there might be some difference in how the GC works on different platforms.","Same here, my CI crashes all time","I have the same issue. CI crashes and is leaking memory.","# Quick Recap\r\n\r\n* Good - Running tests with `jest@23` works as expected - heap size oscillates but goes down to original - it appears like the GC is succeeding to collect all memory allocated during the tests\r\n* Bad - Running tests with `jest@24+` including `jest@26.6.3` - heap size continues to grow over time, oscillating, but doesn't seem to go down to the initial size - My assumption is that there's a memory leak preventing GC for freeing up all the memory\r\n* I took the screenshots after running @jaredjj3's example repo - [see this comment](https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-639874717))\r\n\r\n@SimenB help? \ud83d\ude4f \r\n\r\n### Running with `jest@23`\r\n\r\n<img width=\"383\" alt=\"Screen Shot 2020-11-23 at 13 44 50\" src=\"https:\/\/user-images.githubusercontent.com\/5766483\/99959380-977e2080-2d93-11eb-9c99-a88b84719100.png\">\r\n\r\n### Running with `jest@26`\r\n\r\n<img width=\"363\" alt=\"Screen Shot 2020-11-23 at 13 44 33\" src=\"https:\/\/user-images.githubusercontent.com\/5766483\/99959376-94833000-2d93-11eb-8111-25cb803013a1.png\">\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","For those wanting to get their CI pipeline going with `jest@26`, I found a workaround that works for me. ([this](https:\/\/github.com\/integrations\/slack\/pull\/895) issue comment helped, combined with this [explanation](https:\/\/medium.com\/@ashleydavis75\/node-js-memory-limitations-30d3fe2664c0)). I increased the maximum oldspace on node, and although the leak persists, my CI pipeline seems to be doing better\/passing. Here my package.json input:\r\n` \"test-pipeline\": \"node --max-old-space-size=4096 .\/node_modules\/.bin\/jest --runInBand --forceExit --logHeapUsage --bail\",`\r\n\r\nWhat else I tried and scraped together from a few other issues:\r\n- used the above fix: exposed garbage collector (i.e. `node --expose-gc .\/node_modules\/...`) && used the `afterEach` (did nothing)\r\n- inspected the port where my my server was running (from [here](https:\/\/making.close.com\/posts\/finding-the-cause-of-a-memory-leak-in-jest), increasing heap _seemed_ invisible to the inspector, while at the same time responding to changes)\r\n- patched graceful-fs with [this](https:\/\/github.com\/mikro-orm\/mikro-orm\/commit\/5e848473cffafb5ae981344cbe1868b987b4871a). Probably taken from this [issue](https:\/\/github.com\/facebook\/jest\/issues\/6399), but it did nothing","Hey guys, my team also encounter this issue, and we would like to share our solution.\r\n\r\n**Firstly**, we need to understand that Node.js will find its best timing to swipe unused memory by its own garbage collection algorithm. If we don\u2019t configure it, Node.js will do their own way. \r\n\r\nAnd we have several ways to configure \/ limit how garbage collection works. \r\n\r\n- `--expose-gc` flag \uff1aIf we add this flag while running node.js, there will be a global function called `gc` being exposed. If we call `global.gc()`, node.js will swipe all known unused memory. \r\n\r\n- `--max-old-space-size=xxx` : If we add this flag while running node.js. We are asking node.js to swipe all known unused memory if unused memory has reach xxx MB. \r\n\r\n \r\n\r\n**Secondly**, I think we have 2 types of memory leak issue.\r\n\r\n- **Type 1**: Node.js knows that there are some unused memory, but he think that doesn\u2019t matter his process, so he didn\u2019t swipe unused memory.  However, he ran out of all memory on his container \/ device. \r\n\r\n- **Type 2**: Node.js doest **NOT** know that there exists some unused memory. Even he swipe all unused memory, he still consumed too much memory and finally run out all memory. \r\n\r\nFor **Type 1**, it\u2019s easier to solve. We can use `--expose-gc` flag and run `global.gc()` in each test to swipe unused memory. \r\nOr, we can add `--max-old-space-size=xxx` to remind node.js to swipe all known unused memory once it reached limit. \r\n\r\nBefore adding `--max-old-space-size=1024`:\r\n\r\n```\r\n PASS  src\/xx\/x1.test.js (118 MB heap size)\r\n PASS  src\/xx\/x2.test.js (140 MB heap size)\r\n ...\r\n PASS  src\/xx\/x30.test.js (1736 MB heap size)\r\n PASS  src\/xx\/x31.test.js (1746 MB heap size)\r\n...\r\n```\r\n\r\nAfter adding `--max-old-space-size=1024`:\r\n```\r\n PASS  src\/xx\/x1.test.js (118 MB heap size)\r\n PASS  src\/xx\/x2.test.js (140 MB heap size)\r\n ...\r\n PASS  src\/xx\/x20.test.js (893 MB heap size)\r\n PASS  src\/xx\/x21.test.js (916 MB heap size)\r\n \r\n\/\/ -> (everytime it reachs 1024MB, it will swipe ununsed memory)\r\n \r\n PASS  src\/xx\/x22.test.js (382 MB heap size)\r\n ...\r\n```\r\n\r\n(Note: if we specify lower size, it will of course use less unused memory, but more frequent to swipe it)\r\n\r\nFor **Type 2**, we may need to investigate where memory leaks happened. This would be more difficult.\r\n\r\nBecause in our team, main cause is **Type I** issue, so our solution is adding `--max-old-space-size=1024` to Node.js while running tests\r\n\r\n---\r\n\r\nFinally, I would like to explain why `--expose-gc` works in [previous comment](https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-619194538).\r\n\r\nBecause in [Jest source code](https:\/\/github.com\/facebook\/jest\/blob\/64de4d7361367fd711a231d25c37f3be89564264\/packages\/jest-runner\/src\/runTest.ts#L307), if we add `--logHeapUsage` to Jest, Jest will call `global.gc()` if `gc` exists. In other words, if we add `--logHeapUsage` to Jest and add `--expose-gc` to Node.js, in current version of Jest, it will force Node.js to swipe all known unused memory for each run of test.\r\n\r\nHowever, I don\u2019t really think adding `--logHeapUsage` and `--expose-gc` to solve this issue is a good solution. Because it\u2019s more like we \u201caccidentally\u201d solve it. \r\n\r\n---\r\n\r\nNote:\r\n`--runInBand`: ask Jest to run all tests sequentially. By default, Jest will run tests in parallel by several workers. \r\n`--logHeapUsage`: log heap memory usage in each test.\r\n","Something that might be helpful for those debugging a seeming memory leak in you Jests tests:\r\n\r\nNode's default memory limit applies __seperately to each worker__, so make sure that the total memory available > number of workers * the memory limit. \r\n\r\nWhen the combined memory limit of all of the workers is greater than the available memory, Node will not realized that it needs to run GC, and the memory usage will climb until it OOM's. \r\n\r\nSetting the memory limit correctly causes Node to run GC much more often. \r\n\r\nFor us, the effect was dramatic. When we had the `--max-old-space-size=4096` and three workers on a 6GB machine, memory usage increased to over 3gb per worker and eventually OOM'd. Once we set it to 2gb, memory usage stayed below 1gb per worker, and the OOM's went away. ","I believe I may be experiencing the same problem as reported in this thread. \r\n\r\nSome observations I've made when running `node --inspect-brk --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage`: \r\n- The largest jump (or at least one of the largest jumps) in heap usage tends to occur on the second test file executed\r\n- Heap usage seems to stabilize into the second half of test files executed (in the example below, around the point when `DropoffPreferences.test.js` is run) \r\n- UPDATE: Replacing `--inspect-brk` with `--inspect` actually decreases the overall heap usage. I'm curious about the reason behind this. Using the command `node --inspect --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage` caused the heap size to increase from 45 MB after the first test to just 59MB after the last test. \r\n\r\nMy environment: \r\n```\r\n  System:\r\n    OS: macOS 10.15.7\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz\r\n  Binaries:\r\n    Node: 14.15.1 - \/usr\/local\/bin\/node\r\n    npm: 6.14.8 - \/usr\/local\/bin\/npm\r\n  npmPackages:\r\n    jest: 26.6.0 => 26.6.0\r\n```\r\n\r\nThe command I use to monitor heap usage during tests:\r\n`node --inspect-brk --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage`\r\n\r\nSample results:\r\n```\r\npages\/Web\/Account\/PersonalInfo\/__tests__\/PersonalInfo.test.js (6.652 s, 59 MB heap size)\r\npages\/Web\/Account\/DeliverySignup\/__tests__\/DeliverySignupForm.test.js (85 MB heap size)\r\npages\/Web\/Account\/DonationSignup\/__tests__\/DonationSignupForm.test.js (87 MB heap size)\r\npages\/Web\/DonorFulfillment\/DonorFulfillment.test.js (96 MB heap size)\r\npages\/Web\/Account\/PersonalInfo\/__tests__\/PasswordSection.test.js (109 MB heap size)\r\npages\/Web\/Account\/OrganizationInfo\/__tests__\/OrgAddressSection.test.js (112 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsDropdown.test.js (121 MB heap size)\r\nApp.test.js (124 MB heap size)\r\npages\/Web\/Account\/OrganizationInfo\/__tests__\/OrgNameSection.test.js (135 MB heap size)\r\ncomponents\/Dropdown\/Dropdown.test.js (153 MB heap size)\r\ncomponents\/Wizard\/Wizard.test.js (148 MB heap size)\r\npages\/Web\/Account\/OrganizationInfo\/__tests__\/OrganizationInfo.test.js (155 MB heap size)\r\npages\/Web\/Account\/RecipientAccountSettings\/RecipientAccountSettings.test.js (160 MB heap size)\r\npages\/Web\/Account\/PersonalInfo\/__tests__\/PersonalNameSection.test.js (167 MB heap size)\r\npages\/Web\/Account\/PersonalInfo\/__tests__\/EmailSection.test.js (173 MB heap size)\r\npages\/Web\/Account\/DonationSignup\/__tests__\/DonationSignup.test.js (180 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/OptIn.test.js (186 MB heap size)\r\ncomponents\/Breadcrumbs\/Breadcrumbs.test.js (184 MB heap size)\r\npages\/Web\/Account\/DeliverySignup\/__tests__\/DeliverySignup.test.js (185 MB heap size)\r\ncomponents\/UserAvailability\/__tests__\/TimeBlock.test.js (179 MB heap size)\r\ncomponents\/Modal\/Modal.test.js (185 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsTextArea.test.js (195 MB heap size)\r\npages\/Web\/Account\/PersonalInfo\/__tests__\/PhoneSection.test.js (190 MB heap size)\r\npages\/Web\/Account\/DropoffPreferences\/DropoffPreferences.test.js (183 MB heap size)\r\npages\/Web\/RequestSupplies\/__tests__\/ConfirmDropoffPreferences.test.js (181 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsAvailability.test.js (187 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsCard.test.js (186 MB heap size)\r\npages\/Web\/RequestSupplies\/__tests__\/ConfirmContactInfo.test.js (181 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsChild.test.js (186 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsEditManager.test.js (186 MB heap size)\r\npages\/Web\/Account\/DonorAccountSettings\/DonorAccountSettings.test.js (180 MB heap size)\r\npages\/Web\/Account\/DeliveryPreferences\/DeliveryPreferences.test.js (185 MB heap size)\r\npages\/Web\/Account\/DonationPreferences\/DonationPreferences.test.js (184 MB heap size)\r\ncomponents\/UserAvailability\/__tests__\/UserAvailability.test.js (181 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/AccountSettings.test.js (182 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsParent.test.js (182 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/VolunteerStatus.test.js (182 MB heap size)\r\npages\/Web\/Account\/_helpers\/__tests__\/SettingsContainer.test.js (187 MB heap size)\r\ncomponents\/RouteBreadcrumbs\/RouteBreadcrumbs.test.js (188 MB heap size)\r\n```\r\n\r\nTo help isolate the problem, I commented out all of my tests and replaced them with a dummy test case in each of my test files: \r\n```\r\ntest(\"dummy test\", () => {\r\n    expect(1).toBe(1);\r\n})\r\n```\r\n\r\nThe results after doing so still have memory leakage, but the increase in heap usage increases at a more linear rate of ~3MB per test file (where each file now only contains the dummy test): \r\n ```\r\nPASS  src\/pages\/Web\/RequestSupplies\/__tests__\/ConfirmDropoffPreferences.test.js (47 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DonationSignup\/__tests__\/DonationSignupForm.test.js (54 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsEditManager.test.js (57 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DeliverySignup\/__tests__\/DeliverySignupForm.test.js (60 MB heap size)\r\n PASS  src\/components\/UserAvailability\/__tests__\/UserAvailability.test.js (63 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/PersonalInfo\/__tests__\/PhoneSection.test.js (66 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/OptIn.test.js (69 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DonationPreferences\/DonationPreferences.test.js (72 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DonationSignup\/__tests__\/DonationSignup.test.js (75 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/OrganizationInfo\/__tests__\/OrgNameSection.test.js (78 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsContainer.test.js (81 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DropoffPreferences\/DropoffPreferences.test.js (84 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/AccountSettings.test.js (87 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/RecipientAccountSettings\/RecipientAccountSettings.test.js (90 MB heap size)\r\n PASS  src\/components\/RouteBreadcrumbs\/RouteBreadcrumbs.test.js (93 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsDropdown.test.js (96 MB heap size)\r\n PASS  src\/components\/Modal\/Modal.test.js (99 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/PersonalInfo\/__tests__\/EmailSection.test.js (101 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsTextArea.test.js (105 MB heap size)\r\n PASS  src\/components\/Breadcrumbs\/Breadcrumbs.test.js (107 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsAvailability.test.js (110 MB heap size)\r\n PASS  src\/pages\/Web\/RequestSupplies\/__tests__\/RequestSupplies.test.js (113 MB heap size)\r\n PASS  src\/pages\/Web\/RequestSupplies\/__tests__\/ConfirmContactInfo.test.js (116 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DeliveryPreferences\/DeliveryPreferences.test.js (119 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/PersonalInfo\/__tests__\/PersonalInfo.test.js (122 MB heap size)\r\n PASS  src\/App.test.js (125 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsCard.test.js (127 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/OrganizationInfo\/__tests__\/OrgAddressSection.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DeliverySignup\/__tests__\/DeliverySignup.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/VolunteerStatus.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsParent.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/PersonalInfo\/__tests__\/PersonalNameSection.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/DonorFulfillment\/DonorFulfillment.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/PersonalInfo\/__tests__\/PasswordSection.test.js (130 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsChild.test.js (131 MB heap size)\r\n PASS  src\/components\/Wizard\/Wizard.test.js (131 MB heap size)\r\n PASS  src\/components\/UserAvailability\/__tests__\/TimeBlock.test.js (131 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/OrganizationInfo\/__tests__\/OrganizationInfo.test.js (131 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/DonorAccountSettings\/DonorAccountSettings.test.js (130 MB heap size)\r\n```\r\n\r\nThe suggestion of using `--max-old-space-size` does seem to resolve the issue for me, although I haven't yet added my original tests back into my files: \r\n```\r\nnode --max-old-space-size=70 --expose-gc .\/node_modules\/.bin\/jest --runInBand --logHeapUsage\r\n```\r\n\r\nHeap usage for all of my tests now linger at around 47 MB: \r\n```\r\n PASS  src\/pages\/Web\/RequestSupplies\/__tests__\/ConfirmDropoffPreferences.test.js (45 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/PersonalInfo\/__tests__\/PersonalInfo.test.js (46 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsChild.test.js (45 MB heap size)\r\n PASS  src\/components\/Wizard\/Wizard.test.js (45 MB heap size)\r\n...\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsContainer.test.js (49 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/OrganizationInfo\/__tests__\/OrgNameSection.test.js (47 MB heap size)\r\n PASS  src\/components\/Modal\/Modal.test.js (47 MB heap size)\r\n PASS  src\/pages\/Web\/Account\/_helpers\/__tests__\/SettingsAvailability.test.js (47 MB heap size)\r\n\r\n```","experiencing the exact same issue with jest+ts-jest on a nestjs project\r\n\r\nevent the simplest test is reporting 500mb of heap size. \r\n\r\n```\r\n PASS  tier5-test\/one.get.spec.ts (7.304 s, 596 MB heap size)\r\n```\r\n\r\n```\r\ndescribe('one', () => {\r\n\r\n  it('one', async () => {\r\n    expect(2).toEqual(2);\r\n  });\r\n});\r\n```","Here are my findings.\r\n\r\nDid a study on 4 of our apps, made a benchmark with the following commands.\r\n\r\nCase | Command |\r\n-- | -- | \r\nA | NODE_ENV=ci node node_modules\/.bin\/jest --coverage --ci --runInBand --logHeapUsage\r\nB | NODE_ENV=ci node --expose-gc node_modules\/.bin\/jest --coverage --ci --runInBand --logHeapUsage\r\nC | NODE_ENV=ci node --expose-gc .\/node_modules\/.bin\/jest --logHeapUsage\r\nD | NODE_ENV=ci node node_modules\/.bin\/jest --coverage --ci --logHeapUsage\r\n\r\n**NB**: \"order\" is the rank of the test within the running of the command e.g. 1 means it has been ran first, it's just the order in which the console outputs the test result at the end.\r\n\r\n**EDIT:** All of this is running on my local machine, trying this on the pipeline was even more instructive since only the case where there's GC and no RIB results in 100% PASS. Also GC makes it twice as fast, imagine if you had to pay for memory usage on servers.\r\n\r\n**EDIT 2:** case C has no `--coverage --ci` option but it does not impact performance. I added a chart to measure average pipeline speed with above scenarios. The graph is the average time of tests job on pipeline, 3 execution for each case, regardless of test outcome (All Pass vs some failing tests, because at the moment of collecting data some tests were unstable).\r\n\r\n**Cross apps**\r\nMax Heap\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122192264-caa11200-ce93-11eb-9c49-1d5f7c6d3141.png)\r\n\r\nAverage Heap\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122192697-308d9980-ce94-11eb-9ecd-6100b9d41214.png)\r\n\r\n**App1**\r\nMax Heap and Average Heap\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122193068-79dde900-ce94-11eb-87fb-83e09169d94f.png)\r\n\r\nHeap Chronology\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122194051-5d8e7c00-ce95-11eb-99f4-e2450975086c.png)\r\n\r\nFile Based Heap (x axis is file path)\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122194890-266c9a80-ce96-11eb-8de2-3b4be532deae.png)\r\n\r\n\r\n**App2**\r\nMax Heap and Average Heap\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122193450-caeddd00-ce94-11eb-8a89-6cecedeabae8.png)\r\n\r\nHeap Chronology\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122194301-99c1dc80-ce95-11eb-8ea5-ff374df99d1f.png)\r\n\r\nFile Based Heap (x axis is file path)\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122195010-413f0f00-ce96-11eb-91c9-8f6aa17071d3.png)\r\n\r\n\r\n**App3**\r\nMax Heap and Average Heap\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122193509-d6d99f00-ce94-11eb-8c00-60f1673f739f.png)\r\n\r\nHeap Chronology\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122194360-a7776200-ce95-11eb-8287-783744ae6d2a.png)\r\n\r\nFile Based Heap (x axis is file path)\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122195124-59af2980-ce96-11eb-832f-7ba1923bfbdc.png)\r\n\r\n\r\n**App4**\r\nMax Heap and Average Heap\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122193572-e48f2480-ce94-11eb-9be2-e98c87296bb7.png)\r\n\r\nHeap Chronology\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122194407-b3fbba80-ce95-11eb-91af-69aac59b332f.png)\r\n\r\nFile Based Heap (x axis is file path)\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122195337-92e79980-ce96-11eb-81d8-16cbb9e25b1d.png)\r\n\r\n**Rank of appearance of the highest heap**\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/122193889-2fa93780-ce95-11eb-8ea0-d9f0aa94f92a.png)\r\n\r\n\r\n**App 1**\r\nAverage time of execution for the test job out of 3 pipelines for App1.\r\n![image](https:\/\/user-images.githubusercontent.com\/17337190\/123096113-0c4f3100-d42f-11eb-9f3b-83fbe11623d4.png)\r\n\r\nHope this helps or re-kindles the debate.","Did a heap snapshot for my test suite and noticed that the majority of the memory was being used by strings that store entire source files, often the same string multiple times!\r\n\r\n<img width=\"1479\" alt=\"Screenshot 2021-06-23 at 1 33 30 AM\" src=\"https:\/\/user-images.githubusercontent.com\/8946207\/122994204-d2961000-d3c5-11eb-80c8-01bc315310c2.png\">\r\n\r\n\r\nThe size of these strings continue to grow as jest scans and compiles more source files.  Does it appear that jest or babel holds onto the references for the source files (for caching maybe) and never clears them?\r\n","> Did a heap snapshot for my test suite and noticed that the majority of the memory was being used by strings that store entire source files, often the same string multiple times!\r\n> \r\n> \r\n> The size of these strings continue to grow as jest scans and compiles more source files. Does it appear that jest or babel holds onto the references for the source files (for caching maybe) and never clears them?\r\n\r\nI have found the same thing with Jest, but I have the feeling this is normal. Still, it does beg the question of whether these strings are cleared once jest has finished using them\r\n\r\nHowever, what I've discovered not too long ago, is that importing data from .json files caused my \"memory leak\", or rather, a \"memory overflow\". Once I stuck the JSON files into js files (the dat aof which now sits inside some variable), and exported that variable, heap usage had been significantly reduced during testing, enough that our pipeline didn't crash anymore. ","We at [renovate](\/renovatebot\/renovate) solved the major issues by correctly disable `nock` after each test and run jest with `node --expose-gc node_modules\/jest\/bin\/jest.js --logHeapUsage`","We also noticed that there were a ton of strings containing modules that were eating up memory. It all went away when we set memory limits correctly: https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-744561779\r\n\r\nSetting memory limits correctly is effectively the same as forcing GC with `--logHeapUsage`, as node will run GC automatically to keep from going over the allowed memory. ","When I `--logHeapUsage --runInBand` on my test suite with about 1500+ tests, the memory keeps climbing from ~100MB to ~600MB. The growth seems to be in these strings, and array of such strings (source).\r\n\r\nIt is apparent that the number of compiled files will grow as jest moves further in the test suite \u2014 but if this doesn't get GC'ed, I don't have a way to separate real memory leaks from increases due to more modules stored in memory.\r\n\r\nOn running a reduced version my test suite (only about ~5 tests), I was able to narrow down on this behaviour \u2014\r\n\r\nLet's say we had \u2014 TEST A, **TEST B**, TEST C, TEST D\r\n\r\nI was observing `TEST B`. Without doing anything \u2014\r\n\r\n```\r\nTEST A (135 MB heap size)\r\nTEST B (150 MB heap size)\r\nTEST C (155 MB heap size)\r\nTEST D (157 MB heap size)\r\n```\r\nIf I reduce the number of imports `TEST B` is making, and replace them with stubs \u2014\r\n\r\n```\r\nTEST A (135 MB heap size)\r\nTEST B (130 MB heap size). <-- Memory falls!\r\nTEST C (140 MB heap size)\r\nTEST D (147 MB heap size)\r\n```\r\nThis consistently reduced memory across runs. Also, the imports themselves did not seem to have any obvious leaks (the fall in memory corresponded with the number of imports I commented out).\r\n\r\nOther observations:\r\n- Disabling babel source maps reduces overall memory usage\r\n- JS transformers can have a noticeable impact on memory depending on how they're written.","v27 seems to leak more memory. The test of my project never encountered OOM on v26, but it was killed on v27.","> We at [renovate](\/renovatebot\/renovate) solved the major issues by correctly disable `nock` after each test and run jest with `node --expose-gc node_modules\/jest\/bin\/jest.js --logHeapUsage`\r\n\r\nI went trough the pull requests in your repo but can you give some more information on this? I have been having issues with large heap memory and flaky tests in CI only and I use nock. Any help is appreciated.\r\n\r\nThis is currently the way I manage nock in tests:\r\n\r\n```\r\n  \/\/ nock in used directly from import no local scope is declared\r\n  import nock from 'nock';\r\n  \r\n  beforeEach(() => {\r\n    nock.cleanAll();\r\n    \/\/ More unrelated cleanup stuff\r\n  });\r\n\r\n  afterEach(() => {\r\n    nock.restore();\r\n    nock.activate();\r\n    \/\/ More unrelated cleanup stuff\r\n  });\r\n\r\n  afterAll(() => {\r\n    nock.cleanAll();\r\n    \/\/ More unrelated cleanup stuff\r\n  });\r\n```","You need ` nock.restore();` in `afterAll`, so `nock` is self-removing from `node:http`, otherwise it will activate again and again\r\n\r\neg: nock > nock > nock > nock > node:http\r\n\r\nhttps:\/\/github.com\/renovatebot\/renovate\/blob\/394f0bb7416ff6031bf7eb14498a85f00a6305df\/test\/http-mock.ts#L106-L121\r\n\r\n```ts\r\n \/\/ nock in used directly from import no local scope is declared\r\n  import nock from 'nock';\r\n  \r\n  beforeEach(() => {\r\n    nock.cleanAll();\r\n    \/\/ More unrelated cleanup stuff\r\n  });\r\n\r\n  afterEach(() => {\r\n    \/\/ More unrelated cleanup stuff\r\n  });\r\n\r\n  afterAll(() => {\r\n    nock.cleanAll();\r\n    nock.restore();\r\n    \/\/ More unrelated cleanup stuff\r\n  });\r\n```","I'm being affected by this as well. Our application is a react app with typescript.\r\n\r\nI have tried `NODE_OPTIONS=--max_old_space_size=2048`, `jest.useFakeTimers();`, removing all `import *`, `--clear-cache`, with and without `--coverage`. To no avail.\r\n\r\nConfusingly when I run the chrome devtools to look at the memory heap, it seems to think the heap is only 25mb? It's over 5000mb so I'm not sure what that is about. There are a crapload of strings with code though.\r\n\r\nI'm wondering if it's some interaction with the version of jest, node, typescript, react, babel, or eslint? \r\n\r\nI'm using:\r\njest `27.2.4` \r\nnode `v16.4.0`\r\ntypescript `4.4.3`\r\neslint `7.32.0`\r\nreact `16.4.2`\r\n\r\nEDIT: Currently using this command `node  --inspect-brk  --expose-gc .\/node_modules\/.bin\/jest  --watch --watchAll=false --logHeapUsage --run_in_band --no-cache`\r\n\r\nEDIT 2: Downgrading to `jest@24.9.0` and `ts-jest@26.4.2` seems to fix the issue. The memory never went over 1gb and it completed in 60 seconds instead of 300+ seconds. \r\n\r\nI found `NODE_OPTIONS=--max_old_space_size=8000` did work with `jest@27` however it obviously doesn't fix anything, the memory usage is still 5x higher then it should be and that's causing slowdowns with swap\r\n\r\nEDIT 3: I have no idea what changed, but now tests take 4 minutes again and are filled with errors like\r\n\r\n``` \r\nFAIL  tests\/handheld\/Index.tsx\r\n  \u25cf Test suite failed to run\r\n\r\n    TypeError: buffer.reduce is not a function\r\n\r\n      at _default (node_modules\/jest-cli\/node_modules\/@jest\/console\/build\/getConsoleOutput.js:41:29)\r\n```\r\n\r\nand the summary makes no sense\r\n\r\n```\r\nSnapshot Summary\r\n \u203a 28 snapshots failed from 14 test suites. Inspect your code changes or re-run jest with `-u` to update them.\r\n\r\nTest Suites: 152 failed, 109 passed, 261 of 179 total\r\nTests:       49 failed, 417 passed, 466 total\r\nSnapshots:   28 failed, 152 passed, 180 total\r\nTime:        241.84s\r\n```","This works for me: https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/1967#issuecomment-834090822\r\n\r\nAdd this to jest.config.js\r\n```\r\nglobals: {\r\n    'ts-jest': {\r\n      isolatedModules: true\r\n    }\r\n  }\r\n ```","In the end what really improved our pipeline was fiddling with the\nmaxworkers option to figure our how many would make the fastest yet most\nstable pipeline. The memory leak thingy did not seem to stabilize and\nreduce pipeline times as much as manually finding the right figure for\nmaxworkers actually did.\n\nLe sam. 9 oct. 2021 \u00e0 10:37, Huy Tran ***@***.***> a \u00e9crit :\n\n> This works for me: kulshekhar\/ts-jest#1967 (comment)\n> <https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/1967#issuecomment-834090822>\n>\n> Add this to jest.config.js\n>\n> globals: {\n>     'ts-jest': {\n>       isolatedModules: true\n>     }\n>   }\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-939239534>, or\n> unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AEEIWZWW5MRCPY72EDYKMXDUF7PJ7ANCNFSM4GW5MRBQ>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https:\/\/apps.apple.com\/app\/apple-store\/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https:\/\/play.google.com\/store\/apps\/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n","> This works for me: [kulshekhar\/ts-jest#1967 (comment)](https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/1967#issuecomment-834090822)\r\n> \r\n> Add this to jest.config.js\r\n> \r\n> ```\r\n> globals: {\r\n>     'ts-jest': {\r\n>       isolatedModules: true\r\n>     }\r\n>   }\r\n> ```\r\n\r\nThis totally fixed it for me thank you so much!","Why doesn't jest support TS out of the box... Do they not use it @ facebook?\r\n","@pbrain19 Jest does support TS out of the box, but via Babel and not `ts-jest`.","> Did a heap snapshot for my test suite and noticed that the majority of the memory was being used by strings that store entire source files, often the same string multiple times!\r\n> \r\n> <img alt=\"Screenshot 2021-06-23 at 1 33 30 AM\" width=\"1479\" src=\"https:\/\/user-images.githubusercontent.com\/8946207\/122994204-d2961000-d3c5-11eb-80c8-01bc315310c2.png\">\r\n> \r\n> The size of these strings continue to grow as jest scans and compiles more source files. Does it appear that jest or babel holds onto the references for the source files (for caching maybe) and never clears them?\r\n\r\n+1, we are also running into this issue. Jest is using over 5GB per worker for us. Our heap snapshots show the same thing as above. Any updates would be greatly appreciated.","How can we force jest to delete these? ","I've observed today two unexplained behaviours:\r\n1. There's too much memory usage even when disabling code transforms and cleaning jest's cache\r\n1. When using `--forceExit` or `--detectOpenHandles` (or a combination of both), the memory usage drops from 1.4GB to roughly 300MB\r\n\r\nI don't know if this is specific to our codebase or if the memory leak issue is tied to tests that somehow don't really finish\/cleanup properly (a \"bug\" that detectOpenHandles or forceExit somehow fix)","Bingo. This seems to be the fix alone with making sure to mock any external dependency that maybe no be your DB. In my case I was using a stats lib and bugsnag. When using the createMockFromModule it seems to actually run the file regardless so I ended up just mocking both along with running using `NODE_OPTIONS=--max-old-space-size=6144 NODE_ENV=test && node --expose-gc .\/node_modules\/.bin\/jest -i --detectOpenHandles --logHeapUsage --no-cache`\r\n\r\n@fazouane-marouane thanks so much... this one comment has legit saved the day.\r\n\r\nFor the record I use ts-jest. Memory Leak is gone!","unfortunately none of these solutions worked for me. test suite bloats out to several GB in less than 30 seconds (locally), all ts related\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/633621\/138872939-10df731a-8543-4bf1-8f11-1bc25818d8de.png)\r\n\r\nthe more it has the more it uses!","This is going to sound bad but I have been struggling with the same situation as @pastelsky - memory heap dumps showing huge allocation differences in `array` and `string` between each snapshot and memory not being released after test run is completed.\r\n\r\nWe have been running Jest from inside Node with `jest.runCLI`, I tried everything suggested in this topic and in other issues on GitHub:\r\n- upgrade to newest Jest (from 26.6.3 to 27 latest)\r\n- running with --gc-expose + logHeapUsage\r\n- running in band\r\n- running with 1 worker\r\n- setting max-old-space-size\r\n- More CPU\r\n- More RAM - this of course worked and tests finished but memory once again never been released back\r\n\r\nThe only thing that reduced memory by around 200MB was to switch off default `babel-jest` transformer since we did not need it at all:\r\n```\r\ntestEnvironment: \"node\",\r\ntransform      : JSON.stringify({})\r\n``` \r\nThis has indeed reduced memory usage but still not to the level where we could accept it.\r\n\r\nAfter two days of memory profiling and trying different things, I have just switched to `mocha`runner  since our tests were primarily E2E tests (no typescript, no babel, Node 12) making request to API it was fairly simple:\r\n- change `test` to `it`\r\n- change `beforeAll` to `before`\r\n- change `afterAll` to `after`\r\n\r\nAfter deploying this, tests have been running with stable memory usage of 70MB and never going above while with Jest it was peaking at 700MB.\r\nI am not here to advertise mocha (my first time using it to run tests) but it literally just worked so if you have fairly simple test suites you could try changing your runner if you want to run tests programmatically.\r\n","I'm seeing this same leak, with heap snapshots that look remarkably similar to those posted by @pastelsky above.  I'm at Jest 27.0.6.  Tried moving ahead to 27.4.3 and back to 26.6.3, to no avail.  Tried a few things mentioned in this issue, without affect.  ","**TLDR - The memory leak is not present in version 22.4.4, but starts appearing in the subsequent version 23.0.0-alpha.1. The following steps are for (1) the community to assert\/refute this and then (2) find the offending commit(s) causing the memory leak and increased memory usage.**\r\n\r\nIn https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-639874717, I mentioned that I created a repo [jest-memory-leak-demo](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo) to make this issue easier to reproduce in local and Docker environments.\r\n\r\nI took it a step further and decided to find the version that the memory leak started to show. I did this by listing all the versions returned from `yarn info jest`. Next, I manually performed a binary search to find the versions where version `i` does _not_ produce a memory leak and version `i + 1` does produce a memory leak.\r\n\r\nHere is my env info (I purposely excluded the `npmPackages` since the version was the variable in my experiment):\r\n\r\n```\r\nnpx envinfo --preset jest\r\n\r\n  System:\r\n    OS: macOS 12.0.1\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 17.1.0 - ~\/.nvm\/versions\/node\/v17.1.0\/bin\/node\r\n    Yarn: 1.22.17 - ~\/.nvm\/versions\/node\/v17.1.0\/bin\/yarn\r\n    npm: 8.1.2 - ~\/.nvm\/versions\/node\/v17.1.0\/bin\/npm\r\n```\r\n\r\nThe key finding is in [jest-memory-leak-demo\/versions.txt#L165-L169](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo\/blob\/3bd17ec5566416e9b5938e32abfefd147c714d8d\/versions.txt#L165-L169). You can see several iterations of the binary search throughout the file. I did one commit per iteration, so you also can examine the [commit history](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo\/commits\/master) starting at [edc0567ad4710ba1be2bf2f745a7d5d87242afc4](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo\/commit\/edc0567ad4710ba1be2bf2f745a7d5d87242afc4).\r\n\r\nThe following steps are for the community to validate these initial findings and ultimately use the same approach to find the offending commit causing the memory leaks. Here's a StackOverflow post that will help: [\"How to get the nth commit since the first commit?\"](https:\/\/stackoverflow.com\/questions\/24239737\/how-to-get-the-nth-commit-since-the-first-commit).\r\n\r\nIt would also be great if someone can write a script to do this in [jest-memory-leak-demo](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo). ~The most challenging part of doing this is programming memory leak detection~ edit: The script doesn't have to decide whether or not a test run yields a memory leak or not - it can take a commit range and produce test run stats at each commit. A list of versions can be found by running `yarn info jest`. I don't have time to do this at the moment.\r\n\r\n---\r\n\r\n>**NOTE**: I was not very scientific about defining what versions produce a memory leak and what versions don't. First of all, I should have used the `yarn docker test` command to reproduce the results on other machines, but I just wanted to get an answer as fast as possible. Second, for each version, I should have run the test command >30 times and then aggregated the results. If you decide to reproduce this in the way I did it, YMMV.\r\n\r\n>**NOTE**: For earlier versions, I had to add the following to my `package.json`:\r\n>\r\n>```\r\n>\"jest\": {\r\n>  \"testURL\": \"http:\/\/localhost\/\"\r\n>}\r\n>```\r\n>\r\n>If I didn't, I got the following error:\r\n>\r\n>```\r\n>SecurityError: localStorage is not available for opaque origins\r\n>```\r\n>\r\n>At first, I was diligent in removing this if it was not needed, but then I got lazy after iteration eight or so and just kept it. I don't know if this affected the results.\r\n","I have tested the reproduction with jest 24, jest 27 and jest 28 beta:\r\n\r\n| Version | --runInBand | min heap size | max heap size | \r\n|---|---|---|---|\r\n|  24.9.0 | `true` |  53 MB | 259 MB | \r\n|  24.9.0 | `false` |  47 MB | 61 MB | \r\n|  27.5.1 | `true` |  36 MB |  71 MB |\r\n|  27.5.1 | `false` |  26 MB |  **30 MB** |\r\n|  28.0.0-alpha.6 | `true` |  38 MB |  73 MB |\r\n|  28.0.0-alpha.6 | `false` |  27 MB |  36 MB |\r\n\r\n(All tested on node.js v14.15.3)\r\n\r\nI think *in general* the leak has become less of an issue, but the discrepancy between --runInBand=true and --runInBand=false suggests that there *is* still an issue.\r\n\r\nSee also:\r\n#12142 (leak when using --runInBand)\r\n#10467 (duplicate of this issue)\r\n#7311 (leak when using --runInBand)\r\n#6399 (leak when using --runInBand)\r\n\r\nAs for the cause, from other issues relating to leaks, I suspect that there are multiple issues playing a role. For example:\r\n\r\n#6738 `[Memory Leak] on module loading`\r\n#6814 `Jest leaks memory from required modules with closures over imports`\r\n#8984 `jests async wrapper leaks memory`\r\n#9697 `Memory leak related to require` (might be a duplicate of \/ has common cause with 6738?)\r\n#10550 `Module caching memory leak`\r\n#11956 `[Bug]: Memory consumption issues on Node JS 16.11.0+`\r\n\r\nAnd #8832 could either be another --runInBand issue or a require \/ cache leak. Edit: It seems to be both. It leaks without --runInBand, but activating the option makes the problem much worse. \r\n\r\nThere are also leak issues with coverage, JSDOM and enzyme #9980 has some discussion about that. And #5837 is directly about the `--coverage` option.\r\n\r\n---\r\nAddendum: it would probably be helpful to have one meta-issue tracking the various memory leak issues and create one issue per scenario. As it currently stands, all the issues I mentioned above have some of the puzzle pieces, but nothing is tracked properly, the progress that was made isn't apparent to the end users and it's actually not easy to figure out where to add to the conversation on the general topic. And it probably further contributes to the creation of duplicate issues.","As for triaging memory leaks, there needs to be some minimum info:\r\n\r\n- NodeJS version.\r\n- Leak stats with and without `--runInBand`\r\n- Is coverage used? If so, does the leak persist without code coverage?\r\n\r\nI suggest closing old issues that do not provide the above mentioned info and directing the user to the to-be created meta-issue.\r\n\r\nAnd then it would be nice to find out if the scenario is one of the require and cache leaks. Figuring that out is probably a little involved unless those leaks get fixed.","Ah, thank you so much @StringEpsilon! Is there still a leak now (i.e. forever growing, never reset) in the reproduction on the OP using v27? If not, I think we should close this and encourage new issues with reproductions as you say.\r\n\r\nNote that 2 changes in v27 very much impacts this - we swapped default test environment from jsdom to node, and default test runner from jasmine to circus. So direct comparison between versions might not be perfectly valid.","I can't really say, based on the reproduction. I do see an increase test over test on the heap, but it's completely linear and not the saw-tooth pattern I see on production repositories, so I think node just doesn't run GC. \r\n\r\nBut I did find that running a single test file with *a lot* of tests seems to still leak:\r\n\r\n```js\r\nfor (let i = 0; i < 100000; i++) {\r\n  test(`tautology #${i}`, () => {\r\n    expect(true).toBeTruthy()\r\n  })\r\n}\r\n```\r\n\r\nI had a heap size of 313 mb with that (w\/ `--runInBand`).\r\n\r\nRunning the test with 1 million iterations yields a heap size of 2.6 GB. Beware that testing that takes a while (276 seconds).\r\n\r\nEdit: Okay, this particular kind of leak seems to happen without --runInBand too.","If it's a single test file it always runs in band","I used the above scenario to create a case where the heap increase is more noticable:\r\n\r\n```\r\nnpx jest --logHeapUsage --runInBand\r\n PASS  __test__\/test_1.test.js (13.524 s, 221 MB heap size)\r\n PASS  __test__\/test_2.test.js (188 MB heap size)\r\n PASS  __test__\/test_9.test.js (235 MB heap size)\r\n PASS  __test__\/test_8.test.js (265 MB heap size)\r\n PASS  __test__\/test_7.test.js (306 MB heap size)\r\n PASS  __test__\/test_6.test.js (346 MB heap size)\r\n PASS  __test__\/test_10.test.js (13.586 s, 548 MB heap size)\r\n PASS  __test__\/test_4.test.js (578 MB heap size)\r\n PASS  __test__\/test_3.test.js (620 MB heap size)\r\n```\r\n\r\nand \r\n\r\n```\r\nnpx jest --logHeapUsage \r\n PASS  __test__\/test_7.test.js (54 MB heap size)\r\n PASS  __test__\/test_2.test.js (54 MB heap size)\r\n PASS  __test__\/test_4.test.js (55 MB heap size)\r\n PASS  __test__\/test_9.test.js (53 MB heap size)\r\n PASS  __test__\/test_3.test.js (53 MB heap size)\r\n PASS  __test__\/test_8.test.js (53 MB heap size)\r\n PASS  __test__\/test_6.test.js (54 MB heap size)\r\n PASS  __test__\/test_10.test.js (7.614 s, 196 MB heap size)\r\n PASS  __test__\/test_1.test.js (7.619 s, 197 MB heap size)\r\n```\r\n\r\n(`28.0.0-alpha.6`)\r\n\r\nEach test is just \r\n\r\n```js\r\nfor (let i = 0; i < 50000; i++) {\r\n\tdescribe(\"test\", () => {\r\n\t\tit(`tautology #${i}`, () => {\r\n\t\t\texpect(true).toBeTruthy()\r\n\t\t})\r\n\t})\r\n}\r\n```\r\n\r\nI also noticed that adding the extra `describe()` makes the heap grow faster: \r\n* `--runInBand`: 620 MB peak with and 500 MB peak without\r\n* parallel: 208 MB peak with and 162 MB peak without\r\n","On jest v28.0.0-alpha.6 and node v14.15.3, I observe the same behavior in [jest-memory-leak-demo](https:\/\/github.com\/jaredjj3\/jest-memory-leak-demo) regardless of `--runInBand`:\r\n\r\n- with `--runInBand`, min: 28 MB, max: 102 MB\r\n- ~without `--runInBand`, min: 28 MB, max: 150 MB~\r\n- edit: without `--runInBand`, min: 29 MB, max: 70 MB, this might be ok","It's great that some folks think the memory leak issue is somehow not a big deal anymore, but we're at jest 27 and we have to run our builds at Node 14 even though we will ship with Node 16 so that our test suite can finish without running out of memory.  Even at Node 14, as our test suite has grown, we struggle to get our test suite to run to completion.","@radcapitalist \r\n\r\nI am sorry, my intention was only to report the progress that was made and to figure out the overall situation with the ~30 tickets. I was not trying to suggest that the various leaks are not an issue anymore. In fact, if anything, my testing suggests that --runInBand still has a large confounding effect on whatever leaks may occur.\r\n\r\nAs for the node 16 issue, there is a workaround via patch-package, see this comment https:\/\/github.com\/facebook\/jest\/issues\/11956#issuecomment-1011310131 and following.","@StringEpsilon No need to apologize whatsoever!  @SimenB suggested closing this after your comment and that just worried me a little :-).  \r\nWe are working on splitting up our test files more to see if it helps us.\r\nAnd thanks very much for the patch-package tip, I will look into it!\r\n\r\nEric","@SimenB I have drafted a meta issue: https:\/\/gist.github.com\/StringEpsilon\/6c8e687b47e0096acea9345f8035455f ","> It's great that some folks think the memory leak issue is somehow not a big deal anymore, but we're at jest 27 and we have to run our builds at Node 14 even though we will ship with Node 16 so that our test suite can finish without running out of memory. Even at Node 14, as our test suite has grown, we struggle to get our test suite to run to completion.\r\n\r\nAnd that's exactly my point in potentially closing this - that has next to nothing to do with the reproduction provided in the OP. Your issue is #11956 (which seemingly is a bug in Node and further upstream V8).\r\n\r\nHowever, it seems the OP still shows a leak somewhere, so you can rest easy knowing this issue won't be closed. \ud83d\ude42 \r\n\r\n---\r\n\r\nIf it's an issue for you at work, any time you can spend on solving this (or at least getting more info about what's going on) would be a great help. It's not an issue for me at work, so this is not something I'm spending any time investigating - movement on this issue is likely up to the community. For example gathering traces showing what is kept in memory that could (should) be GC-ed. The new meta issue @StringEpsilon has spent time on is an example of great help - they're probably all a symptom of the same issue (or smaller set of issues), so getting the different cases listed out might help with investigation, and solving one or more might \"inadvertently\" solve other issues as well.","Actually, I think I _will_ close this. \ud83d\ude05 If I run the repo in the OP (using node 14 due to #11956) with `--detect-leaks` (which [forces GC to run](https:\/\/github.com\/facebook\/jest\/blob\/3f3aa80254f2b2f365825c6ac5b5f0a2217631a5\/packages\/jest-leak-detector\/src\/index.ts#L53-L58)), I get this:\r\n\r\n<img width=\"596\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/1404810\/156529121-043bebb2-ced6-43ea-9b71-e26ed77fd961.png\">\r\n\r\n(this is using Jest 27 - using 28 alpha I get 22-23 instead of 24-25, but still miniscule)\r\n\r\nI took heap snapshots in the middle of running (without `--detect-leaks`) and after tests completed running, and it's _all_ source code cache that's the diff between the snapshots.\r\n\r\n<img width=\"1910\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/1404810\/156530626-f469886b-d1a3-449b-b1bb-a48e71d6603d.png\">\r\n\r\n(`compiled code` is the... compiled code, `string` is the source strings within the compiled code, `array` is an internal array of the source code yet again, `system` - again source code and `concatenated string` is.... strings of source code)\r\n\r\nAnd forcing GC will collect them, indicating Node itself will also collect it when it feels like it.\r\n\r\n_Some_ increase of memory usage is expected as we collect test results etc. as we go (vaguely related: #8242), but that's just _increased_ memory usage, not leaking.\r\n\r\nNote that this is the same result https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-639874717 shows. But unless somebody has info that indicates otherwise (e.g. manual GC is more aggressive than the automatic one), I think the cached strings are red herrings since they _can_ be collected, and Node (or v8, who knows) is just choosing not to.\r\n\r\nAlso note that there is no API to clear this cache (either on `Script` instances or just the code cache in general) so for Jest to be able to do anything (except dropping all references to the `Script`s and the contexts they run in (which we do) so GC can pick them up) Node needs to add some APIs.\r\n\r\n---\r\n\r\nI'll go through the issues @StringEpsilon collected, but from what I can tell at a quick glance they all seem to be a duplicate of (to some degree) #6814. Additionally #11956 is a well known upstream issue.\r\n\r\nPlease feel free to open up a new issue (if it's not one of the two I linked right above) with a reproduction if you have one. And while this issue has a lot of decent discussion, examples and workarounds, I think it's better to close it since the issue talked about in the OP is no longer an issue.","One thing I came over when going through the list of issues was this comment: https:\/\/github.com\/facebook\/jest\/issues\/7311#issuecomment-578729020, i.e. manually running GC in Jest.\r\n\r\nSo I tried out with this quick and dirty diff locally:\r\n\r\n```diff\r\ndiff --git i\/packages\/jest-leak-detector\/src\/index.ts w\/packages\/jest-leak-detector\/src\/index.ts\r\nindex 0ec0280104..6500ad067f 100644\r\n--- i\/packages\/jest-leak-detector\/src\/index.ts\r\n+++ w\/packages\/jest-leak-detector\/src\/index.ts\r\n@@ -50,7 +50,7 @@ export default class LeakDetector {\r\n   }\r\n \r\n   async isLeaking(): Promise<boolean> {\r\n-    this._runGarbageCollector();\r\n+    runGarbageCollector();\r\n \r\n     \/\/ wait some ticks to allow GC to run properly, see https:\/\/github.com\/nodejs\/node\/issues\/34636#issuecomment-669366235\r\n     for (let i = 0; i < 10; i++) {\r\n@@ -59,18 +59,18 @@ export default class LeakDetector {\r\n \r\n     return this._isReferenceBeingHeld;\r\n   }\r\n+}\r\n \r\n-  private _runGarbageCollector() {\r\n-    \/\/ @ts-expect-error\r\n-    const isGarbageCollectorHidden = globalThis.gc == null;\r\n+export function runGarbageCollector(): void {\r\n+  \/\/ @ts-expect-error\r\n+  const isGarbageCollectorHidden = globalThis.gc == null;\r\n \r\n-    \/\/ GC is usually hidden, so we have to expose it before running.\r\n-    setFlagsFromString('--expose-gc');\r\n-    runInNewContext('gc')();\r\n+  \/\/ GC is usually hidden, so we have to expose it before running.\r\n+  setFlagsFromString('--expose-gc');\r\n+  runInNewContext('gc')();\r\n \r\n-    \/\/ The GC was not initially exposed, so let's hide it again.\r\n-    if (isGarbageCollectorHidden) {\r\n-      setFlagsFromString('--no-expose-gc');\r\n-    }\r\n+  \/\/ The GC was not initially exposed, so let's hide it again.\r\n+  if (isGarbageCollectorHidden) {\r\n+    setFlagsFromString('--no-expose-gc');\r\n   }\r\n }\r\ndiff --git i\/packages\/jest-runner\/src\/runTest.ts w\/packages\/jest-runner\/src\/runTest.ts\r\nindex dfa50645bf..5e45f06b1b 100644\r\n--- i\/packages\/jest-runner\/src\/runTest.ts\r\n+++ w\/packages\/jest-runner\/src\/runTest.ts\r\n@@ -22,7 +22,7 @@ import type {TestFileEvent, TestResult} from '@jest\/test-result';\r\n import {createScriptTransformer} from '@jest\/transform';\r\n import type {Config} from '@jest\/types';\r\n import * as docblock from 'jest-docblock';\r\n-import LeakDetector from 'jest-leak-detector';\r\n+import LeakDetector, {runGarbageCollector} from 'jest-leak-detector';\r\n import {formatExecError} from 'jest-message-util';\r\n import Resolver, {resolveTestEnvironment} from 'jest-resolve';\r\n import type RuntimeClass from 'jest-runtime';\r\n@@ -382,6 +382,11 @@ export default async function runTest(\r\n     \/\/ Resolve leak detector, outside the \"runTestInternal\" closure.\r\n     result.leaks = await leakDetector.isLeaking();\r\n   } else {\r\n+    if (process.env.DO_IT) {\r\n+      \/\/ Run GC even if leak detector is disabled\r\n+      runGarbageCollector();\r\n+    }\r\n+\r\n     result.leaks = false;\r\n   }\r\n```\r\n\r\nSo if running after every test file, this gives about a 10% perf degradation for `jest pretty-format` in this repo.\r\n\r\n```sh-session\r\n$ hyperfine 'node packages\/jest\/bin\/jest.js pretty-format' 'node packages\/jest\/bin\/jest.js pretty-format -i' 'DO_IT=yes node packages\/jest\/bin\/jest.js pretty-format' 'DO_IT=yes node packages\/jest\/bin\/jest.js pretty-format -i'\r\nBenchmark 1: node packages\/jest\/bin\/jest.js pretty-format\r\n  Time (mean \u00b1 \u03c3):      2.391 s \u00b1  0.088 s    [User: 2.418 s, System: 0.392 s]\r\n  Range (min \u2026 max):    2.273 s \u2026  2.574 s    10 runs\r\n\r\nBenchmark 2: node packages\/jest\/bin\/jest.js pretty-format -i\r\n  Time (mean \u00b1 \u03c3):      2.315 s \u00b1  0.060 s    [User: 2.381 s, System: 0.385 s]\r\n  Range (min \u2026 max):    2.229 s \u2026  2.416 s    10 runs\r\n\r\nBenchmark 3: DO_IT=yes node packages\/jest\/bin\/jest.js pretty-format\r\n  Time (mean \u00b1 \u03c3):      2.513 s \u00b1  0.101 s    [User: 2.966 s, System: 0.397 s]\r\n  Range (min \u2026 max):    2.413 s \u2026  2.746 s    10 runs\r\n\r\nBenchmark 4: DO_IT=yes node packages\/jest\/bin\/jest.js pretty-format -i\r\n  Time (mean \u00b1 \u03c3):      2.581 s \u00b1  0.179 s    [User: 2.981 s, System: 0.403 s]\r\n  Range (min \u2026 max):    2.423 s \u2026  3.032 s    10 runs\r\n\r\nSummary\r\n  'node packages\/jest\/bin\/jest.js pretty-format -i' ran\r\n    1.03 \u00b1 0.05 times faster than 'node packages\/jest\/bin\/jest.js pretty-format'\r\n    1.09 \u00b1 0.05 times faster than 'DO_IT=yes node packages\/jest\/bin\/jest.js pretty-format'\r\n    1.11 \u00b1 0.08 times faster than 'DO_IT=yes node packages\/jest\/bin\/jest.js pretty-format -i'\r\n```\r\n\r\nHowever, this also stabilizes memory usage in the same way `--detect-leaks` does.\r\n\r\nSo it might be worth playing with this (e.g. after every 5 test files instead of every single one?). Thoughts? One option is to support a CLI flag for this, but that sorta sucks as well.\r\n\r\n---\r\n\r\nI'll reopen (didn't take long!) since I'm closing most other issues and pointing back here \ud83d\ude42 But it might be better to disucss this in an entirely new issue. \ud83e\udd14 ","Hi,\r\n\r\nWe experiments the same issue about memory leaks with our Angular 13 app\r\nWe try the `--detect-leaks` as suggested above and it seems to work but only with node 14 (14.19.1)\r\n`npx jest-heap-graph \"ng test --run-in-band --log-heap-usage --detect-leaks\"`\r\n\r\nHere the heap graph for 14.19.1 :\r\n```\r\n--- n: 127 ---\r\n     287.00 \u2524                  \u256d\u256e                  \u256d\u256e\u256d\u256e           \u256d\u256e\r\n     285.00 \u2524      \u256d\u256e \u256d\u256e \u256d\u256e    \u2502\u2502\u256d\u256e \u256d\u256e  \u256d\u256e      \u256d\u256e \u2502\u2502\u2502\u2502      \u256d\u256e  \u256d\u256f\u2502      \u256d\u256e  \u256d\u256e      \u256d\u256e\r\n     283.00 \u2524      \u2502\u2502 \u2502\u2570\u256e\u2502\u2502    \u2502\u2502\u2502\u2502 \u2502\u2570\u256e\u256d\u256f\u2502  \u256d\u256e \u256d\u256f\u2502 \u2502\u2502\u2502\u2502  \u256d\u256e  \u2502\u2502\u256d\u256e\u2502 \u2570\u256e\u256d\u256e   \u2502\u2502 \u256d\u256f\u2502 \u256d\u256e \u256d\u256e\u2502\u2502        \u256d\u256e\r\n     281.00 \u253c\u256e \u256d\u2500\u256e \u2502\u2502 \u2502 \u2502\u2502\u2502  \u256d\u256e\u2502\u2502\u2502\u2502 \u2502 \u2502\u2502 \u2502  \u2502\u2502 \u2502 \u2502 \u2502\u2570\u256f\u2570\u256e\u256d\u256f\u2502  \u2502\u2502\u2502\u2502\u2502  \u2502\u2502\u2502  \u256d\u256f\u2502\u256d\u256f \u2502 \u2502\u2502 \u2502\u2502\u2502\u2502   \u256d\u256e   \u2502\u2502\r\n     279.00 \u2524\u2502 \u2502 \u2502 \u2502\u2502 \u2502 \u2502\u2502\u2502  \u2502\u2570\u256f\u2502\u2502\u2502\u256d\u256f \u2570\u256f \u2570\u256e \u2502\u2570\u256e\u2502 \u2502 \u2502   \u2570\u256f \u2570\u256e \u2502\u2570\u256f\u2570\u256f  \u2502\u2502\u2570\u256e \u2502 \u2502\u2502  \u2570\u256e\u2502\u2502 \u2502\u2502\u2502\u2502 \u256d\u256e\u2502\u2502\u256d\u256e \u2502\u2502\r\n     277.00 \u2524\u2502 \u2502 \u2502 \u2502\u2502 \u2502 \u2502\u2502\u2502\u256d\u256e\u2502  \u2502\u2502\u2502\u2502      \u2502 \u2502 \u2502\u2502 \u2502\u256d\u256f       \u2502 \u2502      \u2570\u256f \u2570\u2500\u256f \u2570\u256f   \u2570\u256f\u2502\u256d\u256f\u2502\u2502\u2570\u2500\u256f\u2502\u2502\u2570\u256f\u2570\u2500\u256f\u2570\u2500\u2500\u2500\u2500\r\n     275.00 \u2524\u2502 \u2502 \u2502\u256d\u256f\u2570\u256e\u2502 \u2502\u2502\u2502\u2502\u2502\u2502  \u2502\u2502\u2502\u2502      \u2570\u256e\u2502 \u2502\u2502 \u2570\u256f        \u2502 \u2502                    \u2570\u256f \u2570\u256f   \u2570\u256f\r\n     273.00 \u2524\u2502\u256d\u256f \u2502\u2502  \u2502\u2502 \u2570\u256f\u2502\u2502\u2502\u2502  \u2502\u2502\u2570\u256f       \u2570\u256f \u2502\u2502           \u2502 \u2502\r\n     271.00 \u2524\u2502\u2502  \u2502\u2502  \u2502\u2502   \u2502\u2502\u2502\u2502  \u2502\u2502            \u2502\u2502           \u2502\u256d\u256f\r\n     269.00 \u2524\u2502\u2502  \u2570\u256f  \u2570\u256f   \u2502\u2502\u2570\u256f  \u2570\u256f            \u2570\u256f           \u2502\u2502\r\n     267.00 \u2524\u2570\u256f           \u2570\u256f                               \u2570\u256f\r\n```\r\n\r\nHere the heap graph for 16.14.2 :\r\n```\r\n--- n: 126 ---\r\n    2212.00 \u2524                                                                                   \u256d\u2500\u2500\u2500\u2500\u2500\r\n    2074.50 \u2524                                                                          \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1937.00 \u2524                                                                \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1799.50 \u2524                                                        \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1662.00 \u2524                                               \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1524.50 \u2524                                      \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1387.00 \u2524                             \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1249.50 \u2524                    \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n    1112.00 \u2524            \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n     974.50 \u2524   \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\r\n     837.00 \u253c\u2500\u2500\u2500\u256f\r\n```\r\n\r\n```\r\nnpx envinfo --preset jest\r\n\r\n  System:\r\n    OS: Windows 10 10.0.19044\r\n    CPU: (12) x64 11th Gen Intel(R) Core(TM) i5-11500H @ 2.90GHz\r\n  Binaries:\r\n    Node: 16.14.2 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.22.18 - ~\\workspace\\WEBTI\\fe-webti\\node_modules\\.bin\\yarn.CMD\r\n    npm: 8.5.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n  npmPackages:\r\n    jest: ^27.3.1 => 27.5.1 \r\n```\r\n\r\nWe also tried the coverageProvider set to babel as here https:\/\/github.com\/facebook\/jest\/issues\/11956#issuecomment-1112561068 no change\r\nWe guess our tests may are not perfectly well written but there still leaks\r\n\r\n## EDIT\r\nDowngrade to node 16.10.0 seems to work\r\n```\r\n--- n: 127 ---\r\n     413.00 \u2524            \u256d\u256e\r\n     409.70 \u2524            \u2502\u2502\r\n     406.40 \u2524            \u2502\u2502\r\n     403.10 \u2524            \u2502\u2502                                                                          \u256d\r\n     399.80 \u2524            \u2502\u2502\u256d\u256e            \u256d\u256e               \u256d\u256e         \u256d\u256e \u256d\u256e                           \u2502\r\n     396.50 \u2524            \u2502\u2502\u2502\u2502    \u256d\u256e      \u2502\u2502       \u256d\u2500\u2500\u256e \u256d\u256e\u256d\u256f\u2570\u2500\u256e \u256d\u2500\u2500\u256e \u256d\u256f\u2502 \u2502\u2502 \u256d\u256e\u256d\u256e         \u256d\u256e        \u256d\u256e\u256d\u256f\r\n     393.20 \u2524\u256d\u256e\u256d\u256e        \u2502\u2502\u2502\u2502    \u2502\u2502\u256d\u2500\u256e \u256d\u256e\u2502\u2502\u256d\u256e \u256d\u256e\u256d\u256e\u2502  \u2502\u256d\u256f\u2502\u2502   \u2502 \u2502  \u2570\u2500\u256f \u2570\u2500\u256f\u2570\u256e\u2502\u2502\u2502\u2570\u2500\u2500\u2500\u256e\u256d\u2500\u2500\u256e\u256d\u256f\u2570\u2500\u256e\u256d\u2500\u256e\u256d\u2500\u2500\u256f\u2570\u256f\r\n     389.90 \u2524\u2502\u2502\u2502\u2502\u256d\u256e     \u256d\u256f\u2502\u2502\u2570\u256e \u256d\u2500\u256f\u2502\u2502 \u2570\u2500\u256f\u2570\u256f\u2502\u2502\u2502 \u2502\u2502\u2502\u2570\u256f  \u2502\u2502 \u2570\u256f   \u2502 \u2502          \u2570\u256f\u2570\u256f    \u2570\u256f  \u2570\u256f   \u2570\u256f \u2570\u256f\r\n     386.60 \u2524\u2502\u2570\u256f\u2570\u256f\u2502  \u256d\u256e\u256d\u256f \u2570\u256f \u2502\u256d\u256f  \u2570\u256f      \u2570\u256f\u2570\u256e\u2502\u2502\u2502    \u2570\u256f      \u2570\u2500\u256f\r\n     383.30 \u253c\u256f    \u2570\u256e \u2502\u2502\u2502     \u2570\u256f              \u2570\u256f\u2570\u256f\r\n     380.00 \u2524      \u2570\u2500\u256f\u2570\u256f\r\n```","I use Jest for integration testing, it can be complicated to find the source of the memory leak (maybe related to a graceful teardown problem in my test suite, not a Jest issue).\r\n\r\nI use this workaround to avoid OOM using matrix on Github actions.\r\n\r\n```yml\r\nname: Backend\r\n\r\non:\r\n  pull_request:\r\n    branches:\r\n      - master\r\n    types: [opened, synchronize, reopened, unlabeled]\r\n\r\njobs:\r\n  buildAndLint:\r\n    timeout-minutes: 10\r\n    runs-on: ubuntu-latest\r\n\r\n    strategy:\r\n      matrix:\r\n        node-version: [16.x]\r\n\r\n    steps:\r\n      - uses: actions\/checkout@v2\r\n      - run: yarn build && yarn lint\r\n  Test:\r\n    needs: [buildAndLint]\r\n    timeout-minutes: 30\r\n    runs-on: ubuntu-latest\r\n\r\n    strategy:\r\n      matrix:\r\n        node-version: [16.x]\r\n        # Each app folder test will be run in parallel using the matrix\r\n        folder: [adapters, auth, cloud, customSchema, miscTest, schemas, utils]\r\n\r\n    steps:\r\n      - uses: actions\/checkout@v2\r\n      # Improve this to use github artifact\r\n      - run: yarn build:fast\r\n      # Jest will only run test from the folder\r\n      - run: yarn test ${{ matrix.folder }}\r\n        env:\r\n          NODE_ENV: TEST\r\n```\r\n\r\nThis script could be improved to upload each LCOV result in a final job and then merge all coverage results into one using `nyc merge` see: https:\/\/stackoverflow.com\/questions\/62560224\/jest-how-to-merge-coverage-reports-from-different-jest-test-runs","As @UnleashSpirit mentioned, downgrading to node 16.10 fixed the memory issue with Jest.","@j0k3r it works:)","Wow - this one got us too ... after scouring the internet and finding this ... reverting to `16.10` fixed our build too (in gitlab, docker image extending `node:16` changed to `node:16.10`). Here's hoping there's a longer-term solution, but many thanks for the suggestion!","This looks like it'll drag on forever as it doesn't appear to be getting picked up on the node\/v8 side. Is there anything that can be done in order to escalate this?","And we're already starting to run into problems with libs requiring a specific min LTS version of node now (as per my linked issue above). This is getting painful to work around without dodgy `--ignore-engines` for CI.\r\n\r\nV8 issue seems to be closed as `WontFix` so got no idea what the longer term solution is: https:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=12198\r\n\r\nLink to node issue https:\/\/github.com\/nodejs\/node\/issues\/40014","It seems there is a suggested fix\/workaround for `Jest` as per this comment: https:\/\/bugs.chromium.org\/p\/v8\/issues\/detail?id=12198#c20\r\n\r\nHopefully this makes more sense to someone in the Jest team ... is this something that could be persued? It seems the first suggestion is for `node` itself but for `jest` they are asking if it's possible to remove _forced GCs_. I gotta admit I don't know the detail.\r\n\r\n> Did Victor's suggested workaround work for Node? Updating from above, it would be to change https:\/\/source.chromium.org\/chromium\/chromium\/src\/+\/main:v8\/src\/heap\/heap.h;l=1460;drc=de8943e4326892f4e584a938b31dab0f14c39980;bpv=1;bpt=1 to remove the `is_current_gc_forced_` check.\r\n> \r\n> In general it's my understanding that `--exposed-gc` is primarily a testing feature and shouldn't be depended upon in production. Is it not possible to remove forced GCs from how jest runs?","Same issue here. \r\nFor me, it seems that the problem is in the setupFilesAfterEnv script.\r\n\r\nIt's better with node 16.10, but it still arrives at 841 MB heap size (580 tests)","Same issue here too. Downgrading to node 16.10 fixed the memory issue with Jest.","Same issue for me. Downgrading to node 16.10 fixed the memory leak with Jest. I was seeing 3.4GB heap sizes with node 16.14, down to ~400MB with node 16.10.","Looking for some forward momentum here as well; CI pipeline is locked at 16.10 and explicitly calls `node --expose-gc .\/node_modules\/.bin\/jest` to reduce heap sizes from ~3699MB to 610MB on two repositories.\r\n\r\nIt hasn't resolved the issue for all repositories, so I suspect this issue more complex.\r\n\r\nPrevious chromium issue [linked](https:\/\/github.com\/facebook\/jest\/issues\/7874#issuecomment-1168091064) by @mbyrne00 is labeled as `wont-fix`, which is concerning to me with Node 18 becoming LTS in October.\r\n\r\nIs there any solution in mind?","The chromium issue points back to node and jest and how they are implementing certain features. As one user on the Chromium issue thread pointed out, this is the closest thing to an attempt to resolve the issue so hopefully it gets legs: https:\/\/github.com\/facebook\/jest\/pull\/12205\/files#diff-c0d5b59e96fdc7ffc98405e8afb46d525505bc7b1c24916b5c8482de5a186c00R1359-R1373\r\n\r\nEven more interesting is this specific comment where someone has published a jest runtime lib to fix the problem until the PR is merged https:\/\/github.com\/facebook\/jest\/pull\/12205#issuecomment-1150255655","Just FYI, the interesting news on the node \/ v8 upstream bug can be found at #11956 (\"Memory consumption issues on Node JS 16.11.0+\") - where some mitigations for the upcoming jest 29 and a workaround (albeit a very slow one) for jest 27 were discussed just 4 days ago. \r\n\r\nAs far as I understood @SimenB's intention with reopening this issue, it is *NOT* to discuss known causes of memory leaks, but to track the overall state of jest leakages outside of identified and known issues and causes. \r\n\r\nThat is to say, if your leak goes away when downgrading to node 16.10, this is not the issue for you. Go to #11956 instead. :)","I've run some tests considering various configurations. Hope it helps someone.\r\n\r\nnode version | node args | jest args | custom behavior | time (seconds) | heap (mb)\r\n-- | -- | -- | -- | -- | --\r\n16.10 | --expose-gc --no-compilation-cache | --maxWorkers 1 | afterAll(global.gc) + force options.serial to false on jest-runner | 303 | 45\r\n16.18 | --expose-gc --no-compilation-cache | --maxWorkers 1 | afterAll(global.gc) + force options.serial to false on jest-runner | 325 | 47\r\n16.10 | --expose-gc --no-compilation-cache | --maxWorkers 2 | - | 236 | 64\r\n16.18 | --expose-gc --no-compilation-cache | --maxWorkers 2 | - | 167 | 67\r\n16.10 | --expose-gc | --maxWorkers 1 | afterAll(global.gc) + force options.serial to false on jest-runner | 234 | 82\r\n16.10 | --expose-gc | --maxWorkers 2 | - | 155 | 96\r\n16.10 | --expose-gc --no-compilation-cache | --runInBand --detectLeaks | afterAll(global.gc) | 313 | 159\r\n16.10 | --expose-gc --no-compilation-cache | --runInBand --detectLeaks | - | 307 | 160\r\n16.10 | --expose-gc --no-compilation-cache | --runInBand | - | 313 | 160\r\n16.10 | --expose-gc --no-compilation-cache | --maxWorkers 1 | - | 333 | 160\r\n16.10 | --expose-gc --no-compilation-cache | --runInBand --detectLeaks | afterEach(global.gc) | 397 | 160\r\n16.18 | --expose-gc --no-compilation-cache | --runInBand --detectLeaks | afterAll(global.gc) | 281 | 164\r\n16.18 | --expose-gc --no-compilation-cache | --runInBand --detectLeaks | afterEach(global.gc) | 298 | 164\r\n16.18 | --expose-gc --no-compilation-cache | --maxWorkers 1 | - | 287 | 165\r\n16.18 | --expose-gc --no-compilation-cache | --runInBand --detectLeaks | - | 300 | 165\r\n16.18 | --expose-gc --no-compilation-cache | --runInBand | - | 337 | 165\r\n16.10 | --expose-gc | --runInBand --detectLeaks | - | 258 | 199\r\n16.10 | --expose-gc | --runInBand | - | 247 | 201\r\n16.10 | --expose-gc | --maxWorkers 2 | - | 286 | 201\r\n16.10 | --expose-gc | --runInBand --detectLeaks | afterAll(global.gc) | 256 | 202\r\n16.10 | --expose-gc | --runInBand --detectLeaks | afterEach(global.gc) | 309 | 206\r\n16.10 | \u00a0 | --runInBand | - | 261 | 629\r\n16.18 | --expose-gc | --maxWorkers 2 | - | 277 | 899\r\n16.18 | --no-compilation-cache | --runInBand | - | 297 | 907\r\n16.18 | \u00a0 | --runInBand | - | 281 | 1055\r\n16.18 | --expose-gc | --runInBand | - | 347 | 1262\r\n16.18 | --expose-gc | --maxWorkers 1 | afterAll(global.gc) + force options.serial to false on jest-runner | 337 | 1380\r\n\r\n```\r\nTest Suites: 3 skipped, 31 passed, 31 of 34 total\r\nTests:       20 skipped, 49 todo, 171 passed, 240 total\r\nSnapshots:   0 total\r\n\r\n* Running with Jest 29.2.2 on a bitbucket pipeline container using node official docker images\r\n```","From a preliminary run or two, it looks to me like going back to 16.10 is resolving these errors for us as well.\r\nIs there any more clarity on _why_ this is, or what a real fix might look like?","> Is there any more clarity on _why_ this is, or what a real fix might look like?\r\n\r\nAll the info on the regression that specifically affects node >= 16.11 is found in this issue: https:\/\/github.com\/facebook\/jest\/issues\/11956","Just spend about 2 days figuring out how to overcome this, until I discovered #11956.\r\n\r\nTLDR; regression introduced in node 16.11, fixed in 21.1. \r\nBackporting Bugfix for node 18 seems to be on the way, see \r\nhttps:\/\/github.com\/jestjs\/jest\/issues\/11956#issuecomment-1824288913","> Just spend about 2 days figuring out how to overcome this, until I discovered #11956.\r\n> \r\n> TLDR; regression introduced in node 16.11, fixed in 21.1. Backporting Bugfix for node 18 seems to be on the way, see [#11956 (comment)](https:\/\/github.com\/jestjs\/jest\/issues\/11956#issuecomment-1824288913)\r\n\r\nIn case anyone stumbles across this and wants a simple solution, node 20.10.0 contains a fix for this.\r\nUpgrading to node 20.10.0 solved this for me \ud83c\udf89 ","Reading the linked issue, it says '21.1', but might as well being already backported to '20.x', leaving '18.x' to be waiting for a fix\ud83e\udd37.\n\nFor our team, switching our ci-builds to '21.x' did the deal, even if this might introduce runtime-confusion \ud83d\ude09. \n\n"],"labels":[":bug: Bug"]},{"title":"Introduce a more flexible and better typed way to mock APIs","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nThis introduces an easy-to-use, lightweight and concise way to (partially) mock typed APIs (Typescript modules, types, classes and above all interfaces) without introducing any breaking change to the API.\r\n\r\n## Motivation\r\n\r\nMocking interfaces on a per-test basis is not possible right now in jest. IMO it is good testing practices to NOT re-use mocks across tests as this quickly makes the mock become a hard-to-maintain object in its own right. Plus shared mocks introduce unwanted dependencies between tests.\r\n\r\nIt is rather established practice to generate light-weight throw-away mocks for each test case that only mock a minimal set of API methods to document what is actually being used by the SUT (and throwing errors if something unexpected is being used). This is currently not well supported by jest - neither for modules nor for hashes\/classes and not at all for interfaces.\r\n\r\nThe mocking of interfaces is central to good programming practices, though, as APIs should always be implementations of interfaces and tests should mock the interface rather than a specific implementation as this will much better decouple the test from the underlying API and avoid false negatives when the implementation details change.\r\n\r\n## Example\r\n\r\n```ts\r\n\/\/ The interface to be mocked - no implementation must be known\/available!\r\n\/\/ It is even possible to do TDD with deferred implementation of the API, e.g.\r\n\/\/ when the API is to be developed at a later time\/in parallel by another team\r\n\/\/ or team mate.\r\ninterface MyApi {\r\n   someMethod(x: number): string;\r\n   someOtherMethod(): void;\r\n   someThirdMethod(): void;\r\n}\r\n\r\ntest('...', () => {\r\n  \/\/ Declare the mock - the correct Mocked type will be automatically\r\n  \/\/ inferred when initialising the variable right away (const ... = mock<...>(...))\r\n  \/\/ which makes the implementation even more concise.\r\n  let myMockedApi: Mocked<MyApi>\r\n\r\n  \/\/ Partially mocking the class or interface. The mock function takes the methods to be\r\n  \/\/ mocked as arguments. The arguments are strongly typed - so TS will throw a compile-\r\n  \/\/ time error if you try to mock non-existent methods.\r\n  \/\/ The test documents which methods are expected to be used by the SUT for the given\r\n  \/\/ test case. \r\n  myMockedApi = mock<MyApi>('someMethod', 'someOtherMethod')\r\n\r\n  \/\/ TS-enabled IDEs will now provide completion for both, the mock functions as well\r\n  \/\/ as the original function itself!\r\n  myMockedApi.someMethod(...) \/\/ IDE will propose\/check the \"x\" argument\r\n  myMockedApi.someMethod.mockReturnValue('12345') \/\/ IDE will propose\/check all mock methods\r\n\r\n  \/\/ Matchers work normally:\r\n  expect(myMockedApi.someMethod).toHaveBeenCalledWith(...)\r\n\r\n  \/\/ If the SUT invokes a non-mocked (unexpected) method on the API an error will be thrown:\r\n  myMockedApi.thirdMethod() \/\/ will throw\r\n})\r\n```\r\n\r\n## Pitch\r\n\r\nJest wants to provide a best-in-class typed mocking solution based on current best testing practice and comparable in capability to established typed mocking solutions for other languages. Jest has chosen TypeScript as one of its major language targets and therefore wants to provide best-in-class TypeScript\/IDE support for its API. Currently a fundamental mocking feature is missing, though, which often means that users that want full typing of their mocks are forced to use 3rd party mocking solutions or create\/maintain their own and cannot use jest's built-in mocking.\r\n\r\n## Working sample implementation of the above mocking API\r\n\r\nObs: This sample implementation currently requires @types\/jest 24.x plus the changes proposed in https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/pull\/32956 (PR) and https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/issues\/32901 (Issue). It is however easily adaptable to work with mainline @types\/jest or any (future) jest core typings. We chose to base our proposal on patched typings to show how we think this should be done properly (based on our current personal opinions and preferred choices).\r\n\r\n```ts\r\ntype GenericFunction = (...args: any[]) => any\r\n\r\nexport type MockFunction<F extends GenericFunction> = F & jest.Mock<ReturnType<F>, ArgsType<F>>\r\n\r\nexport type Mockable<T> = {\r\n  [K in keyof T]: GenericFunction\r\n}\r\n\r\nexport type Mocked<T extends Mockable<T>> = {\r\n  [K in keyof T]: MockFunction<T[K]>\r\n}\r\n\r\ntype PropOf<T> = T[keyof T]\r\n\r\nexport function mock<T extends Mockable<T>>(...mockedMethods: (keyof T)[]): Mocked<T> {\r\n  const mocked: Mocked<T> = {} as Mocked<T>\r\n  mockedMethods.forEach(mockedMethod => mocked[mockedMethod] = jest.fn<PropOf<T>>() as MockFunction<PropOf<T>>)\r\n  return mocked\r\n}\r\n```\r\n\r\n\r\n\r\n","comments":["Thanks for the detailed proposal!\r\n\r\nThis is related to #4257 - whatever API we come up with should work with both Flow and TS. I don't know enough (about either type system) to really contribute a lot to this conversation, but on the surface something like what you propose sounds awesome.\r\n\r\n\/cc @orta @aaronabramov @cpojer ","@SimenB: I agree! :-) Contrary to #4257 the intention of this feature proposal is not to propose a specific jest mocking API but some practical ideas how to implement strongly typed interface mocking in TypeScript. Very much looking forward to the API you'll come up with in the future.\r\n\r\nOnce you have decided upon a target API I will most probably be able to adapt this feature request accordingly while maintaining its basic capability. Just let me know.\r\n\r\nThanks for your great testing framework btw. It's a joy to work with. :-)","Here is a more advanced version that allows to mock types with non-function props:\r\n\r\n```ts\r\ntype GenericFunction = (...args: any[]) => any\r\n\r\ntype PickByTypeKeyFilter<T, C> = {\r\n  [K in keyof T]: T[K] extends C ? K : never\r\n}\r\n\r\ntype KeysByType<T, C> = PickByTypeKeyFilter<T, C>[keyof T]\r\n\r\ntype ValuesByType<T, C> = {\r\n  [K in keyof T]: T[K] extends C ? T[K] : never\r\n}\r\n\r\ntype PickByType<T, C> = Pick<ValuesByType<T, C>, KeysByType<T, C>>\r\n\r\ntype MethodsOf<T> = KeysByType<Required<T>, GenericFunction>\r\n\r\ntype InterfaceOf<T> = PickByType<T, GenericFunction>\r\n\r\ntype PartiallyMockedInterfaceOf<T> = {\r\n  [K in MethodsOf<T>]?: jest.Mock<InterfaceOf<T>[K]>\r\n}\r\n\r\nexport function mock<T>(...mockedMethods: MethodsOf<T>[]): jest.Mocked<T> {\r\n  const partiallyMocked: PartiallyMockedInterfaceOf<T> = {}\r\n  mockedMethods.forEach(mockedMethod =>\r\n    partiallyMocked[mockedMethod] = jest.fn())\r\n  return partiallyMocked as jest.Mocked<T>\r\n}\r\n```","Is there any indication to when an improvement can be expected? I'm really struggling trying to get my typings correct with a strict tslint setup. I've asked help on discord and create an issue on [stackoverflow](https:\/\/stackoverflow.com\/questions\/54941990\/how-to-strongly-type-jest-mocks) but I'm hitting a wall. \r\n\r\nLooking at this issue this improvement is exactly what I'm looking for!","@jerico-dev This is excellent work.  I was just looking for how to do this myself.  Thanks for sharing this with the community.  It would be great to see this pulled into mainline of Jest typing.","Thanks. It works. This is what I am looking for.\r\n\r\nMy issue is: I don't want to mock all method for a class, because those methods are not ready to be tested. But I need let the type validation of typescript pass firstly without modifying the interfaces for implementation.\r\n\r\nFor example, if I don't use the partial mock function, tsc will throw a type error for `adSubscriptionDataSource` like this:\r\n\r\n> is missing the following properties from type 'IAdSubscriptionDataSource': updateById, findByActive, relation, find, and 6 more\r\n\r\nsome methods of `adSubscriptionDataSource` are not ready to be tested, so I don't want to mock them at this time. I just need the type validation of typescript pass. Use `mock` helper function can do this and take care of the partial mocked type issue.\r\n\r\n![\u56fe\u7247](https:\/\/user-images.githubusercontent.com\/17866683\/64177481-2bfc1a80-ce92-11e9-98af-69067ff72618.png)\r\n\r\nThis typed way should be documented.\r\n\r\n","Hey guys,\r\n\r\nAfter reading all of this and a few other articles online, since jest upgrade I'm no longer able to mock a class partially targetting specific method.\r\n\r\nDo you guys have a proper way to mock a class? Create an instance right after and injecting it?\r\n\r\nThank you :)","I ended up writing a library to do this - https:\/\/github.com\/marchaos\/jest-mock-extended, which follows @jerico-dev's initial proposal pretty closely, but adds some extra stuff like calledWith which was another use case that we are using. ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","This issue is not stale, at least not for me.\r\n\r\nIf it wasn't for @marchaos library (thanks a lot!), I'd consider dropping jest in favor of other testing\/mocking frameworks like mocha. This is an essential feature, and a much better approach to writing tests in general IMHO.","`jest-mock` has seen extensive improvements to its types in Jest v28 via #12435, #12442 and #12489\r\n\r\n\r\n```ts\r\nimport {jest} from '@jest\/globals';\r\n\r\ninterface MyApi {\r\n  someMethod(x: number): string;\r\n  someOtherMethod(): void;\r\n  someThirdMethod(): void;\r\n}\r\n\r\nconst mockedApi = jest.mocked({} as MyApi);\r\n```\r\n\r\n<img width=\"783\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/1404810\/155883581-44e21358-4c09-467f-aab2-5c48fd999a5c.png\">\r\n\r\n<img width=\"674\" alt=\"image\" src=\"https:\/\/user-images.githubusercontent.com\/1404810\/155883588-f27db2b9-5fba-4563-a3de-6a1e80e1decf.png\">\r\n\r\nSo I think this issue as stated in the OP is solved? Note that this will require you to have a mock object. Main difference is we need to get passed an object with mocks. We could probably add a `Proxy` implementation like `jest-mock-extended` at least the type part of this feature request seems resolved? I'd be happy to take a PR adding e.g. `jest.generateMock` or something which works like `mock` from `jest-mock-extended`. I think something like\r\n\r\n```ts\r\nimport * as someModule from 'some-module';\r\nimport {jest} from '@jest\/globals';\r\n\r\njest.mock('some-module');\r\n\r\n\r\nconst mockedModule = jest.mocked(someModule);\r\n```\r\n\r\nIs better than some proxy as your setting up mocks that will be used by others. Could you show real use cases where the proxy approach is better\/cleaner?\r\n\r\n---\r\n\r\nThe other feature `jest-mock-extended` provides beyond better types (as far as I can see, apologies if I missed others) is parameterized mocks, which we track in #6180","> ```ts\r\n> import * as someModule from 'some-module';\r\n> import {jest} from '@jest\/globals';\r\n> \r\n> jest.mock('some-module');\r\n> \r\n> const mockedModule = jest.mocked(someModule);\r\n> ```\r\n> \r\n> Is better than some proxy as your setting up mocks that will be used by others. Could you show real use cases where the proxy approach is better\/cleaner?\r\n\r\n@SimenB I'm not too familiar with the differences between `jest-mock-extended`'s proxy approach and Jest's `MaybeMock`, so I might be confusing some topics here.\r\n\r\nMy main gripe with Jest's mocking is the reliance on global\/static mocking (of modules). I highly prefer building my code with classes that their dependencies are injected via their constructor; in testing, that means injecting local mock instances instead of mocking modules globally in place.\r\n\r\nI completely understand the reasoning behind Jest's approach given that many JS codebases are still mainly procedural and don't use the dependency-injection approach of OOP. I hope Jest could also provide the alternative for OOP ehnthusiastics :)\r\n","You can also do [`jest.createMockFromModule('some-module')`](https:\/\/jestjs.io\/docs\/jest-object#jestcreatemockfrommodulemodulename) (this is what `jest.mock` does under the hood if you don't provide a mock factory). But if you don't want to mock at the module boundary at all, then I guess it's not as useful.\r\n\r\nOne limitation of the approach from the OP (and I guess `jest-mock-extended`) is that it only works for functions, not other types. Which might be fine, depending on what you're doing.\r\n\r\n---\r\n\r\nThat said, I do think something like\r\n\r\n```ts\r\nimport {jest} from '@jest\/globals';\r\n\r\ninterface MyApi {\r\n  someMethod(x: number): string;\r\n  someOtherMethod(): void;\r\n  someThirdMethod(): void;\r\n}\r\n\r\nconst myApi: MyApi = {\r\n  someMethod: jest.fn<(x: number) => string>(),\r\n  someOtherMethod: jest.fn(),\r\n  someThirdMethod: jest.fn(),\r\n};\r\n\r\nconst mockedApi = jest.mocked(myApi);\r\n```\r\n\r\nis fine. The `Proxy` approach doesn't seem like it adds too much? IMO closer to the \"local mock instances\" you say you prefer.\r\n\r\nSlightly less typing\r\n\r\n```ts\r\nimport {jest} from '@jest\/globals';\r\n\r\ninterface MyApi {\r\n  someMethod(x: number): string;\r\n  someOtherMethod(): void;\r\n  someThirdMethod(): void;\r\n}\r\n\r\nconst mockedApi = jest.mocked({\r\n  someMethod: jest.fn(),\r\n  someOtherMethod: jest.fn(),\r\n  someThirdMethod: jest.fn(),\r\n} as MyApi);\r\n```\r\n\r\nIf you have a \"real\" implementation you want to create a mock from, we could probably expose what `createMockFromModule` does to the loaded module (https:\/\/github.com\/facebook\/jest\/blob\/c2872aae7e3bdc8f9c236637ade294790a47d7f6\/packages\/jest-runtime\/src\/index.ts#L1759-L1771), essentially just `moduleMocker.generateFromMetadata(moduleMocker.getMetadata(object))`. `jest.createMockFromObject`?","> One limitation of the approach from the OP (and I guess `jest-mock-extended`) is that it only works for functions, not other types. Which might be fine, depending on what you're doing.\r\n\r\nOther types such as? you mean plain properties?\r\n\r\n> ```ts\r\n> const mockedApi = jest.mocked({\r\n>  someMethod: jest.fn(),\r\n >  someOtherMethod: jest.fn(),\r\n >  someThirdMethod: jest.fn(),\r\n>} as MyApi);\r\n> ```\r\n\r\nI would love to not need to explicitly set each function as mock, i.e:\r\n```ts\r\nconst mockedApi = jest.mocked<MyApi>();\r\n```\r\nor something along these lines.\r\n\r\nThis is similar to the approach taken by [Sinon's createStubInstance](https:\/\/sinonjs.org\/releases\/latest\/utils\/) and Java's mocking libraries such as [Mockito](https:\/\/javadoc.io\/doc\/org.mockito\/mockito-core\/latest\/org\/mockito\/Mockito.html#mock-java.lang.Class-).","If you by \"plain properties\" mean primitives, then yes. And classes or arrays. We also detect generator functions or async functions and return the correct type of function.\r\n\r\nBoth sinon and mockito seems to require passing an argument, which is what I'm suggesting? While I've used both in the past, it's been more than 6 years since either, so I've forgotten what I once knew about them \ud83d\ude48 ","Just a quick note. At the moment I am reworking `jest.Mocked<T>` utility type. It will do the same thing as `jest.mocked<T>(arg: T)` function currently does. Simply instead of a value, the utility type will take generic type argument. I think it will work like this:\r\n\r\n```ts\r\nimport myApi from '.\/myApi';\r\n\r\njest.mock('.\/myApi');\r\n\r\nconst mockedApi = myApi as jest.Mocked<typeof myApi>;\r\n```","@SimenB \r\n\r\n> If you by \"plain properties\" mean primitives, then yes. And classes or arrays. We also detect generator functions or async functions and return the correct type of function.\r\n\r\nI think it's sufficient to only mock functions (including getters\/setters).\r\n \r\n> Both sinon and mockito seems to require passing an argument, which is what I'm suggesting? While I've used both in the past, it's been more than 6 years since either, so I've forgotten what I once knew about them \ud83d\ude48\r\n\r\nWhen stubbing a specific function? yes, but not when initializing the mock\/stub.","This was already possible in jasmine for ages with `createSpyObj<MyApi>`. It's weird jest doesn't include something similar since it's based on jasmine.","> If you have a \"real\" implementation you want to create a mock from, we could probably expose what `createMockFromModule` does to the loaded module (https:\/\/github.com\/facebook\/jest\/blob\/c2872aae7e3bdc8f9c236637ade294790a47d7f6\/packages\/jest-runtime\/src\/index.ts#L1759-L1771), essentially just `moduleMocker.generateFromMetadata(moduleMocker.getMetadata(object))`. `jest.createMockFromObject`?\r\n\r\nAny update on this @SimenB ? Our teams are forcibly relying on external mocking libraries such as Sinon.js, moq.ts, td.js just for this feature. It is regrettable since jest already has all the foundation for creating mocks plus custom matchers."],"labels":[":rocket: Feature Request"]},{"title":"Pass context to hooks and tests","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nHello Jest\r\n\r\nI'd like to reflect on an example of jest test that you've recommended in [official React blogpost](https:\/\/reactjs.org\/blog\/2019\/02\/06\/react-v16.8.0.html):\r\n\r\n```es6\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { act } from 'react-dom\/test-utils';\r\nimport Counter from '.\/Counter';\r\n\r\nlet container;\r\n\r\nbeforeEach(() => {\r\n  container = document.createElement('div');\r\n  document.body.appendChild(container);\r\n});\r\n\r\nafterEach(() => {\r\n  document.body.removeChild(container);\r\n  container = null;\r\n});\r\n\r\nit('can render and update a counter', () => {\r\n  \/\/ Test first render and effect\r\n  act(() => {\r\n    ReactDOM.render(<Counter \/>, container);\r\n  });\r\n  const button = container.querySelector('button');\r\n  const label = container.querySelector('p');\r\n  expect(label.textContent).toBe('You clicked 0 times');\r\n  expect(document.title).toBe('You clicked 0 times');\r\n\r\n  \/\/ Test second render and effect\r\n  act(() => {\r\n    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));\r\n  });\r\n  expect(label.textContent).toBe('You clicked 1 times');\r\n  expect(document.title).toBe('You clicked 1 times');\r\n});\r\n```\r\n\r\nAn interesting thing is happening here:\r\n\r\n1. `container` is declared outside of tests and shared between them\r\n2. this variable is mutated by beforeEach block\r\n3. variable is reset with afterEach block\r\n\r\nThis might work when tests are synchronous. This might even work if tests are asynchronous because Jest is somehow smart enough to prevent out of order beforeEach and afterEach calls.\r\n\r\nBut let's face it, it's ugly.\r\n\r\nWouldn't it be better if Jest passed to before hooks and currently tested example the same object that is instantiated from scratch for each individual test? Then your example would look as so:\r\n\r\n```es6\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { act } from 'react-dom\/test-utils';\r\nimport Counter from '.\/Counter';\r\n\r\nbeforeEach(context => {\r\n  context.container = document.createElement('div');\r\n  document.body.appendChild(context.container);\r\n});\r\n\r\nafterEach(({ container }) => {\r\n  document.body.removeChild(container);\r\n});\r\n\r\nit('can render and update a counter', ({ container }) => {\r\n  \/\/ Test first render and effect\r\n  act(() => {\r\n    ReactDOM.render(<Counter \/>, container);\r\n  });\r\n  const button = container.querySelector('button');\r\n  const label = container.querySelector('p');\r\n  expect(label.textContent).toBe('You clicked 0 times');\r\n  expect(document.title).toBe('You clicked 0 times');\r\n\r\n  \/\/ Test second render and effect\r\n  act(() => {\r\n    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));\r\n  });\r\n  expect(label.textContent).toBe('You clicked 1 times');\r\n  expect(document.title).toBe('You clicked 1 times');\r\n});\r\n```\r\n\r\nSee? We don't need to declare global container variable and because context is created from scratch for each test we also don't need `container = null;` in afterEach.\r\n\r\nThis can be totally compatible with `done`, because Jest can detect that beforeEach or afterEach accept an object and enable this mode only then.\r\n\r\nIf someone still needed callback-style `done`-like behavior, but with context, then one could use `expect.assertions` `expect.pass` or `expect.fail` instead (or `return new Promise((resolve, reject) => { ... })`).\r\n\r\nThank you","comments":["Another possibility is to enable this mode when beforeEach returns a context:\r\n\r\n```es6\r\nbeforeEach(() => {\r\n  const container = document.createElement('div');\r\n  document.body.appendChild(container);\r\n  return { container }\r\n});\r\n```","Thanks for the detailed description!\r\n\r\n>Wouldn't it be better if Jest passed to before hooks and currently tested example the same object that is instantiated from scratch for each individual test?\r\n\r\nYeah, we've talked about this some privately - some way of mimicking e.g. [Ava's API](https:\/\/github.com\/avajs\/ava\/) (with a context passed to every test, and also ditching globals). This missing feature is also one of the blockers for more work on `test.concurrent`. We don't currently have any concrete plans - only step we've taken is adding an [ESLint rule](https:\/\/github.com\/jest-community\/eslint-plugin-jest\/blob\/master\/docs\/rules\/no-test-callback.md) that will transform functions that takes a `done` callback to return a promise instead. The intention is to move people off of `done` callbacks so that we can free up the callback argument for a future version of Jest to stick a context there.\r\n\r\n>This can be totally compatible with `done`, because Jest can detect that beforeEach or afterEach accept an object and enable this mode only then.\r\n\r\nThis is interesting - how would we detect it? We currently do `testFn.length` to check how many arguments are accepted by the test function. If we can detect a non-function, that'll unblock us.\r\n\r\n>This might work when tests are synchronous. This might even work if tests are asynchronous because Jest is somehow smart enough to prevent out of order beforeEach and afterEach calls.\r\n\r\nAll tests complete in the declaration order unless you use `test.concurrent`. So it'll work fine sync or async.\r\n\r\n---\r\n\r\nTl;dr: We do want to provide some sort of context object, but we have no concrete plans or roadmap on how to get there.\r\n\r\n\/cc @rubennorte who might have more thoughts on this","> This is interesting - how would we detect it? We currently do `testFn.length` to check how many arguments are accepted by the test function. If we can detect a non-function, that'll unblock us.\r\n\r\nNormally there are no arguments passed to beforeEach and afterEach, so you can check whether `beforeEach.length > 0`, and in such case enable passing context to functions.\r\n\r\nIt's not possible to perform such check on `test` because it already can have more than one argument and it's possible, but computationally hard, to detect whether passed argument is used as context or as done callback (you need parse and analyse syntax, and check for done() call).\r\n\r\nI think the best way is to deprecate done and introduce context, where enabling context can happen by either accepting context to beforeEach (without beforeEach context doesn't make any sense), or when a context is returned from beforeEach.","> Normally there are no arguments passed to beforeEach and afterEach, so you can check whether `beforeEach.length > 0`, and in such case enable passing context to functions.\r\n\r\nLifecycle hooks also supports a `done` callback, same as `test`.","Then I guess we're left with enabling this feature when beforeEach returns context\r\n\r\nI like this more anyway because it avoids mutating context in beforeEach, instead you return it in more \"functional\" way","I think it'd make more sense to have people specifying some config option rather than dynamically figuring it out at runtime. Or maybe setting up some codemod (like the eslint plugin), and saying that in version x, `done` is removed so we don't have to support both ways of doing it","I agree with config option + codemod that rewrites done() calls to something better","btw. I'd be in favor of rewriting:\r\n\r\n```es6\r\ntest('something', done => {\r\n  setTimeout(() => {\r\n    Math.random() < 0.5 ? done() : done(\"Error\")\r\n  ), 1000);\r\n})\r\n```\r\n\r\nto something like:\r\n\r\n```es6\r\ntest('something', () => {\r\n  const done = expect.assertions(1)\r\n  setTimeout(() => {\r\n    Math.random() < 0.5 ? done() : done('Error')\r\n  ), 1000);\r\n})\r\n```\r\n\r\nBecause it means minimal changes are necessary (just remove done from argument, and add one line at the top of the test)","IMO, that should ideally be transformed to:\r\n\r\n```js\r\ntest('something', () =>\r\n  new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      Math.random() < 0.5 ? resolve() : reject('Error')\r\n    }, 1000)\r\n  }))\r\n```\r\n\r\nAll asynchronicity should be done via promises - Jest shouldn't provide its own callbacks for handling async (passed into the test function, or created via some other mechanism).\r\n\r\nThe ESLint plugin doesn't handle the failing case actually (totally slipped my mind when implementing it), so I opened up an issue for it: https:\/\/github.com\/jest-community\/eslint-plugin-jest\/issues\/223","Just one last comment from me: maybe it would be good idea to add eslint-plugin-jest rule disallow mutation of global variables in hooks if `test.concurrent` or `it.concurrent` is used in given file, so for example:\r\n\r\n```es6\r\nlet container = null\r\n\r\nbeforeEach(() => {\r\n  container = document.createElement('div');\r\n  document.body.appendChild(container);\r\n});\r\n\r\nafterEach(() => {\r\n  document.body.removeChild(container);\r\n  container = null;\r\n});\r\n\r\nit.concurrent('can render and update a counter', () => {\r\n   \/\/ ...\r\n})\r\n```\r\n\r\nwould complain at first line of beforeEach and last line of afterEach (but only if context passing is enabled).","Yeah, that makes sense to me - not sure how to statically discover what tests are safe to do and what they're not, though","I've received feedback from many people that want to keep `done`, so we should provide an equivalent solution if we use the context object.\r\n\r\nWe could do something like this:\r\n\r\n```javascript\r\nbeforeEach(t => {\r\n  t.context.user = createUser(); \/\/ could also do t.ctx for short\r\n});\r\n\r\nit('should return the user name', t => {\r\n  expect(getUserName(t.context.user)).toBe(t.context.user.name);\r\n});\r\n\r\nit('should return the user name async', async t => {\r\n    await expect(getUserName(t.context.user)).resolves.toBe(t.context.user.name);\r\n});\r\n\r\nit('should return the user name async 2', t => {\r\n  getUserName(t.context.user, username => {\r\n    expect(username).toBe(t.context.user.name);\r\n    t.done();\r\n  });\r\n  return t.awaitDone();\r\n});\r\n```","As a point of reference, ava requires you to opt in to callbacks by supplying a modifier to the test definition: https:\/\/github.com\/avajs\/ava\/blob\/65133a85ecbc881f9610df78feffd498474bcc8c\/docs\/01-writing-tests.md#callback-support\r\n\r\n```js\r\ntest.cb('data.txt can be read', t => {\r\n\t\/\/ `t.end` automatically checks for error as first argument\r\n\tfs.readFile('data.txt', t.end);\r\n});\r\n```\r\n\r\nI also don't like this example:\r\n\r\n```js\r\nit('should return the user name async 2', t => {\r\n  getUserName(t.context.user, username => {\r\n    expect(username).toBe(t.context.user.name);\r\n    t.done();\r\n  });\r\n  return t.awaitDone();\r\n});\r\n```\r\n\r\nIt will time out since `expect` throws, swallowing the error. I guess if we do `t.expect(username)...` that'll work","> I've received feedback from many people that want to keep `done`, so we should provide an equivalent solution if we use the context object.\r\n\r\nI think `const done = expect.assertions(1)` is better than providing any methods on context. I think context ought to be just plain and empty object.\r\n\r\nAlso doing something like `t.context.user`, prevents you to use short destructuring syntax I've shown at the beginning:\r\n\r\n```es6\r\nafterEach(({ container }) => {\r\n  document.body.removeChild(container);\r\n});\r\n```\r\n\r\nInstead you'd need to write\r\n\r\n```es6\r\nafterEach(({ context: { container } }) => {\r\n  document.body.removeChild(container);\r\n});\r\n```\r\n\r\n`it.cb` could be better but it sill requires adding some default fields to context.. like `t.end`. I don't like introducing such \"reserved words\" on context.\r\n\r\nSo my vote is to recommend for `done`-likers:\r\n\r\n```es6\r\ntest('something', () => {\r\n  const done = expect.assertions(1)\r\n  setTimeout(() => {\r\n    Math.random() < 0.5 ? done() : done('Error')\r\n  ), 1000);\r\n})\r\n```","@SimenB my bad, I wrote that too fast \ud83d\ude05\r\n\r\n@sheerun I didn't mean to include methods in the context but having the context as a separate field in the object. The context would indeed be an empty object. I like you proposal better :)","Maybe I'm missing something, but why not just pass `context` as a second parameter to `it` and `test`? It would default to `{}` and if you return a different object from `beforeEach` then that would be used instead, and it would also be passed as the first (only?) parameter to `afterEach`. Then everyone still gets to keep `done` as the first parameter to `it` and `test` and can opt-in to the context param by just declaring it in the parameter list after `done`. Users who don't need `done` can just put `_` there to silence linters.","To clarify by adjusting your examples:\r\n\r\n```javascript\r\nbeforeEach(() => {\r\n  const container = document.createElement('div');\r\n  document.body.appendChild(container);\r\n  return { container }\r\n});\r\n\r\nafterEach(({ container }) => {\r\n  document.body.removeChild(container);\r\n});\r\n\r\nit('can render and update a counter', (done \/* or _ *\/, { container }) => {\r\n  \/\/ Test first render and effect\r\n  act(() => {\r\n    ReactDOM.render(<Counter \/>, container);\r\n  });\r\n  const button = container.querySelector('button');\r\n  const label = container.querySelector('p');\r\n  expect(label.textContent).toBe('You clicked 0 times');\r\n  expect(document.title).toBe('You clicked 0 times');\r\n\r\n  \/\/ Test second render and effect\r\n  act(() => {\r\n    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));\r\n  });\r\n  expect(label.textContent).toBe('You clicked 1 times');\r\n  expect(document.title).toBe('You clicked 1 times');\r\n});\r\n```","@sdegutis `done` in its current form is supposed to go away anyway, after that happens we could implement something like this properly right away.","Also we use the function arity to determine if we should wait for the user to call `done` to finish the test. If we pass it unconditionally there's no way to tell (unless we use a different method)","Ok thanks for the explanation never mind.","Thanks a lot for the link between related issues.\r\n\r\nI think, this very important feature to write cleaner tests. ","Just a quick thought: Mocha passes context as `this`. i.e.:\r\n\r\n```js\r\nbeforeEach(function() {\r\n  const container = document.createElement('div');\r\n  document.body.appendChild(container);\r\n  this.container = container;\r\n});\r\n\r\nafterEach(function() {\r\n  document.body.removeChild(this.container);\r\n});\r\n\r\nit('can render and update a counter', function() {\r\n  \/\/ Test first render and effect\r\n  act(() => {\r\n    ReactDOM.render(<Counter \/>, this.container);\r\n  });\r\n  \/* ... etc ... *\/\r\n});\r\n```\r\n\r\nThis would not clash with `done`.\r\n\r\nDownside is test functions must be full `function() {}`, not arrow functions, so as to receive `this`. But obviously if you don't want to use context, you can use arrow functions, so it wouldn't require any changes to existing tests.","Until a permanent solution is found: I found an article's approach to context with Jest that works well, with a slight tweak. Can pass variables between before\/tests\/after and even across files as well. I put a comment about it here, in case no one finds it since the issue is closed.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/4903#issuecomment-487335531","Also, it would be great if we can access the overall title of the test:\r\n\r\n```ts\r\ndescribe('a', () => {\r\n  describe('b', () => {\r\n    test('c', ({ title }) => {\r\n      console.log(title) \/\/ 'a > b > c'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI am looking for a way to get a unique id of each test, and getting the title of the test would be a great way to do it.\r\n","@unional this is sort of unrelated, but fyi the test title is not suitable as a uid:\r\n![image](https:\/\/user-images.githubusercontent.com\/16069751\/59342172-83fb0900-8d09-11e9-9696-cfcdbe3c86cd.png)\r\n","@jeysal thanks. Fully aware of that. In my use case that is acceptable. Users are not suppose to do that and I can detect and emit a warning.","Ok while we don't have a solution I did a small wrapper for `describe()`, it works like that, what any of the lifecycle returns it will passed as the context, usage on the repository, or what you pass on the initial, also works with typescript.\r\n\r\nSomething like that could be used as a describe.context() also with some hacks I can make test and beforeEach with context available during execution without the need for destructuring.\r\n\r\n```javascript\r\nimport { withContext } from '..\/src';\r\n \r\nwithContext('before each', ({ test, beforeEach }) => {\r\n  beforeEach((state = { foo: 0 }) => {\r\n    return { foo: state.foo + 1 };\r\n  });\r\n  test('foo 1', ({ foo }) => {\r\n    expect(foo).toBe(1);\r\n  });\r\n  test('foo 2', ({ foo }) => {\r\n    expect(foo).toBe(2);\r\n  });\r\n});\r\n```\r\n\r\nhttps:\/\/www.npmjs.com\/package\/jest-with-context","May I suggest a working example from Elixir:\r\n\r\nhttps:\/\/hexdocs.pm\/ex_unit\/ExUnit.Callbacks.html#module-context","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","Personally, I think this issue is worth keeping open.","Agreed, ties into https:\/\/github.com\/facebook\/jest\/issues\/8297#issuecomment-1050744485","Hi all, I was also interested in this and implemented a version with group context stack and isolated test contexts: [jest-ctx](https:\/\/github.com\/ianpurvis\/jest-ctx) The DX is similar to jest-with-context (thanks @EduardoRFS) but I opted for shimming the globals and all their extensions at the import level. I understand that this does not provide the AVA-style API or solve the architectural issues there, but I hope it can be of use to somebody (I used it to write some shared examples). Cheers!\r\n\r\n","I implemented this concept (but not any of the exact APIs above) in user-land:\r\n\r\n```ts\r\ntype AfterEachParams = Parameters<typeof afterEach>;\r\ntype After = ((...params: AfterEachParams) => void) | void;\r\n\r\nfunction aroundEach(before: () => After) {\r\n  let after: After;\r\n\r\n  beforeEach(() => {\r\n    after = before();\r\n  });\r\n\r\n  afterEach((...params: Parameters<typeof afterEach>) => {\r\n    if (after instanceof Function) {\r\n      after(...params);\r\n    }\r\n  });\r\n}\r\n```\r\n\r\nUsage:\r\n```ts\r\nbeforeEach(\"test aroundEach\", () => {\r\n  aroundEach(() => {\r\n    const rand = Math.random();\r\n    console.log(\"Before\", rand);\r\n    return () => {\r\n      console.log(\"After\", rand);\r\n    };\r\n  });\r\n\r\n  test(\"it runs around\", () => {\r\n    console.log(\"During\");\r\n  })\r\n})\r\n```\r\n\r\nThat's particularly useful if you want to ensure that resources are cleaned up:\r\n```ts\r\naroundEach(() => {\r\n  server = configureServer(...)\r\n  server.start()\r\n  return server.close.bind(server)\r\n})\r\n```\r\n\r\n**Caveat**\r\nI'm not necessarily saying that I think Jest should implement this concept using this `useEffect`-inspired API. I chose this because of the constraints of implementing it in user-land.\r\n\r\nI would love to see the ability to schedule clean up work from within a `beforeEach\/afterEach\/test` instead of within a `describe`. That would let me do this:\r\n\r\n```ts\r\ntest(\"something that depends on a server\" (done, after) => {\r\n  const server = configureServer(...)\r\n  server.start()\r\n  after(() => server.close)\r\n  expect(foo()).toBe('bar')\r\n})\r\n```"],"labels":[":rocket: Enhancement","New API proposal","Discussion","Pinned"]},{"title":"Make test name available in beforeEach() and afterEach()","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nMake test name available in `beforeEach()` and `afterEach()`.\r\n\r\n## Motivation\r\n\r\nWhen running Selenium tests it's helpful to take a screenshot after every test. Best name for those files would be the test name. Now I use url and timestamp, which are not that good.\r\n\r\nFor further logging purposes `beforeEach()` could use the test name too, to log when that test starts. It makes easier to search server logs from the same time.\r\n\r\n## Example\r\n\r\n```javascript\r\nafterEach(async (testName) => {\r\n  await saveScreenshot(testName);\r\n  log(`Test '${testName}' ended at ${getTime()}`);\r\n});\r\n```\r\n","comments":["Interesting suggestion, thanks! If this is implemented, the argument should probably be an object literal to make it easy to pass in more things to the function without a breaking change.","Sounds cool. This will be possible once we get rid of `done` and replace it with generic purpose object, like AVA does :)","That won't happen any time soon though - in the meantime you can use `jest-image-snapshot` - the snapshot file will get the test's name automatically. If that doesn't fit, I'd look into implementing it in some other way using jest's snapshot features so that you get the name included","just wanted to add that this would be super useful when using an XHR vcr like nock back. Right now I have to do this in each test\r\n\r\n```\r\n    const { nockDone } = await nockBack('fixtureName.json')\r\n\r\n    \/\/ the actual test\r\n\r\n    nockDone()\r\n```\r\n\r\nit would be awesome to just do something like \r\n\r\n```\r\n  let nockDone\r\n\r\n  beforeEach(() => {\r\n    const result = await nockBack(testName + '.json')\r\n    nockDone = result.nockDone\r\n  })\r\n\r\n  afterEach(() => {\r\n    nockDone()\r\n  })\r\n```","in case this is helpful, mocha keeps a whole suite of helpers in the befores' `this` scope. Would it make sense to pass some sort of class instance, instead of an object literal, so we can pave the way for things like `.skip()` programmatically?\r\n\r\nhttps:\/\/mochajs.org\/api\/suite#fullTitle\r\n\r\n```js\r\ndescribe('test suite', () => {\r\n  beforeEach(function () {\r\n    console.log(this.currentTest.fullTitle())\r\n    \/\/ test suite nested names are included too\r\n  }\r\n  describe('nested names are', () => {\r\n    it('included too', () => {\r\n    })\r\n  })\r\n})","My current solution.\r\n\r\nFile: `jest.config.js`:\r\n```json\r\nmodule.exports = {\r\n    setupFilesAfterEnv: ['.\/jest.setup.js'],\r\n    \r\n    .................\r\n};\r\n```\r\n\r\nFile `jest.setup.js`:\r\n```js\r\n\/\/ Patch tests\r\njasmine.getEnv().addReporter({\r\n    specStarted: result => jasmine.currentTest = result,\r\n    specDone: result => jasmine.currentTest = result,\r\n});\r\n```\r\nFile `any-test.spec.ts`\r\n```typescript\r\ndescribe('Test description', () => {\r\n    beforeEach(() => console.log('Before test', jasmine['currentTest'].fullName));\r\n\r\n    afterEach(() => console.log(\r\n      'Test', \r\n      jasmine['currentTest'].fullName,\r\n     'failed',\r\n     !!jasmine['currentTest'].failedExpectations.length\r\n   ));\r\n\r\n   it('example', () => expect(1).toBe(1));\r\n});\r\n```\r\n\r\nI hope it helps somebody.\r\n","This would be handy simply because I'm using jest to run long integration tests with lots of logging. It's nice to see which test is being run before the setup in the before* hooks start.","@optimistex 's solution still works today, so that's nice. Here's the types, so you don't have to do the `['currentTest']` and force it into an `any` type:\r\n\r\n```typescript\r\ndeclare namespace jasmine {\r\n    const currentTest: {\r\n        id: string;\r\n        description: string;\r\n        fullName: string;\r\n        failedExpectations: {\r\n            actual: string;\r\n            error: Error;\r\n            expected: string;\r\n            matcherName: string;\r\n            message: string;\r\n            passed: boolean;\r\n            stack: string;\r\n        }[];\r\n        passedExpectations: unknown[];\r\n        pendingReason: string;\r\n        testPath: string;\r\n    };\r\n}\r\n```\r\nNote I made `passedExpectations` an `unkown[]`, as it was always an empty array for me. Not sure if it ever contains something.","Just a quick note: The last bits of Jasmine remaining in Jest are supposed to be phased out soon, as `jest-circus` becomes the default test runner implementation. This does not mean using Jasmine-specific APIs will no longer be possible, just that you may miss out on any new features \/ fixes specific to `jest-circus`. See https:\/\/jestjs.io\/blog\/2020\/05\/05\/jest-26 for a timeline.","In jest-circus, I noticed that when I console.log the `event.test` inside `handleTestEvent`, I get a recursive test type (something like test -> parent -> parent -> ROOT_DESCRIBE_BLOCK):\r\n```javascript\r\nconsole.log({\r\n  type: 'test',\r\n  asyncError: \"ErrorWithStack: etc...\",\r\n  duration: null,\r\n  errors: [],\r\n  fn: [Function (anonymous)],\r\n  invocations: 1,\r\n  mode: undefined,\r\n  name: 'first it',\r\n  parent: {\r\n    type: 'describeBlock',\r\n    children: [ [Circular *1], [Object] ],\r\n    hooks: [],\r\n    mode: undefined,\r\n    name: 'first describe',\r\n    parent: {\r\n      type: 'describeBlock',\r\n      children: [Array],\r\n      hooks: [Array],\r\n      mode: undefined,\r\n      name: 'ROOT_DESCRIBE_BLOCK',\r\n      parent: undefined,\r\n      tests: []\r\n    },\r\n    tests: [ [Circular *1] ]\r\n  },\r\n  startedAt: 1591598218051,\r\n  status: null,\r\n  timeout: undefined\r\n})\r\n```\r\n\r\nI was wondering if there is an equivalent function to `jasmine['currentTest'].fullName`?\r\n\r\nEDIT: In the meantime this is what I did to get the full test name:\r\n```javascript\r\n    if (event.name === \"test_start\") {\r\n      let testNames = [];\r\n      let currentTest = event.test;\r\n      while (currentTest) {\r\n        testNames.push(currentTest.name);\r\n        currentTest = currentTest.parent;\r\n      }\r\n      this.global.testName = testNames\r\n        .slice(0, testNames.length - 1)\r\n        .reverse()\r\n        .map((name) => name.replace(\/\\W\/g, \"-\"))\r\n        .join(\"-\");\r\n    }\r\n```","Bumping this if there is any clear update or expectation on this feature.","I stumbled across the following which may be of interest to others.\r\n\r\n```js\r\nbeforeEach(() => {\r\n  console.log(expect.getState().currentTestName);\r\n})\r\n\r\nafterEach(() => {\r\n  console.log(expect.getState().currentTestName);\r\n})\r\n```","> I stumbled across the following which may be of interest to others.\r\n> \r\n> ```js\r\n> beforeEach(() => {\r\n>   console.log(expect.getState().currentTestName);\r\n> })\r\n> \r\n> afterEach(() => {\r\n>   console.log(expect.getState().currentTestName);\r\n> })\r\n> ```\r\n\r\nVery nice, It works on jest@25.5.1. Thanks!","Despite being undocumented, `expect.getState().currentTestName` still works in Jest v26.6.3, including in `test` blocks, but it returns the full name of the `describe` -> `describe` -> ... -> `test`, with space separators between the path components :man_facepalming:. That may make it confusing to figure out what the `test` name is, vs. the `describe` name, especially in nested `describe`s.\r\n\r\nAnyway, I've added this method as my [#1 answer to this StackOverflow question](https:\/\/stackoverflow.com\/questions\/52788380\/get-the-current-test-spec-name-in-jest\/62694295#62694295) about accessing the test name.","This kind of logging should be done by jest itself (like junit) and there is no need to make this information in another way available.","Using `jest-circus` and a custom environment, [we use `handleTestEvent`](https:\/\/github.com\/getsentry\/sentry\/blob\/master\/tests\/js\/instrumentedEnv\/index.js#L184) to essentially keep state of the test name in these different events. Our use case was to instrument our test suites... the output is something like this:\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/79684\/121261611-c9eef700-c867-11eb-892e-bce8d882778b.png)\r\n","Thanks @billyvg for your answer.  The linked code gave me an idea and wrote an [answer on SO](https:\/\/stackoverflow.com\/a\/67975475\/4420543).","Is there a way we can get the `testStatus` afterEach? ","Based in the @aesyondu snippet and with hours of console.logs I achieved to get the describeName, testName and status\r\n\r\nThis is my CustomNodeEnvironment.js\r\n\r\n```\r\nconst NodeEnvironment = require('jest-environment-node');\r\n\r\nclass CustomNodeEnvironment extends NodeEnvironment {\r\n\r\n    async setup() {\r\n        await super.setup();\r\n      }\r\n\r\n    async handleTestEvent(event, state) {\r\n             \r\n        if (event.name === \"test_start\") {\r\n            let testNames = [];\r\n            let currentTest = event.test;\r\n            while (currentTest) {\r\n              testNames.push(currentTest.name);\r\n              currentTest = currentTest.parent;\r\n            }\r\n\r\n            this.global.describeName = testNames[1]  \r\n            this.global.testName = testNames[0]  \r\n        }\r\n\r\n        if (event.name === \"test_fn_failure\") {\r\n            this.global.testStatus = \"failure\"\r\n        }else if (event.name === \"test_fn_success\") {\r\n            this.global.testStatus = \"success\"\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = CustomNodeEnvironment\r\n```\r\n\r\nThis my test\r\n\r\n```\r\ndescribe(`Im the describe`, () => {\r\n  let driver;\r\n\r\n  it(`Im the first test`, async () => {    \r\n    expect(3).toBe(3);\r\n  });\r\n\r\n  it('Im the second test', async () => {    \r\n    expect(3).toBe(4);\r\n  }); \r\n  \r\n  afterEach(() => {\r\n    console.log({testStatus:testStatus, testName:testName, describeName:describeName});\r\n  }) \r\n});\r\n```\r\nAn my jest.config.js\r\n```\r\nconst { defaults } = require(\"jest-config\");\r\nmodule.exports = {\r\n  testEnvironment: '.\/src\/helpers\/CustomNodeEnvironment.js',\r\n};\r\n```\r\n\r\n\r\nAn this is the log in which I have access to the detail of each test after its execution\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/3322836\/199864574-a469f470-06c8-4afb-91f3-a2fb87701cb8.png)\r\n\r\nI will try to improve the while to get the describe and test names.\r\n","Hello guys!\r\nIs there still no way to get running test suite\/test file name in Jest 29.4.1?\r\ni mean the Jest way","Bump, it was so easy with Jasmine...","> Based in the @aesyondu snippet and with hours of console.logs I achieved to get the describeName, testName and status\r\n> \r\n> This is my CustomNodeEnvironment.js\r\n> \r\n> ```\r\n> const NodeEnvironment = require('jest-environment-node');\r\n> \r\n> class CustomNodeEnvironment extends NodeEnvironment {\r\n> \r\n>     async setup() {\r\n>         await super.setup();\r\n>       }\r\n> \r\n>     async handleTestEvent(event, state) {\r\n>              \r\n>         if (event.name === \"test_start\") {\r\n>             let testNames = [];\r\n>             let currentTest = event.test;\r\n>             while (currentTest) {\r\n>               testNames.push(currentTest.name);\r\n>               currentTest = currentTest.parent;\r\n>             }\r\n> \r\n>             this.global.describeName = testNames[1]  \r\n>             this.global.testName = testNames[0]  \r\n>         }\r\n> \r\n>         if (event.name === \"test_fn_failure\") {\r\n>             this.global.testStatus = \"failure\"\r\n>         }else if (event.name === \"test_fn_success\") {\r\n>             this.global.testStatus = \"success\"\r\n>         }\r\n>     }\r\n> }\r\n> \r\n> module.exports = CustomNodeEnvironment\r\n> ```\r\n> \r\n> This my test\r\n> \r\n> ```\r\n> describe(`Im the describe`, () => {\r\n>   let driver;\r\n> \r\n>   it(`Im the first test`, async () => {    \r\n>     expect(3).toBe(3);\r\n>   });\r\n> \r\n>   it('Im the second test', async () => {    \r\n>     expect(3).toBe(4);\r\n>   }); \r\n>   \r\n>   afterEach(() => {\r\n>     console.log({testStatus:testStatus, testName:testName, describeName:describeName});\r\n>   }) \r\n> });\r\n> ```\r\n> \r\n> An my jest.config.js\r\n> \r\n> ```\r\n> const { defaults } = require(\"jest-config\");\r\n> module.exports = {\r\n>   testEnvironment: '.\/src\/helpers\/CustomNodeEnvironment.js',\r\n> };\r\n> ```\r\n> \r\n> An this is the log in which I have access to the detail of each test after its execution\r\n> \r\n> ![image](https:\/\/user-images.githubusercontent.com\/3322836\/199864574-a469f470-06c8-4afb-91f3-a2fb87701cb8.png)\r\n> \r\n> I will try to improve the while to get the describe and test names.\r\n\r\nDoes this work if the test cases (the \"test(..)\") are running in parallel? Don't the test events get sent out of order?","> just wanted to add that this would be super useful when using an XHR vcr like nock back. Right now I have to do this in each test\r\n> \r\n> ```\r\n>     const { nockDone } = await nockBack('fixtureName.json')\r\n\r\nthis is literally exactly what i came here looking for. this is how i do it in playwright."],"labels":[":rocket: Feature Request"]},{"title":"New top level package for jest-config utilities","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nCurrently src\/utils.js in jest-config contains a lot of methods which could be useful as a top-level package.\r\n\r\n## Motivation\r\n\r\nProvide self-contained packages without additional bloat.\r\n\r\n## Example\r\n\r\njest-junit would use only the replaceRootDirInPath method if it were available as a separate package. https:\/\/github.com\/jest-community\/jest-junit\/blob\/master\/utils\/replaceRootDirInPath.js\r\n","comments":["What would be the name of the package? Should we add something else than `replaceRootDirInPath`?"],"labels":[":rocket: Feature Request"]},{"title":"chore: add worker build on CI","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md in the root of the project if you have not done so. -->\r\n\r\n## Summary\r\nFrom #7610. @rickhanlonii could you take a look? \ud83d\ude42 \r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\nWill fail (for now)\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["`worker_threads` is unflagged in node 11.7.0, so the extra job isn't necessary. When (if) we land #7681 I'll update this PR to remove all the `disableWorkerThreads: true` and see where we're at","Circle has node 11.8 now, which has the `umask` fix. Rebased, hopefully a better result this time \ud83d\ude42 ","We test threads but we're actually running our test suite serially. Maybe it's worth to run tests by default on 2 or 4 workers and run in band e.g. on travis or somewhere?","I wanna see that tests pass without being stupidly slow first. If they do, then we can test by actually spinning up workers \ud83d\ude42 \r\n\r\nThese have to be fixed first:\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/51930962-07235e80-23fc-11e9-9151-82cff22bea59.png)\r\n","haha, it just died \ud83d\ude1b But looking at, and fixing, `multiProjectRunner` might be what we're missing. If anybody wants to pick it up","Test failures on node 12, that's odd...","whatever that old issue was, it seems to have been fixed \ud83d\udc4d \r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/68541332-62787900-039e-11ea-82d2-c438564cfbc5.png)\r\n\r\nWill need to look into why coverage fails, but this is super promising","Very interesting - tests fail on circus, but passes on GH Actions. The failing test on CI passes on my local machine. Very odd...","for those that want to test this, check this patch-package https:\/\/gist.github.com\/sibelius\/c6ef3f0890814dd4163a9ada0cd739f1","@sibelius very interested in hearing numbers if you play with - does it impact memory\/cpu usage?","I've tried to use worker_threads because child process was failing for us, here is the issue https:\/\/github.com\/facebook\/jest\/issues\/10144\r\n\r\nWhen using `worker_threads` we got some \r\n\r\n```\r\nCircleCI received exit code 137 \r\n```\r\n\r\n137 means Out of Memory.\r\n\r\nSo worker threads is kind of worse than child process right now for us\r\n\r\nmongodb-memory-server was causing OOM for us because it was spinning 1 mongod per test file, we fixed this here https:\/\/github.com\/shelfio\/jest-mongodb\/pull\/209\r\n\r\nbut worker_threads still leaking on CircleCI\r\n\r\nbut it does not leak when running local, `--logHeapUsage` show always less than 300mb, so not sure if leakage is because of node 12.18.0 or because of docker or circleci specific","we fixed most issues of our tests\r\n\r\nand now worker_threads is working fine for us (node 12.18.0)\r\n\r\nwe didn't notice any improvement in cpu time or memory usage","https:\/\/www.npmjs.com\/package\/piscina just leaving this here as something to maybe explore in the future, who knows, maybe it's faster than `jest-worker`s worker threads farm impl"],"labels":["Help Wanted","cla signed"]},{"title":"Jest is 3x slower on all windows machines (Windows 10 and lower)","body":"\r\n## \ud83d\udc1b Bug Report\r\n\r\nJest is slow on windows machines.\r\n\r\n## To Reproduce\r\n\r\nAnyone with a windows desktop machine.\r\n\r\n## Expected behavior\r\n\r\nIt should be lightning fast.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\n  System:\r\n    OS: Windows 10\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-7400 CPU @ 3.00GHz\r\n  Binaries:\r\n    npm: 6.2.0 - C:\\Program Files\\nodejs\\npm.CMD\r\n```\r\n\r\nI've done a ton of reading around and it seems like 100% of all windows users are being affected by delaying in running tests with jest, while it is blazingly fast for all mac users. \r\n\r\nHas there been any research or attempts to find what is causing this? Currently I'm copy and pasting all of my components and unit testing them in codesandbox,  (It instantly runs tests blazingly fast) then copy and pasting them back into my project, which isn't the most ideal way to do it but I love the API that jest offers.","comments":["Related: #6783\r\n\r\nIs it slow starting up, or in watch mode as well? If just during startup, you can try to install `watchman`, that should help (https:\/\/facebook.github.io\/watchman\/docs\/install.html)","When its going through the tests it seems fine from there on out (EDIT: Actually it is slower when running tests as well. It goes through one by one at the speed of 0.5 secs while the norm feels like 0.05 \r\n secs per test)\r\nHowever it is slow on starting up and\/or initiating jest tests (about 4-6 seconds delay, 4-6x slower than mac machines)\r\n\r\nI will try watchman and get back to you","If you could profile using e.g. [`ndb`](https:\/\/github.com\/GoogleChromeLabs\/ndb) the startup and figure out what's slow, that'd be a big help as well \ud83d\ude42 ","The delay is still slow even with watchman installed.\r\nI've run a profiling test with ndb running \"jest --verbose\", here are the results:\r\n\r\n### Screenshot of the first 1.7 seconds:\r\n![first_1 7secs](https:\/\/user-images.githubusercontent.com\/20717348\/51157527-18357280-1835-11e9-8977-0613134bc715.JPG)\r\n\r\n### Screenshot of 1.8 secs to 2.7 secs\r\n![image](https:\/\/user-images.githubusercontent.com\/20717348\/51157655-be817800-1835-11e9-9405-272c9ea92418.png)\r\n\r\n### A .json file and a .heapsnapshot file saved from the profile tab in ndb after recording:\r\n[profiling.zip](https:\/\/github.com\/facebook\/jest\/files\/2757988\/profiling.zip)\r\n","@pfftdammitchris what is your [exact] usecase where you noticed the slow?\r\n(one file or multiple files)? (watch mode or no)? can you provide the exemple.\r\nfor one file watch mode problem => please read my last comment in: #6783","It is slow for both single and multiple files, with or without watch mode. Pretty much every time it runs any test there is a 3+ second delay on initializing the tests, and it is slow running the tests one by one by 0.3 or 0.4 or 0.5 seconds each while other test runners like mocha\/chai would usually just run each as if it feels like 0.05 seconds each.\r\n\r\nI use jest in codesandbox and they seem to run jest instantly on initialization\/running tests, I watched my coworkers run jest on their mac machines and they run it instantly like normally. It's just windows machines as far as I know. I use a windows machine at work and jest is having the slow problem there, and I also use a windows machine at home and the problem continues here.\r\n\r\nI used --runInBand but it seemed to have slightly slowed down the unit tests even further by an additional 0.2 seconds each, based on feeling.","**Clarification**\r\n> I used --runInBand but it seemed to have slightly slowed down the unit tests even further by an additional 0.2 seconds each, based on feeling.\r\n\r\n=> did you try with v24?  from v23 to v24, You 'll see a good improvement for this scenario ONLY:\r\n_on the `rerun` with `watch` and only if you run against one file (not on the first run)_\r\n-> 2\/3sec drop to 0.4\/0.5sec . \r\nbut compared to mac i never tried... so maybe it still bad... even with the current improvement\r\n\r\n--------------\r\n\r\n@SimenB \r\n1. I consider https:\/\/github.com\/facebook\/jest\/issues\/7110 as Jest speed regressions [v22 vs v23] on Windows for ALL problematic scenarios.\r\nwhere #6783 is one of them\r\n\r\n**2. I can consider this issue as: speed problem for jest [Mac vs Windows] for ALL problematic scenarios.**\r\n\r\n\r\n","Hello all !\r\nI cumulate the slowness of jest 24 and windows 10 (800s for 400 tests!). The faster way I found to speed up all of this is to use wsl instead of powershell or cmd. Now my tests takes \"only\" 189s.","We have a suite of 144 tests files with 1302 tests that take 1 minute and 43 seconds to run on a Windows 10 build 15063 machine, Core i7 with 16GB , and they takes 28 seconds on a MAC OS Mojave with 32GB. Our development team is split evenly between Windows and Mac and the numbers are very repeatable.","Here's a simple test - \r\n\r\n```\r\nit(\"works\", () => {\r\n  expect(1).toEqual(1);\r\n});\r\n```\r\n\r\nI put it in codesandbox and it runs pretty much instantly - https:\/\/codesandbox.io\/s\/4q8l0q52lw\r\n\r\non my Windows machine though it takes 4-5 seconds - \r\n\r\n> PASS  src\/index.test.js\r\n>   v works (62ms)\r\n> \r\n> Test Suites: 1 passed, 1 total\r\n> Tests:       1 passed, 1 total\r\n> Snapshots:   0 total\r\n> Time:        4.158s\r\n> Ran all test suites.\r\n\r\nThe test itself took 62ms, but the rest of the test harness took 4 seconds. Re-running the test by hitting Enter it takes the same amount of time. \r\n\r\nMy settings - \r\n```\r\n> npx envinfo --preset jest\r\n\r\n  System:\r\n    OS: Windows 10\r\n    CPU: (4) x64 Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz\r\n  Binaries:\r\n    Node: 8.12.0 - C:\\Program Files\\nodejs\\node.EXE\r\n    Yarn: 1.10.1 - C:\\Program Files (x86)\\Yarn\\bin\\yarn.CMD\r\n    npm: 6.4.1 - C:\\Program Files\\nodejs\\npm.CMD\r\n```\r\n\r\nI tried it with the WSL Ubuntu and got the same results (4-5 secs) - those settings - \r\n\r\n```\r\n  System:\r\n    OS: Linux 4.4 Ubuntu 18.04.2 LTS (Bionic Beaver)\r\n    CPU: (4) x64 Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz\r\n  Binaries:\r\n    Node: 8.10.0 - \/usr\/bin\/node\r\n    npm: 3.5.2 - \/usr\/bin\/npm\r\n```\r\n\r\nI'm just getting started with Jest so have pretty simple tests, and they can take 15-20 seconds to run. I'd love to have them running quickly - I tend to lose my train of thought otherwise!\r\n\r\n","@bburns read above issue\r\n\r\n---------------------------------\r\n@kensherman \r\ncan you try with micromatch 4 in your yarn resolutions.  to see if it's  better in windows please?\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/7963#issuecomment-483985345\r\n","I'm on a brand new MacBook Pro. As I have students on both MacOS and Windows 10, I decided to add two more partitions to my drive; one for Windows 10 and one for shared storage using Tuxera NTFS.\r\n\r\nI ran into this speed issue today preparing a JavaScript lesson that incorporates unit tests. I'm actually running Jest from MacOS but the code and tests are located on the shared NTFS partition. Even with all suites marked as `describe.skip`, Jest takes more than 10 seconds to complete, both in single-run and watch modes.\r\n\r\n8 suites\r\n42 tests\r\n\r\nI swapped `jest` for `mocha` and `chai` and runs came back down to about 1 second single and 10 milliseconds watch mode.","> I swapped jest for mocha and chai and runs came back down to about 1 second single and 10 milliseconds watch mode.\r\n\r\nBasically you didn't read my last post. You wanted to promote `mocha\/chai` ... we all know about this... We are trying to make the regression of jest fixed. Either you help to do this [from my post] `...can you try with micromatch 4...`or keep these useless comments out of the thread. Sorry to be direct but at some point there is no other way to say it.","@nasreddineskandrani  i am trying out jest@24.8.0 but i can still see extremely slow execution when running with watch mode any help would be much appreciated.","@pachumon the fix is not present in 24.8.0 as far as i understood\r\n\r\nyou need to set one dependency of jest to a specific version to remove the performance issue (theoretically) the fix will be by default present in jest 25 => read here to know how a dev find out this https:\/\/github.com\/facebook\/jest\/issues\/7963#issuecomment-483985345\r\n\r\nto set the dependency (micromatch) to the version where the fix was done => you can check here i did an example in a little project\r\nhttps:\/\/github.com\/nasreddineskandrani\/benchmark_jest\/blob\/master\/jest_24_with_micromatch4\/package.json\r\n\r\nAdd to your `package.json`: (must use `yarn` not `npm`)\r\n```\r\n...\r\n  \"resolutions\": {\r\n    \"micromatch\": \"^4.0.0\"\r\n  }\r\n...\r\n```\r\n\r\nHope  this helps! and waiting for feedback \r\n\r\n","My test run time has also ballooned from ~2.5 minutes on 23.6.0 to ~15 minutes on 24.7.1 and 24.8.0. Our CI server is running windows and has seen a similarly large increase in build time with this upgrade. I've tried the micromatch dependency resolution override as mentioned above by @nasreddineskandrani to no avail. Please let me know if there's anything I can do to assist with diagnosing this.","@TomMahle this is a super bad newz :( (the regression we are talking about on top was in 23.6 already)\r\nRight now a simple 'sample' project did show good perf. after micromatch update. \r\nso we need real problematic project to debug, you project is private? or public?","Thanks for the suggestion about `micromatch` @nasreddineskandrani, but like @TomMahle above, pinning it to `^4.0.0` didn't seem to improve performance for me either. \ud83d\ude22 \r\n\r\nI did find out one funky thing, though, which might help in diagnosing this problem.\r\n\r\nI have the ability to run jest either on my native windows system, in a docker container with the main app directory mounted from my windows filesystem.  Running in non-watch mode seems to have nearly identical behavior in both systems, which maybe suggests, as @thebearingedge implied, that the core problem has something to do with the NTFS filesystem, since my docker container is ultimately running everything except the filesystem in a linux VM.\r\n\r\nHowever, on watch mode, things are slightly different: native windows always works slowly as expected, but the docker container only runs tests slowly **on the first run**.  Once I tell it to run any test suite for the second time (e.g. by pressing <kbd>p<\/kbd> and entering a pattern), it runs the tests in well under one second (doing the same in native windows takes 3-4 seconds).  The only downside of using docker is that the file change events don't seem to propagate from my windows volume to docker, so I have to manually press <kbd>Enter<\/kbd> to re-run the test rather than having jest do it automatically, but I guess that's not relevant to the issue at hand.\r\n","@nasreddineskandrani. Unfortunately my project is private. If there's any smaller code samples (the jest config?) Or statistics I could provide I'm happy to do that, though. All the tests seem to be dramatically slower (only on windows) so I don't think it has to do with the specific tests. ","I am finishing a docker stuff i am doing for my personnal websites -> after (in a week) i'll come back on this.\r\n\r\n@TomMahle\r\nI'll try my side to have a repo github with the problem you describe.\r\n1. How many tests do you have? \r\n2. are you enabling `dom` mode for the tests? \r\n3. it's react or angular?\r\nbonus: \r\n4. can you try to reproduce the problem in a github repo to be able to debug? \r\n you can fork mine: https:\/\/github.com\/nasreddineskandrani\/benchmark_jest\r\nOr \r\n5. maybe try my repo on your test machine? and see the results? between 23.6 and 24","I thought enough attention had been given to micromatch's maintainers so that this must've been ironed out already. Running(thus writing) jest tests on windows is a very unpleasant experience at the moment.","I've moved to mocha\/chai since then but i'm surprised this issue is still being worked on.\r\n\r\n\r\n> **Clarification**\r\n> \r\n> > I used --runInBand but it seemed to have slightly slowed down the unit tests even further by an additional 0.2 seconds each, based on feeling.\r\n> \r\n> => did you try with v24? from v23 to v24, You 'll see a good improvement for this scenario ONLY:\r\n> _on the `rerun` with `watch` and only if you run against one file (not on the first run)_\r\n> -> 2\/3sec drop to 0.4\/0.5sec .\r\n> but compared to mac i never tried... so maybe it still bad... even with the current improvement\r\n> \r\n> @SimenB\r\n> \r\n> 1. I consider #7110 as Jest speed regressions [v22 vs v23] on Windows for ALL problematic scenarios.\r\n>    where #6783 is one of them\r\n> \r\n> **2. I can consider this issue as: speed problem for jest [Mac vs Windows] for ALL problematic scenarios.**\r\n\r\nI tried with both versions at that time of the post.\r\n\r\nI just created a new project with one test with simple array push tests and it took more than 10 seconds from start to completion. The project is using react\/typescript but the test file is not a react component file but a normal file like a .js. Gif below for visual reference if it makes it better to visualize what the issue might be:\r\n\r\n![1](https:\/\/user-images.githubusercontent.com\/20717348\/61173559-cf434a00-a549-11e9-84e9-c019c3a9a9be.gif)\r\n\r\nI noticed that the first time I run the test it shows that the test is estimated to be 9 seconds. Once it completes, it randomly *retries* the tests a second time to completion.\r\n\r\nWhen I took that gif picture above (which was the second time this time), the time estimated cut down a little  and it didn't perform a second retry. Not sure if that is the expected jest behavior.\r\n\r\nHere is a gif of me running micromatch 4 with yarn in a separate project:\r\n\r\n![2](https:\/\/user-images.githubusercontent.com\/20717348\/61173769-bee09e80-a54c-11e9-88db-a3d5490da4fa.gif)\r\n\r\nUsing windows 10 and my computer specs are:\r\nAMD FX(tm)-8320 Eight-Core Processor 3.50GHz\r\n16GB ram\r\nx64\r\nSSD","Let me share my profiling here. \r\nSpecs:\r\n- Windows 10 Pro\r\n- Node 10.15.3\r\n- Intel Core i7-4702MQ 2.2GHz\r\n- 8GB RAM\r\n- x64\r\n- SSD\r\n\r\nSteps:\r\n1. `npx create-react-app my-app --typescript`\r\n2. change `App.test.tsx`\r\n3. run `npm test`\r\n\r\nCPU Profile:\r\n![image](https:\/\/user-images.githubusercontent.com\/3163392\/62293485-092caf80-b469-11e9-884f-06d117185775.png)\r\n[CPU-20190801T141211.zip](https:\/\/github.com\/facebook\/jest\/files\/3456686\/CPU-20190801T141211.zip)\r\n\r\nIs it expected that 15 seconds are spent only with requring modules for single trivial React component and test?\r\n\r\nCan someone with more experience on CPU profiling take a look?\r\n","112 tests\r\nwindows 10\r\nfirst run 507 seconds\r\nsecond run 23 seconds\r\nlinux sub system\r\nfrist run 54 seconds\r\nsecond run 29 seconds\r\n\r\n85 tests\r\nwindows 10\r\nfirst run 44 seconds\r\nsecond run 15 seconds\r\nlinux sub system\r\nfirst run 26 seconds\r\nsecond run 15 seconds\r\n\r\n","Kepro these results are with micromatch 4?\r\n\r\n-------------------\r\n\r\n I prefer direct chat than having 1 millions message here it's really becoming a hell to follow cross all issues that are related to the same topic.\r\nYou can join here. https:\/\/gitter.im\/wearefrontend\/jest-slow-windows\r\nI am on it now... ","Gitter is blocked over my company VPN - if you lovely people could post any meaningful updates here that would be amazing <3","you can still connect at home to do some open source :P and check it\r\np.s. a dota game takes more time to queue now you can check gitter in this time ;)\r\nthis is where it is now: nodejs\/node#28946","@nasreddineskandrani You got me. I've ordered a new macbook so will be out of open-source action until it arrives. I refuse to actually work on my crappy Windows box in my spare time :D\r\n\r\nIt seems like the issue has moved in to the node\/C++ realm, which is a little (extremely) outside my comfort zone - but I will do some digging!","Hi any news on this? \r\n\r\nAs a workaround you can use  --runInBand if you start multiple tests. It will still took long to start the first test but the next tests will be fast.\r\n\r\nMy project took 21.803s for executing all tests. \r\nNow with   --runInBand it takes only 7.412s","--runInBand for me just make it even slower. 1200tests. Without runinBand 70\/50seconds. With --runInBand its 90 second on second runs at best\r\nOn linux its like 5-8x faster","Try --maxWorkers=4 then.","@cino893, not a solution :) try to find fix not a workaround","Any news on that? I stacked on version 21 because of that bug. v22 is slow and v23 is even slower.\r\nDon't you guys think it is high priority bug?\r\n\r\nWhere I work, we do not have freedom to choosing OS nor to install Ubuntu on Window or something similar.","@gombek have you tried v25? The Jest team have made a lot of performance improvements across the board.","Hi, just thought I'd add some additional information to this discussion. Jest is super slow also when executed inside a Docker container which has the source code and tests shared via volume from the host system (Windows).\r\n\r\nI'm pretty certain this slowdown is due to the differences in how Windows handles file handles compared to unix systems. In unix, if a process has a file handle open that does not block other processes from reading that file. In Windows, a process holding a file handle owns that file as long as it releases the handle. I would look into Jest code for file reading logic and especially when and how file handles are released. A well behaving program should anyway release file handles immediately after it has done it's job. Test runner like Jest should have no reason to hold file handle for a long time anyway.","> @gombek have you tried v25? The Jest team have made a lot of performance improvements across the board.\r\n\r\nI'm using Jest v25 on windows and it is still slow","@pfftdammitchris I have compared pretty complex test suites on Mac + Windows and I see some differences, mainly from a cold cache Windows is notably slower, but once it's hot I get similar performance between the two.\r\n\r\n**HOWEVER...**\r\n\r\nOne thing to be extremely wary of on Windows in particular are intrusive kernel-level programs like Antiviruses\/File-watchers like Carbon Black (or other real-time file watching software). If you have something like this running, you can see **HUGE** performance hits when running Jest. I am talking about it taking tens of minutes to run tests.\r\n\r\nI worked for a company last year where the same test suite took ~30 seconds on a Macbook Pro & 20 **minutes** on a Windows laptop with these file-watching programs running.\r\n\r\nI have no idea why, but I would hazard a guess it's something to do with file-handles & how Jest uses some of the node.js filesystem APIs.","I only have around 20 tests and I've just taken some timings with jest --watch, both on the intial run and then pressing enter to re-run them.\r\n\r\nOn Windows it took about 15 seconds both times whereas for linux it was around 5.3 seconds for the first run and 2.3 on subsequent runs.\r\n\r\nI tried using -t=\"GARBAGE\" to cause all the tests to be skipped. the linux one took 1.5 seconds but windows still took 13, so it seems to me that it's not the actual running of the tests that's taking the time!\r\n\r\nBoth machines are using the latest version of node and jest, and the linux is actually a VM running inside the Windows one using hyper-v, so other things being equal I would expect the Windows one to be faster.","> I only have around 20 tests and I've just taken some timings with jest --watch, both on the intial run and then pressing enter to re-run them.\r\n> \r\n> On Windows it took about 15 seconds both times whereas for linux it was around 5.3 seconds for the first run and 2.3 on subsequent runs.\r\n> \r\n> I tried using -t=\"GARBAGE\" to cause all the tests to be skipped. the linux one took 1.5 seconds but windows still took 13, so it seems to me that it's not the actual running of the tests that's taking the time!\r\n> \r\n> Both machines are using the latest version of node and jest, and the linux is actually a VM running inside the Windows one using hyper-v, so other things being equal I would expect the Windows one to be faster.\r\n\r\nYes. And if you mount the source codes to the linux VM from Windows and run the tests they get as slow as they are in Windows. This strongly implies that the problem is in Jest's file handling logic like I mentioned earlier.","> Yes. And if you mount the source codes to the linux VM from Windows and run the tests they get as slow as they are in Windows. This strongly implies that the problem is in Jest's file handling logic like I mentioned earlier.\r\n\r\nI noticed that while the tests are running the CPU is high but disk usage is not. It it was to do with blocking on file handles, I would expect it to be low CPU (unless jest is somehow in a tight loop waiting for handles to be released)\r\n\r\nI saw hevans90's comments on file watchers. I don't have any third-party anti-virus installed or similar installed, but disabling the Windows built-in real-time protection made no noticeable difference.\r\n\r\nhope this if of some help to anyone who has the time to try and debug it.","So I've confirmed today that Windows Defender makes a huge difference.\r\nI used to have a bunch of exclusion, but when I received my newer faster laptop, I couldn't for the life of me figure out why jest took >10 minutes to run a single file.\r\n\r\nThen I remembered exclusions.\r\nI can't tell exactly which exclusions make a difference, but I got the runner to go down to <15sec instead of >10mins\r\n\r\nI found a gist with relevant exclusions (albeit forceful)\r\nhttps:\/\/gist.github.com\/darvell\/edbc758b11ea4dcd7226b7c9f1821196\r\nI also added file extensions `.ts .js .spec.ts .spec.js .tsx`","> I can't tell exactly which exclusions make a difference, but I got the runner to go down to <15sec instead of >10mins\r\n\r\nhmm I just tried that and it didn't seem to make any difference to mine (mind you, mine wasn't taking minutes, so maybe we are experiencing different problems)","I always have exclusions in place anyway. And actually IntelliJ Idea automatically suggest placing workspace directory into exclusions and does that for you if you let it (you should). So in my case slowness is not due to Windows Defender or any other virus scanner.\r\n\r\nPerformance difference is 5-10x compared to a Mac. PC is a powerful desktop machine (read: **much** faster than the macbook). Everything else is lightning fast, just Jest is suffering from this issue.","any updates on this? ... i am experiencing the same thing, each test takes a long time to setup and loads but after the first one is loaded, it runs at a normal speed.....","Also having this issue. A single test file with a single, hello world test and it takes ~15 seconds to start up, plus another 12 seconds to run the test.","\ud83d\udc4b I see a few replies hinting that they're using typescript with jest - this might be worth looking into (if you're also using ts-jest): https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/908#issuecomment-484043250\r\n\r\nThe change for me was going from waiting 30 mins for jest (without a cache) to start to just a few seconds.\r\n\r\nBear in mind that setting the isolatedModules flag will result in no type-checking for your spec files (and the loss of some functionality): https:\/\/github.com\/kulshekhar\/ts-jest\/blob\/master\/docs\/user\/config\/isolatedModules.md\r\n\r\nI'm only posting this here as it might be useful to determine if your issue is with jest.","> \ud83d\udc4b I see a few replies hinting that they're using typescript with jest - this might be worth looking into (if you're also using ts-jest): [kulshekhar\/ts-jest#908 (comment)](https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/908#issuecomment-484043250)\r\n> \r\n> The change for me was going from waiting 30 mins for jest (without a cache) to start to just a few seconds.\r\n> \r\n> Bear in mind that setting the isolatedModules flag will result in no type-checking for your spec files (and the loss of some functionality): https:\/\/github.com\/kulshekhar\/ts-jest\/blob\/master\/docs\/user\/config\/isolatedModules.md\r\n> \r\n> I'm only posting this here as it might be useful to determine if your issue is with jest.\r\n\r\nPure JavaScript here. I have this issue so not related to TypeScript.","FYI: https:\/\/github.com\/kulshekhar\/ts-jest\/pull\/1549 will be in alpha version of ts-jest (possibly today). Anyone who is using ts-jest please help to test the alpha version and give us some feedbacks for https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/1115","> Also having this issue. A single test file with a single, hello world test and it takes ~15 seconds to start up, plus another 12 seconds to run the test.\r\n\r\nJust ran the same test on a Mac. It takes about 1.5secs to start, <1sec to run the test.\r\n\r\nAlso using JS, not TS here.","Pure JavaScript with Jest as well here. I have a powerful quad core laptop with intel's 10gen processors and everything else is blazing fast, but `jest@25.3.x` is taking 2-3 times more on Windows vs Linux to run some basic tests.","Same issue, about 60 seconds for my tests to run on windows, and no UI is displayed for the first 45 seconds or so. Ran the same exact test suite on my linux machine and it took 8 seconds to run to completion.\r\n\r\n@Cellule's comment above sped things up dramatically to around 15 seconds.","@ryanrapini followed @Cellule 's advice (but went through the `Windows UI > Virus and Threat Protection > Manage Settings > Add Exclusions`) and saw that some tests went from 13 seconds to 6, so basically half. Thanks!","Anyone wanna contribute a section mentioning Windows Defender (or AV in general?) on the FAQ page of the website? https:\/\/jestjs.io\/docs\/en\/troubleshooting","I can confirm that using `isolatedModules: true` with ts-jest made a HUGE difference on cold startup (~10mins => 15sec)\r\nI haven't tested their improvement in the alpha because I'm waiting on #9457 to be addressed before updating to jest 25","Hi all,\r\n\r\nSame problem here and no solution works for me...\r\n\r\nI run some very simple code on which I have currently  a few tests.\r\nIt's from the \"Advanced React Course\" of Wes Bo.\r\nHe runs it on Mac, and gets an immediate answer from his computer.\r\n\r\nAnd for me:\r\n\r\n> Test Suites: 2 skipped, 15 passed, 15 of 17 total\r\n> Tests:       6 skipped, 37 passed, 43 total\r\n> Snapshots:   18 passed, 18 total\r\n> Time:        5.869s\r\n> Ran all test suites.\r\n\r\n`isolatedModules: true` changes nothing in my case, I am still around 5-6 seconds.\r\nAnd when I start testing with any option, it takes 9~10 seconds.\r\n\r\nAdding my dev folder on the Defender Exceptions did nothing either:\r\n\r\n> Test Suites: 2 skipped, 15 passed, 15 of 17 total\r\n> Tests:       6 skipped, 37 passed, 43 total\r\n> Snapshots:   18 passed, 18 total\r\n> Time:        5.563s\r\n> Ran all test suites.\r\n\r\nIs there any good option on Windows ?\r\nDo I need to go for wsl2 ?\r\n","> Hi all,\r\n> \r\n> Same problem here and no solution works for me...\r\n> \r\n> I run some very simple code on which I have currently a few tests.\r\n> It's from the \"Advanced React Course\" of Wes Bo.\r\n> He runs it on Mac, and gets an immediate answer from his computer.\r\n> \r\n> And for me:\r\n> \r\n> > Test Suites: 2 skipped, 15 passed, 15 of 17 total\r\n> > Tests:       6 skipped, 37 passed, 43 total\r\n> > Snapshots:   18 passed, 18 total\r\n> > Time:        5.869s\r\n> > Ran all test suites.\r\n> \r\n> `isolatedModules: true` changes nothing in my case, I am still around 5-6 seconds.\r\n> And when I start testing with any option, it takes 9~10 seconds.\r\n> \r\n> Adding my dev folder on the Defender Exceptions did nothing either:\r\n> \r\n> > Test Suites: 2 skipped, 15 passed, 15 of 17 total\r\n> > Tests:       6 skipped, 37 passed, 43 total\r\n> > Snapshots:   18 passed, 18 total\r\n> > Time:        5.563s\r\n> > Ran all test suites.\r\n> \r\n> Is there any good option on Windows ?\r\n> Do I need to go for wsl2 ?\r\n\r\nCan you try to apply my solution and tell me if it does anything? (actually Cellule's solution, but I did it via the menu instead of running a script)","> Can you try to apply my solution and tell me if it does anything? (actually Cellule's solution, but I did it via the menu instead of running a script)\r\n\r\nAs I said in my message, I already did that :)\r\n\r\nI mean I followed what you did, via the menu and all.","I'm also having this issue on Windows. The test itself runs in <1 second but the overall setup takes ~15 secondes to execute. I've tried it with v24 and v26, it's actually a bit slower on v26\r\n\r\nI did not have luck with any of the following (it did not improve the execution time) :\r\n* adding `--runInBand`\r\n* setting `maxWorkers`\r\n* adding `.ts .js .spec.ts .spec.js .tsx` exclusions to `Virus and Threat Protection`, as suggested by @Cellule and @alessioalex \r\n\r\n","Same issue on Windows here with vanilla javascript as well as a fresh typescript project. 2 seconds to run 9 unit tests which run in <10ms using mocha.","This is crazy!\r\n\r\nSimply installed jest globally and now the exactly same project runs in 0.9s instead of 52(!!!) seconds!\r\n`npm remove jest` in the project, then\r\n`npm install -g jest`\r\n\r\nOf course I'd like to integrate jest as dev dependency into the project again. Any idea why that happens?","> This is crazy!\r\n> \r\n> Simply installed jest globally and now the exactly same project runs in 0.9s instead of 52(!!!) seconds!\r\n> `npm remove jest` in the project, then\r\n> `npm install -g jest`\r\n> \r\n> Of course I'd like to integrate jest as dev dependency into the project again. Any idea why that happens?\r\n\r\nThis most definitely sounds like a virus scanner issue to me. Meaning, your project directory is in the scope of virus scanning which slows down jest to a crawl but your global npm directory is not. This is just a guess though.","I've just tried the same thing as @JPustkuchen & the performance goes from ~10s to < 1 second.","I excluded my project folder from Windows Defender but Jest is still running slow.","I don't know if this is still being worked on, but I notice that when I do a typo in the code, the tests in watch mode instantly fail. Which leads me to the thought that it's not actually forcing a new directory crawl before compiling the test. Very simple tests are taking 10 seconds for me as well.","I would wish so much that someone would at least acknowledge this is a problem. As it is now, my windows desktop machine which has plenty of power (read: much more than my co-workers macbook) is approximately 69 times slower than the macbook when executing tests! This is practically forcing me not to touch the frontend code since it is so inefficient for me to work on those due to Jest tests running so slow. We might have to move away from Jest if this doesn't get fixed. Everything else is lightning fast but Jest tests are superduper slow. The time is spent on something else than actually executing the tests, when the actual test logic is executed those go really fast.","On a more positive note, I'd just like to say I owe this bug a great debt of gratitude. It was the final straw that made me decide to switch to Linux for my main development workflow and I've never been happier. I can't say I'd never go back because sometimes I have to work on legacy projects, but with ASP.NET core being cross-platform, the reasons for booting back into windows are becoming fewer all the time.","Please @timrobinson33 let's stay on topic. There is no reason `jest` should be 68 times slower than any other environment on Windows, considering Node works just fine on any platform. Also might I add, I have not experienced this problem with any other test runner.","I tested with v26.4.2 in my benchmark jest github repo.\r\nhttps:\/\/github.com\/nasreddineskandrani\/benchmark_jest\r\nnode version in my computer: v12.13.0\r\n\r\npretty fine when i update the simple test (see screenshot)! For me jest is now correct for a simple test.\r\nIf you have a problem at your job. You need to try to isolate the problem since by default it's fine.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1953635\/95027705-8ef94b80-0668-11eb-93b5-80dfc1336f26.png)\r\n\r\n@empperi can you try my benchmark repo. example with the v26 folder and tell me how long it takes to run this test in your machine? if it's not 0.166ms or around it you have an issue your side.","> I tested with v26.4.2 in my benchmark jest github repo.\r\n> https:\/\/github.com\/nasreddineskandrani\/benchmark_jest\r\n> node version in my computer: v12.13.0\r\n> \r\n> pretty fine when i update the simple test (see screenshot)! For me jest is now correct for a simple test.\r\n> If you have a problem at your job. You need to try to isolate the problem since by default it's fine.\r\n> \r\n> ![image](https:\/\/user-images.githubusercontent.com\/1953635\/95027705-8ef94b80-0668-11eb-93b5-80dfc1336f26.png)\r\n> \r\n> @empperi can you try my benchmark repo. example with the v26 folder and tell me how long it takes to run this test in your machine? if it's not 0.166ms or around it you have an issue your side.\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/2384816\/95043348-2ef4ba80-06e5-11eb-99a9-c531e1c68661.png)\r\n\r\nAs expected, no difference to your test setup performance. Runs actually bit faster than on your computer. Changed your test setup to contain 100 test files under `__tests__` and those too run fine. Since our app uses `react-scripts` I also added that to your example to check if that might cause the actual issue but no difference in performance.\r\n\r\nHOWEVER then I tried to run those tests in WSL2 bash (against NTFS filesystem) and boom, execution time nearly 10x to raw powershell. Slower I\/O speed is to be expected on WSL2 against NTFS but considering how simple this setup is (just 100 test files with single test on each one) it really shouldn't affect that much. For reference, I executed this on WSL2 bash:\r\n\r\n```\r\ntime find . -name \"*.js\" -print | xargs cat\r\n...(file content prints omitted)...\r\nreal    0m0.138s\r\nuser    0m0.030s\r\nsys     0m0.000s\r\n```\r\n\r\nWhich shows it takes practically no time at all to read the file system from WSL2. For reference similar command in Powershell:\r\n\r\n```\r\n> Measure-Command { ls *.js | % { cat $_ } }\r\n\r\nDays              : 0\r\nHours             : 0\r\nMinutes           : 0\r\nSeconds           : 0\r\nMilliseconds      : 49\r\nTicks             : 499000\r\nTotalDays         : 5,77546296296296E-07\r\nTotalHours        : 1,38611111111111E-05\r\nTotalMinutes      : 0,000831666666666667\r\nTotalSeconds      : 0,0499\r\nTotalMilliseconds : 49,9\r\n```\r\n\r\nWhich shows the performance is on the same ballpark.\r\n\r\nSo, based on this I would say the issue might be caused how Jest uses I\/O and that is somehow affecting the performance dramatically on WSL2. When it comes to the project that is causing me issues it is not a simple task to not require bash due to issues in code and tests (not done by me!). Considering the fact that WSL2 is gaining popularity I would say this is a real issue that should be looked into.\r\n\r\nHope this helps.\r\n\r\n:edit:\r\n\r\nJust out of curiosity I executed our test suite with `--no-watch` to see if watching the file system over WSL2 somehow affects things. The answer is no, it really doesn't affect that much.","Running the benchmark on my windows machine takes about 1.6s. I am not using WSL.\r\nI am using AVG antivirus, but have added exceptions for both the repository and node executable.\r\nMy harddrive is an SSD.\r\n\r\nNode version is `v12.16.1`\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/8037927\/95074553-097ca680-070f-11eb-82d3-5d23adefc5a6.png)\r\n\r\n\r\nUpdating the test instantly triggers the file watcher, but the actual time it takes to run that update is around 1s-2.4s.","I wanted to test if it's the environment being the issue.\r\n\r\nI was messing around with this repo: https:\/\/github.com\/kentcdodds\/react-testing-library-course\/tree\/tjs\r\n- I go for `npm test` and all the tests start running in watch mode.\r\n- I press 'p' to enter a pattern for a file and I type in \"tdd-02\". I get 3+ seconds execution time.\r\n![image](https:\/\/user-images.githubusercontent.com\/19570004\/95078654-279dd300-071e-11eb-89f8-fb90f6d65673.png)\r\n\r\nI'd be surprised if Kent C. Dodds has a messed up environment in his paid course, but if he does, you can debug it there probably :? In his videos, it runs just fine, I think he uses a Mac.\r\n\r\nI have to note something very strange that I can't reproduce again - I had some consecutive test reruns that for one of the files (tdd-02...js) executed for about 0.1s, and for the file next to it (tdd-01...js)- about 3s. The code is almost the same and uses the same dependencies. So, I copied the code from the fast-running file and pasted it to the slow-running one and vice versa. The results were the same - the slow-running file remained slow and the fast-running file remained fast, with the actual codes swapped. This is getting crazy. Now both files run slow again (3-6s).","@Glinkis can you try to hit enter after the first run is it still showin 1.6sec? (trigger a rerun)\r\n\r\n----------------------------------\r\n\r\n@SimeonRolev i'll take a look to the example you posted and see what kind of number i get with the same steps (pattern...)\r\nupdate: \r\ntry1: i tried it i as u and got 6sec when i tried your steps -> drop to 3sec on rerun the same test (hit enter)\r\ntry2: upgraded jest to 26.4 in Kent repo -> 3 sec first run near same for rerun\r\ntry3: I took `index.spec.js` file from my benchmark test repo. and i dropped it to Kent repo. (deleting all other test files) -> surprise 2.8sec (SAME JEST 26.4.2, SAME COMPUTER, POWERSHELL, NODE_VERSION etc... as my test yesterday posted here)\r\n![image](https:\/\/user-images.githubusercontent.com\/1953635\/95148053-719fac80-0750-11eb-81c2-2d32cd664297.png)\r\n\r\n**I don't understand this try3 still => ~3sec on rerun in Kent [repo ](https:\/\/github.com\/kentcdodds\/react-testing-library-course\/tree\/tjs)for my file but in my [repo ](https:\/\/github.com\/nasreddineskandrani\/benchmark_jest)it drops to 0.300s on rerun** (need someone to debug this)\r\nedit: Kent should be the one to check this :P \r\n\r\n","Pressing enter makes the test run in around 200ms.","@nasreddineskandrani Did you try it vice versa? I mean, copying the tests from the slow repo to yours? But I don't think the issue is with the repo that I posted. As we can clearly see, many people are having the same issue, I was just posting a reproducible example.\r\n\r\n@kentcdodds Will you be our hero one more time?","@SimeonRolev In my benchmark i dont see the same issue as in Kent repo. You have something in Kent Repo. that cause this slow => outside of it jest is faster.\r\n\r\nThis github issue is related to Jest performance windows vs macOS\/Linux since they didnt' reach same perf. they didnt clause it i guess. (its far better now than 2 years ago with jest v23)","Hello, I'm experiencing same issue in here. I have a windows machine and WSL. I copied my project files to WSL to test this behavior. Here are the runs of same two basic tests:\r\nWindows 10(Version 2004): \r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98786495-35c2cb80-240f-11eb-9300-634d4c99e79e.png)\r\nWSL 2(Ubuntu 20.04):\r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98786518-3fe4ca00-240f-11eb-8317-50c9fd18a9e5.png)\r\n\r\nThe tests are very simple:\r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98786553-4d9a4f80-240f-11eb-93d9-c9d8f54f8820.png)\r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98786570-5428c700-240f-11eb-9f8d-7b78ea4f879d.png)\r\n\r\nThe project is created with CRA, so there is no configuration to botch the settings, I added nothing in terms of Jest.\r\nThe same tests run blazingly fast on mocha, almost instantly. I'm trying to set up a testing environment for our project, and I would really like to use Jest, but it seems as I add more and more tests, the test suite will be slower and slower it seems. Each tests seems to be adding 0.8 seconds, which is ridiculous, since they do nothing. Something is messing with test execution on windows, and I don't know what.\r\nThe problem was worse, a single test would take around 15 seconds, but when I added --runInBand and , the situation seemed to improve a little bit, but I think it is still not enough, considering mocha watch mode is instant.\r\n\r\nYarn is version 1.22.5, all other npm dependencies(like react and react-scripts) are latest.\r\n\r\nI disabled the anti-virus and windows defender to see if it has any effect, but it doesn't. Also, I disabled indexing for my project folder, to no avail neither.\r\n\r\n\r\nEdit: I tried pressing enter, and the tests were as fast as on WSL:\r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98788699-57718200-2412-11eb-841b-67b54f5776d1.png)\r\n\r\nNow I'm really confused :)\r\n\r\nBut this seems still very slow, since it seems each test takes 0.3 seconds, which is a lot, considering they do nothing. I expect this suite to be completed under 0.1 seconds.\r\n\r\nEdit 2: When I added 100 tests to my test suite, it took around 44 seconds to run them, even if I press the enter to run them:\r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98797208-56921d80-241d-11eb-9ed7-f563a7dce52a.png)\r\n\r\nSame test suites takes around 9-10 seconds on WSL:\r\n![image](https:\/\/user-images.githubusercontent.com\/16986743\/98797302-71649200-241d-11eb-84f5-d260659bfcfb.png)\r\n\r\n","@fatihdogmus \r\nPlease! Share a github repo with your project. I'll test on my desktop. I want to see what number i get for the 102 tests (without WSL)","I realise this isn't addressing the actual performance issue, but I've found a work around that suits me.\r\n\r\nI've setup a devcontainer in VS Code - https:\/\/code.visualstudio.com\/docs\/languages\/typescript and the performance is much better.\r\nI put my source in in my home directory - `\/home\/<user>\/<app>`\r\n\r\nIt's important that the code is **not** in `\/mnt\/<drive letter>\/some\/path`, as the performance is much slower there.","@josh-barker that should be because `\/mnt` is NTFS until `\/home` is ext","Just chiming in to mention that @JPustkuchen's workaround is also working for me i.e. installing Jest _globally_: `npm install -g jest`. Speedup was significant: went from ~36 seconds to ~3 seconds in wall clock time.\r\n\r\n- For reference, I'm just testing the basic \"1 + 2 = 3\" test that's shown in the [Getting Started](https:\/\/jestjs.io\/docs\/getting-started) documentation.\r\n- I'm using Windows 10 Home, WSL v2, and Ubuntu 20.04 LTS.","Same here\r\n![image](https:\/\/user-images.githubusercontent.com\/63580042\/116968775-5a716f00-acdf-11eb-9933-85dafcd7b0a4.png)\r\n![image](https:\/\/user-images.githubusercontent.com\/63580042\/116968892-90aeee80-acdf-11eb-81bc-abfb07662f38.png)\r\n\r\njest version: 25.5.3\r\n","I also want to mention that @josh-barker's solution also seems to work in my case. So here's the present thinking: it seems that as long as Jest is installed under `\/home` and not under `\/mnt`, the performance is fixed.\r\n\r\nSo to summarize, the 2 main workarounds would basically be:\r\n\r\n1. Install Jest globally with `npm install -g jest` and use that instead of a local installation under `\/mnt`.\r\n2. Move the entire project under `\/home`, so that when you run `npm install jest`, it'll be installed under `\/home` as well.\r\n\r\nOnce again, for reference I'm using Windows 10 Home with WSL v2 and Ubuntu 20.04 LTS.","so, we all know that issue is stupid NTFS :D ","> so, we all know that issue is stupid NTFS :D \n\nI have to disagree even if I know you tried to be funny. No other runners suffer from this issue. So even if the issue would come from NTFS behavior it's still a Jest bug.\n\nThat being said, it might be due to difference in file handles. If Jest holds on to file handles too long it would slow down execution a lot.","Since 2019 still we don't have fix for this :( ","> Since 2019 still we don't have fix for this :(\r\n\r\nSo help fix it, this is an open source project. If you can't contribute code, help adding more details about the root causes.","> > Since 2019 still we don't have fix for this :(\r\n> \r\n> So help fix it, this is an open source project. If you can't contribute code, help adding more details about the root causes.\r\n\r\nWell i already added it up there.","> This is crazy!\r\n> \r\n> Simply installed jest globally and now the exactly same project runs in 0.9s instead of 52(!!!) seconds! `npm remove jest` in the project, then `npm install -g jest`\r\n> \r\n> Of course I'd like to integrate jest as dev dependency into the project again. Any idea why that happens?\r\n\r\nCan't figure out how to do this in CRA without ejecting. ","> Can't figure out how to do this in CRA without ejecting.\r\n\r\nSame for Vue CLI here.","Any solutions for WSL for super slow runtimes? Tried installing globally, didn't improve it","**Temporary workaround for WSL2 Users:** Install jest globally too (in addition to installing it as a dev dependency) and then use its binary's absolute path in the `package.json` file instead of only `jest`, e.g.: `\"test\": \"\/usr\/bin\/jest\",`. This will make it use the global jest binary instead of the one in the node_modules which *for some reasons* works 10 times faster.","> Any solutions for WSL for super slow runtimes? Tried installing globally, didn't improve it\r\n\r\ntried the npm global install and it didn't improve my issue.\r\nHowever ... copying the project from the \/mnt\/c\/etc... to \/home\/myproject resolved everything because there is no longer the NTFS issue. But that's just a second temp workaround (as i had to test a few things from ubuntu)","Does `Windows 10 and lower` in the title mean that it's not an issue on Windows 11 or has it just not been tested?\r\n\r\nI find this to be a breaking deal issue on my Windows 10 VM that runs on 4 Xeon 6148 cores, 40 tests take ~90 seconds there\r\n\r\nBut my Windows 11 12700k machine simply slashes through 5555 tests in 7 seconds.\r\nAnd I have the exact same results on both SATA SSD and HDD.\r\n![image](https:\/\/user-images.githubusercontent.com\/36513243\/154263295-011d0324-d8bb-4dce-98c3-8049c90a3ed5.png)\r\n\r\nI get that there's a huge CPU difference but it seems a bit too much to write off as just that.","It's the same slowness for me after upgrading to Windows 11.","Confirmed: using the same windows i7 laptop got the test running 2.5x to 3.5x faster in one of my contracts project with WSL2\r\n\r\n**For Windows:** use this video to setup **wsl2 in vscode**. You can also use wsl2 command line directly\r\nhttps:\/\/www.youtube.com\/watch?v=A0eqZujVfYU&ab_channel=ScottHanselman\r\n\r\nImportant: **clone your project in your ubuntu folder (not \/mnt)** do not keep it in windows partition* and resetup node git in wsl2 vscode ... \r\n","Just mentioning that this will indeed improve test runner performance with WSL when cloning into home folder, but it's not as fast as on native Linux (installed on bare metal, no VM or anything like that) and probably Mac. I ended up switching from Windows 10 to Linux in my client project. \r\n\r\nIf that's allowed in your project, I highly recommend, besides Linux is much faster in most cases and every day usage compared to Windows.","has anyone tried to migrate to **vitest** and had much faster tests on windows then?\r\n\r\nEDIT: Well I have just tried it and it's super fast! And it even has nice vscode plugin. I was struggling with jest for 2 days. But **vitest** looks like a good solution for my troubles. Migration was easy, as it's reusing the jest API. I only had to create a ridiculously small config file and run it.","moving everything completely to linux partition sped things up 100x times at least. Cheers for the tip!","Still a problem","Is there an answer for actual Windows usage here? I'm not interested in using Linux or a Linux VM.\r\n\r\nDoes anyone know the underlying issue here? Is this a problem with Node's use of filesystem APIs or is it Jest itself doing something wrong?","@Southclaws issue is slow NTFS so Windows is the issue","> @Southclaws issue is slow NTFS so Windows is the issue\r\n\r\nNo it is not. If this was the case then all test runners would be as slow. And gazillion other apps. But they are not. But you are partly right: it's a combination of how NTFS works and what Jest wants to do. But saying NTFS is slow is just being ignorant and directs the conversation to wrong direction which isn't in any way productive.","Yeah I'm not convinced it's \"jUsT a WiNdOwS iSsUe\" and I've not really seen compelling evidence to back up the whole NTFS claims over the years, unless there are some deep dives I can go read that actually dig into the technical details. I've not had issues with any other language or high-throughput applications I've worked on so it seems to be something specific to Jest - perhaps it's doing more I\/O operations than it needs to?\r\n\r\n> But saying NTFS is slow is just being ignorant and directs the conversation to wrong direction which isn't in any way productive.\r\n\r\n100%, I'm interested in tooling that works for everyone, not just some people's favourite computers.\r\n\r\nOne thing I did check was the 8dot3name status on this system was enabled so I've disabled that which supposedly speeds things up, it seems to have had a positive effect so far.","Has anyone tried performance on the new MS filesystem - [ReFS](https:\/\/learn.microsoft.com\/en-us\/windows-server\/storage\/refs\/refs-overview) ?\r\nCurrently available via a [DevDrive ](https:\/\/learn.microsoft.com\/en-us\/windows\/dev-drive\/) on Win 11 (insider preview) \r\n","![image](https:\/\/github.com\/jestjs\/jest\/assets\/20336040\/afde4b5b-b4f7-4c3b-b22e-905c436a5b30)\r\nMicrosoft Windows [10.0.22621.2428]\r\nnode v18.16.0\r\njest 29.7.0","> Does `Windows 10 and lower` in the title mean that it's not an issue on Windows 11 or has it just not been tested?\r\n> \r\n> I find this to be a breaking deal issue on my Windows 10 VM that runs on 4 Xeon 6148 cores, 40 tests take ~90 seconds there\r\n> \r\n> But my Windows 11 12700k machine simply slashes through 5555 tests in 7 seconds. And I have the exact same results on both SATA SSD and HDD. ![image](https:\/\/user-images.githubusercontent.com\/36513243\/154263295-011d0324-d8bb-4dce-98c3-8049c90a3ed5.png)\r\n> \r\n> I get that there's a huge CPU difference but it seems a bit too much to write off as just that.\r\n\r\nI get the same behavior on Windows 10 and 11. Same machine, same project, same configs. Oh well."],"labels":[":bug: Bug"]},{"title":"Using jest with node assert got wrong error type.","body":"## \ud83d\udc1b Bug Report\r\n\r\nThe assert module in nodejs will throw error when assertion fail. It will throw a AssertionError If the second parameter is a string. But if the second parameter is an instance of Error, it will throw it instead of AssertionError.\r\n\r\nI've tried this code and got the expected error.\r\n\r\n```js\r\nconst assert = require('assert');\r\nconst err = new Error('error message');\r\n\r\nassert.ok(false, err);\r\n```\r\n\r\nBut in my test case, i got an AssertionError.\r\n\r\n## To Reproduce\r\n\r\nYou may run this test case, it will fail:\r\n\r\n```js\r\nconst assert = require('assert');\r\nconst err = new Error('error message');\r\n\r\ntest('assert error object', () => {\r\n  expect(() => {\r\n    assert.ok(false, err);\r\n  }).toThrow(err);\r\n});\r\n```\r\n\r\nThe failed error message is:\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/1970625\/50416773-615d5c80-085d-11e9-9416-c88e2e8cf717.png)\r\n\r\n\r\n## Expected behavior\r\n\r\nPass the test case. I know i could use something like `.toThrow(err.message)` to pass it, but i want to check the error type also.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nJust run the case above. :)\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nPaste the results here:\r\n\r\n```bash\r\n  System:\r\n    OS: macOS 10.14.1\r\n    CPU: (8) x64 Intel(R) Core(TM) i7-4980HQ CPU @ 2.80GHz\r\n  Binaries:\r\n    Node: 11.5.0 - ~\/.nvm\/versions\/node\/v11.5.0\/bin\/node\r\n    npm: 6.4.1 - ~\/.nvm\/versions\/node\/v11.5.0\/bin\/npm\r\n  npmPackages:\r\n    jest: ^23.6.0 => 23.6.0\r\n```\r\n","comments":["This is weird. Running the snippet above behaves differently in node and through jest.\r\n\r\nI added `try-catch` just to make sure jest doesn't catch the error and format it.\r\n\r\n```js\r\nconst assert = require('assert');\r\nconst err = new Error('error message');\r\n\r\ntry {\r\n  assert.ok(false, err);\r\n} catch (e) {\r\n  console.log(e.stack);\r\n}\r\n```\r\n\r\nJest:\r\n```\r\n    AssertionError [ERR_ASSERTION]: Error: error message\r\n        at Object.ok (\/Users\/simen\/Development\/jest\/weird.test.js:5:10)\r\n        at Runtime._execModule (\/Users\/simen\/Development\/jest\/packages\/jest-runtime\/build\/index.js:709:13)\r\n        at Runtime.requireModule (\/Users\/simen\/Development\/jest\/packages\/jest-runtime\/build\/index.js:354:14)\r\n        at \/Users\/simen\/Development\/jest\/packages\/jest-jasmine2\/build\/index.js:199:13\r\n        at Generator.next (<anonymous>)\r\n        at asyncGeneratorStep (\/Users\/simen\/Development\/jest\/packages\/jest-jasmine2\/build\/index.js:27:24)\r\n        at _next (\/Users\/simen\/Development\/jest\/packages\/jest-jasmine2\/build\/index.js:47:9)\r\n        at \/Users\/simen\/Development\/jest\/packages\/jest-jasmine2\/build\/index.js:52:7\r\n        at new Promise (<anonymous>)\r\n        at \/Users\/simen\/Development\/jest\/packages\/jest-jasmine2\/build\/index.js:44:12\r\n```\r\n\r\nNode:\r\n```\r\nError: error message\r\n    at Object.<anonymous> (\/Users\/simen\/Development\/jest\/weird.test.js:2:13)\r\n    at Module._compile (internal\/modules\/cjs\/loader.js:688:30)\r\n    at Object.Module._extensions..js (internal\/modules\/cjs\/loader.js:699:10)\r\n    at Module.load (internal\/modules\/cjs\/loader.js:598:32)\r\n    at tryModuleLoad (internal\/modules\/cjs\/loader.js:537:12)\r\n    at Function.Module._load (internal\/modules\/cjs\/loader.js:529:3)\r\n    at Function.Module.runMain (internal\/modules\/cjs\/loader.js:741:12)\r\n    at startup (internal\/bootstrap\/node.js:285:19)\r\n    at bootstrapNodeJSCore (internal\/bootstrap\/node.js:739:3)\r\n```\r\n\r\n@thymikee @rickhanlonii any ideas?","IIRC we re-throw Node assert errors with custom AssertionError: https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-circus\/src\/formatNodeAssertErrors.js","Yeah, but that shouldn't happen when I catch it locally, unless we inject a fake `assert` module?","This is a use case for us to consider when deciding on a solution for #4724\r\n\r\nFor more info about the error class see: https:\/\/nodejs.org\/dist\/latest-v10.x\/docs\/api\/assert.html#assert_class_assert_assertionerror","I confirm this behavior.\r\n\r\nThis is a burden in one of our use cases as we use `assert` for tasks unrelated to unit testing. Jest having unexpected side effect on the `assert` lib wherever it is used makes it unreliable as a unit testing framework in our case.","I find it quite worrying that when I am running the code in the test environment it is being handled differently than it would in production. I should be able to rely on the fact my code will run the same in both environments otherwise the tests can't really be trusted.","Are there any news on this issue? I just ran into the same problem and I'd hate to write my own assert function just to work around a longstanding bug in Jest.","Same thing here, I'm using the node's assert function to do some assertions unrelated to unit testing and this behaviour causes the custom Error class to be substituted with the AssertionError. Because of this, all custom fields get lost.","Does anybody have a workaround for this problem ? (One that does not involve using a different assertion library in the base code)","It took me 30 minutes of googling just to find this thread. Why would the library override default `assert` and don't even mention it anywhere in the docs?",":+1: Also keen on a solution here.","https:\/\/www.npmjs.com\/package\/jest-localstorage-mock","Any news on that?\r\nIt has been quite a while.","same issue","This is a fairly significant issue with our codebase as we use `assert` to handle much of our data integrity checks. The errors that are provided with the second argument also encode much of our errors messaging within the server. With Jest or Expect seemingly re-throwing the error as an AssertionError, we no longer can properly test the what is valid and quite helpful code.","thanks jest. having to do this multiple times is very convenient \ud83d\udc4d\r\n![image_2023-08-29_161106386](https:\/\/github.com\/jestjs\/jest\/assets\/68304628\/4c7a88c3-37fe-49d4-a01a-eb5adad2965d)\r\n","@maybesmurf if you are really doing this all over the project, you should consider creating your own [custom matcher](https:\/\/jestjs.io\/docs\/expect#expectextendmatchers) that will do this unwrapping for you","posting in case anyone else stumbles on this, adding this mock to my test files fixes the issue but to other people's points it would be nice if this followed the NodeJS spec more closely.\r\n\r\n```ts\r\n\/\/ normally we would not need to mock nodejs internals but in this case Jest globals are incorrect\r\n\/\/ relevant github issue: https:\/\/github.com\/jestjs\/jest\/issues\/7547\r\njest.mock('assert', () => ({\r\n  __esModule: true,\r\n  default: (statement: unknown, err: Error) => {\r\n    if (!statement) {\r\n      throw err\r\n    }\r\n  }\r\n}))\r\n```"],"labels":[":bug: Bug"]},{"title":"[Circus] Add timeout event, and don't print both timeout and expect.assertions error ","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md in the root of the project if you have not done so. -->\r\n\r\n## Summary\r\n\r\nThis PR adds a new event for jest-circus called `test_fn_timeout` dispatched when a test times out.\r\n\r\nThis event will be fired in _addition_ to `test_fn_failure` (that choice is up for discussion)\r\n\r\n## Motivation\r\nThe motivation for this change is to fix https:\/\/github.com\/facebook\/jest\/issues\/3742\r\n\r\nWe do this by:\r\n- adding `test.expired` to `TestEntry`\r\n- set `test.expired = true` in the new `test_fn_timeout` hook\r\n - check that flag before printing expect.assertion errors\r\n\r\n## Test plan\r\n\r\nAdded e2e tests","comments":["There are a few ways to fix the bug but adding this event seemed to make the most sense -- if this doesn't fit into the vision of jest-circus I'll happily try a different strategy","@rickhanlonii possible to bring this over the line?","Oh wow I forgot about this. I won't have time to look at this until next year ","We'll make circus the default in 27, would be nice to include this","Would be nice to get out before the major as well, as it seems non-breaking, and then we can be confident we make a version of circus the default that has already been proven","AFAIK we can rebase and land this as-is?","@rickhanlonii I still like my feedback here https:\/\/github.com\/facebook\/jest\/pull\/7201#discussion_r226429090 but other than that I think so yeah \ud83d\ude00 "],"labels":["cla signed"]},{"title":"Simplifying configuration","body":"This is a bit rambling, sorry about that. Feel free to edit this to clean it up and add more to it.\r\n\r\nJest currently has 51(!!) configuration options, many of which overlaps or intentionally overrides other options. (CLI options are out of scope for this issue, but they are obviously very much related)\r\n\r\nThey fall into a few different categories:\r\n\r\n- file matching\r\n  - some are arrays, some are not.\r\n  - some are globs, some are regexes \r\n    - `collectCoverageFrom`\r\n    - `coveragePathIgnorePatterns`\r\n    - `forceCoverageMatch`\r\n    - `modulePathIgnorePatterns`\r\n    - `testMatch`\r\n    - `testPathIgnorePatterns`\r\n    - `testRegex`\r\n    - `transformIgnorePatterns`\r\n    - `unmockedModulePathPatterns`\r\n    - `watchPathIgnorePatterns`\r\n- modules and mocking\r\n  - confusing overlap with node's `require` api (node paths, extensions)\r\n    - `resetMocks` vs `clearMocks` vs `restoreMocks`\r\n    - `automock`\r\n    - `moduleDirectories` vs `modulePaths` (I honestly have no idea)\r\n- Coverage things\r\n  - reporters\r\n  - thresholds\r\n  - output directory\r\n- Setup files\r\n  - confusingly named, and inconsistent if they take array or string (#7119)\r\n- it keeps going (feel free to edit)\r\n\r\n---\r\n\r\nFirst of all, I'd like to simplify the file matching a lot. Both to make it easier to use, but also easier to implement and reason about.\r\n\r\nFor file matching I think `coveragePatterns: Array<Glob>`, `testPatterns: Array<Glob>`, `transformPatterns: Array<Glob>` and remove everything else. You can use negated patterns to exclude things instead of a `ignore` thing. No more `force` to override ignores.\r\n\r\nWe could also group things (using the current names, although they are subject to change):\r\n\r\n- `coverage` can have `collectCoverage`, `coverageDirectory`, `coverageReporters`, `coverageThresholds`, `collectCoverageFrom`\r\n- setup can have `globalSetup`, `setupTestFrameworkScriptFile`, `setupFiles`, `globalTeardown`.\r\n  - @palmerj3 had a cool idea about having just a single `setup` which exported different functions. Not as declarative, but maybe better?\r\n- `module` can have `automock`, `resolver`, `moduleDirectories`, `modulePaths`, `moduleNameMapper`, `moduleFileExtensions`, `resetModules`\r\n- `mocks` can have `resetMocks`, `clearMocks, `restoreMocks`, `timers` (`automock?`)\r\n- `snapshots` can have `snapshotSerializers`, `snapshotResolver`\r\n- `notify` and `notifyMode` can be combined (`true` is default mode, `string` sets the mode)\r\n\r\nAnother thing that's somewhat confusing is the difference between `ProjectConfig` and `GlobalConfig`. While the separation makes sense, it's invisible to users, and hard for them to reason about. It also doesn't work well with presets.\r\n\r\n---\r\n\r\nFinally, I leave you with this awesome article https:\/\/fishshell.com\/docs\/current\/design.html \ud83d\ude42\r\n\r\n>Every configuration option in a program is a place where the program is too stupid to figure out for itself what the user really wants, and should be considered a failure of both the program and the programmer who implemented it.","comments":["I completely agree we should rethink our configuration options, so thank you for collecting all this.\r\n\r\nSome comments:\r\n\r\n> For file matching I think coveragePatterns: Array<Glob>, testPatterns: Array<Glob>, transformPatterns: Array<Glob> and remove everything else. You can use negated patterns to exclude things instead of a ignore thing. No more force to override ignores.\r\n\r\nI think we should favor regular expressions over globs, as they're more expressive and anything that can be expressed as a glob can be as a regexp. I'd also keep the `ignore` versions as they're simpler than negated patterns.\r\n\r\n> We could also group things (using the current names, although they are subject to change):\r\n\r\nI'm not sure we should group configuration options in objects. I've usually found flat options easier to deal with and it aligns better with CLI options (e.g.: you could overwrite the `collectCoverageFrom` config option with a `--collectCoverageFrom` CLI option).\r\n",">I think we should favor regular expressions over globs, as they're more expressive and anything that can be expressed as a glob can be as a regexp.\r\n\r\nThe syntax is also way harder, though. I find globs more readable, and easier to write (as you can probably do `ls myglob` in the terminal to test, that's hardet with regex). Escaping globs are easier as well, I think.\r\n\r\n>I'd also keep the ignore versions as they're simpler than negated patterns.\r\n\r\nAs long as we allow an array of globs and apply them in order, it's easy enough to just include an `!`. Harder with regexes, though.\r\n\r\n>I'm not sure we should group configuration options in objects. I've usually found flat options easier to deal with and it aligns better with CLI options\r\n\r\nI agree on this one, at least depending on how yargs could handle deep objects. If you can do `coverage.pattern=blah` that's just as easy\/readable imo","> The syntax is also way harder, though. I find globs more readable, and easier to write (as you can probably do `ls myglob` in the terminal to test, that's hardet with regex). Escaping globs are easier as well, I think.\r\n\r\nAlso a fan of globs for file pattern matching. As long as you can pass arrays for all matchers, the limitations vs. regexp seem like not a big deal. \r\n\r\nAnother alternative (or addition) that would be great is just allowing any file pattern config to also accept `(file: string) => boolean` as its argument and let the consumer do whatever they want. \r\n","Glob arrays + functions seems like a nice compromise of ease-of-use vs power to me.","Passing a function could definitely work. Would it be inline, or point to some file that exports a function? Both?\r\n\r\nEdit: might be confusing that a string can be interpreted as a module, so I guess inline is the way to go","> Passing a function could definitely work. Would it be inline, or point to some file the exports a function? Both?\r\n\r\nIt should be a function because otherwise it'd have to be split in two different configuration options (we can't distinguish a string being a glob or a file containing the function).","> It should be a function because otherwise it'd have to be split in two different configuration options (we can't distinguish a string being a glob or a file containing the function).\r\n\r\nYes, this seem the most flexible since anyone is always free to just import their function.\r\n\r\nAnother related discussion here is that a some other config options require that something that's really just a function be implemented as an npm package, e.g. `resolver` `testResultsProcessor`, etc. \r\n\r\nI'd prefer just allowing config to accept a function for these; people can always implement it as a module themselves if they want to. But it's a lot more cruft to make a module, link it in `package.json`, etc for these things when I'd rather just import it directly where it's consumed.  \r\n","It's something from when config had to be in package.json. I'm all for saying \"use js config\". Presets should help keep boilerplate down and if that's an issue for people.\r\n\r\nWe also have to consider people passing stuff from the CLI, but I don't think that _too_ important for stuff that rarely change (like result processors, resolver, etc).\r\nThe use case of setting certain reporters etc on CI only is easily solved in js config by inspecting the env (or using `is-ci`)","I suppose you could overload again, and accept a string or an fn, where a string is always treated as an npm package? Specifying a reporter by npm package name on the CLI could be useful, though interestingly that can't be done now afaict ;)","You can do `jest --reporters jest-junit` today","This is absolutely stupendous. Thank you all for your work here! It's long been a point of confusion for me.","Resuggesting the above linked issue here: \r\n\r\nIdeally it would be very simple to configure Jest to use the same glob pattern that typescript uses to resolve paths.\r\n\r\nInitially I assumed it had that type of support, but discovered it's regex only [per this so question](https:\/\/stackoverflow.com\/questions\/52931465\/adding-a-module-mapper-to-jest\/52932614#52932614).\r\n\r\nIf this is supported users can use the same glob pattern in jest that they would use in typescript. \r\n\r\nI don't know about the rest of you, but I break out into a cold sweat any time RegEx is mentioned.\r\n\r\n","As part of this, I'd also like to use [`cosmiconfig`](https:\/\/github.com\/davidtheclark\/cosmiconfig) to load configuration from files. It'll both allow us to delete code to look for a configuration file, and it'll allow us to support a few more ways to provide config (we currently have `jest.config.js`, `.jestrc` and `jest` in `packages.json` - all of which are supported by cosmiconfig)","Reposting here at request of @SimenB : https:\/\/github.com\/facebook\/jest\/issues\/7757\r\n\r\nTL;DR: `jest.restoreAllMocks()` -> `jest.restoreAllSpies()`, and in config `restoreMocks` -> `restoreSpies` ","Would be nice to provide a way to specify reporter options (and possibly other things) from the CLI. See #7845\r\n\r\nEdit: Sorry, out of scope \ud83d\ude04 ","From OP:\r\n\r\n>CLI options are out of scope for this issue, but they are obviously very much related\r\n\r\nBut yeah, we should figure out a plan. I think as long as we really standardize on how to pass options (I like the `reporter:s [name, [name, options]]` pattern) it should be possible to figure out some relatively ergonomic way of doing it","> > Passing a function could definitely work. Would it be inline, or point to some file the exports a function? Both?\r\n> \r\n> It should be a function because otherwise it'd have to be split in two different configuration options (we can't distinguish a string being a glob or a file containing the function).\r\n\r\nOne issue with passing functions is that they might encapsulate some state (usually in the form of a closure). E.g.\r\n\r\n```js\r\n\/\/ jest.config.js\r\nconst myMatchingLibrary = require('my-matching-library');\r\n\r\nreturn {\r\n  testMatch: [(filename) => myMatchingLibrary.isTest(filename)]\r\n}\r\n```\r\n\r\nThe only way we could use functions would be to serialize them to string (using `.toString()` then `new Function` or something on the other side), and that would lose the reference to `myMatchingLibrary`.\r\n\r\nSo I think it would have to be a separate option like you mention.\r\n\r\nE.g. either `testMatch: Array<Glob>` _or_ `testMatchModule: require.resolve('.\/my-file-with-matching')`. It would be a hard error to specify both.\r\n\r\n`my-file-with-matching` could use an external module, a regex etc.","After quite a lot a bunch of debates internally here's the current status:\r\n\r\n- move all \"path\" options to be `Array<Glob>` type (and enable passing `RegExp` in JS configs, but don't encourage it)\r\n- remove all \"path ignore\" options\r\n- unify \"cache\"\/\"cacheDirectory\" and \"json\"\/\"outputFile\"\r\n- rename \"moduleLoader\" to \"runtime\"\r\n- rename \"browser\" to useBrowserField\"\r\n- rename \"extraGlobals\" to \"sandboxInjectedGlobals\"\r\n- remove \"testURL\" (can be set in \"testEnvironmentOptions\")\r\n- remove \"changedFilesWithAncestor\" (can be replaced with \"changeSince=HEAD^)\r\n- remove \"enabledTestsMap\" (use \"filter\" instead)\r\n- extract \"coverage\" \"debug\" \"reporters\" and \"watch\" to groups\r\n- using grouped options from CLI is TBD and it may vary, but something like `--debug.detectLeaks` should always be supported.\r\n\r\nThe new config format for the users would now look like this:\r\n\r\n```ts\r\ntype NewConfig = {\r\n  coverage: {\r\n    enabled?: boolean;\r\n    paths: Array<Glob>;\r\n    reportDirectory?: string;\r\n    reporters: Array<string>;\r\n    threshold?: {\r\n      global: {\r\n        [key: string]: number;\r\n      };\r\n    };\r\n  };\r\n  debug: {\r\n    detectLeaks?: boolean;\r\n    detectOpenHandles?: boolean;\r\n    logHeapUsage?: boolean;\r\n    listTests?: boolean;\r\n    errorOnDeprecated?: boolean;\r\n  };\r\n  reporters?: {\r\n    json?: boolean | Path; \/\/ merge with \"outputFile\"\r\n    list?: Array<string | ReporterConfig>;\r\n    testLocationInResults?: boolean;\r\n    testResultsProcessor?: string | null | undefined;\r\n    useStderr?: boolean;\r\n  };\r\n  watch: {\r\n    paths: Array<Path>;\r\n    enable?: boolean;\r\n    all?: boolean; \/\/ former \"watchAll\"\r\n    plugins?: Array<string | [string, Record<string, any>]>;\r\n  };\r\n  \/\/ mocks\r\n  automock?: boolean;\r\n  unmockedModulePathPatterns?: Array<string>;\r\n  timers?: 'real' | 'fake';\r\n  clearMocks?: boolean;\r\n  resetMocks?: boolean;\r\n  resetModules?: boolean;\r\n  restoreMocks?: boolean;\r\n  \/\/ resolve\r\n  useBrowserField?: boolean; \/\/ former \"browser\"\r\n  dependencyExtractor?: string;\r\n  moduleDirectories?: Array<string>;\r\n  moduleFileExtensions?: Array<string>;\r\n  moduleNameMapper?: {\r\n    [key: string]: string;\r\n  };\r\n  modulePaths?: Array<string>;\r\n  resolver?: Path | null | undefined;\r\n  roots?: Array<Path>;\r\n  snapshotResolver?: Path;\r\n  cache?: Path | boolean; \/\/ merge wtih \"cacheDirectory\"\r\n  projects?: Array<Glob | Project>;\r\n  testMatch?: Array<Glob>;\r\n  name?: string;\r\n  displayName?: string;\r\n  globalSetup?: string | null | undefined;\r\n  globalTeardown?: string | null | undefined;\r\n  \/\/ test environment\r\n  sandboxInjectedGlobals?: Array<string>; \/\/ former \"extraGlobals\"\r\n  globals?: ConfigGlobals;\r\n  runtime?: Path; \/\/ former \"moduleLoader\"\r\n  setupFiles?: Array<Path>;\r\n  setupFilesAfterEnv?: Array<Path>;\r\n  snapshotSerializers?: Array<Path>;\r\n  testEnvironment?: string;\r\n  testEnvironmentOptions?: Record<string, any>; \/\/ remove \"testURL\"\r\n  testRunner?: string;\r\n  \/\/ test filtering\r\n  filter?: Path | boolean;\r\n  skipFilter?: boolean;\r\n  findRelatedTests?: Array<Path>;\r\n  runTestsByPath?: boolean;\r\n  testNamePattern?: string;\r\n  preset?: string | null | undefined;\r\n  runner?: string;\r\n  transform?: Array<{\r\n    paths: Array<Path>;\r\n    options: Record<string, any>;\r\n    transformer: string | Path;\r\n  }>;\r\n  maxConcurrency?: number;\r\n\r\n  \/\/ runner - global\r\n  updateSnapshot?: boolean;\r\n  bail?: boolean | number;\r\n  expand?: boolean; \/\/ show full diff\r\n  noStackTrace?: boolean;\r\n  passWithNoTests?: boolean;\r\n  notify?: NotifyMode;\r\n  prettierPath?: string | null | undefined;\r\n  replname?: string | null | undefined;\r\n  rootDir: Path;\r\n  forceExit?: boolean;\r\n  testFailureExitCode?: string | number;\r\n  watchman?: boolean;\r\n  haste?: HasteConfig & {skipNodeResolution?: boolean};\r\n  \/\/ vcs - global\r\n  changedSince: string; \/\/ remove \"changedFilesWithAncestor\"\r\n  onlyChanged: boolean;\r\n  lastCommit?: boolean;\r\n};\r\n```\r\n\r\nWe're still trying to make more sense out of all the config options, but we feel this is pretty close to what we would like to achieve","i'm not sure if this falls exactly into _simplifying configuration_, but requiring projects to install prettier to use inline snapshots seems like an extra complication to configuration. if the Jest API needs prettier to work, that's a direct (if optional) dependency of Jest, not projects using jest as a test runner.","On globs vs. regexp: I've been repeatedly confused by the patterns in `test*` options, and [so have others](https:\/\/github.com\/facebook\/jest\/issues\/4637#issuecomment-341917182). Turned out we didn't know about `micromatch`. One way to eliminate the confusion would be to have options names specifically with a `RegExp` or `Glob` suffix.\r\n\r\nOn simplifying configurations: any thoughts on cascading\/extending\/inheriting hierarchical config files? Here's a [StackOverflow post](https:\/\/stackoverflow.com\/questions\/40726702\/is-there-anyway-to-extend-a-jest-configuration-file) requesting this feature.\r\n\r\nI think ESLint does a great job at this with [cascading configurations](https:\/\/eslint.org\/docs\/user-guide\/configuring#configuration-cascading-and-hierarchy). It's been very easy to use in monorepos: have an `.eslintrc` in the monorepo root with rules common to all projects, then in individual projects that need something different (e.g. `env: {\r\n    browser: false,\r\n    node: true\r\n  }` vs. the other way around), only add those rules to a project-level `.eslintrc`. I've :heart:ed this setup for a long while.","@dandv That also roughly echoes what Babel is moving towards, with one root `babel.config.js` and then `.babelrc` in folders that need configuration overrides.","Some random thoughts from a quick chat with @SimenB:\r\n* Should users `require.resolve` more things themselves? Would solve issues like overriding `babel-jest` version without making it a peer dependency that has to be installed explicitly. Not good for JSON config, but perhaps users who use more complex config are likely to use JS config anyway.\r\n  * Not so serious side note: For CLI usage, just `jest --transform $(node -p 'require.resolve(\"babel-jest\")')` :stuck_out_tongue_closed_eyes: \r\n* Is `<rootDir>` a good thing in JS config where you already have `path.resolve` etc like you use for e.g. webpack config? Probably wouldn't implement it today, instead just telling people to resolve it themselves, but we already have it and it works fine so idk. Plus it's still quite a bit shorter to write.\r\n* Would be great to somehow find out what percentage of users use which configuration method (at least on public gh or something), but I haven't dug that deep into the advanced search queries yet :smile: ","Totally agree, configuration should be simpler and it saves us from wasting time to decide right option to use (while they're same :D) e.g. testRegex vs. testMatch in [my last code review](https:\/\/github.com\/facebook\/jest\/issues\/9169#issuecomment-552792395)","Is there any reason to having both setupFiles and setupFilesAfterEnv? I cannot see any downside of only having setupFilesAfterEnv?","> Is there any reason to having both setupFiles and setupFilesAfterEnv? I cannot see any downside of only having setupFilesAfterEnv?\r\n\r\nI made a separate issue for this: https:\/\/github.com\/facebook\/jest\/issues\/9314","Curious, b\/c I don't see it here (maybe I'm blind?) but does this include simplifying\/clarifying the number of ways to make a mock or mock-like thing (automock, spyOn, jest.mock, \\_\\_mocks__, requireMock, jest.fn)?","Hey there! No, this is for https:\/\/jestjs.io\/docs\/en\/configuration and https:\/\/jestjs.io\/docs\/en\/cli, not anything else. The features you mention are more documentation issues, I think. ","I think the most confusing overlapping configuration options are the different setup options:\r\n\r\n- setupFiles\r\n- setupFilesAfterEnv\r\n- globalSetup\r\n- testEnvironment\r\n- And all the after -versions of above\r\n\r\nAll of these are a bit different flavour of essentially the same thing. What makes it especially difficult is that there's no clear explanation which is used for what purposes and when they are called, are they async or not and so on. And how they differ from each others. To me it looks that all of them have came when someone has needed a new place to setup something and was too afraid to change the existing logic.","I still want to do this at some point, but I'm not sure when I'll have the energy to take it on.\r\n\r\nCurrent plans for Jest and breaking changes are: V28 is right around the corner and will be filled with breaking changes., mostly minor or easy to tweak your code for. V29 will most probably only change `snapshotFormat` defaults and drop node 17 as its only breaking changes, to make the upgrade as smooth as possible (beyond having to regenerate _all_ snapshots (or change config to current options)). But maybe Jest v30 could be the big config overhaul? A boy can dream \ud83d\ude00 \r\n\r\nAnyways - my current thinking before I postpone my reminder yet again: My current thinking hasn't changed much from the OP for file matching (i.e. I'd like to go for just arrays of globs), but we can probably support a function in addition (note that since we run in workers, it would have to be a string pointing to a module exporting a function). I'm thinking they'd be mutually exclusive - either provide globs _or_ a custom function. We tested out doing _just_ globs when I visited FB a few years ago, and it didn't cover their use cases. So a function seems reasonable.\r\n\r\n---\r\n\r\n@villesau (you might know, but others reading might not)\r\n\r\n`setupFiles` before the test framework is loaded - typically where you do polyfilling\r\n`setupFilesAfterEnv` after the test framework is loaded - typically where you add custom matchers, setup spies\/stubs etc\r\n`globalSetup` runs once per project instead of once per test suite (file) - typically where you start a browser or db (and close it in `globalTeardown`)\r\n`testEnvironment` the thing that sandboxes and runs the code in tests\r\n\r\nThey all serve different purposes and cannot really be interchanged (except most `setupFiles` could be `setupFilesAfterEnv`, I guess). `testEnvironment` is for more advanced use cases (like exposing `puppeteer` instance or a db connection to tests, working around the sandbox) that most users won't need.\r\n\r\nThat said, we should probably document these better, and explain when to use which."],"labels":["Discussion"]},{"title":"Allow to share global state between tests from globalSetup","body":"## \ud83d\ude80 Feature Proposal\r\n\r\nAdd a `global` property to the `this` of globalSetup and globalTeardown async functions that can be used to set global variables that can be accessed in all tests via `global`. The same global is shared across all tests.\r\n\r\n## Motivation\r\n\r\nWhile jest was in the beginning used only for frontend testing, it has moved in the direction of becoming a general test framework. Especially for backend integration tests there is a tradeoff between test speed and departmentalization: Starting up a new backend instance for each individual test usually isn't feasible. Therefore most other test frameworks like mocha or jasmine provide possibilities to share state between tests, e. g. the backend instance. Usage examples include mocking http requests via [nock](https:\/\/github.com\/nock\/nock).\r\n\r\n## Example\r\n\r\nLet's assume an integration test that tests backend and database integration. The setup could look like this:\r\n```\r\nconst backend = require('backend')\r\n\r\nasync function setupApp () {\r\n  await new Promise((resolve, reject) => {\r\n    backend.start().then((instance) => {\r\n      this.global.backend = instance\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = setupApp\r\n```\r\nAnd using the global could be done like this:\r\n```\r\nconst request = require('supertest')\r\ntest('should call out to that fancy other api', () => {\r\n  request(jest.globals.backend.url)\r\n    .post('\/some-endpoint')\r\n    expect(200)\r\n})\r\n```\r\n\r\n## Pitch\r\n\r\nAs far as I know this change currently cannot be implemented outside of the main jest framework. Closest is an environment, but environments are sandboxed and do not share global state.\r\n\r\n## Open questions\r\n\r\n### How to best implement it?\r\n\r\nI don't know the jest code well enough to have an idea how to best implement this. It might e. g. be easier to make the global available via `global`, or even `jest.getGlobals()`.\r\n\r\n### Can we prevent misuse?\r\n\r\nSharing state between tests can lead to sideffects and random test breakage. One possible solution would be to make the `jest.globals` read-only, but I am not sure whether this is feasible without massively reducing which kind of objects can be stored.","comments":["First comments is that the setupfiles shouldn't assign to `this`. If we do this, I think the setup should `return` something, and we can assign that inside of jest itself (https:\/\/github.com\/facebook\/jest\/issues\/5731#issuecomment-385070715).\r\n\r\nAlso, I _think_ anything assigned will need to be serializable, I don't think it's technically possible for it to be e.g. an instance of something (we need to send it to workers which is a separate node process)","I took the `this` pattern from [environments](https:\/\/jestjs.io\/docs\/en\/configuration.html#testenvironment-string). It seemed a bit odd to me, too, but would be consistent.\r\n\r\nIf the object needs to be serializable, then unfortunately a lot of merit of this feature would be lost. My main usecase would indeed be using `nock` which attaches itself to its processes `http` module and therefore needs to be called in the same process as the one where the backend is running. It would be possible to set up some helper though I guess that communicates via serializable data. In that case we are talking more about inter-worker-communication then mere globals.","Yeah, the envs are the ones that construct the `global` used in tests, so it makes sense that they have it. Doesn't mean it's a nice pattern, though \ud83d\ude00 \r\n\r\nDue to a hole in the sandbox (we give you the real core and native modules) nock _should_ work. Note that it might break at any time, as that's a bug.","It should? Interesting, I'll give it another try. Last time I didn't get it to work. Basically what this feature proposal is about is providing a sanctioned way to do this.","I agree with @dbartholomae on this issue, I find it hard to recommend jest for all types of testing without the ability to share state between tests. I have a real usecase currently where the company I work for wanted to standardize our testing frameworks so I do to start using Jest over Mocha for my functional API testing for our react app. that was a mistake given that I have to fetch a new bearer token for every test file with no way of retaining that token to a variable \"globally\".","I also agree with this issue - my team is using Jest\/Supertest to test APIs for a microservice, and external service dependencies are faked using node\/http. The setup is fantastic other than we have to use `--runInBand` _always_ because we can't simply reuse external fake processes across tests, and it's not practical to test a single A microservice instance with various B and C dependency service instances running on random ports because each test is run in a separate process and can't access global node\/http fakes of B and C. I hope this helps illustrate the issue at a high level better.","My use case involves testing mobile devices with Appium. Without a global handle to the chromium webdriver (which connects to the device through the appium server and installs the app), each testfile must repeat this process of setup and teardown of the app. It adds up to 40 seconds for each testfile to go through this process. As it stands right now, I also have to --runInBand of course since otherwise the tests will all try to instantiate their own chromedriver connection at the same time. \r\n\r\nI have seen some really gross workarounds to this problem that abstract the various tests in each testfile into regular js functions, and then make you call all the functions inside a single shell test.js file that contains the describe\/it structure. I would really prefer not to do this since it breaks the ability to run a specific testfile on demand by passing the test as a CLI argument. :-(","Fans of this may like the newly opened `Feature Request` as seen right above :)\r\n\r\n> Allow module sandbox to be disabled via configuration https:\/\/github.com\/facebook\/jest\/issues\/8010","Just adding our use case: \r\n\r\nWe have an asynchronous initialization step that we need to do as a one time setup (and then expose the result to individual tests). The initialization is expensive and really should only happen once for the duration of the whole test run, but as it is, without runInBand, it's not possible.","it would be very useful for us as well","+1 here, there's some backend setup we'd like to share across all suites","Note that you'll never be able to share things that are not json-serializable as we have no way of passing that to workers. But sharing e.g. URLs to services will work whenever we get around to this. \r\n\r\nSo things like chromedriver connections talked about above cannot be supported. Puppeteer deals with this through exposing a websocket: https:\/\/github.com\/smooth-code\/jest-puppeteer\/blob\/master\/packages\/jest-environment-puppeteer\/src\/global.js","This is a deal breaker, something has to be done for sure. Most of these apps take 20secs or more to bootstrap and having that happen for 30 or 50 times (once for each test file) is a big no no. It should only happen once as stated above. Can't Jest pass state to it's child processes or something along those lines. It'd be ok if all test files could just access even the master worker's global state.","No, that's not how communication between processes work: https:\/\/nodejs.org\/api\/child_process.html#child_process_subprocess_send_message_sendhandle_options_callback\r\n\r\nIt's a bit better with worker_threads for builtin primitives, but not much: https:\/\/nodejs.org\/api\/worker_threads.html#worker_threads_port_postmessage_value_transferlist\r\n\r\n---\r\n\r\nThis isn't an API choice Jest has made, it's a fundamental technical limitation. Puppeteer allows connecting to a running instance through a websocket, you need to do something similar for whatever thing you're instantiating in a `globalSetup`.","can you give a working example please? Whatever workaround you have to pass around instances,  can't it be integrated into Jest or at least documented in Jest docs.","I don't know in how many ways I can say this, but I'll try one last time: you _cannot_ pass around instances, it's not possible.\r\n\r\nAnd seeing as this issue is still open, we have no solution for passing anything else either. `jest-puppeteer` adds the WS url to `process.env`, which works. When we fix this issue, they'll have an API they can use, which will be documented. We'll not be documenting hacks. The API will allow you to pass strings, numbers, objects and other primitives (not sure about regex, we'll see), but not instances\r\n\r\nPlease don't keep asking about things I've stated multiple times are not possible, or I'll have to lock this issue\r\n\r\n---\r\n\r\n>can you give a working example please?\r\n\r\nI recommend asking on [StackOverflow](https:\/\/stackoverflow.com\/questions\/tagged\/jest) or our [discord channel](https:\/\/discord.gg\/MWRhKCj) for help.","take puppeteer for example:\r\nhttps:\/\/jestjs.io\/docs\/en\/puppeteer.html\r\n```\r\nmodule.exports = {\r\n  globalSetup: '.\/setup.js',\r\n  globalTeardown: '.\/teardown.js',\r\n  testEnvironment: '.\/puppeteer_environment.js',\r\n};\r\n```","@SimenB would it be feasible to not use worker processes, given some flag?","Some problem,I need async get token before all tests running,but official docs say that\r\n\r\n>Note: Any global variables that are defined through globalSetup can only be read in globalTeardown. You cannot retrieve globals defined here in your test suites.\r\n\r\nSo I try use another way,custom **testEnvironment**,and It works.\r\n","@shengbeiniao that's for JSON-serializable stuff.\r\nThat's not what we're trying to achieve here.","Guys, I saw this and hope it can achieve what we are trying to do here. It's being used in VueJS as well for handling SSR stuff whilst passing almost anything around.\r\n\r\nhttps:\/\/www.npmjs.com\/package\/serialize-javascript\r\n\r\nCouldn't we use use this to serialize things and then unserialize for use later in scripts. Therefore sharing state across processes using globalstate that has that limitation.","Is NYC's `__coverage__` variable getting a free pass? I am able to get\/set to it inside tests.","Seeing that this issue is open might make a visitor think this is not possible. As mentioned by @SimenB it is. For many use cases, including mine, passing a string from `globalSetup` to the test suites was all that I needed.\r\n\r\nHere's a link to my project (see `rules-test\/tools\/guarded-session.js` especially): \r\nhttps:\/\/github.com\/akauppi\/GroundLevel-es6-firebase-web\/tree\/master\/rules-test\r\n\r\n>The API will allow you to pass strings, numbers, objects and other primitives (not sure about regex, we'll see), but not instances\r\n\r\nThat's good clarity. So I take there is no guarantee that the `process.env` will continue working, but there will be an API that does the same.","I think my desired use-case is probably not possible, but I figured I'd chime in here as well.\r\n\r\nI need to run integration tests with a server that is instantiated in-memory. That means I'm doing something like this:\r\n\r\n```js\r\nconst server = await startServer()\r\n```\r\n\r\nAnd then I need to use that `server` instance over a bunch of my tests files. To make matters worse, that particular `startServer` function takes about 5 to 10 seconds to startup (this is non-negotiable).\r\n\r\nIf instances cannot be passed around, then it sounds like I'm out of luck. But I would really love it if someone could tell me that I am wrong and that a solution is just around the corner.","My use case is ts-jest wants to pass an Object of file content cache to global to allow each worker to access and use it\r\n\r\nAt the moment each worker performs readFileSync to access this file content cache from disk.","So I'm trying to understand - most of this discussion is how to handle non-serializable items, but where did we leave off on allowing serializable items from globalSetup? \r\nI have a similar case with above where I am unable to set machine ENV variables on the fly through a script or other (whether during globalSetup, or outside it before running Jest). I would be attempting to store a serializable string as a global variable for my tests to achieve:\r\n- It is only initialized\/stored once\r\n- It is available to all tests\r\n\r\nThere's not a good solution currently for Jest as the `testEnvironment` config file runs multiple times (for every test file), but is able modify variables to be made available to all tests; `globalSetup` config file runs once as desired, but is unable to modify variables to be made available to all tests.","I have the same use case as @adrianmcli any info?","@adrianmcli @brianschardt \r\nIt looks like currently what we can do is something like the following if we want to avoid slow `startServer()` execution per test file\r\n```javascript\r\n\/\/ entrypoint.test.js\r\nbeforeAll(async () => {\r\n    global.server = await startServer();\r\n});\r\n\r\nimport '.\/tests\/my-first-test';\r\nimport '.\/tests\/my-second-test';\r\nimport '.\/tests\/other-test';\r\n```\r\n\r\n```javascript\r\n\/\/ .\/tests\/my-first-test.js\r\ntest('my test', () => {\r\n  expect(global.server.doSomeIntereaction()).toBe(...)\r\n})\r\n```\r\nOf course, this does not come with parallelization.\r\nProbably ideal solution would be launching `startServer()` as a separate process like `jest-puppeteer` does, but in that case I am not sure how we can easily swap mocked functions behind `startServer()` for each test case....","I think that #8708 would solve a bunch of problems people have that motivate this kind of state sharing. Instead of having to share something from the global setup down to the child processes, each of those child processes should (probably?) own one and only one of the resources. A puppeteer, a database connection, a booted server, etc, should be one per worker, not one global one per test run, and also not one per test file. That plays nicest with the automatic parallelization, keeps things fast, and I think is semantically sound with what Jest does already. Would that work for you folks and if so please thumbs up #8708! ","> Other resources like Kafka and ElasticSearch we use it in a multi-tenant fashion. \r\n> But to do so we must pass some information like connection string, admin credentials, unique run id for build parallelization on the same host etc.\r\n\r\nRight, that's already possible with `globalSetup` via the `process.env` hack described above. You can boot the global resource once in `globalSetup`, and then pass whatever string-serialized state is necessary down to the workers via `process.env`. That's not training wheels, that's a fundamental limitation of the parallelization Jest gives you, so I'm not sure what you mean by that. If the workers need some piece of state that is the same for each worker but different between them, like say a Kafka connection or an ElasticSearch connection locked to a namespace for that worker, you still need to boot that up per-worker. If you want to have workers be different tenants then they need to act differently, no? \r\n\r\nI think we can say there are many levels and contexts of setup:\r\n\r\n - per-invocation config (`globalSetup`, `globalTeardown`)\r\n - per-worker (not existent, see #8708)\r\n - per-suite (`setupFiles`, `setupFilesAfterEnv`, `beforeAll`, `afterAll`)\r\n - per-test (`beforeEach`, `afterEach`).\r\n\r\nThere is a process boundary between the per-invocation and per-worker layers that allows for parallelization and the Jest authors have said won't go away. That's the right move IMO. That means you can't ever pass real objects and especially not real open sockets down from the one top places to N inner places.\r\n\r\nWhat I am talking about is giving Jest users the ability to run setup once for the worker instead of once per suite. Connecting to ES or Redis or what have you once per suite isn't the end of the world, but for services that don't have multi-tenancy built in like puppeteer, or for app-land code that is expensive to boot, it'd be nice to do it once per worker instead of once per suite. Say creating kafka topics for the worker to use, or creating a Postgres database like `mycoolapp_test__${process.env.JEST_WORKER_ID}`. Right now that's not really possible, and I think it'd make managing these backend services a lot easier. \r\n\r\nI also think tearing down Kafka \/ ES from jest isn't the best idea -- teardowns are more best effort than gauranteed IMO. You can't really guarantee that the teardown runs because a dev could SIGTERM the process, or it could OOM, or whatever really. The best use of those backend services would be re-entrant and automatically massage whatever state is in them into the clean state necessary for the test.","For people that just want to pass primitives like strings from setup file to tests you can do that using environment variables\r\n```js\r\nprocess.env.FOO = 'bar'\r\n```\r\n\r\nBut yeah this is a serializable state.","Sharing global states is possible thanks to configuration's property [testEnvironment](https:\/\/jestjs.io\/docs\/en\/configuration#testenvironment-string)\r\nJust :\r\n- create your own class extending NodeEnvironment (documentation in link above includes an example)\r\n- in your overriding setup method, share the global values from 'global' to 'this.global'. Example :\r\n```\r\nasync setup() {\r\n   await super.setup();\r\n   \r\n   this.global.util = global.util;\r\n}\r\n```\r\n\r\nAnd voil\u00e0 !","@MarquonsDesCompetences-ThiB I didn't test it, but I think that the setup function is called for each test accordiing to the doc\r\n```\r\nNote: TestEnvironment is sandboxed. Each test suite will trigger setup\/teardown in their own TestEnvironment.\r\n```\r\nIn my case, I have two scripts to run tests\r\n  - the `test` one, that executes all the tests required in the `index.test.js` test file\r\n  - the `test-only` to execute test separately\r\n\r\n```javascript\r\n\/\/ package.json\r\n{\r\n  \/\/ ...\r\n  \"scripts\": {\r\n    \/\/ ...\r\n    \"test\": \"jest --forceExit --detectOpenHandles .\/tests\/index.test.js\",\r\n    \"test-only\": \"jest --forceExit --detectOpenHandles --runInBand\"\r\n  },\r\n  \"jest\": {\r\n    \"testPathIgnorePatterns\": [\r\n      \"\/node_modules\/\",\r\n      \".tmp\",\r\n      \".cache\"\r\n    ],\r\n    \"testEnvironment\": \"node\",\r\n    \"setupFilesAfterEnv\": [\r\n      \".\/tests\/helpers\/setup.js\"\r\n    ],\r\n    \"globals\": {\r\n      \"__APP__\": undefined\r\n    }\r\n  }\r\n  \/\/ ...\r\n}\r\n```\r\n\r\nin my setup.js, I setup the global app, for every test, so when I run the `yarn test` it'll be setup only one time, because every test is required there\r\n\r\n```javascript\r\n\/\/ tests\/helpers\/setup.js\r\n\r\nbeforeAll(async (done) => {\r\n    \/\/ setup the app\r\n  global.__APP__ = await setupMyApp();\r\n  done();\r\n});\r\n\r\nafterAll(async (done) => {\r\n  \/\/ teardown the app\r\n  await teardownMyApp()\r\n  global.__APP__ = undefined;\r\n  done()\r\n});\r\n\r\n\r\n```\r\n\r\n```javascript\r\n\/\/ tests\/index.test.js\r\n\r\nconst glob = require('glob');\r\nconst path = require('path');\r\n\r\nit('app is defined', () => {\r\n  expect(global.__APP__).toBeDefined();\r\n});\r\n\r\nglob.sync('.\/tests\/**\/*.test.js').forEach(function (file) {\r\n  require(path.resolve(file));\r\n});\r\n```\r\nIf I want to execute test suites in separate way, I use the `test-only` script, with the file I want to test as argument.\r\n","> @MarquonsDesCompetences-ThiB I didn't test it, but I think that the setup function is called for each test accordiing to the doc\r\n> \r\n> ```\r\n> Note: TestEnvironment is sandboxed. Each test suite will trigger setup\/teardown in their own TestEnvironment.\r\n> ```\r\n> \r\n> In my case, I have two scripts to run tests\r\n> \r\n> * the `test` one, that executes all the tests required in the `index.test.js` test file\r\n> * the `test-only` to execute test separately\r\n> \r\n> ```js\r\n> \/\/ package.json\r\n> {\r\n>   \/\/ ...\r\n>   \"scripts\": {\r\n>     \/\/ ...\r\n>     \"test\": \"jest --forceExit --detectOpenHandles .\/tests\/index.test.js\",\r\n>     \"test-only\": \"jest --forceExit --detectOpenHandles --runInBand\"\r\n>   },\r\n>   \"jest\": {\r\n>     \"testPathIgnorePatterns\": [\r\n>       \"\/node_modules\/\",\r\n>       \".tmp\",\r\n>       \".cache\"\r\n>     ],\r\n>     \"testEnvironment\": \"node\",\r\n>     \"setupFilesAfterEnv\": [\r\n>       \".\/tests\/helpers\/setup.js\"\r\n>     ],\r\n>     \"globals\": {\r\n>       \"__APP__\": undefined\r\n>     }\r\n>   }\r\n>   \/\/ ...\r\n> }\r\n> ```\r\n> \r\n> in my setup.js, I setup the global app, for every test, so when I run the `yarn test` it'll be setup only one time, because every test is required there\r\n> \r\n> ```js\r\n> \/\/ tests\/helpers\/setup.js\r\n> \r\n> beforeAll(async (done) => {\r\n>     \/\/ setup the app\r\n>   global.__APP__ = await setupMyApp();\r\n>   done();\r\n> });\r\n> \r\n> afterAll(async (done) => {\r\n>   \/\/ teardown the app\r\n>   await teardownMyApp()\r\n>   global.__APP__ = undefined;\r\n>   done()\r\n> });\r\n> ```\r\n> \r\n> ```js\r\n> \/\/ tests\/index.test.js\r\n> \r\n> const glob = require('glob');\r\n> const path = require('path');\r\n> \r\n> it('app is defined', () => {\r\n>   expect(global.__APP__).toBeDefined();\r\n> });\r\n> \r\n> glob.sync('.\/tests\/**\/*.test.js').forEach(function (file) {\r\n>   require(path.resolve(file));\r\n> });\r\n> ```\r\n> \r\n> If I want to execute test suites in separate way, I use the `test-only` script, with the file I want to test as argument.\r\n\r\nBut with all tests running under one test suite, you lose out on the ability to scale any integration tests with more than one database.  Now everything is lumped together instead of being completely isolated.",">Also, I think anything assigned will need to be serializable, I don't think it's technically possible for it to be e.g. an instance of something (we need to send it to workers which is a separate node process)\r\n\r\nI would kindly ask also `Date` objects to be automatically serialized.\r\n\r\nThe use case is about sharing a read only dataset (1..10kB) with tests. I'm currently pondering between temporary files  (yuck!) and environment variables. The size limits of env.vars keep me slightly concerned, and a standard mechanism provided by Jest would be preferred.","If somebody wants to try the expected behaviour please read [this comment](https:\/\/github.com\/facebook\/jest\/issues\/8708#issuecomment-1125399375).","Sharing functions as global variables would be awesome for e2e-testing with [prisma.io](https:\/\/www.prisma.io\/) as well. Right now each test has to establish a new database connection and prisma prints a warning that there are too many connections, as mentioned [here](https:\/\/github.com\/prisma\/prisma\/discussions\/4399)","I also am looking for this feature. We are trying to set up a singleton mongoMemoryServer instance (with individual dbs per test suite) but have not been able to get the mongo instance from globalSetup accessible in the environment setup.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","Remove stale label","Based on this thread, it appears that it should not be possible to use global variables in tests if those variables were set up in `globalSetup`. This weirdly works for me (with a caveat though). I'm seeing a behavior where I can set and access a variable (a db container instance) but the changes are 1-directional. Global variables set in globalSetup can be seen in the tests. However, if I attempt to modify those variables in the test, they won't be accessible in the globalTeardown. Could someone explain to me why this is happening by chance? \r\n\r\nBased on this thread this isn't the behavior one should expect to see, so I worry that I can't rely on my setup continuing to work. I've tried this both with --runInBand and without with the same behavior. I've tried setting global context by using `globalThis`, `process.env` and a variable at the top level of a shared file like in the example below. In all scenarios I'm seeing this 1-directional writing allowed.\r\n\r\n\r\nHere is some example code:\r\n```\r\njestGlobalSetup.ts:\r\n\r\nmodule.exports = async () => {\r\n    process.env.TESTCONTAINERS_RYUK_PRIVILEGED = 'true';\r\n    await startMysql();\r\n}\r\n...\r\nmysql.ts:\r\n\r\nlet runningContainer: StartedMySqlContainer | null;\r\n\r\nexport async function startMysql() {\r\n    if (!runningContainer) {\r\n        runningContainer = await new MySqlContainer().start();\r\n    }\r\n}\r\n\r\nexport function deleteMysqlVar() {\r\n    runningContainer = null;\r\n}\r\n\r\nexport async function stopMysql() {\r\n    if (runningContainer) {\r\n        await runningContainer.stop();\r\n    }\r\n}\r\n...\r\ntest.ts:\r\nbeforeAll(async ()=> {\r\n  \/\/ I would love to be able to start a single global MySQL instance from the beforeAll hook (instead of globalSetup) so\r\n  \/\/ that the DB is started only when it's needed. If I do this though, globalTeardown won't see the runningContainer\r\n  \/\/ variable in mysql.ts\r\n  \/\/ startMysql();\r\n));\r\n\r\ntest(\"test things\", async () {\r\n  \/\/ this works\r\n  runningContainer.executeQuery('SELECT DATABASE()');\r\n  \/\/ this won't do anything strangely from the perspective of globalTeardown - it will still see the runningContainer variable\r\n  deleteMysqlVar();\r\n})\r\n\r\n...\r\njest.config.js:\r\n\/** @type {import('ts-jest').JestConfigWithTsJest} *\/\r\nmodule.exports = {\r\n  preset: 'ts-jest',\r\n  testEnvironment: 'node',\r\n  globalSetup: \".\/test\/jestGlobalSetup.ts\",\r\n  globalTeardown: \".\/test\/jestGlobalTeardown.ts\",\r\n  maxWorkers: 2,\r\n};\r\n\r\n```","We have this working:\r\n\r\n```\r\n\r\nbeforeAll(async () => {\r\n  await server.start()\r\n})\r\n\r\nafterAll(async () => {\r\n  await server.stop()\r\n})\r\n\r\ndescribe('user', () => {\r\n\r\n  beforeAll(async () => {\r\n    \/\/ bring db into a certain stage\r\n  })\r\n\r\n  let token\r\n  describe('login', () => {\r\n\r\n    it('logs in with the correct password', async () => {\r\n\r\n      ...\r\n\r\n      token = res.body.user.token\r\n    })\r\n  })\r\n\r\n  describe('users', () => {\r\n    \/\/ use token\r\n```\r\n\r\nWe make sure the db is running before starting the tests and just start\/stop the server.\r\n\r\nIt's not particular great to have test dependencies if the runner isn't aware of them (as it will just error out where instead it should just not run tests) ... but surprisingly it's the work around we managed to live with for the past few years.\r\n\r\nHTH","One of the reasons I want to see this feature implemented is that in my tests, I require a module that takes some time to initialize due to its side effects, as exemplified [here](https:\/\/github.com\/paulmillr\/noble-secp256k1\/blob\/b032053763c0d4ba107c18fee28344f64242b075\/index.js#L156) (this is simple example but there are module that does intensive calculations to pre-calculate curves). When I run the application, this initialization is not a problem because the module initializes only once. However, in isolated test environments, requiring such a module consumes time in every test, even though it would be completely safe to share the initialization between them.\r\n\r\nI found an article how to use jest env to share cached module https:\/\/www.petecorey.com\/blog\/2018\/11\/05\/bending-jest-to-our-will-caching-modules-across-tests\/, but it works only inside same test file, because env initialize per file"],"labels":["Discussion",":rocket: Feature Request"]},{"title":"Inconsistent output with --coverage","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\udc1b Bug Report\r\n\r\nWhen code-covered files exist in the root directory, the `--coverage` output will include the name of the directory. This is not desirable in CI scenarios where the working directory will vary.\r\n\r\n## Actual\r\n\r\nhttps:\/\/github.com\/azz\/jest-istanbul-issue\/tree\/master\r\n\r\nWhen a file exists at root (above), the output is:\r\n\r\n```\r\n$ jest --coverage\r\n PASS  .\/index.test.js\r\n PASS  src\/file.test.js\r\n-------------------------|----------|----------|----------|----------|-------------------|\r\nFile                     |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n-------------------------|----------|----------|----------|----------|-------------------|\r\nAll files                |      100 |      100 |      100 |      100 |                   |\r\n jest-istanbul-issue     |      100 |      100 |      100 |      100 |                   |\r\n  index.js               |      100 |      100 |      100 |      100 |                   |\r\n jest-istanbul-issue\/src |      100 |      100 |      100 |      100 |                   |\r\n  file.js                |      100 |      100 |      100 |      100 |                   |\r\n-------------------------|----------|----------|----------|----------|-------------------|\r\n\r\nTest Suites: 2 passed, 2 total\r\nTests:       2 passed, 2 total\r\nSnapshots:   0 total\r\nTime:        1.983s\r\nRan all test suites.\r\nDone in 2.98s.\r\n```\r\n\r\nNote the `jest-istanbul-issue` above.\r\n\r\n## Expected\r\n\r\nhttps:\/\/github.com\/azz\/jest-istanbul-issue\/tree\/good-case\r\n\r\nWhen it doesn't:\r\n\r\n```\r\n$ jest --coverage\r\n PASS  src\/file.test.js\r\n  \u221a it works (1ms)\r\n\r\n----------|----------|----------|----------|----------|-------------------|\r\nFile      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\r\n----------|----------|----------|----------|----------|-------------------|\r\nAll files |      100 |      100 |      100 |      100 |                   |\r\n file.js  |      100 |      100 |      100 |      100 |                   |\r\n----------|----------|----------|----------|----------|-------------------|\r\nTest Suites: 1 passed, 1 total\r\nTests:       1 passed, 1 total\r\nSnapshots:   0 total\r\nTime:        1.708s\r\nRan all test suites.\r\nDone in 2.76s.\r\n```\r\n\r\n","comments":["IMO the second case should include `\/src` as well. So everything is always relative to the root of the project `rootDir`.","@bcoe could you help out here? Is it possible to change the base reporting directory? I found https:\/\/github.com\/gotwarlost\/istanbul\/blob\/bc84c315271a5dd4d39bcefc5925cfb61a3d174a\/lib\/util\/file-matcher.js, but setting a breakpoint in it doesn't seem to change anything.\r\n\r\nOur code: https:\/\/github.com\/facebook\/jest\/blob\/22f67d49ffcce7a5b6d6891438b837b3b26ba9db\/packages\/jest-cli\/src\/reporters\/coverage_reporter.js#L90-L104\r\n\r\nI tried this, makes no difference:\r\n\r\n```diff\r\ndiff --git i\/packages\/jest-cli\/src\/reporters\/coverage_reporter.js w\/packages\/jest-cli\/src\/reporters\/coverage_reporter.js\r\nindex 7d3fffe2a..9711378b5 100644\r\n--- i\/packages\/jest-cli\/src\/reporters\/coverage_reporter.js\r\n+++ w\/packages\/jest-cli\/src\/reporters\/coverage_reporter.js\r\n@@ -21,7 +21,7 @@ import type {Context} from 'types\/Context';\r\n import type {Test} from 'types\/TestRunner';\r\n \r\n import {clearLine, isInteractive} from 'jest-util';\r\n-import {createReporter} from 'istanbul-api';\r\n+import {config as istanbulConfig, createReporter} from 'istanbul-api';\r\n import chalk from 'chalk';\r\n import istanbulCoverage from 'istanbul-lib-coverage';\r\n import libSourceMaps from 'istanbul-lib-source-maps';\r\n@@ -87,7 +87,12 @@ export default class CoverageReporter extends BaseReporter {\r\n       this._coverageMap,\r\n     );\r\n \r\n-    const reporter = createReporter();\r\n+    \/\/ TODO: Figure out the common base of all of them\r\n+    const root = Array.from(contexts)[0].config.rootDir;\r\n+\r\n+    const cfg = istanbulConfig.loadFile(null, {instrumentation: {root}});\r\n+\r\n+    const reporter = createReporter(cfg);\r\n     try {\r\n       if (this._globalConfig.coverageDirectory) {\r\n         reporter.dir = this._globalConfig.coverageDirectory;\r\n```\r\n","The reporter is `text` and the printed [`name`](https:\/\/github.com\/istanbuljs\/istanbuljs\/blob\/master\/packages\/istanbul-reports\/lib\/text\/index.js#L180) make use of [`getRelativeName`](https:\/\/github.com\/istanbuljs\/istanbuljs\/blob\/ac36fbcaa4d6bf93af04b808866495bbf866a98d\/packages\/istanbul-lib-report\/lib\/summarizer-factory.js#L48).\r\nFrom reading in the implementation, this seems consistent with what is described in the issue (i.e. I don't believe there is a bug). The implementation of `getRelativeName` is referring to the parent level of the topmost name. Likely, this is an issue in the Istanbul reporter implementation and not in jest itself.\r\n","@coreyfarrell thoughts on this one?","Probably would make sense to report relative to the detected\/declared project root and also label that as \"Project Root\" instead of naming the FS directory.  That said it's been this way forever and people tend to be pretty sensitive to reporting changes so I'm not sure I'd want to change this in a semver-minor.  I'm otherwise occupied currently, it would help me if someone posted a bug to github.com\/istanbuljs\/istanbuljs\/ and link to this issue.","In my opinion I don\u2019t see this as a bug. The coverage will always report relative to the folder containing the topmost reported coverage, not related to the current working directory as initially reported. ","I agree it's not a bug in that it behaves as intended - I do think the behavior is not ideal, though.\r\n\r\nI think we should be able to set a root, and that all paths should be relative to that regardless of what istanbul considers \"top of the tree\". If I do `jest some-deep-test --coverage` that only covers a subtree of files, check html coverage, run some other test that makes the tree different, a refresh of the html report should not show me the old file just because istanbul found a file higher up in the FS (or 404 if we had a cleanup between runs).\r\n\r\nI can open up an issue tomorrow \ud83d\udc4d ","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","\ud83d\udc4b bringing this thread back to life, would happily take a patch to [istanbuljs\/istanbuljs](https:\/\/github.com\/istanbuljs\/istanbuljs) to make this configurable.","That'd be awesome! Do you have any pointers to where we would make changes so a `root` option (or something else, naming is hard) would go?","@SimenB I can dig a little bit tomorrow, I'm honestly not too sure.\r\n\r\nIf you could figure out how to provide a minimal example in a repo of behavior that has the wrong root, it would help me dig.","I would assume the repository in the OP still reproduces? Should update jest to latest to ensure we're using the latest versions of istanbul etc, but beyond that it should be fine?","@SimenB does the issue in `eslint-plugin-jest` serve as a reproduction?","probably not, not exactly minimal. Just updating the one in the OP to latest Jest should be enough tho (unless @bcoe wants a version without Jest at all)","I was able to reproduce this with the original repo after upgrading to jest v28.\r\n\r\nI've also been able to create a even smaller reproduction that doesn't use `jest` at all: https:\/\/github.com\/G-Rath\/jest-istanbul-repo\r\n\r\nIt has two coverage maps that were generated from the original reproduction repo just with no code in the `index.js` and `file.js` files to make the maps as small as possible - `coverage-map-one-file.json` is generated by running `jest file --coverage` and `coverage-map-two-file.json` is generated by running `jest --coverage`.\r\n\r\nIf you call `index.js coverage-map-one-file.json` it'll generate an html coverage report with this structure:\r\n\r\n```\r\ncoverage\r\n\u251c\u2500\u2500 base.css\r\n\u251c\u2500\u2500 block-navigation.js\r\n\u251c\u2500\u2500 favicon.png\r\n\u251c\u2500\u2500 file.js.html\r\n\u251c\u2500\u2500 index.html\r\n\u251c\u2500\u2500 prettify.css\r\n\u251c\u2500\u2500 prettify.js\r\n\u251c\u2500\u2500 sort-arrow-sprite.png\r\n\u2514\u2500\u2500 sorter.js\r\n\r\n0 directories, 9 files\r\n```\r\n\r\nIf you call `index.js coverage-map-two-file.json` it'll generate an html coverage report with this structure:\r\n\r\n```\r\ncoverage\r\n\u251c\u2500\u2500 base.css\r\n\u251c\u2500\u2500 block-navigation.js\r\n\u251c\u2500\u2500 favicon.png\r\n\u251c\u2500\u2500 index.html\r\n\u251c\u2500\u2500 index.js.html\r\n\u251c\u2500\u2500 prettify.css\r\n\u251c\u2500\u2500 prettify.js\r\n\u251c\u2500\u2500 sort-arrow-sprite.png\r\n\u251c\u2500\u2500 sorter.js\r\n\u2514\u2500\u2500 src\r\n    \u251c\u2500\u2500 file.js.html\r\n    \u2514\u2500\u2500 index.html\r\n\r\n1 directory, 11 files\r\n```\r\n\r\nThe desired behaviour (which this issue is about) is that both of these coverage reports should have `file.js.html` located in `src`.","Awesome! Yeah, or at least if passed some sort of `root` option. Would you mind filing an issue in the istanbul repo? Then whenever that's fixed, we can use that option (or update the version if it's made the default) and close this issue here \ud83d\ude42 "],"labels":[":rocket: Enhancement","Help Wanted","Pinned"]},{"title":"useFakeTimers breaks with native promise implementation","body":"## \ud83d\udc1b Bug Report\r\n\r\nUse the native Promise implementation breaks useFakeTimers\r\n\r\n## To Reproduce\r\n\r\nSteps to reproduce the behavior:\r\n\r\n```js\r\njest.useFakeTimers();\r\n\r\ntest('timing', () => {\r\n  Promise.resolve().then(() => console.log('promise'));\r\n  setTimeout(() => console.log('timer'), 100);\r\n  jest.runAllTimers();\r\n  console.log('end');\r\n});\r\n```\r\n\r\n## Expected behavior\r\n\r\nIt should log:\r\n\r\n - promise\r\n - timer\r\n - end\r\n\r\nThis is because `runAllTimers` should trigger the async promise handler first, then the timeout delayed by 100ms, then return control.\r\n\r\n## Actual Behaviour\r\n\r\n - timer\r\n - end\r\n - promise\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/repl.it\/repls\/PhysicalBriefCores\r\n","comments":["The workaround I've found is to add:\r\n\r\n```js\r\nglobal.Promise = require('promise');\r\n```\r\n\r\nto my setup.js","Hey @ForbesLindesay, thanks for filing and for the workaround \ud83d\udc4c \r\n\r\nIs this because native promises don't use timers under the hood like a library has to?","Fake timers in Jest does not fake promises (yet: #6876), however - as you discovered - if you use a polyfill for `Promise` that uses either `setImmediate` or `process.nextTick` as its implementation, it'll work. I think this is working as intended (for now)?","@SimenB that's my thought as well","I think you're right about *why* this doesn't work, but I don't think you're really right about this working as intended. Promises are a form of timer, and because in the past everyone was using polyfills, this used to work and only recently stopped working.","The fact people use promises differently isn't Jest's responsibility - it was never a feature of Jest that you could run Promises using its fake timers. As you've noted, polyfilling it with something that uses timers as its implementation makes it work again","> The fact people use promises differently\r\n\r\ni'm not clear on what you mean by this?\r\n\r\n>  it was never a feature of Jest that you could run Promises using its fake timers\r\n\r\nwhen fake timers were created, native Promises didn't exist. The intention was always that as new forms of \"timer\" were added to the language, fake timers would support them. For example, `setImmediate` is not a timer, but is supported. As you can see on https:\/\/repl.it\/repls\/PhysicalBriefCores\r\n\r\nThe goal of jest has, for a long time, included being easy to use and un-surprising. This is **very** surprising behaviour for fake timers to have.","I would like to expand on this issue since it gets amplified by uses of setTimeouts within the async code:\r\n\r\n```javascript\r\njest.useFakeTimers();\r\n\r\ntest('timing', async () => {\r\n  const shouldResolve = Promise.resolve()\r\n    .then(() => console.log('before-promise'))\r\n    .then(() => new Promise(r => setTimeout(r, 20)))\r\n    .then(() => console.log('after-promise'));\r\n\r\n  setTimeout(() => console.log('timer'), 100);\r\n  jest.runAllTimers();\r\n  await shouldResolve;\r\n  console.log('end');\r\n});\r\n```\r\n\r\n`Timeout - Async callback was not invoked within the 30000ms timeout specified by jest.setTimeout.`\r\n\r\nExpected: before-promise -> after-promise -> timer -> end\r\nActual:       timer -> before-promise -> Hangs\r\n\r\nThis issue here is there is nothing to continuously advance the timers once you're within the promise world. shouldResolve will never resolve. \r\n\r\nSwitching to `global.Promise = require('promise');` does seem like does the trick to resolve the issue for this particular use case. However in practice we have found the it does not work for all use-cases. \r\n\r\nThe best solution without replacing promises that i have come up for this is a utility function to continuouslyAdvanceTimers. However your results will still be out of order.\r\n\r\n```javascript\r\nconst _setTimeout = global.setTimeout;\r\nfunction continuouslyAdvanceTimers() {\r\n  let isCancelled = false;\r\n\r\n  async function advance() {\r\n    while (!isCancelled) {\r\n      jest.runOnlyPendingTimers();\r\n      await new Promise(r => _setTimeout(r, 1));\r\n    }\r\n  }\r\n\r\n  advance();\r\n  return () => {\r\n    isCancelled = true;\r\n  };\r\n}\r\n\r\njest.useFakeTimers();\r\n\r\ntest('timing', async () => {\r\n  const shouldResolve = Promise.resolve()\r\n    .then(() => console.log('before-promise'))\r\n    .then(() => new Promise(r => setTimeout(r, 20)))\r\n    .then(() => console.log('after-promise'));\r\n\r\n  setTimeout(() => console.log('timer'), 100);\r\n  const cancelAdvance = continuouslyAdvanceTimers();\r\n  await shouldResolve;\r\n  cancelAdvance();\r\n  console.log('end');\r\n});\r\n```\r\n\r\nExpected: before-promise -> after-promise -> timer -> end\r\nActual:      timer -> before-promise -> after-promise -> end\r\n","@KamalAman \r\n```javascript\r\ntest('timing', async () => {\r\n  const shouldResolve = Promise.resolve()\r\n    .then(() => console.log('before-promise'))\r\n    .then(() => new Promise(r => setTimeout(r, 20)))\r\n    .then(() => console.log('after-promise'));\r\n\r\n  setTimeout(() => console.log('timer'), 100);\r\n  await Promise.resolve()\r\n  jest.runAllTimers() \r\n  await shouldResolve\r\n  console.log('end');\r\n});\r\n```","I don't think there's any point adding to this issue. The problem is clearly stated and defined. All this needs is for one of the jest maintainers to acknowledge that this is **not** working as intended, then someone can submit a patch to fix it.\r\n\r\nIt would be good if the \"Needs more info\" tag could be removed, since this quite clearly doesn't need more info.\r\n\r\nPlease refrain from \"me-too\" style comments.","I love this issue, really. After one day sucking I found this and it works now. Miracle. Incredible that I **have to** do hacks like this to test an async functionality with a test framework that supports async.\r\n\r\nUPDATE. Example fix:\r\n```javascript\r\nwhile (!fixture.storageMock.update.mock.calls.length) {\r\n  await Promise.resolve();\r\n}\r\n```","Note that it is impossible, by JavaScript spec, for an `async function` to return anything other than native promises, so there's not anything we can do generically in Jest. This has to be solved in the engines themselves. You can do what #6876 documents (transpile everything), but that's not something Jest can decide to do for you.\r\n\r\nSee e.g. https:\/\/github.com\/petkaantonov\/bluebird\/issues\/1434 and https:\/\/github.com\/sinonjs\/lolex\/issues\/114. Your best bet is probably to follow the Lolex issue - both because Jest is going to move its fake timers implementation to be backed by Lolex, but also because Ben actually maintains Node, so any news on what would allow `async` functions to function (hah) correctly when faked is probably gonna be posted there.\r\n\r\nIf at some point there is a way to return custom Promise from async functions in Node, then we can look into adding APIs for it in Jest. Until then, we're _unlikely_ to do anything","For what it's worth, we have resorted to overwriting `window.setTimeout` when using a `setTimeout` in a promise chain:\r\n\r\n```es6\r\n\/\/ Place this in the test file\/test block when you want to immediately invoke\r\n\/\/ the callback to setTimeout\r\nwindow.setTimeout = (fn: () => void, _timeout: number): void => fn()\r\n```","Posting this work around in case it helps someone else:\r\n\r\n`await Promise.resolve().then(() => jest.advanceTimersByTime(milliseconds));`\r\n\r\n**More context here**: \r\nhttps:\/\/stackoverflow.com\/questions\/51126786\/jest-fake-timers-with-promises\/51132058#51132058\r\n\r\n**Broader example**:\r\n\r\n```ts\r\n  function sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      setTimeout(resolve, ms);\r\n    });\r\n  }\r\n\r\n  export async function foo(fn: () => T, waitMs: number): Promise<T> {\r\n     await sleep(waitMs);\r\n     return fn();\r\n  }\r\n```\r\n\r\n```ts\r\n  it('calls fn after x milliseconds', async () => {\r\n    jest.useFakeTimers();\r\n\r\n    const fn = jest.fn(() => 3);\r\n    const retVal = foo(fn, 1000);\r\n\r\n    expect(fn).not.toBeCalled();\r\n    await Promise.resolve().then(() => jest.advanceTimersByTime(1000));\r\n    expect(fn).toHaveBeenCalledTimes(1);\r\n    await expect(retVal).resolves.toBe(3);\r\n  });\r\n```\r\n","For those looking for the solution to this problem when using `jest.useFakeTimers(\"modern\");`\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/10221#issuecomment-654687396","Marked","Since `@sinon\/fake-timers` has async versions of all timer-advancing methods designed to also run microtasks (https:\/\/github.com\/sinonjs\/fake-timers\/pull\/237), could this functionality be exposed in jest to solve this issue?","@tatethurston I hate that this solution works, but it does. \ud83d\ude06  Thank you.\r\n","I read that mocking `nextTick` could be the problem? I tried `jest.useFakeTimers({ doNotFake: ['nextTick'] });` but that didn't solve this issue. I still don't get chained promises executed.","> ```js\r\n>  const cancelAdvance = continuouslyAdvanceTimers();\r\n> ```\r\n\r\nThanks, Simple and efficient","Thanks for this thread and [particular comment](https:\/\/github.com\/facebook\/jest\/issues\/7151#issuecomment-463370069) \u2764\ufe0f \r\nI also hate that it works, but it does :)\r\nAlso could be wrapped into helper function \ud83e\udd14 \r\n```javascript\r\nasync function withAllTimersRun(callback) {\r\n  const cancelAdvance = continuouslyAdvanceTimers();\r\n  const result = await callback();\r\n  await cancelAdvance();\r\n  return result;\r\n}\r\n```\r\n\r\nSo in tests it could be:\r\n\r\n```javascript\r\n\/\/...\r\nawait withAllTimersRun(() => someFunctionWithALotOfPromisesAndTimeouts());\r\n\/\/...\r\n```\r\n","> For what it's worth, we have resorted to overwriting `window.setTimeout` when using a `setTimeout` in a promise chain:\r\n> \r\n> ```js\r\n> \/\/ Place this in the test file\/test block when you want to immediately invoke\r\n> \/\/ the callback to setTimeout\r\n> window.setTimeout = (fn: () => void, _timeout: number): void => fn()\r\n> ```\r\n\r\nThanks for this information. When I used it with @KamalAman 's solution it worked perfectly.\r\n"],"labels":[":rocket: Feature Request"]},{"title":"Jest leaks memory from required modules with closures over imports","body":"## \ud83d\udc1b Bug Report\r\n\r\nWe are running into a issue in Jest 23.4.2 where Jest leaks and runs out of memory when running a moderately hefty test suite (~500 to 1000 test files). I believe I have isolated this to the `require` system in Jest and it is not the fault of other packages. Even with the most minimal recreation it leaks around 2-6MB per test.\r\n\r\nThis is very similar to https:\/\/github.com\/facebook\/jest\/issues\/6399 but I opted to make a new issue as I think it's not specific to packages or the node environment. I think it's the also the source or related to the following issues as well but didn't want to sidetrack potentially different issues and conversations.\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/6738\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/6751\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/5837\r\nhttps:\/\/github.com\/facebook\/jest\/issues\/2179\r\n\r\n\r\nThis is my first time digging into memory issues, so please forgive me if I am focusing on the wrong things!\r\n\r\n## Link to repl or repo\r\n\r\nI have created a very minimal reproduction here: https:\/\/github.com\/pk-nb\/jest-memory-leak-repro. You should be able to run and see heap grow and also debug it with the chrome node devtools. With the reproduction, we can see this happens in both `JSDOM` and `node` environments in Jest.\r\n\r\n<img width=\"530\" alt=\"screen shot 2018-08-07 at 7 43 02 pm\" src=\"https:\/\/user-images.githubusercontent.com\/1911028\/43808241-27d3ced2-9a7a-11e8-9da3-a35f9d7021f1.png\">\r\n<img width=\"229\" alt=\"screen shot 2018-08-07 at 6 49 44 pm\" src=\"https:\/\/user-images.githubusercontent.com\/1911028\/43808250-33c9e7d0-9a7a-11e8-8e86-70dba3a89188.png\">\r\n\r\n\r\n## To Reproduce\r\n\r\nSimply run a test suite with tests that require in a file that creates a closure over an imported variable:\r\n\r\n```js\r\n\/\/ sourceThatLeaks.js\r\n\r\nconst https = require('https');\r\n\r\nlet originalHttpsRequest = https.request;\r\n\r\nhttps.request = (options, cb) => {\r\n  return originalHttpsRequest.call(https, options, cb);\r\n};\r\n\r\n\/\/ If this is uncommented, the leak goes away!\r\n\/\/ originalHttpsRequest = null;\r\n```\r\n\r\n```js\r\n\/\/ 1.test.js, 2.test.js, ...\r\n\r\nrequire(\".\/sourceThatLeaks\");\r\n\r\nit(\"leaks memory\", () => {});\r\n```\r\n\r\nWhile every worker leaks memory and will eventually run out, it is easiest to see with `--runInBand`.\r\n\r\nNote that we are not doing anything with `require` to force a reimport\u2014this is a vanilla `require` in each test.\r\n\r\nWhen run with `jasmine`, we can see the issue go away as there is no custom `require` implementation for mocking code. We also see the issue disappear if we release the variable reference for GC by setting to `null`.\r\n\r\nI believe the closure is capturing the entire test context (which also includes other imports like `jest-snapshots`) which quickly adds up. \r\n\r\n## Expected behavior\r\n\r\nHoping to fix so there is no leak. This unfortunately is preventing us from moving to Jest as we cannot run the suite on our memory bound CI (even with multiple workers to try to spread the leak).\r\n\r\nI'm hoping the reproduction is useful\u2014I spent some time trying to fix with some basic guesses at closures but ultimately am in over my head with the codebase.\r\n\r\nYou can see the huge closure in the memory analysis so I'm inclined to think it's some closure capture over the `require` implementation and\/or the jasmine async function (promise).\r\n\r\n<img width=\"1390\" alt=\"screen shot 2018-08-07 at 6 52 50 pm\" src=\"https:\/\/user-images.githubusercontent.com\/1911028\/43808369-b6e2637c-9a7a-11e8-983c-5e3c8f93ebd2.png\">\r\n\r\n<img width=\"1504\" alt=\"screen shot 2018-08-07 at 4 45 32 pm\" src=\"https:\/\/user-images.githubusercontent.com\/1911028\/43808530-7f15111e-9a7b-11e8-993b-dca4eb5c8cc8.png\">\r\n\r\n\r\n<img width=\"1390\" alt=\"screen shot 2018-08-07 at 7 13 23 pm\" src=\"https:\/\/user-images.githubusercontent.com\/1911028\/43808376-bdeaafda-9a7a-11e8-9a19-b1940ecb664b.png\">\r\n\r\nSome leak suspects:\r\n\r\n* [Closures (section 4)](https:\/\/auth0.com\/blog\/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them\/)\r\n    * Wondering if this or other similar code in here is a closure capture that V8 can't break https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-runtime\/src\/index.js#L589-L591\r\n* [Promises (async generator) leaking](https:\/\/github.com\/nodejs\/node\/issues\/6673)\r\n    * Wondering if the promise \/ asyncToGenerator babel is capturing scope with the `next`, preventing it from releasing? https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-runner\/src\/run_test.js#L218-L220\r\n* [Global data (section 1)](https:\/\/auth0.com\/blog\/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them\/)\r\n    * Capturing too much with the global console? https:\/\/github.com\/facebook\/jest\/blob\/master\/packages\/jest-runner\/src\/run_test.js#L108\r\n* All of the above?\r\n\r\nThese are educated guesses, but there are quite a few closures within the runtime \/ runner \/ jasmine packages though so it's very difficult (as least for me being new to the codebase) to pinpoint where the capture lies. I'm hoping that there's a specific point and that each closure in the runtime would not present the same issue.\r\n\r\n\r\n## Our suite\r\n\r\nI have ensured the issue stems from Jest and not our suite\u2014I ran the old suite (mocha) and saw a healthy sawtooth usage of heap.\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\n```bash\r\n\u25b2 npx envinfo --preset jest\r\nnpx: installed 1 in 2.206s\r\n\r\n  System:\r\n    OS: macOS High Sierra 10.13.6\r\n    CPU: x64 Intel(R) Core(TM) i9-8950HK CPU @ 2.90GHz\r\n  Binaries:\r\n    Node: 8.11.3 - ~\/.nodenv\/versions\/8.11.3\/bin\/node\r\n    Yarn: 1.9.4 - ~\/.nodenv\/versions\/8.11.3\/bin\/yarn\r\n    npm: 5.6.0 - ~\/.nodenv\/versions\/8.11.3\/bin\/npm\r\n  npmPackages:\r\n    jest: ^23.4.2 => 23.4.2\r\n```\r\n\r\nPlease let me know if I can help in any way! I'd really love to get our company on Jest and am happy to help where I can. Thanks @lev-kazakov for the original isolation repro.","comments":["@mjesun i think that's it. i ran into the same issue when updating jest internally at facebook","Wow, that's an **awesome report**, @pk-nb! @aaronabramov can we use `--detectLeaks` against Jest and bisect to the commit?","I'm not sure I follow this repro. You're doing this:\r\n\r\n```\r\n\/\/ sourceThatLeaks.js\r\n\r\nconst https = require('https');\r\n\r\nlet originalHttpsRequest = https.request;\r\n\r\nhttps.request = (options, cb) => {\r\n  return originalHttpsRequest.call(https, options, cb);\r\n};\r\n\r\n\/\/ If this is uncommented, the leak goes away!\r\n\/\/ originalHttpsRequest = null;\r\n```\r\n\r\nIt seems expected to have a leak, since you patch `https.request`, but never reset it. When I look from within Jest, the `https` module returned seems to be the actual one, not a mock, so each time this code is executed, the previous patch is repatched, causing the memory to grow more and more, the patches never getting released.\r\n\r\nWhen I look with Jasmine, the memory does go up too, just much slower for two reasons:\r\n\r\n- First, the `sourceThatLeaks.js` file is only executed once. I guess it's because Jasmine caches its export, meaning that the `https` patching only ever occurs once. You need to copy the file content into each file in order to have the same behavior than on Jest.\r\n\r\n- The http patch itself doesn't seem to require a lot of memory. To see the leak, you can allocate a huge buffer (such as a 100MiB buffer), use it inside the closure, and monitor `external` instead of `heapUsed`. You'll notice that in this case, the memory keeps growing. This is expected, since you never remove the hooks you setup on http.\r\n\r\nI also tried your code on 23.0.0, and it seems to also reproduce the behavior, suggesting it always worked this way. Am I missing something?","Hi @arcanis \u2014thanks for taking the time to look at this.\r\n\r\nI will certainly admit the example given is not great code, but is an example of dependencies found in the wild that aim to mock or extend, including [graceful-fs](https:\/\/github.com\/isaacs\/node-graceful-fs\/blob\/9ef21483f8ddfdb96bfc6e2855ecb49ede57681f\/graceful-fs.js#L36-L54), [node-agent](https:\/\/github.com\/TooTallNate\/node-agent-base\/blob\/f892f87a6cb98137c10e14e40d914575e7f9c502\/patch-core.js#L11-L37), and [supertest](https:\/\/github.com\/visionmedia\/supertest\/blob\/master\/lib\/agent.js#L49-L64). I assume there are quite a few packages like this in the wild. We are just porting to Jest now and not comparing this to previous versions of Jest\u2014I'm not sure what version @aaronabramov is updating from.\r\n\r\nWhat's interesting is that I could not repro with the buffer suggestion you posted. Even though it is in the closure, it is being released in a sawtooth.\r\n\r\n```js\r\nconst https = require('https');\r\n\r\nlet buffer = Buffer.alloc(1000000000)\r\n\r\nhttps.request = (options, cb) => {\r\n  console.log(buffer.byteOffset, nodeBuffer.length);\r\n  return cb(buffer.byteOffset);\r\n};\r\n```\r\n\r\n<img width=\"583\" alt=\"screen shot 2018-08-13 at 12 54 02 pm\" src=\"https:\/\/user-images.githubusercontent.com\/1911028\/44046556-cb471c44-9ef9-11e8-94c3-bbb8baf9c4c9.png\">\r\n\r\nI updated suite 01 and 03 in this repro branch if you want to check. https:\/\/github.com\/pk-nb\/jest-memory-leak-repro\/tree\/external-buffer. I'm not sure why this would happen\u2014maybe v8 can be more intelligent with optimizing out the call or something.\r\n\r\n\r\nIgnoring the buffer\u2014with respect, I think the Jest require system should aim to support all of the node require ecosystem, including these \"singleton\" packages that assume a require cache. I imaging this is tricky with the separate Jest environments but hopefully could be supported by cleaning \/ flushing the requires in Jest. Otherwise the above node packages end up unusable in Jest.\r\n\r\n","We tried getting rid of the leak of modifying global objects in #4970, but that caused massive failures. Node has a very particular process of booting up, which includes a stateful ping-pong between the JS and the Native side, which made this impossible.\r\n\r\nThat said, as per @aaronabramov's comment, we know we've recently introduced a leak somewhere else too.","Thanks for the context @mjesun, didn't realize this had been attempted before. For anyone checking on the issue, here's the revert PR https:\/\/github.com\/facebook\/jest\/pull\/5009.\r\n\r\nMaybe an obvious \/ bad idea, but could we simply replace the core module objects following each test to release any global modifications? \r\n\r\nSomething like:\r\n\r\n```js\r\ncoreModules.forEach(() => delete require.cache[key])\r\n```\r\n\r\nThis in addition to setting all custom requires to `null` after a test. Not sure if the core modules have special handling that makes the cache invalidation not work. It's probably more complicated judging from that PR though.\r\n","> What's interesting is that I could not repro with the buffer suggestion you posted. Even though it is in the closure, it is being released in a sawtooth.\r\n\r\nBecause in this new code you're always replacing the previous hook:\r\n\r\n```js\r\nhttps.request = (options, cb) => {\r\n  console.log(buffer.byteOffset, nodeBuffer.length);\r\n  return cb(buffer.byteOffset);\r\n};\r\n```\r\n\r\nSince you overwrite `https.request`, the previous function gets garbage collected, and since the previous function gets garbage collected, the buffer it used gets released. To validate my theory I used a code similar to this:\r\n\r\n```js\r\nlet originalHttpsRequest = https.request;\r\nlet buffer = new Buffer(1024 ** 3);\r\n\r\nhttps.request = (... args) => {\r\n  return originalHttpsRequest.call(... args, buffer);\r\n};\r\n```","Thank you for taking care of the problem. Here's my [repo](https:\/\/github.com\/siluri\/fs.readfile-memory-leak.jest\/) on bug #6738 , I hope it helps to recreate the problem. ","Wanted to leave an update\u2014we found our accidental capture of `http` from the nock package. We accidentally were only calling `cleanAll`, which does not release the [http modifications like `nock.restore` does](https:\/\/github.com\/nock\/nock#restoring). Calling this allowed our test suite to release the full set of requires in each suite (a lot of memory each suite).\r\n\r\nI can close this if you'd like as this was a user issue (I hope this is a good google reference for others who made the same mistake we did). It's still a bummer that libraries that don't have a mechanism for releasing global modifications will be a blocker for others. I'm not sure what is actionable by Jest outside of moving to a environment reset per test suite (maybe by resetting \/ reimporting all built in modules?) or running in separate threads so that leaks can't continue.","We have the same issue with graceful-fs not releasing fs. It would indeed be awesome tom somehow force drop or at least flag it when stuff like this happens","@pk-nb do u have a workaround for that?","Facing the same issue with `fs-extra`, waiting for a good workaround\/fix. Meanwhile downgrading to native `fs` module in problematic places.","Seeing that graceful-fs fixed this in 4.1.12, is it somehow possible to roll out a hotfix for jest < 24.x as this is preventing my company from transitioning our test suite to jest from jasmine.","We use `graceful-fs@^4.1.11`. `4.1.12` is in semver range of that, so you just need to clean install jest.","BTW, can anybody confirm if this indeed fixes the issue and we can close it?","@thymikee Thank you for the quick answer. Sadly it appears to not fix the issue. After ~1000 tests I start maxing out my remaining RAM which is about 10 - 12 GB. The trend of ever-increasing memory-usage is strictly linear which should be further proof that this is not a memory leak on the tests end.","I'm pretty sure jest itself doesn't leak. Do you have some setup\/teardown you run for every single test? Or are you able to put together a reproduction?","It is an Angular project, so in most of the test files I use the TestBed to configure my testing module. Other than that we don't use any setup\/teardown. Am I potentially not respecting any special rules for Angular unit tests with Jest?\r\n\r\n```\r\ndescribe('TestComponent', () => {\r\n  let component: TestComponent;\r\n  let fixture: ComponentFixture<TestComponent>;\r\n\r\n  beforeEach(() => {\r\n    const testHandlerStub = {};\r\n    TestBed.configureTestingModule({\r\n      imports: [TestingModule, StoreModule.forRoot(store)],\r\n      declarations: [TestComponent],\r\n      schemas: [NO_ERRORS_SCHEMA],\r\n      providers: [{ provide: TestHandler, useValue: testHandlerStub }],\r\n    });\r\n    fixture = TestBed.createComponent(TestComponent);\r\n    component = fixture.componentInstance;\r\n  });\r\n\r\n  it('can load instance', () => {\r\n    expect(component).toBeDefined();\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  describe('ngOnInit()', () => {\r\n    it('triggers initializing', () => {\r\n      const spy: any = spyOn(component.handler, 'init');\r\n      component.ngOnInit();\r\n\r\n      expect(spy).toHaveBeenCalled();\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nMost (70%) of our tests look somewhat like this.","@markonyango any non-native node module which decorates a native module will leak in `jest`.\r\nsee https:\/\/github.com\/facebook\/jest\/issues\/6399#issuecomment-415083479 for details.\r\n`graceful-fs` and `agent-base` are 2 common libraries that do such things.\r\ni've created [jest-leak-fixer](https:\/\/github.com\/lev-kazakov\/jest-leak-fixer) some while ago in order to mitigate this issue. it is a hack. it patches `graceful-fs` and `agent-base` so not to leak.\r\nsince `graceful-fs` have introduced a hack of their own you can fork `jest-leak-fixer` (or PR), remove the code that handles `graceful-fs`, and try running your test suite again.\r\nif this does not help, you can help us mapping other leaking modules by running `jest-leak-fixer` [tests](https:\/\/github.com\/lev-kazakov\/jest-leak-fixer\/tree\/master\/test\/test-with-dependencies) against your dependencies graph, one dependency at a time.","@lev-kazakov Sadly, implementing the jest-leak-fixer according to your README did not solve the problem. I would help you running your tests against our dependencies graph if you could instruct me how to do it. If you could send me a message with instructions, I could help you there.","Possibly related to this: https:\/\/github.com\/nock\/nock\/issues\/1448","any updates? We still face memory leaks from time to time, especially in a memory-constrained CI environment (leaks add up and crash at some point)","@mjesun can you help finding someone relevant to review https:\/\/github.com\/facebook\/jest\/pull\/8331?\r\nit's a kind of a hack that allows mitigating these kind of memory leaks, till we come up with something smarter to do.","For anyone else getting hit by this: I used @B4nan's pre test script ahead of running my tests and this seemed to stop the memory leak https:\/\/github.com\/mikro-orm\/mikro-orm\/commit\/5e848473cffafb5ae981344cbe1868b987b4871a\r\n","this issue has also been surfacing in GitHub Actions in this project here: https:\/\/github.com\/lifeiscontent\/realworld\/pull\/229\/checks?check_run_id=826716910","In my team we have the same issue, causing our tests failing with a 'out or memory' error.\r\nAfter investigations it seems lib `aws-xray-sdk` to be the cause, comment any references to it fix the issue.","We run our tests using plain old unix tools to avoid running into these memory leak issues. In case it helps someone:\r\n\r\nIt's a combination of `find`, `sort` and `xargs`. It finds all test files, sorts them randomly, then runs 4 instances of jest in parallel, each will test chunks of 5 files.\r\n\r\n```bash\r\nfind .\/tests -type f \\( -name \\*.test.ts -o -name \\*.test.tsx \\) | sort -R | xargs -L 5 -P 4 jest --runInBand --logHeapUsage\r\n```","*** EDIT ***\r\n\r\nignore the below the issue is back :( \r\n\r\n************\r\n\r\nTLDR: using a `NodeEnvironment` was the problem.\r\n\r\nMy two cents on this, I was using a `NodeEnvironment` for my tests: \r\n\r\nhttps:\/\/jestjs.io\/docs\/en\/configuration#testenvironment-string\r\n\r\nIn here I was setting up the database and exposing through globals, dropping it etc. before each of my tests ran.\r\n\r\nIn the end I ditched this in favour of having a helper class which I just instantiate in the set up of each of my test files. This instance gets garbage collected without any issues.\r\n\r\nRealise this probably isn't the most explicit comment but can't post any code sadly. \r\n\r\n","Ok so got a work around which I hope may be useful to others. \r\n\r\nYou can use this solution to run your tests in batches, one jest process per batch. The processes are run sequentially so should keep the memory usage down. Not ideal but functional and I needed a quick fix as this was issue was preventing us merging any PRs.\r\n\r\n\/\/ run-tests-ci.ts\r\n```typescript\r\nimport {execSync} from \"child_process\";\r\nimport glob from \"glob\";\r\n\r\nconst shell = (cmd) => execSync(cmd, {stdio: \"inherit\"});\r\n\r\nconst run = async () => {\r\n  logger.info(\r\n    \"Running tests in batches to avoid memory leak issue... this means you will see jest start up multiple times.\",\r\n  );\r\n\r\n  const files = await glob.sync(\".\/test\/**\/*.test.ts\");\r\n\r\n  const batchSize = 20;\r\n  let batch: string[] = [];\r\n  const runBatch = () => {\r\n    if (batch.length) {\r\n      shell(`jest ${batch.join(\" \")}`);\r\n      batch = [];\r\n    }\r\n  };\r\n\r\n  for (const file of files) {\r\n    batch.push(file);\r\n    if (batch.length === batchSize) {\r\n      runBatch();\r\n    }\r\n  }\r\n\r\n  runBatch();\r\n};\r\n\r\nrun().catch((err) => {\r\n  logger.error(err);\r\n  process.exit(1);\r\n});\r\n```\r\n\r\npackage.json\r\n```\r\n{\r\n  \"scripts\": {\r\n    \"test-ci\": \"ts-node test\/run-tests-ci.ts\",\r\n  },\r\n\/\/ etc.\r\n}\r\n```\r\n\r\nthen run with `npm run test-ci`","@stuart-clark-45 how do you combine the output from mulitiple --coverage's?","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","I think as mentioned a few times, this is not a bug in Jest per say, but the way Jest works (its own module cache, different globals per test file etc.) can sometimes violate assumptions made by libraries when they patch\/override\/add to globals (either core modules or `globalThis`).\r\n\r\nNot sure what we can do in Jest to detect this and warn, instead of just leak. One thing is #8331 for modules and potentially trying to add a `Proxy` around the global inside the scripts, but I'm not sure it's a particularly good idea. Much (probably by far _most_) modifications are perfectly safe to make, so there'd be a lot of false positives.","@SimenB If it's innate to the implementation of Jest that a lot of larger code bases might run into these problems then I think it would be very helpful to actually have more details in the docs on *why* this would happen and common ways of debugging it (beyond the existing CLI args).\r\n\r\nAs it currently stands there's not a lot of detail on how the module loading works in the docs. And that's understandable in the sense that users \"shouldn't have to know how it works\". However if it is the case that having somewhat of an understanding of at least the general working of Jest can help users write more performant tests and understand why memory leaks can easy become an issue, then it's perhaps worth reconsidering.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.","> This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days.\r\n\r\nOh no, you don't.","for the `agent-base`, I'm using jest.mock to mock the `patch-core` module. It's safer than replacing content since the original file may not be replaced back.\r\n\r\n\/\/ package.json\r\n```json\r\n    \"setupFilesAfterEnv\": [\r\n      \".\/test\/setup-after-env.ts\"\r\n    ],\r\n```\r\n```js\r\n\/\/ test\/setup-after-env.ts\r\njest.mock('agent-base\/patch-core', () => ({}));\r\n```"],"labels":["Pinned"]},{"title":"Jest performance is at best 2x slower than Jasmine, in our case 7x slower","body":"## \ud83d\udc1b Bug Report\r\n\r\nWe've been using Jest alongside Jasmine for the same test suite for about a year now. We love Jest because it's developer experience is superb, however, on our very large monorepo with ~7000+ test specs, Jest runs about 7 times slower than Jasmine. This problem has been getting worse and worse as the test suite grows and as a result, we always run our test suite via Jasmine and only use Jest for development --watch mode. \r\n\r\nWe would \u2665 to use Jest as our only test runner, but its poor performance is preventing us from doing so. Having to run both Jest and Jasmine runners requires painful CI setup and constant upkeep of the Jasmine environment setup (which is much more complex than Jest's).\r\n\r\nI'd like to better understand why the performance difference is so significant and if there's anything that can be done to optimize it.\r\n\r\n## To Reproduce\r\n\r\nI've created a very detailed project to reproduce and profile both Jest and Jasmine on the same test suite in this project: https:\/\/github.com\/EvHaus\/jest-vs-jasmine\r\n\r\nThe environment is the same. The configurations are very similar. Both use JSDom. Both use the same Babel setup. Additional instructions are contained therein.\r\n\r\n## Expected behavior\r\n\r\nRunning tests through Jest should ideally be as fast as running them through Jasmine.\r\n\r\n## Link to repl or repo (highly encouraged)\r\n\r\nhttps:\/\/github.com\/EvHaus\/jest-vs-jasmine\r\n\r\n## Run `npx envinfo --preset jest`\r\n\r\nTested on a few different platform. See https:\/\/github.com\/EvHaus\/jest-vs-jasmine README for more info.","comments":["@EvHaus thanks for the detailed report.\r\n\r\nWe have similar issues under Semantic-Org\/Semantic-UI-React#2971, when Jest's suite is about 5x slower.","@layershifter https:\/\/github.com\/Semantic-Org\/Semantic-UI-React\/pull\/2971\/files#r202618422","Am I right in saying the problem is that jasmine loads all specs into one process and runs it, where as jest creates a new mini-environment per test suite?\r\nWe see exactly the same issue and profiling seems to show a significant amount of time resolving files and parsing javascript - unfortunately the multi-core aspect can't make up for this. I have no idea why resolving is so slow. We made significant speed increases by trying to make suites import the least number of files, but we've hit a wall on going further in that direction as we in many cases want to test multiple components running together and not to mock every dependency.\r\nI planned to do some more profiling and it would be great if anyone on the core jest team can point in any directions to things they would like to see.","I think it's a fair assumption to say it's the module resolution that's taking time. While `require('foo');` is an in-memory cache lookup for jasmine (after the first one), every single test file in jest will have to do full resolution, and execution, of `foo` and all its dependencies. I doubt it's the resolution itself that takes significant time (we should have the fs in memory (after the first run, at least)), but executing the files probably takes up a significant chunk of time.\r\n\r\nAnother difference is that jest executes your code inside the jsdom vm, while with jasmine you've just copied over all the globals to the node runtime (https:\/\/github.com\/jsdom\/jsdom\/wiki\/Don't-stuff-jsdom-globals-onto-the-Node-global), which will always be quicker as you skip an entire abstraction layer (https:\/\/nodejs.org\/api\/vm.html).\r\n\r\nThat said, I agree it's really not ideal (to put it mildly) that Jest is about twice as slow as jasmine. I'm not really sure what we an do, though. We could try to cache the resolution (although we'd still have to run through the entire tree in case there's been any module mocking) which might allow us to not resolve modules by looking around, but again the FS should be in memory, so I doubt it'd have much impact.\r\n\r\n@cpojer @mjesun @aaronabramov @rickhanlonii do you think there's anything clever we can do here? Or any awesome ways of profiling what we spend our time on?\r\n\r\n---\r\n\r\nAlso, thank you so much for setting up a great reproduction case @EvHaus!","> I doubt it's the resolution itself that takes significant time (we should have the fs in memory (after the first run, at least)), but executing the files probably takes up a significant chunk of time.\r\n\r\nI did some profiling of the node processes while running Jest on my projects it seemed like requiring was one of the most time consuming tasks. At least that was the case on Windows (not WSL), which I found to be substantially slower than Linux, especially in watch mode. Granted, I'm not particularly confident in my understanding of the node profiler's output, but that's what it looked like. I saw the same thing with this reproduction.","`require` is both resolution and execution","> I think it's a fair assumption to say it's the module resolution that's taking time. While require('foo'); is an in-memory cache lookup for jasmine (after the first one), every single test file in jest will have to do full resolution, and execution, of foo and all its dependencies.\r\n\r\nI haven't looked at the code, so I can't be totally sure -- but this sure \"feels\" like what's happening. When running through Jasmine there's a very long delay before anything is printed to the console (likely Jasmine resolving\/executing ALL deps), and then the tests run through super quick. Whereas with Jest, it immediately starts running tests without any initial lag, but each test is significantly slower to run.","Any chance switching from worker processes to the [node `vm` api](https:\/\/nodejs.org\/api\/vm.html) could help? That permits pre-compiling sources with `vm.Script`, then running them in isolated, sandboxed contexts. Obviously seems like a lot of work!","Jest already does that.","I believe you, but then what are these `jest-worker` processes?","@rickhanlonii do you have the Jest architecture chart somewhere?","If I had to guess, you use the workers for multi core, but VM as well for isolation, even with --runInBand? With `cachedData` that should skip most parse time even with multi proc. So the time is literally execution time of the modules, which would be pretty hard to skip I guess.\r\n\r\nMaybe a --runVeryInBand that shares a VM?","Looks like `cachedData` isn't being used in `new vm.Script()` (I'm looking at [`jest-runtime`'s `ScriptTransformer`](https:\/\/github.com\/facebook\/jest\/blob\/bf9cbc2bbddc6562b1fea59c41731b3d1c6412ea\/packages\/jest-runtime\/src\/script_transformer.js#L308) - [V8 can now cache script code after code execution](https:\/\/v8project.blogspot.com\/2018\/04\/improved-code-caching.html), which looks like it's exposed by [`vm.Script#createCachedData()`](https:\/\/nodejs.org\/api\/vm.html#vm_script_createcacheddata) from node 10.6, so if there's somewhere sensible to do that, (just before any mock\/test code execution somehow?) it might help even multi-proc?","I tried to use cachedData for an experiment about two years back. There is even a PR (sorry on mobile so can\u2019t find the link). There was no difference in perf that I observed. Cached code is much larger and I assume reading and validating that is equal to the parse time overhead that is saved. I\u2019d be curious to see results of somebody re-running that experiment. Changing the script transformer and running some perf tests should give us some data.","That sounds likely, it could well be that the delayed `createCachedData()` could work better as more useful code would be codegened and thus cacheable (if I'm reading that blog post right).\r\n\r\nThere's also `v8::SnapshotCreator` that node started using recently for it's own startup which persists the full execution state, not just parse\/codegen output, but it sounds like it's quite fiddly to get working even when you control all the code executed (e.g. it requires all handles to be closed).","Things we've done to increase the performance of jest in our setup:\r\n\r\n1. Changed the reporter to not verbose and a dot reporter. For us this 2.5x speed increases\r\n2. Implemented our own custom resolver and instead of just caching imports with a cache key of the current directory and the import, cache based on current directory only if its relative or within node_modules, otherwise cache globally no matter what folder we are in - this appeared to save about 10% for us\r\n3. reduce the files imported per suite - for instance even a static import of ten json files across every suite, when removed saved several seconds. Removing some lazy imports where too much was imported took some suites from 10 seconds to 5 seconds.","I was intrigued by the 2.5x speed increase mentioned from using a dot reporter, so I gave it a go.\r\n\r\nAdded `verbose: false` and `reporters: ['jest-dot-reporter']` to the config. On our giant main repo it only offered about a 15% performance improvement (260s instead of 300s to run all tests). That's small but something. And on the [test repo](https:\/\/github.com\/EvHaus\/jest-vs-jasmine) it didn't seem to make any difference at all (probably because it doesn't have enough specs for the reporter change to make an impact).","That was a windows bash shell in windows 8. It wouldn\u2019t surprise me if shells differed greatly and I\u2019ve previously seen a large slow down from console output.","Is it just console output which is slow or is it colored terminal output?\r\n\r\nIf it is the latter, perhaps somebody could [try switching from `chalk` to `turbocolor`](https:\/\/github.com\/jorgebucaran\/turbocolor\/tree\/master\/bench)? According to the benchmark I linked to it's significantly faster.","Perhaps somewhat effected, but windows console (=terminal) just renders very slowly in general, seemingly linear to the characters on screen - you can clearly see the speed increase as you resize the window slower. It's still using the ancient GDI api to render each span of text of the same color, so if there's a lot of switching at the character level that might have some effect. (They have reported they are working on the console rendering [recently](https:\/\/blogs.msdn.microsoft.com\/commandline\/2018\/07\/20\/windows-command-line-inside-the-windows-console\/), but no exact dates)\r\n\r\nThe results in the original OP's test repo shows similar differences on a macbook, so I doubt this is the real difference here.","Related: #2925 (and #4323 for a PR that gave it a shot). If we could implement that properly (as well as having some sort of state that only on say 20+ transitive dependencies is it activated) that might help","also interesting is this, watch mode is three times slower than non watch mode even with the same amount of workers. (35s vs 11s)\r\n\r\ntracked it down to the passing of to `rawModuleMap` in `_createParallelTestRun`  of jest-runner, it seems like not passing the rawModuleMap is faster for some reason, note that in my case,\r\n`test.context.moduleMap.getRawModuleMap()` always returns `{ duplicates: {}, map: {}, mocks: {} }`","@leiyangyou that was just changed in #6960 (not released yet), maybe it helps? Not sure about the easiest way for you to test it beyond following the steps in the contributing guide on how to use a local version of Jest.\r\n\r\n\/cc @rubennorte ","@SimenB that didn't improve watch mode as the haste map still has to be transferred to the worker processes (it's not persisted in watch mode). It might make that transference a bit slower because we have to serialize the map as a JSON-serializable array.","@SimenB thanks. What I don't quite understand is this, according to logging, the sent raw map is pretty much empty `{ duplicates: {}, map: {}, mocks: {} }`, I will set up a local instance with your changes and let you know.","@leiyangyou the map is only empty when not in watch mode, because the worker is going to read it from disk. In watch mode is the updated haste map with any changes in the watched files already applied.","@rubennorte so I've added a log inside runTestInWorker inside jest-runner\/index.js\r\n\r\n```javascript\r\nconst runTestInWorker = function(test) {\r\n        return mutex(\r\n          _asyncToGenerator(function*() {\r\n            if (watcher.isInterrupted()) {\r\n              return Promise.reject();\r\n            }\r\n\r\n            yield onStart(test);\r\n\r\n            console.log(test.context.moduleMap.getRawModuleMap())\r\n            \r\n            return worker.worker({\r\n              config: test.context.config,\r\n              globalConfig: _this3._globalConfig,\r\n              path: test.path,\r\n              rawModuleMap: (false && watcher.isWatchMode())\r\n                ? test.context.moduleMap.getRawModuleMap()\r\n                : null\r\n            });\r\n          })\r\n        );\r\n      };\r\n```\r\nin watch mode, on initial ran, `{ duplicates: {}, map: {}, mocks: {} }` is printed for each worker, after I change a file, on subsequent runs it's still `{ duplicates: {}, map: {}, mocks: {} }`\r\n\r\nMaybe another bug somewhere? note that I've disabled the actual sending of the module map.\r\n\r\nThis is on the jest 23.6.0 release","@SimenB I tried the latest version of the hash map\r\n\r\nin non-watch mode, running through my test suite takes about 12s (comparable to before)\r\nin watch mode, it takes about 24-30s (marginally faster than before, 30-35s)\r\nagain, not sending the map is faster, the same speed as non-watch mode.\r\nI do have 8 cpus, and an ssd, and my suite is not huge, 70 suites with 787 tests\r\n\r\nwhat is the initial motivation for dispatching module maps to workers?","Mocha takes one second.\r\nJest takes 12 seconds.\r\nSo I removed the Jest from my project.","i was trying to do migration from mocha to jest... and... mocha is finishing all tests before jest starts first one... i think there is somewhere issue with resolving\/reading files -> my project contains ~70k files, and i'm running ~19k tests.\r\n\r\nafter some digging its looks like jest is trying to import all files from all folders before he starts tests, i'm providing explicit match for test file: `testMatch: ['<rootDir>\/dist\/alignment.spec.js']`.\r\n\r\ni was able to run tests by adding to jest.config\r\n```\r\nmodulePathIgnorePatterns: ['<rootDir>\/fixtures\/.*'],\r\n```\r\n\r\nbut it's still 11m... as opposed to mocha ~1m and without test framework (try\/catch assert) ~40-50s\r\n\r\nturning off transformation helped to\r\n```\r\ntransform: {}\r\n```\r\n\r\nso far my configuration looks like this:\r\n\r\n```\r\nmodule.exports = {\r\n  testEnvironment: 'node',\r\n  testMatch: ['<rootDir>\/dist\/alignment.spec.js'],\r\n  moduleFileExtensions: ['js'],\r\n  transform: {},\r\n  modulePathIgnorePatterns: ['<rootDir>\/projects\/.*', '<rootDir>\/node_modules\/.*']\r\n};\r\n```\r\n\r\nits still slow, ~4min\r\n\r\n--------\r\n\r\nnow i'm looking for way to turn of prettier, i don't care about formatting errors...","`modulePathIgnorePatterns` and `transform` didn't show any improvements for me. i shoved off few seconds using a dot reporter though","Same issue here on 25.2.2, file resolution takes too long. Is there any plan to speed it up?","I think it's interesting to revisit `cachedData` in context of using esm:\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/9ffd368330a3aa05a7db9836be44891419b0b97d\/packages\/jest-runtime\/src\/index.ts#L364\r\nI checked using `cachedData` on one big bundle, I see 500 -> 20ms drop for SourceTextModule constructor.\r\nIt's interesting to check if this will improve performance. (we want to know parsing vs evaluation time) \r\nIdeally we want to dump whole memory and reuse it for each test, but I cannot imagine how to do this.","I've succeeded speeding up jest in our project. \r\nMain issue for us was high memory usage and memory leaks. Solution is - proxy builtin modules and call gc before every test. Other speedup options - cache resolver, transformers, vm.script creation.\r\nyou can try in you project.\r\n`jest.config.js`\r\n```js\r\nresolver: require.resolve('.\/cached-jest-resolver'),\r\nmoduleLoader: require.resolve('.\/jest-runtime'),\r\n```\r\n`cached-jest-resolver`\r\n```js\r\n\r\nconst cache = new Map();\r\n\r\nmodule.exports = (request, options)  => {\r\n    const cacheKey = `${request}!!${options.basedir}`;\r\n \r\n    let resolved = cache.get(cacheKey);\r\n    if (!resolved) {\r\n        resolved = options.defaultResolver(request, options);\r\n        cache.set(cacheKey, resolved);\r\n    }\r\n\r\n    return resolved   \r\n}\r\n```\r\n`jest-runtime.js`\r\n```js\r\nconst JestRuntime = require('jest-runtime');\r\nconst vm = require('vm');\r\nconst {handlePotentialSyntaxError} = require('@jest\/transform');\r\nconst v8 = require('v8')\r\n\/\/TODO SAFER BUFFER! request\/request inherits stream\r\nconst PROXY_WHITE_LIST = new Set(['process', 'module', \r\n\/\/ 'buffer', 'stream',\r\n\/\/ 'constants',\r\n'fs'\r\n]);\r\nv8.setFlagsFromString('--expose-gc');\r\n\/\/TODO freeze console????????????\r\nconst gcClean = vm.runInNewContext('gc')\r\nlet RUN_COUNT_FOR_GC = 1\r\nconst CLEAN_EVERY_TIME = 1;\r\nconst detectLeaks = (() => {\r\n  const weak = require('weak-napi');\r\n  let references = 0;\r\n  return (obj) => {\r\n    references += 1;\r\n    console.log('references count ++', references)\r\n    weak(obj, () => {\r\n      references -= 1;\r\n      console.log('references count --', references)\r\n    })\r\n  }\r\n})()\r\nfunction makeReadonlyProxy(obj) {\r\n    if (\r\n      !((typeof obj === 'object' && obj !== null) || typeof obj === 'function')\r\n    ) {\r\n      return obj;\r\n    }\r\n    return new Proxy(obj, {\r\n      get: (target, prop, receiver) => {\r\n        return makeReadonlyProxy(Reflect.get(target, prop, receiver), );\r\n      },\r\n      set: (target, property, value, receiver) => {\r\n        if (typeof value !== 'function') {\r\n          return Reflect.set(target, property, value, receiver);\r\n        }\r\n        \/\/ console.log(`trying to set! ${path.join(', ')} ${property}, ${typeof value}`);\r\n        \/\/ throw new Error(`trying to set! ${filename}, ${property as any}, ${typeof value}`);\r\n        return true;\r\n      },\r\n    });\r\n  }\r\nconst __scriptCache = new Map();\r\nconst __transformCache = new Map();\r\nmodule.exports = class MyJestRuntime extends JestRuntime {\r\n    constructor(...args) {\r\n        super(...args);\r\n        this.__coreModulesCache = new Map();\r\n        \/\/ Object.freeze(this._environment.global.console);\r\n        if (++RUN_COUNT_FOR_GC % CLEAN_EVERY_TIME === 0) {\r\n            console.log('running gc')\r\n          gcClean();\r\n        }\r\n        detectLeaks(this)\r\n        console.log('memory: ', Math.floor(process.memoryUsage().heapUsed\/1000\/1000));\r\n    }\r\n    transformFile(filename, options) {\r\n      \/\/TODO IS WATCH\r\n        let result = __transformCache.get(filename);\r\n        if (!result) {\r\n            result = super.transformFile(filename, options);\r\n            __transformCache.set(filename, result); \/\/DO NOT COMMIT IT\r\n        }\r\n        return result\r\n    }\r\n    _requireCoreModule(moduleName) {\r\n        let mod = this.__coreModulesCache.get(moduleName);\r\n        if (!mod) {\r\n            mod = super._requireCoreModule(moduleName);\r\n            if (!PROXY_WHITE_LIST.has(moduleName)) { \/\/TODO!!!!!\r\n                mod = makeReadonlyProxy(mod)\r\n            }\r\n            this.__coreModulesCache.set(moduleName, mod)\r\n        }\r\n        return mod\r\n    }\r\n    createScriptFromCode(scriptSource, filename) {\r\n        const scriptFromCache = __scriptCache.get(filename);\r\n        if (scriptFromCache) {\r\n            return scriptFromCache\r\n        }\r\n        try {\r\n          const scriptFilename = this._resolver.isCoreModule(filename)\r\n            ? `jest-nodejs-core-${filename}`\r\n            : filename;\r\n          const script =  new vm.Script(this.wrapCodeInModuleWrapper(scriptSource), {\r\n            displayErrors: true,\r\n            filename: scriptFilename,\r\n            \/\/is leaking\r\n            \/\/ @ts-expect-error: Experimental ESM API\r\n            \/\/ importModuleDynamically: async (specifier) => {\r\n            \/\/   invariant(\r\n            \/\/     runtimeSupportsVmModules,\r\n            \/\/     'You need to run with a version of node that supports ES Modules in the VM API. See https:\/\/jestjs.io\/docs\/en\/ecmascript-modules',\r\n            \/\/   );\r\n            \/\/   const context = this._environment.getVmContext?.();\r\n            \/\/   invariant(context, 'Test environment has been torn down');\r\n            \/\/   const module = await this.resolveModule(\r\n            \/\/     specifier,\r\n            \/\/     scriptFilename,\r\n            \/\/     context,\r\n            \/\/   );\r\n            \/\/   return this.linkAndEvaluateModule(module);\r\n            \/\/ },\r\n          });\r\n          __scriptCache.set(filename, script); \/\/TODO is cache\r\n          return script\r\n        } catch (e) {\r\n          throw handlePotentialSyntaxError(e);\r\n        }\r\n      }\r\n}\r\n```\r\nYou can play with this. Mb you'll need to add more deps to PROXY_WHITE_LIST.\r\n`references count` should be <=3, if more - you're probably leaking, which will impact performance.","@goloveychuk Interesting idea, but your solution didn't seem to make a significant difference in my benchmark. \ud83d\ude22  I've added it to https:\/\/github.com\/EvHaus\/jest-vs-jasmine\/.\r\n\r\n## Native Jest\r\n\r\n<img width=\"572\" alt=\"Screen Shot 2021-04-07 at 7 36 35 PM\" src=\"https:\/\/user-images.githubusercontent.com\/226640\/113959970-9563ae00-97d8-11eb-8783-97218b2945c4.png\">\r\n\r\n## Your approach\r\n\r\n<img width=\"570\" alt=\"Screen Shot 2021-04-07 at 7 36 59 PM\" src=\"https:\/\/user-images.githubusercontent.com\/226640\/113960018-a44a6080-97d8-11eb-8533-0c60b30db63d.png\">\r\n\r\n## Jasmine (for comparison)\r\n\r\n<img width=\"572\" alt=\"Screen Shot 2021-04-07 at 7 42 48 PM\" src=\"https:\/\/user-images.githubusercontent.com\/226640\/113960496-73b6f680-97d9-11eb-961c-62c8525d4431.png\">\r\n\r\nI've updated my repo with the latest benchmarks, latest version of Jest, latest version of Node and a more reproducible benchmarking tool (via `hyperfine`). Overall, I'm still seeing Jest performing at least 3x slower than Jasmine. So nothing has really changed since the original post.\r\n\r\nFYI: I'm not complaining. Just want to ensure those subscribed to the thread know that no significant advancements have been made here yet in the latest versions.","@EvHaus yea, I think it won't have a difference in this benchmark. \r\nMore info about my setup\/project.\r\n1) we had leaks\r\n2) 600 test files, 8000 tests total\r\n3) many dependencies - createScriptFromCode is called for 8000 unique files.\r\n4) number of resolved files - 20000.\r\n4) memory used after test file - up to 1gb. (per each worker). If don't clean - up to 2gb (node max old space)\r\n5) workers=8.\r\n6) pc - amd 3700x, 8\/16 cores, 16gb memory.\r\n7) 26.6 jest, jasmine test runner.\r\n\r\nIn this setup I have 531s default, and 226s with above optimisations. \r\nMost important trick is to clean memory before each test file, and it will help only if you're using many workers and your tests are taking much memory. In my example - 8 workers * 2 memory, with 16gb total, system is going to swap. And you have this \"effect\", when at start jest is running pretty fast, and after several test files it's slowed down. If you have such a symptoms - mb gc clean will help you.\r\n\r\nSo answering on your comment - those optimisations could help on real world heavy projects, it cannot make jest same speed  as jasmine, since jest have expensive runtime (think of all those features\/overhead: mocks, transformers, reporters, error formatting, tests isolation, caching etc)","Just updated my benchmarks with a new player in town -- [Vitest](https:\/\/vitest.dev\/). I have good news. It has a compatible API to Jest but in [my benchmarks](https:\/\/github.com\/EvHaus\/jest-vs-jasmine) it ran 2x faster than Jest and even outperformed Jasmine. \ud83d\ude2e\r\n\r\nI'm going to try migrating a larger real world codebase to it early in the new year and report back on the experience for those curious.","Exciting, @EvHaus !","Hey folks, I've done an investigation run on my own with a no-op test and a lot of imports (`requireModuleOrMock()` is being called ~12500 times!). Most of my files in this test are TypeScript.\r\n\r\nIgnoring `jest` init time (by strictly measuring the 2nd test of a `jest --watch ...`), this no-op test takes `~1.5s`.\r\nHere's what I'm seeing that's causing that:\r\n* `~625ms` is spent doing `getModuleID()` which does some expensive FS work to find the absolute location of the module - iteratively check dirs for `package.json`, check if there's aliasing properties in it (`resolveExports`), then find the actual module itself, and do some `resolve` calls as well. Since `getModuleID()` is called once per module (`~26000 calls), these FS operations add up.\r\n* `~450ms` is spent in `_execModule()` (excluding the actual invocation of the module, of course).\r\n    * `~60ms` is spent in `transformFile`: read the file, hash it, check if hash matches local cache\r\n    * `~350ms` is spent in `createScriptFromCode`: I think this is Node VM shenanigans requiring a bunch of work to happen on the script before it can be interpreted \"for real\".\r\n* There's roughly `~400ms` leftover, but I think that it can be explained by interpretation time of the imported modules themselves - there may be other wins in here, but they're going to have depreciating returns.\r\n\r\nSo, a couple recommendations for things to look into next:\r\n1. Perhaps we can extend file-watching to be more intelligent in `getModuleID` to see if a file's been changed? Of course, if file watching isn't available (no `watchman`, etc), then fall back to the current slow mode\r\n2. It might be worth hashing and storing information about `package.json` aliasing, so we don't need to load and parse it from scratch every time. Of course, this would still need to be invalidated if the `package.json` is changed (hopefully file watching can help us with this)\r\n3. As we build an understanding of the file system, we might be able to get more clever to avoid some FS work (e.g. if we know that `package.json` doesn't exist at <subdirectory> in a previous import, perhaps we can avoid a `stat` when importing a future module. Maybe this is already happening and I missed it :)\r\n4. Can we reuse `createScriptFromCode` output between test invocations somehow? I wonder if it is Node-VM-specific (so, each time we create a new sandbox, we need to `createScriptFromCode` again).\r\n5. Smaller thing: [we initialize our hastemaps and `watchman`, even if we aren't in `--watch` mode](https:\/\/github.com\/facebook\/jest\/blob\/main\/packages\/jest-core\/src\/cli\/index.ts#L207-L211). Maybe this can be skipped?\r\n6. Would it be possible to remove the amount of `resolve()`\/`realpath`\/general FS operations in `getModuleID()`? Perhaps some of them are redundant :crossed_fingers:\r\n7. ([Inspired by a workaround discovered by my colleague, Patrik](https:\/\/github.com\/backstage\/backstage\/blob\/master\/packages\/cli\/config\/jestCachingModuleLoader.js#L40-L41)) in watch mode, we can probably lean on `mtime` to determine if a file is changed on re-runs. This sidesteps hashing all input files, which is a big win.\r\n\r\nIf I have time, I may be able to dig into some of these potential perf-gain options in the next few months, but no guarantees. I wanted to brain-dump here in case any other Jesters and Fools got inspired :)\r\n\r\n-----\r\n\r\n(note that I do have some low-hanging-fruit PRs that I'll be upstreaming, but none of them address the remaining code hotspots mentioned above).","To \"fix\" imports overhead, I've written custom test runner.\r\nIt's using `posix fork()` to clone processes (more docs are in link)\r\nIn our case, we reduced our test run from 18 to 4.5 minutes, from which 1 minute is warmup and could be speed up by moving to swc\/esbuild.\r\n\r\nhttps:\/\/github.com\/goloveychuk\/fastest-jest-runner","for those of you struggling with memory leaks https:\/\/github.com\/kulshekhar\/ts-jest\/issues\/1967#issuecomment-1346428383","I have simular performance issues, our tests are running at least 5x slower.","I am having the same issue and it got 2X worse after upgrading Node from 12 to 18.","> I am having the same issue and it got 2X worse after upgrading Node from 12 to 18.\r\n\r\nProbably explains my issues.","Any news on this?","I made a hacked together runtime and test env that doesn't isolate the test suites that improved our frontend tests by 8x with a cold cache. It also has a few caveats. So depending on your project setup it may or may not help. https:\/\/github.com\/m-abboud\/hella-fast-jest-runtime."],"labels":["Confirmed","Help Wanted"]},{"title":"Reinstate timestamps for mock calls","body":"<!-- Love Jest? Please consider supporting our collective: \ud83d\udc49  https:\/\/opencollective.com\/jest\/donate -->\r\n\r\n## \ud83d\ude80 Feature Proposal\r\n\r\nRecord the timestamp of individual mock calls.\r\n\r\n## Motivation\r\n\r\nI am well aware timestamps were removed in favor of `invocationCallOrder`(https:\/\/github.com\/facebook\/jest\/pull\/5867). However, to implement a new matcher proposed in https:\/\/github.com\/jest-community\/jest-extended\/issues\/112, timestamps are necessary. I am proposing to restore the implementation alongside `invocationCallOrder` and, at the same time, address the concerns raised previously regarding the precision issues (https:\/\/github.com\/jest-community\/jest-extended\/issues\/98#issuecomment-355440156, https:\/\/github.com\/facebook\/jest\/issues\/4402#issuecomment-375939427). @brigonzalez was already headed towards a possible solution for this resorting to [process.hrtime()](https:\/\/nodejs.org\/api\/process.html#process_process_hrtime_time) instead of `Date`.\r\n\r\n## Example\r\n\r\nOne potential scenario for this feature is, by making use of the aforementioned matcher, to ensure a function is called in compliance with a given exponential back-off strategy.\r\n\r\n## Pitch\r\n\r\nI believe this feature supports a legitimate use case and other may follow.","comments":["Not sure about this one. What if people want a timestamp for when it returned instead of invoked? Or if it's a promise, when it settled?\r\n\r\nChecking the order of invocations makes sense to me (error handler invoked before logger, or whatever). Not sure about how close to mocks were called. We don't want a too big of an API surface. If you _really_ want that, you could in theory implement it as you `mockImplementation`, and just push into some array you have in your test or something.","@thymikee @rickhanlonii thoughts? Also @UselessPickles since you've been working on the mocks lately \ud83d\ude42 ","It would be fairly simple to update the mock code to record 2 timestamps per call: \r\n\r\n- Time of call\/invokation\r\n- Time of completion (return or throw) \r\n\r\nThere's already a convenient structure containing the \"result\" data where we could also store the time of completion. But the current structure of the rest of the \"mock\" object would require that we add yet another parallel array to contain invocation\/call timestamps. \r\n\r\nIt would be nice to combine all of the parallel arrays into a single array of \"mock call\" objects some day, but that's a big breaking change.\r\n\r\nSo my thoughts are that it's simple and low risk to implement, so it might be a worthwhile inclusion if it helps others write custom matchers that analyze the relationships between different method calls.","...but the real question is how we obtain the the \"now\" timestamp. I haven't fully researched this, but I'm vaguely aware of some options:\r\n\r\n- Date.now() is reliably supported, but limited to no better than millisecond precision, and can be thrown off if the system time is manually or automatically adjusted during execution.\r\n- performance.now() isn't thrown off by system clock changes during execution, and may return better than millisecond precision in some implementations, but can we assume it is supported in all environments where Jest is run?\r\n- I believe there's also some NodeJS-specific process timestamp that can be obtained that is high precision.\r\n\r\nAlso note that performance.now() and the NodeJS process timestamp are NOT real date-time timestamps. They start at zero at the beginning of execution and count how long the process has been running. Is that a problem? Will anyone expect these timestamps to be absolute timestamps, or is it OK for them to be relative to the beginning of the process?",">I believe there's also some NodeJS-specific process timestamp that can be obtained that is high precision.\r\n\r\n`process.hrtime` is that one :) we can use https:\/\/www.npmjs.com\/package\/browser-process-hrtime which should work in all envs we care about","@UselessPickles @SimenB Yep, that's it. At least for the use case I presented, timestamps relative to the beginning of the process will do. The package [convert-hrtime](https:\/\/github.com\/sindresorhus\/convert-hrtime) may prove itself useful for this.","@UselessPickles @SimenB what's the way forward?","Ping @UselessPickles @SimenB","I think we need this PR merged first, because it includes changes to related code\/structures: https:\/\/github.com\/facebook\/jest\/pull\/6381\r\n\r\nOnce that is merged, I could easily create a PR to store invocation and completion timestamps, but it might be time to seriously think about restructuring the parallel arrays of information about mock calls. Without any restructuring, it would require adding yet another parallel array to store the invocation timestamps (which may be \"good enough\" for now to avoid serious breaking changes). I would like feedback from the Jest team on this before I put any work into it.\r\n\r\nNo matter what approach we take, it will technically be a breaking change to the mock serializer.\r\n\r\nThe completion timestamp would simply be a new property on the MockFunctionResult structure that would be undefined while the `type` property is `incomplete`, then updated to a timestamp value when the function either returns or throws.\r\n","@SimenB Now that #6381 is merged, what are your thoughts on this issue? \r\n(see previous comment for some options to consider)","I wonder if we should have `jestMock.mockInvocations` (or something) be an array of this shape:\r\n\r\n```js\r\ntype MockInvocation = {\r\n  call: { args: Array<any> },\r\n  result: { type: 'return' | 'throw', value: any },\r\n  \/\/ Drop it, maybe? #7070\r\n  instance: any\r\n};\r\n```\r\nThen we could in theory add some more stuff\r\n\r\n@thymikee @rickhanlonii thoughts?","I don't see any reason to nest `args` in a `call` property. \r\n\r\nAlso, a slight correction on the type of `result` (can be undefined while the function is incomplete), adding timestamps for this issue, and some suggestions for #7070\r\n\r\n```\r\ntype MockResult = { \r\n  type: 'return' | 'throw', \r\n  value: any,\r\n  \/\/ timestamp of function completion\r\n  timestamp: number,\r\n  \/\/ #7070 - if we want to get fancy and correctly determine whether \r\n  \/\/ the function is called with `new` and created a new instance\r\n  newInstance: any \r\n};\r\n\r\ntype MockInvocation = {\r\n  args: Array<any>,\r\n  result: MockResult | void,\r\n  \/\/ #7070 - rename of `instance` to indicate what it really means.\r\n  \/\/ This is simply the \"this\" context upon which the function was called.\r\n  thisContext: any,\r\n  \/\/ timestamp of function invocation\r\n  timestamp: number\r\n};\r\n```","I like it! Do we want a real timestamp, or just something relative to process startup? Depends on if we want higher precision than milliseconds","Looks like this is stalled (sorry, I've been afk)\r\n\r\nCan we wrap it up for Jest 24? What do we need?","@SimenB \r\n> Do we want a real timestamp, or just something relative to process startup?\r\n\r\nYou suggested using `browser-process-hrtime` previously: https:\/\/github.com\/facebook\/jest\/issues\/6672#issuecomment-404218660\r\n\r\nAnd there seemed to be agreement previously that time relative to process startup is sufficient.\r\n\r\n@rickhanlonii \r\n> Can we wrap it up for Jest 24? What do we need?\r\n\r\nUpdating the mock code itself to use the structures suggested in my previous comment would be easy. The harder parts are:\r\n* Updating all existing matchers and unit tests to work with the new structure (time consuming).\r\n* Updating documentation (time consuming).\r\n* Adding unit tests for the new timestamps (tricky because it involves timestamps).\r\n* Impact on #7070 needs to be decided. Easiest solution is replace the current `instances` with `MockInvocation.thisContext` (same behavior as current `instances`, but named\/documented correctly), while implementing `MockResult.newInstance` correctly (to match what people expect from the current naming of `instances`) requires depending on an ES6 feature: https:\/\/github.com\/facebook\/jest\/issues\/7070#issuecomment-434882343\r\n\r\nI could probably update the mock code and structures itself to help get it started, but I don't think I'll have time to deal with all the other \"harder parts\" I listed. My free time this winter is consumed by a project car.",">there seemed to be agreement previously that time relative to process startup is sufficient.\r\n\r\nSGTM.\r\n\r\n>Adding unit tests for the new timestamps (tricky because it involves timestamps).\r\n\r\nCan mock whatever module we use for timing and increment with `1` or something for each invocation","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 14 days.","> ```ts\r\n> type MockResult = { \r\n>   type: 'return' | 'throw', \r\n>   value: any,\r\n>   \/\/ timestamp of function completion\r\n>   timestamp: number,\r\n>   \/\/ #7070 - if we want to get fancy and correctly determine whether \r\n>   \/\/ the function is called with `new` and created a new instance\r\n>   newInstance: any \r\n> };\r\n> \r\n> type MockInvocation = {\r\n>   args: Array<any>,\r\n>   result: MockResult | void,\r\n>   \/\/ #7070 - rename of `instance` to indicate what it really means.\r\n>   \/\/ This is simply the \"this\" context upon which the function was called.\r\n>   thisContext: any,\r\n>   \/\/ timestamp of function invocation\r\n>   timestamp: number\r\n> };\r\n> ```\r\n\r\nOh.. That is beautiful. Let\u2019s not stale yet.\r\n\r\nI have noticed one funny issue with return types of `spyOn`. Looked around. This could help to solve.","This issue is stale because it has been open for 1 year with no activity. Remove stale label or comment or this will be closed in 30 days."],"labels":["Discussion",":rocket: Feature Request","Pinned"]},{"title":"Intercept process.stdout and process.stderr","body":"<!-- Thanks for submitting a pull request! Please provide enough information so that others can review your pull request. The two fields below are mandatory. -->\r\n\r\n<!-- Please remember to update CHANGELOG.md in the root of the project if you have not done so. -->\r\n\r\n## Summary\r\nFixes #6311.\r\n\r\nThoughts very much welcome on the implementation. I'm not particularly happy with it. I chose to keep it as a stream so that people doing `something.pipe(process.stdout)` in their code didn't break.\r\n\r\n<!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->\r\n\r\n## Test plan\r\nTests updated.\r\n\r\n<!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots \/ videos if the pull request changes UI. -->\r\n","comments":["@aaronabramov thoughts?","In particular, the case reported in #6311 now runs like this:\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/41790048-9abd038e-7651-11e8-8a06-10a012934c45.png)\r\n\r\nWith `--silent`:\r\n![image](https:\/\/user-images.githubusercontent.com\/1404810\/41790080-b22ba9c6-7651-11e8-90ee-a9c56483d662.png)\r\n\r\n(is it a bug that `silent` removes \"Ran all test suites matching \/test_scheduler.test.js\/i.\"?)","Seems like it broke colors in error output. Not sure why...\r\n\r\nEDIT: `isTTY` was changed. Copied it over.\r\n\r\nIt might be a better idea to just replace `write`? IDK","@mjesun these fail:\r\n\r\nhttps:\/\/github.com\/facebook\/jest\/blob\/d1ce3cd0135b5a8b64f84998fd5f36be4afb2bef\/packages\/jest-util\/src\/__tests__\/create_process_object.test.js#L25-L27\r\n\r\nThoughts? Just check that they're still streams?","i actually tried getting this into Jest a few times a while ago, but i think @cpojer had some strong opinions against it.\r\nthis one only affects the worker processes, and not the main, right?","Depending on how `process` is injected into it, yes. Right now it's a copy (and I just modify the copy) I think, but that can be changed","Rebased this, would love to land it","@cpojer do you have thoughts on this, strong or otherwise?","I am ok with it but I do want to point out that people have been upset about us re-routing `console` calls. I think I'm probably in favor of merging this, and adding a cli flag that will disable the re-routing for both `console` and `process.stdout\/stderr`. That way people can choose which one they prefer.","Yeah, that's a good idea. Unsure how we can make that happen without messing up when we clear lines to update status etc, but worth looking into","What's the status of this PR?","I've forgotten about it \ud83d\ude00 I'd like to get back to it at some point though","Might want to take a look at: https:\/\/github.com\/AtakamaLLC\/capio","Just spent almost an hour rebasing this across splitting up `jest-util` into multiple modules and rewriting to TS \ud83d\ude05 Will try to find the time to look into this soonish","Ping?"],"labels":["cla signed"]}]