[{"title":"Add a Threat Model","body":"This proposal is very open for debate and improvements, it is basically a fork from Node.js one (https:\/\/github.com\/nodejs\/node\/pull\/45223).\r\n\r\nI suggest you to review Node.js one first if you are not familiar with Threat models at all.\r\n\r\nThe main goal of this Threat Model is to provide a better support for Security Researches and for us on the triage. This Threat model can be considered as the \"playbook rules\" for reporting vulnerabilities into the project.\r\n\r\nNote: Only the Threat Model is in scope of this PR. The `security.md` has already existing elements that are going to change soon (see: https:\/\/github.com\/expressjs\/security-wg\/issues\/7), so please keep the focus on the target.\r\n\r\n\r\n**Context**\r\nFix https:\/\/github.com\/expressjs\/security-wg\/issues\/3\r\n\r\nYour feedback is more than appreciated: @bensternthal @ruddermann @ljharb @lirantal @mcollina @fraxken @expressjs\/security-wg @expressjs\/security-triage @expressjs\/express-tc ","comments":["I think this is a good starting point.","this looks great, just some small edit suggestions.  also, we should consider moving this to the `.github` repo, but this can be done later"],"labels":["docs","top priority","security"]},{"title":"Update release process documentation","body":"This is a new version for the documentation. It is based on the experience doing #5505 but with some tweaks. \r\n\r\n**Key assumptions**\r\n- We expect to use PGP to verify commits and releases (done by github mostly out-of-the-box)\r\n- We expect to land most of the changes into `master` branch and pick the relevant commits once doing a release\r\n- We can backport changes to the major branches (at any time) without managing releases so we avoid a lot of conflict management \r\n\r\n**Some notes**\r\n- This is based on the [Node.js release process](https:\/\/github.com\/nodejs\/node\/blob\/main\/doc\/contributing\/releases.md)\r\n- I don't think that this process is perfect, but it is an starting point that we can shape in the next releases for v4 and v4 and onboarding new releasers \ud83d\udc4d \r\n- I need to normalize the branches `4.x` and `5.x` in order to make this guide accurate (if you try to follow it in a fork o similar)\r\n- The current release process was not working (out-of-the-box) when @wesleytodd and I reviewed, but feel free to rescue things and propose more changes.\r\n- I will work on a separate Pr once this one is merged just to clarify how to do security releases, just to avoid having a mix guideline that can be more complex to follow.\r\n- From this PR is expected to extract a consolidated way on how to land PRs (see step 4) that we can isolate in a separate guide \"how to land PRs\" \ud83d\udc4d ","comments":["Great work, but I am not really convinced that the Express way \/ Node.js way is the good one here. \r\nI just have one major question here, why are we not switching to using github release to do all the \"hard work\"? I guess we need less process than Node.js itself - this is how fastify is [doing it it seems](https:\/\/github.com\/fastify\/fastify\/releases) - and how I do handle my releases at work\r\n\r\nA lot less maintenance, a lot less impact and manual workflow\r\n- clic on \"generate new release\"\r\n- choose your branche \"v5\"\r\n- setup your tag \"v5.3.2\"\r\n- clic on \"generate release note\" (update if you want)\r\n- done\r\n\r\nWe can discuss that when you want, but for me this would be simpler, and it would be the same process for all packages (not just express)","> I just have one major question here, why are we not switching to using github release to do all the \"hard work\"? \r\n\r\nWe actually do it on the step 7 (partially). If we work directly with the major branches we depend a lot on what is included there in terms of changes (minor, patch...) and it will be hard to select what we ship and when (specially thinking on v5\/v6\/v7 when we only have partial features, etc... \r\n\r\nAlso this can be challenging if we want to do just a security release fast (patching) as we will need to create more ad-hoc branches, etc... \r\n\r\n> We can discuss that when you want, but for me this would be simpler, and it would be the same process for all packages (not just express)\r\n\r\nAlso I don't expect this process to be the same for other libraries in the project.\r\n\r\n","> Also I don't expect this process to be the same for other libraries in the project.\r\n\r\nthat is my main issue, I am not seeing why this is not the same process. For me we should be able to deliver things quickly, like other framework that have multiple releases per months.\r\n\r\nAfter all, in my eyes, Express is just \"another library\" so why not follow a more traditional \/simplified way? (This process would be for the v5 - maybe not v4)\r\n\r\nI am not seeing that we should create a new version every day but even if we have a security update, then let's push what's already merged (that was reviewed and validated, so it should be working)\r\nEven if Express is huge, I don't think we need the same heavyness in the process than for a Node.js release. No specific need to announce before.\r\n\r\nWe could even say \"Hey, every Monday, if there is something new we do a release if not let's see in a week\". This way we have small and quick incremental changes.\r\nFor reference, back in the 2.x days Express had releases every couple weeks, some time even multiples times in the same week https:\/\/github.com\/expressjs\/express\/tags?after=2.5.9 ","Have y\u2019all consider using the semantic-release tooling? I\u2019m using it in [Hubot](https:\/\/github.com\/hubotio\/hubot\/blob\/bb636e20857f54926916f250ee9b2c63e224dd46\/.github\/workflows\/pipeline.yml#L103).","> Great work, but I am not really convinced that the Express way \/ Node.js way is the good one here.\r\n\r\nI think I agree with @sheplu on this, but I have to say seeing it in this form (as a pr changing existing docs) makes it REALLY hard to fully grok the differences. IMO this conversation would be a lot more clear it we had a plain issue write up of the proposal before a PR version. Because I am not sure we really have clarity on the differences and what the ideal even is, I feel like we should start with a *new* issue and outline 2 or 3 options for workflows we can compare.\r\n\r\n","thanks for all the feedback! I will work in an issue to present this version and a simpler one, so we can have a better high level discussion. \r\n\r\nAlso I need to include an step to update the website: (Ref: https:\/\/github.com\/expressjs\/expressjs.com\/pull\/1469)"],"labels":["docs","feedback"]},{"title":"add Github Access Structure Overview section","body":"Here's a first pass at adding a section about planned Org\/Repo access levels. \r\n\r\nThis doesn't spell out what _has changed_ or _will change_ about who has access. You can see some of the shaking out of dust in this issue https:\/\/github.com\/expressjs\/discussions\/issues\/132\r\n\r\nWe should document that somewhere, but I wanted to open a PR to land what I've seen proposed. \r\n\r\nI went with my own definitions and opinions here, and specifically am curious if I got the role for Committer correct re: access to a single repo vs all repos in an org. ","comments":["> I think we need some more work on this. I left a few initial questions but also I think we need to define what the team names are and likely what specific permissions they have. This should both be a doc for folks to understand what it means but also for us on how explicitly to manage it so we are all on the same page on how to do it.\r\n\r\nI left the team names out because naming is hard! I agree we should define names and specific perms\r\n\r\n[Github has built in roles](https:\/\/docs.github.com\/en\/organizations\/managing-user-access-to-your-organizations-repositories\/managing-repository-roles\/repository-roles-for-an-organization#repository-roles-for-organizations) that are close to what we want, but we should evaluate if we need deviations. I err on the side of running with the built in perms where possible and adjusting when necessary. \r\n\r\n<details><summary>an aside...<\/summary>\r\nre: evaluating deviations from the built in roles: e.g. Triagers can review\/approve\/reject PRs, but the reviews don't count towards merging, as approval by user w\/ write permissions is required. It's a nit, but PRs that don't get merged despite being approved by N folks w\/o write looks worse than a PR not merging bc it hasn't been approved at all. Taking away approval perms from Triagers is not a priority, but it is an example of a perm we could deviate on and a weak justification. Honestly, this is likely moot bc you can't create custom roles without having Github Enterprise\r\n\r\n<\/details>\r\n\r\nHere is a summary of the groups I outlined in the PR and what permissions I am suggesting:\r\n* [`@expressjs\/express-tc`](https:\/\/github.com\/orgs\/expressjs\/teams\/express-tc) (already exists) -- `owners` role on the org as defined in [github org permission docs](https:\/\/docs.github.com\/en\/organizations\/managing-peoples-access-to-your-organization-with-roles\/roles-in-an-organization#permissions-for-organization-roles) \r\n* `expressjs\/project-captain` -- no role assigned to the team beyond base org member role. Dunno if this team would be useful or not as permissions for maintaining a given repo will not be assigned at team level, but individually applied to user accounts. It would give an `@expressjs\/project-captain` mention ability, but I don't think see the need for pinging like 3-4 people who are captains, but not all commiters. Won't block on this. \r\n  *  Users will be individually assigned `admin` repo role as defined in [github repo permission docs](https:\/\/docs.github.com\/en\/organizations\/managing-user-access-to-your-organizations-repositories\/managing-repository-roles\/repository-roles-for-an-organization#permissions-for-each-role), per repo they are given project captain status for\r\n* `@expressjs\/committers` -- no role assigned to the team beyond base org member role (Im assuming that committers have write on a subset of repos and not all in the org, if it's all repos in the org then team based permissions would be appropriate). This one I actually do see as having everyone w\/ a commit bit, including TC, Project Captains, and Committers w\/ ad hoc write access. So you can just ping everyone with write. \r\n  * Users will be individually assigned `write` repo role as defined in [github repo permission docs](https:\/\/docs.github.com\/en\/organizations\/managing-user-access-to-your-organizations-repositories\/managing-repository-roles\/repository-roles-for-an-organization#permissions-for-each-role), per repo they are given committer status for\r\n* [`@expressjs\/triagers`](https:\/\/github.com\/orgs\/expressjs\/teams\/triagers) (already exists) -- `triager` role on each repo as defined in [github repo permission docs](https:\/\/docs.github.com\/en\/organizations\/managing-user-access-to-your-organizations-repositories\/managing-repository-roles\/repository-roles-for-an-organization#permissions-for-each-role)\r\n\r\n\r\n### Glossary for Above\r\n\r\n* team -- Github team, a named group of people which can be used to manage permissions\/access for people in an organization, sending notifications via @ mention, or requesting review from the team on PRs\r\n* role -- Github role, a set of built in permissions bundled under a specific name which can be assigned to a user or a team. There are different roles at the Org level and the Repo level\r\n* \"individually applied permission\" -- manually adding\/removing a role or specific permissions for a given collaborator's user account\r\n"],"labels":["docs","pr"]},{"title":"feature: add a GitHub action to quell spam PRs","body":"## Problem\r\nI was scrolling through Twitter and someone posted about [the spam PR](https:\/\/github.com\/expressjs\/express\/pulls?page=1&q=is%3Apr+is%3Aclosed+Readme.md). \r\n\r\n## Possible Solution\r\nImplement this [GitHub action](https:\/\/github.com\/marketplace\/actions\/mark-as-spam). It'll lessen the workload for maintainers. \r\n\r\n","comments":["I am not sure we need an action for this unless there is an action which does more than that one (like spam detection with ai or something). It is easy to delete\/close\/lock with as many clicks as it is to comment and we don't need an additional third party action (added security risk and maintenance) to do it right?","It's kinda scary that, Those idiots spamming PR's","I agree and we are actively removing their comments and blocking them. I wish that work was not necessary, and I appreciate y'all working to help with suggestions and feedback. We used to have a pretty active triage team in place, maybe we can revive that to be more active, and if we do you all are welcome to help!","> unless there is an action which does more than that one (like spam detection with ai or something)\n\nNot sure about AI spam detection, but almost all of these PRs update the readme, have default name (_Update filename_), change only a single line and have no description, so it should be rather easy to close them automatically.\n\nMost authors of these PRs have a repsitory called \"localrepo\", so that's another rule that could be used to detect spam from this source (Apna College).","Yeah this is a one-off issue of the day. Spam PRs have been a problem for years and they come in different varieties. This is why I am hesitant do add an action for this as I would rather ask GitHub for better spam management tooling.","I reported a couple users already for spam. But this is just mopping with the tap wide open. I hate how this impacts contributors their time.","Hey @wesleytodd. I found this on X: https:\/\/twitter.com\/github\/status\/1311772722234560517\r\nMaybe that could work?\r\n ","> This is why I am hesitant do add an action for this as I would rather ask GitHub for better spam management tooling.\r\n\r\nAgree with @wesleytodd. The issue is quite complex because the moderation in GitHub is not an easy thing:\r\n- Many people (those that are watching the repo) will receive a notification in their email or in the app\/web once a new PR is created. This will occur even before a Github Action is triggered. \r\n- Closing PRs is an easy action (1 click), so that is not a big time consumer\r\n- Detecting invalid PRs is not the big issue because you can easily to spot them with the practice.\r\n- Reporting issues\/users is complex because the UI requires many steps to do it for each user, so that is a blocker for many maintainers.\r\n- Nuke button like @CBID2 suggested is great when the community needs to slow down due a discussion\/flame in certain moments, but is not the long term solution as it will prevent other users from contributing (PRs) that are legit or need help (issues) while using Express.\r\n\r\nSo, I think that we are quite limited on how much we can do with GitHub actions in this case. There are other scenarios that are less frequent but more prone to use GitHub Actions to moderate, for example when people do comments that include offensive content or heavily language. In most projects that I am involved the moderation is done by the humans behind the project or a specific team that volunteer to do it, it is a heavy job. The same way as it is hard to keep a slack\/discord\/gitter community channel a safe space by moderating content.","> In most projects that I am involved the moderation is done by the humans behind the project or a specific team that volunteer to do it, it is a heavy job. The same way as it is hard to keep a slack\/discord\/gitter community channel a safe space by moderating content.\r\n\r\nI think historically the express project has not needed the same style of moderation as things like Node.js does. There have been less contentious discussions and mostly the CoC violations have come from folks outside the project so it was relatively simple to ban and move on. I don't think we need to immediately spin up a moderation team but I do think that the Triage team and TC should have the tools to properly moderate. Right now I don't think we have that well in hand. I believe that we can add this to the list of TODOs to address after we can get next weeks TC meeting organized and finished.\r\n\r\nAre we in agreement that a GH Action is most likely not the direction we would want to take to solve this problem?","> I believe that we can add this to the list of TODOs to address after we can get next weeks TC meeting organized and finished.\r\n\r\nYes, we can add it to the TODO list and start to work on it in few weeks\r\n\r\n> Are we in agreement that a GH Action is most likely not the direction we would want to take to solve this problem?\r\n\r\n+1 from me","Maybe a [pull reqest template](https:\/\/docs.github.com\/en\/communities\/using-templates-to-encourage-useful-issues-and-pull-requests\/creating-a-pull-request-template-for-your-repository) would make some people think before creating a PR?\nOn the other hand, it doesn't look like those who spam with pull requests will even bother to read it and they'll probably just click \"Create pull reqest\" with unedited description.","> I agree and we are actively removing their comments and blocking them. I wish that work was not necessary, and I appreciate y'all working to help with suggestions and feedback. We used to have a pretty active triage team in place, maybe we can revive that to be more active, and if we do you all are welcome to help!\r\n\r\nHow can we join the triage team?","> How can we join the triage team?\n\nhttps:\/\/github.com\/expressjs\/express\/blob\/master\/Contributing.md#becoming-a-triager\n","Doesn't need to stop the conversation, but since we specifically don't want to use a GHA to do this then this issue is complete. There are more threads to follow up on, but I think we can do that in other discussions more specific to those.","A workflow could be an option too, These spam PRs generally don't have more than 2-3 words. Closing PRs with less than 3 words sounds reasonable. GitHub too does something similar in it's documentation repository.  [GitHub's workflow](https:\/\/github.com\/github\/docs\/blob\/main\/.github\/workflows\/check-for-spammy-issues.yml)","> A workflow could be an option too, These spam PRs generally don't have more than 2-3 words. Closing PRs with less than 3 words sounds reasonable. GitHub too does something similar in it's documentation repository. [GitHub's workflow](https:\/\/github.com\/github\/docs\/blob\/main\/.github\/workflows\/check-for-spammy-issues.yml)\r\n\r\n@wesleytodd, I think you should reopen this issue. @gaurishhs made another point about using GitHub actions","I do agree that workflow is a bit more well suited IMO. I am still hesitant and I would like to also look at other ways but yeah in the mean time lets re-open the issue so we don't end up having multiple on the same topic or miss out on good ideas like @gaurishhs'.","even one more  better thing is maximum spam pr revolve around README.md ,if we can specify to block those pr updating readme for now (upto the  spam pr's get less) we can  handle this through github actions for this so that good pr's may not effect.","Is it possible to have the workflow also incorporate a check for new contributors when doing the x words check? I feel like that people who contributed, and already have code merged, in the past do not pose much of a threat in regards to spam. Or am I overthinking it?","> Is it possible to have the workflow also incorporate a check for new contributors when doing the x words check? I feel like that people who contributed, and already have code merged, in the past do not pose much of a threat in regards to spam. Or am I overthinking it?\n\nI don't think you're overthinking it @TimGels. Previous contributors should be spared in some way. ","I think the workflow should be something like this:\r\n\r\nThe expressjs member check can be omitted \/ replaced with a collaborator check \r\n![image](https:\/\/github.com\/expressjs\/express\/assets\/78847111\/b849b627-fd97-49a5-ba21-1a1af54c4147)\r\n","> I think the workflow should be something like this:\r\n> \r\n> The expressjs member check can be omitted \/ replaced with a collaborator check ![image](https:\/\/private-user-images.githubusercontent.com\/78847111\/303097006-b849b627-fd97-49a5-ba21-1a1af54c4147.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MDczMzY3OTAsIm5iZiI6MTcwNzMzNjQ5MCwicGF0aCI6Ii83ODg0NzExMS8zMDMwOTcwMDYtYjg0OWI2MjctZmQ5Ny00OWE1LWJhMjEtMWExYWY1NGM0MTQ3LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDAyMDclMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwMjA3VDIwMDgxMFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWQxNGFlMzJkOTczNjRkMTk5OGFlMjAxMzEzMTc0ZWQzN2JjOTE4MmQ1MzVhMzBhZWViZDA2MDEyOWRiMjkzYTEmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.UiIggnRUVhRL7WH6ZnJQ_BINPfT97aKWrNLIEPMwALs)\r\n\r\nI don't think word count matters because some bugs only requires a minimal changes. ","And if word count check is added, they must find some other way to open spam prs. The problem here is those who make spam prs, they just started their development journey and when they got introduced to github (by some youtubers or some articles), they tried to test it by themselves. They didn't have any idea that the thing they are doing is a headace of someone else.\r\n\r\n**The only way we can stop this is by creating awarness.**\r\n","> And if word count check is added, they must find some other way to open spam prs. The problem here is those who make spam prs, they just started their development journey and when they got introduced to github (by some youtubers or some articles), they tried to test it by themselves. They didn't have any idea that the thing they are doing is a headace of someone else.\n> \n> \n> \n> **The only way we can stop this is by creating awarness.**\n> \n> \n\nTrue, but knowing that there those who create spam PRs out of malice, raising awareness is not enough. Protective measures are a must too. ","> > And if word count check is added, they must find some other way to open spam prs. The problem here is those who make spam prs, they just started their development journey and when they got introduced to github (by some youtubers or some articles), they tried to test it by themselves. They didn't have any idea that the thing they are doing is a headace of someone else.\r\n> > **The only way we can stop this is by creating awarness.**\r\n> \r\n> True, but knowing that there those who create spam PRs out of malice, raising awareness is not enough. Protective measures are a must too.\r\n\r\nThere are Rest APIs for getting the info of prs and also for actions. Making a bot which can automate spam pr closing using those rest apis can help. But not sure how to detect spam.","Hello! While I may not possess your level of genius, I've got an idea. Can we utilize NLP in Python code to detect significant changes in a `Readme` file solely through a GitHub Action?","I think we should try my suggestion for now and then do more afterwards. We must take some form of action quickly ","Hello team!\r\nA quick action could be to limit who can submit a PR while there is no action to filter PR spamming.\r\n\r\ngithub provide a settings to limit temporarly the submitted PR for a determined duration (maybe one week) for an external contributor:\r\nhttps:\/\/twitter.com\/github\/status\/1311772722234560517\r\nhttps:\/\/github.com\/orgs\/community\/discussions\/22804\r\n(in this case only express team member can submit a PR)\r\n\r\nI know isn\u2019t aligned with open source phylosophy but it can stop this PR spamming cycle quickly while waiting for a real solution. Maybe when they see that it no longer works, the followers of the video will ask the YouTuber for explanations :)\r\n\r\nAnother solution, is to check if a PR have a commit related to an open issue on the same repo. If not the github action xill close automatically the PR.\r\n\r\nsee you\r\n","I really feel pensive seeing all these PRs come from literally \"tech youtubers\" who don't use basic common senses before uploading a video, I apologize on their behalf \ud83d\ude4f .","> spam detection with ai\r\n\r\nThis seems like a pretty cool project idea, someone should DEFINITELY put something like this into place to help with spam hell for open-source maintainers. ","Hello team,\r\n\r\nSpent few hours learning about GitHub actions and came up with this rule-based spam PR detection action which automatically closes the PR based on user-configurable rules.\r\n\r\nI have setup few rules like detecting the default commit message for `README.md` and also if the pull request template has been updated with the details. It can be easily extended to prevent this PR havoc and future misuses.\r\n\r\nCheck it out here: https:\/\/github.com\/animesh-chouhan\/github-spamstop","@animesh-chouhan The action certainly is a decent idea, however I don't think a simple check of whether a default `README.md` change commit exists in a PR would be enough to prevent such spam. I feel like we should have a greater set of rules to check against, such as how active the said user is on GitHub, whether they've contributed to different repositories, etc.","> @animesh-chouhan The action certainly is a decent idea, however I don't think a simple check of whether a default `README.md` change commit exists in a PR would be enough to prevent such spam. I feel like we should have a greater set of rules to check against, such as how active the said user is on GitHub, whether they've contributed to different repositories, etc.\r\n\r\n@CompeyDev Yeah it is upto the repository owner to configure rules. I have just provide a template and added basic rules just to give an idea. More complex rules can be added depending on the requirement. ","So can we get started?","Hey Everyone, lots going on in here but I suggest we take a beat and pause here. I don't think anyone currently on the contributor, triager, or TC roles really want's an action for this (if anyone in those groups disagrees please correct me). Closing PRs from legitimate users is a bad experience, and avoiding that should be a goal which is hard to do with any automated tooling. This idea is more of a \"last resort\" than an ideal solution.\r\n\r\nTo update folks on the status:\r\n\r\n1. We added Issue templates and will be adding PR templates which will hopefully warn folks against opening spam prs\r\n2. We have reached out through more official ways to the video creators about editing the video to reduce the likelyhood of causing accidental spam\r\n3. Medium term we will likely attempt to get the Triage Team's help for this, but we are not going to do much of that until we sort out a few other things\r\n4. We are continuing to close and locking the spam PRs\r\n\r\nAll that said, if folks could **please STOP directly mentioning maintainers in these PRs (or in any other fashion)** that would be great. We are watching the repos and are well aware without the direct ping's, they are only causing more notification spam. ","> Hey Everyone, lots going on in here but I suggest we take a beat and pause here. I don't think anyone currently on the contributor, triager, or TC roles really want's an action for this (if anyone in those groups disagrees please correct me). Closing PRs from legitimate users is a bad experience, and avoiding that should be a goal which is hard to do with any automated tooling. This idea is more of a \"last resort\" than an ideal solution.\r\n> \r\n> To update folks on the status:\r\n> \r\n> 1. We added Issue templates and will be adding PR templates which will hopefully warn folks against opening spam prs\r\n> 2. We have reached out through more official ways to the video creators about editing the video to reduce the likelyhood of causing accidental spam\r\n> 3. Medium term we will likely attempt to get the Triage Team's help for this, but we are not going to do much of that until we sort out a few other things\r\n> 4. We are continuing to close and locking the spam PRs\r\n> \r\n> All that said, if folks could **please STOP directly mentioning maintainers in these PRs (or in any other fashion)** that would be great. We are watching the repos and are well aware without the direct ping's, they are only causing more notification spam.\r\n\r\nSounds wonderful @wesleytodd! :) I'm going to join the triage team to offer more ideas","Could Github not implement something like stack overflow? (like you need some amount of rating before you could file a PR on a Repo which is a little old, maybe 10-20 commits)","I'm an open source contributor on other projects, I stumbled upon a video explaining what was going on.  Unfortunately this project has become part of a video to teach people how to make github pull requests to open source projects (https:\/\/www.youtube.com\/watch?v=Ez8F0nW6S-w),  Do as I did and report this video to try and get it taken down. Whilst not harmful content its damaging \"misinformation\" after which I gave a description why. (if enough people complain then maybe it can be forced to remove it and that might help, but this video has 1.4M views so be prepared for the number of PRs to keep coming in (pretty much forever and fast)\r\n\r\n I'm not a github expert maybe there is a way to prevent submission of the PR ahead of time if it doesn't contain a github issue, or maybe a \"bug\/enhancement\/contributor label\" , other projects I've worked on you need to be a member of a \"virtual\" organization (e.g. expressjs community), but you can easily join that organization by raising a ticket, a moderator can adds people to that orginization. Nothing would stop contributors creating their own commits in their own forks, but they couldn't then send you their PRs unless they were part of your organization. \r\n\r\nSorry just trying to help, feel bad for you all.\r\n\r\n```yaml\r\nname: Prevent PR submission from non-organization members\r\n\r\non:\r\n  pull_request:\r\n    types:\r\n      - opened\r\n      - synchronize\r\n\r\njobs:\r\n  validate_pr:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Check if PR author is organization member\r\n        uses: actions\/github-script@v4\r\n        with:\r\n          script: |\r\n            const { owner, repo } = context.repo;\r\n            const { login } = context.payload.pull_request.user;\r\n\r\n            const { data: orgMembers } = await github.rest.orgs.listMembers({\r\n              org: owner,\r\n            });\r\n\r\n            const isMember = orgMembers.some((member) => member.login === login);\r\n\r\n            if (!isMember) {\r\n              core.setFailed(`PR author is not an organization member: ${login}`);\r\n            }\r\n        env:\r\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}```","I keep getting email notifications so I figured I would contribute something to the conversation. From my reading of the spam PR's, a lot of them add their own name to the commit. Perhaps a regex to detect if the diff consists of only any variation of username, along with the title \"Update README.md\" would filter at least 60% of the spam PRs.  You don't need to use AI for this","Heya! An update on my last comment: I think I'll be working on an AI based spam detector for use-cases like this, which would analyze diff files of PRs and conclude whether it is worthwhile to keep or not. Will update with progress on that here if y'all would like that.","> Heya! An update on my last comment: I think I'll be working on an AI based spam detector for use-cases like this, which would analyze diff files of PRs and conclude whether it is worthwhile to keep or not. Will update with progress on that here if y'all would like that.\n\nI'd like that ","> Heya! An update on my last comment: I think I'll be working on an AI based spam detector for use-cases like this, which would analyze diff files of PRs and conclude whether it is worthwhile to keep or not. Will update with progress on that here if y'all would like that.\r\n\r\nYou don't need AI for this. How are you going to approach this?","> > Heya! An update on my last comment: I think I'll be working on an AI based spam detector for use-cases like this, which would analyze diff files of PRs and conclude whether it is worthwhile to keep or not. Will update with progress on that here if y'all would like that.\r\n> \r\n> You don't need AI for this. How are you going to approach this?\r\n\r\nI agree with @QuantGeekDev, detecting this kind of spam is relatively easy and using AI would be an overkill. A simple rule-based approach will work well in this case: https:\/\/github.com\/animesh-chouhan\/github-spamstop\/blob\/main\/index.js#L48-L66\r\n\r\nThis uses a pull-request template which needs to be edited with the details of the change which would easily deter a large amount of such PRs.\r\n\r\nPR template: https:\/\/github.com\/animesh-chouhan\/github-spamstop\/blob\/main\/.github\/pull_request_template.md","Yep. I agree, too. A pull request template would be best to fight these spam pull requests.","I just stumbled upon a tweet about a problem that seems identical to the Binod virus that surfaced a few years ago. It's high time that GitHub takes notice of this new issue. Repositories like these should have a strict set of criteria or credibility requirements for contributors. It's imperative to understand that libraries like these are fundamental building blocks of the web ecosystem, and such issues only hinder progress.","Honestly, the only way to qwell this issue is to ask the person who [originally posted a github tutorial on youtube](https:\/\/www.youtube.com\/watch?v=Ez8F0nW6S-w) to pull down her video and reupload it without the ExpressJS bits in the very end. Otherwise, it may keep happening in the future. Honestly not a big ask. I think the express team should get in contact and ask them to do so. They are a medium size coding tutor platform so it should not be a crazy ask. Their contact and other details are available on their website. ","You could probably block 99% of the spam by checking the IP address from which it came. Dunno how to do that, though.","> You could probably block 99% of the spam by checking the IP address from which it came. Dunno how to do that, though.\r\n\r\nBlocking PRs based on IP address isn't a solution because 1. Different people are making these spam PRs so IP addresses are different, 2. If you meant IP range that targets some region, then it can result in legit PR getting blocked.","A PR template with some automation seems good to me . We can check for the change in description . Most of these student dont care to change description , so if a PR is opened with the template as it is without any change then most probably it is spam and a action or any automation could be used to close it .","A way to do this, I think, would be to check diffs and auto-close one without substantial changes\r\n\r\n> checking the IP address from which it came.\r\n\r\nDon't think seeing ips is possible thru github\r\n\r\nFeb 11, 2024 1:27:48 AM Rishabh Bohra ***@***.***>:\r\n\r\n> \r\n> A PR template with some automation seems good to me . We can check for the change in description . Most of these student dont care to change description , so if a PR is opened with the template as it is without any change then most probably it is spam and a action or any automation could be used to close it .\r\n> \r\n> \u2014\r\n> Reply to this email directly, view it on GitHub[https:\/\/github.com\/expressjs\/express\/issues\/5449#issuecomment-1937489364], or unsubscribe[https:\/\/github.com\/notifications\/unsubscribe-auth\/AV2UYYYQLESIVVNMLT6SGJTYTCFILAVCNFSM6AAAAABC4M772OVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMZXGQ4DSMZWGQ].\r\n> You are receiving this because you are subscribed to this thread.\r\n> [Tracking image][https:\/\/github.com\/notifications\/beacon\/AV2UYY4TQ2OHBPWHV55C77DYTCFILA5CNFSM6AAAAABC4M772OWGG33NNVSW45C7OR4XAZNMJFZXG5LFINXW23LFNZ2KUY3PNVWWK3TUL5UWJTTTPO65I.gif]\r\n> \r\n","> We have reached out through more official ways to the video creators about editing the video to reduce the likelyhood of causing accidental spam.\r\n\r\n> the only way to qwell this issue is to ask the person who originally posted a github tutorial on youtube to pull down her video and reupload it without the ExpressJS bits in the very end.\r\n\r\nProbably not going to happen. Based on their post in their Instagram broadcast channel, they feel they did everything right, and they are calling us a bunch of bullies and whiners.\r\n\r\n[Click here to see a screenshot of the channel.](https:\/\/github.com\/expressjs\/express\/assets\/6047296\/30077167-3e1c-4d5e-a062-70bc6e3b3237)\r\n\r\nThis is so unfortunate for the open source community.\r\n\r\n> without substantial changes\r\n\r\nOne of the spam PRs replaced the entire Readme file with junk text. It is a substantial change.","@ADTC is any of this on a public link? I don't have an Instagram account but would be interested in reading links if they are available. Screenshots just don't seem to provide enough context to interpret what she is saying in that post.","@wesleytodd there isn't much on the channel related to this topic. She posted a copy of the tweet, made her comment and started the poll. That's all.\r\n\r\n[Here's the screenshot with the tweet.](https:\/\/github.com\/expressjs\/express\/assets\/6047296\/84126115-d1f2-4bbd-a2dc-9364a4680958)\r\n\r\n\r\nYou can't access the channel without an Instagram account. Here's a link though: https:\/\/ig.me\/j\/AbagxilRJ7KwLyaD\/\r\n\r\nPS: last ditch effort would be to create a new repo and lock this repo as read only. Post a notice sign posting the new repo.","Thanks for the help, we reached out via more formal methods and have not heard anything back afaik so just wanted to check if this had any added context on the situation.\r\n\r\nI am going to take a pass pretty soon on this thread to mark a lot of the comments in here as \"off topic\", so please don't take offense, but this is all really off topic conversation.","Really, I think you could probably just reject anything with \"update: '<filename>'\" as a PR title, I don't think that would be too disruptive for normal PRs.","Maybe we can add a PR template when people want to issue a PR \n\nIt is probably as this people won't be able to know how to change basic things in the PR template","Most of them can be auto-closed if they meet all of the below criteria:\r\n\r\n1. PR has only one commit.\r\n2. Commit changes only one file.\r\n3. Commit has a message subject matching regex `Update [^ ]*\\.[^ ]+` (match is for all file names generally).\r\n4. Commit has no message body.\r\n\r\nThis should auto-close almost all of them. Maybe 1 or 2 every month may not match, but it's much less work to manually check and close them.\r\n\r\nPS: The regex match should be on commit subject, not PR title because the newbie spammers are more likely to change the title.\r\n\r\nFor fun: Close them with a cheeky comment: Congrats! You are now an open source spam contributor. Now learn how to make real contributions and your training will be complete. [Add a Hindi translation of the same.]","I think we can get auther (who made PR) total lifetime PR count if it is more then 10 or whatever we can prevent that ?  \r\n\r\n\r\nlike this \r\n\r\n```sh\r\nname: Spam Detect\r\n\r\non:\r\n  pull_request:\r\n    types:\r\n      - opened\r\n\r\njobs:\r\n  check_author_pr_count:\r\n    runs-on: ubuntu-latest\r\n\r\n    steps:\r\n    - name: Checkout code\r\n      uses: actions\/checkout@v2\r\n\r\n    - name: Set up Node.js\r\n      uses: actions\/setup-node@v4\r\n      with:\r\n        node-version: '14'\r\n\r\n    - name: Install dependencies\r\n      run: npm install github-api\r\n\r\n    - name: Count Merged PRs\r\n      id: pr_count\r\n      run: |\r\n        AUTHOR=$(curl -sSL https:\/\/api.github.com\/repos\/${{ github.repository }}\/pulls\/${{ github.event.pull_request.number }} | jq -r '.user.login')\r\n\r\n        MERGED_PR_COUNT=$(curl -sSL -H \"Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}\" \"https:\/\/api.github.com\/search\/issues?q=is:pr+author:$AUTHOR+is:merged\" | jq -r '.total_count')\r\n        \r\n        echo \"merged_pr_count=$MERGED_PR_COUNT\" >> $GITHUB_OUTPUT\r\n\r\n    - name: Check PR Count\r\n      run: |\r\n        if [[ \"${{ steps.pr_count.outputs.merged_pr_count }}\" -gt 20 ]]; then\r\n          echo \"PR count is greater than 20. Proceed with the workflow.\"\r\n        else\r\n          echo \"PR count is not greater than 20. Blocking the PR.\"\r\n          exit 1  \r\n        fi\r\n```\r\n\r\nthis is it's test https:\/\/github.com\/Kamleshpaul\/github-spam-action-test\/pulls","> I think we can get auther (who made PR) total lifetime PR count if it is more then 10 or whatever we can prevent that ?  \n\nThey already made a github action which takes care of this ","Well, it looks like the issue will be solved when the pr is merged","Hey folks, just to update you: We have a thread open with GitHub support where they are passing along our requests to the various product teams on how to improve the moderation features. I personally am still \ud83d\udc4e on an action which auto closes PRs as it is both a maintenance burden and something best handled by features on GitHub's side. We are focused right now on landing some governance changes and will be following up with re-constituting the triage team. I think ideally this decision is left up to the triage team members. So likely there will not be action on this or the PR until we can get that team organized again. If you are interested in helping that please follow the instructions to get involved there (as some of you already have, thank you very much for that). ","They have slowed down too for the time being, the last one already is two days old.","> > unless there is an action which does more than that one (like spam detection with ai or something)\r\n> \r\n> Not sure about AI spam detection, but almost all of these PRs update the readme, have default name (_Update filename_), change only a single line and have no description, so it should be rather easy to close them automatically.\r\n> \r\n> Most authors of these PRs have a repsitory called \"localrepo\", so that's another rule that could be used to detect spam from this source (Apna College).\r\n\r\nThe flood of pull requests (PRs) occurred due to individuals learning about Git and GitHub from a specific YouTube video \r\n\r\nhttps:\/\/youtu.be\/Ez8F0nW6S-w?t=4323\r\n\r\nIn the video, the presenter demonstrated how to contribute to open-source projects using the Express repository as an example. While the video emphasized creating PRs for meaningful changes only, the majority of the audience consisted of beginners unfamiliar with GitHub and community guidelines. Consequently, many blindly followed the steps outlined in the tutorial, resulting in an overwhelming influx of PRs.\r\n","Thanks @nkroker, please read above as that topic has been covered quite a few times. I will mark this as off topic but thanks for the well intentioned help."],"labels":["ideas"]},{"title":"Add dependabot","body":"### Main Changes\r\n\r\nThe dependabot will check for available updates for the dependencies that we use in the project. In the current setup it will generate PRs once per week if the are new versions for our dependencies (npm and Github Actions).\r\n\r\nWe can remove npm and limit it to Github Actions, as well we can modify the frequency.\r\n\r\nThe dependabot is capable of follow the pin version schema introduced in https:\/\/github.com\/expressjs\/express\/pull\/5432, so it will be able to upgrade and pin the GIthub actions accordantly.\r\n\r\nThe configuration is very flexible, see the [documentation](https:\/\/docs.github.com\/en\/code-security\/dependabot\/dependabot-version-updates\/configuration-options-for-the-dependabot.yml-file)\r\n\r\n\r\n### Context\r\n- Ref: https:\/\/github.com\/expressjs\/security-wg\/issues\/2\r\n- Report: https:\/\/kooltheba.github.io\/openssf-scorecard-api-visualizer\/#\/projects\/github.com\/expressjs\/express\/commit\/2a00da2067b7017f769c9100205a2a5f267a884b\r\n\r\n### Changelog\r\n\r\n- 8e81a04 chore: add dependabot tool by @UlisesGascon\r\n\r\n\r\n\r\n","comments":["@UlisesGascon you can also set pull request limit and timezone, that would be nice!","> @UlisesGascon you can also set pull request limit and timezone, that would be nice!\r\n\r\nFeel free to add [a suggestion](https:\/\/docs.github.com\/en\/pull-requests\/collaborating-with-pull-requests\/reviewing-changes-in-pull-requests\/commenting-on-a-pull-request#adding-comments-to-a-pull-request) in the PR directly @shivam-sharma7 \ud83d\udc4d ","Hey, I just wanted to drop a note in here (I haven't had time to review yet) but we had talked about different approaches to dependency updates for `express` in the past and this approach does not align with the previous decisions on how we should do this. Once we get a regular cadence of meetings going and get over the hump of kicking everything back off I think we should address this, but I believe that it will take some discussion and alignment. Just didn't want folks to get frustrated if this sat for a while without clarity. "],"labels":["pr","deps","tsc-agenda"]},{"title":"HTTP2 insecure server crashes every time.","body":"I am trying to write an insecure HTTP2 web server. However it crashes on any inputs.\r\n\r\nI need an insecure HTTP2 server. Here's my code:\r\n\r\n```typescript\r\nimport { createServer } from 'node:http2';\r\n\r\nimport createExpressApp from 'express';\r\nimport http2ExpressBridge from 'http2-express-bridge';\r\n\r\n\/\/ Test with: curl --insecure -v -k --http2-prior-knowledge \"http:\/\/[::]:8080\"\r\nfunction main(): void {\r\n  const app = http2ExpressBridge(createExpressApp);\r\n\r\n  app.get('*', (request, response) => {\r\n    response.setHeader('Content-Type', 'text\/plain');\r\n    response.status(200);\r\n    response.write('Server reached');\r\n    response.end();\r\n  });\r\n\r\n  const server = createServer(app);\r\n\r\n  server.listen({ port: 8080 });\r\n\r\n  \/\/ Triggered by CMD\/CTRL + C .\r\n  process.on('SIGINT', () => {\r\n    server.close();\r\n    process.exit(0);\r\n  });\r\n}\r\n\r\ntry {\r\n  main();\r\n} catch (error) {\r\n  console.error(error);\r\n  process.exit(1);\r\n}\r\n```\r\n\r\nI'm testing using ` curl --insecure -v -k --http2-prior-knowledge \"http:\/\/[::]:8080\"`\r\n\r\nEvery time I execute it, the server crashes with:\r\n\r\n```text\r\n> tsx src\/example\/http2BugRepro.ts\r\n\r\nnode:events:492\r\n      throw er; \/\/ Unhandled 'error' event\r\n      ^\r\n\r\nTypeError: Cannot read properties of undefined (reading 'readable')\r\n    at IncomingMessage._read (node:_http_incoming:214:19)\r\n    at Readable.read (node:internal\/streams\/readable:547:12)\r\n    at resume_ (node:internal\/streams\/readable:1048:12)\r\n    at process.processTicksAndRejections (node:internal\/process\/task_queues:82:21)\r\nEmitted 'error' event on IncomingMessage instance at:\r\n    at emitErrorNT (node:internal\/streams\/destroy:151:8)\r\n    at errorOrDestroy (node:internal\/streams\/destroy:214:7)\r\n    at Readable.read (node:internal\/streams\/readable:549:7)\r\n    at resume_ (node:internal\/streams\/readable:1048:12)\r\n    at process.processTicksAndRejections (node:internal\/process\/task_queues:82:21)\r\n```\r\n\r\nWhen I add an SSL certificate and use `createSecureServer` everything works fine. But when I use `createServer` it crashes. \r\n\r\nI think it's a bug in `express` or `http2-express-bridge` because without specifying the app, and handling the stream directly produces no errors.\r\n\r\nMy info:\r\n\r\n```\r\nOS: MacOS\r\nNode: 20.9.0\r\nExpress: I tried v5.0.0-beta and v4.18.2\r\nhttp2-express-bridge: 1.0.7\r\n```\r\n\r\nThank you.","comments":["Small correction: This fails for secure servers in express 5 as well. Different stack though:\r\n\r\n```\r\n TypeError: Cannot read properties of undefined (reading 'readable')\r\n    at IncomingMessage._read (node:_http_incoming:214:19)\r\n    at Readable.read (node:internal\/streams\/readable:547:12)\r\n    at resume_ (node:internal\/streams\/readable:1048:12)\r\n    at process.processTicksAndRejections (node:internal\/process\/task_queues:82:21) \r\nTypeError: Cannot set properties of undefined (setting 'content-security-policy')\r\n    at ServerResponse.setHeader (node:_http_outgoing:661:45)\r\n    at Immediate.write (\/somepath\/web-platform\/node_modules\/finalhandler\/index.js:285:9)\r\n    at process.processImmediate (node:internal\/timers:480:21) \r\n```","I will suggest to open an issue on http2-express-bridge, It seems that the issue might be related to the library.","Because Express.JS cannot work with HTTP\/2 natively, and ``http2-express-bridge`` is no longer maintained. If you really need the extra efficiency provided by HTTP\/2, then switching to something like ``fastify`` makes more sense.","i would not mind contributing to create a separate version of express that works with HTTP2, backwards compatibility be damned.\r\n\r\ni would also not mind authoring the change if we can get about $10k-20k into a kickstarter for it.  seems suitable and would likely deliver a lot more back to the community.","It would be awesome if HTTP\/2 ever gets added to ``express.js``! Though, if you are asking for money from kickstarters to kick off the process, I guess:\r\n\r\n1. Others (Springboot, Fastify, even nginx!) have done it and are available to the public for free. You might need a convincing story to get this money, good luck!\r\n2. Actually, ask IBM and StrangeLoop to see if they will offer the money or simply a position at their companies! This will definitely catch their attentions! ","Yeah, well, a startup I consulted for ran out of cash in December and I need a job :)\r\n\r\nBut no, I also want to see this happen.  The last company I worked at informally sponsored Matteo you could say to continue working on Fastify.  I could go to them, but this seems like it would stir some pots.  If not them, a similar organization.\r\n\r\nI am sitting on a large monorepository solution without a safe way to go to market without getting ripped off by Vercel, the powers and IP thiefs at large.  This seems like a reasonable way to gain some notoriety and while I seriously would just sit down for 3-6 months and do this, I burned out my bank account.\r\n\r\nI authored hot reloading in express without doing a server reload on top, and helping with HTTP2 could build trust to push this and similar changes into Express v5 as a PR(s).  I do more stuff that allows route repositioning and declarative route ordering across a monorepository (where construction of route order is not always known in advance).  Basically I have done a lot of additional work to make route positioning more dynamic that might be interesting to propose into Express.\r\n\r\nThis is me, inventing a job for myself.  Scratching at the food line.  This is tech.","See PR : https:\/\/github.com\/expressjs\/express\/pull\/3730\r\n\r\nI can pick up where this one left off (6 years ago!).. speed in Express is important to me.","> See PR : #3730\r\n> \r\n> I can pick up where this one left off (6 years ago!).. speed in Express is important to me.\r\n\r\nHey! Can I join you? I'd love to work on this with you","Yes let's chat @QuantGeekDev i added you in LI"],"labels":["awaiting more info"]},{"title":"Do not auto-remove content headers for body-less status codes","body":"According to [RFC 2616 (HTTP\/1.1 spec)](https:\/\/datatracker.ietf.org\/doc\/html\/rfc2616#page-54) a `HEAD` request is supposed to return *exactly* the same entity-headers as a `GET` request but no body, ~~imho responding to such a request with a 204 status code seems reasonable, thus we should not remove any headers but only ensure that no body is sent.~~","comments":["I did some more digging and in fact [RFC 7230](https:\/\/datatracker.ietf.org\/doc\/html\/rfc7230#section-3.3.2) specifies the following:\r\n\r\n> Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response\r\n\r\n> A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request\r\n\r\n> A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).\r\n\r\nSo I altered my changes (and adjusted the unit tests) to be compliant to that, so that with a 304 we leave the content-headers untouched, but on 204 we remove them. ","write clean code"],"labels":["pr"]},{"title":"Split the examples from this repo","body":"I was thinking that maybe makes sense to separate the examples from this repo.\r\n\r\nThere are some cases when CVEs impact some of the examples and the dependencies upgrade are incompatible with the CI (see: https:\/\/github.com\/expressjs\/express\/pull\/5237).\r\n\r\nWhat do you think? (cc: @dougwilson @expressjs\/triagers )","comments":["Ya, I agree. I believe there is an issue about this somewhere. There are a bunch of code paths only exercised by the examples, which is why they have not been split. We need to replicate  the gaps into our tests directly so we can move the examples to a diff repo and not rely om their tests here for code coverage.","I can create a repository (fork express) and clean up the repo to keep only the examples and the related tests (without breaking Git History). Then we can migrate that repo to the expressjs org.\r\n\r\nThat way we can move the PRs that are related to the examples without breaking the contributors experience. Also we can tweak the CI pipeline to use current\/LTS Node.js versions and latest Express version.\r\n\r\nCan I start working on this @dougwilson?","Sure! I wouldn't bother trying to keep all this repo history in there. Just a clean repo is fine. Just a copy of what is in master and their tests ro start and then we can iterate from there. I made https:\/\/github.com\/expressjs\/examples let me know if u cannot make a pr against an empty repo and I can add a readme","I just created this PR https:\/\/github.com\/expressjs\/express\/pull\/5311 and this repo https:\/\/github.com\/ulisesgascon\/express-examples\/. I will give you admin access so you can migrate it to the org as https:\/\/github.com\/expressjs\/examples. Sorry for the mess \ud83d\ude05 ","@dougwilson you can use [this link](https:\/\/github.com\/UlisesGascon\/express-examples\/invitations) to access to my repo as admin so you can transfer it.\r\n\r\n\r\nAlso I can ask for a transfer using the GIthub UI:\r\n\r\n![Screenshot 2023-11-20 at 12 40 30](https:\/\/github.com\/expressjs\/express\/assets\/5110813\/5b526649-42a3-4f92-95a9-e06d6f4b640e)\r\n\r\nlet me know if what you prefer."],"labels":["discuss","ideas"]},{"title":"CVE-2022-21681. updated marked, disable unsupported opts","body":"### CVE Link \ud83d\udd17\r\n\r\n[CVE-2022-21680](https:\/\/github.com\/advisories\/GHSA-rrrm-qjm4-v8hf)\r\n[CVE-2022-21681](https:\/\/github.com\/advisories\/GHSA-5v2h-r2cx-5xgj)\r\n\r\n### Notes \u270d\ufe0f\r\n\r\n- `marked` was updated - [link](https:\/\/www.npmjs.com\/package\/marked);\r\n- Unsupported options were disabled;","comments":["This is just used in two examples, and the version upgraded here is not compatible. I see the fix is available a few majors before 6, can you try only upgrading the dep to the minimal fixed version to see if that is sufficient? Otherwise we may need to find a new dep for those examples or change the examples to something else."],"labels":["examples","pr"]},{"title":"remove array-flatten dependency, no longer necessary","body":"replaced array-flatten dependency with the new flat() method from JavaScript, which is supported in Node.js version 11.0.0 and above. This simplifies the code and reduces the number of dependencies","comments":[],"labels":["pr","deps"]},{"title":"Use of name 'express' in JSX template engine name","body":"I'm soon to release a JSX based template engine for Express (powered by [NakedJSX](https:\/\/nakedjsx.org)), and I've tentatively named it @nakedjsx\/express-jsx. I have opened this issue to ask whether you are comfortable with this use of the name 'express'.\r\n\r\nOf course, 'express-jsx' by itself wouldn't be appropriate as it would create confusion about who made it. But perhaps given that it would live under the @nakedjsx org, the name used in all practical contexts would be the combined '@nakedjsx\/express-jsx' which I like because it makes two things clear:\r\n\r\n1. It's not an official Express project\r\n2. It's a thing made by @nakedjsx that probably adds JSX to Express.\r\n\r\nWhat are your thoughts?","comments":["Hi @dqh-au thank you for reaching out on this, it is appreciated.\r\n\r\nSo my understanding of what you are saying is that there would be a module named `@nakedjsx\/express`, is that right? I don't see any issue with that, at least I have no issue with such a name :) . Additionally, if you are saying that within NakedJSX (and sorry, I am reading about it now to get more familiar) you are saying someone would say to \"render with 'express'\" and under the hood it used this other module for the template engine, I think that is also perfectly fine instead of saying \"render with 'express-jsx'\".\r\n\r\nYou certainly know NakedJSX better than I, but if you want to have things directly use the name \"express\" vs \"express-jsx\" in order to template with Express, I don't see any issue with it, personally.\r\n\r\nAnd of course as you flesh it out, I'm sure there are some places we can even add Express\/NakedJSX links or usage to our website expressjs.com as well, if you like :)","Hi @dougwilson, thank you, I really appreciate it! And links back once it's released would be fantastic.\r\n\r\nIt hadn't occurred to me that a module called @nakedjsx\/express might be ok - that is indeed a nice succinct name.\r\n\r\nAnd yes, there would be a module called '@nakedjsx\/express', that starts NakedJSX in template engine mode and provides a template engine for express, used like this: (snippet taken from my current test project)\r\n\r\n```\r\nconst { createExpressJsx } = require('@nakedjsx\/express-jsx');\r\n\r\n\/\/ ...\r\n\r\nconst options =\r\n    {\r\n        srcDir,\r\n        output:\r\n            {\r\n                viewsDir,\r\n                tmpDir,\r\n                staticDir,\r\n                staticUriPrefix\r\n            }\r\n    };\r\nconst expressJsx = createExpressJsx(options)\r\n\r\n\/\/\r\n\/\/ Configure express to use @nakedjsx\/express-jsx as template engine\r\n\/\/\r\n\r\napp.engine('mjs', expressJsx.engine);\r\napp.use(express.static(staticDir));\r\napp.set('views', viewsDir);\r\napp.set('view engine', 'mjs');\r\n```\r\n\r\nUsage sadly can't be quite as simple as other template engines, needs that little bit of setup above. Essentially NakedJSX watches a srcDir (containing NakedJSX pages) and generates ~~dummy *.jsx~~ HTML generating .mjs files in the views folder. ~~Those trick express into seeing a routed request as a valid template engine path, allowing @nakedjsx\/express-jsx to forward the request to the running NakedJSX instance which executes an in-memory function compiled from the matching NakedJSX page to generate the HTML.~~\r\n\r\nThose files are imported (once) into NakedJSX and executed in response to requests to generate HTML and other content on demand.\r\n\r\nEDIT: things move quickly"],"labels":["meta"]},{"title":"Express v5 blockers","body":"_I started writing this as a reply to https:\/\/github.com\/expressjs\/express\/issues\/4920#issuecomment-1575599117 but the issue was locked just before I finishing typing my comment._\r\n\r\n@dougwilson Thanks for your continued work on express. I'm sorry you've had to deal with reports of bogus security vulnerabilities as well as folks who don't know better assuming that you've abandoned the project. I hope it doesn't get you down. \u2764\ufe0f\r\n\r\nI do have a question re:\r\n> reach out and I would be happy to Zoom with you or similar and we can work on the remaining items together, like see what you want to help with or hear what there is and you can let me know what you can do.\r\n\r\nAre you open to the idea of enumerating the remaining work to be done in public, rather than in private Zoom calls, e.g. on this issue or another one?\r\n\r\nIt may seem like asking folks to get on a Zoom call is not a big ask, but time zones and other factors could make that a nontrivial barrier. Moreover, documenting this in a public issue would eliminate the need for repeating yourself over `N` Zoom calls.\r\n\r\nThe last update said:\r\n> Express 5 is pretty much completed at this point, and we're just finishing up the last code merges in upstream modules in order to bump the dependencies finally in the 5.0 branch.\r\n\r\nIf this is still the case, perhaps you could provide more details about which modules are currently blocked and link to any relevant PRs\/issues that are stalled. Even if you'd still prefer to for folks that want to help to first reach out to you, providing this additional detail could help to make those conversations more fruitful.\r\n\r\nAnyway, just wanted to pose the question for you to consider. Once again, thanks for your continued work on express and I hope you are doing well!","comments":["Hi @rmacklin sorry about that, I didn't think there would have been any more real replies, and it was quite out of date anyway, so your new issue is probably for the best. I can certainly work on writing it down. I just suggested Zoom would be easier because it is fast and a conversation. I will need to take some time to gather everything, and will of course no longer be working on Express.js code while I do that. It seems like that is what folks want to see, however, so I think that working on documenting everything out is a higher priority than working on the code at this point. Please let me know if I'm mistaken. I have never been great about documenting these things down in writing, and it is a huge weakness of mine; I am more of a code writer, lol. So please forgive me. I would love it if someone who has that as their strong suit would join to help 'fish' it out of me, lol.","Hey I go through your message and would love to join you people in person to work with you and learn from you so I eagerly waiting to hear from you people.","HI @dougwilson - I DM'd you on LinkedIn to see if I could be of any help with this.","Hi, @dougwilson! I'm also willing to help, documenting or anything else. Is there a prefered way\/channel to talk to you about this?","Serious questions, if 5.0 is basically finished, why is it still in Beta?  Maybe time to bump it to RC? I have so much on my plate, I don't have time to test a beta.  But more than willing to test an RC version.  I just want to know if the interface is set.  I know sometimes you have to slide in an interface change, but it would be nice to know that you \"think\" the interface is stable.","Yes, that is the next step, to make it rc. Unless there are comtribs to add anything more, I plan to just run the train to get it out. There are a lot of changes between 4 and 5 especially with route path matching I hoped bugs would get flushed out before marked rc was all.","> HI @dougwilson - I DM'd you on LinkedIn to see if I could be of any help with this.\r\n\r\nSorry I don't really used LinkedIn, but I looked in there and don't see any mesaages on my account. Not sure if it was sent to the wrong account or I don't know where to look, feel free to email me.","> Yes, that is the next step, to make it rc. Unless there are comtribs to add anything more, I plan to just run the train to get it out. There are a lot of changes between 4 and 5 especially with route path matching I hoped bugs would get flushed out before marked rc was all.\r\n\r\nI am an old fart, but back in the day, beta was for working out all the breaking changes and making it work reasonably well with no crashes.  And there will be a 5.1, so if you like where the product is at, RC it. And thanks for all your hard work!!!","Is there an eta on when the RC will be released?","It is difficult to make promises for timelines as this is just voluntary work. I am triaging some security reports currently which take the highest priority so that's ultimately the most I can promise in time frame. If these pan in to actual security issues I would say that whatever the next 5 release is is going to be RC.","@dougwilson would like to help if needed","I tried to add error-handling middleware to a web application recently, found out that it doesn't work with async request handlers, and fell down this rabbit hole.\r\n\r\nExpress 5.0's release date has been continually pushed back [since **2015**](https:\/\/github.com\/expressjs\/express\/pull\/2237#issuecomment-115311279); it seems like people have been told that 5.0's release is just around the corner for the last 8-9 years.\r\n\r\nAre there *any* specific tasks - code, documentation, triaging, etc. - that others can help out with in order to get 5.0 out the door? I understand that you have no specific obligations since this is volunteer work, but it seems like many others are willing to help out with this if they can get an up-to-date roadmap. I'm not sure when the 5.0 milestone or #2237 were last updated, or to what extent they accurately reflect the work left to do.\r\n\r\nIf it's [lack of usage](https:\/\/github.com\/expressjs\/express\/issues\/4920#issuecomment-1149874852) that's blocking the release, you're going to be waiting forever--very few people want to use beta software in production, and it becomes a catch-22 of not wanting to release until more people have used 5.0, but people not wanting to use 5.0 until it's a stable release.\r\n\r\nIf there's any info on what people can do to help (e.g. what documentation needs to be written, what bugs need to be fixed, what features need to be implemented), I think it'd go a long way towards helping people both understand and help out with 5.0.","Sorry about that. I am happy to use my time to write those things down instead of do them if you like. I am admittedly not the best at writing it down, and just typing this from my phone while at work right now, and planned to work on the cookie changes for a 4.x release people need for some Chrome change, so probably a little lower on my list. I figured once I publish that 4 release, I would merge it into the 5 branch and just publish that as 5.0 in the end. Not sure if that helps at all.\r\n\r\nEdit: If anyone wanted to see something in 5.0 that is not in the beta, I guess speak now or forever hold your peace :) especially if the way all the new routing works doesn't work well, well, obviously whay is 5.0 will be 5.0, as no breaking changes again until 6.0","If the interface changes are complete and you aren't \"planning\" on any other breaking changes, please RC it.  More people will start using it and reporting bugs.  RC is for fixing the little stuff.  You are leaving the code in a catch-22.  Some places just don't mess with beta software but more than happy to use RC software to get the bugs worked out before they put it into production.","I don't personally see any issues with the new routing, and the changes have been in the migration guide since last February and I don't know of any way to gather any more feedback.\r\n\r\nOne issue I see with the current docs is that the guides aren't versioned, and it looks like they're still written for 4.x. I could try to either move the guides into `4x`\/`5x` sections like the rest of the docs, or just create a 5x branch which replaces the guides in-place. Assuming the 5.x migration guide is still up-to-date, I could also try porting some of the guides over.","Sure, I can make a RC instead of the final if that is what you want. I just want to do whatever people want, and if you want me to release the above as a RC first and then wait more for testing, I can definitely do that \ud83d\udc4d ","Yea, I think there is still more ways to make the website better, because you are correct, the guides are not versioned in any way, and ideally for 5 they would be using async probably a lot more and whatever else is relevant to 5.","Doug, I'd like to add to the many thanks for maintaining this project.\r\n\r\n> Sure, I can make a RC instead of the final if that is what you want. I just want to do whatever people want, and if you want me to release the above as a RC first and then wait more for testing, I can definitely do that \ud83d\udc4d\r\n\r\nWith this many years of baking, I'd suggest releasing 5.0 final. That way people can start using this, and submitting PRs if they find anything (any bugs). Thanks!\r\n","Yea, definitely, we can always accept bugs and features, just not breaking changes of course as much as possible. And of course just any change in behavior in 5 compared to 4 is not a bug :) just putting that out there as that is what went on with the 3 to 4 era, people would call changes between the two bugs and wanted to revert or change in some additional breaking way. I don't think we should have any ones like that this time; most of the routing changes are bc 5 now follows the URLPattern spec I would think.","I've been using express version 5, trying to put it through its paces. looks good so far. Ready to merge it and release it?","Maybe an Express 5 Christmas Present? \ud83d\ude04","I just wanted to take the current state of Express 5 for a test drive, but realized there aren't any typings on DT yet, is that correct? That's definitely (haha!) something which should be taken care of before Express 5 gets a final release. Or am I missing something? ","@soulchild Express types are currently maintained in https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped and not part of the express repository. Once express 5 is released, we can make a PR to update `@types\/express`. We can also add native types as `5.1` or similar, since it's not a breaking change, but IMO it's important we release express 5.0 as soon as possible so that dependent libraries and types can be updated by other maintainers.\r\n\r\nEdit: also, btw, in the interim, you can totally use `express@5` with `@types\/express@4.17`. I've been using that for a while and it's working fine. The slight mismatch doesn't stop you from compiling your typescript, but might aggravate your linter a little.","I concur. Software is never really done. It's alive.","@dougwilson I'm looking forward to seeing Express 5 released <3 ","I could not agree more [#5205 (comment)](https:\/\/github.com\/expressjs\/express\/issues\/5205#issuecomment-1841883130)\r\n\r\nI would also vote for making it final as is. Better to start moving forward with all the improvements that are already developed and cut a release version. Any other additional requests for changes and features can then go into v6.","the latest v5 was release from 2022, and now it's 2024.","I really really wish we will get Express v5 in 2024.","Hey @melroy89 (and others in this thread), if you are interested in participating we have been working on getting the project back on track. Check out [the initial plan here](https:\/\/github.com\/expressjs\/discussions\/issues\/160) and [our top priorities we put on the TC agenda](https:\/\/github.com\/expressjs\/discussions\/issues\/214). ","Thanks, I will join tomorrow."],"labels":["meta"]},{"title":"ErrorRequestHandler type not detected in VSCode","body":"In Typescript, with \"no implicit any\" setting, I am unable to use the custom error handling OOTB.  This appears to be an issue with the types.  The following produces errors in VSCode and tsc.\r\n\r\n```\r\nimport express, { NextFunction } from 'express';\r\n\r\nconst expressApp = express();\r\nexpressApp.use((req, res, next) => {});\r\nexpressApp.use((err, req, res, next) => {});  \/\/<--------problem\r\nexpressApp.use((err: any, req: any, res: any, next: NextFunction) => {});\r\n```\r\n\r\nThere is a repo here: https:\/\/github.com\/staplespeter\/expressjs-bug-types-ErrorRequestHandler\r\n\r\nIn the code inspector in VSCode the RequestHandler type is displayed for the 3-arg version and RequestHandlerParams for the 4-param version of the possible arguments to use().\r\n\r\nI have had a look at, and played around with the typedefs to no avail.\r\nPlease let me know if i have missed something or if the types are not correctly defined.\r\nThanks!","comments":["[`@types\/express`](https:\/\/www.npmjs.com\/package\/@types\/express) package is provided by the [DefinitelyTyped](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped) project. The problem with error handling in Express is known and looks like the only way to fix it is by manually specifying the error handler's type:\r\n\r\n```ts\r\nimport express, { ErrorRequestHandler, NextFunction } from 'express';\r\n\/\/                ^^^^^^^^^^^^^^^^^^^\r\n\r\n\/\/ ...\r\n\r\n\/\/ (1) wrap the arrow function in () and add as ErrorRequestHandler\r\nexpressApp.use(((err, req, res, next) => {}) as ErrorRequestHandler);\r\n\r\n\/\/ (2) function as a typed variable, IMO the best option\r\nconst errorHandler: ErrorRequestHandler = (err, req, res, next) => {}\r\nexpressApp.use(errorHandler);\r\n\r\n\/\/ (3) anonymous function instead of arrow with as ErrorRequestHandler doesn't require wrapping in ()\r\nexpressApp.use(function (err, req, res, next) {} as ErrorRequestHandler);\r\n```\r\n\r\nRelated issues:\r\n- https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/issues\/4212 (workarounds in comments)\r\n- https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/discussions\/59681 (no response)\r\n- https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/discussions\/61636 (no response)\r\n- https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/discussions\/64888 (no response)\r\n","\r\nYou're correct that the built-in types for Express middleware functions do not correctly support error-handling middleware. This is because Express's types were written before TypeScript had proper variadic tuple type support.\r\n\r\n\r\nTo fix this, you'll need to write your own type definitions for Express's error middleware. Here's what that would look like:\r\n\r\n\r\nimport { Request, Response, NextFunction } from 'express';\r\n\r\ntype ErrorRequestHandler = (\r\n    err: any, \r\n    req: Request, \r\n    res: Response, \r\n    next: NextFunction\r\n) => void;\r\n\r\nexpressApp.use((err: any, req: Request, res: Response, next: NextFunction) => {\r\n  \/\/ Type checks pass\r\n});\r\n\r\nBy defining your own ErrorRequestHandler type, TypeScript now understands that the 4th argument is the NextFunction, and the type checks will pass.\r\n\r\n\r\nThe core issue here is that Express's types don't properly model variadic arguments or overloads, so for some of Express's more dynamic features, you'll need to supplement the types with your own definitions. Defining an ErrorRequestHandler type is a great example of improving Express's type definitions.","@VitorhugoBatista there already is an `ErrorRequestHandler` type in `@types\/express`:\r\n\r\n1. [declaration in `@types\/express`](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/blob\/6dd9877533e87a786d77c4e3a806ffcb208bb5d3\/types\/express\/index.d.ts#L97-L103) extending the declaration from `@types\/express-serve-static-core`\r\n2. [declaration in `@types\/express-serve-static-core`](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/blob\/6dd9877533e87a786d77c4e3a806ffcb208bb5d3\/types\/express-serve-static-core\/index.d.ts#L78-L89)\r\n\r\nthis type is a better version of the one that you suggested and can be imported directly as shown in my previous response. The type basically is:\r\n\r\n```ts\r\nimport * as core from 'express-serve-static-core';\r\n\r\ninterface ErrorRequestHandler<\r\n    P = core.ParamsDictionary,\r\n    ResBody = any,\r\n    ReqBody = any,\r\n    ReqQuery = core.Query,\r\n    Locals extends Record<string, any> = Record<string, any>\r\n> = (\r\n    err: any,\r\n    req: Request<P, ResBody, ReqBody, ReqQuery, Locals>,\r\n    res: Response<ResBody, Locals>,\r\n    next: NextFunction,\r\n) => void;\r\n```\r\n\r\nLack of variadic tuple support (which is supported since TS 4.0) is not a problem - there are only static overloads and variadic are unnecessary. The problem with overload resolution was reported as a TypeScript bug a long time ago, but the issue was closed as a design limitation: microsoft\/TypeScript#31867.\r\n\r\nYou can check a simple version of this TS problem [here](https:\/\/www.typescriptlang.org\/play?ts=5.1.3#code\/G4QwTgBArgzgpgLggeWHMAbA9iAJhAXggAoALEAO1w3SQCU4AXKMCgZUbAEsKBzCAD4QGzVgDUsXXAEpCAPggBvAL4BuAFCw4xYiFkEFK6aogB6UxAA8AWlsR0YLJCwUIjUlxgQAxiAwY3LAgAci1ggBpoChoYLwAHcBAAWyZ0CBAIJzdSOAgAMygKb0YuFwhPNwBPOLhcdXUeRnQ8kG9c1HRsPCV1CD6ScioaMHomFnZOHl5pJGBJXA1+gcpqWmEx8XmZiDmpDWV6xubW3JFxjm4+HqXdJBhJvkiAIyQKKCSn9G37y959w4oTTALTa61EFAkUmu-VuEDeHy+s3m-yAA).\r\n\r\nAdding types to the middleware function parameters can resolve the error, but it is more work than just declaring the type of the error handler like I've shown [previously](https:\/\/github.com\/expressjs\/express\/issues\/5203#issuecomment-1569827410)."],"labels":["discuss"]},{"title":"express request and response processing ","body":"I see that expressjs app has a `stack` of `Layer` object Arrays. Which is the function that is used to pass the \r\n\r\nI want to know:\r\n- When a request is sent from the `http` client which `function is invoked first` and how is the stack array functions with `middlewares` invoked and results passed stepwise? \r\n- Here is an example `app.get(path, [middleware(req, res, next), m2(req, res, next), m3(req, res, next), m4(req, res, next)], handler(req, res))` => which function invokes functions stepwise => `[middleware(req, res, next), m2(req, res, next), m3(req, res, next), m4(req, res, next), handler(req, res)]`\r\n- Where is the `request` and `response` objects created that is passed as `arguments`?\r\n- Where is the `response` object callback function for `send` => `onfinish`\/ `onend` functions which I can use to get the `send`\/ `sendfile's` response object into a `variable` for an `interceptor`?\r\n\r\nI am looking for the entry of the request and exit if the response (with the response result).\r\n \r\n","comments":["When a request is sent from the HTTP client to an Express.js application, the initial function that is invoked is the one that handles the incoming request. In Express.js, this is typically referred to as a \"route handler\" or simply a \"handler function\". The handler function is responsible for processing the request and generating a response.\r\n\r\nIn the example you provided, the handler function is the one specified as the last parameter in the app.get method. It is the final function in the stack and is invoked after all the middlewares have been executed.\r\n\r\nThe stack of functions with middlewares is invoked stepwise in the order they are defined in the array. Each middleware function is invoked in sequence, passing the req (request) and res (response) objects along with the next function to the next middleware in the stack. The next function is used to pass control to the next middleware function in the stack.\r\n\r\nThe request and response objects are created and passed automatically by Express.js as part of the HTTP request-response cycle. When a request is received, Express.js creates the request object (req) and the response object (res) and passes them to the corresponding handler or middleware functions. These objects contain useful properties and methods that allow you to access information about the request and send the response back to the client.\r\n\r\nRegarding the response object callback function for res.send, Express.js does not expose a specific callback function for send. Instead, the response is sent back to the client when you invoke res.send() or any other response-sending methods. If you need to perform additional operations or intercept the response before it is sent, you can create a custom middleware function that sits in the stack before the final handler function. This middleware can access the response object and modify its behavior as needed.\r\n\r\nIn summary, the entry point for the request is the handler function that handles the specific route, and the exit point for the response is the res.send or other response-sending methods. The request and response objects are automatically created by Express.js and are passed along the middleware stack and to the handler function. You can create custom middleware functions to intercept and modify the response before it is sent back to the client.","tried this and failed with errors. if I make an object using the `express\/request.js` and `express\/response.js` and want to traverse the express app router path with their middlewares to get the expected results from a non listening app like from a http server which function do i use and what options do i have?"],"labels":["question"]},{"title":"oidc does not exist on Request type","body":"# Issue\r\n```typescript\r\nimport { Request } from 'express'\r\n\r\n...\r\n\r\nexport async function getServerSideProps(context: GetServerSidePropsContext & { req: Request }) {\r\n  const variable = context.req?.oidc?.user['parameter'];\r\n}\r\n\r\n``` \r\n<img width=\"791\" alt=\"Screenshot 2023-04-21 at 11 52 07 AM\" src=\"https:\/\/user-images.githubusercontent.com\/61043345\/233713158-faedc76f-d76b-4f20-ab7b-84d465fad934.png\">\r\n\r\n## Tried\r\n\r\n- Upgrading to 4.18.x\r\n- Upgrading to beta\r\n- Restarting ts server\r\n- re-yarn-ing\r\n","comments":["are you using next.js? if yes you cannot mix express Request type with it","@CalebJamesStevens, like @dtsuper3 said, you can't mix an express and nextjs.\r\n\r\nIf you want to have `oidc` in the `req` object, you will need to modify the `GetServerSidePropsContext` type.\r\nTry doing this:\r\n\r\n- add a new `next.d.ts` file in your project and add the following code in it.\r\n- aim here is to add a new `oidc` property in it.\r\n\r\n```typescript\r\nimport type { GetServerSidePropsContext as OriginalGetServerSidePropsContext } from \"next\/types\";\r\n\r\ndeclare module \"next\" {\r\n\texport type GetServerSidePropsContext<\r\n\t\tQ extends ParsedUrlQuery = ParsedUrlQuery,\r\n\t\tD extends PreviewData = PreviewData,\r\n\t> = OriginalGetServerSidePropsContext<Q, D> & {\r\n\t\treq: {\r\n\t\t\toidc: string; \/\/ use the correct type here\r\n\t\t};\r\n\t};\r\n\r\n\texport type GetServerSideProps<\r\n\t\tP extends { [key: string]: any } = { [key: string]: any },\r\n\t\tQ extends ParsedUrlQuery = ParsedUrlQuery,\r\n\t\tD extends PreviewData = PreviewData,\r\n\t> = (context: GetServerSidePropsContext<Q, D>) => Promise<GetServerSidePropsResult<P>>;\r\n}\r\n\r\nexport {};\r\n```"],"labels":["discuss"]},{"title":"Request triager role for Ivaylo-Iv","body":"\r\n\r\nI have read and understood the project's Code of Conduct.\r\nI also have read and understood the process and best practices around Express triaging.\r\n\r\nI request for a triager role for the following GitHub organizations:\r\n\r\njshttp\r\npillarjs\r\nexpress","comments":[],"labels":["discuss"]},{"title":"Don't automatically add Expires in res.cookie if expires option is explicitly set to 0","body":"This addresses https:\/\/github.com\/expressjs\/express\/issues\/5150\r\n\r\nThose who wish to exclude `Expires` (but still keep `Max-Age` from the final `Set-Cookie` statement cannot do so if `maxAge` option is passed to `res.cookie`).\r\n\r\nThis proposed solution allows one to exclude Expires if `expires: 0` option is passed to `res.cookie`.","comments":[],"labels":["pr"]},{"title":"res.cookie does not allow setting Max-Age only, without Expires (One should be able to set maxAge alone, with expires: 0)","body":"I want to set a cookie with `Max-Age` only, without having `Expires`. But the following lines 875-876 keep adding the unwanted `Expires`:\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/0debedf4f31bb20203da0534719b9b10d6ac9a29\/lib\/response.js#L871-L878\r\n\r\nSetting `expires: 0` does no good to override that behavior.\r\n\r\nI think one should be allowed to only set Max-Age without automatically having Expires also set.\r\n\r\n```\r\nres.cookie('MyCookie', 'TheValue', {\r\n  expires: 0, \/\/ I don't want any Expires in the resulting Set-Cookie statement\r\n  maxAge: 60000,\r\n});\r\n```\r\n\r\n### Actual result:\r\n\r\n```\r\nMyCookie=TheValue; Max-Age=60; Path=\/; Expires=Sun, 26 Mar 2023 06:00:31 GMT\r\n```\r\n\r\n### Desired result:\r\n\r\n```\r\nMyCookie=TheValue; Max-Age=60; Path=\/; \r\n```\r\n\r\n### Workaround\r\n\r\nThe workaround for this is our having to manually write the `Set-Cookie` statement, possibly mimicking the same logic in the express code.\r\n\r\n### Possible solution\r\n\r\n```\r\nif (opts.expires !== 0) {\r\n  opts.expires = new Date(Date.now() + maxAge)\r\n}\r\n```","comments":["The [RFC6265 - section 4.1.2.2](https:\/\/www.rfc-editor.org\/rfc\/rfc6265#section-4.1.2.2) describes the following behavior:\r\n\r\n> If a cookie has both the Max-Age and the Expires attribute, the Max-Age attribute has precedence and controls the expiration date of the cookie.\r\n\r\nTherefore in the usecase that you described, your proposed solution won't make a difference except the used \"user agent\"\/browser is not implementing RFC6265 properly.  ","Hi @tjarbo that is correct, user agents that support `max-age` attribute should ignore `expires` attribute. But since `max-age` was an add on to `set-cookie` later in life, not all clients support it, so they will use `expires` instead (since they don't understand `max-age`. This is why Express is adding both, so all clients will know when the cookie expires and won't accidentally set it as a session-length cookie. Maybe better understanding of @nbkhope use-case will help.","Hi @dougwilson, wow - I really had to go far back in history to find a well-known specification which describes `Set-Cookie` without 'max-age' \ud83d\ude06 Netscape sends it greetings: https:\/\/curl.se\/rfc\/cookie_spec.html. For my understanding, is it one of the objectives of express to support these outdated (\"outdated\" as today's RFCs describe a different behavior for handling 'Set-Cookie) user agents?\r\n\r\nSo @nbkhope, I also do not see an issue with the current behavior of express. As dougwilson said, maybe an explanation of your use-case could help.","Hi @tjarbo there are many other user agents then web browsers. And many still ezist today that never kept up with the changes in specs. It was added to express in reponse to users have issues is all. As for web browsers, I believe Internet Explorer never supported max-age until IE8, well after Netscape stopped being relevant.\r\n\r\nAnd I wouldn't say express objective is to support every web browser in existence or anything. In this case it just seemed like people where reporting an issue, and adding expires fixed it and we didn't see any harm, as all modern clients just ignore it and use max age (and even thenusing expires would have the same result as long as the two clocks are not out of sync)."],"labels":["discuss","enhancement"]},{"title":"HTML in the `res.redirect()` method is missing a `DOCTYPE` and `<title>` element","body":"The response body of a redirect via the `res.redirect()` method will be `<p>${statuses.message[status]} Redirecting to <a href=\"${url}\">${url}<\/a><\/p>`, which is invalid HTML without a `DOCTYPE` and `<title>` element.\r\nIn particular, the absence of a `<title>` element is detrimental to the user.\r\n\r\n[RFC 9110, 15.4. Redirection 3xx](https:\/\/datatracker.ietf.org\/doc\/html\/rfc9110#section-15.4), states that the user agent behavior when the `Location` header field is set with status code 3xx is \"the user agent MAY automatically redirect its request to the URI\".\r\nNote that it is **MAY**.\r\n\r\nAnd in fact, depending on the user's environment, automatic redirection may not occur and the contents of the response body may be displayed on the screen.\r\nIn the old days, there was an option to disable redirects in Presto Opera's advanced settings.\r\nEven now, when Android Firefox redirects to an app-linked URL with 3xx, the app is automatically launched, but the browser screen still displays the 3xx response body.\r\n\r\nTherefore, it would be desirable to set the `DOCTYPE` and `<title>` element even for 3xx screens.\r\n\r\n\r\n# Improvement plan\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/8368dc178af16b91b576c4c1d135f701a0007e5d\/lib\/response.js#L963\r\n\r\n\u2193\r\n```javascript\r\nbody = '<!DOCTYPE html><title>' + statuses.message[status] + '<\/title><p>' + statuses.message[status] + '. Redirecting to <a href=\"' + u + '\">' + u + '<\/a><\/p>'\r\n```\r\n\r\n","comments":["Not sure that this is something standard. What is being done by others frameworks \/ languages? \r\nIf needed - we should provide a complete and valid HTML part (which would include header\/body) - but again this is a nice to have as the RFC doesn't precise that we need to send a value. ","I am not familiar with the status of other Node.js frameworks, but the situation of popular web server software is as follows.\r\n\r\n# Apache 2.4\r\n\r\n```\r\nServerSignature Off\r\nRedirect permanent \/ https:\/\/example.com\/\r\n```\r\n\r\n```html\r\n<!DOCTYPE HTML PUBLIC \"-\/\/IETF\/\/DTD HTML 2.0\/\/EN\">\r\n<html><head>\r\n<title>301 Moved Permanently<\/title>\r\n<\/head><body>\r\n<h1>Moved Permanently<\/h1>\r\n<p>The document has moved <a href=\"https:\/\/example.com\/\">here<\/a>.<\/p>\r\n<\/body><\/html>\r\n```\r\n\r\n# nginx 1.23\r\n\r\n```\r\nlocation \/ {\r\n    rewrite ^ https:\/\/example.com\/ permanent;\r\n}\r\n```\r\n\r\n```html\r\n<html>\r\n<head><title>301 Moved Permanently<\/title><\/head>\r\n<body>\r\n<center><h1>301 Moved Permanently<\/h1><\/center>\r\n<hr><center>nginx\/1.23.3<\/center>\r\n<\/body>\r\n<\/html>\r\n```\r\n","Hi @SaekiTominaga thank you for that! Those seem to have a lot more parts than your initial recommendation.\r\n\r\nSo in order to understand the issue, can you provide us the details of what clients are not able to render the response from express? This will better help guide the conversation by having the information regarding which clients\/browsers are having an issue with the response from Express and thus we can work to make sure and validate that any changes made will resolve the issue.","Hi, @dougwilson !\r\n\r\nCurrently, most browsers automatically redirect when a `Location` header is present in a 3xx, so the user has very limited exposure to the response HTML.\r\nAs noted in the first comment, I know this occurs in Android Firefox.\r\n\r\n1. Install Firefox and the Twitter application on Android device.\r\n1. Put the redirection process in `app.js`. (Code\uff031)\r\n1. Access `http:\/\/localhost:3000\/twitter` with Firefox.\r\n1. The Twitter application will automatically launch.\r\n1. When you return to the Firefox application, the redirect screen will be displayed. (Image\uff032)\r\n1. Here, the `<title>` element is not present, so the tab displays the URL as is. If `<title>` element is set, the tab will display its value. (Image\uff033)\r\n\r\n<hr>\r\n\r\nCode\uff031 (`app.js`)\r\n```javascript\r\napp.get('\/twitter', (req, res) => {\r\n\tres.redirect(301, 'https:\/\/twitter.com\/');\r\n});\r\n```\r\n\r\nImage\uff032\r\n![Redirect message is displayed on the browser screen](https:\/\/user-images.githubusercontent.com\/4138486\/207826646-1318ebe6-40c6-4534-bddc-36215a6b9a87.png)\r\n\r\nImage\uff033\r\n![A side-by-side view of the redirect screen and Google page in a browser](https:\/\/user-images.githubusercontent.com\/4138486\/207826833-da0b2512-60de-422f-9213-9a09390c23ce.png)\r\n\r\n\\* The redirect process itself works fine. This is just a measure to prevent user confusion by displaying the page title in the browser tab by adding the `<title>` element.\r\n\\* According to the [HTML specification](https:\/\/html.spec.whatwg.org\/multipage\/semantics.html#the-head-element), the `<title>` element is required, with a few exceptions. Therefore, regardless of how Android Firefox works, even redirect screens should include a `<title>` element.\r\n"],"labels":["awaiting more info"]},{"title":"Would love a README update for non-linear architecture examples","body":"The examples show a linear setup, but no one does this -- which is great for quickstart, but real apis always use \/v1\/foo1\/foo2\/\r\n\r\nWhat is the \"recommended\" way to have a nested hierarchy with \/v1\/index.js, \/v1\/foo\/index.js, for example? Although everyone seems to do this, I can really find no guides on it -- even if I do figure it out in my own way, it's likely not standard.","comments":["it really depends how you design your API, because most of the time how I did I would just use sublevel routers which are implemented the same way as basic router \r\n\r\nSo for example\r\n- app router loading multiples files (user, payment, document)\r\n- router in user file implement endpoint but also load another router\r\n\r\nFor me this is the same setup as the first level router. but if needed I could easily PR something for that (or give you an example)","> The examples show a linear setup, but no one does this -- which is great for quickstart, but real apis always use \/v1\/foo1\/foo2\/\r\n> \r\n> What is the \"recommended\" way to have a nested hierarchy with \/v1\/index.js, \/v1\/foo\/index.js, for example? Although everyone seems to do this, I can really find no guides on it -- even if I do figure it out in my own way, it's likely not standard.\r\n\r\nYou're lucky my guy. When I was searching for how to best structure API routes closely mirroring API URI, I couldn't find anything similar. \r\n\r\nHere is my project that has the structure.\r\n\r\n```\r\nhttps:\/\/github.com\/allkindsofgains\/gains\/tree\/main\/src\/apps\/api\r\n```\r\n\r\nI like structuring folders closely relative to API URI. One annoying thing you constantly have to keep doing is, re-registering the routes of a resource. Let me know if you have any questions.","Ha! Thanks @wajeht ! Your longest to shortest imports\/use looks quite beautiful opposed to alpha :) \r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/8840024\/198857429-91c6c0d9-4cf2-416c-b2f0-d84d2d5e0fc2.png)\r\n\r\nI still think the README could use both a linear quickstart and at least a slight mention of the best way for non-linear so folks at least have a standard to base on.","Hi @dylanh724 I'm not sure I understand what you mean by \"non-linear architecture\". Based on the conversation above, is the example https:\/\/github.com\/expressjs\/express\/tree\/master\/examples\/multi-router what you're looking for?","Ah yes that is it! However, I assumed the examples were based off the quickstart (rather than a more-advanced one). One sentence mention in the readme would resolve this, in light of the new info. I am sure I'm not the only one with the same assumption.","Ah. I'm not sure I understand what you are saying it should mention? The examples are mentioned in the README, though really the source for everything is our website: expressjs.com and the README is just to be bare-bones. The examples are part of our \"Getting started\" section (https:\/\/expressjs.com\/en\/starter\/examples.html) which we encourage everyone to at least visit all the pages there (they each end with Previous \/ Next links to make it easier to go through them like a book)."],"labels":["docs","question"]},{"title":"ERR_EMPTY_RESPONSE every time i try to access from a device not local","body":"so im trying to create an express server but i get ERR_EMPTY_RESPONSE(from a VPN) on other devices and my friends got ERR_CONNECTION_TIMED_OUT\r\n\r\nhow can i fix this","comments":["can you help with a screenshot i want to confim something","![Screenshot_20221004_181614](https:\/\/user-images.githubusercontent.com\/101841938\/193940437-00d7d881-4541-4728-81ae-fb4941557429.jpg)\r\n\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst fs = require('fs')\r\napp.use(express.static('public'))\r\nvar lel = app.get('\/', function (req, res) {\r\n}).get('\/site', function (req, res) {\r\n  fs.readFile('.\/public\/site.html', async function(err, data) {\r\n    res.writeHead(200, {'Content-Type': 'text\/html'});\r\n    res.write(data);\r\n    return res.end();\r\n  });\r\n  \r\n\r\n}).get('\/api\/get\/guilds', async function (req, res) {\r\n  res.send(`${await client.guilds.cache.size}`)\r\n}).get('\/api\/get\/members', async function (req, res) {\r\n  res.send(`${await client.users.cache.size}`)\r\n\r\n}).get('\/api\/get', function (req, res) {\r\n  fs.readFile('.\/public\/api\/get\/', async function(err, data) {\r\n    res.writeHead(200, {'Content-Type': 'text\/html'});\r\n    res.write(data);\r\n    return res.end();\r\n  });\r\n\r\n}).listen(port,\"0.0.0.0\", ()=>{\r\n  console.log(`Listening port on ${lel.address().port}`)\r\n});\r\n```","sorry for asking is the ip a publicly accessible  ip address? \r\n\r\nor that of localhost","that was my pc's ipv4 but my public ip address does the same thing. My ipv4, localhost, and public address work on local devices ","ok can you try using ngrok to expose the local port and lets see how that goes?\r\n","it works but i would rather use my ip\r\n","i guess the main issue is the ip adress.\r\n\r\ni guess its not being exposed","It is also possible there is a firewall involved, either on the device itself or the network between the two machines. If you are able to at least get a reaponse on loopback (i.e. 127.0.0.1), then the issue is outside of the express.js framework and something network, machine, or node.js.","![image](https:\/\/user-images.githubusercontent.com\/101841938\/193948949-eb058b77-2354-45e8-8183-17ac85c4b916.png)\r\n![image](https:\/\/user-images.githubusercontent.com\/101841938\/193948988-cb66481e-511e-4b63-935e-51f7f1ed9ed1.png)\r\n![image](https:\/\/user-images.githubusercontent.com\/101841938\/193949011-0af94bbc-b2e6-411e-a290-ce61ddbcb078.png)\r\n","Hi @jman13378 I am certainly sorry you are having trouble. It is unfortunately we are not sure what the issue is exactly that you are experiencing and we are not also experiencing. That puts us in a hard place to help. If you believe this is an issue in Express.js, it may help if you can help provide pointers for where you are seeing the issue in our code and we can perhaps work towards what code changes we need to make, or you're always welcome to contribute such a change directly. Other than that, I'm not sure how else we can help.","> It is also possible there is a firewall involved, either on the device itself or the network between the two machines. If you are able to at least get a reaponse on loopback (i.e. 127.0.0.1), then the issue is outside of the express.js framework and something network, machine, or node.js.\r\n\r\nyea @dougwilson because ngrok also works according to him","Well, here is a test @jman13378 : see if the following code has the same issue or not. This will narrow down for if the Express.js project can assist or not:\r\n```js\r\nconst http = require('http')\r\nconst app = http.createServer((req, res) => res.end('Hello, world!'))\r\napp.listen(3000, \"0.0.0.0\")\r\n```","> ```js\r\n> const http = require('http')\r\n> const app = http.createServer((req, res) => res.end('Hello, world!'))\r\n> app.listen(3000, \"0.0.0.0\")\r\n> ```\r\n\r\nnot that","its most likely an ISP issue or Firewall\r\n","were you able to solve the issue ? or is it still not working ?\r\n\r\nLooking on my side like other people said it is most likely some kind of firewall \/ blocking the request","I will try in my pi but other than that I have not fixed it"],"labels":["discuss","question","awaiting more info"]},{"title":"\"merge params\" option ","body":"Added \"merge params\" option to application as discussed in #5006.\r\n\r\nNote: I am not familiar with the suite, so I copy pasted mergeParams tests and adapted them a bit to the application where needed, but I just wanted to make sure that the behavior of the application is the same as the router. The tests should look the same for both however... Would it make sense to provide `[Router({mergerParams: true}), app.handle]` and run the same tests for them, or is it preferable to have these duplicated?","comments":["> The tests should look the same for both however... Would it make sense to provide [Router({mergerParams: true}), app.handle] and run the same tests for them, or is it preferable to have these duplicated?\r\n\r\nIt's perfectly fine how you have it and we typically keep them duplicated, as we ended up having lots of accidental regressions in the past when trying to be clever in the test suite and consolidate them with various logic. I think there are still a couple places left like that."],"labels":["enhancement","pr"]},{"title":"Router mergerParams setting on app initialization","body":"Hi,\r\n\r\nis there way to make app merge params from the parent app right now? As far as I can tell only the strict and caseSensitive settings are configurable:\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/33e8dc303af9277f8a7e4f46abfdcb5e72f6797b\/lib\/application.js#L144-L149\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/318fd4b543ffbebf97bf0b6c49188afae45741f5\/lib\/application.js#L64-L75\r\n\r\nMy use case is that I have the root app and child apps for view rendering, because I am able to limit the views available to the app, which makes code a bit shorter and cleaner and also project structure is nicer. However I don't have the access to the path parameters in this case.\r\n\r\n```javascript\r\nconst root = express()\r\nconst app = express()\r\napp .set('views', 'path1')\r\napp .get('\/', (req) => console.log(req.params)) \/\/ prints '{}'\r\n\r\nroot.use('\/path\/:someParam', app)\r\n```\r\n\r\nI can submit a PR as it is only one line of code if I didn't overlook something.","comments":["Hello, thank you for your issue. You are right, there is no option for mergeParams for an app, only routers. I don't see any reason off-hand that an app cannot also enable that setting. If you would like to make a PR, you're welcome to do so, just remember to add all the necessary tests around the feature, not just one line to the one file :) . If you're not comfortable doing that, we can still add it for you, just let us know.","I'll take a stab at it. By the way, how are different branches handled? Do I submit PR for both master and 5.0, or just 5.0?","I believe this is just adding a feature (in the form of a new option), so if that is the case just master is all you need."],"labels":["question"]},{"title":"Critical dependency: the request of a dependency is an expression","body":"`WARNING in .\/node_modules\/.pnpm\/express@4.18.1\/node_modules\/express\/lib\/view.js 81:13-25\r\nCritical dependency: the request of a dependency is an expression\r\n    at CommonJsRequireContextDependency.getWarnings (C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\webpack@5.74.0_webpack-cli@4.10.0\\node_modules\\webpack\\lib\\dependencies\\ContextDependency.js:102:18)\r\n    at Compilation.reportDependencyErrorsAndWarnings (C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\webpack@5.74.0_webpack-cli@4.10.0\\node_modules\\webpack\\lib\\Compilation.js:3132:24)\r\n    at C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\webpack@5.74.0_webpack-cli@4.10.0\\node_modules\\webpack\\lib\\Compilation.js:2729:28\r\n    at _next2 (eval at create (C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\tapable@2.2.1\\node_modules\\tapable\\lib\\HookCodeFactory.js:33:10), <anonymous>:16:1)\r\n    at eval (eval at create (C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\tapable@2.2.1\\node_modules\\tapable\\lib\\HookCodeFactory.js:33:10), <anonymous>:42:1)\r\n    at C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\webpack@5.74.0_webpack-cli@4.10.0\\node_modules\\webpack\\lib\\FlagDependencyExportsPlugin.js:385:11\r\n    at C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\neo-async@2.6.2\\node_modules\\neo-async\\async.js:2830:7\r\n    at Object.each (C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\neo-async@2.6.2\\node_modules\\neo-async\\async.js:2850:39)\r\n    at C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\webpack@5.74.0_webpack-cli@4.10.0\\node_modules\\webpack\\lib\\FlagDependencyExportsPlugin.js:361:18\r\n    at C:\\Users\\cmw10\\Desktop\\codes\\react-ssr\\node_modules\\.pnpm\\neo-async@2.6.2\\node_modules\\neo-async\\async.js:2830:7\r\n @ .\/node_modules\/.pnpm\/express@4.18.1\/node_modules\/express\/lib\/application.js 22:11-28\r\n @ .\/node_modules\/.pnpm\/express@4.18.1\/node_modules\/express\/lib\/express.js 18:12-36\r\n @ .\/node_modules\/.pnpm\/express@4.18.1\/node_modules\/express\/index.js 11:0-41\r\n @ .\/src\/server.tsx 3:0-30 8:12-19\r\n @ .\/src\/index.ts 1:0-18`\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/45275792\/193402388-c5e1ba38-7246-4a7d-9a80-e8339182d843.png)\r\n","comments":["Template engine support in Express requires dynamic module resolution, which doesn't play nicely with Webpack.\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/d854c43ea177d1faeea56189249fff8c24a764bd\/lib\/view.js#L80-L81\r\n\r\nYou can find more details about your problem and possible solutions in webpack\/webpack#1576. Probably https:\/\/github.com\/webpack\/webpack\/issues\/1576#issuecomment-766796672 is what you're looking for.","I've linked a discussion on webpack side of things.\r\n\r\nIt seems the code in question is dynamically importing a `template-engine` for purposes of rendering templates\r\nhttps:\/\/expressjs.com\/en\/guide\/using-template-engines.html\r\n\r\nA template engine example is:\r\nhttps:\/\/expressjs.com\/en\/resources\/template-engines.html\r\n\r\nIf we really want to bundle express in webpack output, then we can ignore this warning...\r\n\r\nThere's only two things to consider:\r\n1. Making sure `template-engine` library is bundled or installed with build code, we can perhaps just make sure project code imports the library somewhere\r\n2. Making sure webpack output `e.g main.js` is still able to `require('template-engine')`\r\n3. Making sure rendering is functional."],"labels":["discuss"]},{"title":"Issue a warning when GET route declared before HEAD","body":"I have spent several hours debugging a HEAD route and eventually found that I had fallen foul of the note here:\r\nhttps:\/\/expressjs.com\/en\/4x\/api.html#router.METHOD\r\n\r\nA warning may not be the right approach, but it would be nice to be notified on a HEAD route declared after a GET that the GET logic would be called. I suspect I will be neither the first nor the last to have bashed their head against a wall over this one!","comments":["Hi @peter-batley-depop  ,\r\n\r\nCan you share your code so it will be more clear on your concern.","I ask to take charge of the issue. The issue occurs when the head method is declared after the get method for a certain path. For example, the code:\r\n\r\n```node\r\nconst express = require('express')\r\nconst app = express()\r\n\r\nconst router = express.Router()\r\n\r\nrouter.get('\/', function (req, res) {\r\n  console.log('Get Called')\r\n  res.send('Hello World')\r\n})\r\n\r\nrouter.head('\/', function (req, res, next) {\r\n  console.log('Head Called')\r\n  res.send()\r\n})\r\n\r\napp.use(router)\r\n\r\napp.listen(3000)\r\n```\r\n\r\nAn head request to localhost:3000 will print 'Get Called', so the get method is called instead of the head. The reason is that the layers stack is created in the order in which the methods are defined in the code. When the HEAD method is called, the stack is scrolled until it finds a match with the specified path and method. The _handles_method function in the route.js file checks whether a certain route can handle the method, and returns true if the first route checked is not of type HEAD but the route can handle a GET method. So, when the GET method is defined before HEAD, it is executed.\r\n\r\nMy proposal is to check all routes in the case of HEAD method, instead of stopping at the first one. For this I propose a change to the code of the next function defined at [this line](https:\/\/github.com\/expressjs\/express\/blob\/0debedf4f31bb20203da0534719b9b10d6ac9a29\/lib\/router\/index.js#L177).\r\n\r\nThe change is to modify the stop condition of the while loop in the case of method HEAD to allow scanning of all defined routes and the definition of temporary variables where the best match is stored. If the method HEAD is found, the loop is stopped. In the case of other methods, the loop works as usual.\r\n\r\nThe code defined in [these lines](https:\/\/github.com\/expressjs\/express\/blob\/0debedf4f31bb20203da0534719b9b10d6ac9a29\/lib\/router\/index.js#L220-L266) become something like:\r\n\r\n```\r\n\/\/ find next matching layer\r\nvar layer;\r\nvar match;\r\nvar route;\r\n\r\nvar head_route;\r\nvar head_layer;\r\n\r\n\/\/ scan all routes if method = HEAD\r\nwhile ((match !== true || req.method === 'HEAD') && idx < stack.length) {\r\n  layer = stack[idx++];\r\n  match = matchLayer(layer, path);\r\n  route = layer.route;\r\n\r\n  if (typeof match !== 'boolean') {\r\n    \/\/ hold on to layerError\r\n    layerError = layerError || match;\r\n  }\r\n\r\n  if (match !== true) {\r\n    continue;\r\n  }\r\n\r\n  if (!route) {\r\n    \/\/ process non-route handlers normally\r\n    continue;\r\n  }\r\n\r\n  if (layerError) {\r\n    \/\/ routes do not match with a pending error\r\n    match = false;\r\n    continue;\r\n  }\r\n\r\n  var method = req.method;\r\n  var has_method = route._handles_method(method);\r\n\r\n  \/\/ build up automatic options response\r\n  if (!has_method && method === 'OPTIONS') {\r\n    appendMethods(options, route._options());\r\n  }\r\n\r\n  \/\/ don't even bother matching route\r\n  if (!has_method && method !== 'HEAD') {\r\n    match = false;\r\n  }\r\n\r\n  \/\/ best match for head request\r\n  if (has_method && method === 'HEAD') {\r\n    head_route = route;\r\n    head_layer = layer;\r\n    if (Boolean(route.methods['head'])) {\r\n      break;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\/\/ no match\r\nif (match !== true && !head_route) {\r\n  return done(layerError);\r\n}\r\n\r\n\/\/ set best head route and layer\r\nif (head_route) {\r\n  route = head_route;\r\n  layer = head_layer;\r\n}\r\n```"],"labels":["discuss","enhancement"]},{"title":"SNICallback native","body":"Hello, I would like to indicate a new native functionality for express in your next updates: native **SNICallback**.\r\n\r\nToday we do not have native support for such functionality. I myself, in a current project, needed SNICallback and I only found it in NodeJS native https functions but I didn't find any direct implementation in ExpressJS where I would rather have a raised server.\r\n\r\nThe solution was to join NodeJS https together with Express to use such a feature, but if the same feature was available natively in Express it would be of great help.\r\n\r\nSuch functionality is important because it helps us a lot in several things, including leaving a Dynamic SSL (which was for this functionality I needed).\r\n\r\nExplanation of functionality in NodeJS can be found at the link: [SNICallback in NodeJS](https:\/\/nodejs.org\/dist\/latest-v16.x\/docs\/api\/tls.html#tlscreatesecurecontextoptions)","comments":["I am trying to use SNICallback, but the app I provide never seems to get invoked. Do you have working examples using SNICallback?","> I am trying to use SNICallback, but the app I provide never seems to get invoked. Do you have working examples using SNICallback?\r\n\r\nI use it like this:\r\n\r\n```\r\nimport express from 'express';\r\nimport https from 'node:https';\r\n\r\nconst app = express();\r\n\r\nasync function dynamicCertify(domain){\r\n    \/\/ do something\r\n}\r\n\r\nlet options = {\r\n    SNICallback: async function (domain, cb) {\r\n        if (cb) {\r\n            cb(null, await dynamicCertify(domain));\r\n        } else {\r\n            return await dynamicCertify(domain);\r\n        }\r\n    }\r\n}\r\n\r\nlet server = https.Server(options, app);\r\n\r\napp.get('*', (req, res) => {\r\n    res.send('Hello World!');\r\n});\r\n\r\nserver.listen(PORT, () => {\r\n    console.log(`Server running on port ${PORT}...`);\r\n});\r\n```\r\n","Thanks for the reality check\r\n\r\nKnowing it is supposed to work helps. I wonder if something broke in Node 19. I'll continue to explore.\r\n\r\nMy code is essentially the same as yours though I preload the certificates generated using acme.sh. I'm also running on Windows with Node 19. I wonder if that could be a factor. Or firewall rules or any other attempts to be \"helpful\" in the path. I did try WSL but it may not be pure enough Linux.\r\n\r\n","I've narrowed my issue down. In debug mode, I'm told I have an invalid SNI context. What kind of object does your dynamicCeritify return? I've been using { context: {key, cert}} and that may be the culprit.","Got it to work using \r\n```\r\n cb(null,  tls.createSecureContext(sc));\r\n```"],"labels":["discuss","enhancement","ideas"]},{"title":"Implemented req.completeUrl","body":"Added new getter completeUrl to req object as discussed in #4697 \r\n1) should I make any changes?\r\n2) should I try adding any test cases?","comments":[],"labels":["enhancement","pr"]},{"title":"Clean architecture example","body":"Copy of the PR for the master version. The goal is to add an example on how to use Express with the Clean Architecture approach","comments":["I'm getting an \"Unexpected identifier\" error up to Node v 6.17. Installing that version of node locally I'm not able to make tests run. Could someone help me? Or maybe we can publish the ES5 version that works fine and add a comment that tells users to use ES6 classes instead","Hi @dougwilson could you merge the pr? Or do you have other advice to improve the example? :) ","Thanks for your work! I can't help but notice this example seems very similar to our mvc example, splitting the apps into sets of object operations by file and such. What are the differences this example does from the mvc one? ","> Thanks for your work! I can't help but notice this example seems very similar to our mvc example, splitting the apps into sets of object operations by file and such. What are the differences this example does from the mvc one?\r\n\r\nGood question! When I was studying the clean architecture I made myself the same question. The answer is subtile. We can say that the Clean Architecture is a set of principles that you have to follow when you create the architecture. You can build really complex architectures like [this](https:\/\/github.com\/Sairyss\/domain-driven-hexagon) (but I wanted to keep the example simple). \r\n\r\nMVC (for some aspects) could be seen as a subset of Clean Architecture but the use of MVC doesn't guarantee the respect of all the Clean Architecture rules.\r\n\r\nYou can find more in [this](https:\/\/softwareengineering.stackexchange.com\/questions\/336677\/what-is-the-difference-between-mvp-and-clean-architecture) topic.","Hi @import-brain, sorry for the ping but I don't know how to progress with this PR. Do you think it could be merged or are required other approvals? ","> Hi @import-brain, sorry for the ping but I don't know how to progress with this PR. Do you think it could be merged or are required other approvals? \n\nNo worries :)! I do not have PR merge permissions on this repo. @dougwilson, what do you think?","Sorry about that, thanks for the ping! So I guess reading your response there, I'm just really confused. Does \"Clean Architecture\" mean something? Is there a link to where that is defined? I thought that was just a term you were using to describe your example and didn't mean anything further :) ","> Sorry about that, thanks for the ping! So I guess reading your response there, I'm just really confused. Does \"Clean Architecture\" mean something? Is there a link to where that is defined? I thought that was just a term you were using to describe your example and didn't mean anything further :)\r\n\r\nHi, sure! Clean Architecture is the name of the book by Robert C. Martin (the same author of the book Clean Code) and describes a set of rules and best practices to create scalable architectures. You can find the book on Amazon and by searching onine you can find other releated resources :) ","> Sorry about that, thanks for the ping! So I guess reading your response there, I'm just really confused. Does \"Clean Architecture\" mean something? Is there a link to where that is defined? I thought that was just a term you were using to describe your example and didn't mean anything further :)\r\n\r\nHi  @dougwilson i think the main difference between this example and the mvc is the usage of that pattern, this example in my opinion is a pure backend microservice which expose some REST api (a crud in this case).\r\nThe [mvc](https:\/\/github.com\/expressjs\/express\/tree\/master\/examples\/mvc) example looks like server side rendering, it expose some url in GET and return an html template to render.\r\nAlso if we watch in deep, in this pull request we can see an Object Oriented way (obviusly with common js compatibility \ud83d\ude03) but that is the idea behind it.","HI @dougwilson! Sorry for the ping XD. I would really appreciate a feedback on the PR if you have time. I have followed your advice. Now I think everything is correct :) ","Hi @dougwilson  :) I see that the RR is still pending. Would you consider merging it? :) ","Hi @dougwilson, do you think is worth merging it? If not, I can just close the PR to keep the repo as clean as possible :) "],"labels":["examples","pr"]},{"title":"response.download does not return \/proc\/* files","body":"response.download() returns empty for file under \/proc directory like \/proc\/meminfo, \/proc\/cpuinfo and others. \/proc is a pseudo filesystem, but these files' content can be readable with fs.readFile. I think it should also be readable with response.download and response.sendFile.","comments":["Hi @mleblebici yes, I agree they should be able to work. Unfortunately I just use Windows mainly and don't really have experience there on what would be wrong. Express is just using `fs.createReadStream` under the hood to read them. Would you be willing to make a pull request with a fix?","Hi @dougwilson, it seems the problem stems from send module. Normally fs.createReadStream is able to read contents of \/proc\/* files, but when using send module, it introduces a problem somewhere. I used following code and it was not able to read the contents.\r\n\r\n```\r\nvar http = require('http')\r\nvar send = require('send')\r\n\r\nvar server = http.createServer(function onRequest(req, res) {\r\n\tsend(req, '\/proc\/version').pipe(res)\r\n})\r\n\r\nserver.listen(1234)\r\n```","Hi @mleblebici thanks for investigating! Can you open a bug over there? Ideally if you can open a pull request with a fix, as I don't think I can personally fix it due to not having the \/proc\/ stuff on my system to use for testing what is wrong.","Hi @dougwilson , I also investigated the problem with send library. It seems fs.stat returns size of 0 for \/proc\/* files. So, I added a getSize function to correctly get size of \/proc\/* files. It fixed the problem. But, as I am not a developer (especially not a JS developer), you should probably check to make sure it does not cause any performance issue or create any additional bug.\r\nIssue Link: https:\/\/github.com\/pillarjs\/send\/issues\/212\r\nPR Link: https:\/\/github.com\/pillarjs\/send\/pull\/213","Thanks! Have you checked with the Node.js project that fs.stat returning a size of 0 for those files is not simply a bug in their stat function? We'll want some kind of confirmation before landing a change like that.","Virtual files such as `\/proc\/meminfo` don't have a known size and `stat` syscall returns size 0 for them.","Thanks @krzysdz ! Well, that sucks, as normal files that are zero size also return zero :(","Btw, you may want to check this one https:\/\/github.com\/nodejs\/node\/issues\/43669","> Thanks @krzysdz ! Well, that sucks, as normal files that are zero size also return zero :(\r\n\r\nWell, if the file size is zero, maybe don't set the `Content-Length` header? The files in `\/proc`\/`\/sys` are usually small enough that unknown time-remaining is a non-issue here, and actual empty files will end the stream immediately anyway.","the response.download function uses pillarjs\/send which uses fs.stat to get the size of the file and set the http headers accordingly. then uses the size to generat fs.createReadStream options (start , end ) which is (0,0) this contributes to reciving an empty file.\r\nthe reason fs.stat gets a zero size is that it uses unix system call `stat` which return size 0 for \/proc files and other virtual system.\r\na solution for this is to create special case handler for virtual files in pillarjs\/send. I dont think that is needed as you can use fs directly. \r\n\r\n>  I think using response.download to access \/proc files should not be considered a good practice system information should not be accessed through a web server . they should at least get apprpriate processing.\r\n \r\n``` javascript\r\nconst path = '\/proc\/meminfo';\r\n\/\/ set the header so that the file will download instead of show in the browser \r\nres.setHeader('Content-Disposition',' attachment; filename=\"meminfo\"')\r\nfs.createReadStream(path, 'utf-8').pipe(res);\r\n``` "],"labels":["bug","module:send"]},{"title":"TypeScript Example (CJS)","body":"The following PR relates to a simple TypeScript implementation using `express@5.0`.\r\n\r\nAdditionally, example (found in `examples\/typescript`) includes a `tsconfig.json` that compiles down to `ES5` JavaScript. A merge request I made previously had failed some tests relating to version limitations (node), so this should handle that case.\r\n\r\nHowever, the compiled JavaScript and other generated assets are set to be tracked via VCS (`git`). It's of normal operation to usually *untrack* them via including `*.js` in the `.gitignore`. \r\n\r\nWe can later add a `.gitignore` in the example folder itself. But I do want to see what the GitHub actions returns with. If appropriate, I'll update\/discuss changes to these tests to account for the typescript example.\r\n\r\n---\r\n\r\n## Discussion ##\r\n\r\nLooking at the other example folders, often they are without `README.md`s, `package.json`s, etc. etc.\r\n\r\nWhile totally fine, the example this PR relates to, as well as another I have outstanding, perhaps could be exceptions. I know the package maintainers and other contributors see, almost daily, issues & questions relating to ESM, TypeScript, and even both.\r\n\r\nProviding examples, like this one, hopefully will make everyone's life a bit easier `:D`.","comments":["Nice, seems to have passed","@bozzelliandrea, thank you for the feedback; I've since updated with your [recommended changes](https:\/\/github.com\/expressjs\/express\/pull\/4942\/commits\/bd67010a156cb8747f56f6954c5d1705d78bdda3), and point of replacing [`require` with `import`](https:\/\/github.com\/expressjs\/express\/pull\/4942\/commits\/18fa4f8d470dd47a4017533907178aa9d93bb0f4).\r\n\r\nSorry my response took so long, I'll try and get back sooner next time around `:D`.\r\n\r\nP.S. I updated the `tsconfig.json` and `package.json` to align much closer to what a standard, default configuration would look like. Notice, too, the `latest` package version reference(s).\r\n\r\nUsing `latest` is to avoid (haha hopefully) any technical debt down the road with issues coming through asking to update the `typescript` example.","> @Segmentational everything looks ok and clean, nice work! \ud83d\ude03\r\n> \r\n> Just my curiosity, what does CJS mean?\r\n\r\n@bozzelliandrea, sorry for the delayed response... I just moved halfway across the united states, so that took a little time haha.\r\n\r\nYeah, \"`CJS`\" can be seen in a few odd places in the `node` official documentation. The first example, although referenced as a file extension, can be seen here: \r\n\r\n- https:\/\/nodejs.org\/api\/modules.html#enabling\r\n\r\nI'm unsure of the exact other places, but essentially it's a shorthand sometimes used to describe the `commonjs` javascript module type."],"labels":["examples","pr"]},{"title":"fix(res.send): add Content-Length header only if Transfer-Encoding is not present","body":"## Intent\r\n- Because `Content-Length` and `Transfer-Encoding` can't be present in the response headers together, `Content-Length` should be added only if there is no `Transfer-Encoding` header.","comments":["Hey @dougwilson ,\r\nDoes this PR look good to you or do I need to adjust something else?","Hey, sorry I was just trying to get the new release out. It looks like you still need to add a test for the change to res.redirect, as that was changed too.\r\n\r\nI also took a look in the Node.js source and they also have logic for content-length vs transfer-encoding, but node.js only does stuff if transfer-encoding contains chunked while here is it any value (even a single space character). Is that intentional? Should we follow what the node.js logic is? It may help if the underlying issue you ran in to for this change was disclosed.","Hey @dougwilson,\r\nNo worries. As far as I understand it doesn't matter if `transfer-encoding` contains chunked or not. `transfer-encoding` header can't be present with `content-length` in response headers at the same time. Please correct me if I'm wrong.\r\n\r\nAbout the issue we are running in.\r\nWe are building this https:\/\/github.com\/sasjs\/server NodeJS wrapper for calling the SAS binary executable and we are building some endpoints for test purposes that mock some external API. And to do so we need to respond with exact same headers and payload. And this external API uses `transfer-encoding` header that I can't set because in such case I'll have both  `transfer-encoding` header and `content-length` header in my response. I've been also trying to delete `content-length` header from response before setting `transfer-encoding`, but it didn't work.","Ah, ok. Can you add tests for other values of transfer-encoding besides chunked as well, then? We want to make sure that res.send will work with other values too.\r\n\r\nAs for mocking exact replicas of other apis, you typically want to use the lower-level apis for that like res.write and res.end instead of res.send.","Hey @dougwilson,\r\nSorry for the late responce- I've been on vacation.\r\nAnd thank you for suggestion to use `res.write`.\r\nI reverted changes to `res.redirect` to dedicate current PR to `res.send`. I adjusted my unit test to cover all tranfer-encodings.\r\nPlease let me know if something else is needed to be done.\r\n\r\nRegards,\r\nYury\r\n","Hey! It's no problem at all :) Thanks for adding to the tests. But I think there is an issue with them: though you added other values, it does not seem like res.send is actually honoring them. For example, if you have Transfer-Encoding: gzip set, can the test show that res.send will actually send it as gzip? Example I would expect `res.set('transfer-encoding').send({foo:'bar'})` to be a gzip response with this changeset, right?","Hey @dougwilson!\r\n\r\nCan we actually test that our response transforms to gzip? I think its very low level and I'm not sure that nodejs can transform our response to gzip\/compress\/deflate. Because I did not find any mentions about `transfer-encoding` that it can be a gzip\/compress\/deflate response, only it\u2019s a chucked(nodejs documentation). But okay, we exactly know that our response can be transformed to chunks and how we can test it? I don\u2019t have a clue. \r\n\r\nOf course tools like `zlib` can be used for `content-encoding` but it's not the same as `transfer-encoding`. (mention it to not to be confused)\r\n\r\nI have a suggestion to check our response for having a `transfer-encoding` header with value that we set on the server but I\u2019m not sure about do we need this. And if we need this check, can I do this commit? I want to make my first contribution to open source!\r\n\r\nPlease, correct me guys if I\u2019m wrong. Thank you!","You can check the spec for transfer-encoding at https:\/\/datatracker.ietf.org\/doc\/html\/rfc9112#name-transfer-encoding\r\n\r\nThe very first example shows how it can invlue gzip.","@dougwilson Do you expect that response has corresponding `Transfer-Encoding`? e.g. if we set `Transfer-Encoding: gzip` on server, we should get it in response on client?"],"labels":["needs tests","pr"]},{"title":"How to hold a response? And are there something called \"maxHeldResponseCount\"?","body":"1. I want to implement a long-polling model in my server (express.app).\r\n2. I use a map to stored incoming response, waiting (about 60 seconds later) another request to finally send stored response back.\r\n3. I find the store action will block other incoming request. I mean, the callback of `app.post(\"xxx\"...)` is not called until I close some of stored responses in step 2.\r\n\r\nSo, I wonder:\r\n\r\n1. Is it a right method for me to store response from `app.post` to implement long-polling?\r\n2. Does express.js itself set max concurrent count of held responses?","comments":["Hi @HaloWang there should not be any issue holding on to the objects like thay. As for why your other requests are being blocked, I'm not sure. Express itself does not have any limitation on the number of max concurrent requests. We may need you to provide code and instructions to reproduce the issue so we can help debug."],"labels":["awaiting more info"]},{"title":"Extend res.links() to allow adding multiple links with the same rel #2729","body":"This pr fixes #2729\r\n\r\nI've done the following:\r\n\r\n- [x]  Added a new test that covers my changes\r\n- [x]  Runned linter","comments":["Hi @dougwilson,\r\nseems like there is a problem with the Node.js 6.x ci test in the master branch, which runs with supertest@6.1.6. This problem doesn't occur in 4.18 branch, which has the Node.js 6.x ci test with supertest@3.4.2.\r\nShould I do something? Maybe should I close this PR and open the same for the 4.18 branch?\r\nLet me know \ud83d\ude0a","Hi @andvea no need to do anything. We'll get it fixed up as it get close to landing. Sorry for any confusion there. An issue like that which is not caused by your PR can typically be ignored as it won't be held against your PR or anything :)","Great, wish you good work!"],"labels":["enhancement","pr"]},{"title":"Use object with null prototype for various app properties","body":"See [discussion here](https:\/\/github.com\/expressjs\/express\/pull\/4835#discussion_r811355575).\r\n\r\n`app.cache`, `app.engines`, and `app.settings` are now created with `Object.create(null)` instead of `{}`.\r\n\r\nThis also adds a test that `app.locals` is created the same way.","comments":["This has been open for over a year. No rush from me, but let me know if there's anything I can do to move this along."],"labels":["enhancement","5.x","pr"]},{"title":"res.clearCookie() now ignores maxAge","body":"This pr fixes #4851.\r\n\r\nI have ...\r\n- [X] added a new test that covers my changes\r\n- [X] run linter","comments":["Testing the changes, in the unit-test:\r\n\r\n```\r\n  \/\/ ... blah blah blah\r\n  [Symbol(kOutHeaders)]: [Object: null prototype] {\r\n    'x-powered-by': [ 'X-Powered-By', 'Express' ],\r\n    'set-cookie': [\r\n      'Set-Cookie',\r\n      'sid=; Path=\/admin; Expires=Thu, 01 Jan 1970 00:00:00 GMT'\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nconfirms the `maxAge` attribute is indeed removed. Output following the `request.end()` call yields\r\n\r\n```\r\n\/\/ ... blah blah blah\r\n _maxListeners: undefined,\r\n  _enableHttp2: false,\r\n  _agent: false,\r\n  _formData: null,\r\n  method: 'GET',\r\n  url: 'http:\/\/127.0.0.1:46159\/',\r\n  _header: {},\r\n  header: {},\r\n  writable: true,\r\n  _redirects: 0,\r\n  _maxRedirects: 0,\r\n  cookies: '',\r\n\/\/ ... blah blah blah\r\n```\r\n\r\nGreat, cookies are not set in the raw http response!\r\n\r\nDue to my little experience in our test suite, another PR would be useful. But to my understanding things are looking good."],"labels":["5.x","pr"]},{"title":"`res.clearCookie()` does not ignore `maxAge`","body":"Hi everyone!\r\nI just ran into a bug, where `res.clearCookie()` does not work properly.\r\n\r\n## What happen?\r\nAccording to the typescript definitions, `res.clearCookie()` accepts `CookieOptions` as a second parameter (see [here](https:\/\/github.com\/DefinitelyTyped\/DefinitelyTyped\/blob\/23e0b071471f0120d7c03c5abf206f41e832133b\/types\/express-serve-static-core\/index.d.ts#L920)) which includes the `maxAge` attribute. But if the `maxAge` is set, the cookie won't be deleted.\r\n\r\n## What do I expect?\r\n`.clearCookie()`should ignore (or delete) the `maxAge` attribute, because it is used to calculate the `expire` attribute afterwards in `.cookie()`;\r\n\r\n## Research\r\nI already located the bug and would like to provide a pr to fix this.\r\n","comments":["I had the same problem a few days ago, thanks for the pr i want to try when it merged","Thank you for your work on this @tjarbo !","Please see #4252 for related discussion. This was original designed this way on purpose (ugh), and I see it being used in the wild this way. We can land such a change in the 5.0 branch, so I'm setting it to 5.0.","Added a review for [tgarbo's PR](https:\/\/github.com\/expressjs\/express\/pull\/4852)","Thank you @Segmentational !","Since #4252 is closed, I'll continue the discussion here:\r\n\r\nAs all the other options (domain, sameSite, etc) needs to be the same when clearing the cookie as when setting it, the natural thing to do is use the same `const OPTIONS` when clearing the current cookie as when setting it.  Anything that depends on the current behaviour is obviously broken.  If a new major is needed to fix this, then a new major is needed asap.\r\n\r\nBig thanks to @tjarbo for identifying the problem and provding a PR!"],"labels":["5.x"]},{"title":"Ignore settings on Object.prototype","body":"Before:\r\n\r\n```js\r\napp.get('hasOwnProperty');\r\n\/\/ => [Function: hasOwnProperty]\r\n\r\napp.enabled('hasOwnProperty');\r\n\/\/ => true\r\n```\r\n\r\nAfter:\r\n\r\n```js\r\napp.get('hasOwnProperty');\r\n\/\/ => undefined\r\n\r\napp.enabled('hasOwnProperty');\r\n\/\/ => false\r\n```\r\n\r\nSee #4802 for more details. Similar to #4803, but for Express 5.","comments":["Just rebased this.","Anything else I should do here? No rush from me, just wanna make sure I'm not blocking anything.","Hey! No, these 5.x changes are good. I'm just waiting to merge after the 4.x branch is merged in to reduce the merge conflicts is all. That should be very soon, as the 4.x changes landed are supposed to be out next week! Thank you for your hard work and discovering this issue. API is more sane now thanks to you \ud83d\ude0a ","Great, thanks!!\n\nIf there are other things that need doing, feel free to reach out to me@evanhahn.com and I'll see if I can help.","This has been open for over a year. No rush from me, but let me know if there's anything I can do to move this along."],"labels":["enhancement","5.x","pr"]},{"title":"[feature request] disable decode_param for path routing","body":"I have some special urls thats get mapped to local files like image50%.png.\r\n\r\n```\r\napp.get('\/open\/:path(*)', (req, res) => {})\r\n```\r\n\r\nBut it doesn't work because express automaticly calls decode_param.\r\nIt throws `Failed to decode param`.","comments":["Hi @lublak sorry you are having trouble. There is no need to disable the decoding for this. Your client should be sending the URL as a valid encoding of `\/open\/image50%25.png` \ud83d\udc4d . If you really want to avoid decoding for your use-case if you need to accept improperly encoded URLs, you can use something like `app.use('\/open', (req, res) => {})` and then `req.url` will just be the part after `\/open`. I hope that helps!","Apologies, I didn't mean to close the issue, as we could add some kind of app-level config to disabled\/custom the param decoding.","@dougwilson The problem is that the client is Firefox and it sends this over quite validly (not with %25) the user of course enters image50%.png and not image50%25.png.\r\nI will try that with `app.use('\/open', (req, res) => {})` tomorrow.","Hi @lublak by invalid, I am referring to what Express.js considers invalid. The reason you are getting the error is indeed because the URL is invalid according to Express.js, as it expects parameters to be URL-encoded and if the JavaScript function to decode URL-encoded strings, `decodeURIComplement` throws as invalid, then Express.js will bubble up that error. I did not make any statements regarding how Firefox works, of course, though my understanding is it will send whatever the user types in, regardless of what the web server is expecting. My guess, though, is that Firefox will still turn spaces into `%20`, so if you disable the param decoding, a URL like `\/open\/foo bar.jpg` will end up as `foo%20bar.jpg` on the server when you have decoding disabled, even if the user typed in a literal space, so turning it off probably has down sides.","@dougwilson That's right I didn't think about that of course blank characters are then given as %20 by the browser. The same is true for other characters like \"\u00e4\".\r\nFor me it means that all \"invalid\" % characters must be replaced by %25 to decodeURIComplement .\r\n\r\n```js\r\napp.use('\/open', (req, res) => {\r\n   const path = decodeURIComplement(makeItValid(req.url));\r\n})\r\n```\r\nI will try to implement it tomorrow. Thanks for the thought :)","No problem. The current behavior of decoding params won't be changed, as there can be security implications of your proposal, but it would depend on the application if they are relevant or not. But the feature request, as I see it, would allow the user (like yourself) to implement any kind of decoding routine as they see fit, which would allow you to write any type of logic that works for your particular use case \ud83d\udc4d ","@dougwilson for me it works fine :) thanks for your tip.\r\nBut i decided only support some %. `urlPath.replace(\/%([&$%.-_ #?=*\/]|$)\/g, '%25$1')`"],"labels":["question","module:router"]},{"title":"[suggestion] send\/respond with blob","body":"NodeJS now has support for Blob's globally, \r\n...earlier you had to load it from `require('buffer').Blob`\r\n\r\nit would be cool \/ awesome if it where possible to respond with a Blob by doing something like\r\n\r\n```js\r\nconst str = `<h1>Hello World<\/h1>`\r\nconst blob = new Blob([str], { type: 'text\/html' })\r\nconst file = new File([blob], 'index.html', { type: 'text\/html' })\r\n\r\napp.get('\/', (req, res) => {\r\n  res.send(blob) \/\/ or:\r\n  res.download(blob, 'name.html')\r\n  res.download(file) \/\/ name taken from file instead\r\n})\r\n```\r\n\r\nDoing this would take care of \r\n1. Setting the response header `content-type` to the blob's type (only if content-type haven't been set manually)\r\n2. Setting the response header `content-length` to the blob's size\r\n3. and pipe the data from `blob.stream()` to the response\r\n4. if you used `res.download(blob)` then it would also add content-disposition attachment header\r\n\r\n<s>it's also looking like if node will at some point add a way of getting blobs from the filesystem also, but i don't know when.\r\nref: https:\/\/github.com\/nodejs\/node\/issues\/39015<\/s>\r\n\r\nedit: NodeJS just shipped `fs.openAsBlob(path, { type })` in v20+\r\n","comments":["I think this is a great idea. ","Yeay, then I could take advantage of [fetch-blob\/from.js](https:\/\/github.com\/node-fetch\/fetch-blob#blob-part-backed-up-by-filesystem) methods that can retrieve a Blob\/File from the file system. or use undici or node-fetch `await res.blob()` even\r\n\r\nIf you would accept 3th party blob look-a-like objects ofc...\r\n\r\nthis idea came to me when i worked on a current project that uses a template engine.\r\ni just thought, wouldn't it be nice if consolidate.js or the static folder plugin could just simply give you a blob instead :P\r\n\r\n```js\r\nvar cons = require('consolidate');\r\ncons.swig('views\/page.html', function(err, blob){\r\n  res.send(blob)\r\n});\r\n```\r\n\r\nSo if Blob are not the only thing you are going to support, then there is one extra idea coming from the `File` object\r\nand that is to send lastModifiedDate as a caching header.\r\nand also use the `file.name` when downloading using `res.download(file)`","Hi @dougwilson  , i want to take up this issue can you please assign me ?","fyi, NodeJS just shipped `fs.openAsBlob(path, { type })` in v20+ \r\nwish I where able to use it now.","No worries, there is a PR open that is very close to landing \ud83d\udc4d . Should be in the next Express release."],"labels":["ideas"]},{"title":"Issue #4788 - ESM Module Example","body":"It's getting incredibly late here, but I mocked up a quick example that demonstrates how to use `express` via an ESM module. I've been using ECMA modules for a little while now, and can include a much more complex example upon request. There's a bit of power using modules vs. the CommonJS approach. Imho, as an example, it's a bit easier to add middleware. There's a lot of ease, too, when using `async`. \r\n\r\nHowever, `express@^5` is required. I believe this has to do with the impressive compatibility `express` has kept with the various node versions. ","comments":["Whoops, I forgot to mention Issue #4788. I'll include a link back to this there, too.","Note -- this was ran on the latest LTS version of Node.js."],"labels":["examples","pr"]},{"title":"Ability to get req and res context inside json replacer","body":"More info can be found here. Kindly have a look:\r\nhttps:\/\/github.com\/expressjs\/express\/pull\/3981","comments":["Hi @prkeshri thank you for bringing up this idea. Can you outline what typical use cases this feature would be used for?"],"labels":["ideas"]},{"title":"custom ETag function isn't working for SendFile","body":"I set the custom function according to the http:\/\/expressjs.com\/en\/api.html#etag.options.table\r\n```\r\napp.set('etag', function (body, encoding) {\r\n  return generateHash(body, encoding) \/\/ consider the function is defined\r\n})\r\n```\r\nDespite on that it's not working and the best way I could influence etag value is to call\r\nsendFile with etag : true or false but this just turns on and off the standard etag (also not documented) , not the custom one.\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/issues\/2294\r\nhttps:\/\/github.com\/expressjs\/express\/issues\/2129\r\n\r\n\r\nMy use case is that I want to track responses of specific files. So I wanted to make a \"strong hash\" that I can be 100% sure would  unambiguously represent the file.","comments":["Hi @kokushkin thank you for bringing this up. Yes, the current etag setting does not affect files, as calculating an etag for a file is noy always trivial. For example, a file can be multiple gigabytes in size and it is not practical to hold the entire contents of a file in memory in order to invoke the etag setting.\r\n\r\nYou can currently calcualte your etag and set the etag header using `res.header` and it will not be replaced by the framework.\r\n\r\nWe can determine what kind of API would be needed otherwise in order to assist in calculating the etag for a file. What do yoi currently do to calculate the etag of these files, may I ask?","Well, I've solved my problem by just calculated it's sha256 digest using \"crypto\" and writing the result into the log. But initially I tried to use \"morgan\" together with the standard ETag functionality of \"express\". I think I even tried to make it explicitly with res.header and it didn't work out (morgan was enable to access etag for some reason) but I'm not sure, I might try  it again and give you feedback). So, the initial thought was to hook into the process and say I wanna get absolutely unique digest for some types of files, let's say *.jpg files no matter where they are in the routes and I couldn't do it so I have to explore the routes."],"labels":["awaiting more info"]},{"title":"Request: Introduce a `req.completeURL()` method","body":"When communicating with other systems, sometimes we need to send the complete URL. E.g. include the full `http:\/\/localhost:30000\/foo?a=45` in the response when accessing that URL.\r\n\r\n`req.originURL` becomes `\/foo?a=45`, but the scheme and hostname parts are lost. \r\n\r\n[node.js - How to get the full URL in Express? - Stack Overflow](https:\/\/stackoverflow.com\/questions\/10183291\/how-to-get-the-full-url-in-express) has 578 upvotes and the top answer has 871 upvotes. But there are also a gazillion other answers of varying correctness.\r\n\r\nThe suggestion from [the top answer](https:\/\/stackoverflow.com\/a\/10185427\/345716) is:\r\n```\r\nvar fullUrl = req.protocol + ':\/\/' + req.get('host') + req.originalUrl;\r\n```\r\n\r\nCould we \"officialize\" this and turn it into `req.completeUrl()` (or whatever name you prefer) so everybody uses the same solution that works reliably? I'm happy to create a PR for this one-liner, I just wanted to ask here first...","comments":["Hi @pmorch thanks for the suggestion! We can certainly consider this request, though it is tricky to add new helpers to `req` or `res` without a major version change due to existing applications possibility already providing those. In the meantime, you can add this functionality to your own applications like the following:\r\n\r\n```js\r\napp.request.completeUrl = () => `${this.protocol}:\/\/${this.get('host')}${this.originalUrl}`\r\n```\r\n\r\nAs for your oneliner, it may work fine for your application, but would need to be made robust for an implementation that would land in Express, it that is desired. For example, some parts of your oneliner take into account the `trust proxy` setting, but not others, the `req.originalUrl` may be a fully-qualified URL if the client sent the entire URL as the request-target, `req.originalUrl` may not exist in all locations in which a `req` helper may be called from, among other issues.","@dougwilson writes:\r\n> it may work fine for your application, but would need to be made robust for an implementation that would land in Express\r\n\r\nWhich is *exactly* why this should be in express and not cut'n'pasted from stackoverflow, where it works 60% of the time.","Hi, I am unable to get the complete URL using this. `var fullUrl = req.protocol + ':\/\/' + req.get('host') + req.originalUrl;`\r\n\r\nsuppose I am calling this on route \/getUrl\r\n\r\nI should get http:\/\/<server_ip>\/app\/users\/happy\/getUrl\r\n\r\ninstead I only get http:\/\/<server_ip>\/getUrl\r\n\r\n\r\nI am using Nginx as a reverse proxy.\r\n\r\n```\r\nlocation \/app\/users\/happy\/ {\r\n      proxy_set_header X-Real-IP $remote_addr;\r\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n      proxy_set_header X-NginX-Proxy true;\r\n      proxy_pass http:\/\/localhost:4216\/;\r\n      proxy_ssl_session_reuse off;\r\n      proxy_set_header Host $http_host;\r\n      proxy_cache_bypass $http_upgrade;\r\n      proxy_set_header X-Forwarded-Host $http_host;\r\n      proxy_set_header X-Forwarded-Server $http_host;\r\n      proxy_redirect ~\/(.*)$ \/app\/users\/happy\/$1;\r\n      proxy_http_version 1.1;\r\n      proxy_set_header Upgrade $http_upgrade;\r\n      proxy_set_header Connection \"Upgrade\";\r\n    }\r\n```\r\n\r\nI also tried adding \r\n`app.set('trust proxy', 'loopback');`\r\n"],"labels":["discuss","enhancement","ideas"]},{"title":"Express with SSL example","body":"This is an example how to use Express with SSL enabled.","comments":["Now this PR contains a simple example demonstrating only SSL."],"labels":["docs","examples","needs tests","pr"]},{"title":"POST request causing PreFlight and then getting cancelled after stalling","body":"I wrote  a simple API for learning using express, when I try to send a POST request from POSTMAN it is carried out and returns a success message but when POST is sent from client, PreFlight is issued and POST request after being stalled gets cancelled, after which PreFlight does return \"204 No Content\" success message. \r\n1. PreFlight must not be issued during POST request ?\r\n2. if it does how to make sure it does that it does not stall the POST request, or how to increase the timeout for POST request?\r\n\r\nmy  client side code is: \r\n```\r\n  button.onclick = addElement=> {\r\n            var key = document.getElementById('key').value;\r\n            console.log(\"button clicked\");\r\n            var value = document.getElementById('value').value;\r\n        \r\n            console.log(key);\r\n            var options = {\r\n                method : \"POST\",\r\n                headers : {'Content-Type': 'application\/json'},\r\n                body : JSON.stringify({\r\n                    'key':key,\r\n                    'value':value\r\n                })\r\n            };\r\n            console.log(\"initializing POST\");\r\n            const fet =  fetch('https:\/\/skiadrum.herokuapp.com\/data', options).then(response => {\r\n                console.log(response);\r\n                return response.json();\r\n            }).then(response => {\r\n                console.log(response);\r\n                document.getElementById('api_response').innerHTML = response;\r\n            })\r\n            .catch(error => {\r\n                console.log(\"post request failed\");\r\n                console.error(error);\r\n            });    \r\n\r\n        }\r\n```\r\n\r\n\r\nand the server POST request handler is:\r\n```\r\nvar postCorsOptions = {\r\n\t\"origin\": ['http:\/\/127.0.0.1:5500','http:\/\/127.0.0.1:5501'],\r\n\t\"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\",\r\n\t\"preflightContinue\": false,\r\n\t\"optionsSuccessStatus\": 204,\r\n    \"Content-Type\":\"appllication\/json\"\r\n}\r\n\r\napp.post(\"\/data\", cors(postCorsOptions) , (request, response) => {\r\n    var file = request.body;\r\n    console.log(file.value);\r\n    console.log(\"post request recieved in server\");\r\n    reply = {\r\n        'status': 'success',\r\n        'data_recieved' : {\r\n            'key': request.body.key,\r\n            'value': request.body.value\r\n        }\r\n    }\r\n    score[request.body.key]=request.body.value;\r\n    try{\r\n        fs.writeFile('score.json', JSON.stringify(score, null, 2), err => {\r\n            console.log(\"writing into the file from post request\");\r\n        });\r\n    } catch(error){\r\n        console.error(error);\r\n    }\r\n    \r\n    response.send(reply);\r\n});\r\n\r\n```","comments":["In your server-side code, why do you attach `cors()` as a middleware to the route and not as a global middleware in your `server.js`\/`index.js` ?\r\n\r\nwhat happens if you do something like this?\r\n```javascript\r\nconst cors = require('cors')\r\n\/\/ other declarations\r\n\r\napp.use(cors())\r\n\/\/ other middlewares\r\n\r\napp.post('\/data', async (req, res) => { \r\n    \/\/ other logic\r\n})\r\n```","@am-a-man \r\nI believe this issue occurs because the browser considers this request as complex and requires a pre-flight request, the browser sends this pre-flight request with method set to OPTIONS instead of POST. The [documentation](https:\/\/expressjs.com\/en\/resources\/middleware\/cors.html#enabling-cors-pre-flight) suggests how to deal with this.\r\n\r\nGoing through the Network tab in the browser dev tools might give a better idea of the HTTP headers of the options pre-flight request.\r\n","> I wrote a simple API for learning using express, when I try to send a POST request from POSTMAN it is carried out and returns a success message but when POST is sent from client, PreFlight is issued and POST request after being stalled gets cancelled, after which PreFlight does return \"204 No Content\" success message.\r\n> \r\n> 1. PreFlight must not be issued during POST request ?\r\n> 2. if it does how to make sure it does that it does not stall the POST request, or how to increase the timeout for POST request?\r\n> \r\n> my client side code is:\r\n> \r\n> ```\r\n>   button.onclick = addElement=> {\r\n>             var key = document.getElementById('key').value;\r\n>             console.log(\"button clicked\");\r\n>             var value = document.getElementById('value').value;\r\n>         \r\n>             console.log(key);\r\n>             var options = {\r\n>                 method : \"POST\",\r\n>                 headers : {'Content-Type': 'application\/json'},\r\n>                 body : JSON.stringify({\r\n>                     'key':key,\r\n>                     'value':value\r\n>                 })\r\n>             };\r\n>             console.log(\"initializing POST\");\r\n>             const fet =  fetch('https:\/\/skiadrum.herokuapp.com\/data', options).then(response => {\r\n>                 console.log(response);\r\n>                 return response.json();\r\n>             }).then(response => {\r\n>                 console.log(response);\r\n>                 document.getElementById('api_response').innerHTML = response;\r\n>             })\r\n>             .catch(error => {\r\n>                 console.log(\"post request failed\");\r\n>                 console.error(error);\r\n>             });    \r\n> \r\n>         }\r\n> ```\r\n> \r\n> and the server POST request handler is:\r\n> \r\n> ```\r\n> var postCorsOptions = {\r\n> \t\"origin\": ['http:\/\/127.0.0.1:5500','http:\/\/127.0.0.1:5501'],\r\n> \t\"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\",\r\n> \t\"preflightContinue\": false,\r\n> \t\"optionsSuccessStatus\": 204,\r\n>     \"Content-Type\":\"appllication\/json\"\r\n> }\r\n> \r\n> app.post(\"\/data\", cors(postCorsOptions) , (request, response) => {\r\n>     var file = request.body;\r\n>     console.log(file.value);\r\n>     console.log(\"post request recieved in server\");\r\n>     reply = {\r\n>         'status': 'success',\r\n>         'data_recieved' : {\r\n>             'key': request.body.key,\r\n>             'value': request.body.value\r\n>         }\r\n>     }\r\n>     score[request.body.key]=request.body.value;\r\n>     try{\r\n>         fs.writeFile('score.json', JSON.stringify(score, null, 2), err => {\r\n>             console.log(\"writing into the file from post request\");\r\n>         });\r\n>     } catch(error){\r\n>         console.error(error);\r\n>     }\r\n>     \r\n>     response.send(reply);\r\n> });\r\n> ```\r\n\r\n```\r\nvar postCorsOptions = {\r\n\t\"origin\": ['http:\/\/127.0.0.1:5500','http:\/\/127.0.0.1:5501'],\r\n\t\"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\",\r\n\t\"preflightContinue\": false,\r\n\t\"optionsSuccessStatus\": 204,\r\n    \"Content-Type\":\"appllication\/json\"\r\n}\r\n```\r\n\r\nYou should put all the request methods in an array. "],"labels":["question"]},{"title":"`ext` should be case-insensitive for view engines.","body":"Actually, in issue https:\/\/github.com\/expressjs\/express\/issues\/4593, I provided _Express_ the `import`ed view engine instance.\r\nI registered it as `\"Eta\"` (`\".Eta\"` internally), and _Express_ did not use it for `search.eta` (because it was only looking for the `\".eta\"` one), triggering the undesired automatic `require`.\r\n\r\n```javascript\r\napp.engine(\"Eta\", Eta.renderFile);\r\nconsole.log(app.engines); \/\/ { '.Eta': [Function: renderFile] }\r\napp.set(\"view engine\", \"Eta\");\r\n```\r\n\r\n```javascript\r\nfunction View(name, options) {\r\n  var opts = options || {};\r\n\r\n  this.defaultEngine = opts.defaultEngine;\r\n  this.ext = extname(name);\r\nconsole.info(\"EXPRESS\", [name, extname(name)]); \/\/ EXPRESS [ 'search.eta', '.eta' ]\r\n  this.name = name;\r\n  this.root = opts.root;\r\n```\r\n\r\n-----\r\n\r\nMaybe it should normalize the `ext` to a single case?\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/5c4f3e7cc76fed9b42c27cebcdd9d66ef63092f9\/lib\/application.js#L293-L307\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/5c4f3e7cc76fed9b42c27cebcdd9d66ef63092f9\/lib\/view.js#L52-L88\r\n","comments":["Hm, that is a good point. I don't think such a change would be backwards compatible, but it could potentially be changed in a future major version of Express. I would like to leave this open to explore if folks are using the case sensitivity or not before we should decide on the change. Most file systems are not case insensitive. ","@dougwilson how would it not be backwards-compatible, except if a user foolishly specified 2 same-name view engines with only casing as a difference? Bumping as it may be a good time to take a decision on this issue with the v5 beta's?\r\nTo me it feels logical, just as an OS treats ..JPG & .jpg as the same ext.\r\nBut I would only support it if the  `toLowerCase` is only required at the view engine definition level (not for each template)","Hi @webketje thanks for your input. We are trying to refrain from continuing to snowball the 5.x release with endless changes, and ideally just the last few on the list are all that is left. The change can just be targeted to the next major.\r\n\r\nAs for why it is not backwards compatible, as stated, most file systems (particularly on servers) are not case insensitive, and so you can actually have both a `index.foo` and a `index.Foo` file. Unfortunately we do not have insight in to all the ways folks use Express, and we have many examples and experience that a change like this will break folks. Since we value a stable API where you don't have to worry about upgrading Express, this is a breaking change, as it would change the behavior of view engine extension registration. "],"labels":["ideas"]},{"title":"`App.use(path, ...)` Does Not Mount at `'\/\/'`","body":"`Router` instance mounted explicitly at `'\/\/'` exposes routes when path begins only with a single `\/`:\r\n\r\n```javascript\r\nconst TestRoutes = express.Router();\r\n\r\nTestRoutes.get('\/drop\/table\/:table', (req, res) => { \r\n  \/\/ drop table\r\n  res.send(`Dropped table '${req.params.table}'`);\r\n})\r\n\r\nTestRoutes.get('\/', sendListOfTestRoutes);\r\n\r\nif (TEST) app.use('\/\/', TestRoutes);\r\n\r\napp.listen();\r\n```\r\n\r\nExpected behavior is that navigating to `http:\/\/hostname\/` would bypass this `Router` and go to the main app, but instead Express serves the list of test routes mounted within the router at `\/\/`.","comments":["I didn't dive too deep into this, but when copying and slightly adapting your example code I noticed that it all seems to work as intended depending on if you mount your main app before or after `app.use('\/\/', ...)`. Your observed behavior seems to happen when the main app's routes are added after. If added before the subrouter is mounted, `\/` goes to the main app, `\/\/` to a test route.\r\n\r\nMounting at `\/\\\/\\\/\/` (regular expression vs `'\/\/'`) seems to work regardless of what line you put it but then you run into the problem that you need to access `TestRoutes.get('\/drop\/table\/:table', ...)` via `http:\/\/localhost\/\/\/drop\/table\/test`, with _three_ slashes.\r\n\r\n`app.set('strict routing', true)` didn't seem to help.","Hi @gebbber, does answer above addresses your issue?","Mounting at `\/\/\/` seems to provide the same result. I've currently implemented a workaround like:\r\n\r\n```javascript\r\nRouter.get(`\/`, sendListOfTestAdminRoutes);\r\nRouter.get(`\/adminRoute1`, adminRoute1);\r\n\r\napp.use(`\/\/\/`, Router); \/\/ mount at '\/\/'\r\n```\r\nThis mounts the routes at:\r\n* `http:\/\/host\/\/` for the 'list'\r\n* `http:\/\/host\/\/\/adminRoute1` for the specific route\r\n\r\nI would have expected it to mount the second route at `http:\/\/host\/\/adminRoute1`.\r\n\r\nThis is acceptable as a workaround in my project for now, because in `sendListOf...` the links are generated programmatically and the third `\/` can be coded in, but the behavior is not intuitive and could confuse me again if I need to come back to it later.\r\n\r\nAdmittedly, this seems like a pretty obscure use case.  Once I saw that `\/\/` is a legal route, though, it seemed like a clean choice for this type of application.","Hi @gebbber thanks for the report. I was able to reproduce the issue. I think this is similar to #3798 ; ideally your app should work like you expect when enabling strict routing, but in Express 4.x the strictness does not affect `app.use` statements. It may not be possible to fix this within 4.x due to breakages, but I think we could probably fix it within the 5.x series before it releases. I am currently back to work on getting the deps released to spin out the 5.x release I think within a few weeks or something. So if someone wants to take a stab at it, the sooner the better to land \ud83d\udc4d "],"labels":["question","module:router","awaiting more info"]},{"title":"clearCookie should probably only set one header per cookie name test case","body":"While developing a session termination feature in our apps I noticed that a cookie set by our session middleware to maintain cookie expiration was kept in the response even though the clearCookie was set at a later request handler. This test case attempts to replicate this circumstances.\r\n\r\n**According to https:\/\/tools.ietf.org\/html\/rfc6265#section-4.1.1:**\r\n>    Servers SHOULD NOT include more than one Set-Cookie header field in\r\n   the same response with the same cookie-name.  (See Section 5.2 for\r\n   how user agents handle this case.)\r\n\r\nDo you want filtration of setCookie-headers like this case to be handled within the expressjs framework, if so I could create a PR to fix that, or is this something that should be handled by expressjs users?","comments":["Hi @StefanWallin that is correct, all the cookie-setting functions just add to the outbound `set-cookie` header correctly. `res.clearCookie` is just a `res.cookie` with an expiration in the past (the http cookie spec doesn't have a special \"clear cookie\" command).\r\n\r\nUnfortunately it is quite hard to actually filter them out and thankfully the spec is SHOULD NOT and not MUST NOT. Web browsers out there currently have no issues receiving them like this and processing them in order. Part of what makes it hard to filter out is that you cannot just filter on the cookie's name -- you have to implement the full cookie-matching algorithm just to know if two of the cookies are the _same_ cookie."],"labels":["pr","tests"]},{"title":"Some fetch similarities","body":"I was wondering if we could have a few of the methods that exist on the `window.Request.prototype` since we are all mostly familiar with working with fetch on frontend and backend (using node-fetch\/undici). And maybe have it work a little bit like a service worker.\r\n\r\nnamely\r\n- Request.prototype.arrayBuffer\r\n- Request.prototype.text\r\n- Request.prototype.formData\r\n- Request.prototype.blob\r\n- Request.prototype.json\r\n\r\nAll of this returns a promise with the hole body being parsed. so you don't have to work with streams\r\n\r\nSo instead of having to do this blocking request (that don't call the next handler until it's finish\r\n```js\r\n\/\/ manual body parser\r\napp.post(path, function (req, res, next) {\r\n  const chunks = []\r\n  req.on('data', data => chunks.push(data))\r\n  req.on('end', () => {\r\n    const body = Buffer.concat(chunks)\r\n    \/\/ do something with the hole body\r\n    req.body = JSON.parse(body.toString())\r\n    next()\r\n  })\r\n}, routeHandler)\r\n\/\/ or\r\napp.use(bodyParser.json(), routeHandler)\r\n```\r\nwe could just do what is normally done in service worker & the fetch api:\r\n```js\r\napp.post(path, async function routeHandler (req, res) {\r\n  const arrayBuffer = await req.arrayBuffer()\r\n  const text = await req.text()\r\n  const blob = await req.blob()\r\n  const json = await req.json()\r\n  const formData = await req.formData()\r\n})\r\n```\r\nThe benefit of this would be that your route handler would be able to retrieve request headers first. So you can validate more quickly if a user is authenticated, if the payload is too large by looking at the content-length, what kind of content-type they are sending etc \r\n\r\nofc it is also possible to do that already but it would would require 3 \r\nhandlers and look something like: `app.post(authenticate, bodyParser.json(), handler)` \r\n\r\nI don't know so much about formData since it requires some more work\/parsing and it would require some formdata package\r\n\r\nNode 15.8 introduced buffer.Blob so we also have that.","comments":["@jimmywarting There is a module `body-parser` that handle this cases. We don't need to implement the same thing in `express`.","The body-parser don't really to the same thing. the body-parser is a middleware that blocks the actual route handler that it should call after you have received the hole body. With this solution you call the handler first so you can validate cookies and other request headers and so on before you get the hole body.","I really like this idea, I haven't thad time to think about it enough to know if I think it should be included directly in Express, or be an official middleware though. But my spontaneous thought is that including it would be nice!\r\n\r\nI actually worked on something quite similar here:\r\n- https:\/\/github.com\/node-body\r\n- https:\/\/www.npmjs.com\/package\/@body\/json\r\n\r\nThe idea was that you should be able to just `await` the body wherever you need it, yielding the same benefits that you outlined in the first post \ud83d\ude4c \r\n\r\ne.g.\r\n\r\n```js\r\nconst getJsonBody = require('@body\/json')\r\n\r\n\/\/ ...\r\n\r\napp.post('\/v1\/users', async (req, res, next) => {\r\n  try {\r\n    const body = await getJsonBody(req)\r\n\r\n    \/\/ ...\r\n  } catch (err) {\r\n    return next(err)\r\n  }\r\n})\r\n\r\n\/\/ ...\r\n```"],"labels":["ideas","module:body-parser"]},{"title":"Router events (enabling route documentation) \u2013 feature request","body":"I am very fond of the express router for it provides a great deal of flexibility. But I have somewhat problems keeping track of all the routes, middleware locations and methods.\r\n\r\nIt would be great if there was an event implementation that fires up, if e.g. a middleware handler, another route or a method handler is added.\r\n\r\nIt would then be easy to keep track of the routes and eventually build a documentation.\r\n\r\nSince the lines above might not well explain what I have in mind, I have given this some more thought an created a little example module, which is basically a wrapper\/decorator for the express router, which sort of mimics and extends the express router behavior.\r\n\r\nI hope this example helps explaining why an evented router might be helpful indeed. It's not great code, but rather a quick and dirty hack:\r\n\r\nhttps:\/\/github.com\/mkastner\/mk-express-router-doc\r\n\r\nI don't want to be pushing this too far: but if one could add some documentation on the fly to each respective route and path \u2013 that would be the icing on the cake.\r\n\r\n","comments":["@mkastner  This is a good idea, So we will display the `domain`, `method`, `URI` and `middleware`  for the routes it includes in the generated table. The most significant implementation is to add function like `debugRoutes` It will return the output as follows.\r\n```\r\n| Domain   |      URI      |  Method |  Middleware |\r\n|-------- -|:-------------:|--------:| -----------:|\r\n|          |  \/api         |   GET   | YES         |\r\n```","@getspooky Thanks for your postive response to my _musings_ on the router.\r\n\r\nYet, I was more leaning toward the idea of the router events being fired only once, when the application starts up. I.e. when the routes are being \"mounted\".\r\n\r\nLike in my example here:\r\n\r\nhttps:\/\/github.com\/mkastner\/mk-express-router-doc\/blob\/main\/test\/index.js\r\n\r\nIf you want the domain, you would have to have an actual request to take place. But then you could simply us a request logger. But that wasn't the concern I was focusing on.\r\n\r\nWhat I had in mind was something like:\r\n\r\n```javascript\r\nconst rootRouter = request('express').router();\r\nconst childRouter = request('express').router();\r\n\r\n\/\/ fires e.g. 'method' event -> {route: '\/', method: 'get', handler: ['anonymous'|functionName]); \r\nrouter.get('\/', someHandler);\r\nrouter.use('\/admin', childRouter);\r\n\/\/ fires e.g. 'middleware' event -> { parentRoute: '\/', route: '\/admin', method: '*', handler: ['anonymous',functionName]);\r\n```\r\n\r\nI'd like the events explain the structure of routes:\r\n\r\n- Which route(r) is parent?\r\n  Since each router knows its parent, it's possible to \"walk\" up the hierarchy to root.\r\n- What routes are mounted to each router?\r\n- What's their purpose? Is it a\r\n  - request handler?\r\n  - middleware?\r\n  - router?\r\n- What's the handler implementation:\r\n  - anonymous function\r\n  - named function\r\n\r\nBasically, what I am hoping for is an evented router creation which enables the api programmer to generate a living routing documentation based on the fired informations.\r\n","Hi this is actually something useful\r\nthanks for the idea @mkastner \r\ni would love to spare my skills on it @getspooky please do let me know what do you think "],"labels":["future"]},{"title":"; charset=utf-8 in Content-Type header breaks compatibility with Mosaic 2.1.1 ","body":"Hello, I know this has been asked before and I know the response is that CHARSET=UTF-8 is enforced in the package because of security concerns. \r\n\r\nThis has been discussed in this closed issue: https:\/\/github.com\/expressjs\/express\/issues\/3490\r\n\r\nHowever I have a particular use case. I run a site called theoldnet.com and I serve up 1990's internet content to people like me who collect vintage computers. \r\n\r\nThis means we are trying to access the site using old browsers like Mosaic 2.1.1. \r\n\r\nThese old browsers do not like the semi-colon suffix on modern Content-Type headers. It breaks the ability to render the page entirely. \r\n\r\nCan you tell me where this is enforced in the source code? If need be I can disable this myself and maintain my own fork. My service depends heavily on express and the entire point of the service is to provide cross-browser compatibility dating back to the worlds first web browsers. \r\n\r\nI did a search for text\/html; chartset=utf-8 in the code base and the dependencies. I could not find the cause of this charset being injected on every request.  \r\n\r\nYour help would be appreciated, thanks!","comments":["Hi @ssshake you can actually disable this without actually altering the source code at all. Basically, the charset is because you are telling Express.js to send a string, which it has to encode in some specific charset. This encoding is what is added to the content-type header. BUT if you provide Express.js with the raw bytes, since Express.js is no longer doing the encoding, it does not add the charset parameter it used (since it didn't do any conversion).\r\n\r\nAnother option, of course, is to not use the `.json` \/ `.send` \/ etc. helpers and instead use the Node.js APIs directly (`.write`\/`.end`).\r\n\r\nAnd last but not least, another option is to use something like `on-headers` (https:\/\/www.npmjs.com\/package\/on-headers) to alter the content-type header to strip it off right before it is sent.\r\n\r\nDepending on how, exactly, you are writing your responses would depend on which way is going to be the most straight-forward method.","This is great information, thank you very much!\r\n\r\nUsing write\/end sounds like the most drop-in solution to me but the first solution of the raw bytes sounds appealing. What I have is somewhat of a proxy and I really don't need express trying to handle anything except for in certain cases. \r\n\r\nCould you tell me how I could get started understanding how to do the first option you suggested?\r\n\r\nRegarding your last option I was trying to use a middleware to rewrite the headers but I'm guessing that's too early in the process. ","Hi @ssshake sorry for the delay in response; it may help if you wanted to provide an example of your use-case, especially because proxies should not have this issue, as they will use `.write`\/`.end` typically (see https:\/\/www.npmjs.com\/package\/express-http-proxy and similar packages).\r\n\r\nFor the first option, you just provide a `Buffer` object as the argument to `res.send`. How to get a `Buffer` object will depending on what exactly doing, so I don't have a way to provide an example about that aspect unless you can provide some example code that is not working as you expect.\r\n\r\nFor the last option, you have to use something like `on-headers` (https:\/\/www.npmjs.com\/package\/on-headers) to alter the content-type header to strip it off right before it is sent."],"labels":["question"]},{"title":"Add 'json stringifier' option","body":":sparkles: _**This is an old work account. Please reference @brandonchinn178 for all future communication**_ :sparkles:\n<!-- updated by mention_personal_account_in_comments.py -->\n\n---\n\nFixes https:\/\/github.com\/expressjs\/express\/issues\/4453\r\n\r\n**Please direct all discussion to the issue page**","comments":["Why is this PR blocked? Could any reviewer have an eye on it? "],"labels":["enhancement","pr"]},{"title":"Allow specifying JSON stringifier","body":"It would be great to be able to override the [`JSON.stringify`](https:\/\/github.com\/expressjs\/express\/blob\/508936853a6e311099c9985d4c11a4b1b8f6af07\/lib\/response.js#L1122-L1123) call in `res.json()`, to use `json-bigint` to serialize JSON objects","comments":["It looks like you opened a PR on this feature request before we could understand more. In order to ensure a conversation does not get fragmented, we will close this issue or the PR. Which one would you prefer us to keep open?",":sparkles: _**This is an old work account. Please reference @brandonchinn178 for all future communication**_ :sparkles:\n<!-- updated by mention_personal_account_in_comments.py -->\n\n---\n\nYou can close the PR until discussion here has concluded. Alternatively, I can change the PR to draft mode?","As long as draft mode prevents others from accidentally commenting on the pr that is fine \ud83d\udc4d\n\nI saw your issue open when I was running errands (and still am), but was going to ask what this helps enable that the json replacer setting cannot do. I looked at the module you referenced but couldn't see it documented what the stringify actually did (but I am mobile, so could have missed it).\n\nI know javascript has BigInt and JSON.stringify works with those no problems. Can you show what object you are trying to stringify that gives the wrong output?",":sparkles: _**This is an old work account. Please reference @brandonchinn178 for all future communication**_ :sparkles:\n<!-- updated by mention_personal_account_in_comments.py -->\n\n---\n\nTechnically speaking, people can still comment on closed PRs. I turned the PR into draft mode and added a comment to discuss on the issue page until further notice.\r\n\r\n> I know javascript has BigInt and JSON.stringify works with those no problems.\r\n\r\nThis isn't true. Neither `JSON.parse` nor `JSON.stringify` have BigInt support, which is a major source of frustration for me right now :)\r\n\r\n```js\r\n> 123948124923742397432n\r\n123948124923742397432n\r\n\r\n> JSON.parse('{\"x\":123948124923742397432}')\r\n{ x: 123948124923742400000 }\r\n\r\n> JSON.stringify(123948124923742397432n)\r\nUncaught TypeError: Do not know how to serialize a BigInt\r\n    at JSON.stringify (<anonymous>)\r\n```\r\n\r\nFor now, we're using the `json-bigint` library in order to have BigInt support when serializing\/deserializing JSON. That library has two options: either use the native BigInt or use the `bignumber.js` library. For other reasons that I won't go into, we're using the `bignumber.js` implementation, whose default JSON representation is a string\r\n```js\r\n> const BigNumber = require('bignumber.js')\r\n> let x = new BigNumber('123948124923742397432')\r\n> JSON.stringify({ x })\r\n'{\"x\":\"123948124923742397432\"}'\r\n```\r\nIn order to get it to serialize as a number, you have to use `json-bigint`'s function\r\n```js\r\n> const JSONbig = require('json-bigint')\r\n> JSONbig.stringify({ x })\r\n'{\"x\":123948124923742397432}'\r\n```","Ah, gotcha. So it would seem like using the json replacer option would work great for you use case. Is there something wrong with that setting that is keeping it from working for you?",":sparkles: _**This is an old work account. Please reference @brandonchinn178 for all future communication**_ :sparkles:\n<!-- updated by mention_personal_account_in_comments.py -->\n\n---\n\nI don't think that would work. The problem is if the replacer function converted a `BigInt`\/`BigNumber` into a number, it would lose the precision and get rounded off. But if the replacer function returned the `BigInt`\/`BigNumber` as a string (to keep the precision), it would serialize it as a string, not as a JSON number.\r\n\r\nI don't think there's a way to use the replacer function to return a string and tell `JSON.stringify` \"hey trust me this is a JSON number, interpolate it directly without quotes\".",":sparkles: _**This is an old work account. Please reference @brandonchinn178 for all future communication**_ :sparkles:\n<!-- updated by mention_personal_account_in_comments.py -->\n\n---\n\n@dougwilson Any update on this?","@dougwilson I think @brandon-leapyear makes a good case for why the json replacer function isn't adequate. I too think merging his PR would add powerful capabilities to Express. Any further thoughts?","yeah @dougwilson  i also think that @brandon-leapyear PR will help express","@dougwilson I'm having to work around this issue as well, so agree that merging this PR would improve Express overall. Thanks @brandon-leapyear for taking the time with the fix.","Hey people. Any updates on this? @brandon-leapyear 's PR hasn't been merged yet","Hi -- wondering if there are any updates on this, as I'm struggling with the same at the moment. \r\n\r\n@brandon-leapyear or others on the thread, would you mind sharing any current workarounds you have for this problem?",":sparkles: _**This is an old work account. Please reference @brandonchinn178 for all future communication**_ :sparkles:\n<!-- updated by mention_personal_account_in_comments.py -->\n\n---\n\nI believe the current workaround is to not use res.json, but manually run\nJSONbig.stringify. We have a custom middleware in NestJS that does this\nautomatically.\n\nOn Sat, Apr 23, 2022, 4:29 AM juanfabrega ***@***.***> wrote:\n\n> Hi -- wondering if there are any updates on this, as I'm struggling with\n> the same at the moment.\n>\n> @brandon-leapyear <https:\/\/github.com\/brandon-leapyear> or others on the\n> thread, would you mind sharing any current workarounds you have for this\n> problem?\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/expressjs\/express\/issues\/4453#issuecomment-1107456201>,\n> or unsubscribe\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AGUC75MGZEE6E4KGOIG3S5TVGPNKHANCNFSM4TIBOZRA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n","For anybody else looking at this issue, my temporary solution was to use the `json-bigint` library and just override the JSON methods for my whole app. This may be too drastic for some but with the codebase I have, it does the job and I have no qualms about it since it is transparent otherwise.\r\n\r\nI just put this code at the top of my `app.ts`\r\n```\r\nimport JSONBig from 'json-bigint';\r\n\r\n\r\n\/\/ DANGEROUSLY override JSON prototype methods to handle big ints.\r\nJSON.parse = JSONBig.parse;\r\nJSON.stringify = JSONBig.stringify;\r\n```","> I believe the current workaround is to not use res.json, but manually run JSONbig.stringify. We have a custom middleware in NestJS that does this automatically.\r\n> [\u2026](#)\r\n> On Sat, Apr 23, 2022, 4:29 AM juanfabrega ***@***.***> wrote: Hi -- wondering if there are any updates on this, as I'm struggling with the same at the moment. @brandon-leapyear <https:\/\/github.com\/brandon-leapyear> or others on the thread, would you mind sharing any current workarounds you have for this problem? \u2014 Reply to this email directly, view it on GitHub <[#4453 (comment)](https:\/\/github.com\/expressjs\/express\/issues\/4453#issuecomment-1107456201)>, or unsubscribe <https:\/\/github.com\/notifications\/unsubscribe-auth\/AGUC75MGZEE6E4KGOIG3S5TVGPNKHANCNFSM4TIBOZRA> . You are receiving this because you were mentioned.Message ID: ***@***.***>\r\n\r\nHey, I'm also figuring out a way to stringify BigInt using middleware. From the docs I understand one has to implement a middleware this way:\r\n\r\n```\r\nimport { Request, Response, NextFunction } from 'express';\r\n\r\nexport function logger(req: Request, res: Response, next: NextFunction) {\r\n  console.log(`Request...`);\r\n  next();\r\n};\r\n```\r\n\r\nSo I guess in your custom middleware, you must have modified the `res` object and manually stringified the BigInt values? Or is it a little more complex to implement, if you can share a code snippet, it would be super helpful!","@rohanrajpal I wrote a simple Nest JS interceptor which utilizes the `json-bigint` package under the hood which you may mind useful: \r\n\r\n```\r\nimport {\r\n\tInjectable,\r\n\tNestInterceptor,\r\n\tExecutionContext,\r\n\tCallHandler,\r\n} from \"@nestjs\/common\";\r\nimport { Observable } from \"rxjs\";\r\nimport { map } from \"rxjs\/operators\";\r\nimport JSONBig from \"json-bigint\";\r\n\r\n@Injectable()\r\nexport class BigintInterceptor implements NestInterceptor {\r\n\tintercept(context: ExecutionContext, next: CallHandler): Observable<any> {\r\n\t\treturn next.handle().pipe(\r\n\t\t\tmap((data) => {\r\n\t\t\t\treturn JSONBig.parse(JSONBig.stringify(data));\r\n\t\t\t}),\r\n\t\t);\r\n\t}\r\n}\r\n\r\n```","In the [mozilla docs](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/BigInt#use_within_json) they are recommending to create your own toJSON prototype function. So you dont need an extra package for it, of course you have to handle that on the client side too. \r\n`BigInt.prototype.toJSON = function () {\r\n  return this.toString();\r\n};`","Even so, it would still be valuable to have this feature. For example, such feature would not force changing the API contracts on existing APIs, if you want to convert to strings it will break previous clients.\r\nclient1 sending {\"some\":123} ,\r\n\r\nclient2 sending {\"some\":123291389123893981238921893892198321893198}. Can still work well if serialization and deserialization is done with json-bigint."],"labels":["discuss","enhancement"]},{"title":"Clarity on if it's safe to call next() after send()","body":"Branching https:\/\/github.com\/expressjs\/serve-static\/issues\/136#issuecomment-661169863 since it's more general than express-static\r\n\r\nThe use case I'm trying to catch is when the client aborts. I found in my unit testing it's actually hard to get express\/https.server to shutdown cleanly i.e. if the client aborts while the request is asynchronously talking to the database, https.server.close won't wait for that to finish\/won't wait for any in progress async middleware to finished before the \"close\" callback is called.\r\n\r\nI'm trying to add middleware at the beginning and end of each request to track what's still in progress independent of the connection being severed so I can delay fully closing if there's any middleware that might still use external resources. [on-finished](https:\/\/www.npmjs.com\/package\/on-finished) isn't what I'm looking for because if the client closes the connection in the middle of a request using async middleware \"close\" will be fired *before* all the middleware has finished.\r\n\r\nI'm trying to find official expressjs documentation saying it's unsafe to process middleware after sending the response (as long as you don't try to edit anything about the request object). I just realized I got the idea from this [non-official article](https:\/\/www.bennadel.com\/blog\/3275-you-can-continue-to-process-an-express-js-request-after-the-client-response-has-been-sent.htm#main-content) I know saying \"it works for me\" is not a sign that it's a supported use case but it is working so far. \r\n\r\nShould this be resolved by:\r\n 1) adding explicit wording in the documentation saying calling next() after end() is wrong and it should throw an error. I know I'm being pedantic but the docs currently say\r\n```\r\nIf the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function.\r\n```\r\nwithout being specific about about what's considered the full request-response cycle.\r\n\r\n2) making this a supported use case for people who don't want to block sending a response for server specific work tied to the middleware chain (and not specifically the connection) and adding tests to spot regressions.\r\n\r\n3) adding a dummy middleware that just calls res.end() and acts like 2) but with a delay and using https:\/\/github.com\/expressjs\/serve-static\/issues\/136#issuecomment-661125380 for serve-static.\r\n\r\nI'm a fan of 2. The only other option I see is adding checks after every promise in middleware to see if the request is active but that doesn't catch issues if the request is closed mid-await.\r\n\r\n\r\n\r\n","comments":["To clarify, yes, I tried  listening to \"finish\" and \"close\".  Given:\r\n\r\n```ts\r\nasync function myDatabaseMiddleWare(req, res, next) {\r\n   await databaseQuery1();\r\n   await databaseQuery2();\r\n  next();\r\n}\r\n```\r\n\r\nif server.close is called between databaseQuery1 and databaseQuery2, the \"close\" event will fire for req but the middleware will still try to call databaseQuery2. Express doesn't try to stop the rest of the middleware function.\r\n\r\nThis means server.close will return before its safe to actually tear down the database connection because it will still be used for databaseQuery2.  I'm trying to catch this with the (super simplified) code below.\r\n\r\n```ts\r\nlet requestsStillRunningMiddleware = 0;\r\n\r\n\/\/ at the start of the middleware stack\r\napp.use((req, res, next)=>{\r\n  ++requestsStillRunningMiddleware;\r\n  next();\r\n})\r\n\r\n\r\n\/\/ at the end of the middleware stack\r\napp.use((req, res, next)=>{\r\n  --requestsStillRunningMiddleware;\r\n  if(requestsStillRunningMiddleware=== 0){\r\n      \/\/ signal that it's safe to clean up resources used in middleware.\r\n   }\r\n})\r\n```\r\n\r\nBut it requires all middleware to call next, including the one that actually calls send(). \r\n\r\nYes, I am trying to implement a graceful shutdown system. There are some examples on the Express website: http:\/\/expressjs.com\/en\/advanced\/healthcheck-graceful-shutdown.html. All of them  keep track of connections between the client and the server. They do not keep track of connections between the server and backend services (postgres\/redis\/etc) except through explicit health checks. But this doesn't allow you to make sure no one is using those resources before you consider the server \"closed\" (I guess you could make the health checks return something other than just a 200 but then you're opening yourself up to race conditions).\r\n"],"labels":["question"]},{"title":"req.params undefined with unspecified res.format default","body":"Hello everybody,\r\n\r\nI'm using Express 4.17.1 and I ran into a problem where `req.params` is undefined in an `onFinished` call back that I recently added for error logging.\r\n\r\nI have a middleware which listens to `onFinished` and inspects the `req.params` for error logging.\r\nI also use `res.format` to choose between two different supported `Accept:` headers, but I don't specify a default since the documentation says it will return a 406 if unhandled, which is what I want.  I have a test that ensures that my server returns a 406 according to the documentation.\r\n\r\nMy 406 test fails because `req.params` is undefined so I can't navigate further into the object.  When I was trying to sort that out I added a `\"default\"` handler to `res.format` and then the `req.params` object was valid and parsed correctly.\r\n\r\nAdditionally, I discovered that `req.params` is parsed properly when in my controller (before the call to `res.format`), but the version of the `req.params` that is passed into `onFinished` later in that same request is undefined.\r\n\r\nIs the the expected behavior?  The documentation and behavior makes me think this is unexpected.\r\n\r\nI can provide more information if needed\r\n\r\nThanks","comments":["Hi @CullenShane , the `req.params` property is only populated in the middleware\/handler that has those parameters defined on the path. I assume you defined your error handler with no parameters (`app.use((err, res, res, next) => ...)` vs `app.use('\/:param1', (err, req, res, next) => ...)` which is why the `req.params` is empty, due to the error handler having no parameters defined.\r\n\r\nBut ultimately, without providing the full code and instructions for how to reproduce the issue, we're just making guesses, so not 100% sure if the behavior you are experiencing is expected vs unexpected. If you can provide a reproduceable test-case we can run to see the issue demonstrated, we can make an accurate evaluation.","hi @dougwilson - thanks for taking a look and thanks for all the work you do (and have done over the years) maintaining express and friends \ud83d\ude4f:pray::pray:\r\n\r\n@CullenShane and i were pairing on this one earlier so i figured i'd chime in w\/ more detail. \r\n\r\nbasically, we have a fairly simple app that runs some middleware for all routes to capture data after a response is finished:\r\n\r\n```js\r\nconst onFinished = require('on-finished');\r\nmodule.exports = ({ logFoo }) => {\r\n    return (req, res, next) => {\r\n        onFinished(res, () => logFoo(req.params.foo));\r\n        next();\r\n    };\r\n};\r\n```\r\n\r\n...which hosts an endpoint like:\r\n\r\n```js\r\napp.get('\/v1\/stuff\/:foo\/config', configFooStuff);\r\n```\r\n\r\n...which ultimately calls `res.format()` like:\r\n\r\n```js\r\nconfigFooStuff(req, res) {\r\n    res.format({\r\n        'application\/json': async () => {\r\n            \/\/...\r\n        },\r\n        'application\/schema+json': () => {\r\n            \/\/...\r\n        }\r\n    });\r\n}\r\n```\r\n\r\nwhen the `Accept` header specifies something we aren't handling (e.g. `text\/html`), we end up with `Uncaught TypeError: Cannot read property 'params' of undefined`. when handling a format we do support (e.g. `application\/json`), `req.params` is an object w\/ a valid `.foo` property and everything works as expected. further, if we add an explicit `default` handler to our `res.format()` call - e.g.:\r\n\r\n```js\r\n'default': () => {\r\n    res.status(406).json({ error: 'Not Acceptable' });\r\n}\r\n```\r\n\r\n...things work but `req.params` is an empty object.\r\n\r\nso the main question is why would `req.params` be `undefined` when `res.format()` doesn't use a `default` handler? willing to bet we're just missing something given how exercised this code must be but \ud83e\udd37\u200d\u2642\ufe0f\r\n\r\nthanks again!\r\n\r\nedit: fix typos and minor derpage \ud83e\udd26 ","Ah, very interesting. Even more so given you are seeing the error `Uncaught TypeError: Cannot read property 'params' of undefined occurring... I am not sure how you can possibly seeing such an error with the code you gave above. I would love it if I could run it and try it out, to get that same condition to see what is happening. Is it possible you can write up a really simple app that I can call that demonstrates the issue (reproduces the error)?",">Is it possible you can write up a really simple app that I can call that demonstrates the issue (reproduces the error)?\r\n\r\ncool, yeah that's probably the best next-step. we'll try to pull something together in the next day or two. \r\n\r\nthanks again \ud83d\ude4f:+1:","re-reading this with fresh eyes, i see i messed up the error detail \ud83e\udd26\u200d\u2642\ufe0f\ud83d\ude44\r\n\r\nit's actually:\r\n\r\n```\r\nUncaught TypeError: Cannot read property 'foo' of undefined\r\n```\r\n\r\niow, `req.params` is `undefined` when we expected it always at least be an empty object.\r\n\r\nregardless, we'll put together a simplified demo that reproduces the issue :+1:","> req.params is undefined when we expected it always at least be an empty object.\r\n\r\nAh, thank you, that does help \ud83d\udc4d . I can say, at least, that `req.params` will always be `undefined` when the request cycle is not currently \"in\" a middleware or handler in Express. This means that when the request first comes in from Node.js it will be undefined, and also during any \"in between time\" between middlewares. When a request enters a middleware\/handler, before user code is executed, Express will set up `req.params` property, but once that middleware\/handler calls `next()` or throws an error, the property is removed so the next middleware\/handler can populate it, if needed.\r\n\r\nIt will always be an object if the request is actively \"in\" a middleware\/handler, even if it's an empty object. Since it is `undefined` for you, it means (assuming there is not some code actually setting it to `undefined` somewhere) that the request is not inside a middleware\/handler of Express at all... which would be strange based on your description above.","hm. well, after all that all i can say with confidence is that this _does not_ reproduce the issue:\r\n\r\n```js\r\n\/\/ filename: repro.js\r\nconst onFinished = require('on-finished');\r\nconst express = require('express');\r\nconst app = express();\r\n\r\n\r\napp.use((req, res, next) => {\r\n\tonFinished(res, () => console.log('FOO IS:', req.params.foo));\r\n\tnext();\r\n});\r\n\r\napp.get('\/v1\/stuff\/:foo\/config', (req, res) => {\r\n\tres.format({\r\n\t\t'application\/json': () => {\r\n\t\t\tres.status(200).json({ ok: true });\r\n\t\t},\r\n\t\t'application\/schema+json': () => {\r\n\t\t\tres.status(200).type('application\/schema+json').send('ok');\r\n\t\t}\r\n\t});\r\n});\r\n\r\napp.listen(9001);\r\n\r\nmodule.exports = app;\r\n```\r\n\r\nstart the server:\r\n\r\n```sh\r\n.\/node repro.js\r\n```\r\n\r\nhit the endpoint:\r\n\r\n```sh\r\ncurl http:\/\/localhost:9001\/v1\/stuff\/12345\/config -H \"Accept: text\/html\"\r\n```\r\n\r\nso, i think we have more digging to do :pray::wave:","Thanks for that update @busticated . I just wanted to post here to see if you found anything additional at all or not so far.","thanks for the ping @dougwilson :pray: no, we haven't been able to dig much further into this one yet. feel free to close it if that helps improve your signal-to-noise ratio \ud83d\ude01 \r\n\r\nthe one thing i did turn up is that - in our app at least - we get the same error \/ issue when invoking Express' default error handler ([docs](https:\/\/expressjs.com\/en\/guide\/error-handling.html#the-default-error-handler)) - that is, `req.params` is not an object and we get `Uncaught TypeError: Cannot read property 'foo' of undefined`.\r\n\r\n\r\n","> the one thing i did turn up is that - in our app at least - we get the same error \/ issue when invoking Express' default error handler (docs) - that is, req.params is not an object and we get Uncaught TypeError: Cannot read property 'foo' of undefined.\r\n\r\nAs for this, that is definately expected, as `req.params` is only populated _while_ the request\/response lifecycle is within a handler that defined parameters. Once it leaves the handler and re-enters into the routing system, `req.params` is cleared in order to populate again for the next route. In order for a request\/response to have reached the default error handler, it had to have left a handler (or never entered one) and gone back into the routing system."],"labels":["awaiting more info"]},{"title":"Dependencies (5.0)","body":"It seems that we can remove a few dependencies before the `5.0` release:\r\n\r\n- `methods` - We can use the built-in `http` module:\r\n\r\n```javascript\r\nconst { METHODS } = require(\"http\");\r\nconst methods = METHODS.map((method) => method.toLowerCase());\r\n```\r\n\r\n- `path-is-absolute` - We can use the built-in `path` module:\r\n\r\n```javascript\r\nconst path = require(\"path\");\r\nconst isAbsolute = path.isAbsolute(\"some-path\");\r\n```\r\n\r\n- `safe-buffer` - We can use the built-in `Buffer`:\r\n\r\n```javascript\r\nconst a = Buffer.from(\"something\");\r\n```\r\n\r\n- `setprototypeof` - We can use the `Object.setPrototypeOf()`\r\n\r\n```javascript\r\nObject.setPrototypeOf(this.request, parent.request);\r\n```\r\n\r\n- `utils-merge` - We can use the spread operator:\r\n\r\n```javascript\r\nconst opts = { expires: new Date(1), path: '\/' , ...options};\r\n```","comments":["Good conversation to have! Please don't take this response as a rebuttal, but as the start of a conversation and me thinking out loud.\r\n\r\nThe [`methods`](https:\/\/github.com\/jshttp\/methods) package essentially is just that snippet, and has zero dependencies of its own. (Although it might be worth revisiting, I don't fully understand the value of the fallback behavior defined in the package for Node versions that don't have `http.METHODS`).\r\n\r\nIt exists so that anyone in the ecosystem can use that same standard helper without having to keep that utility code in their own codebase. Having it as a package is essentially the same as if we had that same snippet of code in a utils folder, guarantees that any changes that ever need to happen to it will be synced across every package that uses it. Express maintains that package, as the [`jshttp` org](https:\/\/github.com\/jshttp) is under the Express project umbrella. For context on a similar choice to use a package vs a oneliner, [see this exchange](https:\/\/github.com\/pillarjs\/router\/pull\/92#issue-405589362) between @dougwilson and I where I learned a little about our choice on these things. Also, in v5 `router` is being moved into it's own package, which is the system in Express that uses `methods` the most. Having it as a package ensures that both `router`, the express tests, and the `application` system are all using the exact same snippet at all times.\r\n\r\nI can't find where `path-is-absolute` is used in Express, so I don't have anything to say about that, but if it is being used I would agree that's a simple one to replace since it's introduction in Node v0.11.2 \ud83d\udc4d \r\n\r\n`safe-buffer` can be dropped once Express' lower bound of support is at Node.js v6, I'm still not 100% sure what version v5 will support down to, but that is a good candidate as well once we are there.\r\n\r\n`Object.setPrototypeOf` came to Node in v6.0.0, so again, that can probably be used once version support comes that high. \r\n\r\nThe spread `...` operator came in at Node.js v8.0.0, so same story as the other version support \ud83d\udc4d ","See https:\/\/github.com\/expressjs\/express\/issues\/2755#issuecomment-382499774 for the 5.0 version support:\r\n![image](https:\/\/user-images.githubusercontent.com\/8274162\/82154222-f15ed480-989e-11ea-992b-97584c0d6cf3.png)\r\n","I'm not sure if my comment is being misread here, but it is that we will support down to the LTS at the time, not that we won't support _more_ than that. There has been further discussion since that thread, including in TC meetings, which is what @jonchurch is trying to represent. The version of support we are always aim for is as wide as possible, but there is a balance. Dropping versions for us is more about what we get for it, unrelated to what is supported by the Node.js project. But we will always support at least down to the current LTS version, no exceptions. ","Got it, I misunderstood it before, I thought we just need to support LTS at that time.","No problem. Also (sorry!) to clarify: it doesn't mean this discussion is over at all; just it will help us to have discussions like this where we specify what the change in Node.js requirement will be for each one (like @jonchurch listed) so we can make decisions on what to do, etc.","Hi @mgoffan , as this is an issue for the dependencies in 5.0, it is probably not the right place, as Express 5.0 does not have a dependency on `path-to-regexp`: https:\/\/github.com\/expressjs\/express\/blob\/5.0\/package.json#L29\r\n\r\nEdit: It seems @mgoffan deleted their own comment.","@dougwilson Thanks for the clarification. Just noticed it was here https:\/\/github.com\/expressjs\/express\/issues\/4171 \ud83d\ude42 ","Hi @lucaslago thank you for your comment. If this is an issue with an upstream dependency please report there. If this is something express needs to address, please report though our listed security policy if this is a security issue. I have deleted your post under the assumption it is.","- `setprototypeof`: Object.setPrototypeOf (Node 0.11+, )\r\n\r\n  > Object.setPrototypeOf came to Node in v6.0.0, so again, that can probably be used once version support comes that high.\r\n  \r\n  [MDN says setPrototypeOf was added in Node 0.12](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/setPrototypeOf#browser_compatibility), and a quick check with nvm shows that this is indeed true (absent in 0.10, present in 0.11 and 0.12+); not Node 6.\r\n  \r\n  So the ponyfill is needed in Express 4 as it supports Node 0.10+, but as 5.0.0beta1 [already bumped the minimum Node version to 4](https:\/\/github.com\/expressjs\/express\/blob\/5.0\/package.json#L86), it no longer will be.\r\n\r\n- `array-flatten`: Array.prototype.flat (Node 11+, 2018)\r\n\r\n  If the plan is still for Express 5 to only raise the minimum Node version to 4, this would still be necessary.\r\n\r\n- [Spread syntax](https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Operators\/Spread_syntax#browser_compatibility) is Node 5 (2015), Object Spread is Node 8.3 (2017)"],"labels":["ideas"]},{"title":"named groups in regex routers not supported?","body":"```\r\n\/\/ \/regex\/hello -> matches\r\napp.get(\/\\\/regex\\\/(.+)\/, (req, res) => res.json({ params: req.params }));\r\n\r\n\/\/named groups not suppoted?\r\n\/\/  \/regex\/hello -> error\r\napp.get(\/\\\/regex2\\\/(?<groupname>.+)\/, (req, res) =>\r\n  res.json({ params: req.params })\r\n);\r\n\r\n```\r\n\r\nwhen using named capture groups, I got the following error\r\n```\r\nTypeError: Cannot read property 'name' of undefined\r\n    at Layer.match (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/layer.js?:147:20)\r\n    at matchLayer (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/index.js?:574:18)\r\n    at next (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/index.js?:220:15)\r\n    at cors (webpack:\/\/\/.\/node_modules\/cors\/lib\/index.js?:188:7)\r\n    at eval (webpack:\/\/\/.\/node_modules\/cors\/lib\/index.js?:224:17)\r\n    at originCallback (webpack:\/\/\/.\/node_modules\/cors\/lib\/index.js?:214:15)\r\n    at eval (webpack:\/\/\/.\/node_modules\/cors\/lib\/index.js?:219:13)\r\n    at optionsCallback (webpack:\/\/\/.\/node_modules\/cors\/lib\/index.js?:199:9)\r\n    at corsMiddleware (webpack:\/\/\/.\/node_modules\/cors\/lib\/index.js?:204:7)\r\n    at Layer.handle [as handle_request] (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/layer.js?:95:5)\r\n    at trim_prefix (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/index.js?:317:13)\r\n    at eval (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/index.js?:284:7)\r\n    at Function.process_params (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/index.js?:335:12)\r\n    at next (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/index.js?:275:10)\r\n    at urlencodedParser (webpack:\/\/\/.\/node_modules\/body-parser\/lib\/types\/urlencoded.js?:91:7)\r\n    at Layer.handle [as handle_request] (webpack:\/\/\/.\/node_modules\/express\/lib\/router\/layer.js?:95:5)\r\n```","comments":["No, they are not supported, but no reason why support cannot be added \ud83d\udc4d . If you (or anyone else) would like to add support for this, please go ahead and open a pull request against our router engine code: https:\/\/github.com\/pillarjs\/router"],"labels":["ideas","module:router"]},{"title":"GitHub Actions workflow for Linux and Windows machines","body":"Edit: added @tspascoal as a co-author on this. \r\n\r\n@tspascoal and I have created a GitHub Actions workflow that will build express on both Linux and Windows machines.  I have not opened an issue to link to this, in order to allow all discussion to happen on the PR. I'm happy to open an issue if someone would like me to.\r\n\r\nAverage build time for Travis (Linux) and AppVeyor(Windows) pipelines currently in use is around 30 minutes.  With this workflow, I was able to build both Linux and Windows in just over 5 minutes, total. This is in part due to the number of concurrent pipelines that GitHub gives to open source projects.\r\n\r\nIf you look at the file, you'll notice I am using the same steps for both the Linux builds and the Windows builds.  This allows for code reuse, and also makes it where, if you need to modify a step, you only have to modify it in one place.\r\n\r\nI'm making use of a matrix strategy as well.  Right now, the workflow is set to only use Linux and Windows. If we wanted to also build on Mac (which is an option), all we would need to do is add `macos-latest` to the matrix. The same with any other specific versions of Node we would want to test against.\r\n\r\n[Here is an example of the build output.](https:\/\/github.com\/mickeygousset\/express\/actions\/runs\/86911642)\r\n\r\n[Here is an example of a specific job (Node 2.5 running on Linux)](https:\/\/github.com\/mickeygousset\/express\/runs\/615992721?check_suite_focus=true)\r\n\r\nYou can click into the jobs and then into each individual step on a job and see details of the run.\r\n\r\nAt this point, this workflow does everything the current Travis and Appveyor workflows do.  In addition, it goes a step beyond the AppVeyor workflow, because the GH Action workflow supports pulling down the nightly build for the Windows build (similar to what the Travis build does), which the current Appveyor workflow does not do.","comments":["Related https:\/\/github.com\/expressjs\/discussions\/issues\/88","At this point I've made all the initially requested changes from the comments earlier in the pull request. ","So I have a \"process\" question. For all the conversations above in this PR, should I mark them as resolved, or should someone else?  I think I've answered all the questions asked, but didn't know the appropriate protocol.  @wesleytodd @dougwilson could you provide me some guidance?","Hi @mickeygousset I didn't even know you had the ability to mark them as resolved \ud83d\ude04 . Yes, please do so! Wes and myself spoke about this issue last night and I mentioned resolving the conversations to clear it up, but if you want to do so, please go ahead. Wes gave his blessing there at the end, so I believe this is ready to land at this point. I'm targeting it into the 4.18 branch to get in the line prior to release, which will be a huge improvement to testing times!\r\n\r\nOne thing I started looking at (but never really finished) is what we need to change on our badges to get them to show the status of these GitHub Actions now vs the Travis CI + AppVeyor statues. Not sure if you have that knowledge, and I'm still going to look into it, but just wanted to mention it here in case you knew \u2764\ufe0f ","I don't know if I have the ability, but it gives me a Resolve button, so I will try. :)\r\n\r\nYes, there are status badges. I'll figure it out and report back. ","I have resolved everything I have a button to resolve with :)","GitHub Action Status Badge: https:\/\/help.github.com\/en\/actions\/configuring-and-managing-workflows\/configuring-a-workflow#adding-a-workflow-status-badge-to-your-repository\r\n","I think @dougwilson may still have to do something to clear up the blocking.","Nice on the badge! I'm looking at our badge provider (badgen.net) and I _think_ the way we would do it would be to use the https:\/\/badgen.net\/github#github-status-owner-repo-ref-context area, where the name of the status check that the workflow leaves would be what we would key off.","Ok, so looking at https:\/\/github.com\/badgen\/badgen.net\/issues\/304 it seems that we could use https:\/\/badgen.net\/github#github-checks-owner-repo-ref for the exact replica of that github workflow badge link through badgen."],"labels":["pr"]},{"title":"Throw on invalid status codes","body":"Closes #3143\r\n\r\nWill throw an error if status code is not an integer.\r\n\r\n~Cases that are allowed are cases that Node.js also allows, such as `'200.0'` or `200`. I made this choice (allowing strings) because Node.js allows those strings.~\r\n\r\nAdded tests to make sure it throws on bad inputs. \r\n\r\n~Please excuse the unary use of `Number.isInteger(+code)`, after thinking through this a lot it was the best way to temporarily coerce a string to a number for testing with isInteger.~\r\n\r\n~**Under the hood, Node.js actually uses a bitwise operator to coerce statuscodes to integers before testing if they fall in their range: `code |= 0`**~\r\n\r\nThis PR is actually more strict than Node.js as it currently stands (at least at version 12 LTS), but I went off the work that had been done in #3143.\r\n\r\nIf we want to truly only throw an error when Node.js would, this PR would need to be altered to accept values with floats, possibly coercing them like Node.js does into integers.\r\n\r\n**Edit: The PR has been updated to throw on strings. Currently it still accepts Numbers which can be represented as an integer such as `200.00`.**\r\n\r\n","comments":["I realized after opening this that Node.js does not throw on inputs like `500.5`, this PR however does. From the other PR, I think we decided to throw on these cases, but I wanted to make clear that from my limited testing Node.js is not throwing on floats.","> I wanted to make clear that from my limited testing Node.js is not throwing on floats.\r\n\r\n@jonchurch - my assertion is that `500.5` is definitely invalid, so throwing is the right thing to do.","Yea, I don't have any issues with this throwing on a float; we want to throw on whatever Node.js throws on as the _minimum bar_. If we can also help the users by also throwing on _definitely nonsensical inputs_ (like status codes with fractions) that makes sense of course :) !","Fixed the tests. Now the CI fails on Node.js 0.10 because there is no `Number.isInteger` function available there. \r\n\r\nAssuming we're dropping that version, then this should be good to go pending any requested changes. ","> Fixed the tests. Now the CI fails on Node.js 0.10 because there is no Number.isInteger function available there.\r\n> \r\n> Assuming we're dropping that version, then this should be good to go pending any requested changes.\r\n\r\nA few of us thumbs upped that, but also wanted to call out that yes it is being dropped, so let 0.10 fail on this PR; 0.10 will be removed from the branch's CI prior to this change, so that version failing will turn to passing as things are merged.","as per the TC discussion, this is ready to merge, who is going to do that? @dougwilson , I see your red-X on this - is that still valid, or you are going to remove it and land?","Thinking more about this and something bothers me. I took the approach the previous PR did, since it had been reviewed, but now I'm questioning the use of `res.status` internally to set statuses. \r\n\r\nIf someone monkey-patches `res.status` it will alter the internal behavior of setting status codes on responses. That's not different though for other functions used in response, like `res.type` for example.\r\n\r\nMy question has two parts:\r\n\r\n* Is it a breaking change to be relying on `res.status()` to set status codes internally?\r\n* Do we want to distinguish between private vs public methods? (there are only two things marked private in `response` according to jsdoc comments)\r\n\r\nSee an example of the change in the diff: https:\/\/github.com\/expressjs\/express\/pull\/4212\/files#diff-d86a59ede7d999db4b7bc43cb25a1c11L137-R142\r\n","> Is it a breaking change to be relying on res.status() to set status codes internally?\r\n\r\nYes, as stated in https:\/\/github.com\/expressjs\/express\/pull\/4223#issuecomment-602102852 , but this PR is already a breaking change, right? So I'm not sure if it's super relevant. The change itself makes sense to make, just like we call `res.type` internally and not directly get the `content-type` response header. Even getting headers we internally use `req.get` and not `req.headers`.\r\n\r\n> Do we want to distinguish between private vs public methods? (there are only two things marked private in response according to jsdoc comments)\r\n\r\nI'm not really following on what this part of the question really is. The main reason the internals use Express' own API is especially useful for AOP type of design patterns, if the user so chooses to do them. The Node.js HTTP APIs do the same patterns as well, AFAIK.","I wasn't clear. Re: breaking, I meant that someone's v4 `res.status` monkey patch might affect code in unexpected ways under v5, because it is used in more places than before.\r\n\r\nYou've answered my second question I believe. We aren't interested in making some methods private and off limits to users.\r\n\r\nThanks, I wanted to bring up this point (re: effects of monkey-patching res.status with these changes) just so someone else could check it.\r\n\r\nRealizing that we use a lot of these helper methods internally would indicate that this change is not out of step with what is standard.","Just read that linked comment and saw you did directly address the concern already \ud83d\udc4d ","Yep! I did, though, not directly address the monkey patching messing something up; that is indeed the case, but I don't think any more so than other aspects of Node.js and Javascript. I think that it is going to be possible for users to override something and cause a breakage, but I'm not sure that the effort in order to prevent such a thing is really worth it. From support experience, I think it is extremely rare for such an issue to really show up, haha.","I think this PR should target branch https:\/\/github.com\/expressjs\/express\/tree\/5.0 and not master.\r\nAnd if it's ok, it should be merged aswell in v5 branch."],"labels":["enhancement","5.x","pr"]},{"title":"Zone.js for async error handling","body":"Currently when i create a new express application.\r\nThat application has a default error handling.\r\nSo code like this:\r\n\r\n```\r\nconst express = require(\"express\");\r\n\r\nconst app = express();\r\n\r\napp.get(\"*\", function() {\r\n    throw new Error(\"something happened\");\r\n})\r\n\r\napp.listen(3000, function() {\r\n    console.log(\"we are now listening to port 3000\");\r\n});\r\n```\r\n\r\nWill cause the default express error handler to kick in.\r\nThe js process does not crash and everything works as expected.\r\n\r\nFor async error the behaviour is different and my question is why?\r\nwith **Zone.js** we can now do a similar behaviour.\r\nFor example:\r\n\r\n```\r\nconst express = require(\"express\");\r\n\r\nconst app = express();\r\n\r\napp.get(\"*\", function() {\r\n    setTimeout(() => {\r\n        throw new Error(\"something happened\");\r\n    }, 500);    \r\n})\r\n\r\napp.listen(3000, function() {\r\n    console.log(\"we are now listening to port 3000\");\r\n});\r\n```\r\n\r\nthe above code will crash the process.\r\n\r\nAccording to express docs.\r\nwe can handle sync error but the async error you will have to call **next** with the error.\r\nSo the above code should be like so:\r\n\r\n```\r\napp.get(\"*\", function(req, res, next) {\r\n    setTimeout(() => {\r\n        next(new Error(\"something happened\"));\r\n    }, 500);    \r\n})\r\n```\r\n\r\nSo this behaviour seems non ideal to me, cause in my opinion, with **zone.js** in the picture we can reach a much better results.\r\nI would love to open a discussion on the matter...\r\nThe ideal is similar behaviour with sync and async errors (which is quite possible with zone.js to identify error that originate from async code inside express middleware functions).\r\nso to summarise I would see the async error handling working like this:\r\n- if we are using next(new Error()) then great let's keep the same behaviour. \r\n- if not, determine with zone.js if we have exception in our async code that originated from one of our middleware functions, and pop the default error handler (and of course the process will not crash).\r\n- This will result in much stable apps (process won't be close on async errors) and another added bonus is better debugging, and better error messages and stack traces of the exceptions in our async code.\r\n\r\n\r\n ","comments":["This is relevant to a discussion in the web server frameworks working group: https:\/\/github.com\/nodejs\/web-server-frameworks\/issues\/22","> This is relevant to a discussion in the web server frameworks working group: [nodejs\/web-server-frameworks#22](https:\/\/github.com\/nodejs\/web-server-frameworks\/issues\/22)\r\n\r\nIt's a feature request  that should be added to express...\r\nDoes every feature request goes through that group?\r\nThey seem less active than this group but will open the same discussion there as well.\r\nThanks\r\n","I agree with @ywarezk that the handling is currently not totally ideal. There is an excellent article on [handling async errors in express](https:\/\/thecodebarbarian.com\/80-20-guide-to-express-error-handling).  It is possible to catch the errors via the error handler \r\n```\r\nconst express = require(\"express\");\r\n\r\nconst app = express();\r\nconst randomOtherMiddleware = ( req, res, next) => {\r\n  console.log(\"random other middleware\");\r\n  next();\r\n};\r\nconst errHndlingMiddleWare = ( err, req, res, next ) => {\r\n  console.error(err.message);\r\n  res.status(500).send(\"unhandled error\");\r\n};\r\nconst errorCreatingMiddleware = (req, res, next) => {\r\n  setTimeout(() => {\r\n    next(new Error(\"something happened\"));\r\n  }, 500);\r\n};\r\n\r\napp.get(\"*\", [errorCreatingMiddleware, randomOtherMiddleware, errHndlingMiddleWare]);\r\n\r\napp.listen(3000, function() {\r\n  console.log(\"we are now listening to port 3000\");\r\n});\r\n```\r\n\r\nor via wrapping async calls as here\r\n\r\n```\r\nconst app = require('express')();\r\n\r\napp.get('*', wrapAsync(async function(req, res) {\r\n  await new Promise(resolve => setTimeout(() => resolve(), 50));\r\n  \/\/ Async error!\r\n  throw new Error('woops');\r\n}));\r\n\r\napp.use(function(error, req, res, next) {\r\n  \/\/ Gets called because of `wrapAsync()`\r\n  res.json({ message: error.message });\r\n});\r\n\r\napp.listen(3000);\r\n\r\nfunction wrapAsync(fn) {\r\n  return function(req, res, next) {\r\n    \/\/ Make sure to `.catch()` any errors and pass them along to the `next()`\r\n    \/\/ middleware in the chain, in this case the error handler.\r\n    fn(req, res, next).catch(next);\r\n  };\r\n}\r\n\r\n```\r\n\r\nthis is not the ideal resolution you seek, however for **others** with this **issue** it does provide a solution so I am putting it into the **discussion** here.","I tried playing a bit with zone.js to grab async errors, and invoke the default error handler. \r\nDid the following and it seems to work:\r\n\r\n\r\n```\r\nrequire(\"zone.js\");\r\n\r\nconst onHandleError = (parentZoneDelegate, currentZone, targetZone, error) => {\r\n    const res = currentZone.get(\"res\");\r\n    res.send(\"async error activate the default express error handler\");\r\n}\r\n\r\nconst express = require(\"express\");\r\n\r\nconst app = express();\r\n\r\napp.get(\"*\", function(req, res) {\r\n    const middlewareZone = Zone.current.fork({\r\n        properties: {\r\n            req, res\r\n        },\r\n        onHandleError,  \r\n        name: 'express child'              \r\n    });\r\n    middlewareZone.run(() => {\r\n        console.log(Zone.current.name);\r\n        setTimeout(() => {\r\n            throw new Error('something happened');\r\n        }, 1000);\r\n    })\r\n})\r\n\r\napp.listen(3000, function() {\r\n    console.log(\"we are now listening on port 3000\");\r\n});\r\n```\r\n\r\nA zone has to be created per request response cycle so we can save the **req\/res\/next** in the zone.\r\nSo when a request enters we can open a zone for that request.\r\nI opened the zone inside my middleware for POC but we can do better and open once per request response. \r\nThe middleware function should run in the zone we create.\r\nIf exception happens the zone **onHandleError** catch the exception (async or sync it doesn't matter it will catch all exceptions), can grab the **res** or **next** and pop an error.\r\nwith this there will be no need to doing **next(new Error())**\r\n\r\n\r\n\r\n","Do you have any insights on the overhead from using a full async hook solution ? In my experience it's pretty dreadfull. I'm not against the feature itself, but the ecosystem is simply not ready for it- hence the discussion in the nodejs frameworks working group.","> Do you have any insights on the overhead from using a full async hook solution ? In my experience it's pretty dreadfull. I'm not against the feature itself, but the ecosystem is simply not ready for it- hence the discussion in the nodejs frameworks working group.\r\n\r\n@fed135 you are right.\r\nAlthough the idea seems to me the most elegant and easy to implement with Zone.js (might be even possible to encapsulate the concept in an easy to use middleware, will try to do that), the idea will rise and fall based on performance.\r\n\r\nStill need to do some benchmarking on the subject, but based on what I read and my experience with angular and zone, the performance was not great, so I have a feeling that you are right, but will do some further check and publish my results.\r\n","There is currently a work to provide a CLS-like API directly in Node.js core in a performant and memory-safe way (see https:\/\/github.com\/nodejs\/web-server-frameworks\/issues\/22#issuecomment-592003434)\r\nAlso, I think the landing of https:\/\/github.com\/nodejs\/node\/commit\/fd3d02ac32660dfe5edcfa7592576da68780f7e2 should enable us to update the perfs of the `domain` core module which is basically designed to do this but is now documentation-deprecated.","why let error handing must be async? i think this step is wrong.","> Do you have any insights on the overhead from using a full async hook solution ? In my experience it's pretty dreadfull. I'm not against the feature itself, but the ecosystem is simply not ready for it- hence the discussion in the nodejs frameworks working group.\r\n\r\n\r\n\r\n> > Do you have any insights on the overhead from using a full async hook solution ? In my experience it's pretty dreadfull. I'm not against the feature itself, but the ecosystem is simply not ready for it- hence the discussion in the nodejs frameworks working group.\r\n> \r\n> @fed135 you are right.\r\n> Although the idea seems to me the most elegant and easy to implement with Zone.js (might be even possible to encapsulate the concept in an easy to use middleware, will try to do that), the idea will rise and fall based on performance.\r\n> \r\n> Still need to do some benchmarking on the subject, but based on what I read and my experience with angular and zone, the performance was not great, so I have a feeling that you are right, but will do some further check and publish my results.\r\n\r\nHow about [this change](https:\/\/github.com\/yz89122\/express\/commit\/7dbc6e0cc8904813429e9981684a40ceab6679e6)?\r\n\r\nAnd we can rewrite the middleware as\r\n\r\n```javascript\r\nrouter.use((req, res, next) => {\r\n  \/\/ do STH\r\n  return next(); \/\/ the return is required to return `Promise<void>` or just `void`\r\n})\r\n```\r\n\r\nAnd also we can catch the error by `throw`\r\n\r\n```javascript\r\nrouter.use(async (req, res, next) => {\r\n  try {\r\n    await next();\r\n  } catch (e) {\r\n    console.error(e);\r\n    res.status(500).end();\r\n    \/\/ or\r\n    next(e);\r\n  }\r\n})\r\n```\r\n\r\nThis change also allow\r\n\r\n```javascript\r\nrouter.use(async (req, res, next) => {\r\n  const connection = pool.get();\r\n  res.locals.connection = connection;\r\n  try {\r\n    await next();\r\n  } finally {\r\n    pool.add(connection);\r\n  }\r\n})\r\n```\r\n\r\n**BUT, this change require all middleware to change from**\r\n\r\n```javascript\r\nrouter.use((req, res, next) => {\r\n  \/\/ do STH\r\n  next();\r\n})\r\n```\r\n\r\nto\r\n\r\n```javascript\r\nrouter.use((req, res, next) => {\r\n  \/\/ do STH\r\n  return next();\r\n})\r\n```\r\n\r\n(e.g. [this](https:\/\/github.com\/yz89122\/express\/commit\/7dbc6e0cc8904813429e9981684a40ceab6679e6#diff-653dcdfd7e9a4ff9f5a487e8e7850f73ac6a36d7ee61258556b2d15b907d6070))"],"labels":["discuss"]},{"title":"Add deprecation warning to \"Referrer\" special-casing","body":"re: https:\/\/github.com\/expressjs\/express\/issues\/3951\r\n\r\nTest plan: `npm test`","comments":["\ud83d\udc4c\ud83d\udc4c","@dougwilson thanks for the clarification, and sorry for the delay! I just updated the PR.\r\n\r\nNow, if someone calls:\r\n\r\n- `req.get('referer')` and receives `this.headers.referrer`, or\r\n- `req.get('referrer')` and receives `this.headers.referer`\r\n\r\n\u2026the deprecation notice will print.\r\n\r\nI hope that's what you meant re: lifecycles. As far as I can tell, the only other place this special-casing extends to is [`lib\/response.js:750-753`](https:\/\/github.com\/rileyjshaw\/express\/blob\/bfb559a4db598ff996e3f65c7090d594e8ca8a97\/lib\/response.js#L750-L753), but since that uses `req.get()` it should still flag correctly.","Also worth noting: tests all pass on this commit, but will need to be updated once the special-casing is removed."],"labels":["pr"]},{"title":"Change the interface for setting application settings","body":"The interface `app.set(<name with space>, <value>)` feels a odd for setting values in a JavaScript framework. Also, its counterpart `app.get(<name>)` is a confusing twin of `app.get(path, callback [, callback ...])`, which is a router method.\r\n\r\nI am proposing to implement application settings using getter-setter interfaces.\r\n\r\n```\r\napp.settings.trustProxy = true;\r\n```\r\n\r\nAnd get rid of `app.get(<name>)`.\r\n\r\nSuper major change, I know, but the next major version is a good time to make these interface improvements.\r\n\r\n**Related issues**\r\n\r\n1. https:\/\/github.com\/expressjs\/express\/issues\/2216\r\n2. https:\/\/github.com\/expressjs\/express\/issues\/3997","comments":["I believe there is already a PR solving this issue that is scheduled to land on 5, using a new settings module, right @wesleytodd ?","I see. That PR is https:\/\/github.com\/expressjs\/express\/pull\/3714. It still maintains the `.set(<name with space>, <value>)` syntax.\r\n\r\nI am wondering if there are any advantages of providing functions to set and get values over using getter-setter's.\r\n\r\n`app.settings.set('trust proxy', true)` vs `app.settings.trustProxy = true`\r\n`app.settings.get('trust proxy')` vs `app.settings.trustProxy`\r\n\r\nOr is it just an artefact from the \"pre-`Object.defineProperty`\" era?","~~Yeah I have this PR: #3714~~ Lol, I did not read well.  I see that you already got the PR link... :P\r\n\r\nAs for getters\/setters vs functions, I don't have a strong objection to supporting both, it would be pretty simple using a `Proxy`.  But, that would only land in 5 which drops support for versions w\/o `Proxy` then we should be fine.  The version targeted for 4.x cannot really support that.\r\n\r\nWhen I get some time I really want to move that package over to `pillarjs`.  I just need @dougwilson to give me the proper privileges on that org.  Once that is there we can work on cleaning up the PR and making sure that docs are updated and such.\r\n\r\n","> The version targeted for 4.x cannot really support that.\r\n\r\nNot looking for 4.x at all. 5 is what I have on mind.","Cool, well I am happy to move that repo over so we can get the new interface added.  Just need that permission on pillar \ud83d\udc4d "],"labels":["enhancement"]},{"title":"Rewriting req.url in router with prefix path results in missing slash (\/)","body":"Hello, I've been trying to use a npm module (`connect-history-api-fallback`) and encounter problems that after a lot of debugging I believe boils down to this issue.\r\n\r\nWhen you're in a router that has a mount path, doing a rewrite on the relative root ('') path result in a missing slash, eg with `bug.js` as below\r\n```js\r\nconst express = require('express')\r\nconst app = express()\r\nconst port = 3000\r\n\r\nvar router = express.Router();\r\nrouter.get('\/', function (req, res, next) {\r\n    req.url = \"\/index.html\"\r\n    next()\r\n});\r\n\r\napp.use('\/app', router);\r\n\r\napp.use(function (req, res, next) {\r\n    console.log(\"Rewritten path: \" + req.url)\r\n    res.end()\r\n});\r\n\r\napp.listen(port, () => console.log(`Example app listening on port ${port}!`))\r\n```\r\n\r\nRunning the following commands:\r\n```js\r\nnode bug.js\r\ncurl localhost:3000\/app\r\n```\r\nresults in the rewritten path to be `\/appindex.html` instead of `\/app\/index.html`\r\n\r\nEnvironment:\r\n```\r\n\"node\": 12.10.0\r\n\"express\": 4.17.1\r\n```\r\n\r\nThis sounds like a bug to me, but maybe I'm doing something wrong? I'm not too expert in expressjs to know for sure (my hunch is the router code doesn't 'remount' the prefix path properly.\r\n\r\nThanks!","comments":["Hi @fchu thanks for the report. I see what you mean, though will need to investigate further on what (if any) a fix would look like. To explain what is happening, is that your original URL is `\/app` (no trailing `\/`). When the `\/app` mount is encountered, the routing system will always make sure there is _some_ path there (as in, it doesn't let it become an empty string), so it ends up as `req.url === '\/'` inside the router. Of course, this would translate to a potential original URL of `\/app\/`, though that is not what it was.\r\n\r\nThen `req.url` is set to `\/index.html` inside of `router`, as far as the upper router knows, that `\/` at the beginning was the fake `\/` it injected to ensure that `req.url` was not an empty string, and so is trimming it back away.\r\n\r\nA quick _work-around_ would be to change `\/app` to `\/app\/` in a rewrite above the `\/app` mount.\r\n\r\nAnyway, we will investigate further to see if there is a good solution for this issue, but just wanted to put down the above thoughts and a work-around that may get you unblocked while we work on it.","Hi @dougwilson thanks for the prompt reply. I already have a workaround in place in the form of a rewrite like you suggested, so this is not pressing, but I'll add my few thoughts as well in case it could be useful.\r\n\r\nI think the root conceptual issue is whether a route is made of paths, or strings:\r\n1. if they are paths, then `\/app` and `\/app\/` are equivalent, and so are `''`  and `\/`, and any logic for (un\/)mounting route prefixes should be insensitive to trailing slashes\r\n1. if they are strings, then there is nothing special to slashes, and route manipulation should strictly be about concatenation of partial routes.\r\n\r\nNow I think when the router is in strict mode, it's opting for 1, which is fine for most people. In that case though, maybe the (un\/)mounting of path prefixes should employ logic equivalent to `url.resolve` instead of manual trimming of slashes and keeping track of that state.\r\n\r\nSituation 2 is tricker, as I think one big challenge is that after a mounting point `''` and `'\/'` are fundamentally different endpoints, and I'm not sure to whether express can handle the different well throughout.\r\n\r\nRight now, the router seem to follow both paradigms, if that makes sense.\r\nHope it helps!\r\n\r\n","Is anyone working on this issue?\r\nI would like to work on it.","when router adds removed back it add them [here ](https:\/\/github.com\/pillarjs\/router\/blob\/f76ecfd32f0a4a1f036058c3390162355fec73bf\/index.js#L206)\r\n``` js\r\nreq.url = protohost + removed + req.url.slice(protohost.length)\r\n```\r\nand the values in this example\r\n```\r\nreq.url = 'index.html' \/\/ the leading slash was removed because router thenk it injected\r\nremoved = ' \/app'\r\nprotohost = ''\r\n```\r\na way to solve this is instead of concatinating strings use the `node:path` module to join the three parts.\r\nor create custom code to do that , but it should cover all scenarios (slashes and not).\r\nthe problem of using the module is confimity with the rest of the code\r\n\r\nalso before deleting added slash we could add check that the first char is a slash"],"labels":["4.x","investigate","module:router"]},{"title":"added the ability to for app.set to accept a json of settings","body":"fixes #3997","comments":["Nice! all checks passed now, i knew it!"],"labels":["pr"]},{"title":"Provision to pass json replacer with a set of options.","body":"app.set('json replacer', {\r\n\tfn: function(key, value, {req, res}) { ...},\r\n\treqRes: true\r\n});\r\nThis is another way.\r\nOne of the options is reqRes : true. In this case, the replacer function is called with req and res objects, which can be used to customise the replacement process according to the request.","comments":["Please consider now. Fixed","Updated the test case , fixed bug."],"labels":["pr"]},{"title":"build: drop node <8","body":"> When 5.0 is released it will support down to the LTS version at that time.\r\n\r\n_Originally posted by @dougwilson in https:\/\/github.com\/expressjs\/express\/issues\/2755#issuecomment-382499774_","comments":["I am not sure about this, if the code still passes is there a reason to drop all of the targets?  Obviously we will convert to using some new features like arrow functions at some point, but those are supported back until at least like node 4.  Is there a reason to stop running the tests in the \"likely to still work\" scenarios?  Maybe we could only remove them when we introduce changes which intentionally break them?\r\n\r\nI do not have super strong feelings here, it just seems to me like stopping testing them unless we actually break them is really abrupt.  ","Async functions needs node 8.","@q4w56 We don't currently use async functions in express core.  \r\n\r\nSo I guess my point is that testing express core against these older versions doesn't hurt until we introduce an actually breaking change.  We will not \"support\" them, but I guess I think it might be better for us to keep testing it until the first PR which actually breaks compatibility.","> We don't currently use async functions in express core.\r\n\r\nMaybe because no pr can use async functions before this pr lands?","> > We don't currently use async functions in express core.\r\n> \r\n> Maybe because no pr can use async functions before this pr lands?\r\n\r\nWord!","Your statement is the opposite of how this project operates. Until PRs are put forward that utilize new features that cannot be supported in older versions is how said older versions get dropped, as then there would be a purpose to drop said support. ","express may not have code that fails on EOL Node.js versions, but express-generator depends on a beta version of pug that has a sec vuln, and updating to secure version fails on 0.10 and 0.12: https:\/\/github.com\/expressjs\/generator\/pull\/244\r\n\r\nIs that sufficient to drop CI for EOL Node.js versions?","> Is that sufficient to drop CI for EOL Node.js versions?\r\n\r\nNot necessarily unless there is no possible solution otherwise. The standard Node.js issue template usually asks folks what alternative solutions they have considered prior to their request, so maybe it may help to understand the same thing here: are there alternative solutions \/ which have you considered already? Or maybe are there no possible alternative solutions and why?","Sure, there is an alternate solution: explain to users that express generator creates apps that have audit warnings by default, and they should ensure they update the dependencies before using its output as the base for a production app. When they ask \"why does it do that?\", maybe \"tracking audit warnings is an important part of the lifecycle of a production app, this give you the opportunity to start doing that right away\".","I'm not sure if that comment was made in good faith and instead out of frustration. Maybe you need to cool off? I'm not sure I should provide a response at this time based on the tone there. Please correct me if I'm mistaken.","Hey, sorry to resurrect the off-topic conversation, but  the express generator right now is an issue IMO.  It is just totally old, full of cruft, and promoting bad practice.  I have started the work on a new and complete re-write which I have not yet pushed to that repo.  That said, I just opened [a proposal to our governance](https:\/\/github.com\/expressjs\/discussions\/issues\/98) which might help things like this not happen in the future.  @sam-github, I would love your input and if you are interested in working with me to improve the generator that would be awesome! Hit me up on that repo or on twitter to discuss.\r\n\r\nnote: marking this as off-topic after I post!\r\n\r\n","Dropping support for old versions of NodeJS will probably help getting new contributors, as no one wants to support older version of NodeJS with legacy ecma script features.\r\nSeeing that old versions of NodeJS are still supported can be a big no go."],"labels":["deprecate","pr","needs rebase"]},{"title":"why not make middleware or hooks that works exactly before sending response that could change or alter the response object","body":"**Problem statement**\r\n\r\nThere is a problem which always happens what if we wanted to make certain actions or wrap our responses all our responses in express in a certain standard way right now there is no built in hooks or middlewares which works before the sending \r\n\r\n**Lots of inefficient workarounds**\r\n\r\nI know there is workarounds by just overriding the response object but thats sometimes not efficient enough and sometimes breaks some functions while responding so , why not make hooks for the main response functions and just pass in the req and res objects for the user to modify and just return the res and req after the modification.\r\n\r\n**Just a proposed way for the way to make such hooks**\r\n\r\n```\r\nlet express = require('express');\r\nlet app = express();\r\nlet bodyParser = require('body-parser');\r\n\r\n\/\/ some middlewares\r\n\r\napp.use(bodyParser());\r\n\r\n\/\/ routes here\r\napp.get('\/test',(req,res) => res.send('I am a test function'));\r\n\r\n\/\/ now put a hook in the app to run before the send\r\n\/\/ this is an example of how to make send hook \r\napp.hooks.onSend = (req,res) => {\r\n\r\n    res.body = {\r\n            body: res.body,\r\n            status : 200\r\n   };\r\n\r\n   return { res, req };\r\n};\r\n\r\n```\r\n\r\n**benefits**\r\n\r\nIt is a simple use case but it will help alot of people make their code way better.\r\nby at least making a way to change res object either in headers or in the body or any other thing according to what they need to change.\r\n\r\n\r\n\r\n","comments":["Hi @abdoolly,\r\n\r\nThanks for the detailed and well reasoned request.  While I can see your reasoning, I think that what you are asking for is not the domain of Express to solve.  This is a great use case for a wrapper library which exposes the interface you desire.  This is a common way for users to solve problems where Express is still used under the hood. Also, it is the way the Express generally team prefers because it means we do not have to maintain the code for this new interface (smaller core).\r\n\r\nDoes that make sense?","@abdoolly  [Is this what you want?](https:\/\/github.com\/jiangwei1995\/api-response.git)","@jiangwei1995 : Could you please have a look at: https:\/\/github.com\/prkeshri\/express\/commit\/db50bddde2beb1e1ae3c0b4489c6a421a4c0ffef\/\r\nIf this could provide some value, I will raise a pull request. Thanks.","I've just made a library called [node-ally](https:\/\/github.com\/Grantlyk\/node-ally), you could submit this as a feature request","I think this is a valid request. \r\n\r\nExpress middleware is limited by the fact that the control flows downwards to other middlewares or handlers until the response is sent.\r\n\r\nIt is a useful feature to be able to capture certain actions so that people can control different application behaviours. For instance, users may need to wrap their request-response pipeline into one Unit of Work so that they can either commit or rollback based on the response before sending the response.\r\n \r\nASP.NET framework supports this kind of behaviour but sadly express.js doesn't. "],"labels":["ideas"]},{"title":"default no-cache headers","body":"Hi there!\r\n\r\nBy default, express does not serve no-cache headers on routes, so for instance:\r\n\r\n```\r\nimport * as express from 'express'\r\n\r\nconst app = express()\r\napp.get('\/', (_req, res) => {\r\n  res.send('Hello')\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\nResults in the following:\r\n\r\n```\r\ncurl -I localhost:3000\r\nHTTP\/1.1 200 OK\r\nX-Powered-By: Express\r\nContent-Type: text\/html; charset=utf-8\r\nContent-Length: 5\r\nETag: W\/\"5-9\/+ei3uy4Jtwk1pdeF4MxdnQq\/A\"\r\nDate: Thu, 15 Nov 2018 22:53:08 GMT\r\nConnection: keep-alive\r\n```\r\n\r\nThis is missing `Cache-Control: no-cache`, `Pragma: no-cahe` or `Expires: 0` headers that would inform the browser that the result of the request should not be cached.\r\n\r\nMy suggestion is to serve these files with no-cache headers by default, like [serve-static](https:\/\/expressjs.com\/en\/resources\/middleware\/serve-static.html). This will reduce the chance that folks will forget to configure it, and end up potentially having clients hang on to stale code.\r\n\r\n(this is an issue I've recently run into on my project -- it seems that sometimes browsers do cache such responses when no cache headers are provided)\r\n\r\nThanks for your hard work!","comments":["But we want web browsers to cache the content when possible by default. They should still be sending a conditional request due to the etag. What browser are you using and can you put together a reproduction case that demonstrates the browser not seeing the new content?","Ah, that clarifies things! I didn't know about the `Etag` directive, and missed it in the output above. Thanks!\r\n\r\nI think that totally makes sense as the default setting, and hopefully this issue will help some others that are following the same red herring as me. It's likely that something about our CDN is interfering with proper handling of the Etag header... since we're seeing chrome (69, 70) on ChromeOs and Windows 10 have the stale code issue.","One thing to note is that [`no-cache`](https:\/\/tools.ietf.org\/html\/rfc7234#section-5.2.2.2) does not mean \"do not cache\" - that would be [`no-store`](https:\/\/tools.ietf.org\/html\/rfc7234#section-5.2.2.3), rather it means \"do not serve this content from the cache without first validating it's freshness on the server\".\r\n\r\nAnd because @dlants didn't tell the client to first validate with the server, browsers have to rely on their own [freshness heuristics](https:\/\/tools.ietf.org\/html\/rfc7234#section-4.2.2) in which case the content may be cached for some time.\r\n\r\nI found [this article](https:\/\/paulcalvano.com\/index.php\/2018\/03\/14\/http-heuristic-caching-missing-cache-control-and-expires-headers-explained\/) which goes to the extent of looking at the source code of some of the major browsers, and verifies that content without `cache-control` or `Expires` is cached for \"_10% of the time since the object was last modified (provided that a `Last-Modified` header was returned)_\".\r\n\r\nSo if you have users downloading a web page (which does not use `no-cache` or a low `max-age`) that is still cached for 10% of the time since it was last modified, but has been updated since, breakage should be expected. This of course, should only be the case for documents, sub resources should preferably use file name versioning and a long `max-age` \/ `immutable` directive."],"labels":["ideas","wontfix"]},{"title":"Strict Routing","body":"I've been experimenting with strict routing using `express@latest` and have found that the following the requests all route to the same path when supplying `strict: true` to express. This doesn't seem to uphold the docs explanation of `Disabled by default, \u201c\/foo\u201d and \u201c\/foo\/\u201d are treated the same by the router.`.\r\n\r\n```js\r\nconst express = require('express')\r\nconst app = express({ strict: true })\r\nconst port = 3022\r\n\r\napp.get('\/:param?\/', (req, res) => res.json(req.params.param));\r\n\r\napp.listen(port);\r\n```\r\n\r\n```\r\n> curl -I http:\/\/localhost:3022\/\r\nHTTP\/1.1 200 OK\r\n\r\n> curl -I http:\/\/localhost:3022\/abc\r\nHTTP\/1.1 200 OK\r\n\r\n> curl -I http:\/\/localhost:3022\/abc\/\r\nHTTP\/1.1 200 OK\r\n```\r\n","comments":["Looking at the docs on expressjs.com about it, it doesn't really say what to expect for strict routing besides \"it treats \/foo and \/foo\/ as different\". There is no description for what to even expect when you have an optional parameter.\r\n\r\nThat said, the `express()` function does not take any argument, so the extra `{ strict: true }` your example passes in will do as much as passing in `{ foo: 42 }`.\r\n\r\nWe may have made a mistake in the docs. Can you point to where in the docs it says `express({ strict: true })` is a thing that would do something?","@sabrehagen for the built in router you need to use `app.enable('strict routing')` which is documented here https:\/\/expressjs.com\/en\/4x\/api.html#app.set\r\n\r\nyou can override this when creating a new router as documented here https:\/\/expressjs.com\/en\/4x\/api.html#express.router","I have noticed that strict routing works as documented when following a route defined **within** a route module like this:\r\n\r\n## myroute.js\r\n```js\r\nconst express = require('express')\r\nvar router = express.Router({ strict: true })\r\n\r\nmodule.exports = function (app) {\r\n  router.get('\/', a_middleware)\r\n  router.get('\/:id\/', other_middleware)\r\n  return router\r\n}\r\n```\r\n\r\nWhen the above is attached to my main app as follows:\r\n\r\n## app.js\r\n```js\r\napp.set('strict routing', true)\r\n.\r\n.\r\n.\r\nlet myroute = require('path\/to\/myroute')\r\napp.use(`\/myroute\/`, myroute)\r\n```\r\n\r\nIn the above scenario `https:\/\/server\/myroute\/8\/` routes to \"*other_middleware*\" properly while `https:\/\/server\/myroute\/8` fails. This is the desired and expected result.\r\n\r\nHowever, if I pull back one level it seems that the trailing slash does not change how I'm routed: `https:\/\/server\/myroute\/` and `https:\/\/server\/myroute` appear to work the same and routes me to \"*a_middleware*\" in both cases.\r\n\r\nSo, where the mini-app is attached to the main app the trailing slash makes no difference in the routing.","I'm encountering a similar problem. In my app, starting at a route defined at `\/api`, each subsequent level is a new router object, all created with `{strict: true}`, yet when I make a request to `\/api\/myroute`, it takes the codepath defined at `\/api\/myroute\/`.\r\n\r\nThe routes are defined as follows:\r\n```\r\nrouter.route('\/').get(...).post(...);\r\nrouter.route('').get(...).post(...);\r\n```\r\nWhere `router` is mounted to the parent router with `parent_router.use('\/myroute', router)`.\r\n\r\nA GET request to `\/api\/myroute` will take the first defined above, when I would expect it to take the second.\r\n\r\nOn my main application `app.set('strict routing', true);` has no apparent effect.","The strict routing seems to work, but not as intended. There is a problem with trailing slashes being added to root paths which then become unavailable with strict routing.\r\n\r\n```\r\nconst express = require('express')\r\n\r\nconst app = express()\r\n\r\n\/\/app.enable('strict routing')\r\n\/\/app.set('strict routing', true)\r\n\r\n\/\/ Returns static files from the public subfolder.\r\n\/\/ e.g. localhost:3000\/dir\/public\/views\/desktop.html\r\napp.use('\/dir', express.static('public'))\r\n\r\n\/\/ This adds a trailing slash to localhost:3000\/dir\r\napp.get('\/dir', (req, res) => require('.\/api\/root')(req, res))\r\n\r\n\/\/ This doesn't change and returns view on localhost:3000\/dir\/view\r\napp.get('\/dir\/view', (req, res) => require('.\/api\/root')(req, res))\r\n\r\n\/\/ This returns JSON.\r\napp.get('\/dir\/api\/get', (req, res) => require('.\/api\/get')(req, res))\r\n\r\napp.listen(3000)\r\n```\r\n\r\nThis adds a trailing slash to `localhost:3000\/dir` and returns the view or breaks with strict routing enabled. The behavior is the same whether enabled via .set() or .enable().\r\n\r\n```\r\nconst router = express.Router({ strict: true })\r\n\r\nrouter.get('', (req, res) => require('.\/api\/root')(req, res))\r\n\r\napp.use('\/dir', router)\r\n```\r\n\r\nSame behaviour here... Adds trailing slash and breaks with strict option set in the router.\r\n","Related https:\/\/github.com\/expressjs\/express\/issues\/2281","same problem, providing caseSensitive: true as option to express.Router has no effect.","`express.Router` instantiates `Layer` with `strict: true`. However, there is no `strict` in layer.js. In other words, this feature is not implemented and perhaps never was. \r\n"],"labels":["4.x","awaiting more info"]},{"title":"Allow to bypass middleware to last layer with next('last')","body":"It adds a built-in way to skip to the final route of a layers stack (see this closed issue #1662).\r\n\r\nBased on my experience, i was thinking it could be interesting to have this simple feature available.\r\n\r\nExample :\r\n\r\n```\r\nfunction middleware1 (req, res, next) { next('last'); \/\/ will call lastMiddleware }\r\nfunction middleware2 (req, res, next) { next('last'); \/\/ will call lastMiddleware }\r\nfunction middleware3 (req, res, next) { next('last'); \/\/ will call lastMiddleware }\r\nfunction middleware4 (req, res, next) { next('last'); \/\/ will call lastMiddleware }\r\nfunction lastMiddleware (req, res, next) { next('last'); \/\/ will call the next error middleware }\r\n\r\napp.get('\/my_path', middleware1, middleware2, middleware3, middleware4, lastMiddleware);\r\n```\r\n\r\nIn case of errors, this can allow to break the middleware cycle and jump to the last middleware of the route directly without the need to put a condition `if (res.locals.err)` in each middleware to jump to the next one, or to call an error-handling middleware with `next(err);` and to manage everything there, as redirection, render, controller call depending of the error, or to use `next('route')` with a route duplication each time... (which are three solutions not always very convenient).\r\n\r\n(maybe there is already a way to do that ? I didn't find it yet. See [this question](https:\/\/stackoverflow.com\/questions\/24840545\/is-it-possible-to-skip-route-middleware-in-node-express) and [my own question](https:\/\/stackoverflow.com\/questions\/52470387\/express-node-right-way-to-send-error-messages-through-middleware-cycle))\r\n\r\n\r\nLet me know your thoughts about it.","comments":["Hey @BigFax, thanks for the contribution! While interesting, I think we had wanted to move away from the \"magic strings\".  I think the feature you want seems great, so maybe if we could think of an api to achieve this without the magic string `last`?\r\n\r\nAlso, I would look at opening this PR against the router project, as it is where this would land in the 5.x branch.  https:\/\/github.com\/pillarjs\/router\/\r\n\r\nNote: I cannot find the specific issue where \"magic strings\" were discussed.  So feel free to shoot me down if others disagree.","I don't know the discussion either, but I recall the same thing. The main annoying danger is that most people do like `doThing((err) => { if (err) return next(err); ... }` so random things are passed in as the argument, causing potential extremely hard to debug problem if it gave a string that matched a magic one.\r\n\r\nThat said, I there there is a more general issue with this solution, in that is is not general enough. For example I can 100% forsee a follow up request if this lands that person x needs it to jump to the 2nd to last middleware, not the last one.\r\n\r\nI was reading your SO question and I think I know a workable solution based on your comments. I don't have a SO account to respond there and don't want to mix that into the conversation in this PR. You're welcome to open a new issue with the full background to explore that if you like.","I proposed a new \"magic string\" because it seemed to me to stick with the vision of the project and the normal behavior of the `next()` function (as 'route' and 'router' already existed). Now, in my personal opinion, \"magic string\" is not a good thing and should be removed from the `next()` function. I would prefer a function `next()` without parameter if it is not an error. I think it would be more logic and less confusing. @wesleytodd Do you think of a particular way to implement an API for this issue ? \r\n\r\n@dougwilson When i was thinking to call `next('last');`, it is more to end the route that to call a specific middleware. When a route ends, i think that the expected behavior is often to end the request by doing the render. In my understanding of Express, the render is made mostly in the last route middleware if everything goes as planned. So jump all middlewares to arrive to the last one in the goal to render the \"normal\" response but with error messages about where it broke was my thought. I think it's a common behavior, which is less the case than jumping from specific number of middleware (which can still be achieved with `next('route')` if really need it ? Even if it duplicate routes). It's my point of view, but maybe my understanding of things is not right here.\r\n","> So jump all middlewares to arrive to the last one in the goal to render the \"normal\" response but with error messages about where it broke was my thought. I think it's a common behavior, which is less the case than jumping from specific number of middleware. It's my point of view, but maybe my understanding of things is not right here.\r\n\r\nRight, that's the problem: you're just thinking about _your_ specific layout. Express makes no such requirement and you can easily have multiple handlers that do rendering based on perhaps what type of user was loaded for example. This is the type of thing someone who is already splitting up everything into separate middlewares is going to do, which is the use-case you're presenting. Just as a simple example of two renders at the end of a route:\r\n```js\r\napp.get('\/thing', [...],\r\n  (req, res, next) => { if (!req.user.isAdmin()) return next(); res.render(...) },\r\n  (req, res, next) => { res.render(...) }\r\n)\r\n```\r\n\r\nTypically the `if (...)` is wrapped using a helper, like so:\r\n```js\r\nconst ifUserIsAdmin = (handler) =>\r\n  (req, res, next) => { if (!req.user.isAdmin()) return next() else handler(req, res, next) }\r\napp.get('\/thing', [...],\r\n  ifUserIsAdmin((req, res, next) => res.render(...) }),\r\n  (req, res, next) => res.render(...) }\r\n)\r\n```\r\n\r\nThe other thing is just a functional issue with the PR itself, which is that it doesn't work at all in the common case of handling a route-specific error handler on the end of your route (because even your rendering handler may throw an error). Example:\r\n```\r\napp.get('\/thing', [...], (req, res, next) => res.render(...), (err, req, res, next) => ...)\r\n```","I got your point. \r\n\r\nTo me, `next('last')` was like `next('route')`, a way to manage routing cycle. In your first example, this is indeed one way of doing rendering. In this case, `next('last')` doesn't make sense. Now, as you said yourself, Express makes no such requirement, so you can totally manage rendering with a custom function where `next('last')` would be great, no ? This is the same for `next('route')` and `next('router')`, it depends of your routing organization and sometimes it doesn't make sense to use them. In fact, i think that `next('last')` is one way to help to manage routing without the need to put \"if\" conditions in each middleware (as i mentionned in case of errors, but also in case of roles check...). \r\n\r\nAbout the PR issue, you are right. One fix could be : \r\n\r\n```\r\n\/\/ bypass middleware to last layer\r\nif (err && err === 'last' && idx < stack.length) {\r\n  for (let i = stack.length - 1; i > idx; i--) {\r\n    if (stack[i].handle.length < 4) {\r\n      idx = i;\r\n      break;\r\n    }\r\n  }\r\n  return stack[idx++].handle_request(req, res, next);\r\n}\r\n```\r\n\r\n\r\n\r\n","Hi,\r\n\r\nI think we could rid of \"magic string\" and pass to `next` function another function like:\r\n`\r\nconst checking = () => {\r\n    return 'route'; \/\/ or return -1 to skip to the final\r\n}\r\n`\r\n\r\nand in `next` function we could do this:\r\n\r\n`\r\nif(typeof err === 'function'){\r\n      err = err();\r\n}\r\n`","This is a bit of an older issue, but I think an even better api would be something like:\r\n\r\n- `next.router()`\r\n- `next.route()`\r\n- `next.last()`\r\n\r\nIf we move forward with this I think that would be the api which would get my vote.","@BigFax @dougwilson what's the status on this? Is it still under consideration? I saw it needed tests and would be happy to help with that if appropriate!","@bpernick I don't know. I didn't follow this subject since a long time. I still think that if magic strings are kept, `next('last')` make sense, but that magic strings should be replaced by another API solution as proposed above.","> This is a bit of an older issue, but I think an even better api would be something like:\r\n> \r\n> * `next.router()`\r\n> * `next.route()`\r\n> * `next.last()`\r\n> \r\n> If we move forward with this I think that would be the api which would get my vote.\r\n\r\nMost of my current work requires building APIs with express and I see how this can be useful to me as a developer. But I believe this idea would lead to bad design choices when implementing it. Double edged sword imo. If at all it is acceptable, then the API makes more sense than the magic string."],"labels":["ideas","needs tests","pr"]},{"title":"Support http\/2.","body":"This PR is rebased and added tests from https:\/\/github.com\/expressjs\/express\/pull\/3390\r\nWe need to disable some tests on http\/2, as some node module have issue with http\/2. PR pending on resolution of the following issues:\r\n\r\n- [ ] `\/\/ cookies with http2 has an issue` https:\/\/github.com\/pillarjs\/cookies\/pull\/99\r\n- [ ] `\/\/ vhost with http2 has an issue` https:\/\/github.com\/expressjs\/vhost\/pull\/29\r\n- [x] ~~`\/\/ HEAD with http2 does not support response body`~~\r\n       response.sendFile has an issu. See also https:\/\/github.com\/expressjs\/express\/pull\/3730#issuecomment-419728593\r\n       fixed by commit https:\/\/github.com\/expressjs\/express\/pull\/3730\/commits\/2a78f4cb36ff63a18f1264ce1a0848c9bfedbf2b\r\n- [x] supertest http2 support (supertest removed in https:\/\/github.com\/visionmedia\/superagent\/commit\/b08371c72fbdca40dda3ad39fe8bbbee4a2718d5)\r\n       Fixed by https:\/\/github.com\/visionmedia\/superagent\/pull\/1414\r\n       Currently this PR does not depend on above issue, but this PR and the superagent PR have deplicate codes. We can delete those code after landing PRs.\r\n- [x] http2ServerRequest.socket.destroy() has a bug (filed an issue ihttps:\/\/github.com\/nodejs\/node\/issues\/22855)\r\n       Fixed in https:\/\/github.com\/nodejs\/node\/pull\/22896\r\n       Maybe land on node 10.12.0","comments":["ping @dougwilson","I saw the PR come in, just haven't had time to look over it yet, I apologize. ","Update: Node.js v10.10.0 was released an hour ago, and http2 module is no longer experimental\r\nhttps:\/\/nodejs.org\/en\/blog\/release\/v10.10.0\/","So I started taking a look into this, and it seems like this is good, but only a first pass. There are still a bunch of issues. Mainly, the test suite of Express doesn't extensively test all of it's dependencies, even just the high-level ones like `express.static` and `express.json`, etc. These seem to not work correctly under the HTTP\/2 implementation in this PR. I think that definitely makes the PR a bit less than ideal here.\r\n\r\nI'm going to write up a list of the issues I'm finding. Also, it seems like there is at least one more test disabled for HTTP\/2 not mentioned in the OP. We may want to add a checkmark list (I did that already) and track what is the known-outstanding issues. One of the comments in the PR is `HEAD with http2 does not support response body` but I'm not sure what that means -- the test is not trying to send a response body to a HEAD, as HTTP\/1 doesn't support a response body in a HEAD, either.","> One of the comments in the PR is HEAD with http2 does not support response body but I'm not sure what that means -- the test is not trying to send a response body to a HEAD, as HTTP\/1 doesn't support a response body in a HEAD, either.\r\n\r\nIt's my misunderstanding. I look into it and find issue about sendFile with http2 head method.\r\nFailing `sendFile` with head method is caused by difference with `http_outgoing_message` and `http2ServerResponse`. `http2ServerResponse.finished` with head method is true from [its made](https:\/\/github.com\/nodejs\/node\/blob\/master\/lib\/internal\/http2\/core.js#L2217), but `http_outgoing_message.finished` with head method is `false` until [calling `http_outgoing_message.end()`](https:\/\/github.com\/pillarjs\/send\/blob\/master\/index.js#L703).\r\n\r\n`res.sendFile` with head method seems to depend on the order.\r\n1. call [`onfile`](https:\/\/github.com\/expressjs\/express\/blob\/5.0\/lib\/response.js#L912).\r\n2. call [`onfinish`](https:\/\/github.com\/expressjs\/express\/blob\/5.0\/lib\/response.js#L917).\r\n\r\nHowever, `http2ServerResponse.finished` is always true so that `onfinish` is called first.\r\nI will fix it tomorrow. ","@sogaani `superagent` just dropped the HTTP\/2 support https:\/\/github.com\/visionmedia\/superagent\/commit\/b08371c72fbdca40dda3ad39fe8bbbee4a2718d5 maybe you can help them, or maybe we just need to use something else for our http\/2 tests.","@dougwilson Thank you telling me that. I made PR for superagent. https:\/\/github.com\/visionmedia\/superagent\/pull\/1414\r\nI added same change here.","I think the tests are revealing some kind of Node.js bug:\r\n```\r\n     Uncaught TypeError: Cannot read property 'trailers' of undefined\r\n      at Immediate.finishSendTrailers (internal\/http2\/core.js:1467:31)\r\n```","It is interesting. I will look into it.","Regarding to TypeError, I found a nodejs bug and file the issue. https:\/\/github.com\/nodejs\/node\/issues\/22855","@dougwilson Do you have a list of modules you will investigate to find issue? Maybe I can help you to find the issues by adding http\/2 test to modules.","hello guys,\r\ni know there was  a PR that was merged into one of the branches that supports now http2. i am not seeing this merged PR in the latest releases. Do you guys it is now implemented (with http2 together with websockets)? If sow, which version?\r\n\r\nThanks!","Since the person making this PR has also dropped off (judging by submission history, and the month or so since an update), what's the progress here? Is this the sort of thing we may see in a month? A year? I can't find any timeline for the next release of Express, so wondering whether this is coming soonish, or should I begin to look into other solution \/ switching frameworks? ","It looks like it only possible to work it with spdy right now. ","Is there anything I could do to help here?","It turns out that even though http2 in core has a compatibility API, it is not transparent and still causes a lot of breakages. There are the obvious issues of the colon-prefixed headers that show through in req.headers and so now our internals and existing middleware need to be reworked to properly handle these (think for example anything looking at req.headers.host), but also even the events that are emitted on the objects seem to be slightly different, which is having ramifications on our deep internals.\r\n\r\nI've pretty much come to the conclusion and started working on what I think is the only real option: create an entirely new request and response object that completely wraps the node.js core ones and evens them out between http\/1 and http\/2 so no module ever have to understand the difference between them. Otherwise there is going to be a growing divide in the middlewares, and just using a middleware you'll not easily be able to tell if it works with http\/1, http\/2, or both.\r\n\r\nI think that the common deployment behind lbs will be http\/1 for the foreseeable future, but http\/2 is growing and of course is needed to provide new features, so it does news to be supposed in express. But we cannot scrasifice the usability of middleware by forcing them to manually support 1&2 and hope that just works out.\r\n\r\nThis is a large effort to create this new abstraction layer, though I have recently started work on it. It would be awesome if the core http2 compatibility api was just this layer directly, but i think with it shipping as stable that ship has sailed and express needs to stop letting the node.js core object shine through at all to ensure a stable api.","@dougwilson so it seems, it is not just straight put in some quick http2 code, but it needs more work, but it will be actually finally be working in the foreseeable future ?","Both are correct and on the latter point I am spending all my free time on this task currently. ","Sorry to bug like this, but is there any status update on the HTTP\/2 support? Any signs that it would make it to Express.js 5?","i solved it using express http\/v1.1 and i use a nginx https2 proxy, that is the best solution.","Guys what is status? Maybe i can help?","\/cc @dougwilson friendly ping. Can we release this without major bump? How i can help? Maybe you can to list issues\/PRs\/TODOs?","Any updates? I can't wait for Lighthouse to stop screaming at me once this gets implemented.","HTTP\/2 is not gonna work in browsers unless you have TLS enabled (HTTPS), and you not gonna let Node\/Express handle the SSL traffic because it's much of a burden on it, therefore, you would use Nginx as a reverse proxy in production for your node application. And Nginx will handle the SSL traffic and support HTTP\/2.\r\n\r\nSo, for express or even node to support HTTP\/2 is just a wild idea and not technically practical in real life (production environment).\r\n\r\nSee my tut: ( https:\/\/github.com\/XOR-LIFE\/node-production )","HTTP\/2 is also very valuable in service-to-service communication between microservices, not just from frontend browsers. gRPC uses HTTP\/2 for example, though I guess that isn't totally relevant to express. But it would still be valuable for express to have HTTP\/2 support for REST APIs","I make a case for why server frameworks (and not just (reverse) proxies) needs to support HTTP\/2 in https:\/\/github.com\/aspnet\/AspNetCore\/issues\/4249#issuecomment-460288563. There are more use-cases, but I think the one explained there is a pretty strong one.","\/cc @dougwilson friendly ping again, what is blocker, where i can help?","https:\/\/github.com\/expressjs\/express\/pull\/3730#issuecomment-441338216","@dougwilson thanks, any roadmap\/ideas\/spec how we can solve this and how i can help? It seems to me that now nobody works on this and it is very awful, a lot of software is used express and need this feature so I offer my help, but without feedback from core developers i can't help.","Currently we are trying to focus on the 5.0 release so it does not continue to be years without release. We will come back to focus on items like http\/2 once the 5.0 is out and work to figure out the points you have raised around http\/2  ","@dougwilson how i can help with 5 version? Looks no commits from Oct 27, 2018","We are working on the docs in the expressjs.com repo currently.","@dougwilson thanks for feedback, any ETA for 5 version? We really need https support :disappointed: ","Express 5 is coming out asap. That is why the TC decided to push all these other things to the side and get 5.0 out. None of us are paid for Express work, which consequently means that we have day job obligations that take priority, least we loose the roof over our heads. I bring this up because having an ETA with unpredictable hours is not very possible is all, besides saying that it is asap because it's the only focus at the moment.\r\n\r\nExpress already supports https even without http\/2 ","@dougwilson oh, i was wrong about https, i mean http\/2, thanks for feedback, if you need help with express@5 feel free to ping me, i can find time on help","@dougwilson if there are any specific things you'd like help with please let me know\r\n\r\nIt's impossible to use webpack-dev-server with HTTP\/2 anymore because spdy is broken past node 11.1","> None of us are paid for Express work, which consequently means that we have day job obligations that take priority, least we loose the roof over our heads.\r\n\r\n@dougwilson maybe you already have thought about this idea and also I'm not the person who should say this pardon :grimacing: \r\n \r\nSomething like [opencollective](https:\/\/opencollective.com\/) and [others](https:\/\/opensource.guide\/getting-paid\/) may help to attract **more** people to spend their valuable time on valuable open-source projects like this one.","Hey @devsumanmdn, I am going to mark this as off topic, but I agree and if you would like to discuss more on this topic I have this issue open: https:\/\/github.com\/expressjs\/discussions\/issues\/69","To step forward this PR, I'd like to clarify the issues with http2 compatibility layer and make sure the criteria for landing this PR.\r\nI thought rewriting http1 tests of nodejs to http2 is a reasonable way.\r\n\r\nHere is the initial repo: https:\/\/github.com\/sogaani\/http2_compat_tests\r\n\r\nThanks to the efforts of making the compatibility layer, many tests of this repo are passed. However, this repo exposed 38 failer test cases. As @dougwilson said, this failer will cause a lot of breakages.\r\nAfter notifying a lot of differences between http2 compatibility layer and http1, I concerned that to make the new abstraction layer that @dougwilson is trying needs too large effort to maintain.\r\nSince 38 failers include luck of API(e.g. `res.writeProcessing`, `req.connection.bytesWritten` ) and different behavior of API(e.g. `res.setHeader` cannot overload automatically adds), I think the http2 compatibility layer still has spaces to improve compatibility. \r\n\r\nBecause the repo did not expose the issue I found [here](https:\/\/github.com\/expressjs\/compression\/pull\/128#issuecomment-527730832), rewriting http1 tests of nodejs to http2 can not find all issues, but I think it still reasonable to be the criteria for landing this PR.","express+spdy crashes on node 12 and has no maintainers so there's pretty much no way to use http2 with express. any news regarding native http2 support?","Express 4.0 + spdy + Node 10 work like a charm ","2 years gone and still no http2 here. Any developers here? Any news? We can't work with NodeJS 10 anymore, but we need the http2 support at least on the localhost. Spdy module has stopped the support. :(","[This gist can help somebody who needs to use spdy only for development http2 server with express js](https:\/\/gist.github.com\/studentIvan\/6c78886c140067936ff379031fd12e14)","@sogaani I read the related issues (and above), can you still clarify what the blocker in the current approach is? Any chance of helping (likely no luck ): )? Cheers","There is a core bug in HTTP\/2 in Chromium\/Chrome I found:\r\n\r\nhttps:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=1045328#c50","@eljefedelrodeodeljefe \r\nReferring to  https:\/\/github.com\/expressjs\/express\/pull\/3730#issuecomment-441338216\r\n\r\nCurrent blocker is nodejs `http2` compat layer does not compatible with `http` module and it cause breakages when we use `http2` compat layer as it is.\r\n\r\nCurrent approach is create new request and response object that wrap and hide differences between `http2` and `http` module.\r\nMaybe, @wesleytodd work on first step of that on https:\/\/github.com\/expressjs\/discussions\/issues\/82\r\n\r\nI exposed the differences to fix them on https:\/\/github.com\/nodejs\/node\/issues\/29829","@sogaani Please update the community on the progress - thank you again of spending time on this.","Found this project, which may be just the right thing for non-production use: [http2-express-bridge](https:\/\/github.com\/rahulramesha\/http2-express-bridge)  (You get what you pay for.)","> @sogaani Please update the community on the progress - thank you again of spending time on this.\r\nhttps:\/\/github.com\/expressjs\/express\/pull\/3730#issuecomment-780366418\r\n\r\nAlmost another year has passed -- [HTTP\/3](https:\/\/github.com\/nodejs\/node\/issues\/38478) is around the corner ...\r\n","Any update on HTTP\/2 support in Express?","Hey there, is express now supporting http\/2 ?","Really?!?! My comment was marked as spam? How about something productive like a status update instead?","@sogaani @dougwilson Hi just wondering if this feature is still in the works \/ planned? Or is there is a recommended workaround?","I have not been working on this PR for long time. Currently I don't have much time to progress.\r\nI would be happy if someone could take over this PR.","Any update on HTTP\/2 support in Express?","what the time line on this","any updates?\r\n\r\n@sogaani mind updating the checklist above about what is left? looks like from the above list:\r\n* sendFile\r\n* cookies\r\n* vhost"],"labels":["enhancement","5.x","pr","needs rebase","top priority"]},{"title":"Move settings methods to app.settings and deprecate old versions","body":"Started as a `5.x` PR, this is the deprecation version for the `4.x` branch.  See: #3218\r\n\r\nThe only thing I am worried about this this is that the `app.settings` object has changed.  It used to be a plain object, and is now an instance of `Settings`.  I think some purists would call that a breaking change.  The problem is that there is no way to provide the new functionality without changing that object.\r\n\r\nIf we had a faster major release cadence, we could deprecate in `5.0` (breaking direct `.settings` access) and remove in `6.0`.  But that might be YEARS, and speeding up majors is a different topic, one which I think we should do.  So IMO I think we have two options:\r\n\r\n1. Live with this as a breaking change in an undocumented api and release the deprecation warnings on the documented stuff\r\n2. Only do this in `5.0`.\r\n\r\nI am perfectly happy with either, but if I had a choice it would be 1 because it preps people who are using it for 5.0 and the churn on this api shouldn't be much and is worth it.","comments":["> The only thing I am worried about this this is that the app.settings object has changed. It used to be a plain object, and is now an instance of Settings. I think some purists would call that a breaking change. The problem is that there is no way to provide the new functionality without changing that object.\r\n\r\nAh, never realized that. Yea, it may not be possible to land this in 4 then. But I am on my phone so need to actually look at the changes later to get a better feel.\r\n\r\n> and speeding up majors is a different topic, one which I think we should do. \r\n\r\nI've had similar thoughts recently and I agree it is a different topic, so won't even share my thoughts on this inline to keep on topic. If you would like to open a new discussion in the discussion repo, feel welcome!\r\n\r\n> I am perfectly happy with either, but if I had a choice it would be 1 because it preps people who are using it for 5.0 and the churn on this api shouldn't be much and is worth it.\r\n\r\nYea, I'll take a look both at the implementation and as much existing code that is out there to see if we will definitely break something or not as an additional point of reference.","I believe the last few minors had changes that were super subtle breaking changes that ended up having quick .1s each time to revert them because the age of express meant there was just massive usage of those subtle things because even when we don't document it, it gets in blogs, books, and stackoverflow, making it... difficult,  haha.","Release discussion: https:\/\/github.com\/expressjs\/discussions\/issues\/67\r\n\r\nAnd yeah the support issues is a big deal, and honestly one of the things you have done a great job with in express over the years.  If we don't think it can land in 4 then it is fine, I can just add deprecation warnings that say it will be removed in 5.0.  Of if that other discussion bares fruit, we can move to deprecate in 5.0 and remove in 6 :)"],"labels":["pr"]},{"title":"Add \"view options\" settings for rendering engines","body":"Avoids cluttering app.locals, and is consistent\r\nwith the assignment of the \"view engine\" settings:\r\n```js\r\napp.set(\"view options\", {\r\n    basedir: \"somedir\"\r\n});\r\napp.set(\"view engine\", \"pug\");\r\n```\r\nThe intent is also stated more clearly in comparison to:\r\n```js\r\napp.locals.basedir = \"somedir\"\r\n```","comments":["Seems reasonable. Would this only apply to the set default view engine, or to all view engines (and if so, how would conflicting options be resolved)? Please add some tests when you find the time \ud83d\udc4d ","Yeah, it applies to all view engines, although I've only looked and modified the app.render code, so I may not be entirely sure. ~~It's basically an alias for the app.locals.~~ I'll do a double check.\r\n\r\nEdit: Yeah, it applies to all view engines, not just the default one.\r\nIt merges the options in the following order:\r\n1. app.locals\r\n1. app.settings[\"view options\"] (this is what is added)\r\n1. renderOptions (from app.render(name, renderOptions, callback) { ... })\r\n\r\nThe latter ones override the former. I'm not sure if the added test suffice or they are in the right place.\r\n```"],"labels":["ideas","needs tests","pr"]},{"title":"Auto file extension lookup with multiple view engines","body":"When there is no file extension defined, express will now try to use any extension that is registered with an engine. The default extension set by `app.set('view engine')` is still observed first.\r\n\r\nRelated issue: #3485","comments":["This seems like a good addition to me.  I would like a few more people opinion before we decide what to do with this for sure.  But in general it has my \ud83d\udc4d","Two other notes on both of your open PR's:\r\n\r\n1. Make them against the `5.x` branch, not `5.0`.\r\n2. The formatting should follow [standardjs](https:\/\/www.npmjs.com\/package\/standard)","@dougwilson I just went to investigate, and I was sure that the branch was `5.x`, but the PR (https:\/\/github.com\/expressjs\/express\/pull\/2237) is open from `5.0`.  What is your plan with those?  I feel like most of the open PR's are against `5.x`, but I could be wrong.","So for something destined for the 5.0 alpha the 5.0 branch is right, otherwise 5.x (5.x is the equivalent of master branch for major version 5). But even then, this seems like an enhancement that could do into 4.x, no?","Yeah, this should be able to land in `4` as well.  I only noticed this was open against `5.0`, so I brought it up.","In general as long as the commits are easy to move we can move them to the correct destination upon a merge. Since the view file is identical for 4 and 5 we can always merge to 4 even if the PR is against 5.","Thanks guys, so I'll leave this PR on 5.0. \r\nAs for the formatting are you referring to the _no-semicolon_ and _space before parentheses and opening brace_ rules? (More notably in the test file, which I have followed the current formatting)"],"labels":["pr"]},{"title":"node http code change could have major effect on express","body":"In node, commit nodejs\/node@a899576c that landed yesterday can have major problems for express if someone does use the IncomingMessage option.\r\n\r\nOn line 31 of request https:\/\/github.com\/expressjs\/express\/blob\/master\/lib\/request.js#L31 express references http.IncomingMessage.prototype to extend it with all the express functionality.\r\n\r\nIf someone changes the http IncomingMessage class and doesn't extend IncomingMessage then the reqs will not have any of express functions.\r\n\r\nNot sure why someone would, but they have the option to replicate the whole class without having to extend the real one.\r\n\r\nI haven't tested this yet (I will need to learn how to build node).. but I wanted to give everyone the heads up.","comments":["Very interesting. I wonder if there is a change we can make to Express to compensate for this (ideally backwards compatible with older Node.js versions and folks' existing apps)? I wonder if Node.js core is aware of this; Express.js is still part of the Node.js foundation after all :D","I really think we need to remove the prototypical inheritance here.  I think this should be a requirement for `5.x`.  Not only for this issue, but because replacing the prototype is a perf issue (and one of the  reasons that my new employer does not use express, along with the recursion in the router).\r\n\r\nI started a PR to at least extract the current method into separate modules, but I really think it needs to go a step further.  With the relative stability of these api's, I think the maintenance cost of wrapping them with our own `req`\/`res` will not be that much.\r\n\r\nI am at work right now so can't spend much time writing this up, but I have a bunch of ideas for this.\r\n\r\n","> along with the recursion in the router\r\n\r\nWhat recursion on the router? Wasn't that removed many releases ago to address that Netflix article? Definitely open an issue regarding this so it can be addressed \/ at least be known about :) @wesleytodd you've even an Express member now, lol\r\n\r\n> I am at work right now so can't spend much time writing this up, but I have a bunch of ideas for this.\r\n\r\nDefinitely please share :) ! Express 5.x is our opening to make significant changes. If you want to get together to brainstorm some as well I'm open to scheduling something.","What I'm thinking of is that article https:\/\/medium.com\/netflix-techblog\/node-js-in-flames-ddd073803aa4 which was fixed in Express 4.11.0 Jan 2015.","Yeah, that's the article I am referencing, and afaik we are much better off than we were, but restify takes a different approach which has pros and cons.  In a meeting right now, but I would like to write down all of the things I have been hearing from people here at Netflix which could be help to us improving and pushing express forward :)","Awesome, @wesleytodd looking forward to that. Didn't know you worked at Netflix now, congrats! We have the https:\/\/github.com\/expressjs\/discussions repo to have a place for over-arching planning discussions, especially useful for items that will span multiple repos.","> replacing the prototype is a perf issue\r\n\r\nThough this was done before I was on Express, ultimately this is a better approach than Restify, which actually globally patches Node.js internal objects (https:\/\/github.com\/restify\/node-restify\/blob\/master\/lib\/server.js#L33-L34) affecting all http servers running in the same process. If I had to choose between the way Express currently adds sugar and how Restify currently adds sugar, I would say Express does this is a better way. They are _both_ bad, don't get we wrong, just comparing imo Express is the _least bad_ currently, haha.","Yeah, I agree the way restify is doing it is not good either.  Actually I think restify is doing a ton of things much worse than express.  But there are some performance things which, AFAIK, they can prove they do better.  My hope is we can find a better middle ground that has the implementation strengths from express, but the perf optimizations which Netflix relies on.\r\n\r\nI just reached out to the author of that article, he is still at Netflix, to see if I can pick his brain.  So lets see if I can make that happen.","Gotcha. Yea, Express is open to making the improvements necessary. The biggest blocker is even knowing about them to do anything. This is a common barrier between corporate and the open source world (I'm in corporate world too, so defiantly know): internal to the corporation employees will do many things with open source software, be that finding bugs, quirks, evaluating different solutions with each other. But ultimately none of the findings are ever spoken about outside of the corporation, or at best these days there is a too-generic engineering PR post made on the subject.\r\n\r\nPerformance comparisons are even harder, because often times the employees tasks with doing that work just don't know the ins-and-outs of what they are testing (maybe knows just one really well). I have personally overseen a team doing performance testing that testing two pieces much lower than the others, because they made a coding mistake since they didn't read any documentation and just Googled to quickly slap code together :) I'm not saying this is how they are all, but it's hard to known even when summaries are posted because they usually don't include a method to reproduce the benchmarks.","So it turns out that the original author of that PR to node core is a team member here at Netflix, and it was particularly so that Restify did not need to klober the core `req`\/`res`.  @dougwilson I am going to work on writing up a few things looking at the differences between restify and express, and a proposal for how we could collaborate and combine efforts.  I will post it up in the discussions repo and link back here when I make progress on that.","Nice, looking forward to it :+1: looking at the commit I don't think it's possible for express to make use of it, because Express is designed to just be handed a req and res object which allows Express the flexibility to be embedded within Hapi servers, Koa servers, Connect servers, etc. That commit looks useful for frameworks that do not allow this and instead create the underlying HTTP server like Hapi and Restify, for example."],"labels":["discuss"]},{"title":"Example updated to ES6 syntax","body":"","comments":["Those examples are too old not since es6 now implemented everywhere  ","For reference: #3427 \r\n\r\nMy opinion on this is stated there, but both of these PR's are failing tests, so this might not be an acceptable change until we update the tooling to support new es2015 syntax.","@dougwilson It appears I am still unable to add the proper tags here.  Is there a permission you need to give me?","@express team, please rewritten codebase in es2015+"],"labels":["examples","pr"]},{"title":"Feature request: ability to set settings per response","body":"I'd like to implement middleware that returns formatted json in the response when `pretty_ouput` is present on the query. I attempted this with the following code:\r\n\r\n```js\r\n  \/\/ This code does not work as expected.\r\n  app.use(function(req, res, next) {\r\n    \/\/ Querystring `pretty_output` should prettify json output.\r\n    if (req.query['pretty_ouput']) {\r\n      app.set('json spaces', 2); \/\/ I'd like to set this only for this one request.\r\n    }\r\n    next();\r\n  });\r\n```\r\n\r\nHowever, subsequent requests without the `pretty_ouput` querystring are also formatted.\r\n\r\nIs there a way to set the setting `json spaces` for only one request? Ideally I could call `res.set('json spaces', 2)` that would set this option for only this one response. I'd think this would be generically useful for any Express option.","comments":["@bradvogel What if you disable the setting when the request does not contain the query string?\r\n```js\r\nif (req.query['pretty_output']) {\r\n    app.set('json spaces', 2);\r\n} else {\r\n    app.disable('json spaces'); \/\/ or app.set('json spaces', false)\r\n}\r\n```","The above will most likely not work as you want it.  This would result in a race condition between incoming requests.  At the moment I think your best bet is just returning your own json response logic.  Here is a reference for what the internal `res.json` is doing, maybe that would help:\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/b7817ab1b0bbadabe79fc88819c8338838ead707\/lib\/response.js#L239-L268","You could do something simple like:\r\n\r\n```\r\nfunction sendPrettyJson (req, res, value) {\r\n  this.set('Content-Type', 'application\/json')\r\n  var body = req.query['pretty_output'] ? JSON.stringify(value, null, 2) : JSON.stringify(value)\r\n  res.send(body)\r\n}  \r\n```","Yes - thanks. I know I can take over res.json and format it myself - but I'd prefer to keep using the built-in `res.json` and benefit from its future improvements.\r\n\r\nIsn't there still a generic need for setting options at the response level, e.g. to temporarily disable something like `x-powered-by` for a single response? Or any future options that are added? ","There is a generic need for this, and I believe there are some issues open for this.  I am at work right now and so cant dig for them, but if you search the issues and pr's you can probably find them.  I do not remember if anyone has created a strong enough proposal for it to get marked for inclusion into `5.x`, but feel free to do so :)","@wesleytodd I also thought this was discussed before, but I wasn't able to locate. I think this is useful, though even just looking at the way it's used now it likely wouldn't be compatible with Express 4.x due to a few places where the settings are looked up without any references to `req` or `res` to key off of.","Same, I could not find it either.  I think we should add this to the `5.x` road map.  It should be simple enough to pass `req`\/`res` to those places, and the value add is worth it IMO.","Hi, I have investigated some open issues involving races (as a research project) and took a look at the solution of @graphicbeacon. I created a small app (https:\/\/github.com\/sanji-programmer\/express-issue-3536-race) and as correctly pointed out by @wesleytodd  this solution is subjected to races (https:\/\/github.com\/sanji-programmer\/express-issue-3536-race\/blob\/master\/express01\/server-test.js). Using a tool we have developed, I could explore different callback interleavings that reveal the race. \r\n\r\nI also verified the solution proposed by @wesleytodd (https:\/\/github.com\/sanji-programmer\/express-issue-3536-race\/blob\/master\/express01\/server-test-fixed.js) and this seems alright and no subjected to races. \r\n\r\nI also noticed that modifying global settings of express may also causes races in different scenarios. \r\n\r\n\r\n"],"labels":["ideas"]},{"title":"Updating a couple of examples to ES6 syntax","body":"","comments":["@express team, please rewritten codebase in es2015+"],"labels":["examples","pr","needs rebase"]},{"title":"Deprecate req.path and replace with req.pathname","body":"So currently in Express 4 (and lower) there is `req.path`, which is added by Express. This property will return the _pathname_ of the given request. There has surfaced two issues here now:\r\n\r\n(1) The new Node.js HTTP\/2 compatibility API introduces a new (currently undocumented) `req.path` property that is an alias for the `:path` puesdo-header (`req.headers[':path']`) and so the meaning of `req.path` in Express vs in the HTTP\/2 compatibility layer differ (Express = pathname of `req.url` and HTTP\/2 compatibility API = `:path` header, basically what `req.url` is in HTTP\/1).\r\n(2) The property itself is sort-of misnamed, similar to the `req.host` header that was deprecated already and replaced with `req.hostname` (to come back in Express 5.0 with the current meaning in `req.host`).\r\n\r\nI am proposing that `req.path` is deprecated in Express 4 with a new `req.pathname` introduced in Express 4 and beyond to hold the existing `req.path` behavior.","comments":["Is the plan to fully remove the old functionality in `5.x`, and add a deprecation warning and the new property in the next minor release of `4.x`?\r\n\r\nThe only concern I have with that is that this is similar to what happened with the zero fill buffer issue.  Once everyone started seeing the deprecation warnings they opened issues, causing a ton of churn and work for maintainers.  I know we are on a slower release cycle, so it makes it harder because we can't just wait for `6.x`, but I just want to avoid this if possible.  Especially since this one is very widely used in applications.","There isn't reallt a set plan right now, which is why I opened to discuss :) As it stands, this property is one issue blocking using the new code HTTP\/2 stuff. Ideally it should be marked deprecated in the 4.x line, but another option is no provide no warnings and assume folks will throughly read the 4 to 5 migration docs to figure it out. I'm all ears for any ideas here :)","I think any churn\/work for maintainers of core, in this case, is worth getting the http2 stuff into 5.  Sadly...\r\n\r\n> assume folks will throughly read the 4 to 5 migration docs\r\n\r\nis just not feasible for all the people with packages in the ecosystem.  Having dealt with both the zero-fill buffer and the react 15.5 issues, I think that we are setting ourselves up for problems if we print deprecation warnings in the `4.x` line for such a relied upon feature.  What do you think about cutting the `5.0` branch early, and getting `6.0` support for http2?  I know it is not desirable, but just want to make sure we leave \"no stone unturned\" before subjecting every package maintainer of an express middleware to these issues.\r\n\r\nAt this point, many of the merged breaking changes are stable(ish?), the rest that are pending are smaller.  After `5.x`, maybe we can plan on dropping `6.0` sooner rather than later with more of the larger changes?","Right. But how long would people expect the 4.x and 5.x line be maintained? Would this mean actively maintaining 3 releases for a long time?","Sorry, to complete my thought: since these packages likely don't take a dependency on express and instead are subject to the version of Express the user is using, I'm not sure shipping a new major would alleviate this particular issue, since users will still upgrade and file issues everywhere, unless I'm missing something I guess.\r\n\r\nI am vety aware of deprecation issues and a package maintainer myself, and certainly want them to be seeiously warranted before subjectinf anyone to them. I also know that users think they are \"errors\" and not simply warnings that don't break anything.\r\n\r\nAt least where I am, in thr corporate world, Express is really looked up to for the extremely long support timelines of major versions. Node.js is sadly being hurt with the frequent major release, unfortunately. There isn't time to constantly replatform every year, lol.","Even if the intermediary packages don't directly depend on express, they would still trigger the deprecation warning by accessing `req.path`.  If you published `5.x` with the warning, and also started publicizing that support for `4.x` will end soon, then people would start migrating to the new `req.pathname` implementation now.  \r\n\r\nThe people who are ready for it can adopt 5, change to `pathname`, and move along.  People who are not will stop receiving updates other than if we decided to still do severe security patches (which is optional).  This would move express forward without disrupting EVERYONE by printing a dep warning in a minor point release.\r\n\r\nI think it is reasonable for to pick a support window, even if it is a shorter one.  As long as it is plastered up on the website and readme so people updating will know what to expect.  Maybe to satisfy the corporate need for long support timelines, we could support 5 for a longer period?\r\n\r\nI know what you are saying with node upping its pace being a problem in many areas, but one thing they are doing well is having a documented support timeline.  Maybe that is something that express should do?","I've been telling people so far (even on here) that Express 4 will be supported for at least 1 year after Express 5 comes out. ","We could maybe just add req.pathname in 4.16 just deprecating it in docs. Then maybe in 6 months release a 4.17 with it deprecated in code? Does that seem viable in some way?\r\n\r\n> The people who are ready for it can adopt 5, change to pathname, and move along. \r\n\r\nI thought your argument here was module authors; the authors cannot control the version the users use, so people will still plaster issues across the modules even if the warning didn't appear until 5.0.","![rockhardplace](https:\/\/user-images.githubusercontent.com\/1027776\/30513674-e4361bb0-9acc-11e7-9345-6d1ea951aef7.gif)\r\n\r\nYep, these kind of changes are never fun\/easy.  Maintaining 4, 5 and a possible 6 for a year does not sound like a great idea.  Maybe the best overall solution is just printing the warning in `4.x`.  But at least  if anyone takes issue with it we can point to this conversation to make it clear it was taken seriously.\r\n\r\nI think the gradual idea is better than nothing, it would hopefully make it less of a \"hair on fire\" issue where it all happens at once.  I did originally focus on module authors, but the more I actually think about it, the concern is equally module authors and application developers.","Right, the concern is indeed everyone, but usually the module authors are hit a bit harder when it is a change from something they don't have a direct version dependency on (like Node.js, Express.js) so they are really off guard. The app folks are usually a bit less, sonce they are the folks actually choosing the version (or choosing to live with a giant version range).\r\n\r\nIf we decide to move forward on this, we could possible try out of band warnings as the first stage. In other wards, add req.pathname just as another API in 4.16 maybe and then warn about it only in human land (the website announccement bubble, API docs, maybe even PRs to popular modules \/ ones you personally use) to either use\r\n\r\n    require('parseurl')(req).pathname\r\n\r\nor something verbose like\r\n\r\n    var pathname = req.pathname\r\n    if (typeof pathname !== 'string') pathname = req.path\r\n\r\nOr something. Certainly want to figure out a good solution. I did just read a thread that looks like Node.js master branch has removed req.path from the http\/2 compat layer, though it is not in any Node.js release yet.","So I opened the 4.16 PR, and it sounds like at least for here, we should just add a `req.pathname` property as an alias but leave `req.path` alone for now, right?"],"labels":["discuss","4.x","deprecate"]},{"title":"Node http2 - cannot read this.socket.readable ","body":"Testing node's new http2 native module I couldn't get express to serve requests over http2,\r\nUsing node master build with `--expose-http2` flag:\r\n```js\r\nconst express = require('express');\r\n\r\nconst app = express();\r\n\r\napp.get('\/express', (req, res) => {\r\n  res.send('Hello from express');\r\n});\r\n\r\nconst server = http2.createSecureServer({\r\n  key,\r\n  cert\r\n}, app);\r\n```\r\n\r\nWhen requesting \/express the server crashed with the following error:\r\n```\r\n(node:80731) ExperimentalWarning: The http2 module is an experimental API.\r\n_http_incoming.js:104\r\n  if (this.socket.readable)\r\n                 ^\r\n\r\nTypeError: Cannot read property 'readable' of undefined\r\n    at IncomingMessage._read (_http_incoming.js:104:18)\r\n    at IncomingMessage.Readable.read (_stream_readable.js:431:10)\r\n    at IncomingMessage.read (_http_incoming.js:96:15)\r\n    at resume_ (_stream_readable.js:811:12)\r\n    at _combinedTickCallback (internal\/process\/next_tick.js:138:11)\r\n    at process._tickCallback (internal\/process\/next_tick.js:180:9)\r\n```","comments":["Hi @PiniH since it's experimental and just landed on `master`, I don't think we have done any research into what would need to be done to support it (either in Express.js or maybe bugs in Node.js experimental code). If you would like to help us and take on that task, that would be amazing :) !","I would love to help investigate and assist with all the investigation\/integration between the new http2 and express, however I would need guidance on how\/where to start.\r\n@jasnell ","Yea, I'd need some time to take a look at what is going on to get some pointers for where to start.","@dougwilson From quick investigation - the first problem starts in the init function, it sets the wrong prototype - it's Http2Request\/Response all the way until \r\n```js\r\n    setPrototypeOf(req, app.request)\r\n    setPrototypeOf(res, app.response)\r\n```\r\nNot sure how to proceed now :)","Ah, the prototype. I guess that is different in the http2? Hmm, that sucks, because it is likely to be a large task to fix that. I would have assumed it wouldn't have been different, seeing as even the `spdy` module used those prototypes... and it's a third-party module that implemented http2 for a long time.","Aye, it's a different constructor, I just started playing with it today, I will look into it more tomorrow and post my findings.","I played with it some more, exposing Http2ServerRequest and Http2ServerResponse from node internal http2 files, and used them in the request\/response files, (also had to define an empty setter for response.statusMessage - as Http2ServerResponse only defines a getter but no setter).\r\n\r\nI managed to get a response (404, but still a response ;) ) - it seems to fail at matching the route - \r\n```js\r\n express:router dispatching GET \/express +38s\r\n  express:router query  : \/express +1m\r\n  express:router expressInit  : \/express +34s\r\n```\r\n\r\nit seems to fail at a stack error (but only on the third call - not sure what's up with that yet) on \r\n```js\r\n\/\/ get pathname of request\r\n    var path = getPathname(req);\r\n```\r\n\r\nIt got the correct path 2 times and then got stackoverflow. Any idea where\/how to proceed?\r\n","What's `path` returned as, and what's `getPathname` doing? ","From what I'm seeing, the getPathname is working properly, until the layer that's called expressInit is running (I guess that's an internal layer?), and then the getPathname fails with stackoverflow, will update soon with more details.","Amusing... \r\n\r\nHttp2ServerRequest defines getter for 'url' property as return this.path, express request.js defines 'path' as\r\n```js\r\nreturn parse(this).pathname;\r\n```\r\n\r\nwhich calls - you guessed it, request.url :) resulting in stack overflow, when commenting out the 'path' getter in request.js I got a response.\r\n","any progress so far? is there workaround without touching http2(or express) core?","Hi @hansanghoon all the work is happening in the linked PR: #3390","I am still seeing this issue with Node v10.14.1 and express@4.16.4. Is there any timeline on resolving this problem?","> I am still seeing this issue with Node v10.14.1 and express@4.16.4. Is there any timeline on resolving this problem?\r\n\r\nSame here...","I got the same error today. Any updates?","Same here, trying to serve up a react app over http\/2 using the native http module from node.\r\n\r\nI am using `\"express\": \"4.17.1\"` on Node `v12.13.0`\r\n\r\nAny ideas ?","is this being looked at?\r\nThis means in-built node http2 module cannot be used for Express?","https:\/\/github.com\/expressjs\/express\/pull\/3730","Still not working","+1, not working","Not working on Node `14.5.0`, express `4.17.1`","For now, `http2` is not working with the latest version of Express. You can use `spdy` with Express, or just wait for Express v5.\r\n\r\nsee https:\/\/medium.com\/@azatmardan\/http-2-with-node-js-c928b90423d0","FYI spdy does not work with node >= v15.","Express does seem to have an open PR for this in version 5.0. Until then, I have created a workaround as a package(https:\/\/www.npmjs.com\/package\/http2-express-bridge). It worked perfectly on my application. \r\n\r\nIf anyone wants to experiment with it, do check it out.\r\n\r\nTested on node-14.15.5, express- 4.17.1","> Express does seem to have an open PR for this in version 5.0.\r\n\r\n@rahulramesha There's a PR here: https:\/\/github.com\/expressjs\/express\/pull\/3730","> _Originally posted by @therealgilles in [#3388 (comment)](https:\/\/github.com\/expressjs\/express\/issues\/3388#issuecomment-775389790)_\r\n> FYI spdy does not work with node >= v15.\r\n\r\nThere's the issue here in spdy: https:\/\/github.com\/spdy-http2\/node-spdy\/issues\/380"],"labels":["investigate"]},{"title":"Suggestion: Implicitly-named error handler","body":"Apologies if this has been already requested, if it has I've been unable to find it in the issues or elsewhere on this project page. If this is completely contradictory to the intended design of express and I'm an utter moron, then for that, I also profusely apologise\r\n\r\nAs per the documentation (https:\/\/expressjs.com\/en\/guide\/error-handling.html), it's recommended or suggested practice to place error handlers after middleware to pick up any errors that get passed on. \r\n\r\nHowever, when I am working on projects containing a lot of middleware, it is a little bit of an eyesore to keep pasting in error handlers after middleware, and also some middleware doesn't properly implement errors or doesn't catch some errors, it becomes a pain (and yes, I am raising those instances with the middleware I encounter, too). \r\n\r\nThis means that an error handler at the bottom of the middleware calls, which could be called, for want of a better phrase, a global error catcher, doesn't always work. For example, when using body-parser among other middlewares, and receiving invalid JSON, an error handler needs to be put specifically after body-parser to catch the invalid JSON.\r\n\r\nNow, is it not possible for Express to pass back any errors it encounters iterating over middleware, back to one single function\/class\/whatever that the developer supplies (as a promise or whatever is desired) and cut off the chain of passing down middleware when it does that? That way, you can have all your error handling implemented in one place, and not have to copy-paste your error handler after every piece of middleware to make sure it catches the error you're looking for? \r\n\r\nIt'd still be an option to use the iterative approach, of course, but is this not a possibility in future versions? \r\n\r\nCheers,","comments":["You can put the error handlers at the bottom of your application that way the error handlers would catch all unhandled error. And you can check the type of error and decide whether to handle the error or pass it to the next error handler by calling `next(err)`","Hi hello-w,\r\n\r\nI addressed this in my initial comment in this section -- this approach does not always work consistently:\r\n_This means that an error handler at the bottom of the middleware calls, which could be called, for want of a better phrase, a global error catcher, doesn't always work_\r\n\r\nAnd also made an explanation of why this does not always work in the introduction and latter paragraphs of my post. ","Hi @JordanCraw the Express.js project is made of many people and cultures, not all of which have a comprehensive graph of English, so just pointing back to your original post is not always helpful, as it may have not been understood as written.\r\n\r\nEven myself, I read through it, but am struggling to really understand conceptually what you're asking for, as it sounds to me you are asking for something Express.js already provides. Perhaps it may help if you can provide some examples of what you are talking about in code form, which is sometimes more universal than English. For example, maybe you can provide the following:\r\n\r\n1. Example code that shows what you think is broken.\r\n2. Example code showing what the same code from number 1 would look like if your idea was implemented.","@JordanCraw I guess code like `router.get('path', [normalHandler, errorHandler])` is what you want. where `normalHandler` takes at most 3 arguments e.g. `req`, `res`, `next` in order and `errorHandler` takes exact 4 arguments `err`, `req`, `res`, `next` in order. That way, if there is an error in `normalHandler` you just call `next(err)` in `normalHandler` and `errorHandler` would be called right away. If everything is fine in `normalHandler`,  `errorHandler` won't be called. ","Hi @dougwilson, I appreciate that,  and I didn't mean to offend anyone, but as a speaker of other languages I try to read a post before responding to it, regardless of the language. \r\n\r\nAt the moment the error handling is like this:\r\n```js\r\napp.use(middleware);\r\napp.use(my_error_handler);\r\napp.use(some_other_middleware);\r\napp.use(my_error_handler);\r\nvar my_error_handler = (err,req,res,next) => { if(x){ next();} }\r\n```\r\nHowever, having to implicitly declare error handling after each call in some instances can be a bit of a pain. What I wondered if it would not be easier to also provide the option in a future version of express to have error handling taken out of the iterative declaration it currently is, and made global for the application you're defining. \r\n\r\nHere's an example with some pseudocode of what I mean: \r\n```js\r\n\/\/ Before you declare routes or paths, register it like you register the templating language, etc\r\napp.use('error_handler',global_error_handler)\r\n\r\n\/\/ Pseudocode representing express handling each middleware registered with 'app'\r\n_.each(bit_of_middleware,(err,req,res,next) {\r\n    if(err && app.error_handler != null) { do_the_callback(app.error_handler); }\r\n}\r\n```\r\nThank you for replying with an answer @hello-w, and I appreciate the reply. However, what I am referring to is not the fact of using an error handler, or how to use one for the routes I'm using, as in the example you provided still it requires an error handler be implicitly defined on each path. But rather, I'm requesting  the option to define an error handler _once_ which doesn't require so much code reuse. ","Thanks, I guess I misunderstood the following from your post:\r\n\r\n> This means that an error handler at the bottom of the middleware calls, which could be called, for want of a better phrase, a global error catcher, doesn't always work.\r\n\r\nGo me it read as \"global error catcher doesn't always work\" but was confused because you were asking for Express to provide a mechanism for global error handling, so wasn't sure which part of the post I was reading and if you wanted global error handling or not.\r\n\r\nExpress.js has a method of a single, global error handler today. Does that not work for you? How is your proposal different from the current model of adding a single, global error handler in Express.js?","@dougwilson I might be not looking in the right places, but I've not been able to find that on the documentation I've seen on the expressjs site. Are you able to give an example of what you're referring to as a single global error handler, so I can try? ","You just define one error-handling middleware last, after other app.use() and routes calls.","Okay, but what I am trying to say is -- that doesn't always work if other middleware decides to throw the error back before it reaches the end of the chain to the error-handling middleware. \r\n\r\nFor example -- if I use body-parser, then send malformed JSON, and put other middleware below the body-parser call, such as morgan, or whichever, the error won't make it down to the error handler at the end of the list as you've suggested, it just gets thrown by some other middleware which seems to see the incoming error from the previous request and send it to the client (regardless of if the error  handler is set at the end of the middleware chain).\r\n```js\r\n\/\/ incoming JSON: {this:is_malformed_json;}\r\napp_use(body_parser.json({}));\r\napp.use(this_is_my_error_handler); \/\/ <-- Error reaches here.\r\napp.use(helmet({})); \/\/ Using helmet as an example, but this does the same with other middleware for me, the error gets thrown as soon as it goes into this.\r\napp.use(this_is_my_error_handler) \/\/<-- Doesn't reach here.\r\n```","Hi @JordanCraw in your example, the first`this_is_my_error_handler` will handle the error, os of course it doesn't reach the second `this_is_my_error_handler` unless you forward the error inside that using `next(err)`. Can you try the following and see if your `this_is_my_error_handler` is still invoked? You should only need it once, otherwise this is a _really big bug_, because many people, including myself, rely on the current ability to make global error handlers.\r\n```js\r\n\/\/ incoming JSON: {this:is_malformed_json;}\r\napp_use(body_parser.json({}));\r\n\/\/ remove this --- app.use(this_is_my_error_handler); \/\/ <-- Error reaches here.\r\napp.use(helmet({})); \/\/ Using helmet as an example, but this does the same with other middleware for me, the error gets thrown as soon as it goes into this.\r\napp.use(this_is_my_error_handler) \/\/<-- Does both reach here now?\r\n```","Nope, it doesn't reach it if I remove the first error handler, it only reaches the first error handler because if I remove it, the next middleware throws the error. ","Here is a full example of what global error handling looks like today in Express, complete with an example invalid JSON request showing that the global error handler is invoked just fine. Let me know why this pattern doesn't work for you :) !\r\n\r\n```js\r\nvar express = require('express')\r\nvar bodyParser = require('body-parser')\r\nvar helmet = require('helmet')\r\n\r\nvar app = express()\r\n\r\napp.use(bodyParser.json())\r\napp.use(helmet())\r\n\r\napp.get('\/', function (req, res) {\r\n  res.send('Hello, friendly user!')\r\n})\r\n\r\n\/\/ The single, global error handler\r\napp.use(function (err, req, res, next) {\r\n  res.send('Hello, I am your friendly global error handler! I saw ' + err.toString())\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\nJust save that as `app.js` and then install the required dependencies:\r\n```\r\n$ npm i express body-parser helmet\r\n\r\n+ body-parser@1.17.2\r\n+ helmet@3.6.1\r\n+ express@4.15.3\r\nadded 67 packages in 2.959s\r\n```\r\n\r\nThen start up the app with `node app.js`. Go ahead and call that app with invalid JSON and the gloabl error handler responds just as expected:\r\n```\r\n$ curl -H'Content-Type: application\/json' -d'{this:is_malformed_json;}' http:\/\/127.0.0.1:3000\/\r\nHello, I am your friendly global error handler! I saw SyntaxError: Unexpected token t in JSON at position 1\r\n```","Hi @dougwilson ,\r\n\r\nI've replicated and I get the same result as you, but that's not really my contention. My contention is more with middleware that doesn't do that, and which throws an error straight away. I'll try and explain a little bit. \r\n\r\nSuppose that there is some poor middleware you're using which doesn't pass the error call over:\r\n```js\r\napp.use(middleware_1);\r\napp.use(i_am_middleware_that_will_just_throw_an_error_in_the_result_and_not_use_next);\r\napp.use(my_errror_handler_that_gets_no_errors);\r\n```\r\n\r\nWhat I'm trying to get to is, `i_am_middleware_that_will_just_throw_an_error_in_the_result_and_not_use_next` will not throw the error. So either I go to that middleware's repo and submit a patch that updates the middleware to call `next(err)`, or can not express just handle the error and pass it to a function instead of relying on the error handler sitting at the end, which might not work? That way express doesn't need to rely on all middleware using `next(err)` properly.\r\n\r\nIf it's the case that I should just submit a patch to the repo of the middleware that doesn't do this -- I will close this issue and please accept my apologies :) \r\n\r\n","Hi @JordanCraw even throwing an error will _still_ invoke the global error handling Express.js currently has. Let's take your example and implement that in my example app to see a demonstration.\r\n\r\nHere is the updated `app.js` file. I added the hypothetical `i_am_middleware_that_will_just_throw_an_error_in_the_result_and_not_use_next` middleware that done nothing by hard _throw_ an error. There is no `next(err)` being called in the middleware. Express.js wraps al middleware invocations in a `try`-`catch`, and so thrown errors (either on purpose or accident) will still flow down the error handling framework in Express.\r\n\r\n```js\r\nvar express = require('express')\r\nvar bodyParser = require('body-parser')\r\nvar helmet = require('helmet')\r\n\r\nvar app = express()\r\n\r\napp.use(bodyParser.json())\r\napp.use(helmet())\r\n\r\napp.use(function i_am_middleware_that_will_just_throw_an_error_in_the_result_and_not_use_next (req, res, next) {\r\n  throw new Error('oops, error thrown!')\r\n})\r\n\r\napp.get('\/', function (req, res) {\r\n  res.send('Hello, friendly user!')\r\n})\r\n\r\n\/\/ The single, global error handler\r\napp.use(function (err, req, res, next) {\r\n  res.send('Hello, I am your friendly global error handler! I saw ' + err.toString())\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\nJust save that as `app.js` and then install the required dependencies:\r\n```\r\n$ npm i express body-parser helmet\r\n\r\n+ body-parser@1.17.2\r\n+ helmet@3.6.1\r\n+ express@4.15.3\r\nadded 67 packages in 2.959s\r\n```\r\n\r\nThen start up the app with `node app.js`. Go ahead and call that app and the gloabl error handler responds just as expected:\r\n```\r\n$ curl http:\/\/127.0.0.1:3000\/\r\nHello, I am your friendly global error handler! I saw Error: oops, error thrown!\r\n```\r\n\r\nI'm not saying you're not experiencing some kind of problem, but I would love to see the behavior you describe. Perhaps you can follow the format I'm using here and provide a working example that exactly demonstrates the issue you are describing. I would love to see any gaps closed in Express.js and it feels like you are holding the issue at ransom by not really helping out :) Just create an example `app.js` like I've been doing that has the issue you are describing, provide any setup instructions and the request to make against the server to trigger the issue.","Also, I know there are situations where people cannot provide code, for example being proprietary. You're absolutely welcome to make a pull request implementing a solution to your issue as well, of course!\r\n\r\nI know you provided puesdo code above, but the issue is that Express.js is already hooking into all errors it can and dorwarding them to the error chain. If I were to implement it today, it wouldn't catch any errors the already-existing error handling weren't catching. That's the gap I'm trying to figure out: what is it that that middleware is doing so we can provide some mechanism for you to handle the error (like implementing your global error handling suggestion).","Yeah, that's my conundrum really. I'm sorry if it feels like I'm holding the issue at ransom, but it's not so much issue as a change of approach, which is what I'm trying to get across, but it seems we're having difficulty. It's not a tangible issue like, I have a problem getting this module to work or that -- I am using express in my daily life without issue. \r\n\r\nTo summarise what I'm trying to ask:\r\n\r\n- At the moment you put the error handler at the end of the list of app.use() declarations.\r\n- Instead, why not declare the error handler like you declare the templating engine (i.e. pug, handlebars) and specifically specify _one error handler_ to call if there are errors. \r\n- Then, when express is running each bit of middleware, when it sees the error variable isn't null, why doesn't it just fire the error off to the single error handler I implicitly defined instead? \r\n\r\nAn example of where the error-handler-at-the-end approach won't work properly is if I use someone else's middleware, and in some part of their routines, they don't call `next` and instead call `res.send()` and prevent the middleware at the end from getting the error.\r\n\r\n```js\r\nvar friendly_middleware = (err,req,res,next) => { if(err) { next(err); } }\r\nvar beelzebub_middleware = (err,req,res,next) => { if(err) { res.status(400).send(err);} };\r\nvar disappointed_error_handler = (err,req,res,next) => { res.status(400).send(\"I shouldn't even happen!\"); }\r\n\r\napp.use(friendly_middleware); \/\/ I use next()!\r\napp.use(beelzebub_middleware); \/\/ I don't use next()\r\napp.use(disappointed_error_handler); \/\/ I don't get this error\r\n```\r\n\r\nAs a solution to this, what I envisage is instead using this kind of syntax instead: \r\n\r\n```js\r\nconst my_other_error_handler = require(\".\/other_specific_error_handler\");\r\nvar global_error_handler = (err) => { \r\n  if(err instanceof MySpecificError)\r\n    my_other_error_handler(err);\r\n}\r\napp.use(\"global_error_handler\",global_error_handler);\r\n```\r\n\r\nThen express would function in this way to process the error as it runs each middleware defined using `app.use()`\r\n\r\n```js\r\n\/\/ Pseudocode for express looping through middleware registered to app (i.e. app.use(x), app.use(y) = [x,y])\r\nvar http_request = http.http_request_from_http_server;\r\nvar global_error_handler = app.global_error_handler_defined_above;\r\nvar list_of_middleware = app.middleware_list;\r\nvar dont_bother_continuing = false;\r\n_.each(list_of_middleware,(individual_middleware) {\r\n    if(!dont_bother_continuing) {\r\n       var middleware_output = individual_middleware(http_request);\r\n       if(middleware_output.error != null) {`\r\n           global_error_handler(middleware_output.error);\r\n           dont_bother_continuing = true;\r\n       }\r\n     } \r\n});\r\n```\r\n\r\nSo then, in the example above:\r\n1. friendly_middleware passes an error with `next(err)`\r\n2. Express sees `err` was either set or error was thrown.\r\n3. Express looks at the `global_error_handler` function defined with my hypothetical `app.use(\"error_handler\",global_error_handler);` and passes the `err` variable to it.\r\n4. Express stops processing the rest of the middleware like it does as normal.\r\n\r\nI hope I have made some sense. If not, I'll work on submitting a patch to show what I mean :heart: ","Yea, gotcha.  I'm not sure how to really go about implementing such a feature. If you would like to see it implemented, please make a pull request :)","The biggest thing I'm stuck on is statements like\r\n\r\n> An example of where the error-handler-at-the-end approach won't work properly is if I use someone else's middleware, and in some part of their routines, they don't call next and instead call res.send() and prevent the middleware at the end from getting the error.\r\n\r\nWhixh is really confusing to me, because middleware are never invoked once an error occurs, so other middleware have no way to actually stop the propogation of an error.\r\n\r\nMaybe the trip up is just on terminology. In Express.js there are three main types of things:\r\n\r\n1. A middleware.  These are like body-parser and helmet. They have no ability to stop error propogation since they are not invoked when an error occurs.  Their function signature is `(req, res, next)`.\r\n2. A handler. These also have no ability to stop error propogation,  since they are not invoked when an error occurs. These are the function you write with the logix the responds to the request, for example by calling res.json, res.send, res.write, res.end, etc.\r\n3. And finally error handlers. These are typically also funxtions you write, though there are a very very tiny number of them on npm, for example the errorhandler module. These will write out a response to the request detailing the error. Since they form their own stack,  you can compose them such that your JSON API routes can send back a JSON API formatted error and your HTML pages can send back an HTML error, keeping that logic separate, especially useful when you decompose an app using routers.\r\n\r\nNow, I do see in your most recent ezample of your issue that you are showing error handlers stacked on each other,  not middleware. This may be why I was so confuses before. Of course if an error handler doesn't call next, that is the signal that it's responded to the request. But at the same time, these are not published to npm, so the only error handlers that wpuld normally exist in your app would be entirely your own code, so I'm confused why you can't just change them.","@dougwilson Ah okay, thanks for the clarification - my apologies if I muddied the waters. Yep, I understand what you mean -- and I am not referring to any custom error handlers from NPM, I just wrote that as a hasty example as I'm in the middle of the workday at the moment :smiley: \r\n\r\nIf a middleware does `res.send()` on the error does that not stop the propogation of the error to the error handler? ","> If a middleware does res.send() on the error does that not stop the propogation of the error to the error handler\r\n\r\nIt does, but it would have also stopped the propogation to even a global error handler set at the top, because Express.js would have no way to know an error ever occurred if it was not thrown or not passed to `next()`. How would Express.js know an error occurred at all in that case?\r\n\r\nFor example, here is how I'm interpreting your question:\r\n```js\r\napp.use(function (req, res, next) {\r\n  \/\/ this is a middleware\r\n  \/\/ it does things like looks up a user\r\n  \/\/which takes 500ms from a db call\r\n  setTimeout(function () {\r\n    \/\/ well, the user wasn't found, but for some reason\r\n    \/\/ this middleware is going to res.send() instead of proving\r\n    \/\/ the error\r\n    res.send('there is no such user :O')\r\n  }, 500)\r\n})\r\n```\r\n\r\nThe fact that `res.send()` in the middleware was called isn't want stopped the chain; it was just that nothing called `next()` indicating that the chain should not continue. Since middleware, handlers, and error handlers can do async tasks, the fact that the middleware's main body ran to completion doesn't indicate that it has completed, thus the need for the `next()` function to exist.\r\n\r\nLet me know if I'm not understanding you correctly. I am using the \"middleware\" in your question has I defined it in https:\/\/github.com\/expressjs\/express\/issues\/3367#issuecomment-316423352 just in case we are continuing to be confused on terminology, so this way we have some grounded terms to use with specific meaning behind them :) Alternatively you can use code, of course, like I did here to demonstrate how I interpreted your question.","Oh, and just a quick note since I see you added a heart to my offer to make a pull request, if you end up needing to modify anything under the `lib\/router\/` (https:\/\/github.com\/expressjs\/express\/tree\/master\/lib\/router) directory, please don't make this pull request to this repository; the contents of that are cherry-picked from the dependency backing those files https:\/\/github.com\/pillarjs\/router . If you make the changes there, they will get cherry picked back into this repository with the author data intact. This cherry picking is only an issue on the 4.x branch; the Express 5 branch doesn't have any of those files and instead directly requires the `router` module, so making the changes against the `router` module will also ensure that your changes are not dropped from Express 5.","Yep, you're interpreting what I said correctly. That is what I mean, and to use your terminology,  an error handler would not receive the error, because the `middleware` (`body-parser`,etc) or defined `handler` didn't call `next()` for it to know that there was an error to catch. \r\n\r\nHowever, say if it were practice to always throw errors in the regular JS way, rather than pass them to `next()` then it would be feasible to catch errors during express's execution of `handlers` (as you rightly corrected me on :+1: ) or `middleware`, and then in the catch logic, pass the error caught to the error handler defined in the global `app.use()` call, which would then do whatever it wanted with it. \r\n\r\nAnyway, I've forked the pillarjs\/router repo, I'll hack away on it instead of the expressjs\/express\/tree\/master\/lib\/router dir.  :+1: "],"labels":["discuss","ideas"]},{"title":"default env to production","body":"I just want to query the defaulting of env to 'development' in `app.defaultConfiguration`.\r\n\r\nIn a situation where verbose error messaging may expose sensitive information, there is a risk on information leakage from someone failing to explicitly set `NODE_ENV=production`.\r\n\r\nI'm keen to see the arguments for it being 'development', my feeling is that it should be defaulted to 'production' and then if for some reason it hasn't been explicitly set so, the risk of information leakage is mitigated. Though its entirely likely I'm just being stupid.\r\n\r\nEDIT:\r\nBecause it felt like a bit of bad manners to raise an issue without raising a PR to fix it see here: https:\/\/github.com\/expressjs\/express\/pull\/3347\r\n\r\nEDIT: On **_'view cache'_** and more\r\nHaving read through: \r\n- https:\/\/expressjs.com\/en\/advanced\/best-practice-performance.html#set-nodeenv-to-production\r\n- https:\/\/github.com\/expressjs\/express\/blob\/master\/lib\/application.js\r\n\r\nThe key performance benefit of setting `NODE_ENV=production` is that views are cached when using `app.render`. With the first link above stating an app performance boost of up to 'a factor of 3'.\r\n\r\nAgain I think there is benefit to defaulting to 'production' in this case, as by default we should want 'express' to be the most performant it can be, giving users the best possible experience straight out of the box. \r\n\r\n","comments":["Hi @maxcbc we can certainly discuss adding it to the next major version :) ! I don't 100% have insight to why the default was chosen, as this was before I was even a part of this project, but even by the time I became involved, the default was heavily engrained.\r\n\r\nIf this is changed, we'll need to find a champion to create blog posts, inform publications of the change, and get everyone to update their development workflows. In development, stacktraces \/ any helpful error message will be gone by default, but even weirder, no longer will editing your template files result in changes until the Express server is stopped and then started back up, so we should probably address what the impact to DX will be, exactly.\r\n\r\nThe biggest ask will be finding an advocate to help us change the workflows of our millions of developers, so I think we need to find someone for that, if we want to move forward.\r\n\r\nI am a \ud83d\udc4e on the change, but it's a vote from @expressjs\/express-tc , though I think it's not exactly clear on what yet to vote on since I'm not sure if you've fully evaluated the impact beyond just stacktraces. Can you flesh our your proposal a bit more, including adding the templating caching behavior change this will case and anything else across our entire ecosystem so we can better evaluate the ask?","Thanks for commenting, I really appreciate you taken the time. I'm inclined to agree with you on most points @dougwilson. This would actually be a big change, and should be a semver major sort of change if it were to happen. Particularly I agree this would be one of those things that would require a fair amount of communication with the community. I'm happy to play my part as much as I am able, but I'm not sure I have the depth of understanding to cover everything.\r\n\r\nI'm still convinced that its a change worth doing for the reasons above, and I'm not one for not changing something just because its the status quo. That being said, I think further investigation is needed, I think its worthy of looking into, and I'd be eager to hear experience\/views of how development experience may be impacted; particularly in reference to 'view cache' which is something I don't have much experience of personally.\r\n\r\nI think as to stack traces etc and usefulness to developers, again I think this is a case of requiring communication at the point of a semver major update. Longer term it would be a relatively easy thing to work into _'getting started'_ documentation, to help even the most novice of users of express get used to how 'NODE_ENV' affects different aspects of the library.","Yea, like I said, we can certainly discuss adding it to the next major version :) ! I was trying to be open above to what would be involved, including the work that would need to be done to evaluate the impact prior to making the change. It's definitely OK if you're not able to champion these, but we would need to find _someone_ before we can. There are a lot of modules \/ middleware around that are keying off the `NODE_ENV` \/ the `env` setting, so understanding what the effect of the changes will be here and determining what we need to work through is the first step before changing any code. You can see that for everything we are changing \/ removing between 4.x and 5.x we have an entire deprecation framework and lifecycle those are going through, and this should go through the same thing, including community outreach throughout the process.","May be we needs in **options** param?\r\n```javascript\r\nvar express = require('express');\r\nvar app = express({ env: process.env.NODE_ENV || 'production' });\r\n```","@RomanovRoman here is how you do that in all versions of Express:\r\n```js\r\nvar express = require('express');\r\nvar app = express().set('env', process.env.NODE_ENV || 'production');\r\n```","@dougwilson how it works for '**view cache**' in this issue?","Hi @RomanovRoman I'm sorry, I don't understand what you're asking. Can you phrase it differently?","@dougwilson the issue is about \"defaulting of env to 'development' in **app.defaultConfiguration**\", isn't it?\r\n\r\nIMHO behavior of\r\n```javascript\r\nvar app = express({ env: process.env.NODE_ENV || 'production' });\r\n```\r\ndiffers from\r\n```javascript\r\nvar app = express().set('env', process.env.NODE_ENV || 'production');\r\n```\r\nbecause [application.js#L118](https:\/\/github.com\/expressjs\/express\/blob\/master\/lib\/application.js#L118)","Hi @RomanovRoman I think I understand what you are saying now.","This issue got closed by the OP before a vote \/ discussion was able to occur. Reopening as the tracking discussion for this.","I just wanted to circle around to this hanging issue. I believe this was discussed and the general consensus was to change the default to production to prevent client stack traces by default, eventually removing the magic environment stuff. I can't find the threads yet, but just wanted to write down this as a note here."],"labels":["discuss"]},{"title":"List All Routes in express app","body":"Hi!  I've been fighting this for a bit, but I'm trying to gather a list of all of the endpoints in our express applications.  I've tried 'express-list-router' and the code below, but none give the full paths of the endpoint and the allowed methods to use them.  I've read the documentation, but can't seem to find the properties\/methods to access this information.  Thank you in advance for your time and assistance!\r\n![image](https:\/\/cloud.githubusercontent.com\/assets\/24922184\/25976587\/dd2f5a78-366a-11e7-8b7d-4d7e057cac1d.png)\r\n\r\n\r\n","comments":["It is not possible to get a fill list with the built-in router. Since paths are regular expression-based, there is no easy way in which to reverse them into a path.","Hmmm, I'm auditing a public facing application.  Tons of repos and submodules, it would be almost laughable to do it manually.  Is my only option then to catch them downstream via: `req.method` and `req.originalUrl`?","**Creative and\/or potentially crazy solutions are welcome     :)","There is no general solution that would guarantee you are not missing anything. Is it possible to share the app at all? We could at least see what kind of structure the program is using to see if it's possible at all. What you posted at first is a pretty simplistic method, and if that's not giving what you're looking for, it's hard to really understand why without seeing something.","O I think I can share my sandbox app!  (Way less code anyway.)   Two main datapoints I'm trying to capture:\r\n\r\n- All routes directly declared to the app.\r\n- All routes declared through router(s).\r\n\r\n**Sandbox:**\r\n```\r\nvar expressListRoutes   = require('express-list-routes'),\r\n    express             = require('express'),\r\n    router              = express.Router();\r\n\r\nvar app = express();\r\n \r\napp.use('\/api\/v1', router);\r\n\r\napp.get('\/', function(req, res){\r\n  res.send('hello world');\r\n});\r\n \r\nrouter.route('\/user')\r\n  .post(function(test){})\r\n  .get(function(test){})\r\n  .put(function(test){});\r\n    \r\n\/\/ expressListRoutes({ prefix: '\/api\/v1' }, 'API:', router );\r\n\r\nvar route, routes = [];\r\n\r\napp._router.stack.forEach(function(middleware){\r\n    if(middleware.route){ \/\/ routes registered directly on the app\r\n        routes.push(middleware.route);\r\n    } else if(middleware.name === 'router'){ \/\/ router middleware \r\n        middleware.handle.stack.forEach(function(handler){\r\n            route = handler.route;\r\n            route && routes.push(route);\r\n        });\r\n    }\r\n});\r\n\r\nroutes.forEach(function(temp){\r\n\tvar methods = \"\";\r\n\tfor(var method in temp.methods){\r\n\t\tmethods += method + \", \";\r\n\t}\r\n\tconsole.log(temp.path + \": \" + methods);\r\n});\r\n```\r\n**Output:**\r\n\/user: post, get, put, \r\n\/: get, \r\n**Expected Output:**\r\n\/api\/v1\/user: post, get, put, \r\n\/: get, ","Here is a very, very hacky way for that app. I can't stress how hacky this is, but here it is:\r\n```js\r\nfunction print (path, layer) {\r\n  if (layer.route) {\r\n    layer.route.stack.forEach(print.bind(null, path.concat(split(layer.route.path))))\r\n  } else if (layer.name === 'router' && layer.handle.stack) {\r\n    layer.handle.stack.forEach(print.bind(null, path.concat(split(layer.regexp))))\r\n  } else if (layer.method) {\r\n    console.log('%s \/%s',\r\n      layer.method.toUpperCase(),\r\n      path.concat(split(layer.regexp)).filter(Boolean).join('\/'))\r\n  }\r\n}\r\n\r\nfunction split (thing) {\r\n  if (typeof thing === 'string') {\r\n    return thing.split('\/')\r\n  } else if (thing.fast_slash) {\r\n    return ''\r\n  } else {\r\n    var match = thing.toString()\r\n      .replace('\\\\\/?', '')\r\n      .replace('(?=\\\\\/|$)', '$')\r\n      .match(\/^\\\/\\^((?:\\\\[.*+?^${}()|[\\]\\\\\\\/]|[^.*+?^${}()|[\\]\\\\\\\/])*)\\$\\\/\/)\r\n    return match\r\n      ? match[1].replace(\/\\\\(.)\/g, '$1').split('\/')\r\n      : '<complex:' + thing.toString() + '>'\r\n  }\r\n}\r\n\r\napp._router.stack.forEach(print.bind(null, []))\r\n```\r\n\r\nThat produces:\r\n```\r\nPOST \/api\/v1\/user\r\nGET \/api\/v1\/user\r\nPUT \/api\/v1\/user\r\nGET \/\r\n```","Hey, I'll take hacky over nothing any day .    :)\r\n\r\nI'll have to try this against our other apps and get back to you!   Thanks for looking into this so quickly!!","It's been working perfectly for our simpler projects, pretty confident it'll work for our more convoluted apps as well, but I will keep you posted.    :)\r\n\r\nI wanted to check in with you before I did it, but there's [this](http:\/\/stackoverflow.com\/questions\/14934452\/how-to-get-all-registered-routes-in-express) stackoverflow post of others who have tried to get this working, would it be ok if I posted your hacky albeit effective solution? ","It's the only I found that realy works so far ... good job","Thanks, @dougwilson! This is the only solution working. I hope the next version do not break this code :D","Same topic discussed and addressed on [StackOveflow](https:\/\/stackoverflow.com\/a\/49152014\/1750243).","I've found this package, which seems to work properly: https:\/\/github.com\/AlbertoFdzM\/express-list-endpoints !","I wrote a package to list middleware and routes mounted on an app quite a while ago: https:\/\/github.com\/ErisDS\/middleware-stack-printer\r\n\r\nMaybe its useful for someone else.","Why don't you try something like swagger using tsoa(it automatically generates a swagger.json file) which will have all the api liat including what parameters it takes.\r\nYou can also hoat the same using swagge-ui-express locally. That will act as a better documents and will always auto update if you set up your run scripts correctly.\r\n\r\nJust one note, tsoa requires Typescript.","@surendra-y - the problem I've had with swagger & friends (and tsoa looks similar) is that they all depend on some sort of non-authoritative, duplicate source of route information: annotations, jsdoc, etc. Which only works long term if you're disciplined enough where you probably don't need it in the first place. The great thing about doing it via reflection is:\r\n\r\n -  it's trivial to maintain\r\n -  it's actually helped me find really dumb copy & paste bugs (like a route\/resource was set up by copying another route wiring, and then changing the method... but not the route\/resource), because it's generated from a truly authoritative source of truth. We'll not talk about who wrote the really dumb bug (me) ;)\r\n\r\nThat said, if whatever middleware does this also spits out the result in OpenAPI format - even better!","Here's how I parsed out the express routes to a json array.\r\n\r\n`const endpoints = app._router.stack.filter(x=> x.route && x.route.path && Object.keys(x.route.methods) != 0).map(layer => ({ method :layer.route.stack[0].method.toUpperCase(), path: layer.route.path}));`\r\n\r\nResult\r\n`[{\r\n    method: \"GET\",\r\n    path: \"\/api\/example\r\n}, {...}]`","@StuAtGit, maybe this will help you?\r\n\r\nhttps:\/\/github.com\/wesleytodd\/express-openapi\/","@wesleytodd  - \ud83d\udc4d \r\nThat's a very clever solution. The kind of thing that seems obvious once you see, but as seen in this thread, not until then ;)","I use this package, which gives both terminal and web view\r\nhttps:\/\/www.npmjs.com\/package\/express-routes-catalogue\r\n","@dougwilson \r\n\r\nSeems like that there are also some parasites on the internet, who steal your idea and sell them as their own...\r\n\r\nhttps:\/\/medium.com\/@stupid_arnob\/get-all-api-path-with-method-in-a-single-api-request-f6116254ea1a","Hi if someone is still searching, I rewrote the solution of @dougwilson in Typescript and made it output an array of strings of your routes so you can do with them what you wish.\r\n\r\n```\r\nfunction getRoutesOfLayer(path: string, layer: any): string[] {\r\n    if (layer.method) {\r\n        return [layer.method.toUpperCase() + ' ' + path];\r\n    }\r\n    else if (layer.route) {\r\n        return getRoutesOfLayer(path + split(layer.route.path), layer.route.stack[0]);\r\n    }\r\n    else if (layer.name === 'router' && layer.handle.stack) {\r\n        let routes: string[] = [];\r\n\r\n        layer.handle.stack.forEach(function(stackItem: any) {\r\n            routes = routes.concat(getRoutesOfLayer(path + split(layer.regexp), stackItem));\r\n        });\r\n\r\n        return routes;\r\n    }\r\n\r\n    return [];\r\n}\r\n```\r\n\r\n```\r\nfunction split (thing: any): string {\r\n    if (typeof thing === 'string') {\r\n        return thing;\r\n    } else if (thing.fast_slash) {\r\n        return '';\r\n    } else {\r\n        var match = thing.toString()\r\n        .replace('\\\\\/?', '')\r\n        .replace('(?=\\\\\/|$)', '$')\r\n        .match(\/^\\\/\\^((?:\\\\[.*+?^${}()|[\\]\\\\\\\/]|[^.*+?^${}()|[\\]\\\\\\\/])*)\\$\\\/\/)\r\n        return match\r\n        ? match[1].replace(\/\\\\(.)\/g, '$1')\r\n        : '<complex:' + thing.toString() + '>';\r\n    }\r\n}\r\n```\r\n\r\nAnd then you can call it like this:\r\n\r\n```\r\nfunction getRoutes(app: Application): string[] {\r\n    let routes: string[] = [];\r\n\r\n    app._router.stack.forEach(function(layer: any) {\r\n        routes = routes.concat(getRoutesOfLayer('', layer));\r\n    });\r\n\r\n    return routes;\r\n}\r\n```","We are always listening \ud83d\ude00","Actually I wrote it as an middleware and in a singleton pattern. This is useful if you dont add routes on runtime, every route has only one Routehandler. So you can save the routes into a Map one time and can have a fast lookup. I used it to match the routes to the RouteHandlers and now I can lookup what route a routehandler has.","I wrote up a dependency free Typescript npm package that parses complex express apps and outputs a list of data per route and allows attaching meta-data to each route, if desired. \r\nhttps:\/\/www.npmjs.com\/package\/express-route-parser\r\nIt also handles the cases that wesley todd's open api npm package runs into on some project configurations.","@nklisch I appreciate your library very much. However, I am afraid it does not dig up to the middleware level. Take, for example, my app [available here](https:\/\/github.com\/web-needle\/sappio): I use three libraries, `swagger-stats`, `express-status-monitor` and  `swagger-jsdoc`, which inject some route, respectively `\/swagger-stats\/stats`, `\/status`  and explicitly-defined `\/swagger` route. However, it is not able to find them for a reason unknown.\r\n\r\nCould you please take a look at this abnormal behaviour?","@brunolnetto I'll take a look","@brunolnetto \r\nFor swagger ui try:\r\nrouter.use('\/swagger\"', swaggerUi.serve);\r\nrouter.get('\/swagger\", swaggerUi.setup(swaggerDocument));\r\ninstead of just one app.use() line.\r\n\r\nBut for swagger-stats, I looked into how they do their routing, and unfortunately they have a custom solution that doesn't use Expresses built-in route matching, seen here: \r\nhttps:\/\/github.com\/slanatech\/swagger-stats\/blob\/master\/lib\/swsInterface.js#L141-L149\r\n\r\nThis means it is impossible for someone to scan the Express stack to figure out these routes, as they are hidden inside custom logic, inside a middleware.\r\n","Hey y'all \u2013 to my understanding NestJS uses express for routing \u2013 how can I grab the `@Version` decorator when getting routes? FWIW I'm using URI based versioning, so the routes look something like:\r\n\r\n`\/foo\/1.0\/bar\/baz` however, when querering the router (using this is an example https:\/\/github.com\/expressjs\/express\/issues\/3308#issuecomment-300957572) \u2013 I see: `\/bar\/baz` (which is missing both the versioning prefix (`foo`) and the version number `1.0`. Any help would be greatly appreciated...","Is there anyone that renders it as an HTML file?\r\n"],"labels":["4.x","question"]},{"title":"location: back override option + tests","body":"Make option for setting back as location to override built in behavior. To redirect to page \"back\", default behavior is to use referrer or navigate to root of domain and not the intended relative path. This can be compensated for with \".\/back\" but when dealing with third party responses, you would need to test for \"back\" on every call to replace.\r\n\r\nAdded tests for location('back')","comments":["Adding the missing tests is an obvious thing to immediately merge, so I wish adding tests for the existing stuff was a separate PR from the override option so I could at least merge them while waiting for feedback on the added option. I can split them up myself, but it would cause a merge conflict on this PR if I did that.","I will split once I'm home","Actually, it looks like I can commit to your fork's branch from the new GitHub functionality, so I can split them for you if you don't get around to it :)\r\n\r\nAnyway, on the topic of the new option, I think there are a couple things that would be good to discuss with the collaborators:\r\n\r\n1. Good idea or not?\r\n2. Does this help or change the plan for the removal of the `back` magic string in 5.0?\r\n3. If good, thoughts on the current name of the option ('location back-referrer'), and if bad, what would be a suggestion?\r\n\r\nI know some people may know my thoughts on the magic back string in general, but to reiterate: I definitely don't like it because there is no way to distinguish between wanting the referring behavior vs generating a location of a literal \"back\" (I think as @WORMSS experienced).\r\n\r\nAs for adding an option for controlling the behavior in general, I'm neutral on it right now, but certainly don't see the harm. This option is currently implemented in the PR such that it will not inherit to sub apps, which is what I would expect for this setting (to be app-isolated) since you can't be sure what a sub app you're including is expecting to do.","Removed the non related back tests.\r\n\r\nThey are in their own Isusue #3292 and RP now #3293 ","> I think there are a couple things that would be good to discuss with the collaborators\r\n\r\nDo we have an open discussion around the use of magic strings already? In general, I'd love to kill them all from the codebase and just use functions instead (e.g. `res.location.back()`). This specific PR and workaround for 4.x seems reasonable too, since we can just remove the option in 5.0 when we kill the magic strings.","(for Express 5.0) `res.location.back()` is not too dissimilar to the browsers `window.history.back()` so, I guess it would make sense for the people who do both front and back end.\n\nI have not looked at the 5.0 code yet, so I didn't know `res.function.function-bolt-on` was something the API was going for.","So, was this going to be merged? I got talking to someone today about it and made me think I had already solved this. "],"labels":["ideas","4.x","pr"]},{"title":"Option to turn off built in 'back' functionality in res.location('back')","body":"I had spotted there were no tests for `res.location('back')` so I have added them.\r\n\r\nI came across this because I was trying to navigate to the relative page called 'back' and was being redirected to domain root. It was not expected. After looking at the code I spotted there was a \"special\" case for the word \"back\".","comments":["Hi @WORMSS as for the \"It was not expected\" comment, I felt like your documentation was pretty good (http:\/\/expressjs.com\/en\/4x\/api.html#res.location). How can we improve it?","Oh, by \"not expected\" I mean I was expecting the exact result I put it to come out. After seeing the code and reading the docs, I understood why it was there.. But I was using \"location\" without realising there was special case for the word \"back\". If it had been something like `:back` or `:referrer`,  something that is not a valid url safe, then I doubt I would have encountered it.","Gotcha, so you're saying that the behavior was expected to treat `back` specially from what was in the documentation, you just think it could be done differently. You're not saying that it was undocumented and that there is any improvement we can make to the docs to make it clearer that using the string `'back'` does not literally make the location `'back'`, right?\r\n\r\nThe reason I'm asking is because we can't change the behavior in 4.x, but I don't want people to not realize what is happening, so want to make sure that our documentation is sufficient such that it is not unexpected behavior.","As you have said in #3291 if you have the ability to remove the magic back code from 5.x, I would put my vote for that. You could keep the functionality, as I said above, maybe something that just isn't a common word, or something that is a valid referrer..\r\nBut no, your documentation on the use of the magic back is good.. I just hadn't read it before I stumped myself with it."],"labels":["4.x","tests"]},{"title":"Moves compileQueryParser to separate module","body":"Moved this functionality to a separate module so I could use it in my other package.  It appears no tests were originally written, so I added some in the module.  If you would like we can move this repo under pillar, or here, just let me know.\r\n\r\nhttps:\/\/github.com\/wesleytodd\/compile-query-parser","comments":["Probably should hard-pin the `qs` version within that module to meet the typical version range policy (pin exact versions, but if the module is part of Express, it may float patches with `~`).","I updated that in the module, and assuming it will move into the express family somewhere I used the tilde in here.","Anything blocking us from moving forward?  Do we need to move the repo or can it live where it is?"],"labels":["ideas","5.x","pr"]},{"title":"Add middleware benchmarks","body":"As already discussed at https:\/\/github.com\/expressjs\/express\/issues\/3211 I'm making a PR to add some benchmarks.\r\n\r\nImho, the most important thing to enlight is about the changing of request and response prototypes  (twice slower). But there're no possible to improve performance without breaking compatiblity.","comments":[],"labels":["pr","needs rebase"]},{"title":"Settings functionality moved out of core","body":"This is based on what was discussed at the last TC meeting for a good \"first step\" in abstracting out parts of core than can be shared.  The changes here are rather far reaching, but they basically mean the following:\r\n\r\n```\r\napp.set()\r\napp.get()\r\napp.enable()\r\napp.disable()\r\napp.enabled()\r\napp.disabled()\r\n```\r\n\r\nBecome:\r\n\r\n```\r\napp.settings.set()\r\napp.settings.get()\r\napp.settings.enable()\r\napp.settings.disable()\r\napp.settings.enabled()\r\napp.settings.disabled()\r\n```\r\n\r\nI think there are a bunch of points for discussion here:\r\n\r\n1. I opted to move it all under `.settings`, mainly to resolves the weird behavior from `app.get` being multi purpose.  But it could also be done so that the methods remain the same, either via mixing them in, or explicitly calling into `.settings` as getter methods.\r\n2. If we are already breaking the api, should we also add other changes, like removing the `enabled`\/`disabled` shorthands to minimize the api surface.\r\n3. Do people like the \"setters\" type functionality?  It is used to keep the features like setting `etag` but it actually setting `etag fn`.  Not sure, but it seems to me we could get rid of the whole thing but just using `etag` directly.\r\n\r\nEDIT: standardjs compliance pending :) \r\n**Dont feel like doing all that busy work tonight if the whole PR might get shut down...","comments":["Is there something I can do on this PR to move it forward?","Love it. There hasn't been any objections or anything, and finally gets rid of those annoying overloads like `.get(setting)`. I plan to land this right in the next 5.x release coming here (which will also include the new Promise-supporting router).","Awesome!!  I will go through and do a rebase\/cleanup pass asap.","Sweet, that will help a lot \ud83d\udc4d I had noticed two things, mainly, from looking through it at a high level: (1) cap the dependency to `~` instead of `^` (or pin) and (2) I was curious to see if there would be some way to back port this into 4.x such that there could be a deprecation cycle on the removed APIs (but I don't know if that's possible -- and it's not a requirement to land something breaking into 5.x, of course).","Yeah I can cap that for sure.  For the back porting, I think we can do it, just need to call into the new stuff and log the deprecation in the old.  I will take a look at that as well.","Nice. ","Ok, so the changes in `4.x` are so different that it will actually be better for me to make two separate PR's.  Other than the examples, basically every line changed is a conflict.  I will open up a new PR with the 4.x compatible changes and then see what is required to the 5.0 support.  But unfortunately it has eaten up all of my time today to be sure that is the best way to move forward.  Maybe next weekend :)","Ok, #3714 is open.  It ports all these changes to 4.0 and provides deprecation warnings.  Once we figure out the points I brought up over there I will finalize the changes in this PR for the 5.0 branch.","What is the status of this PR?","@wesleytodd did this die off? Looking at https:\/\/github.com\/expressjs\/express\/pull\/2237 it seems sensitive to ask about 5.0 considering it is locked. Considering that PR was created on 14 Jul 2014 I think it is a fair question (although I do know these topics are sensitive to maintainers, but 7 years is a long time)."],"labels":["enhancement","5.x","pr"]},{"title":"Call callback once on listen error","body":"This is a redo of #2623.  Probably didn't need a new PR, but I took a new direction by using the `once` module, and only binding to the error event.  I think this is slightly more elegant than the previous PR.  As discussed, this is a breaking change, so can only land in a 5.x branch.","comments":["For some reason the test is not happy on Node.js 0.10. That may not actually be a problem with Express 5.0 target, just wanted to call out why the CI failed on this one (for now).","Oh, this is a change since 0.12, but if the server fails to start, calling `close` will error.  The test introduces this case.  In this case I can just not call close I think.  Updated.","Anything blocking this from merging?"],"labels":["enhancement","5.x","pr"]},{"title":"Moves req\/res out of the repo","body":"This is VERY MUCH A WIP, but the idea is that we move the code as is out of the repo.  I did it by publishing temp packages under my personal namespace, but those repo's could be moved into @pillarjs as is, and then we would just update this.\r\n\r\nAlso, I based this off the other branch I opened today (#3213) because that included breaking integration changes.  I can easily change this to not include those if we decide not to land that PR.","comments":["Not sure if this helps address #2432, but figured I would link it up here in case it does."],"labels":["5.x","pr"]},{"title":"Remove direct http dependency","body":"I think this might resolve the issues brought up in #2812 and #3206, and also some of what we talked about at the most recent TC meeting for compat in the browser.  The goal here is that you can do:\r\n\r\n```javascript\r\nvar express = require('express')\r\nvar uws = require('uws')\r\nvar app = express({\r\n  reqProto: uws.http.getRequestPrototype(),\r\n  resProto: uws.http.getResponsePrototype(),\r\n  createServer: uws.http.createServer\r\n})\r\n```\r\n\r\nIn the long run, I think this is also what I need for my Nighthawk project as well, so IMO it is a good way forward.  But let me know your thoughts! \r\n\r\nCC: @dougwilson, @alexhultman, @blakeembrey","comments":["I've removed uws.http.getRequestPrototype() and uws.http.getResponsePrototype() and instead I provide var app = uws.http.getExpressApp(express) so this won't work anymore","Notes: \r\n\r\n1. I tried to apply the \"standard\" style where I made changes, but it results in mixed files, so I can change that back if we want.\r\n2. I applied the `setPrototypeOf` module where we were using `__proto__` like we did in the router, this is also something we could discuss, especially if we drop support for older nodes and browsers.\r\n3. This does nothing to help the larger issue of NOT modifying the prototypes of all req\/res, but I think that moving forward with this should not change anything we do there.\r\n4. Also, not sure if this helps or hinders the efforts for http2 support, so please comment to that regard, thanks!","@alexhultman Hmm, well it seems to me to be a better api for your project to not have to know about express, and for express to just support arbitrary extensions like in this PR.  With `getExpressApp` you are now relying on express supporting what you use, but inverting the responsibility here removes that need.","Lol, tests that hit google.com and rely on a specific html response? Should I fix these brittle tests? Remove them? Or ignore the failures for this PR?","I'll add them back then.","@alexhultman You might want to wait until we get some feedback from the greater @expressjs team and community, the above is merely my opinion :)","Too late I already added them again","The test failures are just from a conflict with 2f8ac6726fa20ab5b4a05c112c886752868ac8ce in which the test is expecting the same code names from the `http` Node.js module but this moved them to use the `statuses` module. I think the change to use `statuses` could probably be extracted to a PR (maybe even against 4.x?).","Updated to move the status stuff into a separate PR, but left the commit in here just so it is clear the intent.  Now that I look I see you did say against 4, so I will update that.\r\n\r\nOne other thing we should have open for discussion is the idea of passing options to `createApplication`.  Doug mentioned that the current way was a preference of @tj, but that we could bring it up for discussion again.  My thoughts are that offering these kind of options while creating the application is nice.  There is also no reason we could not offer both api's, but that increases the test and maintenance surface.  Also, there are some types of settings that should not be changed after startup, because middleware might rely on them working in a certain way, like query string parsing, so IMO these should not be changeable throughout the lifetime of the app like they are now.","Last comment, I think this PR might also be able to land of 4.x.  It passes all the tests, and is really just a minor point addition for the new options api.","@dougwilson Any way we can get this merged?","H @mjsalinger before merging, the CI should at least pass for the PR.","@mjsalinger Could you review those CI failures and address if needed?","I have not had a chance to look at the failures in this PR, which I think needs a bit of revision in respect to the [discussion here](https:\/\/github.com\/expressjs\/express\/issues\/3555).","what the time line on this"],"labels":["ideas","5.x","pr"]},{"title":"Issue warnings when Express used in \"unexpected\" ways","body":"Overall, I am very pleased with Express and have developed very successful API's with it. However, I decided to raise this issue, because over the last couple of months, I've run into 3 separate very hard to debug issues with different apps, which all shared the same common root causes in Express.\r\n\r\nBasically in all of the cases it boiled down to user error, and was one of two things:\r\n\r\n1) [Calling `next()` twice in the same middleware](https:\/\/github.com\/expressjs\/express\/issues\/3024) due to a forgotten\/omitted `return`.\r\n2) Ending a middleware stack prematurely with `res.end()` while there was more middleware expected to run\r\n\r\nIn each case, Express did not actually trigger an error, but the resulting behaviour of the app was very flaky and it took us a long time, literally hours, to pinpoint the problems which were in fact trivial to fix.\r\n\r\nSo my question is if it's possible to have Express \"guard\" against these kind of cases somehow and maybe depending on your configuration\/settings, have Express trigger warnings if such unexpected behaviour is registered?\r\n\r\nI realize it's probably a valid use case to have some middleware in the middle of the stack terminate the response, so it would be hard to write rules around that, but I don't think it's ever expected that the same `next` handler is called twice in the same middleware.\r\n\r\nAny thoughts on how we as developers can better guard against such issues?","comments":["> Calling next() twice in the same middleware due to a forgotten\/omitted return.\n\nWe're already accounting for this in Express 5.0\n\n> Ending a middleware stack prematurely with res.end() while there was more middleware expected to run\n\nI believe someone tried to make a PR for this at some point, but it's basically an impossible thing to ever correctly detect. If you have any thoughts along how we could implement this, that would be a greate conversation :) !\n\nThanks for your feedback, of course! We hate hard-to-debug issues as well, and this topic has come up a few times, but there has never really been any workable proposals put forward with out to actually tackle the issue, so what would help a lot is if you could put together some concrete proposals for how we can go about adding the guards, maybe even making PRs :) I know I draw a blank on these, which is why there are no guards (i.e. we don't have the guards not because we didn't think of them, but because we have yet to think of how to even create them).\n","> We're already accounting for this in Express 5.0\n\nGreat, glad to hear!\n\nI will put it on my todo list and see if I can come up with a proposal, thanks!\n"],"labels":["discuss"]},{"title":"Options for Engines","body":"This is inspired by #2982. It adds an option object to engines, and adds an option for bypassing the filesystem mapping and checks done in view.js.\n\nAlternatively, this option could be used to bypass the `if (!view.path) {` check in application.js:565, or even to assign `view.path = name` somewhere around there.\n\nEither way, I think it'd be a good idea to have options for engines. \nPut into the 5.0 branch because it's a breaking change.\n","comments":["Can you have different view engine options for different view engines? Or do all engines ends up with the same options?\n","Well, if no engine options are given, it uses app.get('view engine options') or {} as a fallback.\n\nBut I've added a parameter to app.engine which lets you pass options for a specific engine.\n","Ah. Can you describe this feature a bit more so I can understand it? We will also need to understand it in order to write up the documentation. Is there a use case for having many view engines use the same options?\n","Basically, this PR changes the following:\n- Store engines in objects instead of just storing the function. Might be handy in case any other data ever needs to be stored with it.\n- Add an options parameter to app.option that allows specifying options for the engine.\n- Add 'view engine options' setting for default engine parameter options.\n- Add the option \"noFileSystem\" to allow bypassing checks and calcs intended only for usage with filesystem engines.\n- Tests\n\nIn short, all this really does right now is add the functionality to bypass the filesystem-specific logic associated with engines, so non-filesystem engines (like ones using databases as described in the linked issue) are possible.\nThis is stored in a general \"options\" object now associated with engine instances, which can be set when using app.engine or the 'view engine options' setting. More options can thus be added trivially.\nThe refactoring from storing just the callback to storing an object is just to store the options object with it right now, but it might come in handy at some other point.\nThe default value setting probably won't see much use while 'noFileSystem' is the only option, but it'll likely be very useful once there's other options. I mainly added it for consistency and maintainability reasons - I can remove it if you prefer though.\n","@dougwilson What's the status of this PR?"],"labels":["needs tests","pr"]},{"title":"Add req.search property containing unparsed query string","body":"This is will make things simpler when building an isomorphic app which will use its own query string parser in order to make it work consistently on the server and the client.\n","comments":["I think you might be able to get what you want by just setting `query parser` to false:\n\n``` javascript\napp.set('query parser', false);\n```\n\nThen `req.query` will be the unparsed query string.  I haven't used this in a while, so I may be miss-remembering how this works, but there is a way to have express not parse the query string.\n\nAnother way to handle this, which is what I do in my isomorphic apps, is to parse the query string on the front-end like it is done on the back end.\n\nEDIT: Either way I don't think changes need to be made to Express to have better support for isomorphic apps.\n"],"labels":["ideas"]},{"title":"Rendering engine without view files","body":"Hello! I want to write an express rendering engine which uses views retrieved from a database, not the file system. I've checked this repo's issue history and done a lot of googling but I've found nothing...\n\nIt seems express _requires_ a view file to exist on disk before passing the req\/res to a rendering engine. Is there a way to prevent this behaviour?\n\nIdeally, when I invoke `res.render(name)`my rendering engine is called with `(name, options, callback)` without `\/[name].html` necessarily existing on disk.\n\nI could overwrite express' `res.render` with my own renderer. However in order to handle errors properly it seems I'd have to pass in `next` each time I called `res.render`. That seems repetitive.\n","comments":["@davglass Express' view rendering is based on the file system. There is no inherent feature to support what you are looking for.\n\nMind explaining why you want to do what you are trying to do?\n","@hacksparrow I think you meant @davidmerfield \ud83d\ude04 \n","Err yes, indeed.\n","Thank you for your response. I'm not quite sure what other information I can provide.\n\nMy question is about the decision to prevent the rendering engine from being invoked if a local template file doesn't exist. \n\nAs I understand it, the rendering engine is passed a file's path (and not its contents). The rendering engine is responsible for reading that file from disk and handling any errors it encounters.\n\nWhy not just pass the view's name directly to the rendering engine? Let the rendering engine resolve the path to the template and then retrieve its contents.\n\n_Rendering Engine Foo_ could use that view name to look up a template in a database, returning an error if the template doesn't exist. _Rendering Engine Bar_ could use that view name to look up a template on disk, returning an error if the template doesn't exist.\n\nAnyway, thank you for getting back to me. I'm sure there's a lot of context I'm missing for these decisions. Feel free to close this, I'll work something out myself.\n","Hi @davidmerfield, I don't believe @hacksparrow was saying n to you, only trying to ask for more clarification on your request. Perhaps I can provide some better context on the current views system. I think it's fair to say this views system was written prior to any of the current maintainers joined Express, and as such, none of us were actually involved with the creation & definition of this part of Express. Essentially \"it is what it is\".\n\nBUT that's absolutely not to say it cannot be different.\n\nI understand where you are coming from, but of course can also say that's just not where the Express view engine is today. I think that possibility morphing the view engine into being able to work as you describe may be a better place.\n\nSo, @davidmerfield, to jump off this discussion, would you be up for formulating a proposal on how this view system should work, how it differs from the current Express view system, and perhaps even what it would take for us to get from the current to the proposal and what kinds of impact it would have to the current view engine ecosystem and perhaps even what the upgrade paths would be?\n","> I could overwrite express'  res.render  with my own renderer. However in order to handle errors properly it seems I'd have to pass in  next  each time I called  res.render . That seems repetitive.\n\nAs for this specific, technical point, you can use the same plumbing Express uses that prevents you from passing in `next` to `res.render`: the `next` function is actually always available as `req.next`, which you can call instead of requiring a callback.\n","Maybe something to be discussed at https:\/\/github.com\/pillarjs\/discussions\/issues\/2\n","The other angle here is 404s. To my knowledge there's three ways for a matched route's handler to 404: it can call `next()` to let the following routes\/handlers try (this isn't an immediate 404, but can become one based on whether the other handlers can serve the request), or it can call `next` with an error with a `status` property with the value `404`, or it can send a 404 response itself. (Custom error handling for 404s would, I believe, be implemented in an error handler callback, which could be triggered in the event no routes match by a final always-matching route handler that just calls `next` with a 404 error.) Supposing I had an `app.findView` function to perform the same lookup that the view engine currently uses so I don't have to duplicate the view lookup logic to get in ahead of the view engine's 500 error, I could check that function and enact the 404 strategy of my choice instead of calling `response.render`. However, that doesn't solve letting the rendering engine do something other than file lookups with the view name\/path, and getting rid of the 500 error to let the rendering engine use non-filesystem resources would be just as broken by such a pre-emptive 404 check as it is by the builtin 500 error.\n\nWhatever solution is worked out here should really have the following characteristics:\n- Whatever calls `response.render` should be able to choose whether a failure to find the view is a 500 error, a call to `next()` to try more route handlers, or a 404 error.\n- The view engine should be able to choose whether the path is resolved against the filesystem or against something else, yet defer to the calling handler's choice of 500 error, `next()` or 404 error when the expected resource is missing (whatever \"missing\" means in the place where the resource is looked up).\n\nAn extra perk to such a system would be that the rendering engine also could theoretically 404 if any resources other than the named view are missing, e.g. if the view `include`s a partial and the partial is missing (analogous to how if a static HTML page links to a page that's missing that link is considered a 404 even though it's an error in the site's content).\n","While looking for `next(\"route\")` in the documentation, I noticed something in the documentation for `express.static` that led me to some further experimentation, and I've discovered that the simpler way to force a 404 and bypass the remaining routes is to pass `next` an error with the property `status` set to `404`. This means my initial strategy for handling 404s in general needs a small adjustment, but it also means I can simplify my desired ideal for how the rendering engine allows for custom 404s. I've updated my preceding comment.\n","Hi @ScottFreeCode great comments, though I'm unclear how the 404 discussion relates to having the views use something other than the file system (the topic of this issue). The means that it is likely that we'll close this issue once non-fs views are implemented, and I don't want your comments to get lost in the shuffle.\n","Hi @dougwilson; thanks! Mainly I am figuring that, if Express were to cease sending 500 errors when the view file isn't found so that rendering engines can look for stuff in places other than the filesystem, then it would be up to the rendering engine to send an error such as 404 if the file isn't found (or, if it's not using the filesystem, if whatever else it's looking for isn't matched) -- because right now the 500 error is basically a 404 (the file wasn't found) but with arguably the wrong number, and that automatic error is what's in the way of non-fs views. So, if as I expect the view engines of the future end up responsible for sending the not-found error, I'd like to not end up in a situation where every engine is making its own choices about how those errors are reported, but rather have a fairly standard way for the calling program to tell the engine whether it should send Express a 500 error as the view system does now, send Express a 404 error instead, or just call `next()`. Maybe that's better suited for discussion at wherever the plans are for view system improvement, though; or maybe it's not something Express can control anyway and just needs to be documented for developers of future rendering engines?\n","I'm still not clear on what you mean, I'm sorry. I can say yes, we give a 500, but only if you are not passing a callback to the render function to do any other behavior. We only 500 if you don't write the code to do something else...?\n","Aaah, you're right; I had forgotten about the callback argument because I initially avoided it in order to avoid having to send the rendered response myself. My bad.\n","@davidmerfield I workaround could be make and express extension that rewrite the default render behavior using a blank template that render just a single variable, once you've retrieved the database view content (You can use you preferred template engine to flat your variables on the database string that will be your template) you can render this template with \n.render('generic-template', {\n    'content': stringWithYourContent\n})\n"],"labels":["ideas"]},{"title":"Add support for overriding settings per request","body":"This commit adds `res.settings`, an object on to which properties can be defined that will override application settings within Express internals (the values returned from `app.get()` are not altered, therefore any middleware\/components that wants to respect the override would need to be updated to use `res.settings` instead of `app.get()`).\n\nAt present, this affects the following settings:\n- view\n- view engine\n- views\n- etag fn\n- json replacer\n- json spaces\n- jsonp callback name\n\nThe `res.settings` object is passed through to view rendering code by adding property `_settings` to the `options` parameter of `app.render()`.\n\nThe entry key for the view cache was changed to prepend the `views` setting to ensure the cache continues to work correctly if `views` is overridden to a different value (eg if view `'users'` was cached\nfrom `\/projdir\/views\/a` but `views` was overridden to point to `\/projdir\/views\/b` for this request, it should not retrieve the `'users'` view from the cache for `\/projdir\/views\/a`).\n\n`res.settings` sets its `__proto__` to be the `settings` property of the current application so settings read from the object will default to the application settings.\n\nAs the request progresses through routing, the `__proto__` will be updated to ensure values always defalt to the settings of the current application.\n\n---\n\nFixes #2849\n","comments":["One thing I'm not sure on is the whether a \"views\" value of \"\/a\" should be considered different to \"\/a\/\" or \"\/a\/b\/..\" etc. The PR assumes the conservative position that they are different and each would create a distinct cached view. If Express can assume these represent hierarchical file paths for all view engines, then it might make sense to canonicalise them when calculating the `cacheKey`.\n","This will need modifying to address the \"special\" options 'etag', 'query parser' and 'trust proxy'.\nSee https:\/\/github.com\/expressjs\/express\/blob\/5.0\/lib\/application.js#L357\n","Related #3536 "],"labels":["enhancement","needs rebase"]},{"title":"View composers","body":"I [posted on Stack Overflow](http:\/\/stackoverflow.com\/questions\/35612168\/automatically-provide-data-to-express-partial-views\/35612360) today with a question about whether Express provides any way to automatically have data calculated and provided to a view context, per view. Apparently not. The feature is known as a [\"view composer\" in Laravel](https:\/\/laravel.com\/docs\/5.2\/views#view-composers).\n\nThe use case would be for things like data needed in _every_ page view using a particular layout -- instead of including the same function call to get the data in every `res.render` call in every route which calls a view using that layout, and remembering to add it to new routes each time, add the data to the view composer associated with the layout view containing the widget in question. Or for a widget in a view partial used sporadically across the site which requires some database lookup or other calculation, that calculation is done in the view's composer rather than the developer having to remember which pages have the widget and which don't, and having the calculation or reference to it in all of the relevant route files. And remembering to remove that from the view context if the widget is removed.\n\nIt's also nice in the case where the views and the business logic are written by different people, like when the designer is the front end developer. The designer may decide to add or remove such a widget at some point, and now the relevant data is calculated and available, or no longer calculated when no longer needed, without the route having to be edited.\n\nI'm wondering if this is a feature others would be interested in, and how feasible it might be. Since there are myriad view engines for Express, and presumably they all handle partials and layouts in different ways, I expect this would work as a pre-render callback which is registered through Express.\n\nThat is, the developer writes something like:\n\n``` js\napp.set('view engine', 'twig');\napp.set('view composer', function (view, context) {\n  \/\/ Whatever logic the developer wants, given the view name\n  \/\/ (or filename\/path?), adding to or transforming the context\n  \/\/ such as this trivial example...\n  switch (view) {\n    case 'layout':\n      context.loggedIn = auth.isUserLoggedIn();\n      break;\n    case 'widgets\/date':\n      context.date = new Date();\n      break;\n  }\n});\n```\n\nThis callback would then be called (at the responsibility of the view engine, presumably) at some point before each view file is rendered. The context can therefore be added to, with whatever data the view needs.\n\nObviously with suitable logic the developer could break these out into separate files to keep things organized.\n\nOr alternatively there could be a standard for an event fired at an equivalent suitable time, and with similar arguments, which could be listened for by the developer.\n\nAny thoughts?\n","comments":["Typically in the express ecosystem you wouldn't handle this via a view level condition, but by creating a middleware that adds the needed data to res.locals (which the view would receive) and including that middleware in the routes that need it.\n","Well that's exactly what I'd like to avoid. I don't want to have to keep track of which routes lead to views which (possibly many includes down the chain) include a particular partial.\n\nI don't see it as a view level condition as such. It would add the possibility for logic to run as a direct result of particular views being included. It'd be more efficient than running this logic on all routes, and easier than keeping track of which routes it's necessary for.\n\nIs what I suggest against the express way of doing things, in some way?\n","Not necessarily, no.  However I believe the plan is to actually reduce the footprint of Express' view engine and possibly even remove it in the future (someone else can chime in if that's wrong).  What you're proposing would probably be better handled via a third party middleware that overrides `response.render()`\n","I think what @ChiperSoft is talking about is this: https:\/\/github.com\/pillarjs\/discussions\/issues\/2\n\nI agree that overriding `response.render()` is the probably best approach here.  You can do literally exactly what you are doing in the above code example with a third-party module.  Here is a quick example:\n\n``` javascript\napp.use(function (req, res, next) {\n  var _oldRender = res.render;\n  res.render = function (view, locals, cb) {\n    switch (view) {\n      case 'layout':\n        locals.loggedIn = auth.isUserLoggedIn();\n        break;\n      case 'widgets\/date':\n        locals.date = new Date();\n        break;\n    }\n    return _oldRender(view, locals, cb);\n  };\n  next();\n});\n```\n\nWould that solve your issue?\n\nEDIT: code fixes\n","@wesleytodd: I'm trying out your code, but it's erroring.\n\nAs is, I get an error `TypeError: Cannot read property 'req' of undefined` at node_modules\/express\/lib\/response.js:939:17, which is the second line in this snippet:\n\n``` js\nres.render = function render(view, options, callback) {\n  var app = this.req.app;\n```\n\nI tried changing the `var _oldRender = res.render;` line to `var _oldRender = res.render.bind(this);` and now I get `TypeError: Cannot read property 'app' of undefined` at the same line of response.js.\n","Never mind; what we wanted was `.bind(res)`. Evaluating now...\n","Not sure what your `this` context is, but in the example above I dont think*\\* you need to bind anything.  It has been a while since I have actually used this in an app, so keep in mind that I just wrote that example off the cuff, so you might need to modify it a bit to do what you really want.  :)\n","oops, just saw your other response, and yeah, I see what is happening.  Your change is correct.\n","I'm afraid this doesn't do what I want.\n\nI've modified it to just print out the view names as they are rendered. In one particular case it is printing `login`, since that is the page being rendered, but then prints nothing else: no partial names, no layout name. Obviously the render method of the `res` object isn't called again for each partial and for the parent layout. I'm not sure if this would be any different for other templating engines.\n","If you want the stuff that Laravel provides I think you might need to look to another view engine.  I think there was another issue about something similar to this recently, but I am having trouble finding it.  I believe that handlebars can do this...\n","I'm aware that view engines would have to provide some support for a feature like this. My main point in this thread is that it would be nice to have a standard for this which the view engines which want to support it could then follow.\n","My guess would be that this is considered out of the scope of Express.  Especially with the conversation happening in the pillarjs org about abstracting the whole view layer out of express core, but someone with more knowledge is welcome to come correct me :)\n","I agree with @wesleytodd, this is better discussed at https:\/\/github.com\/pillarjs\/discussions\/issues\/2. Might be a good feature to have in a future version of the view system.\n"],"labels":["ideas"]},{"title":"Define error-handling middleware functions explicitly (without arity detection)","body":"I propose adding an explicit `app.error` method for defining error-handling middleware functions:\n\n``` js\napp.error(function(err, req, res, next) {\n  res.status(500).send('Something broke!');\n});\n```\n\nInstead of:\n\n``` js\napp.use(function(err, req, res, next) {\n  res.status(500).send('Something broke!');\n});\n```\n\nIt's so easy to forget the `next` argument when it's not being used in the body of the function, and that changes the whole meaning of the middleware. `express` is one of the only packages that has this pattern. Others that used this pattern in the past (i.e. `superagent`) have since removed it.\n\nFurthermore, this clashes with popular linting rules like ESLint's [`no-unused-vars` rule](http:\/\/eslint.org\/docs\/2.0.0\/rules\/no-unused-vars) which enforce that all named arguments must be used in the function body. Users who see this rule and remove the un-unsed `next` parameter will be unwittingly changing the behavior of their program.\n\nNo one expects removing an unused parameter to change the behavior of a program.\n\n``` js\napp.use(function(err, req, res, next \/* <-- unused, guess I'll remove this... *\/) {\n  res.status(500).send('Something broke!');\n});\n```\n\nThe four argument middleware convention should be deprecated in favor of `app.error`, but support for it could remain for a long time, or even indefinitely. I just want to be able to recommend that folks use `app.error` going forward.\n","comments":["This, this this!  I have thought this for a very long time.  The implicit behavior of the error handlers is confusing to beginners and advanced users alike.  I would support making this to 5.0 and explicitly deprecating the old way, for future removal.  And possibly even adding as a new feature in 4.0 as a point release.  Thanks @feross for bringing this up.\n","I think this is probably a Good Idea\u2122.\n\nMaybe we should do some assessment of how much `app.use(function(err, req, res, next) {})` is used in the wild and see how viable deprecation would be for 5.0?\n","My guess is that since it is the only way to handle errors it is used in EVERY express app :)  Right?\r\n\r\nI know for sure that I use it in all of my apps.\r\n","It would have to be changed in the `errorHandler` middleware as well. If deprecated, new versions of the middleware would not work with Express 4. There may be some other modules as well.\n","Do you have a link to the code that you are saying would need to change?\n","https:\/\/github.com\/expressjs\/errorhandler\/blob\/master\/index.js#L83\n\nThis is just an example. There is going to be other third-party modules that are going to have to be changed as well, and I'm not sure if it's possible to handle carefully.\n","This looks like a nice idea. The implicit error handler behaviour is one of the more surprising parts of the api imo.\n","The interface looks lovely. I am assuming the extended example looks something like this:\n\n```\napp.error(function(err, req, res, next) {\n  if (err.code === 404) res.status(err.code).render('404');\n  else res.status(err.code).send(err.string);\n});\n```\n","Major :+1: to this - my linter complains about the unused parameter all the time even though I can't remove it.\n","@billinghamj I use `\/\/ es-lint-disable` a bunch for this, but I think you should be able to do something like `\/\/ eslint no-unused-vars: [2, { \"args\": \"none\" }]` to specifically do just that one rule.  I just hammer it with a full disable because I cannot remember that long argument line :)\n","This API is really nice :+1: \n","Nice option,\nThere is another option,\n\n```\n\/* error parameter will be at end. To maintain standards*\/\napp.use(function(req, res, next, err) { \n  res.status(500).send('Something broke!');\n});\n```\n\nAnother one option. Using chaining to handle error. This will give power to handle error at all levels.\n\n```\napp.get('\/',function(req, res, next) { \n  res.status(500).send('Something broke!');\n}).error(function(err){\n    \/* Error Handler*\/\n});\n```\n","This is a neat idea, but it would have to be a feature because this is a **gigantic** breaking change. There are a lot of Express dependents out there and this breaks all of them, no exceptions.\n\nPersonally, I don't think deprecation is even appropriate.\n","There's no reason not to continue supporting the old method, but just outputting a warning to the console explaining what the new way is.\n\nThe old way can then be removed in the next major version, or perhaps the one after.\n","> There's no reason not to continue supporting the old method, but just outputting a warning to the console explaining what the new way is.\n\nThere absolutely is. How does `app.error` provide a method to only handle errors for specific routes? Specific methods? In the middle of a bunch of handlers? Specifically part of just a single `Route`? The currently proposed `app.error` looks good, but it does not capture how versatile the current error-handling possibilities actually are, only capturing the very basic global handler case.\n","Imo, it would be best not to change the behavior of error handlers at the same time as moving away from the arity detection. If they are independent changes, and the removal of the arity detection makes no difference to the functional behavior, there isn't much to worry about from what I can see.\n\nWhy would `.error` be different than any other kind of middleware? (Other than when it is triggered.)\n","@billinghamj, error handlers can be used in more than just `app.use`.\n","Regardless to various things to work out, what I hear loud and clear: Express should not use argument arity to differentiate between error and non-error handlers, and I 100% agree.\n","+1 for this. I've stumbled on this so many times, because `jshint` always complains about the unused `next` parameter.\n\nCurrent workaround to stop jshint from complaining in middleware that doesn't use next is (without turning off the jshint flag that is):\n\n``` js\nfunction(error, req, res, next) {\n  next = next || null;\n  \/\/do stuff\n}\n```\n\nBut that's just... meh\n","Its been said a lot already but to add I faced  this multiple times also with eslint, reverted to using:\r\n\/* eslint-disable no-unused-vars *\/","If anyone is interested, I opened a PR in the `router` package for this idea.  Would appreciate any feedback.  https:\/\/github.com\/pillarjs\/router\/pull\/59","This issue can be solved if a new approach is devised that allows express to differentiate between error and non-error handlers. For example a property `fn.isExpressErrorHandler` can be assigned and checked. Or a wrapper object `{isErrorHandler: true, fn: handler}` can be used to take place of a handler.\r\n\r\n\r\n### User-facing API\r\nUsers creates an error handler by calling `express.createErrorHandler(fn)`:\r\n```javascript\r\nconst errorHandler = (err, req, res, next) => {...}\r\n\r\napp.use(foo, [bar, express.createErrorHandler(errorHandler)])\r\n\r\n```\r\n\r\n### Implementation\r\n\r\nApproach 1: Assign and check `handler.isExpressErrorHandler`\r\n```javascript\r\nexpress.isErrorHandler = (fn) => {\r\n  return Boolean(fn.isExpressErrorHandler);\r\n}\r\n\r\n\/\/ assign the property `isExpressErrorHandler = true`\r\nexpress.createErrorHandler = (fn) => {\r\n  const clonedFn = fn.bind({})\r\n  clonedFn.isExpressErrorHandler = true;\r\n  return clonedFn;\r\n}\r\n\r\n```\r\n\r\nApproach 2: Assign and check a wrapper object\r\n```javascript\r\n\r\nexpress.createErrorHandler = (fn) => {\r\n  return {\r\n    isExpressErrorHandler: true,\r\n    handler: fn,\r\n  }\r\n}\r\n\r\nexpress.isErrorHandler = (handler) => {\r\n  return Boolean(handler.isExpressErrorHandler);\r\n}\r\n```","@golopot, can you check out the open PR for this?  https:\/\/github.com\/pillarjs\/router\/pull\/59\r\n\r\nYour thoughts would be appreciated there, thanks!"],"labels":["discuss","enhancement","ideas"]},{"title":"discuss commit guidelines","body":"We should probably discuss how we want commit styling and signoff.\n\ni.e. No-one in node core commits without review, but I am not 100% sure that is necessary here.\n\nExample of a node core commit:\n\n```\ndoc: say hello in under 50 chars\n\ndescription in under 72 chars\/line\n\nFixes: <full url>\nPR-URL: <full url>\nReviewed-By: Name <email@example.com>\n```\n\ncc @expressjs\/express \n","comments":["Also note there are existing conventions of `subsystem: message` and not using the \"merge PR\" button. Like node core without some of the additional metadata.\n","I think sign off by at least one other collaborator is a good practice. Aside from helping to ensure stability, it helps awareness of changes going. It can, perhaps be a bit less formal, however. Perhaps: nothing is committed without a PR and there should be sign off from another collaborator but it can be landed after 24 hours (assumed sign off).\n","I like the practice of getting an \"LGTM\" on code changes.\nIt would be good to get the process of landing commits and making releases documented.\n\nI'm happy to make a start on a releases.md. I might need a bit of help with filling in the details though!\n","@tunniclm currently most releases are dictated by the dependancies, and that will probably become even more the case over time.\n\nDoing a weekly check if we should do a release when there has not been a bug-fix release seems to be the best way to document what has roughly been going on into a slghtly more structured manner.\n\nI would like @dougwilson to chime in with thoughts if he is around though.\n","@Fishrock123 I've had a stab at writing a release document and would appreciate any comments to hammer it into shape:  #2890\n","I think that makes sense. Should every single dependency or dev dependency update be a pull request in general? I also don't think 24 hours is long enough at this time, since we're still not very coordinated. I would recommend at minimum 72 hours, if not even longer, to give time to see the commit, especially if the noticing of a commit is going to be left up to GitHub notifications, which have been unreliable for me at times, where I don't always get every one of them and have to open an issue with GitHub to get it resolved.\n","I also think giving a minimum of 72 hours also gives time for non-collaborators to give input as well.\n","72 works.\n\n\/aside: I too have noticed that the GH notifications are rather delayed lately, especially via email. I'd been wondering if it was just me...\n","It seems like we need a collaborators guide document to cover: how to decide if a change belongs in core express, version\/branch applicability\/back-compatibility concerns, providing feedback on a pull request, landing commits.\n\nIf the commit message is ultimately written\/rewritten by a collaborator (rather than the contributor), then those guidelines can go in the collaborators guide too. Otherwise, they need to be in the Contributing.md document. (Or perhaps it's useful in both, regardless).\n\nSo I'm proposing to:\n1. Produce a skeleton collaborators guide pull request if that sounds good.\n2. Add @Fishrock123 's guidelines into the Contributing.md if that's where it belongs, and the format in the original post is agreed.\n\nI'm happy to volunteer for both of these tasks if people agree they are the correct course of action.\n","There's already a start to an expanded contribution guide in the governance PR I opened (I don't have the number handy). We can use that as a base to iterate from. If you'd like, feel free to open a PR against that dev branch.\n","I'll second the need for a collaborators guide.  I refer to the Node.js one every time I land a commit: https:\/\/github.com\/nodejs\/node\/blob\/master\/COLLABORATOR_GUIDE.md#landing-pull-requests\n","Hmmmm, I think dependancies can be bumped without review unless they are minor \/ major? i.e. if the change no code and are not a Major. PRs are still nice to point to in case something goes wrong though.\n","> Hmmmm, I think dependancies can be bumped without review unless they are minor \/ major? i.e. if the change no code and are not a Major. PRs are still nice to point to in case something goes wrong though.\n\nIn projects where I'm using greenkeeper I've noticed that \"if the travis tests pass\" is usually enough indication that we can take any minor bump.\n","I'm good with that approach. Having the PR just makes sense for keeping\ntrack but if CI is green then landing patch or minor dep bumps without\nreview should be fine. I'd still maybe give it a day tho, just to be\nconservative.\nOn Feb 16, 2016 5:23 PM, \"Mikeal Rogers\" notifications@github.com wrote:\n\n> Hmmmm, I think dependancies can be bumped without review unless they are\n> minor \/ major? i.e. if the change no code and are not a Major. PRs are\n> still nice to point to in case something goes wrong though.\n> \n> In projects where I'm using greenkeeper I've noticed that \"if the travis\n> tests pass\" is usually enough indication that we can take any minor bump.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/expressjs\/express\/issues\/2888#issuecomment-184963309.\n","Would it help to _start_ with [this](https:\/\/github.com\/nodejs\/TSC\/blob\/master\/BasePolicies\/CONTRIBUTING.md) and then propose modifications and extensions to it for express? \n\nStarting with the Node.js Collaborator guide seems like overkill as it's half LTS.\n","@mikeal I think that is already at https:\/\/github.com\/expressjs\/express\/pull\/2871?\n\nI was more talking about the commits themselves and metadata etc\n","@Fishrock123 oh wow, totally missed that PR, I'll stay out now :)\n\nBTW, that PR isn't using the new Base Contribution Policy but I'll followup there.\n","Yeah that new base policy hadn't existed yet ;)\n"],"labels":["discuss","meta"]},{"title":"Support for auto-generated Accept-Patch header","body":"The auto-generated `OPTIONS` response works well, but it there currently isn't any option that you can set to include [Accept-Patch](http:\/\/tools.ietf.org\/html\/rfc5789#section-3.1) for the media type(s) that your API's `PATCH` request accepts.\n\nCreating a middleware function like this doesn't work because the middleware executes before the auto-generated `OPTIONS` response:\n\n``` javascript\nlet acceptPatch = function(req, res, next) {\n  if (\/PATCH\/.test(req.get('Allow')))\n    res.set('Accept-Patch', 'application\/json')\n  next()\n}\nrouter.use(acceptPatch) \/\/ won't work because req.get('Allow') hasn't been auto-generated yet\n```\n","comments":["@Risto-Stevcev Could you write something like this (**EDIT**: you can't):\n\n``` js\nlet allowPatch = function(req, res, next) {\n  if (router.methods.patch)\n    res.set('Allow-Patch', 'application\/json')\n  next()\n}\nrouter.use(allowPatch)\n```\n\nI'm not sure whether `methods` is part of the public API, but it looks to be accessible.\n\nIt feels like a better API would allow you to both define middleware (for very general or very dynamic situations) but also specify something directly on the route, like:\n\n``` js\nrouter.patch('\/some-resource', function(req, res, next) {\n...\n}, 'application\/json');\n\nrouter.patch('\/some-resource', function(req, res, next) {\n...\n}, ['application\/json', 'application\/example']);\n\nrouter.patch('\/some-resource', function(req, res, next) {\n...\n}, function(...) {\n...\n});\n```\n\nI should mention, I haven't thought through the feasibility of those ideas. Jut thinking in \"nice api\" mode righ tnow.\n","`router.methods` doesn't seem to be accessible for me (using express 4.13.3), but I'm also weary of hacking using non-public methods because the code is for a web app company.\n","@Risto-Stevcev Apologies, my mistake then. I didn't have a chance to go in and check it for real, only by inspection.\n","@Risto-Stevcev I realised my mistake: `methods` is defined on a `route` not the `Router`. So the problem you'll have with middleware (either app or router middleware) is that it doesn't know yet which route the request is going to resolve to.\n","OK, this seems to work:\n\n``` js\nvar express = require('express');\nvar app = express();\n\nvar router = express.Router();\nrouter.patch('*', function(req, res, next) {\n  res.set('Allow-Patch', 'application\/json');\n  next();\n});\n\nrouter.get('\/a', function(req, res, next) { res.write('{}'); res.end(); });\nrouter.patch('\/a', function(req, res, next) { res.write('{}'); res.end(); });\nrouter.patch('\/b', function(req, res, next) { res.write('{}'); res.end(); });\n\napp.use('\/', router);\n\napp.listen(3000);\n```\n\nHeader not set for: `GET \/a`\nHeader set for: `PATCH \/a` and `PATCH \/b`\n","@tunniclm That doesn't work either, because it affects the `OPTIONS` request and falsely advertises that `PATCH` is available for URIs that don't support it. For example, `HTTP OPTIONS: \/books\/` has only `GET`, `HEAD`, and `POST` methods for a RESTful API, but it will wrongly advertise that `PATCH` is available for a collection of resources. It would work if the route only served resources that support `PATCH` such as `\/books\/:id`, `\/authors\/:id`, etc...\n\nSomething needs to change with how express does this, because there needs to be support from the library end for this.\n","@Risto-Stevcev Darn, yes, you're right.\n\nSo, you totally can already do something like the api I mentioned before. But that wouldn't be automatic like you wanted.\n\n``` js\nfunction allow_patch(type) {\n  return function(req, res, next) {\n    res.set('Allow-Patch', type);\n    next();\n  }\n}\n\nrouter.get('\/a', function(req, res, next) { res.write('{}'); res.end(); });\nrouter.patch('\/a', allow_patch('application\/json'), function(req, res, next) { res.write('{}'); res.end(); });\nrouter.patch('\/b', allow_patch('application\/json'), function(req, res, next) { res.write('{}'); res.end(); });\n```\n\nMaybe with #2828 you could do something like:\n\n``` js\nrouter.with(function(req, res, next) {\n  if (\/PATCH\/.test(req.get('Allow')))\n    res.set('Allow-Patch', 'application\/json')\n  next()\n}\n```\n\n...assuming these `with()` handlers run late enough.\n","@tunniclm \nMy reference implementation for that feature request basically prepends the `.with()` middleware to a route's list of middleware when the route gets created.  In essence it should do exactly the same thing as your above example (the whole reason for it is to avoid having to prepend `allow_patch(...)` to each route manually).  The one caveat is that it affects every route in the router, but you explicitly test for 'Allow' so I think your second example would work just fine.\n","@demalus\nIf the proposed `.with()` middleware is prepended to the route's list of middleware, wouldn't that mean that the `Allow` headers aren't populated yet? That's essentially the problem I'm having with this -- The auto-generated `OPTIONS` middleware populates `Allow` _after_ any middleware I add:\n\n``` js\nlet acceptPatch = function(req, res, next) {\n  if (\/PATCH\/.test(req.get('Allow')))\n    res.set('Accept-Patch', 'application\/json')\n  next()\n}\nrouter.use(acceptPatch) \/\/ won't work because req.get('Allow') hasn't been auto-generated yet\n```\n","@Risto-Stevcev It sounds like `with()` will work the same as pre-pending a route handler function, so if you can do it in a route handler, you should be able to do it.\n","Hopefully it would\n","I just looked up how it sends the options - looks like it wraps the done callback and will send the options response if nothing else responded.  Instead of testing any method against `req.get('Allow')`, you could do something similar to @tunniclm, and put it on a specific method, like `router.patch()` (since the header you want to add is specifically for patch):\n\n``` js\nfunction allow_patch(type) {\n  return function(req, res, next) {\n    if(req.method === 'OPTIONS') {\n      res.set('Allow-Patch', type);\n    }\n    next();\n  }\n}\nrouter.patch('*', allow_patch('application\/json'));\n```\n","@demalus\nIt's actually supposed to be part of `OPTIONS`. If the `Allow` header sent from that request includes `PATCH`, then it will include the `Accept-Patch` [header as well](http:\/\/tools.ietf.org\/html\/rfc5789#section-3.1).\n"],"labels":["discuss","investigate","module:router"]},{"title":"Document Repository Map","body":"One of the more significant complaints I've seen is the confusion caused by all the individual repositories being so spread out across three different github organizations. While there are conversations happening about how those repos should be organized, one interim step is to provide a roadmap that outlines all of the relevant repositories, where they live, and how they relate to one another. This can either be done as a separate doc or added to the contributing guide (which is likely best)\n\n\/cc @tunniclm @ritch\n","comments":["Refs: https:\/\/github.com\/strongloop\/express\/issues\/2844#issuecomment-172691521\n","@dougwilson check me on this, are these: \n\n```\n  expressjs  \"Organization for HTTP utilities and anything Connect\/Express related.\"\n  jshttp     \"Low-Level JavaScript HTTP-related Modules\"\n  pillarjs   \"The BYO HTTP Framework Framework\"\n  strongloop \"StrongLoop Inc.\"\n    express\n    expressjs.com\n```\n","I did some investigation, here's some analysis of dependencies (not complete): https:\/\/gist.github.com\/tunniclm\/17bb1a909bacf2bb37e0\n","Would it also make sense to add some information to http:\/\/expressjs.com on what's in [jshttp](expressjs), [pillarjs](https:\/\/github.com\/pillarjs), and [expressjs](https:\/\/github.com\/expressjs)?  If there's agreement, I'll open an issue in https:\/\/github.com\/strongloop\/expressjs.com to add it to the site.\n"],"labels":["meta"]},{"title":"Document versioning strategy","body":"Is express using semver for versioning? It's not readily obvious. Node.js has picked up the practice of labeling issues as semver-major or semver-minor to help differentiate breaking vs additive changes. I'd recommend something similar here to help keep things organized.\n","comments":["It looks like semver, but I don't know for sure. \n\ncc: @dougwilson, @ritch \n","Seems like it has been semver historically - see [this comment](https:\/\/github.com\/strongloop\/express\/issues\/1838#issuecomment-36460746) [and this one.](https:\/\/github.com\/strongloop\/express\/issues\/1838#issuecomment-36788763)\n","Yes, it is semver. npm forces semver semantics on any package published on it.\n"],"labels":["meta"]},{"title":"Make automatic 304 responses configurable.","body":"I needed to disable this behavior in an application I'm working on. It seemed to me that disabling ETags should disable the automatic comparing of `If-None-Match` and the response `ETag` so [I opened this pull request](https:\/\/github.com\/strongloop\/express\/pull\/2772).\n\n@dougwilson asked that I configure this behavior specifically and I've done that here.\n","comments":["Hi @mqsoh, I'm not sure I quite understand the scenario you have.\n\nI would have expected disabling etags with `app.disable('etag');` to result in responses with `fresh` being true and therefore not have status code `304`. \n\nIs there something going on that would cause this not to be the case?\nOr am I misunderstanding, and you are interested in not sending a 304 response _whilst_ having etags enabled?\n","If you disable the 'etag' feature Express will still compare an `If-None-Match` with the response `ETag` and, if they match, alter the response status to 304 and strip the body.\n\nUsually this would be okay, but I'm dealing with some goofy clients.\n","OK, what are they doing? Is there some middleware or route handler is setting the 'ETag' header, rather than relying on Express to do it, or setting the etag function using `app.set('etag', fn);`?\n","I'm receiving `if-none-match` and sending an `etag`. Even if the cache is still valid, the client needs a `200 OK` with the request body.\n\nThe problem isn't with the ETag values. I happen to be using my own. I probably could use `app.set('etag', fun)` instead. Even if I did, Express would still _compare_ the etag with if-none-match, alter my status codes, and strip the body.\n\nI actually think the behaviors are the the same. I think that disabling the etag feature should stop this behavior. I submitted a pull request with a change like that, but was asked to make it a separate setting.\n","OK, that sounds reasonable to me.\n","Hi @mqsoh, thank you for the pull request!\n\nI think that the pull request is reasonable, only thinking about the name of the setting and wondering if there is a name that can be more generic without including \"304\" in it. Thoughts?\n","Some suggestions:\n\n\"send not modified\"\n\"send unchanged\"\n\"send unaltered\"\n","@tunniclm suggestions are all good. Here's a couple more:\n- unmanaged etags\n- ignore etags\n\nI have a slight preference for \"automatic 304s\". I think that when I was debugging my application and wondering 'Why is it sending 304s?' it would have been easy to find the answer.\n\n\"Ignore etags\" is nice because it's a good description of Express's behavior when compared with the preexisting setting, i.e.\n- **etag**: Set the ETag response header. For possible values, see the etag options table. More about the HTTP ETag header.\n- **ignore etag**: When false, Express will still managed cached responses if the request's `If-None-Match` header is the same as the response's `ETag` header.\n"],"labels":["pr"]},{"title":"include \"typings\" field in package.json","body":"Now that the TS compiler supports module [resolution](https:\/\/github.com\/Microsoft\/TypeScript\/issues\/2338) via node, it would be nice not to use TSD to install the typing but instead have them included with the npm package.\n","comments":["We don't have any typings. What would we put in the field?\n","@dougwilson I would be interested in maintaining them, if that sounds reasonable.\n\nEdit: I'll be working on some related type testing tools in https:\/\/github.com\/typings\/typings which will complement any such support for typings.\n","@blakeembrey , that is absolutely reasonable! I was just talking about these typings today and I think Express should provide official typings for TypeScript as a feature! This means that we would be invested in properly maintaining them as part of the normal commit and release process. If you want to provide the initial typings for Express, that would be amazing!\n\nIdeally I would love it if we could achieve these things:\n1. Provide bindings to users of Express\n2. Add a step to our CI that would validate that the bindings are correct somehow (to help prevent them from deteriorating accidentally)\n\nThese can be independent tasks, but I think Express is going to say yes to supporting TypeScript binding out of the box.\n","Fantastic, I'll work on making sure the CI step is solved properly this week.\n","@blakeembrey that sounds great :+1: @dougwilson does this mean that typings will also be added to the other expressjs packages (morgan, session, etc.)?\n","> does this mean that typings will also be added to the other expressjs packages (morgan, session, etc.)?\n\nyes\n","Great, because I was having a hard time figuring out how to write those typings properly as I kept getting some errors about the way I was declaring them (I was using ambient typings and I realized that is not the way to go).\n","We actually had this problem come up in [multer](https:\/\/github.com\/expressjs\/multer) where the type file that someone used wouldn't account for our middleware adding fields to the `req` object (namely `req.file`). Is this a problem that could be solved somehow? I think that it affects most middleware...\n\nOther than that, we would be happy to include and maintain \"typings\" for multer as well :)\n","@LinusU Mutations are hard to represent in TypeScript, especially with things like adding a field during middleware execution. It's possible to merge the interfaces and we should do that, if nothing else, but I'm not aware of a way to declaratively merge types depending on possible in middleware. That's something I've been thinking about anyway, but I'm glad to share an example of how this would work.\n\nThe reason I haven't yet tried to merge this into Express is because I haven't had time to solve the test suite involved. The closest I have is a feature I've had for a while - bundle the typings, then run the TypeScript compiler, then run unit tests as usual.\n","Would maintainers be interested in converting the express source to TypeScript, so we could automatically generate correct typings with each release? I'd be down for helping with the conversion. \/\/ @dougwilson @ritch \n","Hi @jeffbcross, thanks for the offer, but there is no plan to convert the source to anything other than pure JavaScript, I'm sorry.\n","Thanks @dougwilson I'm asking about openness to such a thing. I.e. knowing your contributor base, would typescript support be something contributors would want (or at least live with)? I could enumerate the benefits here beyond typings generation if it would be helpful. \n","Hi @jeffbcross, I am generally aware of the benefits, but I don't think it aligns with our user base, or even our maintainers. For example, I don't even understand TS and really can't even judge it unless there is a class I can take to learn it? The biggest barrier is that unless the idea is that we transfer ownership of express to you, at the very least the current contributors should know TS well enough to continue to contribute to this module.\n\nI know there is a very minor community that would like TS bindings, mainly for the IDEs, but other than that, I have no real idea how it would impact the user base.\n\nThoughts? And why would it be necessary to completely change the language this module is written in just to declare type bindings?\n","I was looking for issues related to typescript and stumbled upon this.  Can we close this since it has been inactive for so long?  Or maybe @blakeembrey can close it along with a status of the typescript support for express?","It still seems like a good thing to have, even though there hasn't been any movement. I guess the question is do we want this at some point? If so, we don't have a good way to track this wait besides having an open issue somewhere about it, right?","I guess I assumed that we were good with just pointing people to the DT repo.  I think it is surface area that express should probably avoid supporting since only Blake is familiar with the requirements, and the DT project seems to have the support behind it.","Gotcha. I never got into TS myself, but I see the value of it. I'm OK with adding typings if that helps the TS community in some way, though I just don't know enough to really help a ton. I guess we can close this and reopen (or a new one opened) if there is a proposal, ideally including the actual definitions, to add into Express.","What about the types from here: https:\/\/www.npmjs.com\/package\/@types\/express","That is the package we were talking about above :)","ok sry","In #3972 @commonbreed mentions those typings are out of date.  Can you provide some more details here?  What is out of date, is there a simple PR we can make to update them?","@wesleytodd It's likely that the \"outdated\" types are still accurate, as I don't know whether any signatures have changed from 4.16.1 to 4.17.1. Regardless, it would be nice to have the types package consistent with Express versioning. (Every Express release, make a PR to the types package?)","Although I think a TS port is more appropriate.","Thanks @commonbreed.  Can you explain what you mean by \"TS port\"?\r\n\r\n> It's likely that the \"outdated\" types are still accurate\r\n\r\n> whether any signatures have changed from 4.16.1 to 4.17.1\r\n\r\nI see what you mean, and the answer is probably that they are still accurate.  \r\n\r\n> it would be nice to have the types package consistent with Express versioning\r\n\r\nIf this is something the typescript community is used to, then we would probably like to support that.  That being said, we would need someone from the community who actively uses typescript to step up and maintain them.  Is that something you would be interested in?","Ah, just noticed dougwilson has prohibited porting _this_ code base to TypeScript, which is reasonable in the short term - seems to be what many middlewares are opting for too.\r\n\r\n> If this is something the typescript community is used to, then we would probably like to support that. \r\n\r\nUnfortunately, this is not something the community is used to as such. Types don't tend to be updated until there is a significant code refactor, or until someone reports them as broken. It can be confusing to TypeScript developers when they see npm has pulled an \"older\" types package. I think it's probably very safe to add DT typing as a dependency (not a devDependency) - this is a library. I'll make a PR now.\r\n","#3973 Here's the PR","> dougwilson has prohibited porting this code base to TypeScript\r\n\r\nDoug is not a dictator.  He and the rest of the contributors do not want to port anything to TS.  I believe if you search the repo you can find many conversations where we have all shared our opinions on this, so I will not repeat them.  But I did not want someone to come along and read this and miss-understand the situation by reading your comment alone.\r\n\r\n> Unfortunately, this is not something the community is used to as such.\r\n\r\nOk, I don't won't to add more on that PR discussion yet.  But from your comment here it sounds like we do not want to do something which is not already in line with what the TS community expects.  If they already are used to installing `@types\/express` and the version miss-match is fine as long as the types are still correct, then I would prefer to leave it that way.\r\n\r\n>  I think it's probably very safe to add DT typing as a dependency\r\n\r\nAgain, not getting into the issues in the PR, I disagree that adding DT as a dep here is a good thing.  It is not a dep, and since users can opt into typescript and other not, we don't want to make changes which effect everyone for the sake of the few.","> Doug is not a dictator. ...\r\n\r\nI'm fully aware this is a community project and never supposed Doug to be such. Perhaps \"prohibited\" was a little strong, but the sentiment was to suggest that a TypeScript port is likely not going to be on the table any time soon, so to consider alternative options.\r\n\r\n> If they already are used to installing @types\/express and the version miss-match is fine as long as the types are still correct, then I would prefer to leave it that way.\r\n\r\nMy reason for picking up this issue in the first place was to address _specifically_ Express' lack of typings. Express has over 9M weekly downloads on NPM, and has a large community of middleware developers who might depend on solid, directly maintained types for linting, integration into CI\/testing etc.\r\n\r\n> It is not a dep\r\n\r\nI mostly concur. Adding this dependency here is probably not the right move. It causes all kinds of issues with versioning and redundancy. I would however urge folks to consider ensuring PRs are at least made to DT's Express types to ensure any API changes are immediately reflected for TS developers. Don't need to make them a dependency - but at least ensure they're up to date. TypeScript is involved in over 30% of projects on NPM, so it's important for types not to get left behind.\r\n","> I'm fully aware this is a community project and never supposed Doug\r\n\r\nI was not admonishing you, just making sure the governance model was clear to everyone who might read this in the future :)\r\n\r\n> I would however urge folks to consider ensuring PRs are at least made to DT's Express types to ensure any API changes are immediately reflected for TS developers\r\n\r\nI fully agree here.  We would love to have someone who has the right knowledge in this area to participate and ensure that we have updated typings.  If that person is you, then I would suggest following the repo so you see when update branches are being prepared.  Today the matter is just that none of the active core team members (except @blakeembrey who is busy with many other things) are TS users.  So we just don't have the person power to make it happen.","wow this is since 2015, till this day we still looking for type."],"labels":["enhancement","4.x"]},{"title":"Decoupling express.request and express.response from express application","body":"I'd like to be able to use `express.request` and `express.response` outside of an express `application` \"instance\". This means I'd be able to use them as prototypes for my own request and response objects. Additionally, I'd like to also define which objects they delegate to for their prototypes (I understand this last part [is possible already](https:\/\/github.com\/strongloop\/express\/issues\/2805#issuecomment-156841207) but its not first-class and it won't work in an ES2015 world where imports are read-only).\n\nI'm a big fan of the work that was done to decouple the router implementation into its own module so that it no longer assumes the presence of an express application. I believe what I am proposing is in the spirit of that effort.\n\nA couple use cases I'm hoping to address:\n-  Testing for standalone router: I have a router which depends on its request and response arguments to implement the `express.request` and `express.response` interfaces. I'd like to write unit tests that are minimal, so I don't want to initialize an express application, nor do I want it to listen on a port or socket. Ideally, I could create some request and response objects directly from the express prototypes, and also plug in a \"mock\" for `http.IncomingMessage` and `http.ServerResponse` (that [don't need to actually do any networking](https:\/\/www.npmjs.com\/package\/mock-http)) to be one level up the prototype chain. Then I could just invoke my router's `handle()` method with the arguments I've constructed and set up assertions on the behavior. This is currently not possible because both request and response have methods that read settings from `this.app`. I've take a look at the tests for [pillarjs\/router](https:\/\/github.com\/pillarjs\/router) and they seem to be limited to only use API on request and response that are provided by node core.\n-  Extensibility: I've seen a [few](https:\/\/github.com\/strongloop\/express\/issues\/2805) [issues](https:\/\/github.com\/strongloop\/express\/issues\/2781) on the tracker that are essentially asking for the ability to rewire request and response to expose more or different functionality. Its been noted that the design of express was to be a thin wrapper on top of the node core HTTP API, and thats where the limitations come from. If instead of directly using private API of `http.IncomingMessage` and `http.ServerResponse`, we had a declared interface (one that the aforementioned types already adhere to or do so through a thin adapter) for what `express.request` and `express.response` rely on up the prototype chain, we could enable much more innovation in the ecosystem. Express would also benefit from seeing experimentation on those layers and adopt proven and useful extensions back into its core.\n\nOpen Questions:\n-  If response and request don't read its settings from application, where do they read it from?\n-  What is the role of application when router (middleware), request, and response don't need it? Is it just a convenience for wiring things up in the \"default\" way?\n","comments":["I think this will eventually become part of https:\/\/github.com\/pillarjs\/extend-proto\n","Well, part of it. We'll probably have a separate module for the default \"express\" properties.\n","Seems related to https:\/\/github.com\/expressjs\/express\/issues\/2432 ?","I'm not sure what the state of Express 5 is, but is this something that would be up for consideration\/discussion?","I think this is a good idea, @aoberoi \r\n\r\nEspecially that `express.Router()` is a private function, which makes testing express routes with TypeScript really difficult, unless spinning up a http server\r\n\r\nhttps:\/\/github.com\/expressjs\/express\/blob\/master\/lib\/router\/index.js#L131-L136","@kevinsimper If you'll humor me, I'm curious to learn more about your use case. I'm not sure this is the best issue to discuss this, the conversation around moving req\/res out is spread out in a couple of places:\r\n\r\n* [A discussion w\/ a bit of history and context](https:\/\/github.com\/expressjs\/discussions\/issues\/82)\r\n* [Another convo](https:\/\/github.com\/expressjs\/express\/issues\/2432)\r\n* [WIP PR for landing the removal](https:\/\/github.com\/expressjs\/express\/pull\/3214)\r\n\r\nI'm happy to inform you work has begun on moving them to their own repos. But I don't have a use case myself where this would benefit me, so detail about how you plan to use this would be valuable! I.E, what are you doing today, why is it suboptimal, and what would you prefer to be able to do? @wesleytodd has been the champion for including this in v5, and it will likely still happen, but since I have you I'd love to hear more about what problem this could solve.\r\n\r\nThank you \u2764\ufe0f ","> Especially that express.Router() is a private function\r\n\r\n`express.Router()` is not a private function at all. We even document it publicly all over our API docs http:\/\/expressjs.com\/en\/api.html","Well their included link points to `router.handle`, which is labeled private in the jsdoc (not saying you're wrong, just pointing out the context)\r\n","> Well their included link points to router.handle, which is labeled private in the jsdoc\r\n\r\nAh. Yes, that is a private function, as the public call to that is `router(req, res, next)`, not `router.handle(req, res, next)`.","Thanks for the responses!\r\n@dougwilson Did not know of `router(req, res, next)`, I will take a look at that!\r\n\r\n@jonchurch I want to be able to test this code and ensure that send is being called.\r\n```js\r\nimport express, { Request, Response } from \"express\";\r\n\r\nexport const app = express.Router();\r\n\r\napp.get(\"\/\", (req: Request, res: Response) => {\r\n  res.send(\"Login\");\r\n});\r\n```\r\n\r\nI can not see other ways than doing this:\r\n```js\r\nimport express from \"express\";\r\nimport fetch from \"node-fetch\";\r\nimport { app as loginRoutes } from \".\/login\";\r\n\r\ntest(\"login\", (done) => {\r\n  console.time(\"start-test-server\");\r\n  const server = express();\r\n  server.use(loginRoutes);\r\n  const listener = server.listen(0);\r\n  listener.on(\"listening\", async () => {\r\n    const address = listener.address();\r\n    if (typeof address === \"string\") return done(new Error(\"no port\"));\r\n    const req = await fetch(\"http:\/\/localhost:\" + address.port);\r\n    const data = await req.text();\r\n    expect(data).toBe(\"Login\");\r\n    listener.close(() => {\r\n      console.timeEnd(\"start-test-server\");\r\n      done();\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nWhich is not that easy to read, it does not look clean. And the test takes on my i7 anywhere from 27 to 41 ms to run. That is slow compared to unit tests. \r\n\r\nWith typescript it is not possible to create a Response object that does not contain all 79 properties of the response object.\r\n\r\nHere is an example:\r\n```js\r\nimport express, { Response } from \"express\";\r\n\r\ntest(\"login route\", () => {\r\n  const route = (req, res: Response) => {\r\n    res.send(\"Login\");\r\n  };\r\n  const mockSend = jest.fn();\r\n  route({}, { send: mockSend });\r\n});\r\n```\r\n\r\nIt will give you this message:\r\n```\r\nArgument of type '{ send: jest.Mock<any, any>; }' is not assignable to parameter of type 'Response<any>'. Type '{ send: Mock<any, any>; }' is missing the following properties from type 'Response<any>': status, sendStatus, links, json, and 79 more.\r\n```\r\n\r\nI don't believe that other projects should adapt to typescript, so don't think about the typescript part. I just wanted to show that I have tried other ways, but it will not work with typescript because of the difficulties of mocking large objects.","I wish I knew typescript so I could better help, but maybe this will help: the decoupling that this issue is talking about won't suddenly make request and reaponse prototypes usable outside of a http server, as it heavily relies on the state set up there.\r\n\r\nBut if you just want to make them in order to satisfy type checks, the express module already exports them for usage (no real difference than when they will be decoupled into a different module) under `express.request` and `express.response` exports."],"labels":["discuss","ideas"]},{"title":"Express and middleware that manipulate reponses","body":"AFAIK, there is currently no generic \/ documented way to manipulate responses before they are passed on to the underlying socket (through a transform stream for example). I can think of 2 instances where this would be useful: compression and monitoring outgoing bandwidth.\n\nThe https:\/\/github.com\/expressjs\/compression\/ module resorts to monkey patching the `res` object which is prone to error, difficult to maintain and not extensible.\n\nIt would be nice if there was a documented and extensible way to manipulate responses before they are passed to the underlying socket.\n","comments":["Hi! Because all we do is provide a thin app layer oj top of the Node.js core HTTP, without some core-level solution, there isn't too much we can do. If you would like to research, prototype, and share a proposed solution with us, that would be the best way to move this forward :)\n","Ok, I will see if I can come up with something (I think I have some idea on how to do it). \n","Related issues: https:\/\/github.com\/strongloop\/express\/issues\/2255 https:\/\/github.com\/expressjs\/compression\/issues\/13\n","WIP:\n\n``` javascript\nclass ResProxy extends stream.Writable {\n  constructor(res) {\n    super();\n    this.res = res;\n    this.origWrite = res.write;\n    this.origEnd = res.end;\n  }\n\n  write(...args) {\n    \/\/ console.log('res.write');\n    return this.origWrite.apply(this.res, args);\n  }\n\n  end(...args) {\n    \/\/ console.log('res.end');\n    return this.origEnd.apply(this.res, args);\n  }\n}\n\nconst patch = (res) => {\n  const resProxy = new ResProxy(res);\n\n  res.transforms = [ new stream.PassThrough() ];\n  const first = () => {\n    return res.transforms[0];\n  };\n  const last = () => {\n    return res.transforms[res.transforms.length - 1];\n  };\n\n  res.use = (s) => {\n    last().pipe(s);\n    res.transforms.push(s);\n  };\n\n  let streamConnected = false;\n  const connectPipes = () => {\n    if (streamConnected) return;\n    streamConnected = true;\n    last().pipe(resProxy);\n  };\n  res.write = (...args) => {\n    connectPipes();\n    \/\/ console.log('passthrough res.write');\n    return first().write(...args);\n  };\n  res.end = (...args) => {\n    connectPipes();\n    \/\/ console.log('passthrough res.end');\n    return first().end(...args);\n  };\n};\n```\n\nUsage:\n\n``` javascript\napp.use((req, res, next) => {\n  patch(res);\n  res.use(someTransformStream);\n  res.use(someOtherTransformStream);\n  res.send('yay!');\n});\n```\n\nI have been using the code above for my bandwidth monitoring middleware and initial tests seem positive.\n","Created a repo to track progress here: https:\/\/github.com\/olalonde\/express-transform\n","I have similar requirements, and i've found express middleware framework doesn't support full-spec http interceptor concepts, like modifying http response.\r\n\r\nTo be more clear, a middleware, or a http interceptor, should be applied FILO: if it is the first to do with the req, then it will be the last to do with the req. (But i guess this does not occupy with the underlying Node async io mechanism?)\r\n\r\nBut the above `patch` code really shocks me: JavaScript code has since evoled a lot! :-)"],"labels":["discuss","enhancement","ideas"]},{"title":"Feature request: friendly exposure of req\/res logic for HTTP\/2 push promises","body":"HTTP\/2 has a great feature called push promises. It allows you to push files from server to client pro-actively because you know the client will need it. To do this responsibly, you can send along headers that can inform the client about the ETag for example, so the client can abort the file download if it's already in cache. This is all great, but very hard to deal with Express, because I would want to use all the configured Express logic in the `push()` API that (in my case) node-spdy expose.\n\nIn other words, I would love to combine `res.sendFile()` with `res.push()` (that node-spdy exposes). This is currently pretty much impossible as far as I can see. If Express could give more access to the internals of how a file would be delivered without actually delivering it (say, provide me with headers and a file stream I could pipe to res.push) that would be a major help. Alternative solutions of course welcome :)\n\nExample spdy-server with Express:\n\n``` js\nconst fs = require('fs');\nconst config = require('config');\nconst spdy = require('spdy');\nconst express = require('express');\n\nconst app = express();\n\nconst options = {\n    key: fs.readFileSync(config.get('server.ssl.key')),\n    cert: fs.readFileSync(config.get('server.ssl.cert'))\n};\n\nconst httpServer = spdy.createServer(options, app);\nhttpServer.listen(8080);\n\n\/\/ a route with a push promise stream:\n\napp.get('\/index.html', function (req, res) {\n    \/\/ index.html is guaranteed to need styles.css\n    \/\/ if *only* my code could look like this:\n\n    res.push('\/styles.css').sendFile('.\/www\/styles.css'));\n\n    res.sendFile('.\/www\/index.html');\n});\n```\n\nUnfortunately:\n- Express' sendFile function really sends the file directly on the response stream. I wish I could send it on the push stream.\n- node-spdy doesn't make this easier because of how its `push` method works (see [push docs](https:\/\/www.npmjs.com\/package\/spdy#push-streams), cc @indutny).\n\nThe glue has to happen somewhere, and I'm not sure where or how. But without any changes to express and\/or spdy, it seems impossible to do today.\n","comments":["i have https:\/\/github.com\/jshttp\/spdy-push, but it isn't updated for spdy@2, which supports http2. making it easy to push files is a matter of setting more headers. still wondering if it would be included in node, though...\n","node-spdy supports push() out of the box, and it seems easy enough to use. The problem is that express does a lot of logic for me to construct good responses to requests. I don't want to have to replicate though (nor have a different middleware solve it in its own way). I want to use express' internal logic, and simple API to deliver content through push. Ideally, doing a push is a one-liner, just like how most operations in Express are one-liners.\n","Is there a label or over-arching Issue mapped to http\/2 support? I'd love to have it by default in Express.\n"],"labels":["ideas","5.x"]},{"title":"Support for module http2?","body":"Hi, I would like to know if Express 5.0 will have support for http2:\nhttps:\/\/github.com\/molnarg\/node-http2\n\nI was reading a bit and I noticed that exist a problem with http2 module:\nhttps:\/\/github.com\/molnarg\/node-http2\/issues\/100\n\nI have tested in local and the problem continues:\nhttps:\/\/github.com\/jabrena\/CloudFoundryLab\/blob\/master\/Node_HelloWorld_http2_express\/index.js\n\nIt this issue in the roadmap?\nDoes exist another alternative to run a express application with http2?\n\nMany thanks in advance.\n\nJuan Antonio\n","comments":["I have just tested with latest release alpha (5.0.0-alpha.2) and the problem continues:\n\n```\n\n\/*jslint node: true*\/\n\"use strict\";\n\nvar fs = require('fs');\nvar http2 = require('http2');\nvar express = require('express');\n\nvar app = express();\napp.get('\/', function (req, res) {\n    console.log(req.headers);\n\n    res.header('Content-type', 'text\/html');\n    return res.end('<h1>Hello, Secure World!<\/h1>');\n});\n\nvar options = {\n    key: fs.readFileSync('.\/certificate\/localhost.key'),\n    cert: fs.readFileSync('.\/certificate\/localhost.crt')\n};\nvar port = process.env.VCAP_APP_PORT || 8080;\nhttp2.createServer(options, app).listen(port);\n\n```\n\ntraces:\n\n```\n\n    dest.end();\n         ^\n\nTypeError: dest.end is not a function\n    at Stream.onend (_stream_readable.js:490:10)\n    at Stream.g (events.js:260:16)\n    at emitNone (events.js:72:20)\n    at Stream.emit (events.js:166:7)\n    at endReadableNT (_stream_readable.js:893:12)\n    at doNTCallback2 (node.js:429:9)\n    at process._tickCallback (node.js:343:17)\n23 Sep 12:15:24 - [nodemon] app crashed - waiting for file changes before starti\nng...\n\n```\n","Hi! o answer your question, yes, it is a known issue, and no, has not yet been addressed. We have a link back to that referenced `http2` issue (noted in https:\/\/github.com\/molnarg\/node-http2\/issues\/100#issuecomment-111549799) already to track this as well as it listed in our Express 5 roadmap (#2237):\n\n> Support non-core HTTP prototypes (e.g. http2, shot and others)\n\nThe 5.0 alpha 2 does not work because it has not been addressed yet. It is not a simple fix at all, and any help you want to provide toward this as part of a PR is much appreciated!\n","In addition, if all you want to do is replicate the Express routing with `http2`, the module `router` (https:\/\/github.com\/pillarjs\/router) is the actual Express 4.x router, extracted into it's own module and will work just fine with `http2`:\n\n``` js\n\/*jslint node: true*\/\n\"use strict\";\n\nvar finalhandler = require('finalhandler');\nvar fs = require('fs');\nvar http2 = require('http2');\nvar Router = require('router');\n\nvar router = new Router();\nrouter.get('\/', function (req, res) {\n    console.log(req.headers);\n\n    res.setHeader('Content-type', 'text\/html');\n    return res.end('<h1>Hello, Secure World!<\/h1>');\n});\n\nvar options = {\n    key: fs.readFileSync('.\/certificate\/localhost.key'),\n    cert: fs.readFileSync('.\/certificate\/localhost.crt')\n};\nvar port = process.env.VCAP_APP_PORT || 8080;\nhttp2.createServer(options, app).listen(port);\n\nfunction app(req, res) {\n    router(req, res, finalhandler(req, res));\n}\n```\n","Hi @dougwilson, if you provide some technical documentation to check that classes, I could help you to begin fixing this issue. Tomorrow, I will test the alternative.\n","Hi @jabrena , I'm not sure what kind of technical documentation you are looking for. All Express documentation is located at http:\/\/expressjs.com\/ and anything technical is gathered from reading the JavaScript source code of Express.\n","No problem, will try to check this part:\n\n```\nPrototype = req.__proto__; \nreq.__proto__ = app.request; app.request.__proto__ = originalPrototype; \n```\n\nit is a clue from a comment in:\nhttps:\/\/github.com\/molnarg\/node-http2\/issues\/100\n\nBesides, I will compare current router with the router that runs with http2\n\nJuan Antonio\n","@jabrena , @dougwilson why not https:\/\/github.com\/indutny\/node-spdy? \n\n> With this module you can create HTTP2 \/ SPDY\n","AFAIK node-spdy already works with Express 4\n",":+1: \n","Pretty interesting!!!\nI will test next week. \n@victorherraiz @isuriv \n","I can confirm node-spdy works fine, I'm using it. It doesn't however let you use HTTP\/2 push promises very easily with Express. I made an issue about this at #2781.\n","I think having http2 out of the box is perhaps a little out of scope of express itself?\n","> I think having http2 out of the box is perhaps a little out of scope of express itself?\n\nIt may be, but I interpret this issue as the fact that it's impossible to even use the `http2` module. Technically Express doesn't really do HTTP out of the box, unless you count the single `app.listen` entry point. HTTP support is, in the general sense, done with `http.createServer(app)`, and that should work for the `http2` and other modules for this issue to be considered closed.\n","The problem to me is not that express is not compatible with the `spdy` module. They are compatible, it all works. However, if I want to use HTTP2 push promises, all the goodies of Express, like `.static` and `sendFile` become unusable. I cannot connect their logic to the push promise stream.\n","Hi @ronkorving, perhaps open a new issue in regards to that problem? I don't want to loose sight on the issue brought up in the original post on the issue, which is specifically about working with `http2`. Please open a new issue, providing as much detail into the problem as you can, so we can reproduce and see what we can figure out.\n","You mean like #2781 ? :)\n","Ah, yep :) But I don't know anything about `node-spdy` and there is no code for me to even play with. Without a full way to reproduce and the technical details of the issue, I'm not sure how much help I can be on that issue. @jonathanong replied to you and he has used that module in the past, but I don't think anyone else has and I forgot that even existed. Can you fill out the issue some more for use non-spdy users?\n","No problem :+1: \n","@dougwilson - I went down your path of using [router module](https:\/\/github.com\/pillarjs\/router) and ran into issues with not being able to use res.sendFile anymore. I ended up extracting all the sendFile logic and reworking it as a thunk that works just like serveStatic (supports all sendFile options). I published it as [serve-file module](https:\/\/npmjs.com\/package\/serve-file), may come in handy to anyone that ran into the same issues as me. I tested it on http2 \/ spdy with router and had no issues:\n\n``` js\nimport serveFile from 'serve-file'\n\napp.use('\/my-file.txt', serveFile('path\/to\/my-file.txt'))\n```\n","I'm quite curious if initialising an express application as follows would be enough to resolve the problems. It seems to be enough to get a very simple application working (on express 5.0 branch):\n\n``` js\nvar express = require('express');\nvar http2 = require('http2');\n\nexpress.request.__proto__ = http2.IncomingMessage.prototype;\nexpress.response.__proto__ = http2.ServerResponse.prototype;\n\nvar app = express();\n...\n```\n","OK, so the main problem I found with https:\/\/github.com\/expressjs\/express\/issues\/2761#issuecomment-216912022 is that it doesn't handle HTTP\/1.1 fallback properly. Since the prototype used here is statically set to the http2 prototype, it is incorrect when fallback happens to HTTP\/1.1 resulting in a TypeError (attempt to call `push()` on `undefined`).\n\nAbout a month ago, shortly before I posted the above comment I had implemented a change in my local express to _dynamically_ fix-up the prototype chain and that's where I stumbled on `express.request` and `express.response` -- my patch broke that functionality.\n\nHowever, I just ran the acme-air for Node.js benchmark app on my patched express and it seems to fix the problem with falling back. I'm going to see if I can solve the problem with breaking the `express.request` and `express.response` API, or make something that provides similar functionality and push a branch for wider testing.\n","I've cleaned the patch up some and changed it a bit in light of some issues that I found during further testing -- I discovered `app.request` and `app.response`, the application level equivalents of `express.request` and `express.response` and changed the patch to preserve similar functionality.\n\nThe approach the patch takes is to resolve inheritance issues by mixing in the express API object instead of inserting it into the inheritance chain. Combined with lazily caching the prototype chain for each protocol that is used, a correct prototype chain can be kept for each request.\n\nI the latest implementation the mixed-in API objects are also stored in the cache to avoid performing the mixin afresh on every request. This means there is a cache entry for each app and protocol combination in the system.\n\nI have renamed the app-level and express-level request and response objects to make it clear they are now mixins. This may not be desirable as it will break code that modifies these API objects (for example, to add methods), however, it may be a good idea if the difference in behaviour would cause subtle bugs.\n\nSince these mixins are performed once and cached thereafter, modifications to the API objects have no effect after the first request is handled (for a given app\/protocol combination). This could be improved by providing a mechanism for dirtying the cache.\n\nThe branch (based on `5.0`):\nhttps:\/\/github.com\/tunniclm\/express\/tree\/http2_with_dynamic_insertion2\n\nComparison with expressjs\/express branch `5.0`:\nhttps:\/\/github.com\/expressjs\/express\/compare\/5.0...tunniclm:http2_with_dynamic_insertion2\n\nI have already tested a bit on a simple and a medium complexity express application, but not yet tried a server push (these were both converted HTTP\/1.1 apps) -- I'll try that soon. \n\nI'm not wedded to the approach taken in this patch, so feel free to point out if I'm going down the wrong track. I have several other things I'm trying, but this is the first one that is working at the moment.\n\nI'd welcome anyone who can spare a little time to comment or try to test it out. Thanks!\n","do you guys know when this will be working? koa has been working with http2 for a long time and now spdy is outdated as well as of node v11.1.0. we switched a while ago with spdy, but all upstream packages are outdated to work on node v11.1.0 :(\r\n\r\nexpress is such a huge package, everyone knows it and still http2 is just not working. sad, but true.","Is http\/2 still on roadmap?","@tunniclm, your work looks promising. Any reason why you're not submitting it as a pull request towards the official repository?","@asbjornu There's also PR #3730, which could add `http\/2` support for express and maybe it will be merged.","For anyone saying just use spdy, HTTP\/2 is an actual standard now. SPDY is not. On top of that `spdy` makes **heavy** use of private internal functions in node.  It is broken and expected not to be fixed for any node version >= 11.1\r\n\r\nIMO supporting the actual native `http2` should be the current direction that express takes","as @nwgh actually mentioned in https:\/\/github.com\/molnarg\/node-http2\/issues\/100 on Aug 9, **2016** already:\r\n\r\n> [...] just to note, spdy _is_ dead. \r\n\r\nSo the SPDY package is no longer maintained, and due to a bug in the `handle-thing` dependency even broken when running with node > 11.1 (see https:\/\/github.com\/nodejs\/node\/issues\/24097). So going for SPDY is clearly **no longer** an option! The only way forward for express supporting HTTP\/2 _is_ the Node.js `http2` package.\r\n\r\nIs there any update on the progress about this? It'd be a bummer if Express 5 would not provide any HTTP\/2 support! Thanks.","Has anybody got anything to push to fix http\/2 issues? log in #4112 for 4.17.1\/5.0\/5.x... we tried pillerjs\/router as a fix but still leaves is in a broken state. many modules and process explicitly depend on express being available and have only managed to work through a fraction of them to remove express dependencies. ","fyi, the `spdy`\/`handle-thing` issue has been fixed: https:\/\/github.com\/spdy-http2\/handle-thing\/pull\/13\r\n\r\nI was just able to start an HTTP\/2 server using spdy and express on Node `v12.6.0` and `v13.11.0`. I get an ugly console message `(node:48680) [DEP0066] DeprecationWarning: OutgoingMessage.prototype._headers is deprecated` but apart from that, spdy seems to work with the latest Node.js versions again.","[This gist can help somebody who needs to use spdy only for development http2 server with express js](https:\/\/gist.github.com\/studentIvan\/6c78886c140067936ff379031fd12e14)\r\n\r\n","Some one has created a bridge to make this work. Contributors\/Maintaners here can check it and update it if needed,\r\nhttps:\/\/javascript.plainenglish.io\/serving-hello-world-with-http2-and-express-js-4dd0ffe76860","node-spdy does not work for static files on node >=15; [link to issue](https:\/\/github.com\/spdy-http2\/node-spdy\/issues\/380).\r\n","Any progress here on the http\/2 front?","so many years, there is no progress..."],"labels":["future"]},{"title":"feat: Support typed params in routes","body":"I mean, do something like:\n\n``` js\napp.route('\/:an_id{number}');\napp.route('\/:another_id{string}')\n```\n\nwhich is roughly equivalent to use regex in each case, but the shorthand above is clearer and allows `req.params` to properly type the params, fi: `req.params.an_id` would be a number instead of a string.\n\nThanks\n","comments":["Is there prior art this derives from?\n","@aredridel Yes, but I don't recall where I saw it.\n","@aredridel angular `ui-router` module has this feature :smile: I know is front-end but at the backend we can give it a good use of it (thought the syntax is different that the one I added above).\n\nhttps:\/\/github.com\/angular-ui\/ui-router\/wiki\/URL-Routing\n","I have seen this in other express-similar libraries like [bottlepy](http:\/\/bottlepy.org\/docs\/0.12\/tutorial.html#dynamic-routes) & [flask](http:\/\/flask.pocoo.org\/docs\/0.10\/quickstart\/#variable-rules).\n","I implemented some support for this in [path-to-regexp](https:\/\/github.com\/pillarjs\/path-to-regexp), the library that parses the paths into regular expressions.\n\n[My commit is here](https:\/\/github.com\/vladvelici\/path-to-regexp\/commit\/afebe509a1914d4c1c6462b269039301a8d5aa5b). I didn't sent a pull request yet as there is no issue related to it in [path-to-regexp](https:\/\/github.com\/pillarjs\/path-to-regexp). I will open one and try to get some feedback.\n","Interesting. On a (partially related) side note, I did something similar for https:\/\/github.com\/pillarjs\/router\/pull\/29 (the standalone router, not in Express 4.x) which added support for the RAML type system using https:\/\/github.com\/mulesoft-labs\/raml-path-match. If something like that lands, it would be straightforward to add a new path matching implementation with types (I know URI templates is of some interest too). \n\nEdit: That router is here: https:\/\/github.com\/mulesoft-labs\/osprey-router\n"],"labels":["discuss","enhancement","module:router"]},{"title":"Should Express 5.0 require a minimum of Node.js 4?","body":"This is a discussion regarding having Express 5.0 drop support for Node.js 0.10. One of the reasons for the delay in Express 5.0 was the announcement of the official merging of Node.js and io.js, and we were looking forward to it's outcome to determine what we should do with Express 5.0.\n\nHere at Express, we value very long-lived major versions, allowing users to confidentially build their new server on Express and not have to worry about needing to upgrade across a major, breaking change for years. Express 4.0 has been out for over a year now and Express 3.0 was supported for over 3 years !!\n\nWhen Express 5.0 comes out, Express 4.x line will continue to be fully supported, delivering our users bug fixes, new features, and more!\n\nTo this end, we have been carefully watching io.js\/Node.js in relation to Express 5.0 such that we can continue this great support history without accidentally locking us into the past for a long time.\n\nPlease share your thoughts here.\n","comments":["Fwiw 0.10 will be EOL'd October 2016, and 0.12 at the end of year, 2016.\n\nThe former is already in maintenance mode, and 0.12 will go into maintenance-only next April. 0.12's EOL was cut short due to OpenSSL ending support for 1.0.1 at end-of-year 2016.\n\nMore info: https:\/\/github.com\/nodejs\/LTS (Slightly outdated)\n\nI'd personally vote for yes (biased I suppose), and try to encourage a larger move to 4.0.0 sooner than later for users.\n","Dropping 0.10 for 5.0 sounds good to me. Express 4 isn't that different, right?\n","+1\ndrop support for 0.10\n","Highly in favor of dropping support for 0.10.\n","Open source should move as fast as possible w\/ option for sponsored LTS. Drop it.\n","What's the cost of not dropping 0.10?\n","Moving forward to node 4.0 seems more important than supporting 0.10\n","So, just to be clear: Express 5.x dropping support for Node.js 0.10 does not mean _Express_ will drop support for Node.js 0.10. Just like Express 3.x has lived in parallel with Express 4.x for almost 2 years now, Express 4.x will continue to live alongside Express 5.x.\n\nTo answer @aredridel , not dropping 0.10 from Express 5.x means that 5.x would be hard-pressed to consume and support various features in the newer V8 and Node.js platform (things like Intl, generators, promises, and more). Because we want to make longtivity promises, this means that once Express 5.0 comes out, an Express 6.0 is unlikely to appear until 1 year or more later, putting it further behind the curve.\n\nHere is a little mock-up support example:\n\n```\nYear             0      1      2      3      4      5      6\n\nExpress 3 (0.8 ) +--------------------+\nExpress 4 (0.10)               +--------------------+\nExpress 5 (4?  )                      +--------------------+\n```\n\nTypically we'll have 2 active Express majors at a time (more than that gets harder, and the benefit decreases). The idea is that we can then perhaps up the minimum Node.js version with a major, since the previous major will still be around for a long time to come after the release. If you look back at the history of the 3.x line while 4.x has existed, we continued to backport every single new feature from Express 4.x into 3.x that was possible with 3.x's design. We intend to do the same with 4.x\/5.x, which means 4.x will keep up; the release of 5.x does not move 4.x into \"maintenance mode\", either.\n","Perhaps a better question to ask is, what does Express gain by dropping 0.10 but not 0.12? Most of the improvements you mention cant adopted until 0.12 is abandoned.\n","> Perhaps a better question to ask is, what does Express gain by dropping 0.10 but not 0.12? Most of the improvements you mention cant adopted until 0.12 is abandoned.\n\nGood point.\n\nIf we drop 0.10 we should probably also just drop 0.12.\n\nStats are that 0.12 doesn't have nearly the usage of 0.10, and is, quite frankly, rather buggy.\n","@ChiperSoft @Fishrock123 , oh, my bad. I do not like to think of 0.12 as even exiting, as there are so many issues with the V8 in that version, it's laughable that people can even use that version of Node.js without getting various `illegal instruction` errors from corrupted machine code generation.\n\nYes, this topic assumes that the minimum for Express 5 would be Node.js 4. I have updated the title to correspond :)\n","Yeah. I've no real interest in generators, but promises I do -- that said, they work fine on 0.10, so that's not an issue.\n\nIntl is near and dear to my heart, but I'd be intrigued to see what actual plans are before throwing out 0.10.\n\nAs it stands, if 0.10 is thrown out, that leaves basically 1.8.7, 2.3.0 and 3.3.0 as the only stable versions. 4.0.0 is not yet. It will be, and it's sure intended to be the future, but I really do value backward compatibility too. \n","Hi @aredridel , I understand the concerns. This is only a discussion at this point without any actual commitment. We are looking to understand what the value is, of course. As for promises, we won't be importing any third-party library to do promises, so we would have to look into how to do promises in 0.10 without a `Promise` global available.\n\nWhen we implement any feature, we don't want it to be conditional on the version of Node.js you run on, but available on all supported Node.js versions of Express (thus allowing the user to know that running Express 5.2 on a supported Node..js version, they get all the promised features). Because of this, it makes dropping older versions more important, and hopefully should be possible since Express 4 will be _fully supported, even adding all new possible features from 5 as they come out_ :)\n\nIf we decide to bump the minimum version of Express 5, yes, it would delay Express 5 a little longer to ensure that Node.js 4 is in a more stable condition when this occurs.\n","Yeah. I'm just chiming in in the conversation.\n\nWhat's the reason for not using an ES6-compatible shim for promises? It's usually a small dependency, and can be conditional on native not being available.\n","I just want to note that native promises are still _super_ slow.\n","True that.\n","> What's the reason for not using an ES6-compatible shim for promises? It's usually a small dependency, and can be conditional on native not being available.\n\nWe have tried that on a small scale in koa-related repositories, but it never worked very well, and always ended up better if we only used the global `Promise` function, which most have changed to doing now.\n\n> I just want to note that native promises are still super slow.\n\nAnd, just to calm everyone down on promises, Express and it's dependencies will continue to exclusively use callback-based APIs. The adoption of promises would be in the public API (for those who choose it use it) as well as accepting promises, for those who choose to do so. As in, the current roadmap is a dual API externally, and a callback-based API internally. This should provide people with promises without any performance penalty for those who choose not to use them.\n","Good good.\n","Can you clarify what you mean by \"use promises\"? I was under the impression that just meant accepting a thenable as the return on middleware and routes. That shouldn't require any Promise lib, native or otherwise.\n\n> On Sep 14, 2015, at 8:39 AM, Douglas Christopher Wilson notifications@github.com wrote:\n> \n> What's the reason for not using an ES6-compatible shim for promises? It's usually a small dependency, and can be conditional on native not being available.\n> \n> We have tried that on a small scale in koa-related repositories, but it never worked very well, and always ended up better if we only used the global Promise function, which most have changed to doing now.\n> \n> I just want to note that native promises are still super slow.\n> \n> And, just to calm everyone down on promises, Express and it's dependencies will continue to exclusively use callback-based APIs. The adoption of promises would be in the public API (for those who choose it use it) as well as accepting promises, for those who choose to do so. As in, the current roadmap is a dual API externally, and a callback-based API internally. This should provide people with promises without any performance penalty for those who choose not to use them.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n","Requiring Node 4 would be a pretty huge step up, but as long as Express 4 is still maintained I don't think it's a huge problem.  Just need to make it very clear that E5 is a future forward version.\n","@dougwilson What if we adopted [Node's LTS Plan](https:\/\/github.com\/nodejs\/LTS)? It might not be perfect (and IMO it is very complicated), but at least as a user I only would have to understand a single set of legacy support semantics.\n\nEither way it would be nice to have some documentation (what you should expect) around long-lived major versions.\n","Since Node 4 & ES6 finally came out I think the next main version of Express should eye for the future to be a new brand of itself, especially the main version have a long lifecycle.\n\nDevelopers who want to persist in node v0.10 just only to uphold Express 4, and you have already said that would be also maintained after Express 5 realeased. In my opinion node 0.12 should also not to be considered much about compatible in Express 5, but I know that's not realistic.\n","Correct me if I am wrong but compatibility seems to play a bit bigger role here, think third party modules for express. Compatibility would allow quicker uptake of express 5 if it supports node 0.12 for instance as it would not require and would not rely on developers fixing their modules\/dependencies to make it compatible with new express. Or would not require searching for new ones.\n\nHow would developer know if a module that was used for express 4.0 or 3.0 will work for 5.0? Would I push code to production in this case? I do not know of any automatic tool that could tell me that (idea for greenkeeper.io devs)\n","Hi @ivarprudnikov , nothing in here would make third-party modules not work with Express 5.0. This is simply about a minimum Node.js version for Express. Can you explain how bumping the minimum version of Node.js for Express would break third-party modules for Express? Perhaps I'm missing something critical here?\n","@dougwilson but if module is not compatible with Node > 0.12 ? And the fact that express would require higher (supported) version means there would be additional steps involved in checking if all dependencies work.\nIn the case of existing fleet of nodes, upgrade would require extensive QA.\nIn the case when someone creates new apps, one needs to sanity check if all deps (developer is used to) are compatible with higher node version which on the other hand is a positive exercise.\n","Hi @ivarprudnikov are you not able to do this within a timeline of 1 year? Express 4 is not going anywhere for a long time.\n","Also, if you can point me to specific third-party Express modules that do not function with Node.js > 0.12 , that would help a lot.\n","I am not moaning here, sure I could upgrade, it would just take a bit of time. \nBTW I just checked passport module and their package.json says it supports node>=0.4, also their site seems to be silent about node v4, but still this is important module which is possibly used by lots of devs. I guess it is going to work with new version of node out of the box, but that alone needs verification.\nMy 2 cents :)\n","Almost all Express dependencies have \"node >= 0.8\" or \"node >= 0.6\" but those are minimum versions. They work just fine with Node.js 4, so just seeing low minimums in package.json gives no insight into working with recent versions. I have personally used passport on Node.js 4 without issue.\n\nMy point is that Node.js middleware are typically no where low-level enough to be greatly effected by Node.js versions and I have yet yo hear of a module that does not work.\n\nI'm happy yo include that in the decision if you can point out at least one specific instance that is is an abandoned module.\n","Basically, if a module is not going to work with Express 5.0 right away, it's most likely because it's from an Express change, not because of any Node.js change. For example, a module is going to break with Express 5.0 because it's using an API removed in 5.0 or an API that slightly changed more than anything else.\n","+1 drop support for Node.js 0.10\n",":+1: >= node 4.x.x\n","@dougwilson >= 4.x.x :+1:  or >= LTS versions https:\/\/nodejs.org\/dist\/v4.2.1\/\n","Great example for what this might look like: https:\/\/medium.com\/@clayallsopp\/your-first-graphql-server-3c766ab4f0a2#.asxjuiq0g\n","+1 for dropping 0.10 and 0.12\n","@dougwilson :+1:  >= node 4.x.x\n","drop it like it's hot\n","Hapi.js now \"node\": \">=4.0.0\"\n","It's not like we have to support IE6 cuz people refuse to upgrade.\nYou have the control and can upgrade whenever it's needed.\n\nThe only way to move forward with new awesome ES6 classes, generators async\/wait and other modern open standards is to invalidate old technology.\n\nJust saying: Dropping it!\n","@jimmywarting express is server-side which means this has nothing to do with IE6 :)\n","There's a more practical concern: official support for both v0.10 and v0.12 expires at the end of this year. There will be no further updates to either after Dec 31st.\n","At this rate, we could probably target Node v6. :)\n","Just because a runtime is not supported doesn't mean Express will stop supporting it at the same time. Express should support what the users need supported, which is the purpose of this discussion, to determine if users have objections or other things. Node.js 5.x still works on Windows XP, even though it stopped being supported almost a year ago now, as an example.\n\nA good example of an objection is that I, myself, cannot use Node.js 4.x at this time in some places until some clouds are upgraded, which should happen sometime this year. It doesn't seem like there are very strong objections to 4+ for Express 5+, so with the fact that Express 4 will be supported for at least a year after Express 5 comes out, Node.js 4 may very well end up as the minimum version.\n",">  even though it stopped being supported almost a year ago now, as an example.\n\n[Edited: whoops, mis-understood] Support is dropping in v6, for multiple reasons iirc.\n","> >  even though it stopped being supported almost a year ago now, as an example.\n> \n> Not quite correct. Support is dropping in v6, for multiple reasons iirc.\n\nI'm well aware of that. That's why I specifically said Node.js 5.x and not just Node.js in general.\n","We have any deal? If I want to contribute to Express 5.x, what's the version of Node that I can use?","There has not yet been a compelling \"we can't implement feature x without leaving node.js 0.10\", so the 5.x line continues to support 0.10 for now.","@dougwilson I think we should look at specifying the minimum node version as 4.0, even if it doesn't impact Express.js core directly. The ecosystem impact is much more important, and it would signal things like the ability for authors to use the global `Promise` type instead of polyfills, or `Object.assign` instead of a polyfill, etc. I'm sure there's a lot of authors out there using these things today who don't want to have to deal with node 0.10 support when someone tries to use it. And sure, the module author might be able to specify 4.0 themselves but that's just moving the burden from us to them when it comes to their users.","We can improve Express code base with Node.js new features. I think that a project like it have a strong power to push Node forward.\r\n\r\nIf the only benefit was syntax, we can use Babel to transpile to old versions. What do you think?","I mean, simply changing internal syntax to more sugar which has no benefit to users is a net negative benefit to me, because now we are taking away something without any compelling user benefits. The reasons Blake outlines are much better and we can bump 5.0 once something along those lines are needed. In the meantime the 5.0 branch is just 0.10.\r\n\r\nAnother issue with changing all the syntax in 5.0 is that we will continue to maintain 4.x and merge into the 5.0 branch with every release for a year or longer after 5.0 release, so if the code is too drastically different without any user benefit, it makes simply maintaining express way harder for no reason.","> If the only benefit was syntax, we can use Babel to transpile to old versions. What do you think?\r\n\r\nThe way i see it is: It's only meant to run on the backend, It doesn't have to have to work for multiple clients like it's on the web. If the minimum requirement is version x, just update you node version it's not that hard... therefore using babel and transpile it to worse code is a unnecessary step and make it more complicated and just adds up more time waiting for it to compile durning developing and auto testing.\r\n\r\nI really wish node has some kind of auto update so that we don't have to make it backwards compatible cuz some ppl never update \ud83d\ude20 \r\n\r\nI would not mind seeing a error message that it requires version 7. I would gladly update my node version. ","I am in support of upping the min to 4.0, but I am completely against using babel or any transpilers in the core packages, and am also against changing the syntax in core package for the \"sake of change\".  That being said, there are some perf and readability improvements we can make if we start using some of the new stuff where appropriate.\r\n\r\n> It's only meant to run on the backend\r\n\r\nNot true, I am running, or plan to run, most of this code in the browser.\r\n\r\n> I would not mind seeing a error message that it requires version 7. I would gladly update my node version.\r\n\r\nThis is NOT the feeling of the rest of the ecosystem.  Upgrading node versions in production is something we try to avoid doing more than every few months.  And an important package like Express cannot force this.","P.S. I like everyone's use of the emoji reactions. I feel like it actually adds to the conversation when reading it without too much text noise.","@dougwilson I agree with you. The focus is users, but, we are users too. For contributors, it's fun to play in a updated code base (actually, Express code base, in my opinion, it's really awesome).\r\n\r\nI agree with @jimmywarting, in this case, if anyone have to use some older Node version, they can use an older version of Express. If they want the newest things, they should to update their Node version. With this, we are pushing Node & Express forward.",">  it's fun to play\r\n\r\nI agree, but please do not \"play\" in the code that powers the website that pays my bills.  I recommend you take a look at the work being done in [pillarjs](https:\/\/github.com\/pillarjs) and [jshttp](https:\/\/github.com\/jshttp), and just build your own \"play\" project.\r\n\r\nThat being said, I am in support of the min version change to node 4.x, so don't construe my comments as against the main point of this issue.","Out of curiosity, why Node 4.x and not 6.x? Would it be possible to keep the releases of Express in sync with LTS versions of Node?","@yawetse Express supports 6.  In this case we are talking the minimum supported version.  And 4.x is still widely used.  So the main changes that would be based on this discussion would actually start using features not present in <4.x.  So chancing this discussion to <6.x is pretty much out of the question because of the broad usage.\r\n\r\n** If you look above, the main core team is not even fully in support of dropping 0.12, cant imagine going even further :)","@wesleytodd got it, makes sense. I apologize for not reading the full thread previously.\r\n\r\nI know Express supports 6, but I think if you're starting a project today, then you might as well start on Node LTS, and by that logic, if you're building a new Express app today, then it should have on its min requirements Node LTS.\r\n\r\nIf you have an existing Express app that's working for you, nothing would force you to migrate to Express 5. But given what you said about the state of the current conversation, this seems extremely unlikely.","@wesleytodd You are being literal. Currently, I'm using this project in production, so, I want the best for it and I want to contribute too. I don't use any word of your comment. ","@yawetse I think the concern is that if we do not continue supporting the older versions, it takes even longer for users to all get upgraded to 5, and the team then has to continue to support the old version of Express.  So the goal is to get the largest adoption as quickly as possible, users of old Node included.  FWIW, I totally agree about starting a new project, but that is not what Express core is.\r\n\r\n@matheuslc Sorry if I miss-understood your intent with the above comment.  I just meant there is a difference between learning new features of the language, and supporting an important, widely used and deployed project.  And this is not the place to try out new features IMO.","@wesleytodd Sometime we have to do it. Why not now? I'm not saying that we have to use the latest Node version, but we have to start it anytime. Node was in the version 7, maybe version 4 it's a good start point. The longer we take to do this, the worse it will be in the future.","@matheuslc I don't disagree that we are not some kind of user persona as well, but an issue that we would have to contend with is the fact that we are going to support Express 4.x for at least an entire year after Express 5.0, so if the code bases diverge too greatly, performing the merges from 4.x into 5.x will become more and more painful. The argument to use an older version of Express is valid, and is certainly why we are going to maintain it for years to come, but if we make maintaining Express 4.x itself a burden that we cannot merge & maintain, then the argument to \"just use an older Express\" is not a valid one to make, since it's not being maintained.\r\n\r\nMy assumption has been that once Express 5.0 came out, the 4.x\/5.x dual support would work exactly how the dual support for 3.x\/4.x worked: all new features continues to land in the older version as long as they are possible there and they are simply merged up into the new version. This is especially important for bugs, since bugs are the primary thing we would be doing in 4.x.\r\n\r\nI hope that makes sense at least where my mind is at. I think that the discussion for rewriting the internals of Express in ES6 is certainly _related_ to the discussion of bumping the min version of Express, but not exactly the same discussion, because even if Express bumps the minimum to 4 or 6, that still doesn't mean we would rewrite the internals in ES6, as that is a separate discussion, which needs to take into account things like what exactly is the support story of how Express 4 continues to work when the code between the two are so different they are unmergable.","Awesome guys. Let's do it!","@dougwilson I presume that accumulating opinions for 3 years was quite enough :). Was there any decision in the end? Also if any help is needed to convert some of the old code to ES6, I absolutely volunteer :).","Hi! Thanks for volunteering! You can see my thoughts on a ES6 rewrite in my previous post above. If you can help make some proposals on how to overcome the issues brought up above, that would be the first please to start.","@dougwilson Would it be an option to use Babel for Express 4 to transpile distributed code into something 0.10 would understand? Unrelated question: is there any work towards Express 5.0 that could be picked up by someone new to Express codebase?","I'm not familiar with Babel, so can't say either way, but it would be if you know it is, haha. All the Express 5.0 code is on the 5.0 branch.","@dougwilson Idea behind Babel is transpiling JS code that is written in newer JS syntax (e. g. ES2017 or ES2016) into equivalent JS code in older syntax. Its main purpose is compatibility with older browsers (*cough* IE), but it should work fine with Node.js as well. If you think this is a viable way forward, I can work on PR for an npm script that would put transpiled code into \/build folder. Npm publishing configuration will also have to be adjusted to only publish the transpiled code, but I would need your assistance with that as I obviously have no means to test Express publishing pipeline :). Yeah, I understand that Express 5.0 code is in its branch, I'm mostly wondering if there is some work that is currently lying around unassigned and would speed up 5.0 release if taken :).","The issues are labeled with 5.x label. Keep in mind that many people require files in Express module directly, so that needs to work after whatever you're talking about. For example require('express\/lib\/utils') needs to continue to work on 4.x releases, it cannot suddenly become require('express\/build\/lib\/utils') or it will break existing 4.x apps.","@dougwilson Yes, I understand that. Published module needs to retain exact same structure as it does now. Since NPM doesn't natively support that, I'd have to get creative, but it appears to be doable: https:\/\/stackoverflow.com\/questions\/38935176\/how-to-npm-publish-specific-folder-but-as-package-root","I don't want it to be transpiling with Babel. I rather want it the way it already is then. Transpiling means it get harder to debug and it and the over all size, compile time and complexity gets larger. \r\n\r\nI think we should follow nods LTS. \r\n\r\nThe issue started with dropping support for node < 4 and now you want to add Babel for compatibility with older version...! A bit of track if I may say so.\r\n\r\nCode that runs with Babel are actually slower and I don't want that for a server that needs to handle many connection.\r\nNewer features brings micro optimization and mimic what it dose with Babel is not as good","Not to be controversial or anything but Node LTS for v4 is due to end on 2018-04-30 as described on the [Node release schedule](https:\/\/github.com\/nodejs\/Release)\r\n\r\nIf we don't think that v5 of Express will be released before then I would be up for **dropping support for even node v4**. \r\n\r\nNow it's unlikely that we would get much support if we did that, but I think \u261d\ufe0f this kind of thinking should at least draw the line under all pre-v4 versions of node. They are out of date and anyone who wants to use Express with them should be comfortable locking to `express: ^4` in their package.json.","Publishing a transpiled ES5-only build of expressjs also kind of feels pointless. We're not browser bundling express, so we always have the option of including both the ES2015+ source compatible with the current node LTS and the transpiled version compatible with older node.js and just using feature tests to require the correct version for the environment `\/* ???.js *\/ module.exports = <supports 8.x features> ? require('src\/???') : require('build\/???');`.","I think it is a really bad idea having any \"official\" transplied version of express, because if it is official then it needs to be supported.\r\n\r\nDon't forget that Node 0.12 was End of Life over a year ago now, and as the LTS documentation suggests **it is no longer getting any security patches**. If we release anything that is specifically to support versions that have reached EOL then we are in a way complicit in encouraging people to still use versions that they really shouldn't be using in production.\r\n\r\nI understand that there are legacy concerns for enterprises etc but in those cases, our default position should be \"Lock your package.json to v4\"","@jimmywarting @mansona @dantman Please read https:\/\/github.com\/expressjs\/express\/issues\/2755#issuecomment-279887674. While I myself would approach this in a more straightforward deprecation way, it is ultimately maintainer's call to make, and he has made it. According to the latest statistics, 0.10 makes around 20% of all Node.js installations, and decision was made not to abandon them. Hence our question is not \"Drop or not drop 0.10 for 4.x\", our question is \"How do we get ES6 in 4.x at all\".\r\nSpeaking of performance - do you have any benchmarks to reinforce that claim? Older Node.js versions are kinda terrible at optimizing ES6 code execution and it used to perform consistently worse than ES5, so I wouldn't be surprised if certain code would actually work faster after transcompilation.\r\nDebug concern is definitely valid, though. I'm thinking that it might be possible to \"pseudo-transpile\" original unmodified code into something like \/dist-es6 folder with modified package.json that would be published as a separate package so that whoever wants it could opt-in into ES6 4.x version, but that's something I would have to discuss with @dougwilson.","@dantman Dynamic imports with feature tests is definitely an interesting idea, though, I'll definitely consider it in implementation, as that would simplify publishing process a lot.","I think that dropping support for Node.js 0.x is absolutely the right thing to do for Express 5. But that doesn't mean that we have to rewrite it in ES6 just because it's fun...\r\n\r\nWe need to continue support for Express 4 for a long time, and Express 4 can never drop support for Node 0.x (that would breaking and then it would be Express 5).\r\n\r\nIn order to be able to easily backport patches from Express 5 to Express 4 we want to keep the codebase as similar as possible. While one way to do that is to rewrite both to use ES6, and then babel the Express 4 code before sending it to npm, I don't really see the benefits with that...\r\n\r\nApart from how express looks on the inside, would there be any benefit to the consumers of express should we rewrite it in ES6?","@LinusU ES6 is not meant for consumers of express, it is entirely for the benefit of express developers. So the benefit of consumers would be increased productivity of developers and decreased amount of bugs (due to stricter variable scope\/mutability checking, less boilerplate etc)","The thing is, I don't it will be less work for us since the work for backporting patches to Express 4 will be much more than otherwise.\r\n\r\nStill, I like ES6 as much as the next guy, and I think that we should get there eventually. But Express is a really big project and has a ton of users.\r\n\r\nIn this case, I think it's better to be a bit conservative and focus more on the consumers of the library then the developers.\r\n\r\njust my 2\u00a2","@LinusU Hence the plan to use Babel in Express 4. Then no additional work for backporting patches would be necessary at all.","Yeah, that could potentially work. Although I personally don't think that the increased complexity would be worth it...","Sorry I am a bit late to the discussion here, but here are my thoughts:\r\n\r\n### Dropping support for node versions in `5.0`.\r\n\r\nWe should officially drop support for everything before the current LTS version at release time.  Older versions will probably still work, but that doesn't matter, we will not officially support it.  It looks like that will probably mean everything before node 6 at the current pace.\r\n\r\n### Transpiling with Babel\r\n\r\nI think this is very bad path, and we should avoid it for all express modules and dependencies.  It introduces bloat, difficult debugging and increased chance of buggy code.  This opinion comes from having deploy and supported servers transpiled with babel, not just speculation.\r\n\r\n### Goals for introducing `ES*` into Express\r\n\r\nWe should take it slow, and only implement thing that are better for users.  This would include things like:\r\n\r\n- Performance improvements (if a new feature is faster)\r\n- Security improvements (if we have to change something because of a security issue and there is a good es next way to do it)\r\n- Better user facing API (for example, promise\/async\/await support)\r\n\r\n### General thoughts on these kind of changes\r\n\r\nI think it is a real shame that so many people are being taught that \"using ES6 is better\" without taking any time to think about WHY.  I am with @LinusU when I say that I like ES6 as much as the next person.  There are a TON of features in the language now which are great, and we should be focusing on being relevant.  But more importantly we should focus on the service we provide to our users, which is being a reliable and stable server.  So lets stick to doing that, not rewriting code as an \"academic adventure\".\r\n\r\nAlso, people keep saying things like \"es6 is more maintainable\" & \"write es6 because it is better for the developers\".  But in most cases the things people are doing to \"improve developer experience\" is adding complicated tooling (like suggesting Babel).  **Which does the opposite of improving developer experience.**","@wesleytodd So what you are saying is \"No ES6 before Express 6\", right?","No, `5.0` will probably drop during the LTS for node6.  And node6 has a ton of es2015 features.  So IMO, the outcome of this issues discussion should be: start using node6 compatible es2015 features in your PR's to express projects.  But I would like to hear @dougwilson's opinion on that statement.","For reference: http:\/\/node.green\/","Also, I should have specified:\r\n\r\nWith my above stance, we will have to do a small amount of back porting work.  I think this is an acceptable consequence for staying relevant.  But where work is too far divergent, we should reign in usage of new features to keep that amount of work small and manageable.","@wesleytodd Agree 100% with all you are saying \ud83d\udc4d thanks for taking time to write it all down.\r\n\r\nI just have one small thing that we should think about:\r\n\r\n> Older versions will probably still work, but that doesn't matter\r\n\r\nI'm quite sure that this actually happened before with express (maybe with 0.6, need to look it up, anyhow...). We didn't officially support it, but it still worked. At some point, we introduced a commit that broke 0.6 compatibility, and released it in a patch release.\r\n\r\nNow, we didn't officially support 0.6, but people were still using it, and thus they opened issues complaining. I don't remember how we solved it, I think we fixed the compatibility.\r\n\r\nIn the end, we don't want to break the end user, and unfortunately I don't think that people read, but rather just install. So if it works on Node.js 4 when we release it, I think that people will both use it, and complain when we break it.\r\n\r\nI think it would be smart to add some guard that would hard fail it straight from the beginning, just to prevent people trying to use it without reading which runtimes we support...","> I think it would be smart to add some guard that would hard fail it straight from the beginning, just to prevent people trying to use it without reading which runtimes we support...\r\n\r\nI like this idea.  And fully agree with were you are coming from on it.  Couldn't we also use the `package.json` `engines` field?","@wesleytodd This directly contradicts what @dougwilson was previously saying. I'm not arguing with you, I would prefer more aggressive migration stance as well, but I make an assumption that this is something that maintainer is supposed to make decision on.","I can see how @dougwilson and my opinions differ, but I think \"directly contradict\" is a bit strong :)\r\n\r\nAnd that is why I said \"I would like to hear @dougwilson's opinion on that statement\".  I am in favor of a *slightly* more aggressive migration path than we are currently using.  But there is a difference between \"more aggressive\" and \"re-write it all in ESnext\".","@wesleytodd True :)","Hi all, sorry I am traveling today so my access is off and on. I read through all the comments and will definitely write up my thoughts when I'm at a computer soon :) The thoughts in https:\/\/github.com\/expressjs\/express\/issues\/2755#issuecomment-365011388 from @wesleytodd most closely align to my thoughts and is nicely worded. I will provide further clarity on my thoughts later today when I don't have to type them on a phone, but was hoping this would at least help a little in the meantime.","@wesleytodd Btw, there was an idea voiced earlier about dynamic Express.js imports based on feature checks - then those who are using more modern Node.js and do not rely on direct imports would get the proper non-transpiled version. Do you see any problems with this plan?","> Do you see any problems with this plan?\r\n\r\nYes I do.  It is more code to maintain, and unless we were exposing a different interface to the user, they wouldn't even get any benefit.  So there is no upside to doing such.","It's my hope the Express team will drop support for unmaintained versions of Node.js as soon as is feasible.  Mocha has already dropped support for v0.10 and v0.12, and will drop support for v4 ASAP.\r\n\r\nFWIW, \"dropping support\" does not imply \"rewriting\"; it can be as straightforward as removing the version from the matrix in `.travis.yml`.","We already confirmed we are dropping support for them in 5. What still needs to be clarified?","@dougwilson Sorry, it sounded like it was somewhere short of \"official\"--I saw v0.10 and v0.12 were dropped already, but not v4.  But if that's the plan, then great!  \ud83d\udc4d ","When 5.0 is released it will support down to the LTS version at that time.","xref: https:\/\/github.com\/expressjs\/generator\/pull\/244#issuecomment-562680659\r\n\r\nits not clear what \r\n\r\n> When 5.0 is released it will support down to the LTS version at that time.\r\n\r\n4052c15c7f10b79fb7c54f3837ffe118f7a99811 was first alpha, in 2014... but 5 is still in alpha, in 2019, and at this moment the only supported Node.js version are 8.x (until January 1st), 10.x, 12.x, and 13.x, see https:\/\/github.com\/nodejs\/Release#release-schedule\r\n\r\nIs it possible for 5.x to drop support in the middle of the multi-year alpha process?\r\n\r\nShould 5.x be left in alpha, perpetually, and 6.x be the new alpha, with only support for 10.x and later?\r\n\r\nThese are questions larger than whether the default express-generator output installs a version of pug with security vulnerabilities, so this is likely a better place to discuss.\r\n\r\n","> Is it possible for 5.x to drop support in the middle of the multi-year alpha process?\r\n\r\nSure, why not? Is there some reason why we couldn't do this?\r\n\r\n> Should 5.x be left in alpha, perpetually, and 6.x be the new alpha, with only support for 10.x and later?\r\n\r\nNo.","> Is there some reason why we couldn't do this?\r\n\r\nThe outcry from users of 5.x-alpha, who did not pay attention to https:\/\/semver.org\/#spec-item-9\r\n\r\nShall I PR a drop of EOL node from appveyor.yml, .travis.yml, and package.json to master? And is that the only things needing changing?","Would it be different than the outstanding PR https:\/\/github.com\/expressjs\/express\/pull\/3948 ?","@dougwilson I think it is a good idea to drop old Node versions. It would speed up the development process and allow to implement new features. Do you plan to keep support of Node <10 in the next release (`5.0`)?","@dougwilson Now that node 10 is EOLed, would it be a good idea to drop support for it as well?","As a consumer of express, I'm perfectly okay with current major versions only supporting  current, active, and maintenance releases of Node.JS at the time of their release. If I want to use a version of node.js that is no longer maintained, it makes sense that I would need to use an older release of express, that might not be maintained. ","Related: https:\/\/github.com\/pillarjs\/router\/issues\/103\r\n\r\nThe `express` v5 release is getting some traction. Would be great to collect definitive feedback on this and move forward.\r\n\r\nI vote to drop support for `node` < 10, which is what `path-to-regexp` is doing.","> I vote to drop support for `node` < 10, which is what `path-to-regexp` is doing.\r\n\r\nSounds good to me \ud83d\udc4d ","@dougwilson Do you think we've gathered enough feedback on this? This issue has been open for almost 7 years and I haven't really seen any strong argument against the move. I don't think we'll be getting much more than this. Would be nice to move on.","Yes, this issue has plenty of feedback. There is no need for more, as stated above it was already decided upon. This is essentially now a tracking issue for landing the change. I'm going to lock it to prevent further comments that are no longer needed."],"labels":["5.x"]},{"title":"Trailer header field included with 304","body":"Including the `Trailer` header field with responses that don't have `Transfer-Encoding: chunked` causes some (overly strict?) proxies to drop the response e.g. IBM Bluemix sends back a 502 instead of the response generated by Express.  \n\nI think a possible solution here would be to remove the Trailer header field for 304, in addition to the fields currently removed.  Here is where that code lives: https:\/\/github.com\/strongloop\/express\/blob\/f73ff9243006ea010fffdaa748f06df3a5b986e7\/lib\/response.js#L192\n","comments":["Would it make sense to also move trailer values to the header of the 304 response here-ish?\n","> Would it make sense to also move trailer values to the header of the 304 response here-ish?\n\nBy their nature, the trailing values won't even be available until after the application has finished sending the response body (since, for example, they may be calculating a MD5 hash).\n\nRight now, the fact that you can write a body in a 304 and it doesn't actually get sent is all handled by Node.js core HTTP. Perhaps that may be the better place to add this functionality?\n","Thanks!  You're of course right and the trailer won't be known until the response finishes streaming, which defeats the purpose. \n\nI'll open an issue for Node about Trailer. \n","@dougwilson @wprl so can we close this?\n","This is actually a bug. Changing the labels.\n","Is sounds like the spec allows a response to have a `Trailer: ...` header without the matching trailer.\nIt sounds to me like the proxy should be allowing this valid response through.\n\nThe user (ie app\/middleware author) could also prevent this issue by not adding a `Trailer: ...` header to responses that are not `chunked` (including `304`s which shouldn't be `chunked`).\n\nIs there really a bug in Express to fix here?\n\n**EDIT**: Prematurely hit \"Comment\", added the rest in via an edit.\n","Yea, @tunniclm, I sort of agree :) You see, by default Node.js will send responses chunked, but the Express helpers actually force them to non-chunked, which is a more efficient data transfer mechanism and easier to parse for a lot of clients. Ideally Express needs to be a lot smarter around this and how it decides to send the response out according to the headers that were built up before writing them.\n","Do you still think this is a bug, or is it something that can be addressed as an enhancement?\nAnd what are you proposing we do? If we can define the goal of a change more explicitly, I'm happy to have a go at making it.\n"],"labels":["bug","4.x","5.x"]},{"title":"Question: Is there a way to identify a route and create href link to it?","body":"Hi there,\nI'm using Express for what I imagine to be a large project, and I have many href links inside my views. I **do not** want to hardcode them at all! Any time I change something I must go and search in the code in order to make it work.\n\n_Short story_: how can I track back a route, so I can use this in views:\n\n``` html\n<a href=\"{{ url('route_id') }} \/> <!-- \/\/ as you don't mind what the template engine is -->\n```\n\n_Long one_: I've searched for a day about routing in Express and I found a few \"reverse\" routing packages, ALL of them quite broken - they either don't work with `Router()` or they create new Router every time, etc.\nI got to know all the Layers and stacks that the Routing part creates. I understand that you guys want order in routes, as well as multiple handlers for the same path. I agree with all that.\n\nBut isn't there some easy way to add ids for those routes? I found that if I simply use\n\n``` js\napp.use('\/path', function namedFunction(req, res, next) {});\n```\n\nI get `namedFunction` as a name of the Layer in the stack, which is great. But if I use router (like `router.route('\/path').get(...).post(...)`, then the Layer is named `router` and inner stack contains `anonymous` functions.\n\nMy idea here was that after I add all routes, I can browse `app._router` and it's stacks, getting names of routes, then using a function with name parameter so I can construct back a route.\n\nAm I missing something, or there is **no** way to make this easy working? I can't imagine someone having 100+ routes in a project, that hardcodes their links inside it - I just refuse to think of it :)\n","comments":["Come on guys, what's up, not even a single comment? No one reading those issues?\n","Hi! Yes, currently it's not possible, especially when you start to think about how we actually allow your middleware to alter `req.url`\/`req.method` and we continute to route based on these new values! Basically, the way our router is written, you cannot actually figure out the destination without executing the stack with a real request.\n\nI believe, though, there are third party modules (I think part of kraken?) than provide this functionality, though.\n","Thanks for the answer, @dougwilson ! I've just seen their [enrouten](https:\/\/github.com\/krakenjs\/express-enrouten\/) package. It does some pretty magical stuff that I'll have to deeply investigate tomorrow and see if I can use. Thanks for that!\n\nOtherwise - is it really that bad idea to check if one of the params passed to the router is `String` (as they are all now checked to be `Function`), and if so - set it as a name of the Layer? Because now the name is set to the function name (which is sometimes undefined) and moreover the nested layers are all anonymous I guess because of [this](https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/router\/index.js#L498) bind, right? I guess if it's because of it, there should be some pretty simple solution to at least set proper name to the router, and let people like me browse them however they like :)\n","+1 to this, will allow nested routes a breeze too.\n\nCurrently I'm doing the following, which is not the most pretty thing out there but it works :) (I tested several reverse packages too and didn't liked the results):\n\n``` js\nglobal.erp.app.set('route:organizations', global.erp.app\n    .route(global.erp.config.get('api:prefix') + '\/organizations')\n    .get(require('.\/routes\/index'))\n    .post(require('.\/routes\/create')));\n```\n","I created a PR for support for named routes in the Router project if anyone from this issue wants to comment - https:\/\/github.com\/pillarjs\/router\/pull\/36\n","Is there still no way to generate urls to routes instead of hardcoding paths all over the place?","Hi @edevil, I think you should go read the conversation on that PR linked by @sjanuary.  I have not seen any finalizing progress on it, so if you can re-ignite the conversation in a productive way that would be great!\r\n\r\nIf I can give some feedback, I think your approach here could use some refining.  It is usually better to only comment when you have something constructive to add to the conversation, so a better way to phrase the sentiment maybe would be \"Is there anything I can do to help get this feature?\".  That way we as the maintainers would be very willing to help point you in the right direction, as I did above.  Happy contributing!","@wesleytodd I didn't mean to sound dismissive. Since I am new to the Node ecosystem and this was an open ticket with more than 2 years without activity, I really thought that there was something more and it had simply been forgotten.\r\n\r\nRegarding https:\/\/github.com\/pillarjs\/router\/pull\/36, it also seems stalled, depending on https:\/\/github.com\/pillarjs\/router\/pull\/29 which is also stalled. Is this the router that express uses underneath?","Hey, I understand it looking forgotten.  It takes someone championing the topic to push things forward, sometimes pinging on a topic for a while to get people's attention.  Yes pillarjs router is the express router, but for the next major release we are working on.  This would be a great feature to get landed before then, so maybe you can start some conversations over there on how you think we can move it forward."],"labels":["4.x","question"]},{"title":"Fixed #2575","body":" Fixed #2575,res.links() can accept an Array as the arguments\n","comments":[],"labels":["pr"]},{"title":"Extend res.links() to allow adding multiple links with the same rel","body":"Currently, `res.links` allows to only add a single link per rel per call. One can add multiple link with the same rel through calling `res.links` multiple times. #2575 would also allow to add multiple links with the same call. Both of these methods are, however, quite cumbersome when one wants to simply add multiple links with the same rel and without optional parameters.\n\nA possible alternative would be to allow the following:\n\n``` js\nres.links({\n  self: '\/a',\n  item: ['\/a\/0', '\/a\/1']\n})\n```\n\nNote that this would currently result in `Link: <\/a>; rel=\"self\", <\/a\/0,\/a\/1>; rel=\"item\"`, which is incorrect - the path may contain commas, so \/a\/0,\/a\/1 is a single path. The expected result would be `Link: <\/a>; rel=\"self\", <\/a\/0>; rel=\"item\", <\/a\/1>; rel=\"item\"`.\n","comments":[],"labels":["enhancement","4.x","5.x"]},{"title":"Consider using conventional-changelog to generate changelog","body":"we have [conventional-changelog](https:\/\/github.com\/ajoslin\/conventional-changelog) or [conventional-github-releaser](https:\/\/github.com\/stevemao\/conventional-github-releaser) (there are also grunt\/gulp tasks) to automate the process of writing the changelog. As you are using formatted commit messages so the logs can be generated well according to the parts of the message. We use handlebars for templating the logs. It can also ignore reverted commits. There are many other features. We have a jquery preset for people using jquery commit format.\nThe modules are actively maintained.\n","comments":["Sample logs\n\n### build\n- add AppVeyor ([028abf5](https:\/\/github.com\/strongloop\/express\/commit\/028abf5))\n\n### deps\n- accepts@~1.2.4 ([117d0c9](https:\/\/github.com\/strongloop\/express\/commit\/117d0c9))\n- ejs@2.3.1 ([adb6069](https:\/\/github.com\/strongloop\/express\/commit\/adb6069))\n- istanbul@0.3.6 ([1507757](https:\/\/github.com\/strongloop\/express\/commit\/1507757))\n- jade@~1.9.2 ([e56141a](https:\/\/github.com\/strongloop\/express\/commit\/e56141a))\n- serve-static@~1.9.1 ([ce1abd9](https:\/\/github.com\/strongloop\/express\/commit\/ce1abd9))\n- should@~5.0.1 ([fa546bf](https:\/\/github.com\/strongloop\/express\/commit\/fa546bf))\n- type-is@~1.6.0 ([e03ed05](https:\/\/github.com\/strongloop\/express\/commit\/e03ed05))\n- update example dependencies ([9a8cf77](https:\/\/github.com\/strongloop\/express\/commit\/9a8cf77))\n\n### docs\n- update badges ([3882ba4](https:\/\/github.com\/strongloop\/express\/commit\/3882ba4))\n\n### examples\n- fixes to mvc example ([24fce9d](https:\/\/github.com\/strongloop\/express\/commit\/24fce9d)), closes [#2534](https:\/\/github.com\/strongloop\/express\/issues\/2534)\n\n### tests\n- add extra setCharset tests ([53e5991](https:\/\/github.com\/strongloop\/express\/commit\/53e5991))\n- fix error-handling typo ([8fe5fd8](https:\/\/github.com\/strongloop\/express\/commit\/8fe5fd8)), closes [#2557](https:\/\/github.com\/strongloop\/express\/issues\/2557)\n- improve res.download tests ([ca480d7](https:\/\/github.com\/strongloop\/express\/commit\/ca480d7))\n","Oh, neat! is there a way to disable the git commit links using the tool? I usually don't want to link to commits, as it assumes that we don't rewrite history and that we'll always be on GitHub.com . One other question is for deps, I always include the dependency's own change log inline so the change message is more meaningful. Is it possible to do that as well?\n","Its possible to disable the git commit links as it's using handlebarsjs. Btw you could always regenerate all your changelogs. For the deps, the git history isn't in your parent module so it's not possible. Why don't you just give a link of the changelog of the deps when you bump a dep in the parent module in the commit message? Or even copy and paste the deps changelog in the commit message?\n","> Btw you could always regenerate all your changelogs.\n\nSo a simple `git rebase` would noe require me to stop a every commit and regen + re commit? We build our change log on every commit, not just on release, so it would be very tedious to throw this in. I think simply leaving out the commit hashes would be best (which I see you said it could do).\n\n> Why don't you just give a link of the changelog of the deps when you bump a dep in the parent module in the commit message? Or even copy and paste the deps changelog in the commit message?\n\nSo we don't provide links because it doesn't help people understand the difference when they are not online and it requires us to keep changing the history file whenever one of those moves (and also assumes the changelog is even accessible on the Internet at all, which is no guarantee, as something may be published to npm without a public repo).\n\n> Or even copy and paste the deps changelog in the commit message?\n\nWe could, but how will they show up? I see in the example you pasted above, it seems to just smash everything on one line (like you can see those \"closes ...\" are in the body of the commit messages, yet appear on the same line in the history). Could we get them to appear as indented bullets like we do today?\n\nAnother question for sub dependencies, if those sub dependencies then change to use this format, their change logs will no longer be a simple list, but a list with titles, etc. How can we easily translate that here as well?\n\nI ask because I'm very interested in your module and I understand the purpose of it is to automate these things :) But I'm not willing to loose what we have now in order to get it.\n","Another thing that would help is if you could provide an example of how to generate that log you pasted above, or a PR that does :) Otherwise if I have to figure out how to invoke it, it may be a long time before anything is ever done to start using it.\n","> We could, but how will they show up? I see in the example you pasted above, it seems to just smash everything on one line (like you can see those \"closes ...\" are in the body of the commit messages, yet appear on the same line in the history). Could we get them to appear as indented bullets like we do today?\n\nBecause we are using handlebarsjs to template, in essence if handlebarsjs is able to do this we could. The format of your sub deps would depends on the markdown you put in the commit message. So I believe this is yes.\n\nAn ideal commit message would be something like this\n\n```\ndeps: type-is@~1.6.4\n\nThe changes are\n- blabla\n- blabla\n```\n\n> Another question for sub dependencies, if those sub dependencies then change to use this format, their change logs will no longer be a simple list, but a list with titles, etc. How can we easily translate that here as well?\n\nAre you saying to transfer another modules changelog to a module and modify the format\/contents a bit? This is out of the scope of my modules I believe. I think if you want to link two modules changelog it's really better to put ones in another's commit messages. This way it's even easier for people to view both logs (eg `git log`). \n\n> Another thing that would help is if you could provide an example of how to generate that log you pasted above, or a PR that does\n\nThis is generated by `conventional-changelog -p jquery` as the format of jquery message is almost the same. But since you want some templates\/settings just for express we could add an `express` preset so you'll just need to do `conventional-changelog -p express`. Again there are grunt\/gulp wrappers.\n","https:\/\/github.com\/stevemao\/conventional-commits-parser is the parser we use to parse the messages. \n\n> The format of your sub deps would depends on the markdown you put in the commit message. \n\nMeaning we don't parse the messages of the body part because this is usually long paragraph(s) so you could format using markdown by yourself in the commit. The header is the place usually you put different short parts of the message. In the footer you could put some important notes. But I believe you could put your sub deps information in the body.\n","Ah, gotcha. What would it look like to even make customizations, like customizing the templates? We don't (currently) use gulp\/grunt, so hopefully it won't require that we use that to use this module, or it may be a long time before we get around to adopting.\n\nAlso, I forgot to ask, but is it possible to leave things out of the change log? For example, we never list things starting with \"tests:\" or \"build:\" or \"examples:\" or \"docs\" (really, everything except \"perf:\" and \"deps:\") in the changelog, so if it's possible to have this generator skip those commits, that would be ideal as well :)\n\n> Meaning we don't parse the body part of the message because this is usually long paragraph(s) so you could format using markdown by yourself in the commit message. \n\nWould the body show as indented for the commit message in the changelog (like we do today with the sub dependencies)?\n","In the end, the change log right now is not hand-done, but done using scripts. This means that without getting some commands provided to us to use this module (perhaps a PR?) without us doing a lot of research just it's a large incentive, because the current changelog is fully automated already. I'm definitely interested in using something not hand-rolled, but I have pretty much no spare time to do any reading on how to get this module put together to give what we have now, so the more you can provide, the better the changes are for us to switch :)!\n","> What would it look like to even make customizations, like customizing the templates? We don't (currently) use gulp\/grunt, so hopefully it won't require that we use that to use this module, or it may be a long time before we get around to adopting.\n\nthe gulp\/grunt wrappers is pretty much a shortcut of using the cli. As I said we could create an express preset that holds all templates\/settings just for express. (gulp\/grunt has nothing to do with the template)\n\n> Also, I forgot to ask, but is it possible to leave things out of the change log? For example, we never list things starting with \"tests:\" or \"build:\" or \"examples:\" or \"docs\" (really, everything except \"perf:\" and \"deps:\") in the changelog, so if it's possible to have this generator skip those commits, that would be ideal as well :)\n\nYes. You could also change the name `perf` to `Performance` and `deps` to `Dependencies`.\n\n> Would the body show as indented for the commit message in the changelog (like we do today with the sub dependencies)?\n\nIs the body indented because of markdown (I think it is)? As long as the template generates the same markdown its indented right? \n\n> In the end, the change log right now is not hand-done, but done using scripts. This means that without getting some commands provided to us to use this module (perhaps a PR?) without us doing a lot of research just it's a large incentive, because the current changelog is fully automated already. I'm definitely interested in using something not hand-rolled, but I have pretty much no spare time to do any reading on how to get this module put together to give what we have now, so the more you can provide, the better the changes are for us to switch :)!\n\nI understand. I will definitely do a PR.\n","It would be helpful if you could provide the markdown of a release as a sample, and I'll make a express preset that generates the same markdown (Although you'll need to write more in the commit message just for the deps you mentioned).\n","Awesome! I'm not quite sure, are you asking me to provide something? Something more than simply the Markdown we have in our History.md file right now? Let me know what I can provide :)\n","If I were to put the changelog of the upstream dependency within it's commit message, it would look like this:\n\n```\ndeps: type-is@~1.6.4\n\n  * deps: mime-types@~2.1.2\n  * perf: enable strict mode\n  * perf: remove argument reassignment\n```\n\nBut also note that since I've never done this before, the exact format is up for compromise or whatever :)\n","Sorry I didn't see that file. I was looking at your github releases :) we have conventional-changelog or conventional-github-releaser that can do both.\n\nI think that commit message will work. In the meanwhile, I believe you need to add a commit message guideline and state that clearly in it (you could see jquery's as an example). the deps commit would be a bit tricky I think. It would be good for people who contribute and for me as a preset reference.\n","Hi @dougwilson \n\nJust letting you know that I've created a [express branch](https:\/\/github.com\/ajoslin\/conventional-changelog\/tree\/express) and based on sample commits:\n\n```\ndeps: type-is@~1.6.3\\n\\n - deps: mime-types@~2.1.1\\n - perf: reduce try block size\\n - perf: remove bitwise operations\nperf: use saved reference to http.STATUS_CODES\\n\\ncloses #2602\ndocs: add license comments\ndeps: path-to-regexp@0.1.4\nBad commit\n```\n\nit generates:\n\n``` md\n2015-07-27\n===================\n\n\n### Dependencies\n\n* path-to-regexp@0.1.4\n\n* type-is@~1.6.3\n\n - deps: mime-types@~2.1.1\n - perf: reduce try block size\n - perf: remove bitwise operations\n\n\n\n\n### Performance\n\n* use saved reference to http.STATUS_CODES\n\ncloses #2602\n```\n\nwhich compiles to \n\n# 2015-07-27\n\n### Dependencies\n- path-to-regexp@0.1.4\n- type-is@~1.6.3\n  - deps: mime-types@~2.1.1\n  - perf: reduce try block size\n  - perf: remove bitwise operations\n\n### Performance\n- use saved reference to http.STATUS_CODES\n\ncloses #2602\n\nNote that version number or some links are missing that's because it's not in the real express git environment (this is the result of unit test).\n","Using the express package.json and tweak the layout a little bit\n\n``` md\n4.13.1 \/ 2015-07-27\n===================\n\n\n### Dependencies\n\n* path-to-regexp@0.1.4\n* type-is@~1.6.3\n\n - deps: mime-types@~2.1.1\n - perf: reduce try block size\n - perf: remove bitwise operations\n\n\n\n### Performance\n\n* use saved reference to http.STATUS_CODES\n\n  Closes [#2602](https:\/\/github.com\/strongloop\/express\/issues\/2602)\n```\n\n# 4.13.1 \/ 2015-07-27\n\n### Dependencies\n- path-to-regexp@0.1.4\n- type-is@~1.6.3\n  - deps: mime-types@~2.1.1\n  - perf: reduce try block size\n  - perf: remove bitwise operations\n\n### Performance\n- use saved reference to http.STATUS_CODES\n  \n  Closes [#2602](https:\/\/github.com\/strongloop\/express\/issues\/2602)\n"],"labels":["ideas"]},{"title":"Feature request View global option ignore extname","body":"In react-engine you set the `view engine` via a global `app.set` variable.\n\n``` javascript\napp.set('view engine', 'js')\n```\n\nMy request is for another global view option\n\n``` javascript\napp.set('view ignore extname', true)\n```\n\nHere's why:\n\nIn react engine you pass the current page url to `res.render`\n\n```\napp.get(\"\/\", function(req, res){\n  return res.render(req.url, data)\n})\n```\n\nWhen that url has a period it is picked up by a [rendering engine the as an `extname`](https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/view.js#L57). So for the url `\/hello?url=google.com` you get an error because it's looking for the module `com`.\n\nYou can enable periods in react-engine simply by commenting out [this line](https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/view.js#L57). I'm putting in a pull request to copy the whole `View` with this line commented but it would be great if express supported it.\n\nIs there a way to do this already?\n","comments":["Hi @reggi ! I'm not sure what feature you are requesting. Can you add more details\/specificity?\n","Sorry @dougwilson I pressed enter too quickly and it posted with no content, updated!\n","Unfortunately view names are _specifically file system based names_. This means _you cannot pass in URLs_. At best, you can always do `res.render(url.parse(req.url).pathname, data)` to strip off the query string.\n","Actually, something we could do is provide something better than a \"default\" engine, or even expand the default engine in Express 5.0 to include files that have an extension but no mapping.\n","@dougwilson in the case of react-engine it allows ([encourages you](https:\/\/github.com\/paypal\/react-engine#rendering)) you to pass in `req.url`. They have methods of rending a specific react view based on the entire url.\n\nHere's a log from `this` at line [[75 of view.js](https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/view.js#L75)]\n\nVisiting route with `this.ext` uncommented. (Error `Cannot find module 'world'`)\n\n```\n{ useRouter: true,\n  defaultEngine: 'js',\n  ext: '.world',\n  name: '\/hello.world',\n  root: '\/Users\/thomas\/Desktop\/node-app\/public\/views' }\n```\n\nVisiting route with `this.ext` commented. (Works)\n\n```\n{ useRouter: true,\n  defaultEngine: 'js',\n  name: '\/hello.world',\n  root: '\/Users\/thomas\/Desktop\/node-app\/public\/views',\n  ext: '.js' }\n```\n","Yes, they can recommend stuff all they want, but it doesn't change the fact that our current views _only work with file system names_. Frankly, their documentation is wrong\/incomplete. You need to use `res.render(url.parse(req.url).pathname, data)` to strip off the query string.\n","@dougwilson The example above is the url `\/hello.world` this error would occur with the period in any part of the url even `\/index.html`, so it's not specific to periods in the query string.\n","> @dougwilson The example above is the url \/hello.world this error would occur with the period in any part of the url even \/index.html.\n\nI've already provided the solution we will implement at https:\/\/github.com\/strongloop\/express\/issues\/2708#issuecomment-122000489 which would work for the use-case you presented here.\n","Thanks a bunch @dougwilson! Excited to see this feature in Express 5.\n",":+1: \n","@reggi if there's no route defined for `\/hello.world`, wouldn't it `404`? Can you show a simple example of reproducing the extension error? \n\n@dougwilson I am taking a look at this. Can you explain \"include files that have an extension but no mapping\" with an example?\n","@dougwilson I'd also be interested in actually implementing this but as it stands it's not clear what is actually requested as @hacksparrow explained."],"labels":["ideas","5.x"]},{"title":"debug module with dynamic behavior (enable\/disable in runtime)","body":"Hi, I've sent a PR to the _debug_ module project adding the capability of dynamic debug instances that can be enabled\/disabled in runtime (this is, without having to restart the application):\n- https:\/\/github.com\/visionmedia\/debug\/pull\/209\n\nI expect this to be also useful for express applications, so I wonder if you could provide some feedback on the PR :)\n","comments":["I am pretty indifferent, as we'll use whatever the default we get (i.e. we'll only ever use the `require('debug')('<name')` method unless we can't any more. If this requires us to pass in a new option, then we'd pass, because the only way we could promote this well would be a massive updating of all our dependents.\n"],"labels":["discuss"]},{"title":"Cleaner way for redirecting back to the Referrer","body":"The 'back' special case has been moved from `res.location()` to a new `req.back` getter. In the future, this will make it possible to redirect to a regular 'back' page.\n","comments":["As this is a breaking change, though small, I wouldn't mind issuing a deprecation warning and waiting for 5.x instead.\n","Seems reasonable to me to remove the magic string value in 5.0\n","Changed to emit `deprecate()` instead of breaking the current behavior.\n","Any update?\n","How is this any different than just `res.redirect(req.get(\"referer\")||\"\/\")`?\nThe `'back'` should just be removed as it is a feature that only aims to _save keystrokes_.\n\n---\n\nSidenote: If we are to keep this I suggest adding a test or two for `res.location` separate from `res.redirect`.\n","@dougwilson what should I do?\n","I'm all for removing the magic string from Express 5.0, but yes, adding req.back is not a good replacement either, so what to replace it with needs to be thought on more.\n"],"labels":["discuss","5.x","pr"]},{"title":"Resolve paths for views asynchronously","body":"This eliminates the only post-startup synchronous I\/O in Express.\n\nIn addition, this makes the view.lookup method non-private, intended to be used\nby view engines to resolve paths to partials, and, if the View class is\nextended, could be used for other resources such as internationalized messages.\n","comments":["Nice! Anyway we can add to this a way to prevent stampeding (which the sync version protected from) to the default lookup implementation?\n","Oh, yes! I think I could work that in. \n","Updated.\n","\ud83d\udc4d \n"],"labels":["enhancement","5.x","pr"]},{"title":"separate locals from config values","body":"Keeping a separate namespace so that what's sent per-request is separate from long-lived configuration values.\n","comments":["Oh, this is interesting, and super useful for the namespace collisions that have bothered users of `adaro`.\n","As this is not backwards-compatible, it would have to wait for 5.0. I'm not against this at all, just highlighting why it won't get merged right away :) I'm a +1 for this, though.\n","That's awesome. The mashed-up namespaces there really do make backward compatibility a pain -- you can't safely add anything. Separating locals is the best start.\n","Aha, thank you folks!\n"],"labels":["enhancement","5.x","pr"]},{"title":"change res.links() to also accept array","body":"","comments":[],"labels":["4.x","help wanted","pr"]},{"title":"Multiple callbacks on app.param. Eg: app.param('resource', cb1, cb2)","body":"Duplicate of #2181, but since it has been locked I have to create a new issue.\n\nI saw in the [last comment](https:\/\/github.com\/strongloop\/express\/issues\/2181#issuecomment-46851349) from #2181 that a use case was required:\n\nConsidering one would want to do both authorization and loading for en entity, having both callbacks defined in the `app.param()` would be more readable, as well as provide controller reuse:\n\n``` javascript\napp.all('\/app\/entity*', permissions.initEntityAuth);\n\napp.all('\/app\/entity\/:entityid*',\n  entity.authorize,\n  entity.loadEntity,\n  function (req, res, next) {\n    return next('route');\n  });\n\napp.route('\/app\/entity\/:entityid')\n    .get(...)\n    .put(...);\n```\n\nvs\n\n``` javascript\napp.all('\/app\/entity*', permissions.initEntityAuth);\n\napp.param('entityid', \n   \/\/ everything done inside this controller. Reuse level 0.\n   entity.authorizeAndLoad);\n\napp.route('\/app\/entity\/:entityid')\n    .get(...)\n    .put(...);\n```\n\nvs\n\n``` javascript\napp.all('\/app\/entity*', permissions.initEntityAuth);\n\napp.param('entityid', \n    \/\/ Ohh, no. I have to maintain an async_wrap now\n    some_async_wrap(entity.authorize, entity.loadEntity));\n\napp.route('\/app\/entity\/:entityid')\n    .get(...)\n    .put(...);\n```\n\nvs\n\n``` javascript\n\/\/ It seems to be much more readable as well as keeping the code reuse \napp.all('\/app\/entity*', permissions.initEntityAuth);\n\napp.param('entityid', \n   entity.authorize, \n   entity.loadEntity);\n\napp.route('\/app\/entity\/:entityid')\n    .get(...)\n    .put(...);\n```\n\nWhat do you think?\n","comments":["how about this? I think it will do the same thing. But your idea is nice\n\n```\n[entity.authorize, entity.loadEntity].forEach(function(fn){\n  app.param('entityid', fn);\n});\n```\n","Being able to register middleware multiple times for the same parameter can be confusing, therefore I would prefer to register using `app.param` only once for one given parameter.\n"],"labels":["discuss","ideas"]},{"title":"WebSocket GET handshake (upgrade) routing","body":"I don't meam an \"integrated WebSocket server\" but the possibility of performing express routing for WebSocket handshake requests.\n\nNode `httpServer` emits an \"upgrade\" event for HTTP GET requests including a \"Upgrade\" header. Express may provide a new \"method\" called \"websocket\" for handling them (if the \"Upgrade\" header has value \"websocket\"), so the GET request may be processed as any other HTTP verb:\n\n``` javascript\nvar app = express();\n\napp.websocket('\/websocket\/:service', function(req, res, next) {\n  [...]\n});\n```\n\nIn this way, Cookies present in the HTTP request may be checked using express middlewares (for example).\n","comments":["Perhaps, but Express is not a HTTP server, it is only a function. You just pass an Express app yo the requestListener osf whatever HTTP server module you choose to use.\n\nAll an app is is app(req, res, next). You can even typeof on your app variable. Because of this, Express has no way to actually listen to any events on the HTTP server.\n","As for using Express middleware with websockets, this is already possible without any effort from express. Many many people already do this today, especially with express-session.\n","I'm not dismissing this (or I would have closed the issue), but if you or someone could put together a PR that is even just a WIP towards this against the 5.x branch, that would have the best chance of getting in :)\n","FYI I don't think it's necessary to listen to the event, that is just a convenience for other libraries (i.e. `socket.io`). We just need to check if the `Upgrade:` header is present and act accordingly.\n","Please make a PR :)\n","IMHO this is not so easy. AFAIK the `httpServer` will emit `upgrade` upon receipt of a GET request with header \"Upgrade\", and it is in that event where existing WS libraries (such as `ws` or `websocket-node`) react to perform the handshake or notify the app. What I mean is that, at that point (\"upgrade\" event fired) the WS server as already control over the request. Express should keep the \"upgrade\" event until a middleware handles it. Otherwise it should be replied with 404 as usual, but for that something should listen for the \"upgrade\" event and invoke the `app.handle()` method somehow...\n","Sure. The problem is I really don't use WebSockets, so I'm really looking for someone to offer a PR against the 5.x branch for this idea is all, otherwise if no on I going to make a PR, I may have to close this issue since it's not being acted on.\n\nThe PR can even be a WIP, as I said above. I'm just looking for code to demonstrate your idea.\n","+1 I'm currently using a custom handleUpgrade to do authentication before passing the request to https:\/\/github.com\/websockets\/ws\/ but it would be nice to be able to use express middleware \/ routing. Not interested in using socket.io\n","Just wrote this module: https:\/\/github.com\/olalonde\/express-websocket\n\n``` javascript\nvar http = require('http');\nvar ws = require('ws');\n\nmodule.exports = function (app, wss) {\n  if (!wss) {\n    wss = new ws.Server({ noServer: true });\n  }\n\n  \/\/ https:\/\/github.com\/websockets\/ws\/blob\/master\/lib\/WebSocketServer.js#L77\n  return function (req, socket, upgradeHead) {\n    var res = new http.ServerResponse(req);\n    res.assignSocket(socket);\n\n    res.websocket = function (cb) {\n      var head = new Buffer(upgradeHead.length);\n      upgradeHead.copy(head);\n      wss.handleUpgrade(req, socket, head, function (client) {\n        \/\/client.req = req; res.req\n        wss.emit('connection'+req.url, client);\n        wss.emit('connection', client);\n        cb(client);\n      });\n    };\n\n    return app(req, res);\n  };\n};\n```\n\nBasically, it routes the request to an express app and exposes the res.websocket() method which starts the websocket connection.\n","There hasn't been much discussion in here for a month. Any thoughts on issuing a PR to discuss over? Otherwise, I may need to close this for becoming stale.\n","It'd be awesome to do something like the above that @olalonde has done,  and I might be adopting his solution (if slightly modified).\nAs it currently stands, it feels very strangely architectured IMHO.\n\n**edit:** my solution:\n\n``` js\nlet http = require('http')\nlet express = require('express')\n\nlet app = express()\nlet server = http.createServer(...)\n\n\/\/ ... etc\nserver.on('upgrade', (req, socket) => {\n  let res = new http.ServerResponse(req)\n  res.assignSocket(socket)\n\n  res.on('finish', () => res.socket.destroy())\n  app(req, res)\n})\n\n\/\/ elsewhere\n  router.use('\/', (req, res, next) => {\n    if (!req.headers ||\n      req.headers.upgrade === undefined ||\n      req.headers.upgrade.toLowerCase() !== 'websocket') return next()\n\n    wss.handleUpgrade(req, req.socket, undefined, (socket) => {\n      console.log('upgraded!')\n      socket.send('woo')\n      socket.close()\n    })\n  })\n```\n","I just ran across this old thread. Perhaps the following library is relevant now?\r\nhttps:\/\/www.npmjs.com\/package\/express-ws"],"labels":["ideas","help wanted"]},{"title":"links() function insufficient for attributes other than `rel`","body":"With [v4 `links()` function](http:\/\/expressjs.com\/4x\/api.html#res.links) it is not possible to set the [`type` attribute](http:\/\/tools.ietf.org\/html\/rfc5988#section-5.4), inter alia.\n\nI propose that an interface variant is added where the function takes an array of objects, e.g.:\n\n``` javascript\nres.links([\n    {\n        href: 'http:\/\/api.example.com\/users?page=2',\n        rel: 'next',\n        title: 'next chapter',\n        type: 'text\/plain;charset=UTF-8'\n    },\n    {\n        href: 'http:\/\/api.example.com\/users?page=5',\n        rel: 'last',\n        title: 'the grand finale',\n        type: 'video\/webm'\n    }\n]);\n```\n","comments":["Sounds fine to me, we can certainly add something.\n","The following prs also attempt to address this: #2702 (which follows on from #2619).\n","#2702 incorporates some feedback from @dougwilson regarding validation of the provided keys which is not present in #2619 or #2575.\n"],"labels":["enhancement","4.x","5.x"]},{"title":"Shouldn't app.set(\"case sensitive routing\") propagate to new Routers?","body":"Just wondering if app settings such as \"case sensitive routing\" should be also applied in new `Router` instances created by the user.\n\nOf course that would require some kind of magic in what `express.Router` returns (it should be a function that creates a new `Router` and applies the app settings unless provided by the user).\n","comments":["Sorry, `express.Router()` cannot return an instance with same settings as the app. Of course it should be done via a new method `app.Router()`.\n","There will likely be a `app.createRouter(opt)` in 5.0, that would create a router with the `opt` merged with the app's options.\n","Something like this works:\n\n``` js\nApplication.prototype.Router = function(options) {\n    options = options || {};\n\n    if (! options.hasOwnProperty('caseSensitive')) {\n        options.caseSensitive = this.enabled('case sensitive routing');\n    }\n\n    if (! options.hasOwnProperty('strict')) {\n        options.strict = this.enabled('strict routing');\n    }\n\n    return new Router(options);\n};\n```\n\nand then:\n\n``` js\nvar router = app.Router(options);\n```\n","@dougwilson Wanted to take my stab at implementing this but it seems like you already did so [here](https:\/\/github.com\/expressjs\/express\/blob\/c8d9223e93ee0c08490e4840f3278314ccb221a5\/lib\/application.js#L63). Shouldn't this issue be closed?","I never implemented the request at hand."],"labels":["enhancement"]},{"title":"Simplify app.all and app.VERB","body":"https:\/\/github.com\/strongloop\/express\/blob\/5.0\/lib\/application.js\n\nCurrently:\n\n``` js\n\/**\n * Delegate `.VERB(...)` calls to `router.VERB(...)`.\n *\/\n\nmethods.forEach(function(method){\n  app[method] = function(path){\n    if ('get' == method && 1 == arguments.length) return this.set(path);\n\n    var route = this.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n\/**\n * Special-cased \"all\" method, applying the given route `path`,\n * middleware, and callback to _every_ HTTP method.\n *\n * @param {String} path\n * @param {Function} ...\n * @return {app} for chaining\n * @api public\n *\/\n\napp.all = function(path){\n  var route = this.route(path);\n  var args = slice.call(arguments, 1);\n  methods.forEach(function(method){\n    route[method].apply(route, args);\n  });\n\n  return this;\n};\n```\n\nBut the following simplified code does exactly the same (in fact `lib\/Router\/index.js` does it):\n\n``` js\n\/**\n * Delegate `.all(...)` and `.VERB(...)` calls to `Router#all(...)` and `Router#VERB(...)`.\n *\/\n\nmethods.concat('all').forEach(function(method){\n  app[method] = function(path){\n    if ('get' == method && 1 == arguments.length) return this.set(path);\n\n    var route = this.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n```\n","comments":["It may seem different from the outside, but in fact is very different in the internal structure it creates. We can look into the consequences of changing this as part of 5.0.\n","Actually it changes the outside behavior as well; right now app.all only responds to known verbs. This change will make it also respond to unknown verbs.\n","Well, `Router#all()` already respond to unknown verbs, am I wrong?:\n\n```\n\/\/ create Router#VERB functions\nmethods.concat('all').forEach(function(method){\n  Router.prototype[method] = function (path) {\n    var route = this.route(path)\n    route[method].apply(route, slice.call(arguments, 1))\n    return this\n  }\n})\n```\n","Right, you are not wrong. But app.all doesn't, so it would be a change of behavior for app.all\n","Since `app.xxxx()` is supposed to be a simple proxy to the main `Router#xxxx()`, shouldn't the behavior be the same?\n","In 4.x, it is not a simple proxy. Perhaps it can be in 5.0, but the behavior change just needs to be evaluated first.\n"],"labels":["5.x","module:router"]},{"title":"Application may be a class","body":"https:\/\/github.com\/strongloop\/express\/blob\/5.0\/lib\/application.js\n\nThe fact is that `lib\/application.js` may perfectly export the constructor of a \"real\" `Application` class, and define its prototype as usual instead of `var app = exports = module.exports = {};`. I mean:\n\n```\nmodule.exports = Application;\n\n\nfunction Application() {\n  var router = null;\n\n  this.cache = {};\n  this.settings = {};\n  this.engines = {};\n  this.defaultConfiguration();\n\n  etc etc\n}\n\nApplication.prototype.defaultConfiguration = function() {\n  ...\n};\n\nApplication.prototype.handle = function(req, res, done) {\n  ...\n};\n```\n\nI don't see any downside in doing it that way, do I miss something? At the end the new `Router` class is now designed as a \"real\" JavaScript class.\n","comments":["We are planning to do this, yes :)\n"],"labels":["5.x"]},{"title":"Fix setting inheritance","body":"Looking for feedback on this, but a recent issue was brought up with \"trust proxy\" and got me reading through a bunch of old issues on here.\n\nPersonally I like having apps as isolated islands, but sometimes it's nice\/makes sense to inherit some settings from the parent app when using sub apps. There was a suggestion back in https:\/\/github.com\/strongloop\/express\/issues\/905#issuecomment-4750824 to add \"inherit ___\" settings where you would pick and choose settings to inherit. This seems kludgy to me, but I guess works?\n\nReally, right now the way mounted sub apps work with settings is half-assed :) They pretend like they will inherit settings, unless they are special magical default Express settings. You can't have it both ways, Express!\n\nSo, what should we do for 5.0:\n1. Remove setting inheritance and make it opt-in only\n   a. per setting\n   b. any setting\n2. Fix setting inheritance to differentiate \"default settings\" from Express itself vs user-set settings. When sub apps are mounted, all non-user-set settings will thus be inherited (which means default Express settings would now be inherited)\n","comments":["I just came here to raise almost this exact issue. I recently mounted our app as a sub app and discovered that the x-powered-by header re-appeared despite having run `app.disable('x-powered-by')` in the top-level app.\n\nI'd assumed that disabling this setting at the top level would be sufficient for it to be disabled all the way down the stack, but it looks from https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/middleware\/init.js#L13 that the header will be added if it's not disabled at every level, which frankly sucks.\n\nI would be strongly in favour of allowing child mounted apps to inherit parent settings, or at least make it explicit what is and what isn't inherited (since I assume from your reference to \"special magical default Express settings\" that some things will be inherited?).\n","@lennym The problem is here https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/application.js#L69-L98\n\nWhen the express application is created, there are some defaults set.  \nThen, if that application gets mounted, its settings are inherit from its parent. But it is too late because those settings are now set by default. \n\n```\n\/\/ Example here\nvar express = require('express');\nvar parent = express();\nparent.disable('x-powered-by');\nconsole.log(parent.set('x-powered-by')) \/\/ false, as expected\nvar child = express();\nconsole.log(child.set('x-powered-by')) \/\/ true, because x-powered-by is set to true by default\nparent.use(child); \/\/ mount\nconsole.log(child.set('x-powered-by')) \/\/ true, we are using child setting\ndelete child.settings['x-powered-by']; \nconsole.log(child.set('x-powered-by')) \/\/ false, now, child does not define this setting and uses his parent one\n```\n\nA simple and dirty hack can be\n\n```\nchild.on('mount', function () {             \n    delete this.settings['x-powered-by'];\n});\nparent.use(child);\n```\n","@dougwilson Further feedback\/thoughts on settings inheritance, some of it doubtless caused by my own misapplication and misunderstanding of intent...\n\nI've just been bitten slightly by the 'views' setting being defaulted at the instantiation of an app, where I had assumed that if not set then it would fall back to the parent app's setting.\n\nWith hindsight, the solution was to export a router instead of a full app, but because of the way that express defaulted the views directory I spent _quite a lot_ of time debugging because the default for the child was the same path as the \"grandparent\" app.\n\nI guess I'm saying that my feeling is that settings should be inherited by default - undefined settings call up to the parent, and only if no parent exists, resort to default values. So `app.get` effectively looks up the \"app tree\" to find its settings, in a not dissimilar way to how node's require searches up the file system for node_modules. \n\nYou could add `app.set('inherit', false)` to prevent this if required (which would of course be inherited by child apps (-;), but I would certainly say that my expectation has continually proven to be assumed inheritance.\n","@lennym then it sounds like what I plan to change with Express 5.0 will make sub apps and inheritance work exactly as you were expecting.\n","Excellent. Let me know if I can be of any help.\n",":+1: on this :smile:\n"],"labels":["discuss","ideas","5.x"]},{"title":"path specific error handler not called","body":"The following test passes on 3.x but fails to master.  I can't find anything in the migration guide mentioning something like this - is it an intended change I'll need to work around or a regression?\n\n``` javascript\nvar express = require('..\/')\n  , request = require('supertest');\n\ndescribe('app', function(){\n  describe('.VERB()', function(){\n    it('should call an error handling routing callback when path matches', function(done){\n      var app = express();\n\n      app.all('*', function (req, res, next) {\n        next(new Error('fabricated error'));\n      });\n\n      app.get('\/', function(err, req, res, next){\n        next();\n      }, function(req, res){\n        res.send(204);\n      });\n\n      request(app)\n      .get('\/')\n      .expect(204, done);\n    })\n  })\n})\n```\n\nmaster gives this error:\n\n```\n  1) app .VERB() should call an error handling routing callback when path matches:\n     Error: expected 204 \"No Content\", got 500 \"Internal Server Error\"\n```\n","comments":["I'll have to check to confirm or deny ;)\n","Ok, so here is the answer (and I'm not saying it's the correct answer, just saying it's what the 3 -> 4 change was):\n\nWhen an error enters back into the router (it'll enter back into the router after the `.all()` completes with the error), the router will no longer traverse any routes, only `app.use()` statements to look for an error handler.\n\nSpecifically, the commit f41d09a3cf0592b65a1359495b65d3d7cf949c50 introduced the change (between 3 and 4.0.0). At this point, I would say that it's an oversight in the migration guide (especially with something edge-case-y) and I will leave this open for discussion.\n","Thanks for investigating.  Yes, I came to a similar conclusion and came up with a workaround along the lines of\n\n``` javascript\napp.all('*', function (req, res, next) {\n    next(new Error('fabricated error'));\n});\n\napp.use('\/', function(err, req, res, next) {\n    next();\n});\napp.get('\/', function(req, res){\n    res.send(204);\n});\n```\n\nI agree my first use case is rather edge-case-y!  It still isn't clear to me whether error handlers can be used in routes or just in `app.use()`.  For example, one of the existing tests for this (`app.routes.error.js`) does use it as a 'route'.  And, for example in the spirit of that test, this works:\n\n``` javascript\napp.get('\/', function (req, res, next) {\n    next(new Error('fabricated error'));\n}, function(err, req, res, next) {\n    next();\n}, function(req, res){\n    res.send(204);\n});\n```\n\nbut this doesn't (which I find confusing):\n\n``` javascript\napp.get('\/', function (req, res, next) {\n    next(new Error('fabricated error'));\n});\napp.get('\/', function(err, req, res, next) {\n    next();\n}, function(req, res){\n    res.send(204);\n});\n```\n"],"labels":["discuss","4.x","module:router"]},{"title":"Add \"set\" Method to \"Router\"","body":"Hey guys,\nI think it would be nice to be able to set options to single Routes. For example one can set a default layout for the handlebars rendering engine with \n\n``` javascript\napp.set('view options', { layout: 'main' });\n```\n\nor with \n\n``` javascript\napp.engine(\".hbs\", handlebars({\n    defaultLayout: \"main\", \n}));\n```\n\nWhen using a `express.Router()` for example with `app.use(\"\/admin\", adminRouter)` it would be nice to be able to use something like\n\n``` javascript\nadminRouter.set('view options', { layout: 'adminMain' });\n```\n\nto prevent using \n\n``` javascript\nres.render('home', {layout: \"adminMain\"});\n```\n\nfor every call to `res.render`\n\nThanks\n\n-Andr\u00e9-\n","comments":["I found that one way to solve my special Layout problem is\n\n``` javascript\nadminRouter.use(function(req, res, next)\n{\n    res.locals.layout = \"adminMain\";\n    next();\n});\n```\n","The solution from yesterday is no real solution.\n\nConsider the following example\n\n``` javascript\nvar adminRouter = express.Router();\nadminRouter.use(function(req, res, next)\n{\n    res.locals.layout = \"adminMain\";\n    next();\n});\nadminRouter.get(\"\/\", admin.admin);\n\napp.use(\"\/admin\", adminRouter);\napp.get(\"\/register\", register.register);\n```\n\nWhen I first visit the `\/register`route, everything is fine.\nBut when I call `\/admin\/`and then the `\/register`  route, `res.locals.layout` is set to `\"adminMain\"`. As a result to this, in the `\/register` route the wrong layout is rendered.\n","This needs discussion, but from me I am (currently) -1, because that's what the difference is between an app and a router: an app has settings.\n","In case you need different settings, you should go with a sub-app pattern and in your main express app, actually use it. \n\n``` js\nfirstExpressapp.use('\/admin\/', anotherExpressApp);\n```\n\n@dougwilson is there any performance impact when using sub-apps instead of nested Router? I think there shouldn't be as app delegates all the requests to the top-level router anyway.\n","Well from scoping perspective... in version 3 this was great, because there was no Router, with addition to router, app -> router -> response; router should\/could get a locals attribute that would upgrade locals to the response object and possible views that would use them. You can do this manually as @akesser pointed out.\n","Also with @dougwilson on this -- the functionality is probably better suited in it's own sub-module somehow.\n"],"labels":["discuss","ideas","module:router"]},{"title":"Reject routes containing an unescaped space character","body":"At the moment, when the developer provides a route path containing raw characters that must escaped by HTTP clients, for example a space character, the route is registered by express even though it will never match any request (URL):\n\n``` js\nvar app = express();\napp.get('\/foo bar', function(req, res) { \/* ... *\/ });\n\n\/\/ clients send `GET \/foo%20bar`, server responds with 404\n```\n\nSuch situation is difficult to troubleshoot, especially if the invalid character was included by mistake.\n\nI am proposing to modify Express and\/or path-to-regexp to print a warning when a string path argument contains characters that will be always sent in the encoded form by HTTP clients. [RFC3986](https:\/\/tools.ietf.org\/html\/rfc3986#section-2) allows some characters to be sent either encoded or unencoded. Such characters should be accepted as valid (no error\/warning).\n\nIn other words, only the following characters may be present in the unencoded form:\n- Unreserved characters: `ALPHA \/ DIGIT \/ \"-\" \/ \".\" \/ \"_\" \/ \"~\"`\n- Reserved characters: `\":\" \/ \"\/\" \/ \"?\" \/ \"#\" \/ \"[\" \/ \"]\" \/ \"@\" \/ \"!\" \/ \"$\" \/ \"&\" \/ \"'\" \/ \"(\" \/ \")\" \/ \"*\" \/ \"+\" \/ \",\" \/ \";\" \/ \"=\"`\n\n@dougwilson thoughts? StrongLoop can contribute the change, I just want to check with you that such change will be accepted.\n\nI was initially thinking that express should throw an error instead of printing a warning, but since such change may be considered as breaking backwards compatibility, it's probably better to stay with the warning.\n\n\/cc @PradnyaBaviskar\n","comments":["That's fine, but RFC 3986 does not dictate what character may appear in the `req.url` string, which is what the path matches against, RFC 7230 does:\n\n```\nrequest-line   = method SP request-target SP HTTP-version CRLF\nrequest-target = origin-form\n               \/ absolute-form\n               \/ authority-form\n               \/ asterisk-form\norigin-form    = absolute-path [ \"?\" query ]\nabsolute-form  = absolute-URI\nauthority-form = authority\nasterisk-form  = \"*\"\nabsolute-path = 1*( \"\/\" segment )\nsegment       = *pchar\npchar         = unreserved \/ pct-encoded \/ sub-delims \/ \":\" \/ \"@\"\nunreserved    = ALPHA \/ DIGIT \/ \"-\" \/ \".\" \/ \"_\" \/ \"~\"\npct-encoded   = \"%\" HEXDIG HEXDIG\nsub-delims    = \"!\" \/ \"$\" \/ \"&\" \/ \"'\" \/ \"(\" \/ \")\"\n              \/ \"*\" \/ \"+\" \/ \",\" \/ \";\" \/ \"=\"\nquery         = *( pchar \/ \"\/\" \/ \"?\" )\nabsolute-URI  = scheme \":\" hier-part [ \"?\" query ]\nscheme        = ALPHA *( ALPHA \/ DIGIT \/ \"+\" \/ \"-\" \/ \".\" )\nhier-part   = \"\/\/\" authority path-abempty\n            \/ path-absolute\n            \/ path-rootless\n            \/ path-empty\nauthority   = [ userinfo \"@\" ] host [ \":\" port ]\nuserinfo    = *( unreserved \/ pct-encoded \/ sub-delims \/ \":\" )\nhost        = IP-literal \/ IPv4address \/ reg-name\nIP-literal    = \"[\" ( IPv6address \/ IPvFuture  ) \"]\"\nIPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved \/ sub-delims \/ \":\" )\nIPv6address   =                            6( h16 \":\" ) ls32\n              \/                       \"::\" 5( h16 \":\" ) ls32\n              \/ [               h16 ] \"::\" 4( h16 \":\" ) ls32\n              \/ [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n              \/ [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n              \/ [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n              \/ [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n              \/ [ *5( h16 \":\" ) h16 ] \"::\"              h16\n              \/ [ *6( h16 \":\" ) h16 ] \"::\"\nport          = *DIGIT\npath-abempty  = *( \"\/\" segment )\npath-absolute = \"\/\" [ segment-nz *( \"\/\" segment ) ]\nsegment-nz    = 1*pchar\npath-rootless = segment-nz *( \"\/\" segment )\npath-empty    = 0<pchar>\n```\n\nI'm OK with throwing on anything that cannot be `request-target`. The change will have to be in `path-to-regexp`, in the 0.1.x series and we can pull it into Express 4.x. A change to Express 3.x would be a direct change to this repository, though.\n","As far as throw vs warning, it would be probably be better to do warning in the existing majors, but even then, there is no proper warning framework for Node.js, so I would say we should _deprecate_ it rather than warn on it (because then that opens us to to throw in 5.x).\n","> I'm OK with throwing on anything that cannot be request-target. The change will have to be in path-to-regexp\n\nCool!\n\nImplementing a fully-compliant `request-target` parser seems to me like a too much work with low return. Do you have any objections if we simplify the implementation to only check for characters that are not allowed in any part of `request-target`? \n\nThat way we won't reject some invalid targets (e.g. a `scheme` containing an underscore character), but we will still accept all valid targets and the implementation will be vastly simpler.\n\n> The change will have to be in path-to-regexp, in the 0.1.x series and we can pull it into Express 4.x. A change to Express 3.x would be a direct change to this repository, though.\n\nAs far as I am concerned, it is enough to fix this problem in path-to-regexp and Express 4.x.\n\n> We should deprecate it rather than warn on it (because then that opens us to to throw in 5.x).\n\nMakes sense, let's do that.\n","> Do you have any objections if we simplify the implementation to only check for characters that are not allowed in any part of request-target? \n\nRight, that's what I was getting at. I just gave the spec so you would know when making the blacklist exactly what is on the whitelist :)\n","And if it's, for some reason, unfeasible to get a change that works will into `path-to-regexp` 0.1.x itself, we could probably compromise on just running it in [the Layer constructor](https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/router\/layer.js).\n","We have discussed the matter with @dougwilson:\n\nPath parameter names don't follow the `request-target` spec, e.g. `app.get(\u201c\/:\u0161o\u0161ovica\u201d, fn)` is a valid path. If it turns out that the implementation supporting this exception is too difficult, then we can simplify the solution and reject only whitespace characters, since they are not allowed anywhere in the path (including parameters).\n","3.20.0, the last 3.x that will ever have an enhancement like this, will be released 2\/18. Without an implementation for 3.x before then, this certainly won't make it into the 3.x series.\n","I'm bumping this from the 3.x series.\n","> I'm bumping this from the 3.x series.\n\n@dougwilson that's fine :+1: \n","Interestingly, this brings up a slightly different conversation that might be interesting to have. Should paths be automatically url encoded? For example, supporting unicode characters and accents in the url? Right now people would need to write out \u6211 as `%E6%88%91` in the path string. We could easily allow unicode expansion and I think it'd be useful for international audiences. In that respect, ` `would automatically expand to`%20`. Discussion can continue with https:\/\/github.com\/pillarjs\/path-to-regexp\/issues\/42.\n"],"labels":["discuss","enhancement","4.x","5.x","module:router"]},{"title":"Add originalRoute like originalUrl","body":"In a request we can get the originalUrl, which is the complete URL for the request after it has travelled through nested routes.\n\nBut I think an originalRoute would be at least as usefull, especially for request logging.\n\nI don't think it should be that difficult to add.\n\nCurrently I've made a simple hack to accomplish this, but I rather see it built-in.\n\n```\nvar _ = require('lodash');\nvar express = require('express');\nvar Router = express.Router;\nvar Router_process_params = Router.process_params;\n\nRouter.process_params = function (layer, called, req, res, done) {\n  req.originalRoute = (req.originalRoute || '') + (req.route && req.route.path || layer.path ||\u00a0'');\n  return Router_process_params.apply(this, _.toArray(arguments));\n}\n```\n","comments":["Can you show a little express app that makes use of this as well, please :)?\n","@dougwilson Is the following good enough?\n\nA request could be `GET \/api\/user\/123`, and I would expect to be able to get the full route `\/api\/user\/:id` in the request object.\n\n`server.js`\n\n```\nvar express = require('express');\nvar app = express();\n\napp.use('\/api', require('.\/api').router);\n\napp.listen(port);\n\n```\n\n`api\/index.js`\n\n```\nvar express = require('express');\nvar router = express.Router();\n\nrouter.use('\/user', require('.\/user'));\nrouter.use('\/items', require('.\/items'));\n\nexports.router = router;\n```\n\n`api\/user.js`\n\n```\nvar express = require('express');\nvar router = express.Router();\n\nrouter.get('\/:id', function(...) {});\nrouter.get('\/', function(...) {});\n\nexports.router = router;\n```\n\n`api\/items.js`\n\n```\nvar express = require('express');\nvar router = express.Router();\n\nrouter.get('\/:id', function(...) {});\nrouter.get('\/', function(...) {});\n\nexports.router = router;\n```\n","How would it work for RegExp routes or array routes?\n","i.e. we need it to work if your main file has\n\n``` js\napp.use(['\/api', '\/api\/v1'], require('.\/api').router);\n```\n\nor\n\n``` js\napp.use(\/^\\\/api(?:\\\/v1)?\\\/\/i, require('.\/api').router);\n```\n","@dougwilson I see your concerns, and that we have to re-think it, to ensure all methods will be handled correctly.\n\nAnother approach could be to simply expose an array of routes in the order they were matched, and if you are going to use the data, you'll have to deal with the different data types.\n\nAssume that you'd replaced my route in `server.js` with one of you version, then `req.originalRoute === [['\/api', '\/api\/v1'], '\/user', '\/:id'];` or `req.originalRoute === [\/^\\\/api(?:\\\/v1)?\\\/\/i, '\/user', '\/:id']`. In the \"array\" version, we might actually be able to identify which of the two was used for the request, and then show that specific one instead of an array - and then we only need to see if we can do something better on RegExp-route.\n\nI don't know if newrelic is able to handle all cases (haven't investigated their code further), but they do something similar to my hacky workaround. https:\/\/github.com\/newrelic\/node-newrelic\/blob\/master\/lib\/instrumentation\/express.js#L184\n","That's fine. I don't mind adding something for this. We just want to make sure that what gets added to Express core is compatible with all of Express's features, rather than only the features a particular user just happens to be using it is all :)\n","I'm all in on that - I did not just want this to be a feature for me :) This issue was to rise a discussion on a good way to implement something like this, as the new Router in Express 4 is giving the power to split and nest routes, but the downside is, that it can be hard to know exactly where you are, and for logging purpose it is often useful to be able to group by route rather than exact URL, to know how many request of a specific type has happend.\n\nWhich way do you prefer? Some way to concat the routes or should we go with the array of routes a particular request has travelled from entry to the final route?\n","An array that gets built up sounds like the simplest method to me.\n","An array is fine with me... if a use case needs another format, it simply has to handle the transformation from the array to something else, eg a concat-string.\n","Hey, I can confirm that it would be great to have originalRoute. I'm trying to implement declarative ACL based on routing so it's very uncomfortable to deal with it without knowing what route was matched =(\n","Any traction on a PR?\n","@dougwilson Created a PR about this (#2864).\n","@ajfranzoia Thank you very much\n","@dougwilson @ajfranzoia @danieljuhl @devlato thoughts on #3100? \n","Hi @evanshortiss it looks like that PR doesn't address the concerns brought up in this PR.\n","@ajfranzoia @danieljuhl @devlato, your input would be appreciated based on @dougwilson's latest comments on #3100.\n\nCurrently #3100 is building up an Array of all matched routes as discussed in this PR. @dougwilson rightly suggested that _req.route_ could be used for some scenarios. _req.route_ is workable so long as you only need the relative path. \n\nAn issue arises when you'd like to have access to all matched routes. The code below for example cannot provide the full matched path, only the local path, thus we lose \"\/hey\" in logs, analytics, and wherever else your use case requires.\n\n``` js\nvar app = require('express')();\nvar route = require('express').Router();\n\nroute.get('\/you\/:id', function (req, res) {\n  res.end(req.route.path); \/\/ Will return \"\/you\/:id\", not \"\/hey\/you\/:id\" or similar\n});\n\napp.use('\/hey', route);\n\napp.listen(3000);\n```\n\nThere are ways around this using middleware or alternative structures, but think it would be nice if express had the ability to provide this information in a clean, clear built-in manner. My thoughts on a middleware is something to the effect of this, which I'd actually settle for if adding this behaviour to express doesn't make sense:\n\n``` js\nfunction expressMatchedMiddleware (req, res, next) {\n  if (!req.matchedRoutes) {\n    req.matchedRoutes = [];\n  }\n\n  if (req.route) {\n    req.matchedRoutes.push(req.route);\n  }\n\n  next();\n};\n```\n","WRT #3100 as well.\n\nSince the `path` parameter of middleware and router handlers can be more than simple strings - [examples](http:\/\/expressjs.com\/en\/4x\/api.html#path-examples), this kind of feature will have a hard time being universally useful.\n\nLet's look at some scenarios.\n1. The API should return an array of matched layers\/routes.\n   \n   Consider the resulting array, when a request is made to `\/secret`:\n   \n   ```\n   \/\/ there are two built-in middleware in express already\n   app.use(...) \/\/ logger\n   app.use(...) \/\/ body parse\n   app.use(...) \/\/ cookie parser\n   app.use(...) \/\/ some more root-level middleware\n   app.use([['restricted', 'hidden'], \/lol\/, 'ha*'], (req, res, next) => next())\n   app.use('\/secret', (req, res, next) => next())\n   app.use('\/secret', (req, res, next) => res.send('ABRACADABRA!'))\n   ```\n   \n   Questions:\n   \n   a. Would the resulting array of matched layers\/routes be useful?\n   b. What advantage would it have over manually looking through the code?\n2. The API should return the absolute path of the route (full route)\n   \n   What should it return when a request is made to `\/whatever\/pineapple` or `\/whatever\/apple`, in this case?\n   \n   ```\n   var router = express.Router()\n   \n   router.get([['cat', 'dog'], '*apple'], (req, res, next) => {\n   req.whatever = 'YOLO'\n   next()\n   })\n   router.get(['\/apple', '\/pineapple'], (req, res) => res.send(req.whatever))\n   \n   app.use('\/whatever', router)\n   ```\n   \n   Simply returning `\/whatever\/pineapple` or `\/whatever\/apple` hides the significance of what `router.get([['cat', 'dog'], '*apple']` does to `req`.\n3. Best case scenario: the \"path\" is a simple string\n   \n   ```\n   app.get('\/apple', (req, res, next) => next())\n   app.get('\/apple', (req, res, next) => next())\n   app.get('\/apple', (req, res, next) => next())\n   app.get('\/apple', (req, res, next) => next())\n   app.get('\/apple', (req, res, next) => res.send('APPLE'))\n   app.get('\/apple', (req, res, next) => next())\n   ```\n   \n   The API will return `\/apple`, but there is no context about the route handler, unlike `req.route`.\n\nMy suggestion would be to let the users implement their own ways of retrieving the absolute path of the matched route(s), for use cases unique to their own requirements.\n\n@dougwilson @ajfranzoia @danieljuhl @devlato @evanshortiss \n","@hacksparrow your scenarios are valid, but it seems like you assume that the API should return a combined string. Or am I getting you wrong?\n\nI believe it has already been discussed a lot, that the only solution that would make sense, is to return an array of the actual route definitions, that be a string, regex, an array or whatever is allowed by express.\n\nAs I see it, @evanshortiss has actually handled that, though more test scenarios should be created, to ensure the API is handling all kinds of route definitions.\n","@danieljuhl I am not making any assumptions about what the API should return. In fact, I cannot think of anything that should be returned, which would make sense universally.\n\nScenarios 1 and 3 highlight the issue of using an array as implemented by @evanshortiss.\n","@hacksparrow here are some thoughts.\n1. I think populating with _req.route_ makes sense, but this example (_app.use_) is definitely a valid gap, since you do actually respond in the final handler but it (req.matchedRoutes) would yield no matches in this case if we were to use req.route. However, I would argue that you should use _app.all('\/secrets', handler)_ or _app.METHOD('\/secrets', handler)_ for the last scenario since this would populate _req.route_ and is more sensible from a semantic standpoint. For middleware such as body parser, nothing should be added to the matched routes, since they aren't routes, but are a passthrough.\n   \n   a. Yes, one would expect this is populating the Array using _req.route_ and _app.all_: _[{path: '\/secret', \/\\* other req.route props *\/}]_, or the current PR _[ '\/', '\/', '\/', '\/secret', '\/secret' ]_.\n   b. This information can be useful at runtime for logging.\n2. True, but it's a passthrough middleware. The purpose of this issue is purely to get the matched routes, not the state of the request object.\n3. Correct, but again these are passthroughs\/middleware. One can delete known passthroughs to easily construct the absolute URL, or use them if their scenario requires.\n\nUltimately the goal of this issue is to enable a developer to programatically determine matched routes which seems like a reasonable request. But I agree, we can see it's a challenge to achieve in a manner that works \"universally\" and raises the question of can and\/or should express attempt provide this.\n","@evanshortiss yes, I agree it is a reasonable request. It's just that the API is not very convincing or a lot of complexities will be involved (eg: detecting passthroughs). It would be great to have a really elegant solution.\n\n\ud83d\udc4d for _\"This information can be useful at runtime for logging\"_, hadn't thought about it.\n","@hacksparrow I think the purpose of this PR is to get the routes matched not the 'route handlers' matched. The purpose of this PR, IMHO, is to get the 'context', and not just the final route matched. I do aknowledge that it can look messy if you have a very complex route structure, but I can't see how you can make something messy, look elegant - at least not for now :)\n","Hi @danieljuhl which PR are you referring to? This is just an issue and references a few PRs, so just trying to get context on your statement.\n","@dougwilson - sorry, PR #3100 as referenced by @hacksparrow\n","Gotcha. I was thinking that, @danieljuhl , but all the examples in the #3100 seem to indicate the intention of the PR is to build the final route matched, which seems to conflict what your description of your PR. Perhaps I'm just misunderstanding here?\n","@dougwilson @danieljuhl correct, it's to get context. For me personally I'd like to construct a string that represents the matched URL. @hacksparrow has a nice solution [here](https:\/\/github.com\/pillarjs\/router\/pull\/49) that would allow one to do what my PR does, without technically adding it as a feature to express.\n","any solution for this will make me happy ;)","Another use case would be when supporting Prometheus metrics for all endpoints. To do that, one could use middleware functions at the app-level and use the `originalRoute` as value of one of the label, something like this:\r\n\r\n```JavaScript\r\napp.use((req, res, next) => {\r\n    requestsCount.inc({api: req.originalRoute, method: req.method});\r\n});\r\n```\r\n\r\nSince `req.url` could have user-id, tokens, etc, in it, we cannot use it as the values as that way the number of time-series would be too many.. Not good. So I've kinda this workaround:\r\n\r\n\r\n```JavaScript\r\napp.use((req, res, next) => {\r\n    requestsCount.inc({api: normalize(req.url), method: req.method});\r\n});\r\n```\r\n.. where `normalize` is a function which finds & replaces variable-values such as uuid, tokens, etc with something constant like `-` and just empty-string. It pointlessly consumes some CPU time. We could _avoid_ paying for this if we have `originalRoute`, or `originalPath` (whichever sounds good).","The router has been moved, and this would be a feature of the router.  You can see what IMO is the best option for this on the `Router` repo: https:\/\/github.com\/pillarjs\/router\/pull\/34\r\n\r\nAny future conversation should be had over on that thread, as it is where we would make this kind of change.","So it's impossible to have metrics for \"response times by endpoint\" using express with the current implementation of router?"],"labels":["discuss","module:router"]},{"title":"Route param error handle","body":"```\nvar webapps = express.Router();\nmodule.exports = webapps;\n\nfunction handleError(err, req, res, next) {\n    \/\/this function is not executed\n    res.send(\"hello\");\n    next();\n}\n\nwebapps.param(\"app\", function(req, res, next, name) {\n    next(\"asfaf\");\n});\n\nwebapps.route(\"\/:app\")\n    .all(handleError);\n```\n\nI am expected handleError to be executed and send a response of \"hello\", but instead \"asfaf\" is being send with status 500.\n","comments":["Ah, it's because the error handler is within the route and since the error is the parameter, the route is not actually entered.\n\nI agree though, that it would make sense to execute error handlers within the route if there was an error in a parameter for the route.\n","So if we have to catch this type of error it has to be on top of the router?\n","Yes, it has to be on the router, after your route. You can also add a second route with the same path that does not use the same parameter to try and only capture the correct error.\n\nThis change would be a pretty big behavior change, so it'll likely have to wait for 5.0, which is due this month sometime after the io.js release.\n","I'll put this in the router module though, so you can use that in any version of express, so you don't have to wait.\n","So does this remove the error middleware with 4 params?\n","No. This is to make it possible to catch errors from `app.param(name, fn)` functions within the route itself.\n"],"labels":["enhancement","5.x"]},{"title":"Feature request: Add a custom event `render` (due `req.route` & routing middleware nature)","body":"**Related links**\n\nhttps:\/\/github.com\/strongloop\/express\/issues\/2093\nhttp:\/\/stackoverflow.com\/a\/19460598\/881286\n\nA practical and real application of `req.route` would be one that you have\n- a dynamic route like `\/user\/:id`\n- a navbar and want to activate an item depending on the route (adding a CSS class),\n\nAt the view, it would be nice to do a conditional on a route definition instead of the actual url path.\n\nTo acomplish that right now it is needed to add a local variable in each route middleware definition, whis is a cumbersome task:\n\n``` js\n    router.route('\/users\/:id').get(function (req, res) {\n      res.locals.route = req.route;\n      res.render('users', {});\n    });\n```\n\n**Real deal**\n\nA nice way to overcome this would be having a general middleware that do it in a single place, but the issue is that `req.route` only gets filled when the routing middleware gets executed, so there is no way to code a separated middleware that gets executed AFTER `req.route` is defined and BEFORE the `render` method.\n\n**Conclusion**\n\nIf an Expressjs custom event existed, that gets executed just after the `render` method gets executed, it could be used to overcome this issue:\n\n``` js\napp.use(function (req, res, next) {\n    res.on('render', function(){\n         res.locals.route = req.route;\n    });\n    next();\n});\n```\n\nThanks\n","comments":["I'm leaving this open for discussion and to think about, but the obvious solution that would work right now if you needed it would be the following (so you're not blocked on discussions here):\n\n``` js\napp.use(function (req, res, next) {\n  res.render = createRouteRender(res.render)\n  next()\n})\n\nfunction createRouteRender(_render) {\n  return function render() {\n    this.locals.route = this.req.route\n    return _render.apply(this, arguments)\n  }\n}\n```\n","@dougwilson That would really work, thanks for the tip, but it could be great that other solution is provided for the long term (being the 'render' event or another one). The thing is that I don't feel quite right overwriting `.render` (if you are suggesting this then maybe the side effects are minimum to null).\n\nSo, thanks again, expecting further discussion on this :smile:\n","I have a similar issue. I'm writing an authorization middleware that goes above where the routes are all defined. In that case, `req.route` is null.\n\nSo if I'm trying to allow\/deny access in the authorization middleware based on `req.route.path` to something like `\/user\/:id`, it becomes difficult (if it's checking a path that doesn't use params, like `\/user`, then I don't need `req.route` to be available as I can just use `req.originalUrl`.\n\nI could use regexes but that becomes error prone depending on what kind of routes exist.\n","@rightaway I'm trying to resolve the same problem. Did you get the result?\n","@algebris I had exact same task as @rightaway and I ended up with adding additional layer of middleware everywhere, inside I check authorization to various routes depending on what user is allowed to do.\n\nDetails: I have object defining all routes restrictions, e.g. all req.route.path'es that should be protected, depending on users role. If route has no restrictions, I just next(), else check if user role is allowed to execute the controller, if not - render 40x.\n\nWould be great to somehow make this work without injecting another middleware layer.\n","@rzk yeah, that's would be great anyway. I need req.route.path in order to find a matches in my swagger declarations with auth, validation, caching etc. But i have a lot end-points to add middleware to all of them. So I'm still trying to find a way to make it right ...\n","Well, I don't know but I've made in yesterday dirty hack to express internals ...\nI have tested it with express@4.13.3\nIt intercepts your middleware stack with custom functions before first middleware call\n\nhttps:\/\/gist.github.com\/algebris\/1f931e112b0253249a04\n\nCould anybody verify how's it bad to do like that? I know it's just a hack but ...\n1. If you have a lot end-points you don't need to extend it with the same middleware bundle like ...\n   app.get('\/someroute', middleware1, middleware2, ... )\n2. You will gain an access to req.route.path route pattern. I need it to control validation, access, cache, etc.\n"],"labels":["discuss","ideas"]},{"title":"Option to disable ETag for certain routes?","body":"There's a need to disable ETag for certain routes, where it is a GET but the data may still change between requests - and it is mandatory to have no caching on it.\n\nCurrently the ETag processing is done after the user's code for the response, so there's no way to remove it _after_ express has added it.\n\nNow if we add a `Cache-Control: no-store`, the client will surely ignore the ETag, but then the ETag is generated for nothing, and it's an extra CRC or MD5 call which can be spared.\n\nSo I think there's a need to make the ETag conditional also on the existence of a \"no-store\".\n","comments":["oo, I think we can definitely make the ETag generation skip if there is a certain `Cache-Control` header for sure.\n\nAs for if you need something immediately, you can use this little bit of code in your route (I won't skip the actual ETag generation, but at least the header won't exist):\n\n``` js\nvar onHeaders = require('on-headers')\n\nfunction myRoute(req, res) {\n  scrubETag(res)\n  \/\/ do the rest\n  res.send('something')\n}\n\nfunction scrubETag(res) {\n  onHeaders(res, function () {\n    this.removeHeader('ETag')\n  })\n}\n```\n\nIn general, this is fitting into a general theme that has been building up: people want to be able to override app settings on a per-request basis.\n","oo this is a nice trick :+1: \n\nAre you going to add the Cache-Control condition or should I make a pull request?\n","> Are you going to add the Cache-Control condition or should I make a pull request?\n\nI think it's a great idea :) I do want to consult some RFCs just to verify that it is the right behavior to have embedded, but feel free to make a PR. :)\n","I'd say \"don't bother, I've already done that\", but that would be irresponsible of you ;-)\n","#2473 \n","So the PR has been rejected, because it turned out that bit about `no-cache` was just an assumption; browsers still consult the `ETag` and make conditional requests, even with `Cache-Control: no-cache` so it doesn't make sense for Express to not add it to those responses.\n\nAs for you being able to control the ETag on a per-response\/per-route basis, that's still a valid request :)\n","Yeah it seems to be more complicated...\nFrom further reading a combination of no-store no-cache restricts the browser more strictly, but it is a more complicated case to detect as there are many ways in which the combination can be specified.\n\nAny ideas on how to implement ETag control on a per request basis?\n","> Any ideas on how to implement ETag control on a per request basis?\n\nIt's not easy, but I'm working on it :) We basically want you to be able to override all the different app settings on a per-route\/per-request basis, and the `etag` setting would of course be one :)\n","Related to #2524\n","@dougwilson\r\n\r\nIs it possible to do this in express 4.18.1 or is this still an open FR?\r\n\r\nIf it's not possible, is the kludge (no judgment, haha) above in https:\/\/github.com\/expressjs\/express\/issues\/2472#issuecomment-67186349 still valid?","Btw, dunno how valid this suggestion is but if you're still trying to think of a way to implement it, maybe a more generic approach could be to let routes accept overrides of certain [app settings](https:\/\/expressjs.com\/en\/api.html#app.set), and internally drop those overrides in over the actual settings where possible when processing that route. Then users could set an etag app setting override for the route, and as a bonus side-effect it might open up a lot of other nice per-route settings."],"labels":["enhancement"]},{"title":"Move req \/ res prototype extension to a separate repo","body":"@dougwilson should be added to #2237\n","comments":["Extraction of the logic is almost done, but we also need to decide on where to put the properties.\n\nThe suggestion was to bundle these into \"packs\".\n\nList of req \/ res prototype properties in express 4.10.6:\n\n``` js\n\/\/ Request\n[ 'header',\n  'get',\n  'accepts',\n  'acceptsEncodings',\n  'acceptsEncoding',\n  'acceptsCharsets',\n  'acceptsCharset',\n  'acceptsLanguages',\n  'acceptsLanguage',\n  'range',\n  'param',\n  'is',\n  'protocol',\n  'secure',\n  'ip',\n  'ips',\n  'subdomains',\n  'path',\n  'hostname',\n  'host',\n  'fresh',\n  'stale',\n  'xhr' ]\n\n\/\/ Response\n[ 'status',\n  'links',\n  'send',\n  'json',\n  'jsonp',\n  'sendStatus',\n  'sendFile',\n  'sendfile',\n  'download',\n  'type',\n  'contentType',\n  'format',\n  'attachment',\n  'header',\n  'set',\n  'get',\n  'clearCookie',\n  'cookie',\n  'location',\n  'redirect',\n  'vary',\n  'render' ]\n```\n","The one very easy one is that `render()` should come with the views abstraction. (but it depends on `send()` still...)\n","As long as the req \/ res prototypes are being moved to separate repos, I wanted to ask if there was a compelling reason to keep these as middleware processes rather than just directly modifying the http streams before ever making a server?\n- It would cut down on the amount of `__proto__`  replacement logic that has been brought up in issues before.\n- It would thin out the expressInit 'mandatory' middleware. It could be similar to some of the changes in the query middleware(?)\n- The req & res objects, to be extended onto http, could still be exposed off of express (and be modular etc).\n\nStupid simple example:\nexample.js\n\n```\nvar _ = require('lodash');\nvar http = require('http');\nvar res = require('response');\n\n_.extend(http.ServerResponse.prototype, res);\n\nvar server = http.createServer(function(request,response){\n  response.render('example',{'hello':'hello world'});\n});\n\nserver.listen(8000);\n```\n\nI just tested a quick and dirty implementation with express by\n- removing `req.__proto__ = app.request;` and `res.__proto__ = app.response;`, in lib\/middleware\/init.js\n- adding the prototypes directly onto http, in application.js.\n\n```\napp.listen = function(){\n\n  \/\/ replace the servers response stream and request stream\n  http.IncomingMessage.prototype = this.request;\n  http.ServerResponse.prototype = this.response;\n\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n```\n\nIs there a compelling reason to keep `req.__proto__ = app.request;` and `res.__proto__ = app.response;` as a middleware process? I've always thought the current middleware implementation was possibly slower, uses deprecated `__proto__`, and has more mental overhead to understand\/modify. \n","No, we won't be removing the use of  `__proto__`. The reason I these cannot be globals. Users should be able to have an Express server in the same process as a plain http server and the plain http server should not have any of the Express extensions visible to it, which is what would happen if you modified the global prototypes.\n\n> I've always thought the current middleware implementation was possibly slower, uses deprecated  `__proto__`, and has more mental overhead to understand\/modify.\n\nYou can always benchmark it, but JavaScript doesn't provide any other good way to do this without global modifications. Other methods like calling a ton of Object.defineProperty on every request is slower.\n","@NickStefan the pillarjs module this is being extracted to is going to be public soon; I can assure you the implementation is far cleaner than the current. :)\n","@dougwilson Being able to have an unmodified http res req process alongside of an express app makes sense. I'm sure it gets old answering about the `__proto__`, but thanks for the explanation.\n\n@Fishrock123 Thanks. Hadn't seen pillarjs yet. Looks promising.\n","@NickStefan Another reason is that certain modules (like [node-http2](https:\/\/github.com\/molnarg\/node-http2\/issues\/100)) expect certain http res\/req methods.\n","@yoshokatana , so node-http2 inherits its `req` from another `IncomingMessage`, right? And two prototype injections sorta conflict with each other?\n\nWe probably need a way to specify which class `req\/res` should be inherited from then.\n","Yep. I'm not sure whose responsibility that is, though. I get why express uses its own req\/res objects, but I also understand why node-http2 assumes it can inherit it. Not sure what the sanest convention should be in this case.\n","Regarding the `http2` discussion, I put a comment over at their repo saying we are willing to make any changes\/fixes necessary here if someone wants to open a _new_ issue about this and perhaps an explanation of what the issue is :)\n","Yeah the only issue is that node-http2 has a different class (and because of this, different proto for instances) for requests and responses than the built-in HTTP1 implementation. Express changes the proto to an extended version of the built-in IncomingMessage. As per @dougwilson 's comment in https:\/\/github.com\/molnarg\/node-http2\/issues\/100, I will expect express 5.0 to solve this problem, and make a note about this in the node-http2 readme. Thanks :)\n","Seems related to https:\/\/github.com\/expressjs\/express\/issues\/2812 ?"],"labels":["5.x","future"]},{"title":"Optional custom json replacer\/spaces per response","body":"In some cases it is useful to be able to overwrite the json replacer at response level, in the end it is something related to the response.\n\nThis change also makes it possible to simply say: `res.jsonReplacer = null; res.json(data);` to prevent the jsonReplacer from kicking in.\n","comments":["Please come up with a different API, as adding a magical property to `res` is not what we want.\n\nPlease also read through a previous request at https:\/\/github.com\/strongloop\/express\/pull\/2098 and, if you can, provide a sample use-case for what the per-request replacer function you are trying to use.\n","Here is a better idea:\n\n``` js\napp.get('\/', function() {\n  res.body = { '...': 'any json you want' } \/\/ use that instead of res.json()\n  res.jsonReplacer = function(){ \/* whatever *\/ }\n  next()\n})\n\napp.use(function(req, res, next) {\n  if (!res.body) return next()\n  res.send(JSON.stringify(res.body, res.jsonReplacer))\n})\n```\n\nWhich doesn't require any changes to the core at all.\n","I don't think we want to use res.send for json.\n","Hi @rubenstolk , have you had time to come up with a different API yet?\n","Not yet, but I will, hopefully have some time this weekend.\n\n## \n\nRuben Stolk\n\nCHANGER, Raising the bar in Online Experience!\n\n+91 95 6105 0034\n+31 6 46 11 80 37\n\nINDIA OFFICE\n308 Sky Max, Datta Mandir Chowk, Viman Nagar, Pune \u2013 411014, India (\nhttp:\/\/goo.gl\/maps\/muZw7 http:\/\/g.co\/maps\/g9y7n)\n+91 20 65 7373 33\n\nNETHERLANDS OFFICE\nMaerten Trompstraat 25, 2628 RC Delft, Netherlands (http:\/\/goo.gl\/QQHfWE\nhttp:\/\/g.co\/maps\/tcpwn)\n+31 88 1001300\n\nhttp:\/\/changer.nl\n\nOn Fri, Oct 31, 2014 at 7:06 PM, Douglas Christopher Wilson <\nnotifications@github.com> wrote:\n\n> Hi @rubenstolk https:\/\/github.com\/rubenstolk , have you had time to\n> come up with a different API yet?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/strongloop\/express\/pull\/2422#issuecomment-61260391.\n","If you really think it is a good idea to add it to express itself, the best api as of now would be this:\n\n``` js\nres.set('json replacer', function(){})\nres.json(data)\n```\n\nThus, allowing to override any `app.set()` with `res.set()` for an individual request.\n\nI'd totally went for it in `express@3`. But express becomes more modular nowadays, and now I doubt that `replacer` is even worth having here.\n","I don't like the idea of `res.set('json replacer', function(){})`\n\nMainly because set\/get probably will not not exist in 5 and this is additional overhead.\n\nCan we do `res.json(data, replacer)`?\n","> Can we do res.json(data, replacer)?\n\n`res.type('json').send(JSON.stringify(data, replacer))`\n\nOtherwise `res.json(data, replacer)` is ambiguous, because `data` could be a number and `replacer` could be `null`, which is why they form has been turned down before.\n","> Otherwise res.json(data, replacer) is ambiguous, because data could be a number and replacer could be null, which is why they form has been turned down before.\n\nem, pardon?\n\nIsn't json(num, data) being removed in 5.x?\n","I was under the impression this PR was a feature request for 4, since that is where is PR is based. @rubenstolk what version are you requesting this feature in?\n","@dougwilson I'm not sure it matters.\n\nI'm wondering where we can implement the most reasonable interface for the feature.\n","@Fishrock123 I was just saying your suggestion is impossible to implemented in 3\/4 is all, as it will break current (deprecated) uses of `res.json`.\n\nWhat is wrong with `res.type('json').send(JSON.stringify(data, replacer))`?\n","Plus I'm still waiting the hear what the use-case is for a per-request json replacer. The provided use-case from the last time this was requested was fundamentally flawed and made no sense, which contributed to why it wasn't added.\n","> What is wrong with `res.type('json').send(JSON.stringify(data, replacer))`?\n\nNothing actually. I forgot that this was actually stringifying it. >_<\n\nThis is the most reasonable approach yeah. I don't think we should add it regardless of use case.\n","Guys, I wasn't aware of the fact that we could use `.get` and `.set` on `res` as well, so I've changed that at least. I think current solution is really good and pragmatic. You can now either set the `json replacer` on app level or on response level.\n\nMy use case:\n- We have an app that has a 'global' `json replacer` that strips out certain unwanted properties from all of our models (for example, mongoose models icw `toObject` always results in `__v` and `id` properties which we do not want in our json), so we strip them out.\n- Now, on one of our api's (a legacy one used by and older production version of a client) needs to have the `id` property. Since we currently only have the option to define `json replacer` at app level, we can't override this. (Except using the custom `res.send` as suggested by some people above, but I really don't like that because our framework is fully convention based and our generic api-layer takes care of the `res.json`).\n- My preferred suggestion: accept this pull request, it doesn't harm anything but allows more flexibility.\n- My alternative suggestion: remove `json replacer` from app level, but come up with an alternative to make the behavior of `res.json` overridable. Currently the `res.json` method does not allow for customizing the behavior at all, which is limiting imho.\n","> Guys, I wasn't aware of the fact that we could use .get and .set on res as well, so I've changed that at least.\n\nYou... can't. It was a suggestion for a possible implementation, but you'd have to fully implement `res.set` and `res.get`...\n","OK got it, I'll come up with something else then, give me more time.\n","> Uhm, why is it working then?\n\nBecause `res.get('json replacer')` calls `res.getHeader('json replacer')` which is just returning `undefined`, since there is no `json replacer` header set. You never tried to add tests for the feature you added to notice?\n","Using your code right now, the following app:\n\n``` js\nvar express = require('.\/index')\nvar app = express()\n\napp.set('json replacer', function (key, value) {\n  if (key === 'id') return\n  return value\n})\n\napp.use(function (req, res) {\n  res.set('json replacer', function (key, value) {\n    if (key === 'secret') return\n    return value\n  })\n\n  res.json({\n    id: 3,\n    secret: 'keyboardcat',\n    name: 'loki'\n  })\n})\n\napp.listen(3000)\n```\n\nResults in the following HTTP response:\n\n```\n$ curl -i http:\/\/localhost:3000\/\nHTTP\/1.1 200 OK\nX-Powered-By: Express\njson replacer: function (key, value) {if (key === 'secret') returnreturn value}\nContent-Type: application\/json; charset=utf-8\nContent-Length: 38\nETag: W\/\"26-3a6fc2e6\"\nDate: Sat, 01 Nov 2014 03:55:17 GMT\nConnection: keep-alive\n\n{\"secret\":\"keyboardcat\",\"name\":\"loki\"}\n```\n\nNotice how the json replace I tried to set with `res.set` not only didn't apply to the body (because the \"secret\" key is still there), but the body of the function appears as a response header.\n","Oh, sorry @rubenstolk I didn't realized you replied. You can just make a new comment rather than replying by completely replacing the content of an old comment, which is really confusing and doesn't let me know you made a reply.\n","Oh, and FYI, to me the use-case for adding this I guess sounds valid, though using express to do your DTO -> DTO transformations seems a little heavy-handed to me.\n","Well, I'm not using express per se for it, but express has a `json replacer` setting which is meant for this purpose right?\n","@dougwilson What do you think about the current approach? A separate 'createJSON' method which is used by both `res.json` and `res.jsonp`. Now we can just override `createJSON` on res if needed which will solve my need.\n","Interested to hear if this is going to work out or not. FYI, currently I'm living with this patch in my code:\n\n``` js\n  \/\/ TODO: this is a non desired override because it might not survive express updates\n  \/\/ Hopefully https:\/\/github.com\/strongloop\/express\/pull\/2422 works out\n  app.response.__proto__.json = function (obj) { \/\/ jshint ignore:line\n    var replacer = typeof this.jsonReplacer !== 'undefined' ?\n      this.jsonReplacer : this.app.get('json replacer');\n    var spaces = typeof this.jsonSpaces !== 'undefined' ?\n      this.jsonSpaces : this.app.get('json spaces');\n    var body = JSON.stringify(obj, replacer, spaces);\n    if (!this.get('Content-Type')) {\n      this.set('Content-Type', 'application\/json');\n    }\n    return this.send(body);\n  };\n```\n","So, it's still open because we _need_ to address this (the issue about the replacer\/spaces scope) in some way, but I'm not sure the current implementation in the PR would work out, i.m.o.\n","While I don't have a use for setting `json replacer` on the response level, I [do have a use](https:\/\/github.com\/strongloop\/express\/pull\/2469) for setting `json spaces`.  I'm not sure there is a great way to implement this without messing up the API but, I'm thinking about something along the lines of \n\n```\nres\n    .config({\n        \"json replacer\" : function() {...},\n        \"json spaces\" : 0\n    })\n    .json(data);\n```\n\nBasically, `.config` could be used to set properties of the response that are not headers. Do you think something like that would be consistent enough with the API?\n","Likewise, I could see something like\n\n```\nres\n    .config(\"json spaces\", 0)\n    .json(data);\n```\n","+1. This would be very helpful when escaping output from certain requests, and not from others.\n"],"labels":["discuss","enhancement","pr"]},{"title":"route() should handle 405 Method not allowed","body":"I know this has been discussed in numerous issues here, but not about this specific case.\n\nIMHO the following code\n\n``` js\napp.route('\/user\/:id').get(oneUser).delete(delUser).put(updateUser);\n```\n\nshould send `405 Method Not Allowed` for a `POST` request to `\/user\/123`.\n\nI can of course workaround this easily by adding a `.all(send405)` to all of my `route()` calls but I couldn't find any variable in req that would expose what methods the route does have (for `Allow` header).\n\nI know there are a ton of ways how `POST \/user\/123` could still be defined, but if you do call `.route()` then it would be IMO reasonable to believe that it is the only way of  defining methods for that one route.\n\nSo I suggest three alternative ways how I'd like this to be fixed (in the order of preference):\n1. Make it the default behavior to send a correct 405 response if route() does not have that method.\n2. Make it configurable (per router or something) to automatically send 405 responses.\n3. Expose configured methods to be self used in `all()`.\n\nThis most likely will raise the question about 'How about when GET returns 404, then POST should also return 404 even though with a different id it should send 405.'\n\nI kinda agree, and this is why I add first in chain a method:\n\n``` js\nvar withUser = function(req, res, next) {\n  fetchUser(req.params.id, function(err, user) {\n    if (err) return next(err);\n    if (!user) return res.status(404).end();\n    req.user = user;\n    next();\n  });\n};\n\nrouter.route('\/users\/:id').all(withUser).get(sendUser).put(updateUser).delete(deleteUser).all(send405);\n```\n","comments":["`#1` is not backwards-compatible, so just won't happen in 4.x and the others are really just cumbersome or something. I would envision this as the API, what do you think?\n\n``` js\n\/\/ route-specific\napp.route(path, { automatic405: true })\n.get(handler)\n\n\/\/ router-wide default\nvar router = express.Router({ automatic405: true })\n\n\/\/ can be overridden\nrouter.route(path, { automatic405: false })\n.get(handler)\n```\n\nThis would go along with how other things like the automatic HEAD and OPTIONS settings would be handled. What do you think?\n\nThe remaining open question is how would the following work? Would it be a compile-time error? Would the `post` just never be called and lead to much confusion among users? Something else?\n\n``` js\nvar router = express.Router({ automatic405: true })\nrouter.route(path)\n.get(handler)\n.put(handler)\nrouter.post(path, handler)\n```\n","IMHO the .post() could add a debug log (like the deprecation warnings from res.send(201, {}) etc) saying something like `POST handler for <path> will never be called, check your routes`.\n","Otherwise I like the API, something I'd use with pleasure.\n","@dougwilson  any update on that issue? It really is something that would be nice to have! :+1: \n\nI guess a compile-time error would be perfect. It wouldn't break existing code because it would only send the error if a route is added on a path when automatic405 is true. I guess that makes sense!\n","For some reason this issue slipped by me this last release, otherwise I soul have added it. I'm sorry!\n","Awesome! Thanks for the update and nice work on last release!\n","+1 In the meantime is there a way to \"Hack\" around this?\n","> In the meantime is there a way to \"Hack\" around this?\n\nThere may be a clever way, but the simplest way is to add a `.all` on your route:\n\n``` js\nrouter.route('\/some\/path')\n.get(getHandler)\n.post(postHandler)\n.all(methodNotAllowedHandler)\n\nfunction methodNotAllowedHandler(req, res) {\n  res.sendStatus(405)\n}\n```\n","@dougwilson Thanks for the quick response, that doesn't seem like a bad idea. Thanks\n","@dougwilson  any update on that!? Thanks a lot!\n","PRs are welcome!\n","Hi, I noticed there are PR's for this. So what is the state of this, how can I contribute to it?","Hey @moar55, this example was merged on the router package which might help.  https:\/\/github.com\/pillarjs\/router\/pull\/63\r\n\r\nI think the current answer is that we will not be adding a feature to directly support this, but there is a decent work around if you want your api to support it.  I think if there was sufficient demand, and a really good PR showed up then we would reconsider, but that is not where it is at now.  If you want to generate that PR and demonstrate the demand I am happy to comment\/help more.","Please any new regarding this issue as still not working in express 5.x\r\n","Hi,\r\nWhat is the current state of this issue?\r\nIf it is still open, can I contribute to it?\r\n\r\nThanks,\r\nSrikar","Hey @srkyaganti, you can start by looking at these related issues and PRs:\r\n\r\nhttps:\/\/github.com\/pillarjs\/router\/pull\/63\r\nhttps:\/\/github.com\/pillarjs\/router\/pull\/70\r\nhttps:\/\/github.com\/expressjs\/express\/issues\/3790\r\n\r\nBut I think where this was left is that it is possible today, and all the proposed solutions are breaking changes, so probably not going to land.","@dougwilson are you still open to an API similar to the one you envisioned in [this comment](https:\/\/github.com\/expressjs\/express\/issues\/2414#issuecomment-60535119)?\r\n\r\nIt could be helpful to also add opt-in flags for `OPTIONS` request handling at the same priority as the route, as it is currently difficult to use the built-in `OPTIONS` request handling when using any catch-all middleware.\r\n\r\n```js\r\nvar router = express.Router({ automaticOptions: true })\r\n```\r\n\r\nAnother nice feature would be the option to pass a middleware function to the flag:\r\n\r\n```js\r\nfunction handleMethodNotAllowed(req, res) {\r\n  res.status(405).send(\"no!\");\r\n}\r\nvar router = express.Router({ automatic405: handleMethodNotAllowed })\r\n```\r\n\r\nIn terms of your concern:\r\n> ```js\r\n> var router = express.Router({ automatic405: true })\r\n> router.route(path)\r\n>   .get(handler)\r\n>   .put(handler)\r\n>  router.post(path, handler)\r\n> ```\r\n\r\nI think it would be most user-friendly if this threw a compile-time error providing useful info, for example that `next('route')` would allow the `POST` middleware to be reached, etc. \r\n\r\nThe problem with that, then, is detecting 'equivalent' routes:\r\n\r\n```js\r\nvar topLevelRouter = express.Router();\r\nvar childRouter = express.Router();\r\n\r\nchildRouter.route(\"\/bar\")\r\n  .get(...);\r\n\r\ntopLevelRouter.use(\"\/foo\", childRouter);\r\n\r\ntopLevelRouter.route(\"\/foo\/bar\")\r\n  .get(...)\r\n```\r\n\r\nand then the implementation starts to get complicated.\r\n\r\nMaybe a more elegant solution would be to expose (in a library) the `OPTIONS` and 405-handling middleware, so that similarly to [this comment](https:\/\/github.com\/expressjs\/express\/issues\/2414#issuecomment-76436006), users could\r\n```js\r\nimport { optionsHandler, methodNotAllowedCatcher } from \"express\";\r\n\r\nrouter.route(path)\r\n  .get(handler)\r\n  .options(optionsHandler())\r\n  .all(methodNotAllowedCatcher())\r\n```\r\n\r\nAnd in that case, why not place those as instance methods onto the `Route`:\r\n```js\r\nrouter.route(path)\r\n  .get(handler)\r\n  .automaticOptions()\r\n  .automatic405()\r\n```\r\n"],"labels":["enhancement","help wanted","5.x"]},{"title":"Disable ETag for `res.sendFile()`","body":"`res.sendFile()` accepts an option to disable ETags. It would make sense that `app.disable('etag')` sets `sendFile()`s `options.etag` to `false` for you. This is a breaking change so it would have to wait for `5.x`.\n","comments":["@ritch did this make it into 5.x already?\n","Hi @ilanbiala you can look at #2237 to see what has been checked off. The answer for this is no, especially since there is not hard date for 5.0 yet.\n"],"labels":["enhancement","5.x"]},{"title":"'\/' route breaks strict routing","body":"Hi there,\n\nCurrently, if you define a route like this:\n\n``` javascript\nroute = require('express').Router({strict: true});\nroute.get('\/', function(req, res) {\n  res.send('hi');\n});\n```\n\nAnd `use()` that in an express application like this:\n\n``` javascript\napp = require('express')();\napp.use('\/strict\/', route);\n```\n\nYou will receive a 200 when requesting `\/strict\/` and `\/strict`. I would expect only `\/strict\/` to return a 200.\n\nI've found an acceptable workaround by adding a check like this:\n\n``` javascript\nroute.get('\/', function(req, res, next) {\n    if (req.originalUrl.slice(-1) != '\/') return next();\n    res.send('root with slash');\n});\nroute.get('\/', function(req, res) {\n    res.send('root without slash');\n});\n```\n\nBut I think it would be less surprising if `route.get('\/')` only worked for the path ending in `\/` when strict routing is enabled, and perhaps `route.get('')` could be used for the no-slash case.\n","comments":["try defining a route for '\/strict' as well, I think that's the functionality of strict routing, you have to provide a route to handle for both.\n\n```\napp = require('express')();\napp.use('\/strict\/', route);\napp.use('\/strict', route);\n```\n","When the route gets passed to trim fix it adds the \/ to the \/strict request... as it evaluates the path as '' when it arrives at trim fix and trimfix assures a leading slash.\n","https:\/\/github.com\/strongloop\/express\/blob\/master\/lib\/router\/index.js#L247\nthe req.url is '' but becomes '\/' after.\n","It seems that settings in the router are not being passed to express... as such the strict setting in the router is being ignored, it apparently is expecting express's `.enable(\"strict routing\")` for anything `.use` related.\n","@sgentle  Its working perfectly for me(https:\/\/gist.github.com\/arjunrp\/dba902fe3c1a0dba6f8d). Can u give a sample code?\n","@arjunrp sample code is in the first post. all the code is one example, just split up by the explanation.\n","@dougwilson  I checked it out with the latest version,its working properly\n","i just retried and it's still broken. here is the simplest example to demonstrate:\n\n``` js\nvar express = require('express')\nvar app = express()\nvar router = express.Router({ strict: true })\n\nrouter.get('\/', function (req, res) {\n  res.send('hi!')\n})\n\napp.use('\/strict\/', router)\napp.listen(4000)\n```\n\n`GET \/strict` should probably be 404, but it isn't. That's what @sgentle is reporting. The issue still exists in 4.9\n","Another related case...\n\n``` javascript\nvar express = require('express');\nvar app = express();\nvar router = express.Router({ strict: true });\n\nrouter.use('', function (req, res) {\n  res.send('hi');\n});\n\napp.use('\/strict', router);\napp.listen(4000);\n```\n\n`GET \/strict` should give 200 and `GET \/strict\/` should give 404, but both give a 200. Or is there another way to route a path to the routers root?\n","@danieljuhl the issue is really a fundamental functionality of API guarantees within the router. The only work-around right now is to make both routers strict (your app with strict routing and the router strict) or use the work-around posted in the initial issue comment.\n","@dougwilson I'm not sure, if I fully understand the work-around you're explaining. So far, I can't manage to get the result I'm looking for, no matter how many times I declare the app and the router strict. Can you provide a sample of how to accomplish this?\n","@danieljuhl the work-around was posted above in https:\/\/github.com\/strongloop\/express\/issues\/2281#issue-39535754 by the original user :) For the code you posted, here is the work-around added to it:\n\n``` js\nvar express = require('express');\nvar app = express();\nvar parseUrl = require('parseurl');\nvar router = express.Router({ strict: true });\n\nrouter.use('', function (req, res, next) {\n  if (parseUrl.original(req).pathname !== req.baseUrl) return next(); \/\/ skip this for strictness\n  res.send('hi');\n});\n\napp.use('\/strict', router);\napp.listen(4000);\n```\n","@dougwilson Sorry, I read your comment, as if there were two work-arounds (the one you re-posted) AND another one using strict-routing on both application and router.\n","+1, having the same issue. I have enabled strict routing at the app level and at the router level. Seems like this should still be classified as a bug?\n","It's an extremely difficult fix, but can be done, just needs some effort for probably 5.0. I'll fix the labels :)\n","``` js\nvar express = require('express');\nvar app = express();\napp.set('strict routing', true);\nvar router = express.Router({ strict: true });\n\nrouter.use('', function (req, res, next) {\n  res.send('noslash');\n});\n\nrouter.use( '\/', function(req, res) {\n    res.send('slash');\n});\n\napp.use('\/strict', router);\napp.use('\/strictslash\/', router);\n\napp.listen(4000);\n```\n\nFor the code above, here are some test cases that can be used by whoever works on this:\nGET \/strict -> noslash\nGET \/strict\/ -> noslash (expect slash)\nGET \/strict\/\/ -> noslash (expect 404)\nGET \/strictslash -> noslash (expect 404)\nGET \/strictslash\/ -> noslash\nGET \/strictslash\/\/ -> noslash (expect 404 or slash - not sure)\nGET \/strictslash\/\/\/ -> noslash (expect 404)\n","@dougwilson Just FYI, all these issues are fixed on latest `path-to-regexp` (I fixed it last July) and should be possible to backport. Also, in the latest `path-to-regexp` you no longer need to do the `req.url || '\/'` hack.\n\nEdit: Sorry, you're right. Forgot about `.use('\/test', route)` and `route.get('\/')` still working with `\/test`. However, there's enough catches there that you hopefully can just do `if (!options.strict) { req.url = req.url || '\/'; }`\n","@dougwilson Just wanted to clarify the previous message. It's actually _all_ provided out of the box with the latest `path-to-regexp` version and those changes could be back-ported (maybe some odd incompatibility though). I realised that a `\/` regexp that's not strict will actually match an empty string anyway. Same with the reverse definition. So it should pass all expected tests in strict and non-strict.\n","The issue here is with Express and the way the `router` works, rather than anything with `path-to-regexp` :) Essentially what happens in the reported case is that `req.url` will never, ever be set to an empty string by Express, but it's not a possible valid value, ever. Instead if Express's router is about to set `req.url` to an empty string, it sets it to `\/` instead. The sub router will not pick up the fact that there was no trailing slash is the issue. That can be fixed by Express by mucking about within `req.originalUrl`.\n","I've looked through the code and found that before, but why wouldn't you consider an empty string to be valid? It's factually correct (`\/test` vs `\/test\/`) and would be matched still with the single slash regexp in the latest version. I just wanted to confirm that it's all currently possible without mucking with the path logic and you can fully rely on the regexp to be correct now.\n","> but why wouldn't you consider an empty string to be valid?\n\nBecause it's the contact of the `req.url` API from Node.js. The first line of an HTTP request is in the form `<method> <path> HTTP\/<version><CR><LF>`. `req.url` refers to whatever the exact string that appears in the `<path>` portion and `GET  HTTP\/1.1` (that is, `GET<space><space>HTTP\/1.1`, because GitHub seems to ignore the double-space when rendered) is a syntax error (where the `<path>` would resolve to an empty string). As such, we will not violate the expectation that `req.url` cannot be an empty string.\n","Interesting, thanks. I wasn't sure if this would be treated differently with nested routing.\n","Nope :) We want the nested stuff to think they are not even nested, which really helps with reusable code. `serve-static` does similar `req.originalUrl` \"mucking\" that I can pictures the router doing to be able to handle this case. Express may very well decide to pass something into `path-to-regexp` regular expressions that are not always exactly `req.url`, if it works :)\n","Hi, I'm having a similar issue in 4.x branch:\nhttps:\/\/github.com\/expressjs\/express\/blob\/4.x\/lib\/router\/index.js#L466\n\nPoked around the code base for reasons behind this:\n\npath-to-regex considers 'strict' an option which means:\n\"Match ^path$ instead of ^path(?|\/?)$\"\nWhile express expects 'strict' only influence trailing slash.\n\nEven if I enforce 'strict' inheritance in this particular line -- I end up with middleware no longer working on child paths ('\/path\/sub\/' no longer triggers middleware mounted on '\/path\/', since path-to-regex with 'strict' no longer matches).\n","Hi @xytis, I'm not sure what you are reporting, I'm sorry. That line forces `strict` mode for a specific reason, and it is not meant to be changed. If you can please _open a new GitHub issue_ (https:\/\/github.com\/expressjs\/express\/issues\/new) and describe your issue, and even better if you provide code we can use to reproduce the issue with the current version of Express, we would be happy to look into the issue (but please make a new issue).\n","Code example:\n\n```\napp.enable('strict routing');\nrouter = ...\napp.use('\/path\/', router);\n```\n\nFrom documentation I would expect that my application will not serve \"\/path\" endpoint, yet it gets forwarded to given router.\n\nLine of code that I reference basically says \"do not perform strict routing on internal layers\". Which, by my understanding, is exactly what I expect in above example. I went deeper into path-to-regex of currently used version found the inconsistency in \"strict\" definition, which I mentioned earlier.\n\nI am not sure if this requires a separate issue, since, by the looks of it, it will be fixed as soon as express updates it's dependancy of path-to-regex.\n","> .From documentation I would expect that my application will not serve \"\/path\" endpoint, yet it gets forwarded to given router.\n\nUnfortunately the documentation in this case is simply wrong. The strict routing feature in no way affects paths under app.use, and it is not intended to. This issue is definitely different from what you are describing.\n\n> I am not sure if this requires a separate issue, since, by the looks of it, it will be fixed as soon as express updates it's dependancy of path-to-regex.\n\nIt will not, because app.use is not affected by strict routing, and will always act in a non-strict manor.\n\nThere is a lot of off topic chatter in this thread, and some is issues like yours that are actually misunderstandings and some are of the original bug. The bug is only the code in the initial post. It is a bug because router.get is being used, which absolutely should be enforcing strict routing. Your code is not utilizing any methods that actually are affected by strict routing.\n","If you don't care about supporting empty paths, using the below middleware seems to enforce strict routing:\r\n\r\n```js\r\n\/\/  Results:\r\n\/\/\r\n\/\/  GET \/strict -> (404)\r\n\/\/  GET \/strict\/ -> slash\r\n\/\/  GET \/strict\/\/ -> (404)\r\n\/\/  GET \/strictslash -> (404)\r\n\/\/  GET \/strictslash\/ -> slash\r\n\/\/  GET \/strictslash\/\/ -> (404)\r\n\/\/  GET \/strictslash\/\/\/ -> (404)\r\n\r\nconst express = require(\"express\");\r\n\r\nconst app = express();\r\napp.set(\"strict routing\", true);\r\n\r\nconst router = express.Router({ strict: true });\r\n\r\n\/\/  Middleware to enforce strict URLs\r\n\/\/  Note: must be applied to the router (and not app)\r\nrouter.use(function strict(req, res, next) {\r\n  if (req.app.get(\"strict routing\")) {\r\n    req.url = req.originalUrl.substring(req.baseUrl.length);\r\n  }\r\n  next();\r\n});\r\n\r\n\/\/  This solution does not support empty paths like these:\r\n\/\/  router.use(\"\", function (req, res, next) {\r\nrouter.all(\"\", function (req, res, next) {\r\n  res.send(\"noslash\");\r\n});\r\n\r\n\/\/  Note: using .use() will not work, use methods instead (all, get, post, etc):\r\n\/\/  router.use(\"\", function (req, res, next) {\r\nrouter.all(\"\/\", function(req, res) {\r\n    res.send(\"slash\");\r\n});\r\n\r\napp.use(\"\/strict\", router);\r\napp.use(\"\/strictslash\/\", router);\r\n\r\napp.listen(4000);\r\n```","@dougwilson Is there any more information in regard to 'mucking about' with the original url?\r\n\r\nWe really would like to use ourcompany.com as address and not ourcompany.com\/\r\n\r\nTo be fair we use express mostly in a debug environment and the serverless routing support routes without trailing slashes. It would be great if the same links work in the express debug environment.","Hi @dbauszus-glx sorry you are having issues. Your description, to me, sounds like a more specific bug instance. Would you be willing to open a new issue about this and include a reproduction case? I believe for your specific scenario (\"We really would like to use ourcompany.com as address and not ourcompany.com\/\") it is the Node.hs HTTP server that is at issue here which is why it works serverless (it's not used) vs not (we use it to parse the HTTP requests).","@dougwilson I will have to come back to this once a I get a chance to deploy an express instance. At the moment we use Express only for debugging which means I can only describe the problem with localhost which is probably not very helpful. I understand that req.url may not be empty and would expect `app.get(\"\", handler)` to return localhost:3000\/. I am only surprised why req.url is empty when I set `app.get(\"\/root\", handler)` and returns localhost:3000\/root instead of localhost:3000\/root\r\n\r\nI will do a bit more reading on this and get back on this once I am better capable of explaining the issue. It's very low impact for now and I plan to use a micro router for my debug case in the future.","I use middleware for add \/ and redirect all routes in new address.\r\nI fink it's possible to use in strict mode.\r\n```javascript\r\napp.use((req, res, next) => {\r\n  const url = req.url;\r\n  const fileRegExp = new RegExp(\/\\.\/);\r\n  const isParams = Object.keys(req.params).length;\r\n  const isQuery = Object.keys(req.query).length;\r\n  if(url.length && fileRegExp.test(url) || isParams || isQuery){\r\n    next();\r\n  } else if(url.length && url.slice(-1) != '\/') {\r\n    res.redirect(301, `${url}\/`);\r\n  } else {\r\n    next();\r\n  }\r\n});\r\n```"],"labels":["bug","5.x"]},{"title":"Default responder should not console.error 4xx errors","body":"Right now the default handler (last step) will `console.error` when it gets an `err`, otherwise 404. I think that it probably shouldn't `console.error` when the `err` it got was a 4xx error, mainly because a 4xx is supposed to be a client error, of which the server admin probably cannot do anything about. Adding a custom error handler could, of course, let the user log 4xx error all they wanted--this is just about the default behavior. It could probably wait until express 5, though.\n","comments":["+1\n",":+1: 5.0\n","I agree this should be removed. In a hello world express app, you'll sometimes get a nasty error printed when the browser tries to grab `\/favicon.ico` which is pretty annoying.\n\n> It could probably wait until express 5, though.\n\nWe should avoid removing behavior (however lame it might be) in a minor version. Anything landing in 4.x should be additive or fixes until 5. This change may actually be breaking, even though it seems like it wouldn't. Eg. someone might have a log parser that relies on this error, who knows.\n","> Anything landing in 4.x should be additive or fixes until 5. This change may actually be breaking, even though it seems like it wouldn't. Eg. someone might have a log parser that relies on this error, who knows.\n\nThus the reason I said it should land in 5 :)\n","The reason I only _suggested_ it wait for 5 is because there is a bunch of work around it. If it were to change, it should be made configurable. Of course if it's configurable, it could then easily land on 4 with the default config having it operate as it does now. Standard back-compat stuffs.\n","Also, feel free to read through all the git commits in the history, at least through all the ones over the past couple months. They demonstrate that back-compat pattern well, giving people the ability to opt-in to cool new stuff, but not change the existing behavior for people who do nothing, etc.\n","> The reason I only suggested it wait for 5 is because there is a bunch of work around it.\n\nMakes sense. So would the ideal approach (with a bunch of work) be to land the ability to configure in 4.x and change the default in 5?\n","> So would the ideal approach \n\nI already highlighted the ideal approach in the comment below what you quoted :)\n","Haha not sure how I missed that you said exactly that.... Re-reading my comment it doesn't make any sense. What I'm getting at is that I'd like to take this on and do it the right way.\n\nCan we mark this as 4.x? Or is there anything else to sort out?\n","Would something like this be considered a reasonable back-compatible solution?\n\n``` diff\ndiff --git a\/lib\/application.js b\/lib\/application.js\nindex 0ee4def..47e573a 100644\n--- a\/lib\/application.js\n+++ b\/lib\/application.js\n@@ -76,6 +76,7 @@ app.defaultConfiguration = function defaultConfiguration() {\n   this.set('query parser', 'extended');\n   this.set('subdomain offset', 2);\n   this.set('trust proxy', false);\n+  this.set('log client errors', true);\n\n   \/\/ trust proxy inherit back-compat\n   Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n@@ -625,6 +626,10 @@ app.listen = function listen() {\n  *\/\n\n function logerror(err) {\n+  if (!this.get('log client errors')) {\n+    var status = err.status || err.statusCode || res.statusCode || 500;\n+    if (status >= 400 && status <= 499) return;\n+  }\n   \/* istanbul ignore next *\/\n   if (this.get('env') !== 'test') console.error(err.stack || err.toString());\n }\n```\n","@tunniclm, we should focus on getting the needed changed into Express 5.0 instead of adding more weird back-compat solutions. There are already two solutions for Express 4.x users can use for this, and so adding yet another solution is, i.m.o., not very valuable.\n\nCurrently the best solution in Express 4.x is to just handle your errors with an error middleware and not forward 4xx ones to the default handler.\n\nAs part of the \"minimalist web framework\" ideology of Express, we historically favor not adding a bunch of configuration switches, as by the time we're done, you may as well just use Hapi.js :)\n","@dougwilson That's fine by me. I assume the next step is to raise a pull request against pillarjs\/router then (with a forward-looking change)?\n","Hi @tunniclm, I was hoping the labels would make it clear which mode these issues correspond to :) This is for the `finalhandler` module and it's already been implemented: https:\/\/github.com\/pillarjs\/finalhandler\/commit\/0a6847daeaa534df8aeaa7bb3e7d39568648a0a7\n","Sorry, wrong commit; I'll have to take a look later, but yea, this is against the `finalhandler` module.\n","@dougwilson Arg, so many issues relate to the router I think my brain went on autopilot. \nAlthough, I thought this change might be in application.js  because I expected that the `onerror` handler should be called even for 4xx error codes, but just the `onerror` handler for the default handler shouldn't log them.\n\nIs that incorrect, is the intention that the `onerror` not be called for `4xx` status codes at all (even if it is a user provided function)?\n","Hi @tunniclm, there are really two parts here: a change to `finalhandler` and then a change in `application.js`, though that needs to be moved into a new module in `pillarjs` as well.\n\nThe built-in error logging that is implemented in the `application.js`-split module should use a 1.x version of `finalhandler` that provides the detected `status` to the logging function, otherwise all you're doing is duplicating the logic to get the status from the `err` object, which sucks for maintainability and the ability to reason about the program flow (for example, your patch will still log for `err.stats = 201`, which is confusing).\n\nSo once `finalhandler` is changed to provide the status code (and yes, it would always be invoked, even on 4xx errors, as it would be invoked whenever there was an `err` object), then the new module that is built to replace the `application.js` file would use it and this new logic. This issue is the over-all tracking towards these Express 5.0 features.\n\nI hope that helps! From the previous discussions over a year ago, some of which is written down in the 5.0 pull request in this repo, there are no 5.0 changes that will be in this repository; 5.0 will consist of implementing new features in other modules & extracting all existing functionality into new modules. Implementing new 5.0 features in this repository is in general not working towards the 5.0 goal of extraction.\n","> The reason I only suggested it wait for 5 is because there is a bunch of work around it. If it were to change, it should be made configurable. Of course if it's configurable, it could then easily land on 4 with the default config having it operate as it does now. Standard back-compat stuffs.\n\nJust to check vs this earlier comment, are we saying this behaviour should not be configurable in 5?\n\nAlso, regarding refactoring parts of application.js out into a new module, it seems like it would be better to do that under an issue specifically for that purpose and refer to that from here.\n"],"labels":["ideas","5.x","module:finalhandler"]},{"title":"Deprecate res.send(obj) json overload","body":"This is an idea for removing the `res.send(obj)` signature and it's other similar signatures that will `JSON.stringify` the value and send it as JSON. In my opinion there is no reason you cannot just type `res.json` instead. Deprecating and removing this overload will mean people do not have to make sure their variable to `res.send` is a string to get HTML output.\n","comments":["Sounds reasonable.\n","meh i would just leave it. makes it easier for newer people.\n\n>  make sure their variable to res.send is a string to get HTML output.\n\nwhat does this mean? if anything, we could deprecate `res.send(Buffer)` since i don't see the point of doing that. supporting only strings or JSON objects doesn't sound unreasonable.\n","> what does this mean?\n\nIt means\n\n``` js\nrenderPage(function(err, page){\n  if (err) return next(err)\n  res.send(page)\n})\n```\n\nwill suddenly send JSON if that function returned something weird by mistake (like a `null`). In `res.send`, `null` and `undefined` actually have two different behaviors because of the JSON stuff, which `res.end` does not suffer from (but `res.end` does not give automatic conditional responses and `ETag`s).\n\n> we could deprecate res.send(Buffer) since i don't see the point of doing that\n\nNo, I disagree. Using a `Buffer` is necessary if you are going to send your HTML in a different charset than UTF-8 (using something like `iconv` to encode). I do think that `Buffer` values should probably set the content-type to `text\/html`, though. If `res.send` did not accept `Buffer`, then we'd need to add another method that did, because it's the way you get `ETag` and conditional responses for free.\n\nTL;DR I think `res.send` should just send `text\/html` out, just like `res.json` only does `application\/json`, instead of mixing a bunch of things together.\n","I just think it's unnecessary API breakage. Other than that, it doesn't really matter to me\n","Right, it's just a thought right now. If we did make this change, though, you could do neat stuff like this:\n\n``` js\nres.get('\/', function (req, res) {\n  var page = new Page()\n  res.send(page)\n})\n\nfunction Page() {\n}\nPage.prototype.toString = function toString() {\n  \/\/ return the constructed page contents\n  return '<html>' + this.data + '<\/html>'\n}\n```\n","+1 for not doing magic in `.send` for objects. Calling toString seems sensible over automagically returning JSON.\n","Overall, I think forcing the arg to a string and sending only HTML is a good answer (especially since we have `res.json` already for a long time), but I was thinking on @jonathanong 's point and thinking maybe to not deprecate `res.send(obj)` until after 5.0 is released so it would be scheduled for removal in a 6.0, idk yet.\n","i like the `Page()` idea. we could do some crazy stuff and check `if (typeof obj === 'object' && obj.constructor === Object)` and only `JSON.stringify()` if that's the case. hahaha\n","Though people may be sending in objects right now that instead have a `toJSON` on their prototype, since it's getting passed to `JSON.stringify` right now.\n","+1 for the sake of consistency. If you want to send json, you have `res.json()`. Best to have one interface for one thing.\n","This is an interesting topic. It's nice to be able to just res.send whatever I like and it just gets handled but at the same time res.json is more accurate and simplifies the res.send if object handling were removed.\n\nOne use case I have for keeping it in res.send is if I use a bunch of middleware that will append \/ overwrite an attribute res.output to either be:\n- json object\n- string\n- statuscode\n\nI don't have to check the type in the final middleware when I do res.send(res.output). At the same time, it's not hard to do.\n\nSo +1 for removing object detection in res.send.\n\nKind regards,\nJarrad Seers\n021 809 770\n\n> On 21\/07\/2014, at 8:40 am, Jonathan Ong notifications@github.com wrote:\n> \n> I just think it's unnecessary API breakage. Other than that, it doesn't really matter to me\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n","Maybe allow user to register some kind of a callback to format res.send(object) result? So if he wants magic to happen, he could register a function that serializes objects to json.\n\nI know it could be done with monkey-patching already, but it would be great to have a better way.\n","> Maybe allow user to register some kind of a callback to format res.send(object) result? So if he wants magic to happen, he could register a function that serializes objects to json.\n\nWhat would be the advantage over calling `res.json` here?\n","1. one interface for returning anything. Instead of remembering `res.json`, `res.jsonp`, `res.whatever` a developer would have to just use `res.send()` everywhere\n2. it is more easily configurable, if I want to tweak `JSON.stringify()` arguments (space or replacer), it's easier to register a callback than to read documentation trying to find how to set up each of those arguments in settings\n","In fact, I even thought about second middleware stack that's executed by `res.send()` where you can define functions to manipulate result of `res.send()` (for example, forming JSONP output or doing `JSON.stringify()`).\n","> In fact, I even thought about second middleware stack that's executed by res.send() where you can define functions to manipulate result of res.send() (for example, forming JSONP output or doing JSON.stringify()).\n\nHmm. Perhaps open a new issue for this and I can label it as \"Idea\" for discussion from everyone :) Ideally this pipeline would not be tied to `res.send`, but include `res.end` and all other ways to write out data (seems like it would be a good use-case for people wanting to do HTML-injection, URL-rewriting, etc.).\n\nI don't think that would particularly overrule this idea, since I think you idea, if implemented, should be more generalized than being specific to `res.send`. A lot of middleware, for example, do not use `res.send` since it is an express thing and they want to work with connect and vanilla Node.js servers.\n","Developer should stop using JSONP and go for CORS instead\n\nJSONP is unsafe and overly complicated to maintain on both backend and frontend. now days its very easy cuz we have this awesome framework that dose it for us :(\n\nIf we should have any shortcut to sending json cross domain it would be something with `res.cors().json(obj)` or with the help of middleware i would not encourage new user to use `res.jsonp()`. If they were using it then I would show a warning message to tell them a reason why, how to solve, and why its being deprecated.\n","Not sure how the comment relates to the original post (which does not mention JSONP at all). Let's stay on topic, please :)\n","Sorry, went to far. properly wouldn't have mention it if it weren't for @rlidwka who brought up jsonp in one of his message. no offence\n"],"labels":["ideas"]},{"title":"Make automatic HEAD -> GET configurable","body":"The automatic conversion of `HEAD` requests to `GET` requests when there is no HEAD method in the route should be configurable (i.e. turn it on or off).\n","comments":["Sounds like a router setting. :thumbsup: \n","This behavior is not very clear (using 4.12.2). Take for example, registering routes in this order:\n\n```\napp.get('\/resource\/:id', getHandler);\napp.head('\/resource\/:id', headHandler);\n```\n\nDone this way you will never _ever_ hit the `headHandler`. However, if you reverse the order:\n\n```\napp.head('\/resource\/:id', headHandler);\napp.get('\/resource\/:id', getHandler);\n```\n\nThe `headHandler` is called on HTTP `HEAD` requests, and the `getHandler` is called on `GET`. Caused me a headache today :-1: \n","@rsandor yes, this is a sad situation :( This is one of the reasons we added `.route()` to Express 4.0, though, so you won't ever hit this issue:\n\n``` js\napp.route('\/resource\/:id')\n.get(getHandler)\n.head(headHandler)\n```\n","As a bonus, using `.route()` is more efficient, so you'll have a slightly higher throughput for the equivalent non-`.route()` app.\n","Sorry to bump an old issue - Is `.route()` always preferred, or just in situations where you have a single URL with a few HTTP methods?\nIs it more efficient just in general?\n","It is always preferred and more efficient in general, due to the stack being more compact.\n","@dougwilson - Are the use of routes now enforced at an interface level in the newest versions of the library? If not, I highly suggest either making them so or simply fixing this issue. It seems like bad form to let a problem like this persist :\/\n","@rsandor , you're welcome to express your displeasure of the pace of this project to callback@strongloop.com , as this project is under StrongLoop and I am just a Collaborator.\n","@dougwilson - kudos for not answering my question and taking the critique as a personal attack. Sorry I confused you with someone who could have an impact on the project.\n","No problem!\n"],"labels":["ideas","module:router"]},{"title":"Make automatic OPTIONS responses configurable","body":"The automatic OPTIONS responses should be configurable (i.e. turn it on or off).\n","comments":[":thumbsup: \n","As of 4.12.2, the automatic OPTIONS response contains the `Allow` header. Its content is OK, but the header should be named `Access-Control-Allow-Methods` in my app. I would like to be able to configure that, as I'm not able to (easily) correctly set the headers myself.\n\nA config, or better yet, a dedicated middleware would be a most welcome improvement.\n","OPTIONS has meaning outside of CORS. Please use a CORS module like corser for that.\n","Is there anyone working on this?  I can send a PR if there's no one working on it :) @dougwilson   ","Hey @dougwilson. Is there any update on this? "],"labels":["ideas","module:router"]},{"title":"Release 5.0","body":"This is a tracking issue for release 5.0.\r\n\r\n**_5.0.0-beta.1 published on npm_**\r\n\r\nI am trying to give better visibility for upcoming changes and so am trying out making a PR for a release here, pulling from the official next release branch into 4.x. This allows for the current pending changes to be easily visible.\r\n\r\n**Please keep feature requests in their own issues**\r\n\r\nI'm also leaving this PR unlocked so people can make comments\/etc. and we'll see how it goes :) If you want to make a comment on a particular change, please make the comment in the \"Files changed\" tab so comments are not lost during a rebase (they will occur frequently has 4.x progresses).\r\n\r\nThe goal of Express 5 is to be API tweaks & the removal of all code from the Express repository, moving into components in the pillarjs project (https:\/\/github.com\/pillarjs), providing at least basic support for promise-returning handlers and complete HTTP\/2 functionality. Express 5 would become a \"view into pillarjs\" and would be an arrangement of these components.\r\n\r\nList of changes for release:\r\n- [x] Add support for Promises in all handlers #2259 (though `router@2.0.0-alpha.1`)\r\n- [ ] Add support for Promises in `app.param` (though `router@2.0.0-beta.2`)\r\n- [x] Bring back `app.router` which is just generally useful for directly calling to the router\r\n  - [ ] Make sure 3.x-style `app.use(app.router)` does not explode\r\n- [ ] ~Fix views to resolve paths async #2653~\r\n- [x] Make `query parser` option default to `'simple'` #3361\r\n- [x] Make `bodyParser.urlencoded` default to `'simple'` (though `body-parser@2.0.0-beta.1`)\r\n- [x] Make `req.host` actually return the host #2179\r\n- [x] Make `req.query` a getter instead of added by middleware #2215\r\n- [x] Make `res.render` always async callback, to hide sync view engines #2668\r\n- [ ] ~Make `res.render` use the default engine even when an extension was found #2708~\r\n- [ ] ~Make `res.sendFile` use the `\"etag\"` application setting #2294~\r\n- [ ] Make `res.status` throw on invalid argument type #4212 #2795 #2797 #3111 #3137 #3143\r\n- [ ] ~Make `express.static` use the `\"etag\"` application setting #2317~\r\n- [x] New path matching syntax #2057 #2173 #4321 (though `router@2.0.0-beta.1`)\r\n- [ ] ~Provide separate locals and options to view engine #2648~\r\n- [x] Remove Express 3.x middleware error stubs #3217\r\n- [x] Use `mime-types` instead of `mime`\r\n- [x] Use `path-is-absolute` module for absolute path detection #2620 \r\n\r\nList of deprecated things removed:\r\n- [x] Leading `:` in `name` for `app.param(name, fn)`\r\n- [x] `app.del`\r\n- [x] `app.param(fn)`\r\n- [x] `req.acceptsCharset`\r\n- [x] `req.acceptsEncoding`\r\n- [x] `req.acceptsLanguage`\r\n- [x] `res.json(obj, status)`\r\n- [x] `res.json(status, obj)` #2939\r\n- [x] `res.jsonp(obj, status)`\r\n- [x] `res.jsonp(status, obj)` #2940\r\n- [x] `req.param()`\r\n- [x] `res.redirect(url, status)` #2941\r\n- [x] `res.send(body, status)`\r\n- [x] `res.send(status)`\r\n- [x] `res.send(status, body)` #2942\r\n- [x] `res.sendfile`\r\n- [x] `res.vary()` (i.e. no arguments) #2943\r\n\r\nList of things to refactor (still provided by `express`):\r\n- [ ] ~Better `res.cookie` and general cookie reading\/setting (new `keygrip` and `cookies` modules; new `req.cookies` or such)~\r\n- [ ] ~Move prototype properties to own repo #2432~\r\n- [x] Move `Router` to it's own repo #2411\r\n\r\n**Testing this release**\r\n\r\nIf you want to try out this release, you can install it with the following command:\r\n\r\n``` bash\r\n$ npm install expressjs\/express#5.0\r\n```\r\n\r\nOwners\/collaborators: please do not merge this PR :)\r\n","comments":["here's some mostly refactor-based changes i'd like to see. AFAIK you've got this covered @dougwilson, but let me know if you need help:\n- refactor the router to a separate repository\n- refactor the view system to a separate repository. maybe [templation](https:\/\/github.com\/expressjs\/templation), maybe something else more backwards compatible\n- finish next versions of `cookies` and `keygrip` and use them in Express\n- finish refactoring `body-parser` into the `request-body` module before including it here\n- refactor the router to use [path-match](https:\/\/github.com\/expressjs\/path-match) or something else between `path-to-regexp` and the router itself\n- refactor [proxy-addr](https:\/\/github.com\/expressjs\/proxy-addr). i just emailed npm to ask for the `trust` package\n","All great stuff @jonathanong :) I added all but the `body-parser` one up there, because I really want to add that in a 4.x release, but time-dependent :D \n","How close is this to a prerelease? I just want to know if you think it's stable enough to start playing around with for future projects.\n","So you're always welcome to play around with `npm install visionmedia\/express#5.0` (and you can add `\"express\": \"visionmedia\/express#5.0\"` to your `package.json` if you really wish). If you are looking for something published to `npm`, just ask :) No one has really ask for it yet is all. Would you like an alpha or something published to npm? I can do it right after 4.10 (which is due something this week) so it'll include 4.10 stuff.\n","> If you are looking for something published to npm\n\nI'm looking for the router to be published to npm for the looong time now. :)\n","@rlidwka the docs are just about complete and I was just porting the recent changes to the router in here over yesterday :) I also really want it, haha\n",":+1:\n","Can someone link me to the docs for the new router?\n","@ilanbiala the 5.x router is the same as the 4.x router, so the main docs can be found at http:\/\/expressjs.com\/4x\/api.html#router ; the documentation talked about above is basically a rewrite of them to live with the extracted router.\n","Everyone on this thread: The first Express 5.0 alpha has been released to npm!\n\n``` sh\n$ npm install express@5.0.0-alpha.1\n```\n","Is there an approx ETA for 5.0?\n","> Is there an approx ETA for 5.0?\n\nYep; whenever Pillarjs is complete enough to make express one file. XD\n","Haha, is it getting close?\n","@Fishrock123 What's pillarjs?\n","@hacksparrow there is no real ETA just yet, mostly because I don't want to have to commit to a date :) There have been people asking on IRC\/Twitter\/here about getting something on `npm` from this branch, so the alpha 1 is that :) What do you think about making a 5x section on the website? I feel like it's probably too early, personally. Perhaps when it's beta, and definitely when it's RC, unless you think otherwise, lol.\n","@dougwilson, that's what I wanted to get a feel of. I am in agreement with \"Perhaps when it's beta, and definitely when it's RC\".\n","@ilanbiala pillarjs is a collection of framework components. It's being extracted from express: https:\/\/github.com\/pillarjs - more info is available in [this empirenode talk](http:\/\/youtu.be\/FiHI6--wB4s?list=PL31ehRjJCA6Fh_l4jd-0neUKLUDwycZK8)\n","@hacksparrow so my general feel was alpha Nov 1, beta Dec 1, RC Jan 1, release 1 week after RC unless issues brought up.\n","@dougwilson sounds good!\n","@dougwilson are we still keeping static in here?\n","Probably.\n","Is this still up to date?\n","Yep.\n","Isn't req.param() being removed?\n","@ChiperSoft see #2450\n","@Fishrock123 right. is it only being deprecated and not removed in 5.0?\n","So until I actually deprecate them and see how it blows over, I don't want to commit to removing them from 5.0. If there isn't enough time, they may just was well stay as deprecated.\n","Is 5.0 going to come with new features\/big performance fixes, or is it just more modular?\n","New features: a few, yes. (Performant custom prototype extensions are one, more info soon)\n\n\"Big performance fixes\": what? Do elaborate, express is by no means close to slow. The router will have some increased performance though.\n","@Fishrock123 not saying it's slow, but there's always up, right? :)\n","The answer is we are not aware of any performance issues, so no, there wont be any changes there. If there is something, we wouldn't really wait for a major to fix anyhow. During the 4.x series many performance issues were addressed, as an example.\n\nThere is even a slight router performance change going into 4.11.\n","@dougwilson  Hi, Doug, thanks for reply. As beginner in Node and fall in love with Express.js for more than one year,   I am really concerning about its future, will it still be supported as independent light-weight easy-to-start  core-robust-but-not-too-fancy-feature project that every new beginner can quickly start with, OR will it be put a lot of feature into and gradually merged into StrongLoop to make it like Django in Python? From the talk above, I can tell Express is going to be more robust, but I am not sure if it is going to be Fat?\n","@kuanslove As far as core Express goes (what you get with `npm install express` is not getting any fatter and only potentially slimmer.\n","Basically the general sort answer to your question, @kuanslove , is Express's future is \"more of the same, but more flexible\".\n","@dougwilson  Cool, that is great! This is the exact place which attracts me so much. Another question is about Language Trend comparison: From TJ's early post farewell to node, I start to know the Golang, I also want to hear your opinion about the comparison between these two in Web development area. Most posts about Go and Node I found talking about GO is good at speed and Concurrent, but I am not sure if those PROs is actually commonly used a lot in our daily coding life for most web projects? \n","I have no experience with Go. In my day job I write in C#, and as hobbies I write in Perl (which also works with an event loop--even libuv, the underlying loop for Node.js) and JavaScript, all of which have concurrency, so there's no insight I can really give you on Go.\n","@dougwilson Thanks Doug! Speaking of C# and even Asp.net, I wonder why there are a lot of people use it,  is that because it has a whole set of solution for web development? Like from IDE to Platform? I do not have any experience on Windows web dev, do you think it still a huge promising job market? I am thinking if I need to put some C#\/Asp.net experience in my knowledge tree. [It is my fault, I guess this should be talked offline, what is your Twitter id]\n","Is the locals\/view engine options separation being worked on? I don't see a ticket regarding that\n","@TimothyGu yes, if you're referring to the discussion from `ejs` a little bit back :) Indeed, there is no ticket, mainly because I don't have any code to really show for it, but feel free to open any issues\/PRs you like if you have suggestions for how `__express` and `res.render` can be improved, from your point of view :)!\n","@kuanslove my email in in my GitHub profile :)\n","@dougwilson said:\n\n> @TimothyGu yes, if you're referring to the discussion from `ejs` a little bit back :) Indeed, there is no ticket, mainly because I don't have any code to really show for it, but feel free to open any issues\/PRs you like if you have suggestions for how `__express` and `res.render` can be improved, from your point of view :)!\n\nOK cool. I'll try to find some time to do that. What I have in mind however is something that looks like `res.render('file', options, locals, cb)`, with `app.locals`, `app.viewOptions`, `res.locals`, and `res.viewOptions`.\n","@TimothyGu great!\n","@TimothyGu loop me in when you create the issue :)\n","Awesome. Any chance on including some ES6 features? generators, yield, promises, etc.?\n","@jancarloviray there are already a few issues at https:\/\/github.com\/strongloop\/express\/issues under discussion.\n","Would love to see #2653 in the 5.0.0 release!\n","I guess I was mistaken when I said this check list was complete :) I'm adding that PR here and making sure everything currently tagged with \"5.x\" is listed here (because, really, they mean 5.0.0).\n",":+1: \n","I'm curious... with Koa and Express being so similar, is Express being developed towards ES6-7 and minimalism like Koa, is Express the robust, for-prod one and Koa the experiment etc...\n","@mgenev I'm not sure specifically what you're asking, but Express and Koa are just different approaches at being a web server in Node.js; one would not become more like the other and they are going to continue down the same paths they are already on.\n","@dougwilson As best I can tell, the ETA for initial 5.0 release is \"July 2015\".  Can you provide a more specific date?  We'd like to release the docs at the same time, and we are working on them...  Just need a target date if possible.\n","No problem, @crandmck :) I swore I wrote this down _somewhere_, though clearly it's not in this thread, haha. So I plan to release the beta 1 this weekend (about June 29), followed by any follow ups or RCs each weekend of July until the final release July 29. The final release is not absolute stone, though, if a user brings up a big issue that we cannot resolve by then for some reason, of course :) Hope this helps!\n","Thanks @dougwilson that's very helpful.  The docs might not be quite ready by this weekend, but I will talk with @hacksparrow and see how soon we can get them ready.   \n\nMy suggestion would be that for beta releases, the 4.x docs should remain the \"default\" docs, and then once 5.0 final is released ~7\/29, we would switch to the 5.0 docs as the default replacing the 4.x docs (with 4.x API docs still available of course).  The migration guide would probably come in somewhere in there, perhaps not 'til 7\/29.\n","@crandmck that's no problem. We don't even really _need_ docs ready until release, and even this, probably can simply skip on having them all the way to an actual RC.\n","`app.param(function)` and `router.param(function)` were deprecated as of 4.11.0, but they seem to be working fine and dandy in 5.0.0-alpha.1. The behavior is the same only the deprecation message is gone.\n\nOr am I missing something?\n","Same thing for `req.param(name [, defaultValue])`.\n","Are we getting rid of everything that was deprecated in 4.x?  `res.send(status, body)` is still intact (with the deprecation message, of course).\n\n@dougwilson if it would help, please assign some of the open issues to me.\n","Hi @hacksparrow , yes, all deprecated things will be removed in 5.0. Right now, the current 5.0.0-alpha.1 is based off Express 4.10.1, and thus anything deprecated after 4.10.1 has not yet been removed from the 5.0 alpha. Express 4.x is essentially locked for new features this month so I can get a 5.0 beta out based off 4.13.\n","@dougwilson I am starting preliminary work on the API docs, is there a checklist of changes in 4.13 to make it 5.0 beta? It will help me in the documentation. I may also be able to help you close some of the open items.\n","Hi @hacksparrow , the check list at the very top should be up-to-date now.\n","5.0.0-alpha.2 of Express has just been published to npm. You can install with `npm install express@5`.\n","@dougwilson that's great!\n",":+1: \n","@dougwilson \n\n> I'm not sure specifically what you're asking, but Express and Koa are just different approaches at being a web server in Node.js; one would not become more like the other and they are going to continue down the same paths they are already on.\n\nForgive my ignorance, but what is so different? They seem close to identical to me... \n","@dougwilson apperently you can't `npm install express@5` (you can although `npm install express@5.0.0-alpha.2`)\n`npm ERR! notarget No compatible version found: express@'>=5.0.0 <6.0.0'`\nI installed the 5.0.0-alpha.2 version to test the [http2 issue](https:\/\/github.com\/molnarg\/node-http2\/issues\/100) #2432 and it seem that I still have the error\n\n```\n_stream_readable.js:505\n    dest.end();\n         ^\nTypeError: undefined is not a function\n    at Stream.onend (_stream_readable.js:505:10)\n    at Stream.g (events.js:199:16)\n    at Stream.emit (events.js:129:20)\n    at _stream_readable.js:908:16\n    at process._tickCallback (node.js:355:11)\n```\n\nbut it's appear only on windows, on linux (ubuntu) I don't have this issue from version 4.13.1\nany progress on that matter?\n","Hi @amitmtrn I am able to \"npm install express@5\" OK, but perhaps out version of npm differ on the matter :\/ As for that error, the answer is no, Express 5 alpha 2 still does not accept custom prototypes on req and res. I have not gotten to it, but PRs made against the 5.0 branch for it are welcome.\n","Otherwise, you can track if an issue has been released by waiting for the issue to be closed on GitHub.\n","Any progress?\n","The current progress is represented by the GitHub milestone and the check boxes at the top of this PR :)\n","Hi,\n\nI've been having some trouble figuring out what the status is on promises is. Could someone explain it (the status for express, not promises in general) for me? Thanks!\n","Hi @ariporad , the check box is not checked in the list at the top, thus not done. It is not yet in progress, either.\n","@dougwilson: If I'd like to help implement it, what should I do. I'm a little lost with pillarjs\/express\/etc.\n\nThanks!\n","Hi @ariporad , you would want to look at the https:\/\/github.com\/pillarjs\/router module, adding it to the handlers there, which is the router that backs Express 5.0 (https:\/\/github.com\/strongloop\/express\/blob\/5.0\/lib\/application.js#L27).\n","It would be awesome if we could have a solution for #2781 in Express 5. HTTP\/2 is the next big thing for webservers and I think it would be a great opportunity to offer support for it from the start. Now is the time, imho. Any guidance as to how we could get there would be much appreciated.\n","@dougwilson is there a community gitter or slack?\n","@gabrielcsapo Yes, it's mentioned in the README: https:\/\/github.com\/expressjs\/express#docs--community. See https:\/\/gitter.im\/expressjs\/express.\n","Any progress on beta\/RC releases for 5.0?","Can we remove the [warnings for the middleware](https:\/\/github.com\/expressjs\/express\/blob\/c8d9223e93ee0c08490e4840f3278314ccb221a5\/lib\/express.js#L70-L102) that was deprecated for `4.x`?  It seems to me that leaving the warnings for a whole major version\/multiple years should be enough.  Right?","@wesleytodd I thought the same thing the other night. I would like to remove them. Ideally people are much less confused these days, though I have no idea how to really gauge that without just removing them and then we can always add them back again in 5.x if it seems warranted. Feel free to make a PR to remove \ud83d\ude03 ","Done: #3217","Guys when is next release coming? alpha 6 ... any roadmap we can refer to?  I know it is not easy to keep things consistent and release updates quickly.  But waiting too long historically had negative impact on some of the largest javascrpt frameworks (Angular?) Specially around this time when NodeJS and EcmaScript is aggressively moving forward and developers want to utilize them.   Any update would be appreciated.  I didn't find any info on your website.  I am mainly waiting for async middleware functions.\r\n\r\nThanks.  and please don't ask me to use Koa.","@alamin3000 I've been waiting for Node.js to finally land http\/2 in code to know what deep changes will need to be done in Express.js. There is (finally) a PR in Node.jc core to land http\/2 behind a flag, and when the reviews go through on that, there will finally be an implementation to start building against here on this end.\r\n\r\nThe general roadmap is right at the top of this PR, in checkbox form even :)","Thanks.  So we are still waiting on NodeJS.  I see.. I thought with NodeJS version 8 everything was ready.  Really tough to start new project with Express 4, specially when we know 5 is on horizon and specially Promise based middleware is coming.  (I will need to write tons of middleware for the project).\r\n\r\nBTW, as for roadmap, I meant timeline of releases... not feature list.\r\n\r\nThanks.","Gotcha. Since Node.js does not provide a timeline of features, we would have nothibg to base ours on.","> thanks to IBM\r\n\r\nWat?\r\n\r\n@dougwilson is doing amazing work I saw commits recently.","I think the issue isn't about who is doing or not doing good job on this project.  I am sure everyone involved in this project is doing their best since it is backed by big players in the industry.  And it is indeed very important project in this community.  \r\n\r\nHowever the issue is as a normal developer it is very frustrating when we can't use latest features and don't know how long to wait.  I have complained about this before that we don't even know the timeline (dates) for releases.  Even nodejs has timeline roadmap.\r\n\r\nHonestly technologies are moving too fast, specially in ES and Node realm.  So progress in the ExpressJS is in that prospective is disappointing.  Again, from our (developers) prospective.  NOT from the team who is involved in it assuming they are doing their best.\r\n\r\nI'm not looking for alternative to Express or even how to start working and Express 4 and then migrate to version 5.... I'm  strictly talking about\/referring to Express 5.","Please stop unnecessary discussion in this PR. It would be nice to be notified of *actual* updates to the progress.","Please, I'm sure there is a better forum to have this conversation in. If you want to know what is currently happening with Express 5 at this very moment, the `router` module, which is the basis of Express 5 routing engine, is currently building up the 2.0 release, which is what Express 5.0 will be based on (PR https:\/\/github.com\/pillarjs\/router\/pull\/60). This encountered a bug in `path-to-regexp`, which got fixed and working through that upgrade for the 2.0 router (PR https:\/\/github.com\/pillarjs\/router\/pull\/42). I pinged about the state of the `path-to-regexp` PR just a couple hours ago.","sorry for disturbs, all deleted","Is it even remotely possible to give update on dates when express 5 will be RC or release?. All I get is feature updates. I thought express is under node foundation incubator program and would have better management outside of just doing coding. Call me jerk or what, just an approximate time when we can expect to get released. Please.","I'm not sure anyone is getting paid to work on this, and so it just falls under whenever there is time to do the next task. If there is a better methodology to do this or you have some tips on how to do release planning and such, please let us know! For example, how do we come up with a date to release?","If this is for sure, that this project is not under some kind of organization where compensation is available for developers and it is as you say whenever there is time, then I drop all my complain.  Honestly if is just another open source side project by some smart developers, then I don't expect timeline or anything.   I will delete my comments soon.","@dougwilson it really sucks you're not getting paid to work on express. I'd love to help out with managing the project and figuring out how how to monetize if you're interested. So many companies, mine included, depend on express and want to see the project succeed.","I wouldn't assume that just because Doug doesn't have job working on express full-time that it's what he *wants* :)\r\n\r\nDoug is a very accomplished developer who has a lot of options.\r\n\r\nJust because other people want Doug to work on the thing *they* need doesn't mean that it's the best thing for Doug to be doing with his life. Open source is people, and people get to make the decisions that are going to make them the most happy and fulfilled, not what is best for you :)\r\n\r\nIf you want the release to get out quicker, contributions are welcome :smiley: ","Just putting a possible option out there, no pressure, but I'd appreciate if Doug spoke for what Doug wants rather than a third party. No way Express should be a full-time job, lib is not nearly complex enough to justify that, but the lib is stuck in 2014 and I'm happy to help :)","*NOTE: @dougwilson I think once this conversation has run it's course it would be worth just deleting all of these comments, including mine.*\r\n\r\nFor anyone wondering, there is a TON of active work happening in the express community.  If you are interested you can follow some of the more active repos (links below).  Also, feel free to check out the [discussions repo](https:\/\/github.com\/expressjs\/discussions\/issues) for past meetings of the CTC (which admittedly has not happened in a while).  Supporting such a large community is a big job, and luckily @dougwilson is nice enough to commit a ton of time to it.  But that being said, it is an open community that is welcome to new people.  So if you have suggestions or PR's you want to open, then BRING IT :)\r\n\r\nWe all need to make sure we focus on more than just the major version number, and the \"shiny new things\".  The strength of express it not in it's speed of feature development, but in it's reliability for its users.  So lets make sure to focus on if it serves it users, not how fast the major versions increment.\r\n\r\nRepos to follow:\r\nhttps:\/\/github.com\/expressjs\/express\r\nhttps:\/\/github.com\/pillarjs\/router\r\nhttps:\/\/github.com\/pillarjs\/path-to-regexp\r\nhttps:\/\/github.com\/expressjs\/session","Express.js 5.0.0-alpha.7 has been published which includes the initial support for Promises in the router. Middleware and handlers can now return promises and if the promise is rejected, `next(err)` will be called with `err` being the value of the rejection. The implementation is seeking feedback from real usage, and please open any feedback as a new issue, either in this issue tracker or in the `router` issue tracker.\r\n\r\nI am currently working on writing up Express.js-specific documentation on this feature, but in the meantime, the documentation can be found in the `router` repository:\r\n\r\nhttps:\/\/github.com\/pillarjs\/router\/tree\/v2.0.0-alpha.1#middleware\r\n\r\n> The function can optionally return a Promise object. If a Promise object is returned from the function, the router will attach an onRejected callback using .then. If the promise is rejected, next will be called with the rejected value, or an error if the value is falsy.","Great to see this progress!  Since it's still alpha, I don't think we need to create a bunch of official docs, but I would think an alert and link on the home page would be appropriate.  LMK if I can help.","Is there any vague guestimate of a release date for the stable version? ","Your comment is irrelevant, I'm sorry. If you want a stable Express.js just use the current version. If you want to use preview features, just use the alpha. The only difference between them is API stability between versions, not how usable it is for production. The implementation is seeking feedback from real usage, and please open any feedback as a new issue, either in this issue tracker or in the router issue tracker.","Great progress and I'm looking forward to start using Express v5. Is there any plan to have TypeScript types part of the package?\r\n\r\nI apologise if this is not the right place to have this discussion.","@72lions You can see our conversation on this topic here: https:\/\/github.com\/expressjs\/express\/issues\/2818","Hi, many months have passed since the last commit or comment. Is it still worth to expect a new express version or should we put the effort into other frameworks? I saw your comment https:\/\/github.com\/expressjs\/express\/pull\/2237#issuecomment-435078982 and I fully agree with you but it's also really hard for me to be on track with the status quo. How can we move forward? Thanks!","> Is it still worth to expect a new express version\r\n\r\nYes\r\n\r\n> or should we put the effort into other frameworks?\r\n\r\nThat is something you would have to decide; I don't know enough about your work\/projects to make such a decision for you.\r\n\r\n> I saw your comment #2237 (comment) and I fully agree with you but it's also really hard for me to be on track with the status quo. How can we move forward?\r\n\r\nPlease open a new issue with your feedback as requested in that comment. The PR has gotten very long for conversations.","It was last January when we said we would shoot for a release early summer for this.  Now that it is January again, I would like to take the lead in pushing this release out the door by the end of the month.  I know that sounds like \"well why could we do it now when we couldn't all last year\".  And the answer really is that no one is paid to work on this project and we all are very busy.  So call it a new years resolution or what, but I want us to make this happen so we can unblock so much development on Express 6.0.  So what will it take to make this happen:\r\n\r\n1. Agree on the Jan 31, 2020 goal\r\n2. Create an updated list of todo items\r\n3. Knock those out\r\n4. Prepare a blog post announcing it and describing the update process\r\n5. Publish `5.0`!\r\n6. Start work on `6.0`\r\n\r\nI really think that a few solid days work is all we are away from having this out the door, and I will be taking time this month to make it happen.  So, for step 2, here is what I think the real todo list is:\r\n\r\n1. #3621 Just a simple PR to open then merge\r\n2. #2432 I started this in https:\/\/github.com\/expressjs\/discussions\/issues\/82, and it is pretty simple to finish\r\n3. Status `undefined`: #2795 #2797 #3111 #3137 #3143\r\n4. https:\/\/github.com\/pillarjs\/router\/pull\/42 Merge this with its current state. The `path-to-regexp@6` can go with `express@6`\r\n5. Remove the `alpha` tag on the 5.0 docs\r\n\r\nAm I missing anything?  If that is it then I will start on these and the list at the top can just be updated to be more concise.\r\n\r\nAs for the announcement, we can work with the OpenJS foundation blog I think, they might even be able to help us write it.  If not I am happy to also knock that out once the rest is done."],"labels":["5.x","release","pr","top priority"]},{"title":"refactor view engine","body":"it shoudl just be in its own library. i quickly hacked together https:\/\/github.com\/expressjs\/templation. some opinions would be nice.\n\na really good view engine is https:\/\/github.com\/ericf\/express3-handlebars, but the one express includes should be able to use most templating languages\n","comments":["-1. Don't see a major win by pulling out out completely. We should remove the \"app.render\" and clean up some code but I don't see removing it as gaining much. It can still be a module, but we should include it.\n","Oh yeah separate module but still included\n",":+1: \nI saw that templation supports `then-jade` with kind of streaming support. Does this mean we could get real streaming views in express 5.x (of course we would also need a template engine which supports it correctly) ? :+1: for streaming views!\n","I'd love to see streaming views. Of course, that's pretty much `templateEngine(whatever).pipe(res)`...\n","If you pull out view engine, how express would be any different from connect? :)\n","> If you pull out view engine, how express would be any different from connect? :)\n\nIt means like the view engine would be a module, and `express` would `require()` that module and still use it--i.e. to the user, nothing would change, there'd still be views, etc. :)\n","> It means like the view engine would be a module, and express would require() that module and still use it--i.e. to the user, nothing would change\n\nHmm... let me think... can I then include this view engine to my connect application, and get something like express without actually using express? :)\n\nI don't quite remember why connect had gotten rid of, but if you modularize everything, I feel a lot of feature overlap there.\n","> Hmm... let me think... can I then include this view engine to my connect application, and get something like express without actually using express? :)\n\nYes.\n\n> I don't quite remember why connect had gotten rid of, but if you modularize everything, I feel a lot of feature overlap there.\n\nWell, I'm not 100% of the reasoning, but I eventually want to reconsider it for 5.x. We are also going to do the same thing for the router, so it would reason that `express` would be connect + views + router + other stuff. connect as it is is basically just `.use()`, which is the core of express as well. I have slowly been extracting the commonalities anyway :)\n","There was already a lot of overlap and express was pretty highly coupled to\nconnect. We removed connect because the router we wanted to ship got more\ncomplex than connect's basic .use middleware handling.\nOn Jul 10, 2014 11:24 AM, \"Douglas Christopher Wilson\" <\nnotifications@github.com> wrote:\n\n> Hmm... let me think... can I then include this view engine to my connect\n> application, and get something like express without actually using express?\n> :)\n> \n> Yes.\n> \n> I don't quite remember why connect had gotten rid of, but if you\n> modularize everything, I feel a lot of feature overlap there.\n> \n> Well, I'm not 100% of the reasoning, but I eventually want to reconsider\n> it for 5.x. We are also going to do the same thing for the router, so it\n> would reason that express would be connect + views + router + other\n> stuff. connect as it is is basically just .use(), which is the core of\n> express as well. I have slowly been extracting the commonalities anyway :)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/visionmedia\/express\/issues\/2217#issuecomment-48619832\n> .\n","> We removed connect because the router we wanted to ship got more complex than connect's basic .use middleware handling.\n\nYep, that's what I figured--, though in it's current state that no longer applies. I'll push up a branch with connect 3 at the express core that we can mull over.\n","I kind of made a streaming template engine a while ago called \"blue\"\n\n<\/unrelated >\nLe 10 juil. 2014 17:31, \"Douglas Christopher Wilson\" <\nnotifications@github.com> a \u00e9crit :\n\n> We removed connect because the router we wanted to ship got more complex\n> than connect's basic .use middleware handling.\n> \n> Yep, that's what I figured--, though in it's current state that no longer\n> applies. I'll push up a branch with connect 3 at the express core that we\n> can mull over.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/visionmedia\/express\/issues\/2217#issuecomment-48620816\n> .\n","what's your views on templation? if it's good enough for 5.x i'll work on it some more. some help with more templating engines as well as collabs would be great \n","I have not taken a look at it just yet.\n","Any progress on this? Streaming views would be pretty nice.\n","This may belong in another feature ticket, but I would prefer to couple view engines with view directories together in order to accommodate handling multiple view engines and multiple view directories within a single express app.  For example ...\n\n``` javascript\n\/\/ hypothetical initialization\napp.set('view engines', [\n    { 'engine': 'jade', 'views': [ 'views\/jade1', 'views\/jade2' ] },\n    { 'engine': 'handlebars', 'views': [ 'views\/handlebards' ] }\n]);\n```\n"],"labels":["future"]},{"title":"remove .get() and .set() functions for settings","body":"and just do `app.viewEngine=` and stuff instead\n","comments":["Why?\n","`app.get` serves a double purpose of adding routes and getting settings. Maybe we can go the cleaner route of\n\n``` js\n\/\/ to set\napp.settings('foo bar', 'value for foo bar');\n\n\/\/ to get\napp.settings('foo bar');\n```\n\nOtherwise, I too want to know the reason for removing. App level settings is a nice place to configure some things.\n","I don't like the double purposijg of `app.get()`. `settings()` will work, but at that point we should just make settings an object and let people overwrite it with their own config system \n\nThe main thing I want to do is stop people from using express' configuration system for everything\n","> The main thing I want to do is stop people from using express' configuration system for everything\n\nWhy?\n","Why do you want to do that?\n","because express is an app framework, not a configuration framework. the number of options should be minimal and should only be used for express-specific options. otherwise, you should set the options yourself using another module or file. \n\ni've seen issues on stackoverflow where people advocate using `app.get()` and `app.set()` for non-express related options when they could more easily just create a `options.js` file. this is more an issue for beginners since more advanced already know they need better configuration handling.\n","Agreed with Jon and Roman.\n\nMy suggestion would be to use a single interface \/ property to set the\nconfigurations (e.g.: app.settings or app.settings()).\n\nOn Jul 7, 2014 9:00 AM, \"Jonathan Ong\" notifications@github.com wrote:\n\n> because express is an app framework, not a configuration framework. the\n> number of options should be minimal and should only be used for\n> express-specific options. otherwise, you should set the options yourself\n> using another module or file.\n> \n> i've seen issues on stackoverflow where people advocate using app.get()\n> and app.set() for non-express related options when they could more easily\n> just create a options.js file. this is more an issue for beginners since\n> more advanced already know they need better configuration handling.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https:\/\/github.com\/visionmedia\/express\/issues\/2216#issuecomment-48138196\n> .\n","It is true that when I first started to use Express, this function kinda threw me off.\nMaybe we could just namespace it; `app.settings.set({string}, {*})` `app.settings.get({string})` and event let `app.settings({string},\u00a0[{string}])`as a shortcut.\nThinking of something like this:\n\n```\napp.settings = function () {\n    if (arguments.length === 1) return app.settings.set.apply(app.settings, arguments);\n    else if (arguments.length === 2) return app.settings.get.apply(app.settings, arguments);\n}\n\napp.settings.set = function (name, value) { \/** ... **\/ }\n\napp.settings.get = function (name) { \/** ... **\/ }\n```\n","Hey all, I created a pull request to solve this issue. It passes all the tests. Let me know if you have questions :) https:\/\/github.com\/strongloop\/express\/pull\/2267\n","Everything is probably going to be configured via options objects 5.x fwiw\n","@dougwilson should we already deprecate in 4.x?\n","> should we already deprecate in 4.x?\n\nNo, because we cannot deprecate something without an alternative method :) There are not alternatives for tuning some of the Express internals besides `app.set(name, val)` right now. But even then, it would be super annoying :)\n"],"labels":["ideas","deprecate","5.x"]},{"title":"Params registered on app available in routers used by app","body":"I discovered today that it seems params registered on `app` are not respected in routes registered via a router (`express.Router()`).  Perhaps I'm just missing something though!\n\nWhile sectioning an application's routes via routers is super handy, having to re-register shared params on each of them is not.\n\nA use case to consider: an application that has a page which renders user details in which the view needs the user data, and in addition the app exposes an API to get the raw JSON response for use by a client-side app, mobile app, or third party.\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\n\/\/ Shared Params\n\napp.param('user', function (req, res, next, id) {\n  req.user = { id: id, name: 'Fred' };\n  next();\n});\n\n\/\/ Website\n\napp.get('\/users\/:user', function (req, res) {\n  res.render('user', req.user);\n});\n\n\/\/ Application API (JSON Responses)\n\nvar APIRouter = express.Router();\n\nrouter.get('\/users\/:user', function (req, res) {\n  res.json(req.user); \/\/ req.user is undefined!\n});\n\napp.use('\/api', APIRouter);\n\n\/\/ App Start\n\napp.listen(8000);\n```\n\nSeems that shared params across application \"sections\" when using routers would be a very common scenario.\n\n---\n\nMaybe this is going too far, but it'd make sense that any param registered on a parent router applied to its children, but possibly not visa-versa:\n\n``` javascript\nvar parent = express.Router();\nvar child = express.Router();\n\nparent.param('foo', function (req, res, next) {\n    req.foo = { ... };\n    next();\n});\n\nchild.param('bar', function (req, res, next) {\n    req.bar = { ... };\n    next();\n});\n\nparent.get('\/:foo\/:bar', function (req, res) {\n    res.json({\n        foo: req.foo, \/\/ OK!\n        bar: req.bar \/\/ undefined\n    });\n});\n\nchild.get('\/:foo\/:bar', function (req, res) {\n    res.json({\n        foo: req.foo, \/\/ OK!\n        bar: req.bar \/\/ OK!\n    });\n});\n\nparent.use(child);\n```\n\nThoughts\/advice appreciated!\n","comments":["This is as-intended. Please see #2138 \n","Perhaps we can add an option to the router to inherit params (opt-in).\n","That'd satisfy me, as well as the scenario referenced in #2138.  :+1: \n",":+1:\n",":+1:\n",":+1:\n","Probably `express.Router({ params: 'inherit' })`\n","So the following would now work?\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\napp.param('user', function (req, res, next, id) {\n  req.user = { id: id, name: 'Fred' };\n  next();\n});\n\napp.use('\/users\/:user', express.Router({ params: 'inherit' })\n    .get(function (req, res) {\n        console.log(req.params.user); \/\/ 10\n        console.log(req.user); \/\/ { id: 10, name: 'Fred' }\n    }));\n```\n","@adamterlson that's the idea.\n","@dougwilson You're my hero.\n","+100\n","FYI, this is going to change a bit. It's basically impossible to look \"up\" the stack, because of the extreme flexibility here (and the fact that you can have a single router mounted in multiple places). Instead, the `params` option can simply take an object of defined params, which you can pass in. Something like `new Router({ params: app.params })`, perhaps. This is still in flux, because it does not have an easy solution with the current structure.\n\nJust wanted to give an update here.\n",":+1: for this! Hopefully this gets implemented ASAP.\n","@dougwilson Regarding registered param middleware, I am mostly confused I think by your side note about the difficulty of multiple mountings of a single router--can you explain that a little bit more?  Does that impact param middleware working (#2 below) or the presence of req.params from the \"parent\" route (#1)?\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\napp.param('user', function (req, res, next, id) {\n  req.user = { id: id, name: 'Fred' };\n  next();\n});\n\napp.use('\/foo\/:user', express.Router({ params: 'inherit' })\n    .get(function (req, res) {\n        console.log(req.params.user); \/\/ #1\n        console.log(req.user); \/\/ #2\n    }));\n```\n\nIf I had to choose, getting child params working is much more important than sharing param middleware--the latter can be worked around while it's impossible to get around the former.  The idea of passing in the params from one router to the other would be pretty handy for getting the param middleware on the child, but does not address accessing req.params from the parent route, correct?\n\nMaybe these need to be tracked by separate issues?\n","> Maybe these need to be tracked by separate issues?\n\n@adamterlson I'm not sure what you're talking about, sorry. If you like, you can send an email to my email in my GitHub profile and we can have a voice conversation so I can figure out what you are talking about.\n\n>  Does that impact param middleware working (# 2 below) or the presence of req.params from the \"parent\" route (# 1)?\n\nnum 1 already works and is not changing. # 2 is what this is about, but your example does populate # 2, because it doesn't use child params, so I'm still confused about what you are talking about, since your example currently works in the existing express (and thus would not be changing).\n\nThe router does not know what it's parent is, so there is no easy way to get the params from the \"parent\". Think of this case:\n\n``` js\nvar app = express()\nvar app2 = express()\nvar router = express.Router()\n\napp.param('user', function () { \/* get user from redis *\/ })\napp2.param('user', function () { \/* get user from mysql *\/ })\n\napp.use('\/something', router)\napp2.use('\/api', router)\n```\n\nRouter has, in effect, 2 parents with different params, etc. The solution to how router determines what \"user\" param function to use is not easy, since it cannot be determined at construction time and there is no current mechanism to bring this data to the router, especially such that it works with multiple levels of routers.\n","Actually, I think I may see my disconnect. I believe # 2 works in your example, but it is # 1 that does not, is that correct? # 1 should definitely be made to work for your example where the param is listed in the path on the app; that is an easy fix, actually.\n","Ah, I'm definitely to blame as reused my previous example.  Here's a more accurate one that I think is more illustrative as it uses two params, one at the \"higher\" level and one in the use'd router.\n\n``` javascript\nvar express = require('express');\nvar app = express();\n\napp.param('foo', function (req, res, next, id) {\n  req.foo = 'Foo';\n  next();\n});\n\napp.param('bar', function (req, res, next, id) {\n  req.bar = 'Bar';\n  next();\n});\n\napp.use('\/:foo', express.Router()\n    .get('\/:bar', function (req, res) {\n        console.log(req.params.foo); \/\/ #1 - Undefined -- Cannot be worked around in any way I'm aware of\n        console.log(req.params.bar); \/\/ #2 - Works\n        console.log(req.foo); \/\/ #3 - Works\n        console.log(req.bar); \/\/ #4 - Undefined -- Can be worked around by re-registering all params on router\n    }));\n```\n\nI would love for # 1 - 4 to all work (via some opt-in config option or whatever), and # 1 I consider to be the most important.\n\nYour proposal would make # 4 work, but would not address # 1.\n","Right, you nailed it there. So this ticket (and it's complicated-ness) is about # 4. There is no easy way to solve that, which is why it still has not been done.\n\nAs an aside, # 1 I didn't even realize was like that and does need to be fixed, but it's an easy fix.\n","This is getting a bit hairy isn't it.  So many params and routes and routers and everything!  Thank you for your time.  Your fix would totally be great for # 4.\n\nWould you like me to create a separate issue for # 1?\n","I totally thought this was about #1, but anyways, it is good to hear that there's an easy fix\n","> Would you like me to create a separate issue for # 1?\n\nDone here: https:\/\/github.com\/visionmedia\/express\/issues\/2203\n","Actually I already had created one that mentioned this too: #2153  :)\n","Yea, this whole thing seems to be a big disconnect between your thoughts is all :) Merging params with an option seems desirable to me, even across routers if people opt into it in their router.\n",":+1: \n","I'm currently having to do:\n\n``` js\nvar routers = [\n    rootRouter,\n    userRouter,\n    feedRouter,\n    websiteRouter,\n    sessionRouter\n];\n\/\/ https:\/\/github.com\/strongloop\/express\/issues\/2151\nrouters.forEach(function (router) {\n    router.param('feedUrl', function (req, res, next) {\n        \u2026\n```\n\nQuite frustrating! I like the idea of allowing params to inherit.\n","i have an issue when i have 2 level of nesting Routers. the URL param processing is in the first Router level and when i give this Router the second router as code here:\n\nrouter.use(require(\".\/Router1Test\"));\n\nit ignore first level Router and just do the child Router.\nmeaning, when i have multi level Routers the child get priority on the parent 'router.param' calls and just ignore them.\n","Anyone reaching this page after 2014, all you need to do is express.Router({mergeParams: true});\n","I love all of you...  express.Router({mergeParams: true}) did the trick!\n","How does one install Express 4.5? I need this `mergeParams` feature :(\n","Yeah, i need it too.... im using multiple api point where i want to reuse all params like \":contentId\", \":userID\", \":albumId\" or what eva, but also have automatic routing adding on top of app.... really need this :(\n","In my case even only using router itself is not even working:\r\n\r\n`\r\n\r\n    router.param('id', function (req, res, next, id) {\r\n        Lesson.getLessonById(id, function (err, lesson) {\r\n            if (err) { throw err; }\r\n            req.lesson = lesson;\r\n        });\r\n        console.log(req.lesson); \/\/undefined\r\n        next();\r\n    });\r\n\r\n    router.get('\/dashboard\/:id', function(req, res) {\r\n            var lesson = req.lesson; \/\/lesson undefined\r\n            res.render('lessons\/dashboard', { lesson: lesson });\r\n    });`","@iyunusov You are calling `next()` in the wrong place. It should be called after your `req.lesson = lesson;` line (INSIDE the async callback, not outside).\r\n","@iyunusov:\r\n\r\n```js\r\nrouter.param('id', function (req, res, next, id) {\r\n    Lesson.getLessonById(id, function (err, lesson) {\r\n        if (err) { throw err; }\r\n        req.lesson = lesson;\r\n        console.log(req.lesson);\r\n        next();\r\n    });\r\n});\r\n\r\nrouter.get('\/dashboard\/:id', function(req, res) {\r\n        var lesson = req.lesson;\r\n        res.render('lessons\/dashboard', { lesson: lesson });\r\n});\r\n```","@JamesMGreene Although it took me some time to realize it by myself, thanks for your response and noticing my exact mistake."],"labels":["enhancement","4.x"]},{"title":"Please add app.route('foo').use()","body":"For Express 4.x, documentation says \"Using app.route() is a recommended approach to avoiding duplicate route naming and thus typo errors.\" However, since all() and use() are different, it would be nice to be able to call use() on route objects as well, to avoid duplicate route naming.\n","comments":["Suggested tags: 4x, Feature Request, Routes.\n","We decided against this because .use carries a specific meaning with what it does to req.path\n","Doesn't route do the same? That is, strip the path segment from the url? Or is there some more I'm not seeing?\n\nIn any case, does this means that your recommended usage is:\n\n``` javascript\napp.use('\/app', middleware);\napp.route('\/app')\n  .get(function (req, res) { ... });\n```\n\nor\n\n``` javascript\napp.route('\/app')\n  .all(middleware)\n  .get(function (req, res) { ... });\n```\n\nDoes the latter make a difference in OPTIONS behavior or something else?\n","no, `app.route()` doesn't strip the path segment from the url. only `.use()` does. up to @defunctzombie if he wants to support this though. it could make the internal code simpler if all middleware used `.route()` internally, but i'm not sure i see a use-case for this.\n","I need to check on the OPTIONS behavior but I would lean towards making sure `.all` doesn't affect OPTIONS for `.route` or `app.all()` but that might break some other assumptions people have made (or backwards compat) so it could be a no-go.\n\nThe second approach is what I would recommend but it could depend on your reliance on `req.path` inside the middleware.\n","Well, at the very least, when enabling all debugging, using `.all` will add **24** separate handlers. That doesn't seem reasonable for simply using a middleware.\n\nThe way I see it is simply that there are three types of handlers on the incoming requests:\n- Handlers that simply skip requests not matching path prefix\n- Handlers that skip requests not matching path prefix **and** strip prefix from requests matching path prefix\n- Handlers that match a certain METHOD and resolve path containing wildcards, params, etc.\n\nThese three types should be usable in all situations.\n","Yeah, sorry, `route()` does not strip the path, I confused it with `Router` - I thought those two were the same thing, with `route('\/path')` just calling `app.use('\/path', new Router())` and returning the generated instance.\n","I think we should change `.all` to simply add middleware and not affect options responses. Yes, it will be slightly different than app.all, but whatever.\n","> I think we should change .all to simply add middleware and not affect options responses. Yes, it will be slightly different than app.all, but whatever.\n\n+1\n","I'm a fan of the following syntax, since i keep my apps very modularized:\n\n(note: often times a sub app will handle most of it's own routing, so this much indentation wouldn't be necessary irl)\n\n```\napp\n\n  .route('\/library')\n    .use(middleware.auth.hasLibraryCard)\n      .route('\/books')\n        .get(controllers.books.index)\n\n        .get('\/:book_id',\n          controllers.books.show)\n\n        .route('\/overdue')\n          .get(controllers.overdueBooks.index)\n          .post(controllers.overdueBooks.create)\n          .end() \/\/ this would be nice to help in chaining\n\n        .post(controllers.books.create)\n        .end() \n\n      .route('\/shelves')\n        .route('\/:shelf_id')\n          .use(middleware.loadShelf) \/\/ to req.locals or something\n          .get(controllers.shelves.show)\n          .post(controllers.shelves.update)\n          .end()\n        .end()\n      .end()\n    .end()\n\n  .route('fire_station')\n    \/\/ etc....\n```\n\ncheers!\n","easier to make a module that does that for you, then see if people are interested in it. adding it to express means additional bloat.\n\nplus, i hate that `.end()` stuff. and the ridiculous amount of nesting.\n","> plus, i hate that .end() stuff. and the ridiculous amount of nesting.\n\n:+1:\n","> I think we should change .all to simply add middleware and not affect options responses. Yes, it will be slightly different than app.all, but whatever.\n\nFYI `route.all` never did affect the options behavior, so there is nothing to change there. `route.use` is still useful in situations where you want to add a middleware that is expecting the path to be stripped (like `static` and such).\n","Sounds like a 5.x feature maybe. Along with possibly ripping out the routing system into a module finally.\n","Adding `route.use` should be trivial for 4.x, right? I was thinking of adding it for the 4.5 release.\n","@nakedible after re-reading your original posts, it is clear you are confusing `app.all` behavior with `route.all` behavior: `app.all` adds 24 handlers and affects OPTIONS, but `route.all` does not and only adds a single handler.\n","Anyway, a `route.use()` that just operates like `route.all()` but strips the path does not seem useful, because of course the path will always be `\/`. BUT I think `route.use()` would be useful if it would make the middleware only invoked if there was a handler for the incoming method. This would make it very useful for adding middleware to your route, but if your route only did `GET` and `POST`, your middleware wouldn't even be invoked when a `TRACE` came in on your route for no reason.\n\nThoughts? @defunctzombie @jonathanong \n","I think having a route.use() that strips the path could be interesting. It would allow you to built up trees of routes minimizing repeating the same route string. I support either adding it and maintaining the strip path semantics or not adding it.\n","@defunctzombie you're thinking a signature of `route.use(path, fn)`, right (where `path` defaults to `'\/'`)?\n","`route.use(fn)` because the path is built in already\n","Well, I don't see how that would really build trees, then? Do you have an example? My only example I can think of is\n\n``` js\nvar userRouter = express.Router()\nuserRouter.route('\/:id')\n.get(getUser)\n.put(updateUser)\napp.route('\/users')\n.get(getUsers)\n.post(createUser)\n.use(userRouter)\n```\n\nBut really all those handle under the route could just be under `'\/'` in the router...?\n","Actually, the above would never work, because `.route(path)` matches up the full path, so `\/user\/1` would never come through there.\n","Yea, actually I think you are right in that it should support `(path, fn)` if it supports anything at all.\n","Well, I just realized that `route(path)` does a full match on the path, so like `path` to use would essentially only match downwards, like `app.route('\/users\/:id').use('\/users', fn)` would work, but `app.route('\/users').use('\/users\/:id', fn)` would not work or something.\n","Right, the `.use` would be path after stripping away the route's path. Then it could strip away any additional path you pass as well.\n","> Right, the .use would be path after stripping away the route's path.\n\nWhat I'm saying is that the route's path is actually a match-to-the-end match, so `app.route('\/users')` would not match `\/users\/1` and such, which seems like a `.use()` under that would just never match anything to me...\n","It seems that having this feature is useless then?\n","> It seems that having this feature is useless then?\n\nRight. So the only use I could come up with was the one above, which would let a user do this:\n\n``` js\napp.route('\/users')\n.use(bodyParser.json())\n.get(getUsers)\n.post(createUser)\n```\n\nand the `bodyParser.json` middleware would not even be invoked for a `PUT \/users`. It's super easy to implement, but I'm not sure how much of a value it would be. It would basically be the short-hand of doing\n\n``` js\napp.route('\/users')\n.get(bodyParser.json(), getUsers)\n.post(bodyParser.json(), createUser)\n```\n","-1 for \".use()\" in routing. Its a terminology that confuses people, \"use\" for middleware and such and nothing else\n","Why `app.route()` doesn't have `use()` when `Router()` instance has? What's the difference and what is the proper manner to mount subapp\/router over `app.route()` instance? Looks like `all` has another meaning so I need `use` to mount whole subapp.\n","looks like a nice discussion around router abstraction, but with no forward path, or convergence. Is closing the right thing to do here?"],"labels":["4.x","module:router"]}]