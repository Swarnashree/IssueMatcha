[{"title":"Realm.Init configuration take too long delay when move intent from 1st page into next page ","body":"### How frequently does the bug occur?\n\nAlways\n\n### Description\n\nI was try to move into next page which in second page of activity. I was used Realm.Init to initialize of realm. But, it takes too long delay when move from 1st page into 2nd page. I'm also try Realm Init call from 1st Activity or Realm Init run inside of runOnUIThread(). but, it doesn't work well.\n\n### Stacktrace & log output\n\n```shell\n2024-03-21 14:50:29.656  4240-4240  data_check  xxx.xxxx.xxx.xxx         D  first access realm init\r\n2024-03-21 14:50:30.012  4240-4240  data_check  xxx.xxxx.xxx.xxx         D  add category of product\r\n2024-03-21 14:50:30.559  4240-4240  data_check  xxx.xxxx.xxx.xxx         D  add product\n```\n\n\n### Can you reproduce the bug?\n\nAlways\n\n### Reproduction Steps\n\n1. Access First Page. \r\n2. Access Second Page After Page was positioned offline mode\n\n### Version\n\n10.15.1\n\n### What Atlas App Services are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo\n\n### Platform OS and version(s)\n\nOne UI v.5.1, Android 13\n\n### Build environment\n\nAndroid Studio version:  2023.2.1 Patch 1\r\nAndroid Build Tools version: 33.0.0\r\nGradle version: 8.0.0\r\n","comments":["\u27a4 PM Bot commented:\n\nJira ticket: RJAVA-1255"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:Off"]},{"title":"Realm Transformer Output Missing During Android Instrumented Test","body":"### How frequently does the bug occur?\r\n\r\nAlways\r\n\r\n### Description\r\n\r\nThis is related to https:\/\/github.com\/realm\/realm-java\/issues\/2936 and https:\/\/github.com\/realm\/realm-java\/pull\/3030\r\n\r\nAfter upgrading to Gradle 7, our build is now issuing a warning about a deprecated feature (the AGP Transformer API). It seems that newer versions have been released to address this however our app is not currently able to support realm 10-x versions. \r\n\r\nWhen running Android instrumented tests a ClassCastException is being thrown at runtime. Several attempts were made to resolve this, like adding kotlin-kapt before realm-android Gradle plugin. The exception only occurs during instrumentation tests. \r\n\r\nThe output of the realm transformer is being generated to the app\/build\/intermediates\/transforms. Yet the final APK being ran does not contain the generated source.\r\n\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\njava.lang.ClassCastException: my.package.MyRealmObject cannot be cast to io.realm.my_package_MyRealmObjectProxyInterface\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nAlways\r\n\r\n### Reproduction Steps\r\nin app\/build.gradle\r\n    androidTestImplementation project(\":app\")\r\n\r\n### Version\r\n\r\n6.1.0 up to 10.11.1\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nYes\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 10-13\r\n\r\n### Build environment\r\n\r\n- Android Studio Electric Eel\r\n- Gradle 7.5.1 and AGP 7.4.0\r\n- JDK 11\r\n- Kotlin 1.7.21 ","comments":["\u27a4 PM Bot commented:\n\nJira ticket: RJAVA-1254"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:On"]},{"title":"io.realm.exceptions.RealmFileException","body":"### How frequently does the bug occur?\n\nAlways\n\n### Description\n\nMy app seems to be crashing on a Google pixel 8 (Android 14) every time it starts and `io.realm.exceptions.RealmFileException` is logged and it seems to be only happening on the app published on play store if I build from Android studio the crash does not occur.  This is my realm initialization class\r\n```\r\nimport android.content.Context\r\nimport io.realm.Realm\r\nimport io.realm.RealmConfiguration\r\n\r\nclass DatabaseService(context: Context) {\r\n    init {\r\n        Realm.init(context)\r\n    }\r\n\r\n    val realmInstance: Realm\r\n        get() {\r\n            val config = RealmConfiguration.Builder().name(Realm.DEFAULT_REALM_NAME)\r\n                .deleteRealmIfMigrationNeeded().schemaVersion(4).build()\r\n            Realm.setDefaultConfiguration(config)\r\n            return Realm.getInstance(config)\r\n        }\r\n}\r\n```\n\n### Stacktrace & log output\n\n```shell\nException io.realm.exceptions.RealmFileException:\r\n  at io.realm.internal.OsSharedRealm.nativeGetSharedRealm\r\n  at io.realm.internal.OsSharedRealm.<init> (OsSharedRealm.java:175)\r\n  at io.realm.internal.OsSharedRealm.getInstance (OsSharedRealm.java:260)\r\n  at io.realm.BaseRealm.<init> (BaseRealm.java:142)\r\n  at io.realm.BaseRealm.<init> (BaseRealm.java:109)\r\n  at io.realm.Realm.<init> (Realm.java:161)\r\n  at io.realm.Realm.createInstance (Realm.java:535)\r\n  at io.realm.RealmCache.createInstance (RealmCache.java:508)\r\n  at io.realm.RealmCache.doCreateRealmOrGetFromCache (RealmCache.java:461)\r\n  at io.realm.RealmCache.createRealmOrGetFromCache (RealmCache.java:422)\r\n  at io.realm.Realm.getInstance (Realm.java:464)\r\n  at org.ole.planet.myplanet.datamanager.DatabaseService.getRealmInstance (DatabaseService.kt:17)\r\n  at org.ole.planet.myplanet.service.UploadToShelfService.uploadUserData (UploadToShelfService.kt:45)\r\n  at org.ole.planet.myplanet.service.AutoSyncWorker.onError (AutoSyncWorker.kt:95)\r\n  at org.ole.planet.myplanet.datamanager.Service$checkVersion$1$onResponse$1.onResponse (Service.kt:148)\r\n  at retrofit2.DefaultCallAdapterFactory$ExecutorCallbackCall$1.lambda$onResponse$0$retrofit2-DefaultCallAdapterFactory$ExecutorCallbackCall$1 (DefaultCallAdapterFactory.java:89)\r\n  at retrofit2.DefaultCallAdapterFactory$ExecutorCallbackCall$1$$ExternalSyntheticLambda0.run (D8$$SyntheticClass)\r\n  at android.os.Handler.handleCallback (Handler.java:958)\r\n  at android.os.Handler.dispatchMessage (Handler.java:99)\r\n  at android.os.Looper.loopOnce (Looper.java:205)\r\n  at android.os.Looper.loop (Looper.java:294)\r\n  at android.app.ActivityThread.main (ActivityThread.java:8248)\r\n  at java.lang.reflect.Method.invoke\r\n  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run (RuntimeInit.java:552)\r\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:971)\r\n```\n```\n\n\n### Can you reproduce the bug?\n\nNo\n\n### Reproduction Steps\n\n**APK build from Android studio**\r\nhttps:\/\/github.com\/open-learning-exchange\/myplanet\/releases\/download\/v0.14.21-lite\/myPlanet.apk\r\n\r\n**APK on playstore**\r\nhttps:\/\/play.google.com\/store\/apps\/details?id=org.ole.planet.myplanet\r\n\r\n**Link to GitHub repo**\r\nhttps:\/\/github.com\/open-learning-exchange\/myplanet\n\n### Version\n\n10.18.0\n\n### What Atlas App Services are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo\n\n### Platform OS and version(s)\n\nGoogle pixel 8 Android 14\n\n### Build environment\n\nAndroid Studio version: Iguana | 2023.2.1\r\nAndroid Build Tools version: 28.0.0\r\nGradle version: 8.4","comments":["\u27a4 PM Bot commented:\n\nJira ticket: RJAVA-1253","@Okuro3499 Thank you for reporting.\r\n\r\nDo you expect a schema migration? If so, the file will be deleted, and the schema version will be set to zero. What if you remove `schemaVersion(4)` - will you still see the exception?","I still get the same exception"],"labels":["T-Bug","O-Community","Needs-Attention","Frequency:Always","SDK-Use:Local","Encryption:Off","Repro:No"]},{"title":"Model cannot be cast to ModelRealmProxyInterface while using realm jars built from source in Android Project","body":"### How frequently does the bug occur?\r\n\r\nAlways\r\n\r\n### Description\r\n\r\nI am using Realm jars which are built from source code. I have added realm-library aar file,  realm-annotations-10.18.0.jar, realm-transformer-10.18.0.jar, realm-gradle-plugin into libs folder of Android project and tried to build. Able to launch the application however getting \r\n\r\n\r\nUserModel cannot be cast to io.realm.com_example_mobile_test_auth_model_UserModelRealmProxyInterface\r\n whenever any db operation is performed\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\n2024-03-07 15:45:21.304  5922-5922  ExampleException         com.example        D  null : null\r\n2024-03-07 15:45:21.305  5922-5922  ExampleException          com.example         D\r\n UserModel cannot be cast to io.realm.com_example_mobile_test_auth_model_UserModelRealmProxyInterface\r\n\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nAlways\r\n\r\n### Reproduction Steps\r\n\r\nBuild the realm code base from source\r\n\r\n### Version\r\n\r\n10.18.0\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nNo\r\n\r\n### Platform OS and version(s)\r\n\r\nMac OS 14.3\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: Android Studio Hedgehog | 2023.1.1 Patch 2\r\nAndroid Build Tools version: 33.0.1\r\nGradle version: 8\r\n","comments":["\u27a4 PM Bot commented:\n\nJira ticket: RJAVA-1251","Any help on this. Stuck with the above error and unable to proceed","Looks like you are not transforming the realm model classes. If you don't  apply our plugin you will have to [register the transformer](https:\/\/github.com\/realm\/realm-java\/blob\/main\/realm-transformer\/src\/main\/kotlin\/io\/realm\/transformer\/RealmTransformer.kt#L86) yourself. ","Adding the realm-transformer jar file to libs doesn't help here?\r\n Is there any way to apply the plugin using jar file. \r\nEarlier I used  **android.registerTransform(new RealmTransformer(rootProject))** to register but in Gradle 8 android.registerTransform is deprecated. ","Any help on this","I have tried using \r\n \r\n**import io.realm.transformer.RealmTransformerKt\r\nRealmTransformerKt.registerRealmTransformerTask(rootProject)**\r\n \r\nto register the RealmTransformer in the build.gradle file, however getting below error while trying to build it\r\n\r\nCaused by: org.gradle.api.UnknownDomainObjectException: Extension of type 'AndroidComponentsExtension' does not exist. Currently registered extension types: [ExtraPropertiesExtension, KtlintExtension]\r\n\tat org.gradle.internal.extensibility.ExtensionsStorage.getHolderByType(ExtensionsStorage.java:88)\r\n\tat org.gradle.internal.extensibility.ExtensionsStorage.getByType(ExtensionsStorage.java:74)\r\n\tat org.gradle.internal.extensibility.DefaultConvention.getByType(DefaultConvention.java:160)\r\n\tat org.gradle.internal.extensibility.DefaultConvention.getByType(DefaultConvention.java:155)\r\n\tat io.realm.transformer.RealmTransformerKt.registerRealmTransformerTask(RealmTransformer.kt:88)\r\n\tat io.realm.transformer.RealmTransformerKt$registerRealmTransformerTask.call(Unknown Source)\r\n\t\r\nLet me know if I missed anything here\r\n\t"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:Off"]},{"title":"[realm-core-12.3.0] Assertion failed: false","body":"#### SDK and version\nSDK : java realm-core-12.3.0\nVersion: 12.3.0\n\n#### Observations\ni dont not the step, user crashes while using the app\u3002\n\n#### Crash log \/ stacktrace\nbacktrace:\n    #00 pc 000000000007066c  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (abort+160)\n    realm\/realm-core#1 pc 000000000066d55c  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/librealm-jni.so\n    realm\/realm-core#2 pc 000000000066d858  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/librealm-jni.so\n    realm\/realm-core#3 pc 000000000066d694  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/librealm-jni.so\n    realm\/realm-core#4 pc 00000000003c64b8  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/librealm-jni.so\n    realm\/realm-core#5 pc 00000000000d2578  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__cxa_finalize+212)\n    realm\/realm-core#6 pc 00000000000cdf60  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (exit+24)\n    realm\/realm-core#7 pc 0000000000557828  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/libflutter.so\n    realm\/realm-core#8 pc 00000000005591b8  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/libflutter.so\n    realm\/realm-core#9 pc 000000000062da0c  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/libflutter.so\n    realm\/realm-core#10 pc 000000000062d864  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/libflutter.so\n    realm\/realm-core#11 pc 00000000000044fc  \/data\/app\/com.demo.eh-9zyvbbrKmFJvAIcxvAHXjw==\/lib\/arm64\/libapp.so (_kDartVmSnapshotInstructions+9468)\n\n01-25 15:23:44.968 22446 22649 E REALM   : \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/jni_util\/jni_utils.cpp:54: [realm-core-12.3.0] Assertion failed: false\n01-25 15:23:44.968 22446 22649 E REALM   : <backtrace not supported on this platform>!!! IMPORTANT: Please report this at https:\/\/github.com\/realm\/realm-core\/issues\/new\/choose\n\n#### Steps & Code to Reproduce\ni dont not the step\n\n","comments":["Hello, thanks for reporting this, however this is not a core issue, It is a JNI issue in the Java SDK. \r\nIn particular, I think this is the offending code:\r\n\r\n```\r\nJNIEnv* JniUtils::get_env(bool attach_if_needed)\r\n{\r\n    REALM_ASSERT_DEBUG(s_instance);\r\n\r\n    JNIEnv* env;\r\n    if (s_instance->m_vm->GetEnv(reinterpret_cast<void**>(&env), s_instance->m_vm_version) != JNI_OK) {\r\n        if (attach_if_needed) {\r\n            jint ret = s_instance->m_vm->AttachCurrentThread(&env, nullptr);\r\n            REALM_ASSERT_RELEASE(ret == JNI_OK);\r\n        }\r\n        else {\r\n            REALM_ASSERT_RELEASE(false);\r\n        }\r\n    }\r\n\r\n    return env;\r\n}\r\n```\r\n\r\nI am not an expert, but it seems to me that `JniUtils::get_env(bool attach_if_needed)` was called with `attach_if_needed = false.`","\u27a4 PM Bot commented:\n\nJira ticket: RJAVA-1252","@jalen-ma \r\n\r\nIt is similar to https:\/\/github.com\/realm\/realm-java\/issues\/6987.\r\n\r\nHow often does it happen? Any particular operation which triggers it?"],"labels":["O-Community","Waiting-For-Reporter"]},{"title":"Internal crash on OsJavaNetworkTransport.cpp","body":"### How frequently does the bug occur?\n\nSometimes\n\n### Description\n\nSometimes when we try to access a realm it crashes our app, don\u00b4t really have much info per the stacktrace but hopefully it means something for you guys, our QA team says it happens from time to time.\n\n### Stacktrace & log output\n\n```shell\nFatal Exception: java.lang.IllegalArgumentException: Illegal Argument: Invalid column key in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_objectstore_OsJavaNetworkTransport.cpp line 61\r\n       at io.realm.internal.objectstore.OsJavaNetworkTransport.nativeHandleResponse(OsJavaNetworkTransport.java)\r\n       at io.realm.internal.objectstore.OsJavaNetworkTransport.handleResponse(OsJavaNetworkTransport.java:98)\r\n       at io.realm.internal.network.OkHttpNetworkTransport$1.run(OkHttpNetworkTransport.java:102)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n       at java.lang.Thread.run(Thread.java:919)\n```\n\n\n### Can you reproduce the bug?\n\nSometimes\n\n### Reproduction Steps\n\n_No response_\n\n### Version\n\n10.17.0\n\n### What Atlas App Services are you using?\n\nAtlas Device Sync\n\n### Are you using encryption?\n\nNo\n\n### Platform OS and version(s)\n\nAndroid 10\n\n### Build environment\n\nAndroid Studio version: Android Studio Hedgehog | 2023.1.1 Canary 15\r\nAndroid Build Tools version: 33.0.2\r\nGradle version: 7.6.2","comments":["Hmm, the crash is associated with HTTP requests going to App Services. The error message \"Invalid column key\" however is  an internal crash saying that our association between model class properties and their underlying representation is no longer correct.\r\n\r\nThis is a bit weird, since Device Sync does not use the `OsJavaNetworkTransport` class, it uses its own Websocket connection.\r\n\r\nAre you by any chance using Functions? And if yes, are you perhaps writing to the Realm using the result of the function response?\r\n","mmm no I don't think so @cmelchior, we don't write at any time on our app, writes are even set to false on our device sync config, only reads are allowed, all writes are done by the sync SDK internally while syncing.","Hi @jhonnyinstacart. Could this somehow be related to testing scenarios of upgrading or downgrading the application? The user metadata is stored in an internal realm-file. The schema of this realm changed with 10.17.0, so ex. downgrading from that version to a prior one would require the user to login again, and some scenarios with user\/authentication operations  could maybe trigger the above error. Can you try to elaborate on the use cases that triggers this? ","I think you might be right @rorbech, thanks for the suggestion, we are still trying to come up with repro steps, no luck just yet, but independently can you guys make a fix for this based on your theory? the SDK should def not crash when upgrading or downgrading \ud83d\ude4f ","Hi @jhonnyinstacart. I have tried replicating your issue by updating and downgrading across 10.16.2 and 10.17.0. Upgrading works, but downgrading is not possible because of an internal check in core that does not work as intended (https:\/\/github.com\/realm\/realm-core\/pull\/7256). The work around for downgrading would be to delete the metadata Realm in `$[SYNC-ROOT-DIRECTORY]\/mongodb-realm\/[APP-ID]\/server-utility\/metadata\/` as part of the downgrade and would of course require logging in again.  \r\n\r\nEven with the very unfortunate issue of not being able to downgrade, I cannot provoke you crash, so please gather information on any use case leading up to the crash. \r\n\r\n "],"labels":["T-Bug","Reproduction-Required","O-Community","Encryption:Off","Frequency:Sometimes","SDK-Use:Sync","Repro:Sometimes"]},{"title":"Not Receiving Object Updates","body":"### How frequently does the bug occur?\r\n\r\nSometimes\r\n\r\n### Description\r\n\r\nWhen updating a field in an object I expect that a Flowable taken from the results of a query that returns that object will emit the changed object. In practice nothing is emitted.\r\n\r\nWhen using the debugger, I can see the proxy being updated and the calls to the native functions. I cannot see anything coming back out of the native functions.\r\n\r\n### Stacktrace & log output\r\n\r\n_No response_\r\n\r\n### Can you reproduce the bug?\r\n\r\nSometimes - seems intermittent with no discernible pattern\r\n\r\n### Reproduction Steps\r\n\r\nRealm Initialisation:\r\n\r\n```\r\nRealmConfiguration realmConfiguration = new RealmConfiguration.Builder()\r\n\t.schemaVersion(11)\r\n\t.migration(new MyRealmMigration())\r\n\t.allowWritesOnUiThread(true)\r\n\t.rxFactory(new RealmObservableFactory(false))\r\n\t.build();\r\nRealm.setDefaultConfiguration(realmConfiguration);\r\n```\r\n\r\nQuery and flowable retrieval where visitId is a primary for the Visit class:\r\n\r\n```\r\nVisit visit = realm.where(Visit.class)\r\n                .equalTo(key visitId).findFirstAsync();\r\n\r\nDisposable subscription = visit.asFlowable() \/\/ No further emissions after initial result even if data is changed elsewhere\r\n            .filter(realmObject -> realmObject.isLoaded() && realmObject.isValid())\r\n            .firstElement()\r\n            .flatMap(realmObject -> {\r\n                Visit theVisit = (Visit) realmObject;\r\n                listener.setVisit(theVisit);\r\n                UIVisitData uiVisitData = getUiVisitFromVisit(theVisit, listener);\r\n                return Maybe.just(uiVisitData);\r\n            }).observeOn(AndroidSchedulers.mainThread())\r\n            .subscribe(listener);\r\n        listener.setObservableSubscription(subscription);\r\n```\r\n\r\nThe proxy for Visit:\r\n\r\n```\r\npublic void realmSet$visitStatus(String value) {\r\n    if (proxyState.isUnderConstruction()) {\r\n        if (!proxyState.getAcceptDefaultValue$realm()) {\r\n            return;\r\n        }\r\n        final Row row = proxyState.getRow$realm();\r\n        if (value == null) {\r\n            row.getTable().setNull(columnInfo.visitStatusColKey, row.getObjectKey(), true);\r\n            return;\r\n        }\r\n        row.getTable().setString(columnInfo.visitStatusColKey, row.getObjectKey(), value, true);\r\n        return;\r\n    }\r\n\r\n    proxyState.getRealm$realm().checkIfValid();\r\n    if (value == null) {\r\n        proxyState.getRow$realm().setNull(columnInfo.visitStatusColKey);\r\n        return;\r\n    }\r\n    proxyState.getRow$realm().setString(columnInfo.visitStatusColKey, value);\r\n}\r\n```\r\n\r\n### Version\r\n\r\n10.16.1\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nNo\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 13, possiblyothers\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: Hedgehog, but also older version\r\nAndroid Build Tools version: 34\r\nGradle version: 8.0\r\n","comments":["Hi @rhysll34. There is a lot of non-Realm code in play in our report. Could you try to boil you example down to minimal example showing your issue and leave out all non-Realm related (e.g. first element, flatmap, visitors, etc.).  ","I have added some code to my project to create a minimal example. The code below reflects what I have added. As I interact with the UI the result of `Visit::getVisitStatus()` should change between various string values, and I would expect to see each new value appear in Logcat. This doesn't always happen. I am fairly certain that the updates are being persisted into Realm. The Visit object is being updated by setting the field value of the object within a Realm transaction. Causing the method below to be caused again will result in the correct value to be retrieved.\r\n\r\n```\r\nclass RealmDB {\r\n    RealmObject visit;\r\n    private final Realm realm;\r\n\r\n    ...\r\n\r\n    public void getVisit(int visitId) {\r\n        visit = realm.where(Visit.class)\r\n            .equalTo(\"key\", visitId).findFirstAsync();\r\n\r\n        visit.addChangeListener(a -> {\r\n            Visit visitB = (Visit)a;\r\n            Timber.d(\"Visit status: %s\", visitB.getVisitStatus());\r\n        }); \r\n    }\r\n\r\n    ....\r\n}\r\n```\r\n\r\nThe instance of RealmDB should remain in scope while the Activity is still running."],"labels":["T-Bug","O-Community","Needs-Attention","Repro:Always","SDK-Use:Local","Encryption:Off","Frequency:Sometimes"]},{"title":"kapt plugin throwing error with kotlinx.coroutines 1.7.x","body":"### How frequently does the bug occur?\r\n\r\nAlways\r\n\r\n### Description\r\n\r\nI have updated my app dependencies and some now depend on `org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.1` and `org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.1`.\r\nBefore, they were version 1.6.4.\r\nWhen building the project now, Realm throws an error `Field \"xyz\" of type \"@org.jetbrains.annotations.Nullable byte[]\" is not supported`.\r\nField `xyz` being a variable of a `RealmObject` implemented in Kotlin (`var xyz: ByteArray? = null`).\r\n\r\nI tried updating both to the latest version (as of now 1.7.3) but the issue remains.\r\nWhen explicitly downgrading to version 1.6.4 it works again:\r\n`implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4!!\")`\r\n`implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4!!\")`\r\n\r\nThe release notes of kotlinx-coroutines 1.7.0 list some breaking changes, but I haven't been able to find more details.\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\n> Task :app:kaptDebugKotlin FAILED\r\nerror: Field \"xyz\" of type \"@org.jetbrains.annotations.Nullable byte[]\" is not supported.\r\npublic class Foo extends io.realm.RealmObject {\r\n       ^\r\nwarning: Unclosed files for the types 'io.realm.foo_bar_FooRealmProxy'; these types will not undergo annotation processing\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n* What went wrong:\r\nExecution failed for task ':app:kaptDebugKotlin'.\r\n> A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask$KaptExecutionWorkAction\r\n   > java.lang.reflect.InvocationTargetException (no error message)\r\n\r\n* Try:\r\n> Run with --stacktrace option to get the stack trace.\r\n> Run with --info or --debug option to get more log output.\r\n> Run with --scan to get full insights.\r\n\r\n* Get more help at https:\/\/help.gradle.org\r\n\r\nBUILD FAILED in 21s\r\n40 actionable tasks: 40 executed\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nAlways\r\n\r\n### Reproduction Steps\r\n\r\n- Create an Android Studio project with Kotlin.\r\n- Install the Realm Java SDK.\r\n- Include the `org.jetbrains.kotlinx:kotlinx-coroutines-core` and\/or `org.jetbrains.kotlinx:kotlinx-coroutines-android` dependency with a version >= 1.7.0:\r\n`implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3\")`\r\n`implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3\")`\r\n- Create a Realm Object class with a variable of type `ByteArray?` and a default value of `null`:\r\n`var foo: ByteArray? = null`\r\n- Build the project.\r\n\r\n### Version\r\n\r\n10.17.0\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nNo\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 14, SDK 34\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: Giraffe 2022.3.1 Patch 2\r\nAndroid Build Tools version: 33.0.1\r\nGradle version: 8.0\r\nKotlin & kapt version: 1.9.0","comments":["I'm having the same issue!!"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:Off"]},{"title":"SEGV_MAPERR crash by RealmFinalizing","body":"### How frequently does the bug occur?\r\n\r\nOnce\r\n\r\n### Description\r\n\r\nI haven't found a way to reproduce this, but this seems like only happened after I upgraded from 10.16.1 to 10.17.0.\r\n\r\n### Stacktrace & log output\r\n\r\n```\r\n*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\nBuild fingerprint: 'samsung\/gts9wifixx\/gts9wifi:13\/TP1A.220624.014\/X710XXU1AWHA:user\/release-keys'\r\nRevision: '6'\r\nABI: 'arm64'\r\nProcessor: '3'\r\nTimestamp: 2023-10-23 18:27:14.849304615+0800\r\nProcess uptime: 44s\r\nCmdline: com.yygg.note.app.dev\r\npid: 25116, tid: 25269, name: RealmFinalizing  >>> com.yygg.note.app.dev <<<\r\nuid: 10536\r\ntagged_addr_ctrl: 0000000000000001 (PR_TAGGED_ADDR_ENABLE)\r\npac_enabled_keys: 000000000000000f (PR_PAC_APIAKEY, PR_PAC_APIBKEY, PR_PAC_APDAKEY, PR_PAC_APDBKEY)\r\nsignal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x4d7a634c6368635e\r\n    x0  4d7a634c636862f6  x1  000000706ebaee10  x2  0000006fd7590c8c  x3  b400006ff8e9bd40\r\n    x4  0000000000000000  x5  000000001ed905a9  x6  b4000070557de800  x7  0000000000000001\r\n    x8  92e7a6171d52fdc8  x9  92e7a6171d52fdc8  x10 0000000000000000  x11 0000000000000004\r\n    x12 0000006fa99aa5a0  x13 0000006fa99aa490  x14 000000706ebaee11  x15 00000000ebad6a89\r\n    x16 0000006fd7568858  x17 0000006fa99ab970  x18 0000006fa9762000  x19 b400006ff8e9bd40\r\n    x20 4d7a634c636862f6  x21 634c7653634c684d  x22 000000706ebaee10  x23 000000706ebaee10\r\n    x24 0000006fa99abac0  x25 b400007126841c00  x26 0000000000004071  x27 000000706ebaee30\r\n    x28 0000006fa99ab980  x29 0000006fa99ab950\r\n    lr  0000006fd75e8da8  sp  0000006fa99ab910  pc  0000006fd75d211c  pst 0000000080001000\r\n\r\nbacktrace:\r\n      #00 pc 000000000054511c  \/data\/app\/~~cuGCwB2JcmQGjwyPkQhMJA==\/com.yygg.note.app.dev-7j5M0xaRN4jonDfXtjWfFA==\/base.apk!librealm-jni.so (BuildId: 34c2baa0e05e15474c7de859b65b28cb4506f3da)\r\n      #01 pc 000000000055bda4  \/data\/app\/~~cuGCwB2JcmQGjwyPkQhMJA==\/com.yygg.note.app.dev-7j5M0xaRN4jonDfXtjWfFA==\/base.apk!librealm-jni.so (BuildId: 34c2baa0e05e15474c7de859b65b28cb4506f3da)\r\n      #02 pc 0000000000503ca0  \/data\/app\/~~cuGCwB2JcmQGjwyPkQhMJA==\/com.yygg.note.app.dev-7j5M0xaRN4jonDfXtjWfFA==\/base.apk!librealm-jni.so (BuildId: 34c2baa0e05e15474c7de859b65b28cb4506f3da)\r\n      #03 pc 000000000034dc30  \/apex\/com.android.art\/lib64\/libart.so (art_quick_generic_jni_trampoline+144) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #04 pc 0000000000337480  \/apex\/com.android.art\/lib64\/libart.so (art_quick_invoke_static_stub+640) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #05 pc 0000000000519914  \/apex\/com.android.art\/lib64\/libart.so (bool art::interpreter::DoCall<false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, bool, art::JValue*)+2364) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #06 pc 00000000004a31ac  \/apex\/com.android.art\/lib64\/libart.so (void art::interpreter::ExecuteSwitchImplCpp<false>(art::interpreter::SwitchImplContext*)+1840) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #07 pc 00000000003503d8  \/apex\/com.android.art\/lib64\/libart.so (ExecuteSwitchImplAsm+8) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #08 pc 000000000026ca14  [anon:dalvik-classes9.dex extracted in memory from \/data\/app\/~~cuGCwB2JcmQGjwyPkQhMJA==\/com.yygg.note.app.dev-7j5M0xaRN4jonDfXtjWfFA==\/base.apk!classes9.dex] (io.realm.internal.NativeObjectReference.cleanup+0)\r\n      #09 pc 000000000036c700  \/apex\/com.android.art\/lib64\/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame&, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.3816585244953842104)+232) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #10 pc 000000000051a45c  \/apex\/com.android.art\/lib64\/libart.so (bool art::interpreter::DoCall<false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, bool, art::JValue*)+5252) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #11 pc 00000000004a2e3c  \/apex\/com.android.art\/lib64\/libart.so (void art::interpreter::ExecuteSwitchImplCpp<false>(art::interpreter::SwitchImplContext*)+960) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #12 pc 00000000003503d8  \/apex\/com.android.art\/lib64\/libart.so (ExecuteSwitchImplAsm+8) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #13 pc 000000000026c034  [anon:dalvik-classes9.dex extracted in memory from \/data\/app\/~~cuGCwB2JcmQGjwyPkQhMJA==\/com.yygg.note.app.dev-7j5M0xaRN4jonDfXtjWfFA==\/base.apk!classes9.dex] (io.realm.internal.FinalizerRunnable.run+0)\r\n      #14 pc 000000000036c700  \/apex\/com.android.art\/lib64\/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame&, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.3816585244953842104)+232) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #15 pc 000000000051a45c  \/apex\/com.android.art\/lib64\/libart.so (bool art::interpreter::DoCall<false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, bool, art::JValue*)+5252) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #16 pc 00000000004a3ce8  \/apex\/com.android.art\/lib64\/libart.so (void art::interpreter::ExecuteSwitchImplCpp<false>(art::interpreter::SwitchImplContext*)+4716) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #17 pc 00000000003503d8  \/apex\/com.android.art\/lib64\/libart.so (ExecuteSwitchImplAsm+8) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #18 pc 000000000010ee0c  \/apex\/com.android.art\/javalib\/core-oj.jar (java.lang.Thread.run+0)\r\n      #19 pc 000000000036c700  \/apex\/com.android.art\/lib64\/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame&, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.3816585244953842104)+232) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #20 pc 000000000036bff8  \/apex\/com.android.art\/lib64\/libart.so (artQuickToInterpreterBridge+964) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #21 pc 000000000034dd68  \/apex\/com.android.art\/lib64\/libart.so (art_quick_to_interpreter_bridge+88) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #22 pc 00000000003371a4  \/apex\/com.android.art\/lib64\/libart.so (art_quick_invoke_stub+612) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #23 pc 000000000023ea64  \/apex\/com.android.art\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+144) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #24 pc 000000000054436c  \/apex\/com.android.art\/lib64\/libart.so (art::Thread::CreateCallback(void*)+1600) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)\r\n      #25 pc 00000000000f5298  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__pthread_start(void*)+208) (BuildId: 55a7515345951d438fd16e74b171760b)\r\n      #26 pc 000000000008ebdc  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__start_thread+68) (BuildId: 55a7515345951d438fd16e74b171760b)\r\n```\r\n\r\nI saw this happened twice, once yesterday and once today. There has been no code change in how we use realm, nor realm db schemas in the last one month.\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nNo\r\n\r\n### Reproduction Steps\r\n\r\n_No response_\r\n\r\n### Version\r\n\r\n10.17.0\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nNo\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 13\r\n\r\n### Build environment\r\n\r\nAndroid Studio Giraffe | 2022.3.1 Patch 2\r\nGradle 8.1.2\r\n","comments":["Thanks for the report, do you have a full stack trace for this crash?","@clementetb Just updated!"],"labels":["T-Bug","O-Community","SDK-Use:Local","Encryption:Off","Repro:No","Frequency:Once"]},{"title":"Test of nullability of private properties","body":"Test showcasing #7810. Bumping to Kotlin 1.8.20 in `dependencies.txt` will make the test `kotlinTypeNonNull` pass, while it fails for lower versions.","comments":[],"labels":["cla: yes"]},{"title":"IllegalAccessError with Android Gradle Plugin 8.0.2 and Java 17","body":"### How frequently does the bug occur?\r\n\r\nAlways\r\n\r\n### Description\r\n\r\nWe recently bumped our Android app to \r\nRealm 10.16.0\r\nKotlin 1.8.21\r\nGradle 8.0.2 \r\nkotlinCompilerExtensionVersion 1.4.7\r\nAnd due to some kapt related error we also had to specifically set Java to the app and its modules like:\r\n```\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_17\r\n        targetCompatibility JavaVersion.VERSION_17\r\n    }\r\n```\r\nWith this setup we are getting an error when trying to run our unit tests and these unit tests use Java objects that include the LinkingObjects annotation:\r\n\r\n`java.lang.IllegalAccessError: Update to non-static final field com.example.myapplication.objects.Dog.owners attempted from a different method (realmSet$owners) than the initializer method <init>` \r\n\r\nThis error maybe related to these ones:\r\nhttps:\/\/github.com\/realm\/realm-java\/issues\/7799\r\nhttps:\/\/github.com\/realm\/realm-java\/issues\/7804\r\n\r\nTwo workarounds that we tried and worked are\r\n- Using :\r\n```\r\nafterEvaluate {\r\n    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {\r\n      if (project.plugins.hasPlugin(\"com.android.application\") || project.plugins.hasPlugin(\"com.android.library\")) {\r\n        kotlinOptions.jvmTarget = android.compileOptions.sourceCompatibility\r\n      } else {\r\n        kotlinOptions.jvmTarget = sourceCompatibility\r\n      }\r\n    }\r\n  }\r\n```\r\ninstead of:\r\n```\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_17\r\n        targetCompatibility JavaVersion.VERSION_17\r\n    }\r\n```\r\n- converting the related Java objects to Kotlin ones\r\n\r\nUnfortunately both solutions are risky or hacky (the first one) or require too much work (the second one) and are not acceptable for the time being.\r\n\r\n\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\njava.lang.IllegalAccessError: Update to non-static final field com.example.myapplication.objects.Dog.owners attempted from a different method (realmSet$owners) than the initializer method <init>\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nAlways\r\n\r\n### Reproduction Steps\r\n\r\nFor this reason I created a demo project based on the same setup as our project which demonstrates the same behaviour\r\n[MyApplication.zip](https:\/\/github.com\/realm\/realm-java\/files\/11771906\/MyApplication.zip)\r\n\r\n\r\n### Version\r\n\r\nAndroid 13\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nYes\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 13\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: Flamingo | 2022.2.1\r\nRealm 10.16.0\r\nKotlin 1.8.21\r\nGradle 8.0.2 \r\nkotlinCompilerExtensionVersion 1.4.7\r\n","comments":["I've got the same problem with my Java application after upgrading to AGP 8.0.2 and Java 17. Do you still use workarounds to solve it or we have any chance to get it fixed?","I got a possible solution on another thread @patricknanganocappello \r\n\r\nCheck [here](https:\/\/github.com\/actions\/runner-images\/issues\/7915#issuecomment-1682231669)\r\n\r\nLet me know if works, I still didn't had the time to check myself "],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:On"]},{"title":"Compensating writes","body":"Expose better error messages for compensating writes similar to https:\/\/github.com\/realm\/realm-kotlin\/issues\/1375\n\n","comments":[],"labels":["gathering-interest"]},{"title":"Could not find 'librealm-jni.so'. Looked for: [arm64-v8a], but only found: []","body":"### How frequently does the bug occur?\n\nSometimes\n\n### Description\n\nI'm using version 10.11.1, and found the crash happened 5 times on a same device.\r\n```\r\nFatal Exception: java.lang.RuntimeException: Unable to create application com.dw.android.mukbee.App: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a], but only found: [].\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6465)\r\n       at android.app.ActivityThread.access$1300(ActivityThread.java:219)\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1859)\r\n       at android.os.Handler.dispatchMessage(Handler.java:107)\r\n       at android.os.Looper.loop(Looper.java:214)\r\n       at android.app.ActivityThread.main(ActivityThread.java:7356)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)\r\n```\r\n\r\n```\r\nCaused by com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a], but only found: [].\r\n       at com.getkeepsafe.relinker.ApkLibraryInstaller.installLibrary(ApkLibraryInstaller.java:173)\r\n       at com.getkeepsafe.relinker.ReLinkerInstance.loadLibraryInternal(ReLinkerInstance.java:180)\r\n       at com.getkeepsafe.relinker.ReLinkerInstance.loadLibrary(ReLinkerInstance.java:136)\r\n       at com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:70)\r\n       at com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:57)\r\n       at io.realm.internal.RealmCore.loadLibrary(RealmCore.java:60)\r\n       at io.realm.Realm.initializeRealm(Realm.java:348)\r\n       at io.realm.Realm.init(Realm.java:263)\r\n       at com.dw.android.mukbee.App.initRealm(App.java:89)\r\n       at com.dw.android.mukbee.App.onCreate(App.java:73)\r\n       at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1182)\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6460)\r\n       at android.app.ActivityThread.access$1300(ActivityThread.java:219)\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1859)\r\n       at android.os.Handler.dispatchMessage(Handler.java:107)\r\n       at android.os.Looper.loop(Looper.java:214)\r\n       at android.app.ActivityThread.main(ActivityThread.java:7356)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)\r\n```\r\n\r\nDevice: Google Mainline Android 10\r\n\r\nI also checked my apk file, and I can find the 'librealm-jni.so' file.\r\n<img width=\"579\" alt=\"\u56fe\u7247\" src=\"https:\/\/github.com\/realm\/realm-java\/assets\/17312834\/4cdd4b12-1639-4bbf-ae25-f83aca0ce4ab\">\r\n\n\n### Stacktrace & log output\n\n```shell\nSee \"Description\" part.\n```\n\n\n### Can you reproduce the bug?\n\nNo\n\n### Reproduction Steps\n\nOnly found crash logs on firebase Crashlytics.\n\n### Version\n\n10.11.1\n\n### What Atlas App Services are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo\n\n### Platform OS and version(s)\n\nAndroid Android 10\n\n### Build environment\n\nAndroid Studio version: Android Studio Electric Eel | 2022.1.1 Patch 2\r\nAndroid Build Tools version: \"29.0.3\"\r\nGradle version: \"7.1.3\"\r\n","comments":["In my project we've been seeing this issue plenty of times, mainly for Android 6 and Android 8 - there were actually no occurrences for Android > 10. \r\nFor what I know several other people have also noticed that as there are some reports on other sites. And I believe this ticket is a duplicate of \r\nhttps:\/\/github.com\/realm\/realm-java\/issues\/6812","\u27a4 clementetb commented:\n\nHi, thanks for reporting the issue. Are you publishing the app via app bundle or APK?","I always use app bundle.","Do you have any update on that? There is a growing number of such issues in my projects, mainly for Android < 8.x. And we also always use app bundles.","same issue\r\n```\r\njava.lang.RuntimeException: Unable to create application com.myapp.MainApplication:  com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].\r\n                                                                                                    \tat android.app.ActivityThread.handleBindApplication(ActivityThread.java:6998)\r\n                                                                                                    \tat android.app.ActivityThread.-$$Nest$mhandleBindApplication(Unknown Source:0)\r\n                                                                                                    \tat android.app.ActivityThread$H.handleMessage(ActivityThread.java:2228)\r\n                                                                                                    \tat android.os.Handler.dispatchMessage(Handler.java:106)\r\n                                                                                                    \tat android.os.Looper.loopOnce(Looper.java:210)\r\n                                                                                                    \tat android.os.Looper.loop(Looper.java:299)\r\n                                                                                                    \tat android.app.ActivityThread.main(ActivityThread.java:8136)\r\n                                                                                                    \tat java.lang.reflect.Method.invoke(Native Method)\r\n                                                                                                    \tat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:580)\r\n                                                                                                    \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1028)\r\n                                                                                                    Caused by: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].\r\n                                                                                                    \tat com.getkeepsafe.relinker.ApkLibraryInstaller.installLibrary(ApkLibraryInstaller.java:173)\r\n                                                                                                    \tat com.getkeepsafe.relinker.ReLinkerInstance.loadLibraryInternal(ReLinkerInstance.java:180)\r\n                                                                                                    \tat com.getkeepsafe.relinker.ReLinkerInstance.loadLibrary(ReLinkerInstance.java:136)\r\n                                                                                                    \tat com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:70)\r\n                                                                                                    \tat com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:57)\r\n                                                                                                    \tat io.realm.internal.RealmCore.loadLibrary(RealmCore.java:60)\r\n                                                                                                    \tat io.realm.Realm.initializeRealm(Realm.java:318)\r\n                                                                                                    \tat io.realm.Realm.init(Realm.java:261)\r\n                                                                                                    \tat com.myapp.MainApplication.onCreate(MainApplication.java:97)\r\n                                                                                                    \tat android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1277)\r\n                                                                                                    \tat android.app.ActivityThread.handleBindApplication(ActivityThread.java:6992)\r\n                                                                                                    \tat android.app.ActivityThread.-$$Nest$mhandleBindApplication(Unknown Source:0)\u00a0\r\n                                                                                                    \tat android.app.ActivityThread$H.handleMessage(ActivityThread.java:2228)\u00a0\r\n                                                                                                    \tat android.os.Handler.dispatchMessage(Handler.java:106)\u00a0\r\n                                                                                                    \tat android.os.Looper.loopOnce(Looper.java:210)\u00a0\r\n                                                                                                    \tat android.os.Looper.loop(Looper.java:299)\u00a0\r\n                                                                                                    \tat android.app.ActivityThread.main(ActivityThread.java:8136)\u00a0\r\n                                                                                                    \tat java.lang.reflect.Method.invoke(Native Method)\u00a0\r\n                                                                                                    \tat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:580)\u00a0\r\n                                                                                                    \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1028)\u00a0\r\n```","Could you try doing this: https:\/\/github.com\/realm\/realm-java\/issues\/6812#issuecomment-1637585048"],"labels":["T-Bug","O-Community","Waiting-For-Reporter","SDK-Use:Local","Encryption:Off","Frequency:Sometimes","Repro:No"]},{"title":"[Draft] Make examples compile with AGP 8","body":"Mostly for testing. This PR makes all the examples compile with AGP 8. It requires Java 17 to run.","comments":[],"labels":["cla: yes"]},{"title":"Transformer-api breaks MoshiX generated adapters","body":"### How frequently does the bug occur?\n\nAlways\n\n### Description\n\nWhen we combine MoshiX's Kotlin Compiler plugin with realm using transformer api, our production build misses generated JsonAdapters. Adding a custom rule for R8 adds them back. So the best guess is that realm is somehow blocking Moshi from generating custom rules or removing custom rules, tbh no idea.\r\n\r\nOriginally reported here: https:\/\/github.com\/ZacSweers\/MoshiX\/issues\/396\n\n### Stacktrace & log output\n\n_No response_\n\n### Can you reproduce the bug?\n\nAlways\n\n### Reproduction Steps\n\nThe reproduction is attached.\r\n\r\n[moshigradlecrash-full.zip](https:\/\/github.com\/realm\/realm-java\/files\/11160284\/moshigradlecrash-full.zip)\r\n\n\n### Version\n\n10.13.3-transformer-api\n\n### What Atlas App Services are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo\n\n### Platform OS and version(s)\n\nMacOS\n\n### Build environment\n\nAndroid Studio version: AS 2022.1.1\r\nAndroid Build Tools version: AGP's default.\r\nGradle version: AGP 7.4\r\n","comments":["I tried to investigate the `app\/build\/outpus\/mapping\/release\/configuration.txt` and it seems like the MoshiX defined rules are not picked up when you apply the realm-plugin. After dumping the inputs and outputs of `app:mergeReleaseGeneratedProguardFiles` with and without applying the realm-plugin it shows that the MoshiX generated rules are not added as inputs when applying the plugin. \r\n\r\nWithout realm plugin:\r\n```\r\n> Task :app:mergeReleaseGeneratedProguardFiles\r\ninputs:\r\n        ..\/moshigradlecrash\/app\/build\/generated\/moshix\/release\/resources\/META-INF\/proguard\/moshi-com.example.moshigradlecrash.Test.pro\r\noutputs:\r\n        ..\/moshigradlecrash\/app\/build\/intermediates\/generated_proguard_file\/release\/proguard.txt\r\n```\r\nWith realm plugin:\r\n```\r\n> Task :app:mergeReleaseGeneratedProguardFiles UP-TO-DATE\r\ninputs:\r\noutputs:\r\n        ..\/moshigradlecrash\/app\/build\/intermediates\/generated_proguard_file\/release\/proguard.txt\r\n```\r\nI can't find the tasks that actually generates that output, so have a hard time tracing the dependencies. Maybe the files are attached to a task that is somehow not triggered when the new transformer pipeline is in effect. (Or maybe we somehow fail to pick up the resource files.) But the convention about putting the proguard configuration in `resource\/META-INF\/` seems off, so wouldn't expect it to be the way to go and would think that the wiring of generated proguard rules to the `mergeReleaseGeneratedProguardFiles` should be reworked to match the new transformer API in MoshiX.\r\n\r\nAs a workaround you could maybe just add the generated proguard configuration to `android.buildTypes.release.proguardFiles` and add the appropriate task dependencies if you can locate the task that generates it. "],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:Off"]},{"title":"Choose the linker used during the initialization phase","body":"### Problem\n\nSome users are reporting crashes during the initialization phase where `Relinker` is not able to find the native libraries. \n\n### Solution\n\nAlbeit we don't know the exact cause as we cannot reproduce the issue we think it might be related to using `Relinker` on Android with API >= 23.\r\n\r\nProviding a way to disable `Relinker` on APIS >= 23, or even disabling it completely would allow users to validate if this is the root cause and fix it.\n\n### Alternatives\n\n_No response_\n\n### How important is this improvement for you?\n\nWould be a major improvement\n\n### Feature would mainly be used with\n\nLocal Database only","comments":[],"labels":["T-Enhancement","SDK-Use:Local","Importance:Major"]},{"title":"Test exposing bug in Dictionary migration","body":"Surfacing https:\/\/github.com\/realm\/realm-java\/issues\/7781","comments":[],"labels":["cla: yes"]},{"title":"FallbackToDestructiveMigration feature","body":"When we are using a Room database, we are allowed to use **.fallbackToDestructiveMigration()** option.\r\nSetting this option, Room tries to execute the migrations we specified. If any error occurs, Room will delete the schema.\r\n\r\nHow can we achieve this with Realm. **.deleteRealmIfMigrationNeeded()**  is just dropping the database. It just ignores the migration.","comments":["I found different workarounds for this in **StackOverFlow**.\r\nBut I am gonna get the right way of doing it from the developers","Hi @Khudoyshukur \r\n\r\nWe don't have explicit support for it right now, but you could just catch the `RealmMigrationNeededException` and delete the file in that case, i.e. something like this:\r\n\r\n\r\n```\r\nval config = RealmConfiguration.Builder()\r\n  .schemaVersion(1)\r\n  .migration(MyMigration())\r\n  .build()\r\n\r\nval realm = try {\r\n    Realm.getInstance(config)\r\n} catch(ex: RealmMigrationNeededException) {\r\n    Realm.deleteRealm(config)\r\n    Realm.open(config)\r\n}\r\n```"],"labels":["O-Community"]},{"title":"Crash when changing dictionary nullability during migration","body":"### How frequently does the bug occur?\r\n\r\nAlways\r\n\r\n### Description\r\n\r\nI am unable to use app as it is crashing always.\r\nI have a migration function, in which I have a line which making realDictionary field required.\r\nAfter executing that line app is crashing\r\n`schema.setRequired(\"fieldName\", true)`\r\nInitially this RealmDictionary field was nullable.\r\n`var data: RealmDictionary<String> = RealmDictionary()`\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\n13:22:34.628 6804-6935\/compackage.name A\/libc: Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0 in tid 6935 (androidx.work-1), pid 6804\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nAlways\r\n\r\n### Reproduction Steps\r\n\r\n1. Have a class with variable type of RealmDictionary [nullable]\r\n2. Store some data into DB\r\n3. Write migration, and try to make this field REQUIRED\r\n\r\n### Version\r\n\r\n10.6.0\r\n\r\n### What Atlas App Services are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nYes\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 10+ [API 30+]\r\n\r\n### Build environment\r\n\r\nAndroid Studio Bumblebee | 2021.1.1 Patch 3\r\nBuild #AI-211.7628.21.2111.8309675, built on March 16, 2022\r\nRuntime version: 11.0.11+9-b60-7590822 amd64\r\nVM: OpenJDK 64-Bit Server VM by Oracle Corporation","comments":["Hi @RakeshPatil111. Thanks for the report. I am able to reproduce it and will investigate.","> Hi @RakeshPatil111. Thanks for the report. I am able to reproduce it and will investigate.\r\n\r\nThanks, hope we can find something.","It points out to be a core issue. I have created an issue in core to track this: https:\/\/github.com\/realm\/realm-core\/issues\/6408"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:On"]},{"title":"MissingLibraryException","body":"API level: '29'\r\nOS version: '10'\r\nABI list: 'arm64-v8a,armeabi-v7a,armeabi'\r\nManufacturer: 'samsung'\r\nBrand: 'samsung'\r\nModel: 'SM-G9600'\r\nBuild fingerprint: 'samsung\/starqltezc\/starqltechn:10\/QP1A.190711.020\/G9600ZCS9FVA4:user\/release-keys'\r\n\r\n\r\n\r\ninitializeRealm in Application#attachBaseContext \r\n\r\nSystem.err: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].\r\nSystem.err: \tat com.getkeepsafe.relinker.ApkLibraryInstaller.installLibrary(ApkLibraryInstaller.java:173)\r\nSystem.err: \tat com.getkeepsafe.relinker.ReLinkerInstance.loadLibraryInternal(ReLinkerInstance.java:180)\r\nSystem.err: \tat com.getkeepsafe.relinker.ReLinkerInstance.loadLibrary(ReLinkerInstance.java:136)\r\nSystem.err: \tat com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:70)\r\nSystem.err: \tat com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:57)\r\nSystem.err: \tat io.realm.internal.RealmCore.loadLibrary(RealmCore.java:60)\r\nSystem.err: \tat io.realm.Realm.initializeRealm(Realm.java:348)\r\nSystem.err: \tat io.realm.Realm.init(Realm.java:263)\r\n\r\nrealm version \r\n\r\nclasspath \"io.realm:realm-gradle-plugin:10.11.1\"\r\n\r\n\r\n\r\n\r\n\r\n","comments":["@yangyaoyao  where did you write this Realm.init(context). in Application or Activity?"],"labels":["O-Community"]},{"title":"Caused by j8.b: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].","body":"### How frequently does the bug occur?\n\nSometimes\n\n### Description\n\nCaused by j8.b: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].\r\n       at com.getkeepsafe.relinker.ApkLibraryInstaller.installLibrary(ApkLibraryInstaller.java:173)\r\n       at com.getkeepsafe.relinker.ReLinkerInstance.loadLibraryInternal(ReLinkerInstance.java:180)\r\n       at com.getkeepsafe.relinker.ReLinkerInstance.loadLibrary(ReLinkerInstance.java:136)\r\n       at com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:70)\r\n       at com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:57)\r\n       at io.realm.internal.RealmCore.loadLibrary(RealmCore.java:60)\r\n       at io.realm.Realm.initializeRealm(Realm.java:348)\r\n       at io.realm.Realm.init(Realm.java:263)\r\n       at com.globme.common.data.local.realm.LocalRealmDB.realConfiguration(LocalRealmDB.java:27)\r\n       at com.globme.timeware.application.Application.onCreate(Application.java:34)\r\n       at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1192)\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7233)\r\n       at android.app.ActivityThread.access$1700(ActivityThread.java:292)\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2172)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:255)\r\n       at android.app.ActivityThread.main(ActivityThread.java:8224)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:632)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1049)\n\n### Stacktrace & log output\n\n```shell\nCaused by j8.b: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].\r\n       at com.getkeepsafe.relinker.ApkLibraryInstaller.installLibrary(ApkLibraryInstaller.java:173)\r\n       at com.getkeepsafe.relinker.ReLinkerInstance.loadLibraryInternal(ReLinkerInstance.java:180)\r\n       at com.getkeepsafe.relinker.ReLinkerInstance.loadLibrary(ReLinkerInstance.java:136)\r\n       at com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:70)\r\n       at com.getkeepsafe.relinker.ReLinker.loadLibrary(ReLinker.java:57)\r\n       at io.realm.internal.RealmCore.loadLibrary(RealmCore.java:60)\r\n       at io.realm.Realm.initializeRealm(Realm.java:348)\r\n       at io.realm.Realm.init(Realm.java:263)\r\n       at com.globme.common.data.local.realm.LocalRealmDB.realConfiguration(LocalRealmDB.java:27)\r\n       at com.globme.timeware.application.Application.onCreate(Application.java:34)\r\n       at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1192)\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7233)\r\n       at android.app.ActivityThread.access$1700(ActivityThread.java:292)\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2172)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:255)\r\n       at android.app.ActivityThread.main(ActivityThread.java:8224)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:632)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1049)\n```\n\n\n### Can you reproduce the bug?\n\n-- select --\n\n### Reproduction Steps\n\n_No response_\n\n### Version\n\n10.13.2-transformer-api\n\n### What Atlas App Services are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo\n\n### Platform OS and version(s)\n\nAndroid 12\n\n### Build environment\n\nAndroid Studio version: Android Studio Electric Eel | 2022.1.1 Patch 1\r\nAndroid Build Tools version: Build #AI-221.6008.13.2211.9514443, built on January 21, 2023\r\nGradle version: gradle:7.4.1\r\n","comments":["Hi @adaonder \r\n\r\nWe have seen this happen in a few cases:\r\n\r\n- If you are using App Bundles and are using an APK that was copied from another device. This usually requires a rooted device.\r\n- If the app was downloaded from a 3rd party app store that didn't package the so files correctly (see above).\r\n- If you are running the app in an emulator that don't match exactly the architecture you are building for.\r\n\r\nAll of these things are unfortunately outside our control.\r\n\r\nIf you somehow are able to reproduce this, we would love to get the details.\r\n","Hi @cmelchior\r\n\r\nI think the source of the problem is app bundles(.aab). I download the app from Google Play Store. \r\nThe problem comes out like that, but it doesn't always happen. \r\nit happened on first install, i saw samsung galaxy s10 lite with android 12 once then i couldn't catch it again. \r\nI was using google room db now I am using real library. ","Hi @adaonder \r\nUnfortunately we can't help you with this unless you provide us with a way to reproduce the error. Please let us know if you find a way to do it.","Hi, we just started seeing this same issue today in our Crashlytics console.\r\nWe are using Realm 10.10.1 and have been for about a year now, but haven't seen this appear until today. We deploy our app using AABs, rather than APKs.\r\nSo far, it has only appeared on Android 8 and 10 devices. LGE Nexus 5X devices running Android 8.1 are most affected. No device this has occurred on is rooted.\r\n\r\nWe have not reproduced this issue ourselves, but I will provide more information as I am able to. Thanks.","This issue has been automatically closed because there has been no response to our request for more information from the original author. With only the information that is currently in the issue, we don't have enough information to take action. Please reach out if you have or find the answers we need so that we can investigate further.","@edualonso  this method Realm.init(context); I was getting it when I typed it in Application. Now I wrote it in Activity I no longer get this error.","I couldn't reproduce the issue by deploying an app bundle with Realm on a Samsung S9 (Android 10) and on a Samsung A70 (Android 11).","@clementetb \r\n\r\nI already saw it by chance once, it didn't happen yet. It was constantly coming up on firebase.","maybe there is a bug in android. But I first saw this error in your library. There was this error when the application was in the extended class. The command there is Realm.init().","@cmelchior, @clementetb,  You can close this thread if you want. because this error hasn't come yet since I changed my code.","Initializing the code in `Application` shouldn't be the issue.\r\n\r\n@adaonder On what callback were you invoking `Realm.init`, was it on `onCreate` or `attachBaseContext`?","@clementetb \r\n\r\nOld Code: \r\n\r\nclass Application extends MultiDexApplication ;\r\n\r\n`@Override\r\n    public void onCreate() {\r\n    \r\n        super.onCreate();\r\n        instance = this;\r\n        LocalRealmDB.getInstance().realConfiguration(getApplicationContext());\r\n        \r\n    }`\r\n    \r\n    \r\n    And\r\n    \r\n    LocalRealmDB class; \r\n    \r\n    `public static LocalRealmDB getInstance() {\r\n        return new LocalRealmDB();\r\n    }`\r\n    \r\n    `public void realConfiguration(Context context) {\r\n    \r\n        Realm.init(context);\r\n        \r\n        RealmConfiguration configuration = new RealmConfiguration.Builder().schemaVersion(SCHEMA_V_NOW).name(realmName).build()\r\n        \r\n        Realm.setDefaultConfiguration(configuration);\r\n        \r\n    }`\r\n    "],"labels":["T-Bug","O-Community","SDK-Use:Local","Encryption:Off","Frequency:Sometimes"]},{"title":"realm-annotation-processor-10.12.0 still dependent on kotlin-stdlib-1.5.31.jar","body":"I don't know it this is the correct place to post, but I couldn't find a dedicated realm annotation processor repository. \r\n\r\nAccording to Mend (previously WhiteSource), our native Android app containing Realm still has a dependency on kotlin-stdlib-1.5.31 because of the realm-annotation-processor-10.12.0. This is the latest version according to mvnrepository.com. This poses a medium security [vulnerability](https:\/\/www.mend.io\/vulnerability-database\/CVE-2022-24329), and should be updated to 1.6. \r\n\r\n\r\n\r\n\r\n","comments":["Thanks for reporting the issue, we will address the issue.","Thanks, we will bump in the next release, meanwhile, you can fix to a specific version on your project using the strict syntax. [See](https:\/\/docs.gradle.org\/current\/userguide\/rich_versions.html#sec:strict-version)"],"labels":["O-Community"]},{"title":"Allow consumers to prefer APT in Kotlin projects","body":"### Problem\r\n\r\nThere is currently no way to bypass the usage of kapt for Kotlin projects using Realm. The plugin's code has [a pending TODO comment](https:\/\/github.com\/realm\/realm-java\/blob\/master\/gradle-plugin\/src\/main\/groovy\/io\/realm\/gradle\/Realm.groovy#L48-L49) about allowing the configuration of this setting, but no way to actually control it. This prevents people from using tools like [NAPT](https:\/\/github.com\/sergei-lapin\/napt) for improving the build speed of their project. For instance, in my case, the only remaining library to rely on kapt is Realm and I'd like to move away from it to speed up compilations.\r\n\r\nUnfortunately, moving to realm-kotlin is not a realistic alternative because of the huge undertaking in migrating the codebase to support it.\r\n\r\n### Solution\r\n\r\nI'd like to request that a `preferAptOnKotlinProject` flag be added to its DSL of the Gradle plugin, with a default value of `false`.\r\n\r\n### Alternatives\r\n\r\n_No response_\r\n\r\n### How important is this improvement for you?\r\n\r\nI'd like to see it, but have a workaround","comments":["Hi @mannodermaus.\r\n\r\nHave you considered not applying the plugin and just manually doing what it does? Would that solve your problem? https:\/\/www.mongodb.com\/docs\/realm\/sdk\/java\/troubleshooting\/#customize-dependecies-defined-by-the-realm-gradle-plugin","Thanks for the suggestion @cmelchior, I wasn't aware that the full extent of the Gradle plugin could be so easily unwrapped. Skipping the Gradle plugin in favor of a manual setup as per the linked guide works well. I'm demoting the priority of the request to \"I'd like to see it, but have a workaround\" \ud83d\ude47\u200d\u2642\ufe0f"],"labels":["T-Enhancement","O-Community","Importance:Workaround"]},{"title":"RealmTransformer doesn't execute when running androidTest","body":"### How frequently does the bug occur?\n\nAll the time\n\n### Description\n\nIn order to avoid duplicating fake test data across `test` and `androidTest`, I have created a module `sharedtestcode` which depends on `app`. I then consume `sharedtestcode` as a test dependency of the `app` module via `testImplementation` and `androidTestImplementation`. \r\n\r\nThis is the recommended way to share test data starting from Android Studio Chipmunk. (see: https:\/\/issuetracker.google.com\/issues\/232420188)\r\n\r\nThis seems to work fine when running unit tests, but when I attempt to run an android test, I get:\r\n```\r\nRealmTransformer doesn't seem to be applied. Please update the project configuration to use the Realm Gradle plugin.\r\n```\n\n### Stacktrace & log output\n\n_No response_\n\n### Can you reproduce the bug?\n\nYes, always\n\n### Reproduction Steps\n\nDemo project: https:\/\/github.com\/danika\/RealmSharedTest\n\n### Version\n\n10.11.1\n\n### What SDK flavour are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid (SDK 31)\n\n### Build environment\n\nAndroid Studio version: Chipmunk 2021.2.1 Patch 2\r\nAndroid Build Tools version: 7.2.2\r\nGradle version: 7.3.3\r\n","comments":["Hi @danika. Thanks for the report. This seems like a duplicate of https:\/\/github.com\/realm\/realm-java\/pull\/3030 that originates from an issue around which classes that are passed to our transformer. The currently used transforer API of AGP has been undergoing development and will be removed from AGP 8.0, so the original reported [issue](https:\/\/issuetracker.google.com\/issues\/37115447) is left as obsolete. We are currently in the process of migrating to the new API in #7714 (specifically also [applying the transformer on unittest and test components](https:\/\/github.com\/realm\/realm-java\/pull\/7694\/commits\/bf97b43762772a5033e66ccc94154b46ca735696#diff-8a83f569e4ba752d608bc311fb6c94440f2ac17505def263dd62569ee0ec1d43R92)) and with this we should hopefully also address this ","hello again, I've updated the realm dependency in my [demo project](https:\/\/github.com\/danika\/RealmSharedTest) to `10.13.1-transformer-api` and the problem persists :(","same issue for me.","I can confirm that the issue is fixed with the following combo:\r\n\r\nAGP 8.0.0\r\nKotlin 1.8.20\r\nRealm 10.15.0\r\n\r\nthanks!"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:Off"]},{"title":"Opening a realm with initialSubscriptions while offline blocks its initialisation","body":"Opening a realm after having specified initialSubscriptions in the sync config while offline causes the initialisation to hang. We should be able to open a flexible sync enabled realm with subscriptions even if the device has no connectivity.","comments":["Yes I faced the similar issue. Is there any workaround ?","Hi @vikrantuk. Yes, there is. Calls to `Application.currentUser()` will return a valid user unless you log out once you are logged in. With this in mind you can assume your `SyncConfiguration` doesn't need to call `initialSubscriptions` since you should have already configured them when you logged in for the first time. This is the only viable workaround at the moment.","@edualonso Thanks for responding. The problem is I'm using async method getInstanceAsync(config) which expects config to be passed and it might cause the same issue as config passed to Realm.setDefaultConfig has entry of intialSubscription passed into it. \r\nPlease correct me if I'm wrong or misunderstood a thing or 2","You should change the way you initialise your `SyncConfiguration` to avoid calling `initialSubscriptions` if your user is logged in and you have previously configured initial subscriptions. Something along these lines:\r\n```\r\n\/\/ ...\r\nprivate void doStuff(User currentUser) {\r\n    SyncConfiguration syncConfig;\r\n\r\n    \/\/ Are we logged in?\r\n    if (currentUser == null) {\r\n        \/\/ log in and update your current user wherever you are storing it\r\n        User loggedInUser = login();\r\n\r\n        \/\/ first time creating the config: we are guaranteed to be online at this point so we need to add the initial subscriptions\r\n        syncConfig = createConfig(loggedInUser, false);\r\n    } else {\r\n        syncConfig = createConfig(currentUser, true);\r\n    }\r\n    openRealm(syncConfig);\r\n}\r\n\r\n\/**\r\n * @param user               current user.\r\n * @param previouslyLoggedIn if true means we have been online at some point, so no need to call 'initialSubscriptions' when creating the SyncConfiguration.\r\n *\/\r\nprivate SyncConfiguration createConfig(User user, boolean previouslyLoggedIn) {\r\n    SyncConfiguration.Builder builder = new SyncConfiguration.Builder(user);\r\n\r\n    \/\/ add subscriptions in case we were not logged in, otherwise don't do it and allow using preexisting subscriptions from a time when the app was open and phone was online\r\n    if (!previouslyLoggedIn) {\r\n        builder.initialSubscriptions(new SyncConfiguration.InitialFlexibleSyncSubscriptions() {\r\n            @Override\r\n            public void configure(Realm realm, MutableSubscriptionSet subscriptions) {\r\n                \/\/ add a subscription with a name\r\n                Subscription mySubscription = subscriptions.find(\"MySubscription\");\r\n\r\n                if (mySubscription == null) {\r\n                    RealmQuery subscriptionQuery = ...;\r\n                    subscriptions.add(Subscription.create(\"MySubscription\", subscriptionQuery));\r\n                }\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n    return builder.allowQueriesOnUiThread(true)\r\n            .allowWritesOnUiThread(true)\r\n            .build();\r\n}\r\n\r\n\/\/ ...\r\n```\r\nPlease observe this will not work if you have not added initial subscriptions before introducing this change. You must have been able to add these subscriptions at a prior point in time.","@edualonso Thanks.. I wasn't aware there is no need to set initialsubscriptions again. What I thought was running Realm.setDefaultConfig(config) again will overwrite the last set config and hence initialsubscription will also get wiped up. Thanks for the clarification :)\r\n","Also are there resources where these minute things are covered. I had no idea about this from the documentation ","Hi @vikrantuk.\r\n> Also are there resources where these minute things are covered. I had no idea about this from the documentation\r\n\r\nI'm afraid there aren't more resources than what's available in the official documentation. We will try to improve it to make it clearer in future modifications.","@edualonso Using your `avoid calling initialSubscriptions` doesn't work if I initialise Realm in next activity without initialSubscriptions. Got this error:\r\n\r\n```log\r\nConfigurations cannot be different if used to open the same file.\r\n\r\nCached configuration:\r\n\r\nrealmDirectory: \/data\/user\/0\/com.in\/files\/mongodb-realm\/application-0-vaocb\/65566a52ab8ce3e71ebdcf22\r\nrealmFileName : default.realm\r\ncanonicalPath: \/data\/user\/0\/com.in\/files\/mongodb-realm\/application-0-vaocb\/65566a52ab8ce3e71ebdcf22\/default.realm\r\nkey: [length: 0]\r\nschemaVersion: 0\r\nmigration: null\r\ndeleteRealmIfMigrationNeeded: false\r\ndurability: FULL\r\nschemaMediator: io.realm.DefaultRealmModuleMediator@41e1a0d\r\nreadOnly: false\r\ncompactOnLaunch: null\r\nmaxNumberOfActiveVersions: 9223372036854775807\r\nserverUrl: wss:\/\/realm.mongodb.com\/\r\nuser: io.realm.mongodb.User@346e449f\r\nerrorHandler: io.realm.mongodb.AppConfiguration$Builder$1@32b3670\r\ninitialSubscriptions: com.in.HomeActivity$1$1@2b60fa5\r\ndeleteRealmOnLogout: false\r\nsyncClientValidateSsl: true\r\nserverCertificateAssetName: null\r\nserverCertificateFilePath: null\r\nwaitForInitialData: false\r\ninitialDataTimeoutMillis: 9223372036854775807\r\nsessionStopPolicy: AFTER_CHANGES_UPLOADED\r\nsyncUrlPrefix: \/api\/client\/v2.0\/app\/application-0-vaocb\/realm-sync\r\npartitionValue: null\r\n\r\nNew configuration: \r\n\r\nrealmDirectory: \/data\/user\/0\/com.in\/files\/mongodb-realm\/application-0-vaocb\/65566a52ab8ce3e71ebdcf22\r\nrealmFileName : default.realm\r\ncanonicalPath: \/data\/user\/0\/com.in\/files\/mongodb-realm\/application-0-vaocb\/65566a52ab8ce3e71ebdcf22\/default.realm\r\nkey: [length: 0]\r\nschemaVersion: 0\r\nmigration: null\r\ndeleteRealmIfMigrationNeeded: false\r\ndurability: FULL\r\nschemaMediator: io.realm.DefaultRealmModuleMediator@41e1a0d\r\nreadOnly: false\r\ncompactOnLaunch: null\r\nmaxNumberOfActiveVersions: 9223372036854775807\r\nserverUrl: wss:\/\/realm.mongodb.com\/\r\nuser: io.realm.mongodb.User@346e449f\r\nerrorHandler: io.realm.mongodb.AppConfiguration$Builder$1@32b3670\r\ninitialSubscriptions: null\r\ndeleteRealmOnLogout: false\r\nsyncClientValidateSsl: true\r\nserverCertificateAssetName: null\r\nserverCertificateFilePath: null\r\nwaitForInitialData: false\r\ninitialDataTimeoutMillis: 9223372036854775807\r\nsessionStopPolicy: AFTER_CHANGES_UPLOADED\r\nsyncUrlPrefix: \/api\/client\/v2.0\/app\/application-0-vaocb\/realm-sync\r\npartitionValue: null\r\n```"],"labels":["T-Bug"]},{"title":"where in throws : Unsupported comparison between type 'uuid' and type 'string'","body":"### Problem\r\n\r\nI have UUID as primary key in my class \r\n\r\nI want to make this query: \r\n\r\nUUID[] values = new UUID[]{\r\n                UUID.fromString(key1)\r\n        };\r\nquery.in(\"uuid_field\" ,  values);\r\n\r\nexception will thrown : Unsupported comparison between type 'uuid' and type 'string'\r\n\r\nhow can i acheive that ?\r\n\r\nJAVA - android studio , realm DB\r\n### Solution\r\n\r\n_No response_\r\n\r\n### Alternatives\r\n\r\n_No response_\r\n\r\n### How important is this improvement for you?\r\n\r\nI'd like to see it, but have a workaround","comments":["Hi @amer-zk. There is currently no way to use `in` with non-primitive types, so you would have to build the query manually with something like \r\n\r\n```\r\nRealmQuery<...> query = realm.where(....).beginGroup();\r\nBoolean first = true;\r\nfor (UUID uuid : uuids) {\r\n    if (first) {\r\n        first = false;\r\n    } else {\r\n        query.or();\r\n    }\r\n    query.equalTo(\"uuid_field\", uuid);\r\n}\r\nquery.endGroup();\r\n```","> Hi @amer-zk. There is currently no way to use `in` with non-primitive types, so you would have to build the query manually with something like\r\n> \r\n> ```\r\n> RealmQuery<...> query = realm.where(....).beginGroup();\r\n> Boolean first = true;\r\n> for (UUID uuid : uuids) {\r\n>     if (first) {\r\n>         first = false;\r\n>     } else {\r\n>         query.or();\r\n>     }\r\n>     query.equalTo(\"uuid_field\", uuid);\r\n> }\r\n> query.endGroup();\r\n> ```\r\n\r\ni think thats will lead to performance issue ! it must be optimized to excute without loops!","We just recently added support for querying with multiple values in the underlying core implementation but haven't adopted this in the SDK yet. We are currently focusing on getting features into the Realm Kotlin SDK so you can track the adoption of this in https:\/\/github.com\/realm\/realm-kotlin\/issues\/929. To fully cover your use case we would also need support for type coercion as part of the query engine. That will most probably be handled as part of https:\/\/github.com\/realm\/realm-kotlin\/issues\/587."],"labels":["T-Enhancement","O-Community","gathering-interest","Importance:Workaround"]},{"title":"[DO NOT MERGE] manual release to maven central","body":"This is a template PR of how you can replay a release build to bypass the checks of tests, tags etc and only publish the artifacts into maven central.\r\n\r\nThis originally was motivated by a successful release job but an incomplete upload of artefacts into the staging repository in SOnatype\/Maven. The idea is to disable part of some of the checks and steps in the publish script as well as some unnecessary Jenkins stages (slack notification, tests etc).","comments":[],"labels":["cla: yes"]},{"title":"Unrecoverable error. No such table exists Exception backtrace: <backtrace not supported on this platform> in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107","body":"### How frequently does the bug occur?\n\nSometimes\n\n### Description\n\nAndroid app with latest realm (10.10.1) crashes with the error mentioned in the stack trace provided by Firebase Crashlytics.  \r\nAccording to Firebase, the crash occurs for case when device is trying to update widget.\r\nCant reproduce on my device (Pixel 2XL, emulator).\r\nAccording to stack-trace, the crash is occurring on this line:\r\n\r\n`Realm realm = Realm.getDefaultInstance())`\r\n\r\nDetails from Firebase:\r\n\r\nin background(96%),\r\n\r\nAndroid versions:\r\nAndroid 10 - 94%\r\n\r\nDevices:\r\nHuawei - 94%\r\n\r\nLet me know if additional details are required\r\n\r\n<img width=\"1275\" alt=\"Screenshot 2022-05-16 at 13 12 42\" src=\"https:\/\/user-images.githubusercontent.com\/555572\/168570910-145d0cea-46bf-49c4-a6e7-003bc8fe61ca.png\">\r\n\r\n\r\n\n\n### Stacktrace & log output\n\n```shell\nio.realm.internal.OsSharedRealm.nativeGetSharedRealm (OsSharedRealm.java)\r\nio.realm.internal.OsSharedRealm.<init> (OsSharedRealm.java:176)\r\nio.realm.internal.OsSharedRealm.getInstance (OsSharedRealm.java:261)\r\nio.realm.BaseRealm.<init> (BaseRealm.java:143)\r\nio.realm.BaseRealm.<init> (BaseRealm.java:110)\r\nio.realm.Realm.<init> (Realm.java:159)\r\nio.realm.Realm.createInstance (Realm.java:506)\r\nio.realm.RealmCache.createInstance (RealmCache.java:508)\r\nio.realm.RealmCache.doCreateRealmOrGetFromCache (RealmCache.java:461)\r\nio.realm.RealmCache.createRealmOrGetFromCache (RealmCache.java:422)\r\nio.realm.Realm.getDefaultInstance (Realm.java:414)\r\n<my.app.package>.MainService.updateWidgetValues (MainService.java:202)\r\nandroidx.core.app.WakefulIntentService.onHandleWork (WakefulIntentService.java:79)\r\nandroidx.core.app.JobIntentService$CommandProcessor.doInBackground (JobIntentService.java:396)\r\nandroidx.core.app.JobIntentService$CommandProcessor.doInBackground (JobIntentService.java:387)\r\nandroid.os.AsyncTask$3.call (AsyncTask.java:378)\r\njava.util.concurrent.FutureTask.run (FutureTask.java:266)\r\njava.util.concurrent.ThreadPoolExecutor.processTask (ThreadPoolExecutor.java:1187)\r\njava.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1152)\r\njava.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:641)\r\njava.lang.Thread.run (Thread.java:929)\n```\n\n\n### Can you reproduce the bug?\n\nNot yet\n\n### Reproduction Steps\n\n_No response_\n\n### Version\n\nio.realm:realm-gradle-plugin:10.10.1\n\n### What SDK flavour are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid 10\n\n### Build environment\n\nAndroid Studio version: 2021.2.1\r\nAndroid Build Tools version: 32.0.0\r\nGradle version: 7.1.2\r\n","comments":["\u27a4 Clemente Tort Barbero commented:\n\nIs this still an issue?","Still an issue\r\nfor last 30 days (Jun 12 - Jul 11, 2022)\r\nThis issue has 5033 crash events affecting 377 users\r\n<img width=\"1034\" alt=\"Screenshot 2022-07-11 at 11 08 14\" src=\"https:\/\/user-images.githubusercontent.com\/555572\/178218634-06c3eb24-a657-4c14-b44b-aa5eaa0abdde.png\">\r\n\r\n","@svyd there isn't much we can do with the information you provide us as calling `Realm.getDefaultInstance()` alone doesn't give us much information. Make sure you have a reproduction case where you specify the configuration you have for your realm (using encryption, migrations, etc.) or even better, share a sample repository with said reproduction case.","@edualonso We are also observing the same issue but unfortunately don't have repro steps.\r\n\r\n<img width=\"1287\" alt=\"Screenshot 2022-07-23 at 8 11 26 AM\" src=\"https:\/\/user-images.githubusercontent.com\/11852236\/180587644-f3bc14aa-b675-404f-bacf-cc4c33099388.png\">\r\n ","@svyd @dhanesh007 Any of you that has been able to gather more information about this issue?","Closing due to inactivity.","I'd like to follow up on this issue as it still persists. @edualonso are you able to tell what can cause this error to occur in `Realm.getDefaultInstance()`? As we are not querying a specific table, just getting the default instance of Realm I think it would help us to better investigate if we knew what can cause Realm to throw this specific error","\u6211\u4e5f\u9047\u5230\u4e86\u8fd9\u4e2a\u95ee\u9898 \u6211\u7684\u7248\u672c\u662f  classpath \"io.realm:realm-gradle-plugin:10.0.1\"\r\n\u590d\u73b0\u6b65\u9aa4\uff1a\u53ea\u8981\u6dfb\u52a0\u7cfb\u7edf\u6743\u9650\u5c31\u4f1a\u5d29\u6e83\r\n2023-03-09 18:01:47.844 10436-10436\/com.jc.scale E\/CrashReport: io.realm.exceptions.RealmError: Unrecoverable error. Permission denied in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n        at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(Native Method)\r\n        at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:175)\r\n        at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:251)\r\n        at io.realm.BaseRealm.<init>(BaseRealm.java:137)\r\n        at io.realm.BaseRealm.<init>(BaseRealm.java:104)\r\n        at io.realm.Realm.<init>(Realm.java:163)\r\n        at io.realm.Realm.createInstance(Realm.java:499)\r\n        at io.realm.RealmCache.createInstance(RealmCache.java:507)\r\n        at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:473)\r\n        at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:414)\r\n        at io.realm.Realm.getDefaultInstance(Realm.java:407)\r\n        at com.jc.scale.App.onCreate(App.java:109)\r\n        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1211)\r\n        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6765)\r\n        at android.app.ActivityThread.access$1600(ActivityThread.java:253)\r\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2090)\r\n        at android.os.Handler.dispatchMessage(Handler.java:106)\r\n        at android.os.Looper.loopOnce(Looper.java:201)\r\n        at android.os.Looper.loop(Looper.java:288)\r\n        at android.app.ActivityThread.main(ActivityThread.java:7881)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:568)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1045)\r\n","We're running into the same crash on Realm: `io.realm:realm-gradle-plugin:10.11.1`. This started happening on our latest release and has only impacted one user so far but we have only rolled out to a small number of users. The crash happens on App launch after calling `Realm.getInstance(config)` in the function below.\r\n\r\nInside our Application.onCreate() we're calling `initRealm` with the Application context:\r\n\r\n```\r\nprivate val baseConfig: RealmConfiguration\r\n    get() = RealmConfiguration.Builder()\r\n        .name(Constants.REALM_STORE_NAME)\r\n        .build()\r\n\r\n\r\nprivate fun initRealm(context: Context) {\r\n    Realm.init(context)\r\n\r\n    val config: RealmConfiguration = try {\r\n        RealmConfiguration.Builder()\r\n            .name(Constants.REALM_STORE_NAME)\r\n            .schemaVersion(REALM_VERSION.toLong())\r\n            .migration(Migration())\r\n            .build()\r\n    } catch (e: Exception) {\r\n        baseConfig\r\n    }\r\n\r\n    storeRealm = try {\r\n        Realm.getInstance(config)\r\n    } catch (ex: RealmMigrationNeededException) {\r\n        Realm.deleteRealm(config)\r\n        Realm.getInstance(config)\r\n    } catch (ex: Exception) {\r\n        throw ex\r\n    }\r\n}\r\n```\r\n\r\nThe crash happened on a Moto G Stylus 5G (2022) running Android 12. We have not been able to reproduce so far.\r\n\r\nWe're using the local database only. \r\n\r\nAndroid Studio version: Android Studio Flamingo | 2022.2.1\r\nAndroid Build Tools version: 33\r\nGradle version: 7.5.1\r\n\r\nStack trace of crash:\r\n\r\n```\r\nFatal Exception: io.realm.exceptions.RealmError: Unrecoverable error. No such table exists\r\nException backtrace:\r\n<backtrace not supported on this platform> in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n       at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java)\r\n       at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:174)\r\n       at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:259)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:142)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:109)\r\n       at io.realm.Realm.<init>(Realm.java:161)\r\n       at io.realm.Realm.createInstance(Realm.java:535)\r\n       at io.realm.RealmCache.createInstance(RealmCache.java:508)\r\n       at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:461)\r\n       at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422)\r\n       at io.realm.Realm.getInstance(Realm.java:464)\r\n       at com.our.app.data.db.DataStore.initRealm(DataStore.kt:87)\r\n       at com.our.app.data.db.DataStore.<init>(DataStore.kt:59)\r\n       at com.our.app.data.db.DataStore.<init>(DataStore.kt:55)\r\n       at com.our.app.data.db.DataStore$Companion.init(DataStore.kt:24)\r\n       at com.our.app.application.OurApp.onCreate(KslClassifiedsApplication.kt:131)\r\n       at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1213)\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6906)\r\n       at android.app.ActivityThread.access$1600(ActivityThread.java:261)\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2154)\r\n       at android.os.Handler.dispatchMessage(Handler.java:111)\r\n       at android.os.Looper.loopOnce(Looper.java:238)\r\n       at android.os.Looper.loop(Looper.java:357)\r\n       at android.app.ActivityThread.main(ActivityThread.java:8089)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1026)\r\n```\r\n\r\nOur `Migration` class is structured like so:\r\n\r\n```\r\nclass Migration: RealmMigration {\r\n    override fun hashCode(): Int {\r\n        return REALM_VERSION\r\n    }\r\n\r\n    override fun equals(other: Any?): Boolean {\r\n        return other is Migration\r\n    }\r\n\r\n    override fun migrate(realm: DynamicRealm, oldVersion: Long, newVersion: Long) {\r\n        val schema = realm.schema\r\n        var version = oldVersion\r\n\r\n        \/\/ First migration, add sort column to SavedSearch\r\n        if (version == 0L) {\r\n            schema[\"SavedSearch\"]?.addField(\"sortKey\", String::class.java)\r\n            version++\r\n        }\r\n        if (version == 1L) {\r\n            schema.create(\"LocationSearchItem\")\r\n                .addField(\"zip\", String::class.java, FieldAttribute.PRIMARY_KEY)\r\n                .addField(\"id\", String::class.java)\r\n                .addField(\"name\", String::class.java)\r\n                .addField(\"label\", String::class.java)\r\n                .addField(\"latitude\", String::class.java)\r\n                .addField(\"longitude\", String::class.java)\r\n                .addField(\"searchDate\", Date::class.java)\r\n            version++\r\n        }\r\n    ...\r\n```\r\n\r\n@rorbech If any additional info would be helpful, let me know. I'll update if we're able to reproduce.\r\n","@starchey Thanks for the feedback. There are number of code paths that could lead to this, but I can't really figure out which one that is triggered from you input. Do you by chance have any insights in whether this happens once when running the migration, first installation or sometime later out of the blue?","> @starchey Thanks for the feedback. There are number of code paths that could lead to this, but I can't really figure out which one that is triggered from you input. Do you by chance have any insights in whether this happens once when running the migration, first installation or sometime later out of the blue?\r\n\r\nI'm not sure whether it happens on first install or on a migration. All I can tell from the trace is when it happens, it happens on launch. 94% of the crashes happened on Motorola devices which make up a small percent of a user-base (majority of those on a Moto G Stylus 5G).","Facing same issue. Repetitive crash in crashlytics. If anyone got the solution, please help here.\r\n<img width=\"1138\" alt=\"Screenshot 2024-03-11 at 1 05 49\u202fPM\" src=\"https:\/\/github.com\/realm\/realm-java\/assets\/162962236\/8a9f9ccd-bd29-4d79-af88-fb0aec98038c\">\r\n"],"labels":["T-Bug","Reproduction-Required","O-Community","Waiting-For-Reporter"]},{"title":"Public field name not available on Flexible sync queries","body":"### How frequently does the bug occur?\n\nAll the time\n\n### Description\n\nIf both public and private name are defined on a field, the public one cannot is not available to define Flexible sync queries.\n\n### Stacktrace & log output\n\n_No response_\n\n### Can you reproduce the bug?\n\nYes, always\n\n### Reproduction Steps\n\n1. Define a model with a field that has an internal and public name.\r\n2. Try to define a Flexible sync query that filters by the public field name.\r\n3. Throw error as the public name is not available.\n\n### Version\n\n10.10.1\n\n### What SDK flavour are you using?\n\nMongoDB Realm (i.e. Sync, auth, functions)\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid12\n\n### Build environment\n\nAndroid Studio version: ...\r\nAndroid Build Tools version: ...\r\nGradle version: ...\r\n","comments":[],"labels":["T-Bug"]},{"title":"Notifications not working properly on Flexible sync","body":"### How frequently does the bug occur?\n\nAll the time\n\n### Description\n\n`RealmResults` change listener does not trigger on remote changes for objects filtered by Flexible sync.\r\n\r\n\n\n### Stacktrace & log output\n\n_No response_\n\n### Can you reproduce the bug?\n\nYes, always\n\n### Reproduction Steps\n\nUsing the following project:\r\n\r\nhttps:\/\/github.com\/realm\/flexible-sync-team-floggie\r\n\r\nThe game list does not react to games created by the admin:\n\n### Version\n\n10.10.1\n\n### What SDK flavour are you using?\n\nMongoDB Realm (i.e. Sync, auth, functions)\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid12\n\n### Build environment\n\nAndroid Studio version: ...\r\nAndroid Build Tools version: ...\r\nGradle version: ...\r\n","comments":["It was an app issue","I run into some issues here as well, I suspect we do have some things that can be improved","Closed because I thought it was an app issue, reopening because I was able to reproduce it again.","Any news on this bug? I have same issue on Poco F3 Android 12, but can't reproduce on Android emulator."],"labels":["T-Bug","Reproduction-Required"]},{"title":"Crash with Flexible sync","body":"### How frequently does the bug occur?\nSometimes\n\n### Description\nWhile developing with Flexible sync I run into this crash. It happens after reinstalling the app several times during development. Clearing the app data fixes the issue.\n\n### Stacktrace & log output\nSee attached txt file. Character limits in Jira prevent us from adding the full stacktrace.\n\n","comments":[],"labels":["T-Bug","Reproduction-Required"]},{"title":"Flexible Sync subscription silently fails and reported on wrong callback","body":"### How frequently does the bug occur?\n\nAll the time\n\n### Description\n\nWhen adding a dynamic subscription if the query includes the keyword `CONTAINS` the subscription fails, the user has no clue why the data is not synced unless he register a `StateChangeCallback`  like the following \r\n```Kotlin \r\nrealm.subscriptions.update {...}.waitForSynchronizationAsync(object: SubscriptionSet.StateChangeCallback {\r\n                            override fun onStateChange(subscriptions: SubscriptionSet) {\r\n                                println(\">>>>>>>>>>>>> subscriptions state changed ${subscriptions.state}\")\r\n                            }\r\n\r\n                            override fun onError(e: Throwable) {\r\n                                println(\">>>>>>>>>>>>>>>>>>> SUB error: $e\")\r\n                            }\r\n\r\n                        }\r\n```\r\nHowever in our case instead of reporting the error \r\n```\r\nClient provided query with bad syntax: unsupported query for table \"Book\": CONTAINS is not yet supported in server-side queries\r\n```\r\non the `onError` callback it is reported as a state change via `onStateChange` with `State.ERROR` then the user has to pull the error via `getErrorMessage().` which makes overriding `onError` useless\/misleading \n\n### Stacktrace & log output\n\n_No response_\n\n### Can you reproduce the bug?\n\nYes, always\n\n### Reproduction Steps\n\n_No response_\n\n### Version\n\n10.10.1\n\n### What SDK flavour are you using?\n\nMongoDB Realm (i.e. Sync, auth, functions)\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid API29 x86_64\n\n### Build environment\n\n_No response_","comments":[],"labels":["T-Bug"]},{"title":"Flexible Sync initialSubscriptions should run the first time only ","body":"### How frequently does the bug occur?\n\nAll the time\n\n### Description\n\n`initialSubscriptions` block runs on the subsequent starts of the App which causes the subscriptions to be added which throws \r\n\r\n```Kotlin\r\n        app.loginAsync(Credentials.anonymous()) {\r\n            if (it.isSuccess)  {\r\n                user = it.get()\r\n                val config = SyncConfiguration.Builder(user)\r\n                    .initialSubscriptions { realm, subscriptions ->\r\n\r\n                        subscriptions.add(\r\n                            Subscription.create(\r\n                                \"My Bookshelf\",\r\n                                realm.where(Bookshelf::class.java)\r\n                            )\r\n                        )\r\n\r\n                        subscriptions.add(\r\n                            Subscription.create(\r\n                                \"All Book\",\r\n                                realm.where(Book::class.java)\r\n                            )\r\n                        )\r\n\r\n                        subscriptions.add(\r\n                            Subscription.create(\r\n                                \"All Authors\",\r\n                                realm.where(Author::class.java)\r\n                            )\r\n                        )\r\n                        subscriptions.add(\r\n                            Subscription.create(\r\n                                \"All UserBook\",\r\n                                realm.where(UserBook::class.java)\r\n                            )\r\n                        )\r\n                    }\r\n                    .waitForInitialRemoteData()\r\n                    .build()\r\n                Realm.getInstanceAsync(config, object : Callback() {\r\n                    override fun onSuccess(syncRealm: Realm) {\r\n                        realm = syncRealm\r\n                        _isSyncReady.value = true\r\n                   }})\r\n\r\n```\r\n\n\n### Stacktrace & log output\n\n```shell\n03-10 21:34:07.580 13996 14040 E REALM_JNI: jni: ThrowingException 1, Subscription could not be added because it already existed, .\r\n03-10 21:34:07.580 13996 14040 E REALM_JNI: Exception has been thrown: Illegal Argument: Subscription could not be added because it already existed\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: java.lang.IllegalArgumentException: Illegal Argument: Subscription could not be added because it already existed\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.objectstore.OsMutableSubscriptionSet.nativeInsertOrAssign(Native Method)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.objectstore.OsMutableSubscriptionSet.addSubscription(OsMutableSubscriptionSet.java:49)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.objectstore.OsMutableSubscriptionSet.add(OsMutableSubscriptionSet.java:38)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.example.bookshelf.RealmDatabase.init$lambda-1$lambda-0(RealmDatabase.kt:89)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.example.bookshelf.RealmDatabase.$r8$lambda$pPIJyIDfcis7MGgVcDWegtLQiQA(Unknown Source:0)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.example.bookshelf.RealmDatabase$$ExternalSyntheticLambda1.configure(Unknown Source:0)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.SyncObjectServerFacade$1.update(SyncObjectServerFacade.java:304)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.objectstore.OsSubscriptionSet.update(OsSubscriptionSet.java:178)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.SyncObjectServerFacade.downloadInitialFlexibleSyncData(SyncObjectServerFacade.java:301)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:473)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.RealmCache$CreateRealmRunnable.run(RealmCache.java:249)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat io.realm.internal.async.BgPriorityRunnable.run(BgPriorityRunnable.java:34)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:462)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: \tat java.lang.Thread.run(Thread.java:919)\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA:\r\n03-10 21:34:07.586 13996 14040 E REALM_JAVA: `CreateRealmRunnable` failed.\r\n03-10 21:34:07.697 13996 13996 D AndroidRuntime: Shutting down VM\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: FATAL EXCEPTION: main\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: Process: io.realm.example.bookshelf, PID: 13996\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: io.realm.exceptions.RealmException: Exception happens when initializing Realm in the background thread.\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.BaseRealm$InstanceCallback.onError(BaseRealm.java:1058)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.Realm$Callback.onError(Realm.java:2061)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.RealmCache$CreateRealmRunnable$2.run(RealmCache.java:303)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat android.os.Handler.handleCallback(Handler.java:883)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat android.os.Handler.dispatchMessage(Handler.java:100)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat android.os.Looper.loop(Looper.java:214)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat android.app.ActivityThread.main(ActivityThread.java:7356)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat java.lang.reflect.Method.invoke(Native Method)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: Caused by: java.lang.IllegalArgumentException: Illegal Argument: Subscription could not be added because it already existed\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.objectstore.OsMutableSubscriptionSet.nativeInsertOrAssign(Native Method)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.objectstore.OsMutableSubscriptionSet.addSubscription(OsMutableSubscriptionSet.java:49)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.objectstore.OsMutableSubscriptionSet.add(OsMutableSubscriptionSet.java:38)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.example.bookshelf.RealmDatabase.init$lambda-1$lambda-0(RealmDatabase.kt:89)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.example.bookshelf.RealmDatabase.$r8$lambda$pPIJyIDfcis7MGgVcDWegtLQiQA(Unknown Source:0)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.example.bookshelf.RealmDatabase$$ExternalSyntheticLambda1.configure(Unknown Source:0)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.SyncObjectServerFacade$1.update(SyncObjectServerFacade.java:304)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.objectstore.OsSubscriptionSet.update(OsSubscriptionSet.java:178)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.SyncObjectServerFacade.downloadInitialFlexibleSyncData(SyncObjectServerFacade.java:301)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:473)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.RealmCache$CreateRealmRunnable.run(RealmCache.java:249)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat io.realm.internal.async.BgPriorityRunnable.run(BgPriorityRunnable.java:34)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:462)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n03-10 21:34:07.699 13996 13996 E AndroidRuntime: \tat java.lang.Thread.run(Thread.java:919)\r\n03-10 21:34:07.699 13159 13159 I GoogleInputMethodService: GoogleInputMethodService.onFinishInput():3210\r\n03-10 21:34:07.700 13996 14036 I OpenGLRenderer: Davey! duration=1023ms; Flags=0, IntendedVsync=155469373454252, Vsync=155470140120888, OldestInputEvent=9223372036854775807, NewestInputEvent=0, HandleInputStart=155470149052428, AnimationStart=155470149109428, PerformTraversalsStart=155470357014428, DrawStart=155470382723428, SyncQueued=155470390499428, SyncStart=155470390777428, IssueDrawCommandsStart=155470390847428, SwapBuffers=155470391936428, FrameCompleted=155470397143428, DequeueBufferDur\n```\n\n\n### Can you reproduce the bug?\n\nYes, always\n\n### Reproduction Steps\n\n_No response_\n\n### Version\n\n10.10.1\n\n### What SDK flavour are you using?\n\nMongoDB Realm (i.e. Sync, auth, functions)\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid API29 x86_64\n\n### Build environment\n\n_No response_","comments":["I ran into this issue too. The workaround that seems to work for me is to use `subscriptions.addOrUpdate(...)` instead of `subscriptions.add(...)`. ","`subscriptions.addOrUpdate(...)` is this the official method?","On furthur reading\/testing, it seems that `subscriptions.addOrUpdate(...)` is not a usable workaround. It doesn't work when the device is offline and in blocks the initialization of the `Realm.getInstance()`\r\n\r\nSo issue still persists."],"labels":["T-Bug"]},{"title":"Explore Instant Apps support","body":null,"comments":[],"labels":["cla: yes"]},{"title":"Orphan removal during migration to embedded Objects","body":"### How frequently does the bug occur?\r\n\r\nSometimes\r\n\r\n### Description\r\n\r\nWe do a migration to embedded objects, and to do this we remove all orphans with the `transform` function, it works well until we notice that on some devices, we receive this exception `At least one object in 'class_Rights' does not have a backlink (data would get lost).`\r\nWouldn't the `transform` function process all files in some cases? Or is the error due to something else? \r\n\r\nI've done a lot of tests without ever succeeding in reproducing it, but we do have customers with this problem, although it's a minority.\r\n\r\n**Here is our migration code:**\r\n```kotlin\r\nschema.get(Rights::class.java.simpleName)?.transform { \/\/ apply for each right\r\n    val fileId = it.getInt(\"fileId\")\r\n    val file = realm.where(File::class.java.simpleName).equalTo(File::id.name, fileId).findFirst()\r\n    if (file == null) it.deleteFromRealm() \/\/ Delete if it's orphan\r\n}?.apply {\r\n    removePrimaryKey()\r\n    removeField(\"fileId\")\r\n    isEmbedded = true\r\n}\r\n```\r\n>A right is orphaned simply if there are no more files associated with it.\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\njava.lang.IllegalStateException: At least one object in 'class_Rights' does not have a backlink (data would get lost).\r\n    at io.realm.internal.Table.nativeSetEmbedded(Table.java)\r\n    at io.realm.internal.Table.setEmbedded(Table.java:796)\r\n    at io.realm.RealmObjectSchema.setEmbedded(RealmObjectSchema.java:595)\r\n    at com.infomaniak.drive.data.cache.FileMigration.migrate(FileMigration.kt:86)\r\n    at io.realm.BaseRealm$6.onMigrationNeeded(BaseRealm.java:867)\r\n    at io.realm.internal.OsSharedRealm.runMigrationCallback(OsSharedRealm.java:561)\r\n    at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java)\r\n    at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:175)\r\n    at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:251)\r\n    at io.realm.BaseRealm.<init>(BaseRealm.java:141)\r\n    at io.realm.BaseRealm.<init>(BaseRealm.java:108)\r\n    at io.realm.Realm.<init>(Realm.java:159)\r\n    at io.realm.Realm.createInstance(Realm.java:495)\r\n    at io.realm.RealmCache.createInstance(RealmCache.java:494)\r\n    at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:461)\r\n    at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422)\r\n    at io.realm.Realm.getInstance(Realm.java:424)\r\n    at com.infomaniak.drive.data.cache.FileController.getRealmInstance(FileController.kt:312)\r\n    at com.infomaniak.drive.utils.SyncOfflineUtils.startSyncOffline(SyncOfflineUtils.kt:44)\r\n    at com.infomaniak.drive.ui.MainViewModel$syncOfflineFiles$2.invoke(MainViewModel.kt:268)\r\n    at com.infomaniak.drive.ui.MainViewModel$syncOfflineFiles$2.invoke(MainViewModel.kt:267)\r\n    at kotlinx.coroutines.InterruptibleKt.runInterruptibleInExpectedContext(Interruptible.kt:46)\r\n    at kotlinx.coroutines.InterruptibleKt.access$runInterruptibleInExpectedContext(Interruptible.kt:1)\r\n    at kotlinx.coroutines.InterruptibleKt$runInterruptible$2.invokeSuspend(Interruptible.kt:38)\r\n    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\r\n    at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)\r\n    at kotlinx.coroutines.internal.LimitedDispatcher.run(LimitedDispatcher.kt:39)\r\n    at kotlinx.coroutines.scheduling.TaskImpl.run(Tasks.kt:95)\r\n    at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:571)\r\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:750)\r\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:678)\r\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:665)\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nNot yet\r\n\r\n### Reproduction Steps\r\n\r\n_No response_\r\n\r\n### Version\r\n\r\n10.8.0\r\n\r\n### What SDK flavour are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nNo, not using encryption\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 9\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: Android Studio Bumblebee | 2021.1.1\r\nAndroid Build Tools version: ...\r\nGradle version: gradle-7.1.1\r\n","comments":["Hi @sirambd \r\n\r\nYes, the `transform` method should iterate all objects, but looking at the source code for it, I noticed that we might have a bug there if you delete the object being transformed (as in it might accidentally skip the next object).\r\n\r\nI will look more into this and post an update.","@cmelchior Ok thank you, I will wait for your return"],"labels":["T-Bug","Reproduction-Required","O-Community","SDK-Use:Local","Encryption:Off","Frequency:Sometimes","Repro:No"]},{"title":"Support for Android Instant Apps with Android App Bundle.","body":"### How frequently does the bug occur?\r\n\r\nAll the time\r\n\r\n### Description\r\n\r\nWhen I use the Instant App of my application which is distributed through Google Play, I am getting  this error while I tried to use a realm operation to wait for synchronization between Realm and Mongo db or doing an insert operation like:\r\n\r\n\r\n```\r\noverride suspend fun upsertPartial(key: String, value: String?): ObjectId {\r\n        var objectId: ObjectId? = null\r\n        val insertedValue: PartialEntity? = this.getPartialByKey(key)\r\n        val realm: Realm = Realm.getDefaultInstance()\r\n        realm.executeTransactionAwait(this.dispatcher) {\r\n            objectId = insertedValue?.partialId ?: ObjectId()\r\n            val partialEntity = PartialEntity(\r\n                partialId = objectId!!,\r\n                partitionKey = this.invitationPartitionKey,\r\n                invitationId = this.invitationId,\r\n                key = key,\r\n                value = value\r\n            )\r\n\r\n\/\/ ERROR\r\n            realm.insertOrUpdate(partialEntity)\r\n        }\r\n\r\n        realm.close()\r\n\r\n        return objectId!!\r\n    }\r\n```\r\n\r\nINSTALLED VERSION OF THE APP DOESN'T THROW THIS ERROR!\r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\n2022-02-03 13:15:28.639 18543-18823\/? E\/REALM_JNI: jni: ThrowingException 7, Permission denied in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107, .\r\n2022-02-03 13:15:28.640 18543-18823\/? E\/REALM_JNI: Exception has been thrown: Permission denied in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nYes, always\r\n\r\n### Reproduction Steps\r\n\r\nInitializing a realm application like: \r\n```\r\nobject RealmProviderManager {\r\n\r\n    private const val TAG = \"RealmProviderManager\"\r\n\r\n    private var realmApplication: App? = null\r\n\r\n    private var user: User? = null\r\n\r\n    private var realmSyncConfiguration: SyncConfiguration? = null\r\n\r\n    private var syncSession: SyncSession? = null\r\n\r\n    suspend fun initialize(context: Context, realmAppId: String, partitionKey: String): Boolean {\r\n\r\n        return try {\r\n\r\n            Realm.init(context)\r\n\r\n            if (BuildConfig.DEBUG) {\r\n\r\n                RealmLog.setLevel(LogLevel.ALL)\r\n            }\r\n\r\n            val realmAppConfiguration = AppConfiguration.Builder(realmAppId)\r\n                .build()\r\n\r\n            this.realmApplication = App(realmAppConfiguration)\r\n\r\n            this.initialize(this.realmApplication!!, partitionKey)\r\n\r\n            this.initializeRealmSession()\r\n\r\n            true\r\n        } catch (ex: Exception) {\r\n\r\n            \/\/ TODO log error to telemetry\r\n\r\n            false\r\n        }\r\n    }\r\n\r\n    suspend fun initialize(realmApplication: App, partitionKey: String) {\r\n\r\n        this.realmApplication = realmApplication\r\n\r\n        this.user = this.loginToRealm()\r\n\r\n        realmSyncConfiguration = SyncConfiguration.Builder(\r\n            this.user,\r\n            partitionKey\r\n        ).build()\r\n\r\n        if(Realm.getDefaultConfiguration()?.realmFileName != realmSyncConfiguration?.realmFileName) {\r\n\r\n            Realm.setDefaultConfiguration(realmSyncConfiguration!!)\r\n        }\r\n    }\r\n\r\n    private suspend fun loginToRealm(): User? {\r\n\r\n        return suspendCancellableCoroutine { continuation ->\r\n\r\n            \/\/ TODO update this to use a custom JWT token or maybe a custom function\r\n            val credentials: Credentials = Credentials.anonymous()\r\n\r\n            realmApplication!!.loginAsync(credentials) { loginResult ->\r\n\r\n                if (loginResult.isSuccess) {\r\n\r\n                    val loginUser: User? = loginResult.get()\r\n\r\n                    continuation.resume(loginUser) {\r\n\r\n                        \/\/ implementation not required\r\n                    }\r\n                }\r\n                \/\/ otherwise the exception will be thrown in the coroutine\r\n                \/\/ and this should be catch in the consumer of this function\r\n                else {\r\n\r\n                    val error: AppException = loginResult.error\r\n\r\n                    continuation.resumeWithException(error)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun initializeRealmSession() {\r\n\r\n        this.syncSession = realmApplication?.sync?.getOrCreateSession(realmSyncConfiguration)\r\n\r\n        syncSession?.start()\r\n    }\r\n\r\n    @OptIn(ExperimentalCoroutinesApi::class)\r\n    suspend fun waitToDownloadComplete(): Boolean {\r\n\r\n        val realm: Realm = Realm.getDefaultInstance()\r\n\r\n        return suspendCancellableCoroutine { cancelableContinuation ->\r\n\r\n            syncSession?.addDownloadProgressListener(ProgressMode.INDEFINITELY) { progress ->\r\n\r\n                if(progress.isTransferComplete) {\r\n\r\n                    cancelableContinuation.resume(true){\r\n\r\n                        \/\/ Implementation not required\r\n                    }\r\n\r\n                    realm.close()\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nIn my view model I call the function like.\r\n\r\n```\r\nclass SynchronizationViewModel @Inject constructor(\r\nprivate val dispatcher: CoroutineDispatcher = Dispatchers.IO\r\n) : ViewModel() {\r\n\r\nfun initializeViewModel() {\r\n\r\n        this.viewModelScope.launch(this.dispatcher) {\r\n\r\n            try {\r\n\/\/ ...\r\nRealmProviderManager.waitToDownloadComplete()\r\n            } catch (exception: Exception) {\r\n\/\/ ...\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n\r\n### Version\r\n\r\n10.8.0, 10.10.1\r\n\r\n### What SDK flavour are you using?\r\n\r\nMongoDB Realm (i.e. Sync, auth, functions)\r\n\r\n### Are you using encryption?\r\n\r\nNo, not using encryption\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid, Android Instant App\r\n\r\n### Build environment\r\n\r\n**Android Studio version**\r\n\r\nAndroid Studio Bumblebee | 2021.1.1\r\nBuild #AI-211.7628.21.2111.8092744, built on January 18, 2022\r\nRuntime version: 11.0.11+0-b60-7590822 x86_64\r\nVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.\r\nmacOS 11.6.2\r\nGC: G1 Young Generation, G1 Old Generation\r\nMemory: 2048M\r\nCores: 8\r\nRegistry: external.system.auto.import.disabled=true\r\nNon-Bundled Plugins: com.dengzii.plugin.adb (2021.1.3), com.wakatime.intellij.plugin (13.1.8), idea.plugin.protoeditor (2.3.1), net.codestats.plugin.atom.intellij (1.0.9), app.teamhub (14.0.6), wu.seal.tool.jsontokotlin (3.7.2), com.thoughtworks.gauge (211.6693.111), com.google.mad-scorecard (1.2), org.intellij.plugins.markdown (211.7142.37)\r\n\r\n**Android Build Tools version**\r\nAndroid Gradle Plugin version: 7.0.4\r\n\r\n**Gradle version (gradle-wrapper.properties):**\r\n#Thu Nov 25 18:31:09 CST 2021\r\ndistributionBase=GRADLE_USER_HOME\r\ndistributionUrl=https\\:\/\/services.gradle.org\/distributions\/gradle-7.0.2-bin.zip\r\ndistributionPath=wrapper\/dists\r\nzipStorePath=wrapper\/dists\r\nzipStoreBase=GRADLE_USER_HOME\r\n\r\n","comments":["Instant apps have a limitation that does not allow creating named pipes, required by the realm commit notifier. It has been reported to google and they are looking into it, see\u00a0https:\/\/issuetracker.google.com\/issues\/203772220"],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","Encryption:Off","SDK-Use:Sync"]},{"title":"Build failed - Cause: broken method","body":"### How frequently does the bug occur?\n\nAll the time\n\n### Description\n\nHello.\r\n\r\nI'm encountering a build error that seems to be related to Realm.\r\n\r\nI've added a new method _(`getFolderIcon`)_ in a RealmObject _(`File`)_, and I'm not able to build anymore.\r\n\r\nThe build fails at the task `:app:transformClassesWithRealmTransformerForStandardDebug`, with the cause being `broken method`.\r\n\r\nIf I put the method as an extension function in the class companion _(or somewhere else in the project)_, it builds without issue.\r\n\r\nYou can find here the RealmObject: https:\/\/github.com\/Infomaniak\/android-kDrive\/blob\/Realm-broken-method\/app\/src\/main\/java\/com\/infomaniak\/drive\/data\/models\/File.kt\r\n\r\nYou can see in its companion that there is another methods with the same issue.\n\n### Stacktrace & log output\n\n```shell\n> Task :app:transformClassesWithRealmTransformerForStandardDebug FAILED\r\nExecution failed for task ':app:transformClassesWithRealmTransformerForStandardDebug'.\r\n> Failed to transform com.infomaniak.drive.data.models.File.\r\n\r\n* Try:\r\nRun with --info or --debug option to get more log output. Run with --scan to get full insights.\r\n\r\n* Exception is:\r\norg.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:transformClassesWithRealmTransformerForStandardDebug'.\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$1(ExecuteActionsTaskExecuter.java:188)\r\n\tat org.gradle.internal.Try$Failure.ifSuccessfulOrElse(Try.java:263)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:186)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:174)\r\n\tat org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:109)\r\n\tat org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\r\n\tat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\r\n\tat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:56)\r\n\tat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:200)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:195)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:62)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$call$2(DefaultBuildOperationExecutor.java:79)\r\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.callWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:54)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:79)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\r\n\tat org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:74)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:408)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:395)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:388)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:374)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.lambda$run$0(DefaultPlanExecutor.java:127)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:191)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.executeNextNode(DefaultPlanExecutor.java:182)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:124)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)\r\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)\r\nCaused by: java.lang.RuntimeException: Failed to transform com.infomaniak.drive.data.models.File.\r\n\tat io.realm.transformer.build.FullBuild.transformDirectAccessToModelFields(FullBuild.kt:139)\r\n\tat io.realm.transformer.RealmTransformer.transform(RealmTransformer.kt:139)\r\n\tat com.android.build.api.transform.Transform.transform(Transform.java:315)\r\n\tat com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:284)\r\n\tat com.android.build.gradle.internal.profile.NoOpAnalyticsService.recordBlock(NoOpAnalyticsService.kt:72)\r\n\tat com.android.build.gradle.internal.pipeline.TransformTask.transform(TransformTask.java:242)\r\n\tat java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat java.base\/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:104)\r\n\tat org.gradle.api.internal.project.taskfactory.IncrementalTaskInputsTaskAction.doExecute(IncrementalTaskInputsTaskAction.java:47)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:51)\r\n\tat org.gradle.api.internal.project.taskfactory.AbstractIncrementalTaskAction.execute(AbstractIncrementalTaskAction.java:25)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:29)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$2.run(ExecuteActionsTaskExecuter.java:506)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:29)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:26)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:56)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$run$1(DefaultBuildOperationExecutor.java:74)\r\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.runWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:45)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:74)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:491)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:474)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.access$300(ExecuteActionsTaskExecuter.java:106)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$TaskExecution.executeWithPreviousOutputFiles(ExecuteActionsTaskExecuter.java:271)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$TaskExecution.execute(ExecuteActionsTaskExecuter.java:249)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:83)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:37)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:50)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:47)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:200)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:195)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:62)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$call$2(DefaultBuildOperationExecutor.java:79)\r\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.callWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:54)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:79)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:47)\r\n\tat org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:37)\r\n\tat org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:68)\r\n\tat org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:38)\r\n\tat org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:50)\r\n\tat org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:36)\r\n\tat org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:41)\r\n\tat org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:74)\r\n\tat org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)\r\n\tat org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:51)\r\n\tat org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:29)\r\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:54)\r\n\tat org.gradle.internal.execution.steps.CaptureStateAfterExecutionStep.execute(CaptureStateAfterExecutionStep.java:35)\r\n\tat org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:60)\r\n\tat org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:27)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:174)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:74)\r\n\tat org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:45)\r\n\tat org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:40)\r\n\tat org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:29)\r\n\tat org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:36)\r\n\tat org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:22)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:99)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:92)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:52)\r\n\tat org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:36)\r\n\tat org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:85)\r\n\tat org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:42)\r\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)\r\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)\r\n\tat org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:91)\r\n\tat org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:49)\r\n\tat org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:106)\r\n\tat org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:51)\r\n\tat org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:72)\r\n\tat org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:46)\r\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:86)\r\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:86)\r\n\tat org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:32)\r\n\tat org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)\r\n\tat org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:43)\r\n\tat org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:31)\r\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.lambda$execute$0(AssignWorkspaceStep.java:40)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$TaskExecution$2.withWorkspace(ExecuteActionsTaskExecuter.java:284)\r\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:40)\r\n\tat org.gradle.internal.execution.steps.AssignWorkspaceStep.execute(AssignWorkspaceStep.java:30)\r\n\tat org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:37)\r\n\tat org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:27)\r\n\tat org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:44)\r\n\tat org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:33)\r\n\tat org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:76)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:185)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:174)\r\n\tat org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:109)\r\n\tat org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)\r\n\tat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)\r\n\tat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:56)\r\n\tat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:200)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:195)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:75)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner$3.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:153)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:68)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:62)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.lambda$call$2(DefaultBuildOperationExecutor.java:79)\r\n\tat org.gradle.internal.operations.UnmanagedBuildOperationWrapper.callWithUnmanagedSupport(UnmanagedBuildOperationWrapper.java:54)\r\n\tat org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:79)\r\n\tat org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)\r\n\tat org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:74)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:408)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:395)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:388)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:374)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.lambda$run$0(DefaultPlanExecutor.java:127)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:191)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.executeNextNode(DefaultPlanExecutor.java:182)\r\n\tat org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:124)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)\r\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)\r\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)\r\nCaused by: javassist.CannotCompileException: broken method\r\n\tat javassist.expr.FieldAccess.replace(FieldAccess.java:243)\r\n\tat io.realm.transformer.BytecodeModifier$FieldAccessToAccessorConverterUsingList.edit(ByteCodeModifier.kt:144)\r\n\tat javassist.expr.ExprEditor.loopBody(ExprEditor.java:203)\r\n\tat javassist.expr.ExprEditor.doit(ExprEditor.java:96)\r\n\tat javassist.CtBehavior.instrument(CtBehavior.java:744)\r\n\tat io.realm.transformer.BytecodeModifier$Companion.useRealmAccessors(ByteCodeModifier.kt:79)\r\n\tat io.realm.transformer.build.FullBuild.transformDirectAccessToModelFields(FullBuild.kt:136)\r\n\t... 128 more\n```\n\n\n### Can you reproduce the bug?\n\nYes, always\n\n### Reproduction Steps\n\nYou can checkout this branch and just build the app module: https:\/\/github.com\/Infomaniak\/android-kDrive\/tree\/Realm-broken-method\n\n### Version\n\n10.8.0 & 10.10.1\n\n### What SDK flavour are you using?\n\nLocal Database only\n\n### Are you using encryption?\n\nNo, not using encryption\n\n### Platform OS and version(s)\n\nAndroid 12\n\n### Build environment\n\nAndroid Studio version: 2020.3.1 Patch 4\r\nAndroid Build Tools version: 31.0.0\r\nGradle version: 7.0.4","comments":["Hi @KevinBoulongne Sorry for the late reply.\r\n\r\nI tried to reproduce the behavior in one of our sample projects, but I had to modify the File model class quite significantly for it to compile, and then it didn't trigger the behavior.\r\n\r\nThen, since your project is open source, I tried to build your branch from source, but I'm getting hit by this build error:\r\n\r\n```\r\n* What went wrong:\r\nCould not determine the dependencies of task ':app:mergePreprodReleaseNativeLibs'.\r\n> Could not resolve all task dependencies for configuration ':app:preprodReleaseRuntimeClasspath'.\r\n   > Could not resolve project :Core.\r\n     Required by:\r\n         project :app\r\n      > No matching configuration of project :Core was found. The consumer was configured to find a runtime of a component, preferably optimized for Android, as well as attribute 'com.android.build.api.attributes.BuildTypeAttr' with value 'release', attribute 'distribution' with value 'preprod', attribute 'org.jetbrains.kotlin.platform.type' with value 'androidJvm' but:\r\n          - None of the consumable configurations have attributes.\r\n```\r\n\r\nCan you provide any advice on how to build your repo, because I suspect it will be much faster to test there.","Hello @cmelchior !\r\nNo worries for the delay.\r\n\r\nYou need to clone the repository with the submodules.\r\nHere is the correct command: `git clone --recurse-submodules git@github.com:Infomaniak\/android-kDrive.git`\r\n\r\nThen just checkout the test branch, and everything should be ok :)","@KevinBoulongne Thanks for the instructions. We were able to reproduce the bug.\r\n\r\nThe Realm build transformer crashes when it encounters a resource within the function. You can avoid this issue, while we work out a solution, by moving the function body into a helper function. A static method in the companion object would work. "],"labels":["T-Bug","O-Community","Frequency:Always","Repro:Always","SDK-Use:Local","Encryption:Off"]},{"title":"RealmList size() crashes occurring for many users since version 10.9.0","body":"### How frequently does the bug occur?\r\n\r\nSometimes\r\n\r\n### Description\r\n\r\nHello,\r\n\r\nWe are facing multiple crashes since the update of the Realm Version from 10.8.1 -> **10.9.0**.\r\n\r\nSo far, more than 2000 users have been affected by these crashes (~5%).  But we don't have specific complaints about it, so it can be silent crashes. There is ~1.4 crash\/user on average so maybe it's just happening once\/per device or in really specific conditions.  \r\n\r\nAll the crashes are happening in the `equals()` method of a `RealmObject` used in a recyclerview with a Diffutils. More precisely in the `size() `method of a `RealmList` contained in the `RealmObject`.\r\n\r\nThese crashes don't seem to be related to specific devices, we were not able to reproduce with the same devices.\r\n\r\n### Stacktrace & log output\r\n\r\n```\r\nsignal 11 (SIGSEGV), code 1 (SEGV_MAPERR)\r\nlibrealm-jni.so (offset 0xab0000)\r\n```\r\n\r\nObfuscated trace : \r\n```shell\r\n*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\npid: 0, tid: 0 >>> eu.qonto.qonto <<<\r\n\r\nbacktrace:\r\n  #00  pc 0000000000375398  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n  #00  pc 0000000000588774  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n  #00  pc 00000000005885d4  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n  #00  pc 0000000000586d44  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n  #00  pc 000000000036ae98  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000) (Java_io_realm_internal_OsList_nativeSize+20)\r\n  #00  pc 0000000000206bf8  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (art_jni_trampoline+152)\r\n  #00  pc 0000000000387a30  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (io.realm.internal.OsList.V+48)\r\n  #00  pc 000000000038c080  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (io.realm.u0.size+192)\r\n  #00  pc 000000000037728c  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (io.realm.u0$b.hasNext+156)\r\n  #00  pc 00000000002bfad8  \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.util.AbstractList.equals+456)\r\n  #00  pc 00000000008171c0  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (kotlin.jvm.internal.n.e+64)\r\n  #00  pc 0000000000718b54  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (com.qonto.qonto.data.model.Transaction.equals+2196)\r\n  #00  pc 000000000092e160  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (rv.f.equals+240)\r\n  #00  pc 00000000008171c0  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (kotlin.jvm.internal.n.e+64)\r\n  #00  pc 0000000000282abc  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (dd.c.a+252)\r\n  #00  pc 00000000006f3c10  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (ip.j.d+288)\r\n  #00  pc 00000000006f3998  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (ip.j.a+104)\r\n  #00  pc 0000000000526d7c  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.d$a$a.a+236)\r\n  #00  pc 0000000000423948  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.h$e.e+280)\r\n  #00  pc 000000000042338c  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.h$e.<init>+268)\r\n  #00  pc 0000000000424dc0  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.h.c+1088)\r\n  #00  pc 000000000041ff0c  \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.d$a.run+140)\r\n  #00  pc 00000000002d0638  \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.util.concurrent.ThreadPoolExecutor.runWorker+984)\r\n  #00  pc 00000000002cd650  \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.util.concurrent.ThreadPoolExecutor$Worker.run+64)\r\n  #00  pc 0000000000176798  \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.lang.Thread.run+72)\r\n  #00  pc 0000000000133564  \/apex\/com.android.art\/lib64\/libart.so (art_quick_invoke_stub+548)\r\n  #00  pc 00000000001a8a78  \/apex\/com.android.art\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+200)\r\n  #00  pc 000000000055581c  \/apex\/com.android.art\/lib64\/libart.so (art::JValue art::InvokeVirtualOrInterfaceWithJValues<art::ArtMethod*>(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, art::ArtMethod*, jvalue const*)+460)\r\n  #00  pc 00000000005a4b80  \/apex\/com.android.art\/lib64\/libart.so (art::Thread::CreateCallback(void*)+1308)\r\n  #00  pc 00000000000da278  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__pthread_start(void*)+64)\r\n  #00  pc 000000000007a448  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__start_thread+64)\r\n```\r\n\r\nDeobfuscated trace\r\n```shell\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000) (Java_io_realm_internal_OsList_nativeSize+20)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (art_jni_trampoline+152)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (io.realm.internal.OsList.size+60)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (io.realm.RealmList$RealmItr.hasNext+304)\r\n\/system\/framework\/arm64\/boot.oat (java.util.AbstractList.equals+424)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (kotlin.jvm.internal.Intrinsics.areEqual+64)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (com.qonto.qonto.data.model.Transaction.equals+2196)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (com.qonto.qonto.ui.transaction.list.TransactionListItem.equals+244)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (kotlin.jvm.internal.Intrinsics.areEqual+64)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (com.qonto.core.utils.diffutil.HasIdItemCallback.areContentsTheSame+252)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (com.qonto.qonto.ui.core.baselist.ListItemDiffUtils.areContentsTheSame+288)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (com.qonto.qonto.ui.core.baselist.ListItemDiffUtils.areContentsTheSame+104)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.AsyncListDiffer$1$1.areContentsTheSame+236)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.DiffUtil$DiffResult.findMatchingItems+280)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.DiffUtil$DiffResult.<init>+268)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.DiffUtil.calculateDiff+1088)\r\n\/data\/app\/eu.qonto.qonto-yx5M_Ko3r36ME10l4xG2CQ==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.AsyncListDiffer$1.run+144)\r\n\/system\/framework\/arm64\/boot.oat (java.util.concurrent.ThreadPoolExecutor.runWorker+984)\r\n\/system\/framework\/arm64\/boot.oat (java.util.concurrent.ThreadPoolExecutor$Worker.run+64)\r\n\/system\/framework\/arm64\/boot.oat (java.lang.Thread.run+72)\r\n\/apex\/com.android.runtime\/lib64\/libart.so (art_quick_invoke_stub+548)\r\n\/apex\/com.android.runtime\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+252)\r\n\/apex\/com.android.runtime\/lib64\/libart.so (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const&, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+104)\r\n\/apex\/com.android.runtime\/lib64\/libart.so (art::InvokeVirtualOrInterfaceWithJValues(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, _jmethodID*, jvalue const*)+416)\r\n\/apex\/com.android.runtime\/lib64\/libart.so (art::Thread::CreateCallback(void*)+1176)\r\n\/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__pthread_start(void*)+36)\r\n\/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__start_thread+64)\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nNot yet\r\n\r\n### Reproduction Steps\r\n\r\nWe are unable to reproduce the crash so far, but it's impacting more than 5% of our userbase.\r\n\r\n### Version\r\n\r\n10.9.0\r\n\r\n### What SDK flavour are you using?\r\n\r\nLocal Database\r\n\r\n### Are you using encryption?\r\n\r\nYes, using encryption\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid  - mostly v10 & 11\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: ...\r\nAndroid Build Tools version: ...\r\nGradle version: ...\r\n","comments":["Hi, thanks for reporting the issue. We cannot unroll the stacktrace because it is missing the backtrace, are you able to get a full one, here you can find how they look like: https:\/\/developer.android.com\/ndk\/guides\/ndk-stack","Hello @clementetb ! We updated the description by adding the backtrace, does it help ?","@qonto-android-team The unrolled stack trace looks a bit weird. It looks more reasonably if I unroll it against the \"Local Database\"-library symbols. Are you in fact using \"MongoDB Realm\" (with remote sync functionality)?","Yes indeed, we are using the Local Database only. My bad.\r\n","Thanks for clarifying.\r\n\r\nFor reference the unrolled stack trace is:\r\n```\r\n#00 0x0000000000375398 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n                                                                                                                                                              realm::BPlusTreeBase::init_from_parent()\r\n                                                                                                                                                              \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/bplustree.hpp:186:34\r\n#00 0x0000000000588774 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n                                                                                                                                                              realm::Lst<realm::StringData>::init_from_parent(bool) const\r\n                                                                                                                                                              \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/list.hpp:239:21\r\n#00 0x00000000005885d4 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n                                                                                                                                                              realm::Lst<realm::StringData>::update_if_needed() const\r\n                                                                                                                                                              \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/list.hpp:173:33\r\n#00 0x0000000000586d44 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000)\r\n                                                                                                                                                              realm::Lst<realm::StringData>::update() const\r\n                                                                                                                                                              \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/list.hpp:207:16\r\n                                                                                                                                                              realm::Lst<realm::StringData>::size() const\r\n                                                                                                                                                              \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/list.hpp:557:12\r\n#00 0x000000000036ae98 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0xab0000) (Java_io_realm_internal_OsList_nativeSize+20)\r\n                                                                                                                                                              Java_io_realm_internal_OsList_nativeSize\r\n                                                                                                                                                              \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsList.cpp:192:37\r\n#00 0x0000000000206bf8 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (art_jni_trampoline+152)\r\n#00 0x0000000000387a30 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (io.realm.internal.OsList.V+48)\r\n#00 0x000000000038c080 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (io.realm.u0.size+192)\r\n#00 0x000000000037728c \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (io.realm.u0$b.hasNext+156)\r\n#00 0x00000000002bfad8 \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.util.AbstractList.equals+456)\r\n#00 0x00000000008171c0 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (kotlin.jvm.internal.n.e+64)\r\n#00 0x0000000000718b54 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (com.qonto.qonto.data.model.Transaction.equals+2196)\r\n#00 0x000000000092e160 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (rv.f.equals+240)\r\n#00 0x00000000008171c0 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (kotlin.jvm.internal.n.e+64)\r\n#00 0x0000000000282abc \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (dd.c.a+252)\r\n#00 0x00000000006f3c10 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (ip.j.d+288)\r\n#00 0x00000000006f3998 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (ip.j.a+104)\r\n#00 0x0000000000526d7c \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.d$a$a.a+236)\r\n#00 0x0000000000423948 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.h$e.e+280)\r\n#00 0x000000000042338c \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.h$e.<init>+268)\r\n#00 0x0000000000424dc0 \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.h.c+1088)\r\n#00 0x000000000041ff0c \/data\/app\/~~IM2LYE6LLUpHM_1qPg16kA==\/eu.qonto.qonto-_rP1yxixX2tLoHWEx4QI4A==\/oat\/arm64\/base.odex (androidx.recyclerview.widget.d$a.run+140)\r\n#00 0x00000000002d0638 \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.util.concurrent.ThreadPoolExecutor.runWorker+984)\r\n#00 0x00000000002cd650 \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.util.concurrent.ThreadPoolExecutor$Worker.run+64)\r\n#00 0x0000000000176798 \/apex\/com.android.art\/javalib\/arm64\/boot.oat (java.lang.Thread.run+72)\r\n#00 0x0000000000133564 \/apex\/com.android.art\/lib64\/libart.so (art_quick_invoke_stub+548)\r\n#00 0x00000000001a8a78 \/apex\/com.android.art\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+200)\r\n#00 0x000000000055581c \/apex\/com.android.art\/lib64\/libart.so (art::JValue art::InvokeVirtualOrInterfaceWithJValues<art::ArtMethod*>(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, art::ArtMethod*, jvalue const*)+460)\r\n#00 0x00000000005a4b80 \/apex\/com.android.art\/lib64\/libart.so (art::Thread::CreateCallback(void*)+1308)\r\n#00 0x00000000000da278 \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__pthread_start(void*)+64)\r\n#00 0x000000000007a448 \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__start_thread+64)\r\n```","Not a lot to work on here. @rorbech  It seems like the size method on a List of strings is called directly from java. Can we find out how this object is created and in which context it is used? ","@qonto-android-team Unfortunately there is not enough information in the stack trace to guide us to compile a reproduction case for this. Are you able to share some more details about this: \r\n- Are there any chance to get a hold on a Realm exhibiting this? \r\n- Is it a one time issue only happening when people have upgraded? And do you know if the app is operational after this happens?\r\n- Have you tried reproducing by upgrading you app?q","Hello @rorbech !\r\n\r\n- Are there any chance to get a hold on a Realm exhibiting this? => It's improbable. We don't reproduce the issue and we can't identify users that have this issue, so we can't have a hand on a Realm exhibiting this sadly.\r\n\r\n- Is it a one time issue only happening when people have upgraded? => We think that's a one time issue, but we can't ensure it. By the way, checking the occurences vs users impacted, we have a ratio of 1.4, so it probably mean that's not only 1 time by user.\r\n\r\n- Have you tried reproducing by upgrading you app? => Yes and we do not reproduce"],"labels":["T-Bug","Reproduction-Required","O-Community","Frequency:Sometimes","Repro:No","Encryption:On"]},{"title":"Add unit test trying to reproduce App.currentUser returning invalid user.","body":null,"comments":[],"labels":["cla: yes"]},{"title":"Implement Convert Non-Sync to Sync Realm","body":null,"comments":[],"labels":["gathering-interest"]},{"title":"Attempt to recreate a file for type io.realm.PACKAGE_OBJECTRealmProxy","body":"> Great, I'll issume this issue is fixed then. Closing.\r\n\r\nhello again!\r\none more related problem appeared on Gradle 7.3-rc-5\/ 7.3-bin:\r\n\r\nsame error:\r\n\r\n```\r\nerror: Attempt to recreate a file for type io.realm.com_PACKAGE_OBJECTRealmProxy\r\npublic class OBJECT extends RealmObject {\r\n       ^\r\n```\r\n\r\nAppears if I add an svg in Drawable through Add Vector Asset or if I add new file in drawable (selector for example).\r\nMake Project -> Run doesn't help anymore.\r\nHave to Clean Project -> Rebuild.\r\n\r\n_Originally posted by @jorrdane in https:\/\/github.com\/realm\/realm-java\/issues\/7562#issuecomment-976326598_\r\n\r\nAlso appears sometimes if I edit something in xml (added dimensions)","comments":["We are about to release version `10.9.0`, would you mind validating on it once it gets published?","> \r\n\r\nyeah, sure","> \r\n\r\nhello!\r\nrealm 10.9.0 -> added dimensions -> same error","Seems to be reproducible on our \"Intro Example\"","> Seems to be reproducible on our \"Intro Example\"\r\n\r\nin previous thread one of your developers could reproduce this somehow","I have changed the app icon from vector asset and its showing this error !! What should I do ","@76105 Haven't seen your reply. I think you've already resolved it but if no: Clean Project - Rebuild."],"labels":["O-Community"]},{"title":"Reproduce memory crash when accessing RealmAny","body":"See https:\/\/github.com\/realm\/realm-java\/issues\/7586","comments":[],"labels":["cla: yes"]},{"title":"In memory Realm doesn't get deleted after Realm close. io.realm.exceptions.RealmError: Unrecoverable error. Decryption failed Exception backtrace: <backtrace not supported on this platform> () in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 144. (76K Occurrences)","body":"### How frequently does the bug occur?\r\n\r\nEvery time\r\n\r\n### Description\r\n\r\nUpgraded from 5.13.1 to 7.0.0 as part of regular SDK upgrade. \r\n\r\n- Added encryption key while creating in-memory realm config.\r\n\r\n\r\nAfter these changes were pushed to production, there was a very high number of crashes in Play Store Console and Firebase Crashlytics. \r\n \r\n\r\n### Stacktrace & log output\r\n\r\n```shell\r\nFatal Exception: io.realm.exceptions.RealmException: Async transaction failed\r\n       at io.realm.Realm$1$2.run(Realm.java:1657)\r\n       at android.os.Handler.handleCallback(Handler.java:873)\r\n       at android.os.Handler.dispatchMessage(Handler.java:99)\r\n       at android.os.Looper.loop(Looper.java:224)\r\n       at android.app.ActivityThread.main(ActivityThread.java:7081)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:604)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:928)\r\nCaused by io.realm.exceptions.RealmError: Unrecoverable error. Decryption failed\r\nException backtrace:\r\n<backtrace not supported on this platform> () in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 144\r\n       at io.realm.internal.OsSharedRealm.nativeCommitTransaction(OsSharedRealm.java)\r\n       at io.realm.internal.OsSharedRealm.commitTransaction(OsSharedRealm.java:283)\r\n       at io.realm.BaseRealm.commitTransaction(BaseRealm.java:441)\r\n       at io.realm.Realm.commitTransaction(Realm.java:145)\r\n       at io.realm.Realm$1.run(Realm.java:1607)\r\n       at io.realm.internal.async.BgPriorityRunnable.run(BgPriorityRunnable.java:34)\r\n       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:458)\r\n       at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n       at java.lang.Thread.run(Thread.java:764)\r\n```\r\n\r\n\r\n### Can you reproduce the bug?\r\n\r\nYes\r\n\r\n### Reproduction Steps\r\n\r\nStep 1 - App version 1 creates an in-memory realm configuration upon consumer's demand.\r\nStep 2 - App version 2 creates an in-memory realm configuration upon consumer's demand but with an encryption key.\r\nStep 3 - When a user migrates from App version 1 to App version 2, the app crashes.\r\n\r\n### Version\r\n\r\n7.0.0\r\n\r\n### What SDK flavor are you using?\r\n\r\nLocal Database only\r\n\r\n### Are you using encryption?\r\n\r\nYes, using encryption\r\n\r\n### Platform OS and version(s)\r\n\r\nAndroid 8,9,10,11\r\n\r\n### Build environment\r\n\r\nAndroid Studio version: ...\r\nAndroid Build Tools version: ...\r\nGradle version: ...\r\n","comments":["`Unrecoverable error. Decryption failed` is caused when you try to open an existing Realm with an invalid encryption data.\r\n\r\nCould you check that the encryption key used to open such Realms is correct?\r\nHave you been able to reproduce it?","Thanks for getting back. Yes, we can reproduce the issue every time now. Here is a use case that causes this crash -\r\n1) App version 1 creates an in-memory realm configuration upon consumer's demand.\r\n2) App version 2 creates an in-memory realm configuration upon consumer's demand but with an encryption key.\r\n3) When a user migrates from App version 1 to App version 2, the app crashes.\r\n\r\nAs per the documentation, such Realm configurations are deleted from the memory after the realm closes but we can find memxxxx.realm files in the device file system. Here is a sample project we have created :\r\n\r\nhttps:\/\/drive.google.com\/file\/d\/1jx2ZZ3BQ4xwwyVNbS6aFYVbMdfvYOykR\/view?usp=sharing\r\n\r\nFirst comment line#188\r\n\r\nbuild the app and install\r\n\r\nuncomment line 188\r\n\r\nbuild the app and install \r\n\r\napp will crash all the time\r\n","@fzandroid in-memory Realms write some data into the disk that is only closed when the latest Realm gets closed, and it is not cleared once it starts again after for example an update.\r\n\r\nI am going to raise the issue with the Core team. Meanwhile, a solution to avoid the clash would be to change the in-memory Realm file name.","Thanks for providing the workaround. I tested the flow again and looks like in-memory Realm DB isn't getting deleted even after Realm has successfully closed. Will you be providing a fix for this in the coming releases?\r\nFrom the consumer's perspective, our expectation is that we shouldn't have any in-memory Realm files in the application directory after Realm has closed. Is that correct?  ","\u27a4 Clemente Tort Barbero commented:\n\nYes, the in-memory Realm files should not persist between two app runs. We are investigating how to fix this bug.","How frequently does the bug occur?\r\nEvery time\r\n\r\nVersion\r\n* \"io.realm:realm-gradle-plugin:10.17.0\"\r\n\r\nDescription\r\n* Added encryption key while creating in-memory realm config.\r\n\r\nStacktrace\r\n\r\n```\r\nE\/REALM_JNI: jni: ThrowingException 6, Decryption failed: 'unable to decrypt after 0 seconds (retry_count=0, from=i != bytes_read, size=4096)' () in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 144, .\r\nE\/REALM_JNI: Exception has been thrown: Unrecoverable error. Decryption failed: 'unable to decrypt after 0 seconds (retry_count=0, from=i != bytes_read, size=4096)' () in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 144\r\nE\/ErrorHandlerImpl: ErrorHandler\r\n    io.realm.exceptions.RealmError: Unrecoverable error. Decryption failed: 'unable to decrypt after 0 seconds (retry_count=0, from=i != bytes_read, size=4096)' () in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 144\r\n        at io.realm.internal.OsSharedRealm.nativeCommitTransaction(Native Method)\r\n        at io.realm.internal.OsSharedRealm.commitTransaction(OsSharedRealm.java:292)\r\n        at io.realm.BaseRealm.commitTransaction(BaseRealm.java:459)\r\n        at io.realm.Realm.commitTransaction(Realm.java:138)\r\n        at io.reactivex.internal.operators.completable.CompletableCreate.subscribeActual(CompletableCreate.java:39)\r\n        at io.reactivex.Completable.subscribe(Completable.java:2309)\r\n        at io.reactivex.internal.operators.completable.CompletableSubscribeOn$SubscribeOnObserver.run(CompletableSubscribeOn.java:64)\r\n        at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:608)\r\n        at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)\r\n        at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)\r\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\r\n        at java.lang.Thread.run(Thread.java:764)\r\n```\r\n\r\n```\r\n E\/ErrorHandlerImpl: ErrorHandler\r\n    io.realm.exceptions.RealmError: Unrecoverable error. Decryption failed: 'unable to decrypt after 0 seconds (retry_count=0, from=i != bytes_read, size=4096)' () in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 144\r\n```\r\n\r\n`E\/libc++abi: terminating with uncaught exception of type realm::util::DecryptionFailed: Decryption failed: 'unable to decrypt after 0 seconds (retry_count=0, from=iv1 == 0, size=4096)'`\r\n\r\nReproduction Steps\r\n1. clean installation app\r\n2. works with realm from multiple processes\r\n3. get an unhandled exception\r\n\r\nCan you reproduce the bug?\r\nYes\r\n\r\nAre you using encryption?\r\nYes, using encryption\r\n\r\nPlatform OS and version(s)\r\nAndroid 8.1,13"],"labels":["T-Bug","O-Community","Encryption:On"]},{"title":"Frozen Realms don't reference count correctly","body":"#### Goal\r\n\r\nI would like the following code not to crash.\r\n\r\n```kotlin\r\nval realm = Realm.getDefaultInstance()\r\n\r\n\/\/ Freeze the Realm\r\nval realm1 = realm.freeze()\r\n\/\/ Freeze a second time first, then write to the live Realm\r\nval realm2 = realm.freeze()\r\nrealm.executeTransaction { ... }\r\n\r\n\/\/ Close the first frozen instance.\r\nrealm1.close()\r\n\r\n\/\/ Make a query on the second frozen instance\r\n\/\/ Throws IllegalStateException, saying that realm2 is closed.\r\nrealm2.where<...>().findAll().doSomething()\r\n\r\n\/\/ Clean up\r\nrealm2.close()\r\nrealm.close()\r\n```\r\n\r\n#### Actual Results\r\nThe code crashes on querying `realm2`, saying that `realm2` is closed.\r\n\r\n#### Steps & Code to Reproduce\r\nRun the above code.\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s): 10.6.0\r\n\r\nRealm Sync feature enabled: No\r\n\r\nAndroid Studio version: 4.2\r\n\r\nAndroid Build Tools version: 4.0.1\r\n\r\nGradle version: 6.7.1\r\n\r\nWhich Android version and device(s): Android Emulator running 7.1.1 and 9.0\r\n\r\n#### Other comments\r\n\r\nThe cause of the issue is the reference counting associated with the following code:\r\n```kotlin\r\nval realm1 = Realm.getDefaultInstance().freeze()\r\nval realm2 = Realm.getDefaultInstance().freeze()\r\n\/\/ The count of frozen instances at this version of the Realm is 1, not 2\r\n\/\/ Now when we close one of our frozen instances, the reference count goes to 0. The shared frozen instance is deallocated.\r\nrealm1.close()\r\n\/\/ So when we try to do a query on the other instance, an IllegalStateException is thrown.\r\nrealm2.where<...>().findAll()\r\n```\r\nIf we insert a write transaction (to an unfrozen instance) between the two `freeze()` calls, then an exception is no longer thrown because `realm1` and `realm2` now point at different database versions, rather than sharing a frozen instance. The main issue for me is that this can lead to a race condition between modifying the database and taking a frozen snapshot, with different results depending on who wins.\r\n\r\nI submitted a PR (#7504) which I think fixes this &ndash; not sure what your guys' workflow is so sorry if that was a bit forward of me :D ","comments":["Hi @alecbarber. Thanks for the detailed report and fix. We will of course have to verify the issue and your fix. Will get back when that is done. "],"labels":["O-Community"]},{"title":"I get an native freeze recorder in Google Dev Console","body":"#### Goal\r\nDo not have freeze caused by realm or its usage\r\n\r\n#### Actual Results\r\n```\r\n*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\npid: 0, tid: 0 >>> com.foo.bar <<<\r\n\r\nbacktrace:\r\n  #00  pc 0000000000419c40  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000)\r\n  #00  pc 000000000038a2d4  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000)\r\n  #00  pc 000000000043d1d0  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000)\r\n  #00  pc 000000000032f25c  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000) (Java_io_realm_internal_Table_nativeFreeze+456)\r\n  #00  pc 000000000016b720  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.odex (art_jni_trampoline+160)\r\n  #00  pc 00000000001445b8  \/apex\/com.android.runtime\/lib64\/libart.so (art_quick_invoke_static_stub+568)\r\n  #00  pc 00000000001531c4  \/apex\/com.android.runtime\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+284)\r\n  #00  pc 00000000002ee6d8  \/apex\/com.android.runtime\/lib64\/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+384)\r\n  #00  pc 00000000002e99a8  \/apex\/com.android.runtime\/lib64\/libart.so (bool art::interpreter::DoCall<false, false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, art::JValue*)+912)\r\n  #00  pc 00000000005bde3c  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeStatic+368)\r\n  #00  pc 000000000013e994  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_static+20)\r\n  #00  pc 0000000000c36c60  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.internal.Table.freeze+28)\r\n  #00  pc 00000000005c17ac  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n  #00  pc 0000000000142594  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n  #00  pc 0000000000c329e0  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.internal.OsResults.freeze+8)\r\n  #00  pc 00000000005c17ac  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n  #00  pc 0000000000142594  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n  #00  pc 0000000000c03000  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.RealmResults.freeze+32)\r\n  #00  pc 00000000005c17ac  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n  #00  pc 0000000000142594  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n  #00  pc 0000000000c415e0  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.rx.RealmObservableFactory$6.subscribe+128)\r\n  #00  pc 00000000005bcd94  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeInterface+1752)\r\n  #00  pc 000000000013ea14  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_interface+20)\r\n  #00  pc 0000000000bdb55c  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.internal.operators.flowable.FlowableCreate.J+120)\r\n  #00  pc 00000000005c17ac  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n  #00  pc 0000000000142594  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n  #00  pc 0000000000bd4db8  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.Flowable.I+28)\r\n  #00  pc 00000000005c17ac  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n  #00  pc 0000000000142594  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n  #00  pc 0000000000bd4e14  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.Flowable.a+12)\r\n  #00  pc 00000000005bcd94  \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeInterface+1752)\r\n  #00  pc 000000000013ea14  \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_interface+20)\r\n  #00  pc 0000000000bdeea4  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run+24)\r\n  #00  pc 00000000002bf314  \/apex\/com.android.runtime\/lib64\/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame&, art::JValue, bool, bool) (.llvm.17950311261770437987)+240)\r\n  #00  pc 00000000005a6470  \/apex\/com.android.runtime\/lib64\/libart.so (artQuickToInterpreterBridge+1012)\r\n  #00  pc 000000000014d468  \/apex\/com.android.runtime\/lib64\/libart.so (art_quick_to_interpreter_bridge+88)\r\n  #00  pc 0000000000493ea8  \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.odex (io.reactivex.android.schedulers.HandlerScheduler$ScheduledRunnable.run+72)\r\n  #00  pc 00000000008a730c  \/system\/framework\/arm64\/boot-framework.oat (android.os.Handler.dispatchMessage+76)\r\n  #00  pc 00000000008aa960  \/system\/framework\/arm64\/boot-framework.oat (android.os.Looper.loop+1456)\r\n  #00  pc 00000000008a9380  \/system\/framework\/arm64\/boot-framework.oat (android.os.HandlerThread.run+576)\r\n  #00  pc 0000000000144334  \/apex\/com.android.runtime\/lib64\/libart.so (art_quick_invoke_stub+548)\r\n  #00  pc 00000000001531a4  \/apex\/com.android.runtime\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+252)\r\n  #00  pc 00000000004c6ec0  \/apex\/com.android.runtime\/lib64\/libart.so (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const&, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+104)\r\n  #00  pc 00000000004c7f54  \/apex\/com.android.runtime\/lib64\/libart.so (art::InvokeVirtualOrInterfaceWithJValues(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, _jmethodID*, jvalue const*)+416)\r\n  #00  pc 0000000000507f24  \/apex\/com.android.runtime\/lib64\/libart.so (art::Thread::CreateCallback(void*)+1176)\r\n  #00  pc 00000000000ce1c0  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__pthread_start(void*)+36)\r\n  #00  pc 0000000000070ba8  \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__start_thread+64)\r\n```\r\n\r\n#### Steps & Code to Reproduce\r\nDo not know.\r\nWe use realm in a app that follow the Clean Archi\r\nEvery realm object is gather from this BaseRealmDataStore abstract class.\r\n\r\n```\r\npackage com.foo.bar.presentation.common.base\r\n\r\nimport android.os.HandlerThread\r\nimport com.foo.bar.common.tagging.CrashlyticsUtils\r\nimport io.reactivex.Flowable\r\nimport io.reactivex.Scheduler\r\nimport io.reactivex.Single\r\nimport io.reactivex.android.schedulers.AndroidSchedulers\r\nimport io.realm.Realm\r\nimport io.realm.RealmObject\r\nimport io.realm.RealmQuery\r\nimport timber.log.Timber\r\n\r\n@Suppress(\"UNCHECKED_CAST\")\r\nabstract class BaseRealmDataStore<RO : RealmObject> {\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ CONFIGURATION\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    protected abstract val realmObjectClass: Class<RO>\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ DATA\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    companion object {\r\n\r\n        private const val LOOPER_NAME = \"LOOPER_SCHEDULER\"\r\n        private const val DO_LOG = true\r\n\r\n        \/**\r\n         * Delete the whole Realm default database\r\n         *\/\r\n        fun deleteAll() {\r\n            Realm.getDefaultInstance().use { realm ->\r\n                realm.executeTransactionAsync {\r\n                    it.deleteAll()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ DATA\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/**\r\n     * Thread safe Android scheduler with looper\r\n     *\/\r\n    private val looperScheduler: Scheduler by lazy {\r\n        \/\/ read scheduler\r\n        val handlerThread = HandlerThread(LOOPER_NAME + \"_\" + realmObjectClass.name)\r\n        handlerThread.start()\r\n        synchronized(handlerThread) {\r\n            return@lazy AndroidSchedulers.from(handlerThread.looper, true)\r\n        }\r\n    }\r\n\r\n    private val realm: Realm by lazy {\r\n        Realm.getDefaultInstance()\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ GENERIC CRUD API\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ CREATE \/ UPDATE\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    fun save(obj: RO, clearAllBefore: Boolean = false) {\r\n        logMethod(\"save\")\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.logNumberOfActiveVersions()\r\n            realm.executeTransaction {\r\n                if (clearAllBefore) it.delete(realmObjectClass)\r\n                it.copyToRealmOrUpdate(obj)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun saveAll(list: List<RO>, clearAllBefore: Boolean = false) {\r\n        logMethod(\"clearAll\")\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.logNumberOfActiveVersions()\r\n            realm.executeTransaction {\r\n                if (clearAllBefore) it.delete(realmObjectClass)\r\n                it.copyToRealmOrUpdate(list)\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/ HELPER\r\n    fun List<RO>.saveAllToRealm(clearAllBefore: Boolean = false) {\r\n        if (clearAllBefore) {\r\n            logMethod(\"clearAllAndSaveAll\")\r\n            Realm.getDefaultInstance().use { realm ->\r\n                realm.logNumberOfActiveVersions()\r\n                realm.executeTransaction {\r\n                    it.delete(realmObjectClass)\r\n                    it.copyToRealmOrUpdate(this)\r\n                }\r\n            }\r\n        } else {\r\n            saveAll(this)\r\n        }\r\n    }\r\n\r\n    fun RO.saveToRealm(clearAllBefore: Boolean = false) {\r\n        save(this, clearAllBefore)\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ CREATE AND LOG\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    @SuppressWarnings(\"TooGenericExceptionCaught\")\r\n    fun saveAllOrLog(list: List<RO>) {\r\n        try {\r\n            Timber.w(\"saveAll() on [${list.firstOrNull()?.javaClass}]\")\r\n            saveAll(list)\r\n        } catch (e: Exception) {\r\n            Timber.e(\"saveAll() on [${list.firstOrNull()?.javaClass}] : ${e.localizedMessage}\")\r\n            CrashlyticsUtils.log(\"[${list.firstOrNull()?.javaClass}] saveAll() ${e.localizedMessage}\")\r\n        }\r\n    }\r\n\r\n    \/\/ HELPER\r\n    fun List<RO>.saveAllToRealmOrLog() {\r\n        saveAllOrLog(this)\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ READ\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    fun query(query: RealmQuery<RO>.() -> Unit): List<RO> {\r\n        logMethod(\"query\")\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.logNumberOfActiveVersions()\r\n            return realm\r\n                .where(realmObjectClass)\r\n                .withQuery(query)\r\n                .findAll()\r\n                .map { realm.copyFromRealm(it) }\r\n        }\r\n    }\r\n\r\n    fun queryFirst(query: RealmQuery<RO>.() -> Unit): RO? {\r\n        logMethod(\"queryFirst\")\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.logNumberOfActiveVersions()\r\n            return realm\r\n                .where(realmObjectClass)\r\n                .withQuery(query)\r\n                .findFirst()\r\n                ?.let { realm.copyFromRealm(it) }\r\n        }\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ READ RX\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    fun queryAllAsFlowable(): Flowable<List<RO>> {\r\n        logMethod(\"queryAllAsFlowable\")\r\n        return Flowable\r\n            .defer {\r\n                realm.logNumberOfActiveVersions()\r\n                realm\r\n                    .where(realmObjectClass)\r\n                    .findAll()\r\n                    .asFlowable()\r\n            }\r\n            .subscribeOn(looperScheduler)\r\n            .unsubscribeOn(looperScheduler)\r\n            .doOnTerminate { Thread.currentThread().interrupt() }\r\n            .map { it.toList() }\r\n    }\r\n\r\n    fun queryAsFlowable(query: RealmQuery<RO>.() -> Unit): Flowable<List<RO>> {\r\n        logMethod(\"queryAsFlowable\")\r\n        return Flowable\r\n            .defer {\r\n                realm.logNumberOfActiveVersions()\r\n                realm\r\n                    .where(realmObjectClass)\r\n                    .withQuery(query)\r\n                    .findAll()\r\n                    .asFlowable()\r\n            }\r\n            .subscribeOn(looperScheduler)\r\n            .unsubscribeOn(looperScheduler)\r\n            .doOnTerminate { Thread.currentThread().interrupt() }\r\n            .map { it.toList() }\r\n    }\r\n\r\n    fun queryFirstAsFlowable(query: RealmQuery<RO>.() -> Unit): Flowable<RO> {\r\n        logMethod(\"queryFirstAsFlowable\")\r\n        return Flowable\r\n            .defer {\r\n                realm.logNumberOfActiveVersions()\r\n                realm\r\n                    .where(realmObjectClass)\r\n                    .withQuery(query)\r\n                    .findFirst()\r\n                    ?.asFlowable<RO>()\r\n            }\r\n            .subscribeOn(looperScheduler)\r\n            .unsubscribeOn(looperScheduler)\r\n            .doOnTerminate { Thread.currentThread().interrupt() }\r\n    }\r\n\r\n    fun queryAsSingle(query: RealmQuery<RO>.() -> Unit): Single<List<RO>> {\r\n        logMethod(\"queryAsSingle\")\r\n        return Single\r\n            .defer {\r\n                realm.logNumberOfActiveVersions()\r\n                realm\r\n                    .where(realmObjectClass)\r\n                    .withQuery(query)\r\n                    .findAll()\r\n                    .asFlowable()\r\n                    .firstOrError()\r\n            }\r\n            .subscribeOn(looperScheduler)\r\n            .unsubscribeOn(looperScheduler)\r\n            .doOnDispose { Thread.currentThread().interrupt() }\r\n            .map { it.toList() }\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ DELETE\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    fun deleteAllObjectsOfType() {\r\n        logMethod(\"deleteAllObjectsOfType\")\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.logNumberOfActiveVersions()\r\n            realm.executeTransactionAsync {\r\n                it.delete(realmObjectClass)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun deleteByQuery(query: RealmQuery<RO>.() -> Unit) {\r\n        logMethod(\"deleteByQuery\")\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.logNumberOfActiveVersions()\r\n            realm\r\n                .where(realmObjectClass)\r\n                .withQuery(query)\r\n                .findAllAsync()\r\n                .deleteAllFromRealm()\r\n        }\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    \/\/ HELPER\r\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    private fun <T> T.withQuery(block: (T) -> Unit): T {\r\n        block(this); return this\r\n    }\r\n\r\n    private fun Realm.logNumberOfActiveVersions() {\r\n        if (DO_LOG) Timber\r\n            .tag(realmObjectClass.simpleName + \" realm\")\r\n            .d(\"${this.numberOfActiveVersions} instance in thread : ${Thread.currentThread().name}\")\r\n    }\r\n\r\n    private fun logMethod(methodName: String) {\r\n        if (DO_LOG) Timber\r\n            .tag(realmObjectClass.simpleName + \" method\")\r\n            .d(\"$methodName call in thread : ${Thread.currentThread().name}\")\r\n    }\r\n}\r\n```\r\n\r\nI just activate adding  ndk.debugSymbolLevel \"FULL\" in my build.gradle, but have not yet result.\r\nNothing else I can do ?\r\nDo you have any idea ? Or advise to help me understand the stack ?\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s):  10.4.0\r\n\r\nRealm Sync feature enabled: No\r\n\r\nAndroid Studio version: 4.2\r\n\r\nAndroid Build Tools version: 4.1.3\r\n\r\nGradle version: 6.8.3\r\n\r\nWhich Android version and device(s):  mainly chinese phones : Huawei, Honor...\r\n","comments":["Sorry for the late reply. This is the unrolled stack trace:\r\n```\r\n********** Crash dump: **********\r\n#00 0x0000000000419c40 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000)\r\n                                                                                                                                long realm::Array::get_universal<16ul>(char const*, unsigned long) const\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/array.hpp:1162:16\r\n                                                                                                                                long realm::Array::get<16ul>(unsigned long) const\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/array.hpp:1136:12\r\n#00 0x000000000038a2d4 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000)\r\n                                                                                                                                realm::Array::get(unsigned long) const\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/array.hpp:859:12\r\n#00 0x000000000043d1d0 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000)\r\n                                                                                                                                realm::Array::get_as_ref_or_tagged(unsigned long) const\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/array.hpp:899:24\r\n                                                                                                                                realm::Group::create_table_accessor(unsigned long)\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/group.cpp:929:32\r\n#00 0x000000000032f25c \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/split_config.arm64_v8a.apk!lib\/arm64-v8a\/librealm-jni.so (offset 0x11e000) (Java_io_realm_internal_Table_nativeFreeze+456)\r\n                                                                                                                                realm::Group::do_get_table(unsigned long)\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/group.cpp:829:21\r\n                                                                                                                                realm::Group::get_table(realm::TableKey)\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/group.hpp:991:20\r\n                                                                                                                                realm::Transaction::import_copy_of(realm::ConstTableRef)\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/db.cpp:2633:12\r\n                                                                                                                                auto realm::Realm::import_copy_of<realm::TableRef&>(realm::TableRef&)\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/realm-core\/src\/realm\/object-store\/shared_realm.hpp:390:30\r\n                                                                                                                                Java_io_realm_internal_Table_nativeFreeze\r\n                                                                                                                                \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Table.cpp:971:57\r\n#00 0x000000000016b720 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.odex (art_jni_trampoline+160)\r\n#00 0x00000000001445b8 \/apex\/com.android.runtime\/lib64\/libart.so (art_quick_invoke_static_stub+568)\r\n#00 0x00000000001531c4 \/apex\/com.android.runtime\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+284)\r\n#00 0x00000000002ee6d8 \/apex\/com.android.runtime\/lib64\/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+384)\r\n#00 0x00000000002e99a8 \/apex\/com.android.runtime\/lib64\/libart.so (bool art::interpreter::DoCall<false, false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, art::JValue*)+912)\r\n#00 0x00000000005bde3c \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeStatic+368)\r\n#00 0x000000000013e994 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_static+20)\r\n#00 0x0000000000c36c60 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.internal.Table.freeze+28)\r\n#00 0x00000000005c17ac \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n#00 0x0000000000142594 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n#00 0x0000000000c329e0 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.internal.OsResults.freeze+8)\r\n#00 0x00000000005c17ac \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n#00 0x0000000000142594 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n#00 0x0000000000c03000 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.RealmResults.freeze+32)\r\n#00 0x00000000005c17ac \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n#00 0x0000000000142594 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n#00 0x0000000000c415e0 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.realm.rx.RealmObservableFactory$6.subscribe+128)\r\n#00 0x00000000005bcd94 \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeInterface+1752)\r\n#00 0x000000000013ea14 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_interface+20)\r\n#00 0x0000000000bdb55c \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.internal.operators.flowable.FlowableCreate.J+120)\r\n#00 0x00000000005c17ac \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n#00 0x0000000000142594 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n#00 0x0000000000bd4db8 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.Flowable.I+28)\r\n#00 0x00000000005c17ac \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeVirtualQuick+1368)\r\n#00 0x0000000000142594 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_virtual_quick+20)\r\n#00 0x0000000000bd4e14 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.Flowable.a+12)\r\n#00 0x00000000005bcd94 \/apex\/com.android.runtime\/lib64\/libart.so (MterpInvokeInterface+1752)\r\n#00 0x000000000013ea14 \/apex\/com.android.runtime\/lib64\/libart.so (mterp_op_invoke_interface+20)\r\n#00 0x0000000000bdeea4 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.vdex (io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run+24)\r\n#00 0x00000000002bf314 \/apex\/com.android.runtime\/lib64\/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame&, art::JValue, bool, bool) (.llvm.17950311261770437987)+240)\r\n#00 0x00000000005a6470 \/apex\/com.android.runtime\/lib64\/libart.so (artQuickToInterpreterBridge+1012)\r\n#00 0x000000000014d468 \/apex\/com.android.runtime\/lib64\/libart.so (art_quick_to_interpreter_bridge+88)\r\n#00 0x0000000000493ea8 \/data\/app\/com.foo.bar-ufZXOINUM9h8MHdoBa7WvA==\/oat\/arm64\/base.odex (io.reactivex.android.schedulers.HandlerScheduler$ScheduledRunnable.run+72)\r\n#00 0x00000000008a730c \/system\/framework\/arm64\/boot-framework.oat (android.os.Handler.dispatchMessage+76)\r\n#00 0x00000000008aa960 \/system\/framework\/arm64\/boot-framework.oat (android.os.Looper.loop+1456)\r\n#00 0x00000000008a9380 \/system\/framework\/arm64\/boot-framework.oat (android.os.HandlerThread.run+576)\r\n#00 0x0000000000144334 \/apex\/com.android.runtime\/lib64\/libart.so (art_quick_invoke_stub+548)\r\n#00 0x00000000001531a4 \/apex\/com.android.runtime\/lib64\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+252)\r\n#00 0x00000000004c6ec0 \/apex\/com.android.runtime\/lib64\/libart.so (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const&, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+104)\r\n#00 0x00000000004c7f54 \/apex\/com.android.runtime\/lib64\/libart.so (art::InvokeVirtualOrInterfaceWithJValues(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, _jmethodID*, jvalue const*)+416)\r\n#00 0x0000000000507f24 \/apex\/com.android.runtime\/lib64\/libart.so (art::Thread::CreateCallback(void*)+1176)\r\n#00 0x00000000000ce1c0 \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__pthread_start(void*)+36)\r\n#00 0x0000000000070ba8 \/apex\/com.android.runtime\/lib64\/bionic\/libc.so (__start_thread+64)\r\n```","Do you have the exact error message as well? It is unclear exactly what type of error is happening here.","It is probably a segmentation fault. That is about the only error that can occur at this place. Could it be that the `SharedRealm` that is used in `Java_io_realm_internal_Table_nativeFreeze` is somehow stale?"],"labels":["Reproduction-Required","O-Community"]},{"title":"executeTransaction() throws NullPointerException","body":"#### Goal\r\n\r\nCalling `Realm#executeTransaction()` and `DynamicRealm#executeTransaction()` against closed instance throws `IllegalStateException` with message `This Realm instance has already been closed, making it unusable.`.\r\n\r\n`executeTransaction()` should call `checkIfValid()` before calling `checkAllowWritesOnUiThread()`.\r\n\r\n#### Actual Results\r\n\r\nGot java.lang.NullPointerException: Attempt to read from field 'io.realm.internal.Capabilities io.realm.internal.OsSharedRealm.capabilities' on a null object reference\r\n\r\n#### Steps & Code to Reproduce\r\n\r\nCalling `Realm#executeTransaction()` and `DynamicRealm#executeTransaction()` against closed Realm or DynamicRealm instance.\r\n\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s): 10.6.0\r\n\r\nRealm Sync feature enabled: both\r\n\r\nAndroid Studio version: ?\r\n\r\nAndroid Build Tools version: ?\r\n\r\nGradle version: ?\r\n\r\nWhich Android version and device(s): ?\r\n","comments":["Ups. Good catch \ud83d\udc4d ","@cmelchior DynamicRealm has the same issue https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/java\/io\/realm\/DynamicRealm.java#L301"],"labels":["O-Community"]},{"title":"Frozen Realm doesn't reference count correctly","body":"Creating new instances of an already-cached version doesn't increment the reference count, which causes closing frozen Realm instances to be non-deterministic. The following code works as expected:\r\n\r\n```kotlin\r\nval realm = Realm.getDefaultInstance()\r\n\r\n\/\/ Freeze the Realm\r\nval realm1 = realm.freeze()\r\n\/\/ Write to the live Realm, and freeze again\r\nrealm.executeTransaction { ... }\r\nval realm2 = realm.freeze()\r\n\r\n\/\/ Close the first frozen instance\r\nrealm1.close()\r\n\r\n\/\/ Make a query on the second frozen instance\r\nrealm2.where<...>().findAll().doSomething()\r\n\r\n\/\/ Clean up\r\nrealm2.close()\r\nrealm.close()\r\n```\r\n\r\nHowever, this code throws an `IllegalStateException` if the write operation doesn't happen between the two freeze operations:\r\n\r\n```kotlin\r\nval realm = Realm.getDefaultInstance()\r\n\r\n\/\/ Freeze the Realm\r\nval realm1 = realm.freeze()\r\n\/\/ Freeze a second time first, then write to the live Realm\r\nval realm2 = realm.freeze()\r\nrealm.executeTransaction { ... }\r\n\r\n\/\/ Close the first frozen instance.\r\nrealm1.close()\r\n\r\n\/\/ Make a query on the second frozen instance\r\n\/\/ Throws IllegalStateException, saying that realm2 is closed.\r\nrealm2.where<...>().findAll().doSomething()\r\n\r\n\/\/ Clean up\r\nrealm2.close()\r\nrealm.close()\r\n```\r\n\r\nIn a use-case where frozen RealmObjects\/RealmResults are being temporarily created and there are concurrent write transactions (which is for example very easy to achieve with Kotlin Coroutines), cleaning up frozen Realms rapidly becomes non-deterministic.\r\n\r\nThis PR attempts to fix the issue by making the reference-counting behaviour of frozen Realms match that of live Realms \u2013 that is, every Realm instance created with `Realm.freeze()` is active (and using resources) until `close()` is called on that instance.","comments":["@cla-bot check","Thank you for your pull request and welcome to our community. We could not parse the GitHub identity of the following contributors: **alecbarber**.\nThis is most likely caused by a git client misconfiguration; please make sure to:\n1. check if your git client is configured with an email to sign commits `git config --list | grep email`\n2. If not, set it up using `git config --global user.email email@example.com`\n3. Make sure that the git commit email is configured in your GitHub account settings, see https:\/\/github.com\/settings\/emails","The cla-bot has been summoned, and re-checked this pull request!"],"labels":["O-Community","cla: yes"]},{"title":"Using Java reserved keywords in Kotlin model classes result in property being ignored.","body":"#### Goal\r\n<!-- What do you want to achieve? -->\r\nIf `long` is a reserved keyword I would expect the build failure.\r\nIf not I would expect it is saved in the DB. \r\n\r\n#### Actual Results\r\n<!-- What happened? If an exception was thrown please copy\/paste the stack trace from Logcat. -->\r\nThe field with the name `long` is never saved in the DB.\r\n\r\n#### Steps & Code to Reproduce\r\n<!-- What steps resulted in the crash? Please show any relevant code or steps that can be used to -->\r\n<!-- reproduce it, including any Realm model classes used. Even better is a full sample project -->\r\n<!-- that can reproduce the crash. Code can be shared privately at help@realm.io if needed. -->\r\nI have class \r\n```\r\nopen class Location(\r\n  @PrimaryKey\r\n  var fakeID: Int = 1,\r\n  var lat: Double? = 0.0,\r\n  var long: Double? = 0.0\r\n) : RealmObject() {\r\n```\r\n\r\nSave it to DB and open DB with the Realm Studio:\r\n<img width=\"420\" alt=\"Screenshot 2021-06-01 at 19 00 31\" src=\"https:\/\/user-images.githubusercontent.com\/295424\/120363886-f0171300-c30c-11eb-85cd-fea67aa38e81.png\">\r\n\r\nChange class to:\r\n```\r\nopen class Location(\r\n  @PrimaryKey\r\n  var fakeID: Int = 1,\r\n  var lat: Double? = 0.0,\r\n  var longitude: Double? = 0.0\r\n) : RealmObject() {\r\n```\r\n\r\nSave it to DB and open with the Realm Studio:\r\n<img width=\"694\" alt=\"Screenshot 2021-06-01 at 19 00 15\" src=\"https:\/\/user-images.githubusercontent.com\/295424\/120364049-12109580-c30d-11eb-847e-fa180c018460.png\">\r\n\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s): 10.3.1\r\n\r\nRealm Sync feature enabled: No\r\n\r\nAndroid Studio version: Doesn't matter\r\n\r\nAndroid Build Tools version: 30.0.3\r\n\r\nGradle version: 7.0.2\r\n\r\nWhich Android version and device(s): Doesn't matter\r\n","comments":["Hmm, thank you for reporting this. We had the same problem in the past with another reserved keyword https:\/\/github.com\/realm\/realm-java\/issues\/6361. It is indeed surprising this doesn't cause the compilation to fail and as a minimum, we should fail the build and point to possible solutions.","Thank you for pointing out the old ticket. I draw my attention to check the generated code.\r\n\r\nHere is a bit of it:\r\n```\r\npublic class com_getsquire_entities_LocationRealmProxy extends com.getsquire.entities.Location\r\n    implements RealmObjectProxy, com_getsquire_entities_LocationRealmProxyInterface {\r\n\r\n    static final class LocationColumnInfo extends ColumnInfo {\r\n        long latColKey;\r\n\r\n        LocationColumnInfo(OsSchemaInfo schemaInfo) {\r\n            super(1);\r\n            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"Location\");\r\n            this.latColKey = addColumnDetails(\"lat\", \"lat\", objectSchemaInfo);\r\n        }\r\n....\r\n```\r\n\r\nBasically, `longitude` data is just missing from it. Probably your generator failed with code generation and silently skipped it.\r\n","The problem is with the annotation library"],"labels":["T-Bug","O-Community"]},{"title":"Possible to query embedded realm objects directly","body":"I [posted on Stackoverflow](https:\/\/stackoverflow.com\/questions\/66116874\/possible-to-query-embedded-realm-objects-directly-on-android-java) 3 months ago but haven't gotten a response.\n\nI migrated my Android app to Realm 10 recently in order to use the new embedded object functionalities (mainly cascade deleting). So, according to the official documentation: \"It is not possible to query embedded objects directly. Instead, access embedded objects through a query for the parent object type.\"\n\nHowever, I was able to migrate some of my realm objects to embedded without changing any queries and I don't get any compilation errors, nor failing queries or crashes, even though I have queries in my code where I retrieve (now) embedded objects directly. At the same time, on the iOS counterpart of the projects when the same realm objects where migrated to embedded those same queries were no longer compiling and needed to be reworked.\n\nSo my questions are:\n\nHave I misunderstood the documentation on that specific part?\n\nIs there an error in the documentation on that specific part?\n\nIs the \"not possible to query embedded objects directly\" part something that will be added soon and will prevent my app from working correctly in the future?\n\nHere is an example from my project of a working query accessing and embedded object directly:\n\n```\nAddressDbm address = realm.where(AddressDbm.class)\n        .equalTo(\"contacts.contactId\", contactId)\n        .equalTo(\"contacts.firstName\", firstName)\n        .equalTo(\"contacts.lastName\", lastName)\n        .findFirst();\n        \n```\n\nand the corresponding realm objects:\n\n```\nRealmClass(embedded = true)\npublic class ContactDbm extends RealmObject {\n```\n\n```\n    private String contactId;\n    private String firstName;\n    private String lastName;\n    RealmList<AddressDbm> addresses;\n}\n```\n\n```\n@RealmClass(embedded = true)\npublic class AddressDbm extends RealmObject {\n    private String streetName;\n```\n\n```\n    @LinkingObjects(\"addresses\")\n    private final RealmResults<ContactDbm> contacts = null;\n}\n\n```\n\nI even tried a query without using the reverse relationships and it still works, e.g.:\n\n```\nAddressDbm address = realm.where(AddressDbm.class)\n        .equalTo(\"streetName\", \"Washington blvd.\")\n        .findFirst();\n```\n\n#### Version of Realm and tooling\nRealm version(s): 10.0.1\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 4.1.2\n\nGradle version: 4.1.2\n\n","comments":["Hi @ionkoto \r\n\r\nThe Javadoc is correct in the sense that it was the semantics we had in mind. The reason was that Embeded Objects only live within the context of a parent so we was afraid that querying across them would cause confusion. But we made a bug in the implementation, actually allowing it, and I have seen a number of other people having use cases around. \r\n\r\nSo I would be tempted to just adjust the Javadoc to actually describe the current behaviour","Hi @cmelchior, thanks for your comment. Please let me know (with a comment here) when\/if you actually adjust the Javadoc to the current behaviour.  "],"labels":["O-Community"]},{"title":"Compacting Realm during getInstanceAsync causes listeners to stop working","body":"#### Goal\r\n\r\nWhen `Realm.compactRealm()` is called while Realm is being initialized (`Realm.getInstanceAsync()`), Realm is still opened, but no listeners get called afterwards.\r\n\r\n#### Actual Results\r\n\r\nI noticed this bug while using my application and, due to its services and compact workflow, I figured that compact could be the cause.\r\nSometimes, after an update, the application wouldn't show any data.\r\n\r\n#### Steps & Code to Reproduce\r\n\r\nI have created a simplified Android project to reproduce the issue:\r\nhttps:\/\/github.com\/jpmcosta\/RealmTestProject\/tree\/e6b69172f3d5f77c122468092cd672da869bb37f\r\n\r\nAfter opening the application, a list of items should be shown, but it is not. Plus, when the FAB is clicked, a new item should be created and added to the list, but that also doesn't happen.\r\n\r\nIt seems that there's an issue when something like this is called (and compact actually runs):\r\n```kotlin\r\nval realmAsyncTask = Realm.getInstanceAsync(realmConfiguration, realmCallback)\r\nRealm.compactRealm(realmConfiguration) \/\/ This is causing an issue.\r\n```\r\n\r\nWhile `realmAsyncTask` finishes successfully and Realm is opened, no listeners get called afterwards.\r\n\r\nThe way I could consistently reproduce the issue was to ensure that the Realm file was always recreated.\r\nOtherwise, the issue stops happening, probably because compact is not doing anything.\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s): 10.4.0\r\n\r\nRealm Sync feature enabled: No\r\n\r\nWhich Android version and device(s): API 29 (emulator)\r\n","comments":["Hi @jpmcosta Thank you very much. This does indeed sound like a bug. I suspect we have a race condition in our internal datastructures that somehow gets out of sync in this case.\r\n\r\n"],"labels":["O-Community"]},{"title":"Sets and dictionary iterators should use frozen versions.","body":"Because sets and dictionaries iterators work with live objects they are open to concurrent modification issues by the user, this could be solved by iterating over frozen versions instead.\n\n","comments":[],"labels":["gathering-interest"]},{"title":"How to convert realmobject to JSON","body":"\r\nMy requirement is to convert the information stored in realm into JSON, which can also be converted into realm data.\r\n\r\nBased on the above requirements, I can use that RealmResult.asJson Method to convert the data into a JSON string. The attempt to transfer out was successful. But the transferred JSON will be transferred out through realm.createAllFromJson  There was an exception when reading. The exception information is below:\r\n\r\n    io.realm.exceptions.RealmException: Failed to parse date [\"2020-03-29 22:24:01']: Invalid time zone indicator ' '\r\n        at io.realm.internal.android.JsonUtils.stringToDate(JsonUtils.java:72)\r\n\r\nThe problem is that realmobject has a date data and there seems to be no time zone information when it is transferred out. I don't know how to deal with this problem.","comments":["I was able to reproduce this. I will try to come up with the best fix without breaking existing behavour. I don't think that I have an easy workaround for this while waiting for the fix, so the immediate one would be to add the `Z` timezone to all timestamps with something like (fixed previously erroneous suggestion):\r\n```\r\nString fixed = json.replaceAll(\"(\\\\d{4}-\\\\d{2}-\\\\d{2}) (\\\\d{2}:\\\\d{2}:\\\\d{2})\", \"$1T$2Z\");\r\n```\r\n"],"labels":["O-Community"]},{"title":"Refactor RealmFieldType","body":"Currently, the `RealmFieldType` class is an enum that enumerates all possible supported field types. This makes it easy to iterate and access the types but isn't really scalable. https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/java\/io\/realm\/RealmFieldType.java\r\n\r\nEspecially with the introduction of new collection types, the number of combinations explodes and as soon as we support multiple key types for Maps, the approach breaks down completely.\r\n\r\nInstead, we should refactor the class to mimic the bitmask already found at the C++ layer. If we keep the static constants for primitive types, I believe it should be possible to refactor the API with minimal breaking changes to user (but there will be some).\r\n\r\nA proposal could be something like this:\r\n\r\n```\r\nclass RealmFieldType extends Number {\r\n\r\n    public enum Type {\r\n        INTEGER,\r\n        BOOLEAN,\r\n        STRING,\r\n        BYTE_ARRAY,\r\n        DATE,\r\n        FLOAT,\r\n        DOUBLE,\r\n        OBJECT_LINK,\r\n        LINKING_OBJECTS,\r\n        MIXED,\r\n        OBJECT_ID,\r\n        DECIMAL128,\r\n        UUID\r\n    }\r\n\r\n    private enum Collection {\r\n        NONE,\r\n        LIST,\r\n        SET,\r\n        MAP\r\n    }\r\n\r\n    private enum Nullability {\r\n        NULLABLE,\r\n        REQUIRED\r\n    }\r\n\r\n    \/\/\/ Constants for the primitive types\r\n    public static final int INTEGER = new RealmFieldType(Int);\r\n    public static final int BOOLEAN = new RealmFieldType(Bool);\r\n    public static final int STRING = new RealmFieldType(String);\r\n    public static final int BINARY = new RealmFieldType(Data);\r\n    public static final int DATE = new RealmFieldType(Date);\r\n    public static final int FLOAT = new RealmFieldType(Float);\r\n\r\n    private static final int Int = 0;\r\n    private static final int Bool = 1;\r\n    private static final int String = 2;\r\n    private static final int Data = 3;\r\n    private static final int Date = 4;\r\n    private static final int Float = 5;\r\n    private static final int Double = 6;\r\n    private static final int Object = 7; \/\/ currently must be either Array xor Nullable\r\n    private static final int LinkingObjects = 8; \/\/ currently must be Array and not Nullable\r\n    private static final int Mixed = 9;\r\n    private static final int ObjectId = 10;\r\n    private static final int Decimal128 = 11;\r\n    private static final int UUID = 12;\r\n\r\n    private static final int Required = 0;\r\n    private static final int Nullable = 64;\r\n    private static final int Array = 128;\r\n    private static final int Set = 256;\r\n    private static final int Dictionary = 512;\r\n\r\n    private static final int Collection = Array | Set | Dictionary;\r\n\r\n    private final int value;\r\n\r\n    private RealmFieldType(int value) { this.value = value; }\r\n\r\n    public boolean isCollection() { return (value | Collection) == Collection; }\r\n    public boolean isNullable() { return (value | Nullable) == Nullable; }\r\n\r\n    public Nullability getNullability() { }\r\n    public Collection getCollectionType() { }\r\n    public Collection getPropertyType() { }\r\n\r\n    @Override public int intValue() {\r\n        return value;\r\n    }\r\n    @Override public long longValue() {\r\n        return value;\r\n    }\r\n    @Override public float floatValue() {\r\n        return value;\r\n    }\r\n    @Override public double doubleValue() {\r\n        return value;\r\n    }\r\n}\r\n```\r\n\r\n\r\n","comments":["We should also take into consideration how to handle testing, more specifically how we handle different data types in the `AllTypes` class - see https:\/\/github.com\/realm\/realm-java\/pull\/7323\/files#r586315003 for more context on this.","Include the way `RealmObjectSchema` handles data types too - see https:\/\/github.com\/realm\/realm-java\/pull\/7343#discussion_r594137565","Include enums in `SetSupportedType` once sets are merged: https:\/\/github.com\/realm\/realm-java\/pull\/7357#discussion_r597217437"],"labels":["T-Enhancement"]},{"title":"Support Kotlin Symbol Processing (KSP)","body":"#### Describe your problem or use case\r\n<!-- A clear and concise description of what the problem is and what you are trying to accomplish. -->\r\n[Kotlin Symbol Processing (KSP)](https:\/\/github.com\/google\/ksp) is a joint effort by Google & JetBrains and seeks to provide an API for building compiler plugins. Compared to KAPT, annotation processors that use KSP can run up to 2x faster.\r\n\r\n#### Describe the solution you'd like\r\n<!-- A clear and concise description of how you think a solution could look like. -->\r\nIntroduce a sibling artifact to the `realm-annotations-processor` which leverages the performance and benefits of KSP over KAPT for Kotlin-based projects.","comments":["@mannodermaus Thanks for the input. We are aware that KSP has been promoted to alpha, but have not yet evaluated\/looked into replacing the current Realm annotation processor for Kotlin with it. ","Just FYI, KSP is now stable!\ud83d\udc40 \r\n\r\nhttps:\/\/android-developers.googleblog.com\/2021\/09\/accelerated-kotlin-build-times-with.html","FWIW I was trying to help out here and look into a potential migration to KSP as an external contribution, but frankly I was unable to get Realm compiled on my machine. \ud83d\ude48 Is there a rough roadmap or guidance of Realm regarding this feature?","The Realm Kotlin SDK exists now. Is it safe to assume that KSP wouldn't be added for the older Java SDK, esp. since the new one seems to be built as a compiler plugin instead?","Yes, we do not have any immediate plans to rewrite the code generation parts of realm-java with KSP. KSP would only work for Kotlin code and doesn't support transforming existing code, so wouldn't suffice for our full use case. This is also why we use compiler plugins in realm-kotlin.","Heyoooo <3 any updates on this front? Just curious as we are moving our entire project over to ksp and the last bit is the realm of it all.\r\nNot meant to be a pressure or pain, just curious if this work (realm to ksp instead of kapt) is going to happen at some point in the future?\r\n\r\nJust for reference, i changed our module containing realm into ksp and got this error, after searching on the net i found that the underlying generation uses kapt, which led me here :) \r\n```\r\nAn exception occurred applying plugin request [id: 'realm-android']\r\n> Failed to apply plugin 'realm-android'.\r\n   > Configuration with name 'kapt' not found.\r\n```\r\n\r\nFor now the android docs say kapt and ksp can run in parralel together so ill add kapt plugin back to this module and keep an eye on this issue <3\r\n\r\nThank you all btw for your amazing work on realm, just needed to be said <3"],"labels":["O-Community"]},{"title":"RealmFileException: Unable to open a realm at path","body":"#### Goal\r\nOpen a realm database\r\n\r\n#### Actual Results\r\nIn a few devices, Realm cannot initialize the file and it throws an exception:\r\n\r\n```\r\nFatal Exception: io.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/user\/0\/my.package.name\/files\/default.realm': Realm file initial open failed Path:Exception backtrace:\r\n<backtrace not supported on this platform>. (Realm file initial open failed Path: \/data\/user\/0\/my.package.name\/files\/default.realm\r\nException backtrace:\r\n<backtrace not supported on this platform>) (\/data\/user\/0\/my.package.name\/files\/default.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n       at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java)\r\n       at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:173)\r\n       at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:249)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:138)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:105)\r\n       at io.realm.Realm.<init>(Realm.java:159)\r\n       at io.realm.Realm.createInstance(Realm.java:495)\r\n       at io.realm.RealmCache.createInstance(RealmCache.java:481)\r\n       at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:448)\r\n       at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:412)\r\n       at io.realm.Realm.getDefaultInstance(Realm.java:403)\r\n```\r\n\r\n#### Steps & Code to Reproduce\r\nI cannot replicate the problem. I have the crash reports from open test users.\r\nThis is how I initialize the DB in the app\r\n\r\n```\r\n       Realm.init(this)\r\n       val realmConfiguration = RealmConfiguration.Builder()\r\n                .encryptionKey(....)\r\n                .assetFile(\"database\/deploy.realm\")\r\n                .build()\r\n\r\n        Realm.setDefaultConfiguration(realmConfiguration)\r\n```\r\n\r\nThen, later, the first time I do\r\n`Realm.getDefaultInstance()`\r\nit crashes for some users.\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s): 10.3.1\r\n\r\nRealm Sync feature enabled: No\r\n\r\nAndroid Studio version: 4.1.2\r\n\r\nAndroid Build Tools version: 4.1.2\r\n\r\nGradle version: 6.8.1\r\n\r\nWhich Android version and device(s): \r\nat the moment it happened on different Samsung models with Android 10\r\nAffected users are about 0.3% of the open tests user base\r\n","comments":["Thanks for reporting the issue, we are currently investigating it.\r\n\r\nAre the affected users not able to use the app, or are these random crashes?","They can't use the app, because those who are having this problem are having it every time the app tries to open the DB.\r\nI also tried to wrap the opening in a try\/catch block, and try again, but the result is the same.\r\n\r\nThe Init block is in the Application OnCreate function.","@vernazza Does the issue happen on fresh installs\/reinstalls or are they ending up there after a while? \r\n\r\nIf on fresh installs would you be able to list the exact devices it is happening on? \r\nOr if after a while would you be able to get hold of a realm file exhibiting this behavior?","Actually they are not fresh installs, but before that version, realm was not used, so it's the first time that those users use realm.\r\n\r\nThe problem seems to be on the creation of the DB file.\r\n\r\nThe devices that had the problems are Samsung Galaxy A51, Samsung Galaxy S9, Huaweu JNY-LX1. All 3 are Android 10","Are you by any chance able to get a realm file from a device where this happens are able to share it or open it on a local device? And do you know whether it reoccurs if the app is uninstalled and installed again?  ","Update.\r\nThe devices where I'm getting the problem are:\r\n56% android 10,\r\n43% android 9\r\n1% Android 7\r\n\r\nModels:\r\n- Samsung Galaxy a51\r\n- Samsung Galaxy S9\r\n- Samsung Galaxy S8+\r\n- Samsung Galaxy S8\r\n- Samsung Galaxy A10\r\n- Huawey JNY-LX1\r\n- A-gold F1\r\n\r\nSo, it doesn't seem to be related to a specific vendor or to a specific OS\r\n\r\n","Sorry, where it happens the DB is not created, so there is nothing to retrieve.\r\nAnyway, I could not replicate the problem and I have only the crash reports, so I don't know if uninstalling fixes the problem.","I have been getting the same exception since migrating to realm 10.3.0\r\n\r\n**Implementation**\r\n\r\n```\r\nclass App : Application() {   \r\n     override fun onCreate() {\r\n        super.onCreate()\r\n    \r\n      val realmConfiguration: RealmConfiguration = RealmConfiguration.Builder()\r\n                  .name(App.instance.getString(R.string.app_name))\r\n                  .schemaVersion(1)\r\n                  .deleteRealmIfMigrationNeeded()\r\n                  .build()\r\n                  \r\n           Realm.init(this)\r\n           Realm.setDefaultConfiguration(realmConfiguration)\r\n    }\r\n}\r\n```\r\n\r\n**Calling Function**\r\n\r\n```\r\n    \/\/ update cart with latest values\r\n    private fun updateLocalCart(updatedCart: Cart) {\r\n        Realm.getDefaultInstance().use { realm ->\r\n            realm.executeTransaction { r->\r\n                val c = r.where<Cart>().findFirst()\r\n                c?.orderItems?.apply {\r\n                    clear()\r\n                    addAll(updatedCart.orderItems)\r\n                }\r\n\r\n                c?.totalAmount = updatedCart.totalAmount\r\n\r\n                val totalItems = c?.orderItems?.size ?: 0\r\n\r\n                cartValue.postValue(Pair(totalItems, c?.totalAmount ?: 0.0))\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n**Full trace** \r\n\r\n```\r\nFatal Exception: io.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/user\/0\/com.company.app\/files\/AppName': Realm file initial open failed Path:Exception backtrace:\r\n<backtrace not supported on this platform>. (Realm file initial open failed Path: \/data\/user\/0\/com.company.app\/files\/AppName\r\nException backtrace:\r\n<backtrace not supported on this platform>) (\/data\/user\/0\/com.company.app\/files\/AppName) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n       at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java)\r\n       at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:8)\r\n       at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:2)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:12)\r\n       at io.realm.Realm.<init>(Realm.java:4)\r\n       at io.realm.Realm.createInstance(Realm.java:14)\r\n       at io.realm.RealmCache.createInstance(RealmCache.java:14)\r\n       at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:14)\r\n       at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:14)\r\n       at io.realm.Realm.getDefaultInstance(Realm.java:2)\r\n       at com.company.app.ui.fragment.cart.CartViewModel.updateLocalCart(CartViewModel.java:1)\r\n       at com.company.app.ui.fragment.cart.CartViewModel$getCart$1.invokeSuspend(CartViewModel.java:10)\r\n       at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(BaseContinuationImpl.java:2)\r\n       at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.java)\r\n       at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.java)\r\n       at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.java:5)\r\n```\r\n\r\n**Affected devices**\r\nLenovo, Huawei, Oppo, Infinix Mobility\r\n\r\n**Affected OSes**\r\n\r\nAndroid 5.1.1(29%), 9(14%) and 7(57%)\r\n\r\n**Tooling**\r\n\r\n- Gradle 6.5\r\n- Realm 10.3.0\r\n- Realm Sync feature enabled: No\r\n- Android Studio version: 4.1.2\r\n- Android Build Tools version: 4.1.2\r\n\r\nThis is happenning in production and I'm yet to reproduce it on debug.\r\n\r\n+++ Our users have reported that the app works if they uninstall and reinstall","Hello @adhiamboperes. Just out of curiosity: you mention you started seeing this crash after migrating to 10.3.1. Which version did you migrate from? And to be 100% sure, you were and are not using encryption in the database, right?","I am seeing this in v10.3.0. i updated from realm v10.2.0 @edualonso \r\n","It seems that the problem is related to an incomplete DB while copying from the assets.\r\nI didn't have a chance to get a corrupted file, but I added some logs to check the file size and I see that it's smaller than the deployed one (I'm not deleting data from the DB, so it can't be smaller).\r\n\r\nI solved my problem like this:\r\n\r\n```\r\n   fun getRealmDefaultInstance(): Realm {\r\n        return try {\r\n            Realm.getDefaultInstance()\r\n        } catch (e: io.realm.exceptions.RealmFileException) {            \r\n            \/\/The file is probably malformed. Delete it and try again\r\n            Realm.getDefaultConfiguration()?.let{Realm.deleteRealm(it)}\r\n            Realm.getDefaultInstance()\r\n        }\r\n    }\r\n```\r\n\r\nand calling this instead of `Realm.GetDefaultInstance()`\r\n\r\nBTW, I also tried reverting to Realm 10.0.0 and I kept getting the problem.","Thanks @vernazza , I'll try this fix and update if it helps","Reproduced today. Crash happened in production and probably on the fresh install.\r\n\r\nRealm version: 10.3.1\r\nRealm Sync feature enabled: No\r\nAndroid Studio version: 4.2\r\nbuildToolsVersion: 30.0.2\r\nGradle version: 6.8\r\n\r\nDevice: OUKITEL WP7, Android 9\r\n\r\ninit process:\r\n```\r\nRealm.init(this)\r\n...\r\nval configuration = RealmConfiguration.Builder()\r\n  .schemaVersion(..)\r\n  .migration(..)\r\n  .name(Realm.DEFAULT_REALM_NAME)\r\n  .build()\r\nval realm = Realm.getInstance(configuration)\r\n```","@clementetb  i am also facing this issue \r\n\r\n`Unable to open a realm at path '\/data\/user\/0\/com.bloomer.alaWad3k\/files\/conetent_db\/Db83.realm': Realm file initial open failed: Top ref outside file (size = 1081344). top_ref[0]: FFFFFFFFFFFFFFFF, top_ref[1]: 4088E8, mnemonic: 54 2D 44 42, fmt[0]: 22, fmt[1]: 22, flags: 1 Path:Exception backtrace: <backtrace not supported on this platform> Path: \/data\/user\/0\/com.bloomer.alaWad3k\/files\/conetent_db\/Db83.realm Exception backtrace: <backtrace not supported on this platform>. (Realm file initial open failed: Top ref outside file (size = 1081344). top_ref[0]: FFFFFFFFFFFFFFFF, top_ref[1]: 4088E8, mnemonic: 54 2D 44 42, fmt[0]: 22, fmt[1]: 22, flags: 1 Path: \/data\/user\/0\/com.bloomer.alaWad3k\/files\/conetent_db\/Db83.realm Exception backtrace: <backtrace not supported on this platform> Path: \/data\/user\/0\/com.bloomer.alaWad3k\/files\/conetent_db\/Db83.realm Exception backtrace: <backtrace not supported on this platform>) (\/data\/user\/0\/com.bloomer.alaWad3k\/files\/conetent_db\/Db83.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107`","@mahmoudElfeel67 This is not the same issue. Please create another github issue. Thanks!","@adhiamboperes\r\n\r\nI am reading your snippet and I noticed that on your `Application` constructor you call `Realm.init()` after building the configuration, that should not be even possible, as it would throw an `IllegalStateException(\"Call Realm.init(Context) before creating a RealmConfiguration\")`.\r\n\r\nIs that App initialization code triggered at all?","Having the same issue. The realm file turns into a malformed file for some reason randomly. Couldnt Find the real cause.\r\n\r\nRealm Version: 10.10.1\r\n\r\nCan the realm malformation happen if the user left the process while the realm transaction occurs? \r\n\r\n`Unable to start activity ComponentInfo{com.ertech.daynote\/com.ertech.daynote.Activities.MainActivity}: io.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/user\/0\/com.ertech.daynote\/files\/default.realm': Invalid top array size (ref: 120512, size: 0) Path:Exception backtrace: <backtrace not supported on this platform>. (Invalid top array size (ref: 120512, size: 0) Path: \/data\/user\/0\/com.ertech.daynote\/files\/default.realm Exception backtrace: <backtrace not supported on this platform>) (\/data\/user\/0\/com.ertech.daynote\/files\/default.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 106 Kind: ACCESS_ERROR.\r\n`\r\n```\r\nio.realm.internal.OsSharedRealm.nativeGetSharedRealm (OsSharedRealm.java)\r\nio.realm.internal.OsSharedRealm.<init> (OsSharedRealm.java:175)\r\nio.realm.internal.OsSharedRealm.getInstance (OsSharedRealm.java:251)\r\nio.realm.BaseRealm.<init> (BaseRealm.java:141)\r\nio.realm.BaseRealm.<init> (BaseRealm.java:108)\r\nio.realm.Realm.<init> (Realm.java:159)\r\nio.realm.Realm.createInstance (Realm.java:495)\r\nio.realm.RealmCache.createInstance (RealmCache.java:494)\r\nio.realm.RealmCache.doCreateRealmOrGetFromCache (RealmCache.java:461)\r\nio.realm.RealmCache.createRealmOrGetFromCache (RealmCache.java:422)\r\nio.realm.Realm.getInstance (Realm.java:424)\r\n```","Realm 10.10.1\r\nAndroid Gradle Plugin Version 7.3.0-alpha07\r\nGradle Version 7.4.1\r\nsame problem crash because Realm.init(this)\r\n```kotlin\r\nD\/AndroidRuntime: Shutting down VM\r\nE\/AndroidRuntime: FATAL EXCEPTION: main\r\n    Process: com.coolme.me.square18, PID: 11723\r\n    java.lang.ExceptionInInitializerError: RealmTransformer doesn't seem to be applied. Please update the project configuration to use the Realm Gradle plugin. See https:\/\/docs.mongodb.com\/realm\/sdk\/android\/install\/#customize-dependecies-defined-by-the-realm-gradle-plugin\r\n        at io.realm.RealmConfiguration.<clinit>(RealmConfiguration.java:80)\r\n        at io.realm.RealmConfiguration.access$000(RealmConfiguration.java:68)\r\n        at io.realm.RealmConfiguration$Builder.initializeBuilder(RealmConfiguration.java:552)\r\n        at io.realm.RealmConfiguration$Builder.<init>(RealmConfiguration.java:538)\r\n        at io.realm.Realm.initializeRealm(Realm.java:320)\r\n        at io.realm.Realm.init(Realm.java:261)\r\n        at com.coolme.me.square18.MyApplication.onCreate(MyApplication.kt:15)\r\n        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1223)\r\n        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6734)\r\n        at android.app.ActivityThread.access$1500(ActivityThread.java:256)\r\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2090)\r\n        at android.os.Handler.dispatchMessage(Handler.java:106)\r\n        at android.os.Looper.loopOnce(Looper.java:201)\r\n        at android.os.Looper.loop(Looper.java:288)\r\n        at android.app.ActivityThread.main(ActivityThread.java:7842)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1003)\r\nI\/Process: Sending signal. PID: 11723 SIG: 9\r\n```","I found the solution: Use Kotlin SDK instead of Java SDK\r\nhttps:\/\/www.mongodb.com\/docs\/realm\/sdk\/kotlin\/install\/android\/\r\nhere is the document\r\neven work with hilt\r\n\u263a\u263a\u263a\u263a\ud83d\ude00\ud83d\ude00\ud83d\ude00","Hint - 99% crashes are heppening in the background only, when workmanger is getting triggered. \r\nalso it is happening only devices which are android-9 or above.","Hi,\r\n\r\nI was debugging my app and I just bumped in what seems to be the same issue.\r\n\r\n`\r\nio.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/user\/0\/it.intesys.dolomitisuperski\/files\/default.realm': Realm file initial open failed: Top ref outside file (size = 7376896). top_ref[0]: 30315000000E0F8, top_ref[1]: 46020200, mnemonic: 54 2D 44 42, fmt[0]: 22, fmt[1]: 22, flags: 1\r\n`\r\n\r\nThe application was working just fine, did a few changes **not Realm reladed** to the code and suddenly it started throwing this error.\r\nI do have a copy of the broken .realm file, if that can be helpful in anyway. I didn't manage to open that file in any way, not even with Realm Studio\/Mongo DB Realm Studio.\r\nI'm not sure I'll be able to replicate the issue tho, I need to uninstall the app and proceed further with the development now.\r\n\r\nIt's an Android application in Kotlin and:\r\n`classpath \"io.realm:realm-gradle-plugin:10.8.0\"`\r\n\r\nLet me know if I can help in any way with the debug.\r\n\r\nKind regards,\r\nAlessandro","I am running into this issue on Android(The app is ReactNative), iOS works fine. We get the following exception. This is happening mostly on Samsung devices. \r\n```\r\nUnable to open a realm at path '\/data\/user\/0\/com.example.app\/files\/app.realm': Realm file initial open failed: Top ref outside file (size = 36388864). top_ref[0]: FFFFFFFFFFFFFFFF, top_ref[1]: 3368860, mnemonic: 54 2D 44 42, fmt[0]: 9, fmt[1]: 9, flags: 1\r\n```\r\nWhen I split the Realm file(using the split command) and only use the first part I get a similar crash as above. I think this points to the Realm file not being copied properly. This is happening to quite a lot of users. On Android, the assets are compressed by default so I think that might be interfering with the copying process. ","Hi @susonthapa. This repository is for `realm-java`. If you use `realm-js` with ReactNative then please report your issues at https:\/\/github.com\/realm\/realm-js. ","Caused by io.realm.exceptions.RealmFileException\r\nUnable to open a realm at path '\/data\/user\/0\/app.quizpatenteonline.quizpatenteb2018pertutti\/files\/realm_encrypt.realm': Realm file decryption failed Path:Exception backtrace: <backtrace not supported on this platform>. (Realm file decryption failed Path: \/data\/user\/0\/app.quizpatenteonline.quizpatenteb2018pertutti\/files\/realm_encrypt.realm Exception backtrace: <backtrace not supported on this platform>) (\/data\/user\/0\/app.quizpatenteonline.quizpatenteb2018pertutti\/files\/realm_encrypt.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n\r\nif anyone got the solution , please help me to get myself out of it. Thanks\r\n","In my case, I identified the root cause of the issue as the version of the Android application being used by our users, which was 1.0.1. Upon attempting to update to the newer version 1.0.2, I encountered an issue with realm encryption file access. While reviewing the changes I had made, I realized that I had modified the application name from 'x' to 'y'. This change impacted the encryption key generated from KeyPairGeneratorSpec, which was based on the application name. To resolve the issue, I re-added the previous application name for key pair generation, in addition to other feature changes made in the application. This successfully resolved the issue with realm encryption file access.","actually i am also getting error on update , when user update the app from playstore it get crash . while uninstalling the previous and installing the new one went well, app name is same for both the versions\r\n","I'm facing the same issue by now:\r\n\r\n`\r\nCaused by io.realm.exceptions.RealmFileException: Failed to open Realm file at path '\/data\/user\/0\/<APP_ID>\/files\/default.realm': Realm file decryption failed (Decryption failed: 'unable to decrypt after 0 seconds (retry_count=4, from=i != bytes_read, size=4096)') (\/data\/user\/0\/<APP_ID>\/files\/default.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\r\n       at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java)\r\n       at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:175)\r\n       at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:260)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:142)\r\n       at io.realm.BaseRealm.<init>(BaseRealm.java:109)\r\n       at io.realm.Realm.<init>(Realm.java:161)\r\n       at io.realm.Realm.createInstance(Realm.java:535)\r\n       at io.realm.RealmCache.createInstance(RealmCache.java:508)\r\n       at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:461)\r\n       at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422)\r\n       at io.realm.Realm.getDefaultInstance(Realm.java:443)\r\n`","> I'm facing the same issue by now:\r\n> \r\n> `Caused by io.realm.exceptions.RealmFileException: Failed to open Realm file at path '\/data\/user\/0\/<APP_ID>\/files\/default.realm': Realm file decryption failed (Decryption failed: 'unable to decrypt after 0 seconds (retry_count=4, from=i != bytes_read, size=4096)') (\/data\/user\/0\/<APP_ID>\/files\/default.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107 at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java) at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:175) at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:260) at io.realm.BaseRealm.<init>(BaseRealm.java:142) at io.realm.BaseRealm.<init>(BaseRealm.java:109) at io.realm.Realm.<init>(Realm.java:161) at io.realm.Realm.createInstance(Realm.java:535) at io.realm.RealmCache.createInstance(RealmCache.java:508) at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:461) at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422) at io.realm.Realm.getDefaultInstance(Realm.java:443)`\r\n\r\nCan you check by any chance if you updated your app name?\r\nIn my case, the app name was part of my encryption key and when I changed the app name it was failing.","> > I'm facing the same issue by now:\r\n> > `Caused by io.realm.exceptions.RealmFileException: Failed to open Realm file at path '\/data\/user\/0\/<APP_ID>\/files\/default.realm': Realm file decryption failed (Decryption failed: 'unable to decrypt after 0 seconds (retry_count=4, from=i != bytes_read, size=4096)') (\/data\/user\/0\/<APP_ID>\/files\/default.realm) in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107 at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(OsSharedRealm.java) at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:175) at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:260) at io.realm.BaseRealm.<init>(BaseRealm.java:142) at io.realm.BaseRealm.<init>(BaseRealm.java:109) at io.realm.Realm.<init>(Realm.java:161) at io.realm.Realm.createInstance(Realm.java:535) at io.realm.RealmCache.createInstance(RealmCache.java:508) at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:461) at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:422) at io.realm.Realm.getDefaultInstance(Realm.java:443)`\r\n> \r\n> Can you check by any chance if you updated your app name? In my case, the app name was part of my encryption key and when I changed the app name it was failing.\r\n\r\nI have already looked into that but no because we use the app identifier and the apps are live for a while (+\/- 4 years)","Do you have compaction enabled in your Realm?","> Do you have compaction enabled in your Realm?\r\n\r\nNo","I got my answer to this issue on the issue below:\r\n\r\nhttps:\/\/github.com\/realm\/realm-java\/issues\/7574","I'm also facing the same problem. This issue seems to occur intermittently, affecting only certain devices while most work fine. After analyzing the pattern, the error appears more likely to occur when the system marks the application as \"unused\" and initiates the power-saving or sleep mode. This leads me to hypothesize that the error might be connected to the system's attempt to put the application to sleep, affecting the Realm database operations.","Facing same issue and many crashes logged in crashlytics. If anyone got the solution, please help here.\r\n<img width=\"1139\" alt=\"Screenshot 2024-03-11 at 12 49 08\u202fPM\" src=\"https:\/\/github.com\/realm\/realm-java\/assets\/162962236\/3c2e576c-1441-4b6d-b83f-177be043d245\">\r\n"],"labels":["Reproduction-Required","O-Community","Waiting-For-Reporter"]},{"title":"Incompatibility issue with Gradle configuration cache","body":"The configuration cache is a feature that significantly improves build performance by caching the result of the configuration phase and reusing this for subsequent builds.\r\n\r\nImplementing support for the configuration cache in this plugin would improve users experience by dramatically reducing build times.\r\n\r\nSee https:\/\/docs.gradle.org\/current\/userguide\/configuration_cache.html\r\n\r\nThe configuration cache is already available since Gradle 6.6.\r\n\r\nWhen I run `.\/gradlew app:assembleRelease`, and the configuration doesn't come from the cache, Gradle reports this error:\r\n\r\n```\r\nTask `:app:transformClassesWithRealmTransformerForDebug` of type\r\n`com.android.build.gradle.internal.pipeline.TransformTask`: cannot serialize object of type \r\n'org.gradle.api.internal.project.DefaultProject', a subtype of 'org.gradle.api.Project',\r\nas these are not supported with the configuration cache.\r\n```\r\nSee https:\/\/docs.gradle.org\/6.8.1\/userguide\/configuration_cache.html#config_cache:requirements:disallowed_types\r\n\r\n\r\nAre there any plans to support configuration cache?","comments":["Thanks for the heads up on configuration cache, we are going to evaluate supporting it.","In Android Studio 7.0.0 there is a warning in the Build Analyzer, that configuration cache could be enabled. Unfortunately Realm is not yet compatible.","Looking a bit into this. It requires us to move to Gradle 7.0 as well, which contains a few breaking changes for us. I'm currently looking into how difficult it would be to upgrade.","Hmm, this also requires Java 11 it seems, so also ties into #7533 ","We will address this as part of https:\/\/github.com\/realm\/realm-java\/pull\/7535","@Jeff11 @sanogueralorenzo I'm trying to reproduce this, but cannot. Can you try to describe the exact versions of Gradle, Android Studio and Android Gradle plugin you are using?","I have also the same issue, that the configuration cache is not working. My used versions are:\r\n\r\n- Android Studio Arctic Fox | 2020.3.1 Patch 1 Build #AI-203.7717.56.2031.7621141, built on August 7, 2021\r\n- Gradle JDK: Android Studio Default JDK 11.0.10\r\n- Android Gradle Plugin Version 7.0.1\r\n- Gradle Verson 7.1\r\n- io.realm:realm-gradle-plugin:10.8.0","I believe its not yet merged with 10.10.1, when can we expect it to be available in stable release?","The configuration cache is still not working. My used versions are:\r\n\r\n- Android Studio Electric Eel | 2022.1.1 Beta 1\r\n- Gradle JDK: Android Studio Default JDK 11.\r\n- Android Gradle Plugin Version 7.2.2\r\n- Gradle Version 7.3.3\r\n- io.realm:realm-gradle-plugin:10.10.1\r\n\r\n@cmelchior ","The latest realm gradle plugin 10.11.1 is shown as incompatible with Gradle Configuraton cache feature. Using Android Studio Flamingo 2022.2.1 Canary 6","Can I have some eyes on this PR please: https:\/\/github.com\/realm\/realm-java\/pull\/7750 It adds support for Configuration Cache for `-transformer-api` versions. @cmelchior ","Still get the warning for the `10.13.2-transformer-api` version","Is there any update on this, on 10.5.1 and the configuration cache seems to be incompatible."],"labels":["O-Community","gathering-interest"]},{"title":"Publish plugin to Gradle plugin portal","body":"#### Describe your problem or use case\r\nCurrently I need to specify classpath to use `realm-android` plugin.\r\n\r\n\r\n#### Describe the solution you'd like\r\n```gradle\r\nplugins {\r\n   id \"realm-android\"\r\n}\r\n```\r\nwithout need to specify `classpath` in project gradle.\r\n\r\nPlugin should be published here: https:\/\/plugins.gradle.org\/\r\n\r\n","comments":["Thanks for the input. \r\n\r\nJust for reference; the `realm-kotlin` equivalent issue is in https:\/\/github.com\/realm\/realm-kotlin\/issues\/26.","It seems this is still not done and we're stuck with the old way of writing the project's build.gradle file.","Yes, we have not migrated to Gradle plugin portal.","> Yes, we have not migrated to Gradle plugin portal.\r\n\r\nAre there no plans to do so? We're stuck.with the old, outdated layout of build files due to that. Since realm-kotlin can do it, I'm sure you can do it as well \ud83d\ude42","We don't have plans to work on it as of now."],"labels":["O-Community"]},{"title":"MongoClientTest.watchError() no longer times out in Unit tests","body":"https:\/\/github.com\/realm\/realm-java\/pull\/7225\/files#diff-1da29b2bd378c63c1aadb00ca95051a3c0aeee22ed5ed7cb2750c81e7ae4deb0L1351 no longer times out after 60 seconds. \n\nWe need to figure out another way to test error events from watch.\n\n","comments":["This is still observed using `MONGODB_REALM_SERVER=2021-01-13` on [master](https:\/\/github.com\/realm\/realm-java\/tree\/6964515880df9864f97c9ade01e289cc6360a535) "],"labels":["T-Internal"]},{"title":"In and oneOf for binary fields","body":"Seems like `RealmQuery.in` and the extension method `RealmQuery.oneOf` is not implemented for binary fields (`byte[]\/ByteArray`). \r\n\r\nAs far as I can see we could just add methods similar to the other types\r\n```\r\nRealmQuery.in(String fieldName, @Nullable byte[][] values) {\r\n```\r\nAnd the extension method\r\n```\r\nfun <T : RealmModel> RealmQuery<T>.oneOf(propertyName: String, value: Array<out ByteArray?>): RealmQuery<T> \r\n```","comments":["Hi, I would like to work on this issue, so can you help me get started?\r\n","Can I work on this issue?"],"labels":["T-Enhancement","First-Good-Issue"]},{"title":"Fatal Exception: io.realm.exceptions.RealmError: Unrecoverable error. transaction_ended Exception backtrace: <backtrace not supported on this platform> in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 492","body":"#### Goal\nAndroid app with latest realm (10.0.1) & even older version crashes with the error mentioned in the stack trace provided by Firebase Crashlytics. I thought the latest version might have fixed this issue. Also, the crash doesn't point to any of the files related to the project and I'm unable to reproduce this issue.\n\n\n#### Actual Results\nStack trace provided by Firebase Crashlytics:\n\nFatal Exception: io.realm.exceptions.RealmError: Unrecoverable error. transaction_ended\n Exception backtrace:\n <backtrace not supported on this platform> in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 492\n at io.realm.internal.OsResults.nativeEvaluateQueryIfNeeded(OsResults.java)\n at io.realm.internal.OsResults.load(OsResults.java:701)\n at io.realm.internal.OsResults.freeze(OsResults.java:329)\n at io.realm.RealmResults.freeze(RealmResults.java:603)\n at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:196)\n at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:192)\n at io.realm.internal.ObservableCollection$RealmChangeListenerWrapper.onChange(ObservableCollection.java:39)\n at io.realm.internal.ObservableCollection$CollectionObserverPair.onChange(ObservableCollection.java:20)\n at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:64)\n at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:54)\n at io.realm.internal.ObserverPairList.foreach(ObserverPairList.java:109)\n at io.realm.internal.OsResults.notifyChangeListeners(OsResults.java:675)\n at android.os.MessageQueue.nativePollOnce(MessageQueue.java)\n at android.os.MessageQueue.next(MessageQueue.java:336)\n at android.os.Looper.loop(Looper.java:174)\n at android.app.ActivityThread.main(ActivityThread.java:7397)\n at java.lang.reflect.Method.invoke(Method.java)\n at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\n at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:935)\n\n\n#### Steps & Code to Reproduce\nUnable to reproduce the issue. I have seen multiple devices (including my personal device) crash. I could only read the stack trace from Firebase Crashlytics and it doesn't point to any of the files within the project.\n\n\n#### Version of Realm and tooling\nRealm version(s): 10.0.1\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 4.1.1\n\nAndroid Build Tools version: 30.0.2\n\nGradle version: 6.5\n\nWhich Android version and device(s):\n\nSamsung Galaxy Note 9 \u2013 Android version 10\n Xiaomi Mi 9T Pro \u2013 Android version 10\n LG Stylo 5 \u2013 Android version 10\n Samsung Galaxy Note 10+ \u2013 Android version 10\n Realme narzo 20 Pro \u2013 Android version 10\n Nokia 5.3 \u2013 Android version 10\n\nThere are more devices with older android versions, but unfortunately crashlytics is not allowing to view crashes past 90 days.\n ![](https:\/\/user-images.githubusercontent.com\/48918690\/100620392-63cb6980-3344-11eb-8062-f0dbf40e763e.png)\n\n","comments":["Thanks for the report. I don't have an immediate explanation for this, so I will have to investigate a bit to answer it properly.  ","Maybe related to https:\/\/github.com\/realm\/realm-java\/issues\/7250.","There is a chance this might be fixed by Realm Java ` 10.3.0`. Which will be released shortly. At least this was in the changelog: https:\/\/github.com\/realm\/realm-core\/blob\/master\/CHANGELOG.md#1033-release-notes\r\n\r\n```\r\nFix a race condition which would lead to \"uncaught exception in notifier thread: N5realm15InvalidTableRefE: transaction_ended\" and a crash when the source Realm was closed or invalidated at a very specific time during the first run of a collection notifier (#3761, since v6.0.0).\r\n```","I hope the above version fixes the issue, as I'm on the verge of moving away from Realm due to this issue.","@arshak-kahnputers Have you been able to test this with 10.3.0 (https:\/\/github.com\/realm\/realm-java\/blob\/master\/CHANGELOG.md)?","@rorbech I have updated the library, so far haven't noticed any crash. Will update if I were to see any on Crashlytics.","@arshak-kahnputers Thanks for the feedback. I will close the issue for now. Please feel free to repost if you have new observations. ","@rorbech The issue still persists on 10.3.0 which happened on LGE Stylo 6 running Android 10 which doesn't point to any Project files. The exception title text seemed to have changed but the line number and the remaining lines looks similar. Please check the attached screenshot.  \r\n\r\nHere's the stack trace:\r\nFatal Exception: java.lang.IllegalStateException: Access to invalidated Results objects in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 492\r\n       at io.realm.internal.OsResults.nativeEvaluateQueryIfNeeded(OsResults.java)\r\n       at io.realm.internal.OsResults.load(OsResults.java:701)\r\n       at io.realm.internal.OsResults.freeze(OsResults.java:329)\r\n       at io.realm.RealmResults.freeze(RealmResults.java:600)\r\n       at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:196)\r\n       at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:192)\r\n       at io.realm.internal.ObservableCollection$RealmChangeListenerWrapper.onChange(ObservableCollection.java:39)\r\n       at io.realm.internal.ObservableCollection$CollectionObserverPair.onChange(ObservableCollection.java:20)\r\n       at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:64)\r\n       at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:54)\r\n       at io.realm.internal.ObserverPairList.foreach(ObserverPairList.java:109)\r\n       at io.realm.internal.OsResults.notifyChangeListeners(OsResults.java:675)\r\n       at android.os.MessageQueue.nativePollOnce(MessageQueue.java)\r\n       at android.os.MessageQueue.next(MessageQueue.java:336)\r\n       at android.os.Looper.loop(Looper.java:174)\r\n       at android.os.HandlerThread.run(HandlerThread.java:67)\r\n\r\n![Screenshot 2021-01-26 at 7 43 19 PM](https:\/\/user-images.githubusercontent.com\/48918690\/105856112-dab47400-600e-11eb-817c-255ec995176d.png)\r\n","We are in the same situation here ! Top Crashlitics Crash : 500 by days. Help would be good !","Little different message of error at the same line:\r\n\r\n`Caused by io.realm.exceptions.RealmError: Unrecoverable error. No such object in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 492\r\n       at io.realm.internal.OsResults.nativeEvaluateQueryIfNeeded(OsResults.java)\r\n       at io.realm.internal.OsResults.load(OsResults.java:701)\r\n       at io.realm.RealmResults.load(RealmResults.java:142)\r\n       at io.realm.RealmQuery.createRealmResults(RealmQuery.java:2360)\r\n       at io.realm.RealmQuery.findAll(RealmQuery.java:2039)`","Hi, we are looking into it, but nothing conclusive yet.","@cmelchior Please let us know once this issue has been resolved. \r\n\r\nI'm commenting on this so that the issue remains open, as it seems that a bot has closed this issue yesterday.","@cmelchior  Hi any news on this ?\r\n\r\nHere is a crash I get close to the issue (but in a Rx context)\r\n\r\n```\r\nFatal Exception: io.realm.exceptions.RealmError: Unrecoverable error. transaction_ended\r\nException backtrace:\r\n<backtrace not supported on this platform> in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 504\r\n       at io.realm.internal.OsResults.nativeFreeze(OsResults.java)\r\n       at io.realm.internal.OsResults.freeze(OsResults.java:14)\r\n       at io.realm.RealmResults.freeze(RealmResults.java:16)\r\n       at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:20)\r\n       at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:2)\r\n       at io.realm.internal.ObservableCollection$RealmChangeListenerWrapper.onChange(ObservableCollection.java:2)\r\n       at io.realm.internal.ObservableCollection$CollectionObserverPair.onChange(ObservableCollection.java:13)\r\n       at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:2)\r\n       at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:2)\r\n       at io.realm.internal.ObserverPairList.foreach(ObserverPairList.java:41)\r\n       at io.realm.internal.OsResults.notifyChangeListeners(OsResults.java:46)\r\n       at android.os.MessageQueue.nativePollOnce(MessageQueue.java)\r\n       at android.os.MessageQueue.next(MessageQueue.java:336)\r\n       at android.os.Looper.loop(Looper.java:197)\r\n       at android.os.HandlerThread.run(HandlerThread.java:67)\r\n```\r\n\r\nApp uses 10.0.4","or \r\n```\r\nFatal Exception: java.lang.IllegalStateException: Access to invalidated Results objects in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 492\r\n       at io.realm.internal.OsResults.nativeEvaluateQueryIfNeeded(OsResults.java)\r\n       at io.realm.internal.OsResults.load(OsResults.java:8)\r\n       at io.realm.internal.OsResults.freeze(OsResults.java:27)\r\n       at io.realm.RealmResults.freeze(RealmResults.java:16)\r\n       at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:20)\r\n       at io.realm.rx.RealmObservableFactory$6$1.onChange(RealmObservableFactory.java:2)\r\n       at io.realm.internal.ObservableCollection$RealmChangeListenerWrapper.onChange(ObservableCollection.java:2)\r\n       at io.realm.internal.ObservableCollection$CollectionObserverPair.onChange(ObservableCollection.java:13)\r\n       at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:2)\r\n       at io.realm.internal.ObservableCollection$Callback.onCalled(ObservableCollection.java:2)\r\n       at io.realm.internal.ObserverPairList.foreach(ObserverPairList.java:41)\r\n       at io.realm.internal.OsResults.notifyChangeListeners(OsResults.java:46)\r\n       at android.os.MessageQueue.nativePollOnce(MessageQueue.java)\r\n       at android.os.MessageQueue.next(MessageQueue.java:326)\r\n       at android.os.Looper.loop(Looper.java:181)\r\n       at android.os.HandlerThread.run(HandlerThread.java:65)\r\n```\r\n\r\nWhat is strange here is how this may happen with freezed object, isn't it ?","any update here? ","@shrikantbmali Are you experiencing anything similar? Could you please post all details? Are you in any way able to reproduce?","@bmunkholm  Yes, When I try to create a realm instance in temp folder while I am running my Dotnet core 3.1 app it fails,\r\nI can consistently reproduce it.\r\nhowever, I just realized that I am posting of java thread.\r\nmy bad, but the log is exactly the same.","@shrikantbmali That's interesting - could you please create a new issue in realm\/realm-dotnet ? All details in terms how we could possibly reproduce it would be appreciated. Feel free to reference this issue as well as possibly related.\r\nThanks!","Any update on this one? This is our one of the top crashes.\r\n\r\n> This issue has 59931 crash events affecting 11803 users\r\n\r\n`\r\nException io.realm.exceptions.RealmError: Unrecoverable error. transaction_ended\r\nException backtrace:\r\n<backtrace not supported on this platform> in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 517\r\n  at io.realm.internal.OsResults.nativeEvaluateQueryIfNeeded (OsResults.java)\r\n  at io.realm.internal.OsResults.load (OsResults.java:745)\r\n  at io.realm.RealmResults.load (RealmResults.java:152)\r\n  at io.realm.RealmQuery.createRealmResults (RealmQuery.java:2850)\r\n  at io.realm.RealmQuery.findAll (RealmQuery.java:2465)\r\n`\r\n\r\nRealm: v10.11.0\r\n\r\nLet me know if you guys need anything else from our end to debug\/fix this issue.","@silicon-pranit your issue might not necessarily be the same as the one originally reported in this ticket. I would suggest you create another ticket and provide us with a full stack trace, including any potential native crashes following the format shown in https:\/\/developer.android.com\/ndk\/guides\/ndk-stack","We are also noticing this issues in production:\r\n\r\n```\r\nio.realm.exceptions.RealmError: Unrecoverable error. transaction_ended\r\nException backtrace:\r\n<backtrace not supported on this platform> in \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsResults.cpp line 529\r\n    at io.realm.internal.OsResults.nativeFreeze\r\n    at io.realm.internal.OsResults.freeze\r\n    at io.realm.RealmResults.freeze\r\n    at io.realm.rx.RealmObservableFactory$6$1.onChange\r\n    at io.realm.rx.RealmObservableFactory$6$1.onChange\r\n    at io.realm.internal.ObservableCollection$RealmChangeListenerWrapper.onChange\r\n    at io.realm.internal.ObservableCollection$CollectionObserverPair.onChange\r\n    at io.realm.internal.ObservableCollection$Callback.onCalled\r\n    at io.realm.internal.ObservableCollection$Callback.onCalled\r\n    at io.realm.internal.ObserverPairList.foreach\r\n    at io.realm.internal.OsResults.notifyChangeListeners\r\n    at android.os.MessageQueue.nativePollOnce(MessageQueue.java)\r\n    at android.os.MessageQueue.next(MessageQueue.java:335)\r\n    at android.os.Looper.loopOnce(Looper.java:161)\r\n    at android.os.Looper.loop(Looper.java:288)\r\n    at android.os.HandlerThread.run(HandlerThread.java:67)\r\n```"],"labels":["T-Bug-Crash","Reproduction-Required","O-Community"]},{"title":"Make it possible to pass objects to async transactions","body":"Currently when you do an async transaction, you have to write a lot of boilerplate code to re-fetch the objects you want to use within the transaction. Since the transaction happens on a background thread, we cannot access the original thread-confined object, and even if we are dealing with frozen objects, we still have to get a live mutable version before we can update it.\r\n\r\n A common example:\r\n\r\n```java\r\n\/\/ get an identifier for the object we want to pass to the transaction\r\nfinal String idToChange = myCat.getId();\r\n\r\n\/\/ create an asynchronous transaction (it will happen on background thread)\r\nrealm.executeTransactionAsync(bgRealm -> {\r\n   \/\/ we need to find the Cat we want to modify from the background thread\u2019s Realm\r\n   Cat cat = bgRealm.where(Cat.class)\r\n                    .equalTo(CatFields.ID, idToChange)\r\n                    .findFirst();\r\n\r\n   \/\/ do something with the cat\r\n   cat.deleteFromRealm()\r\n});\r\n```\r\n\r\nIt would be much nicer, performant and less error prone if it was possible to pass objects along to the transaction, and it handled the handover internally:\r\n\r\n```java\r\n\/\/ no need to get an identifier\r\n\/\/ final String idToChange = myCat.getId();\r\n\r\n\/\/ create an asynchronous transaction (it will happen on background thread)\r\nrealm.executeTransactionAsync(myCat, (bgRealm, cat) -> {\r\n   \/\/ do something with the cat\r\n   cat.deleteFromRealm()\r\n});\r\n```\r\n\r\nInternally this could use our handover mechanics so it would work with both objects, lists, query results and frozen objects.","comments":["Agree, this would be pretty useful. I have been thinking about something in similar lines."],"labels":["T-Enhancement"]},{"title":"Flaky test: PushTest.registerDevice_twice","body":"Seen in https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-7198\/4\/tests\n\n","comments":["Also here: https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-7212\/2\/tests","And here: https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-7212\/3\/tests","There seems to be an issue on the server-side of things: https:\/\/github.com\/realm\/realm-object-store\/blob\/master\/tests\/sync\/app.cpp#L1749","Also observed on https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-7232\/8\/pipeline"],"labels":["Reproduction-Required"]},{"title":"Unhelpful exception when calling toFlow on an invalid RealmResults","body":"#### Goal\r\nException or error should not be thrown, or have information about what has gone wrong\r\n\r\n#### Actual Results\r\nException from CallbackFlowBuilder:\r\n    java.lang.IllegalStateException: 'awaitClose { yourCallbackOrListener.cancel() }' should be used in the end of callbackFlow block.\r\n    Otherwise, a callback\/listener may leak in case of external cancellation.\r\n    See callbackFlow API documentation for the details.\r\n        at kotlinx.coroutines.flow.CallbackFlowBuilder.collectTo(Builders.kt:348)\r\n        at kotlinx.coroutines.flow.internal.ChannelFlow$collectToFun$1.invokeSuspend(ChannelFlow.kt:53)\r\n        at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\r\n        at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:56)\r\n        at android.os.Handler.handleCallback(Handler.java:873)\r\n        at android.os.Handler.dispatchMessage(Handler.java:99)\r\n        at android.os.Looper.loop(Looper.java:214)\r\n        at android.app.ActivityThread.main(ActivityThread.java:7050)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:494)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:965)\r\n\r\n#### Steps & Code to Reproduce\r\nI have a DAO class with this function:\r\n    fun getMessages(): Flow<List<RealmMessage>> {\r\n        return Realm.getInstance(config).use { r ->\r\n            r.where<RealmMessage>()\r\n                .sort(\"timestamp\", Sort.DESCENDING)\r\n                .findAll()\r\n                .toFlow()\r\n        }\r\n    }\r\n\r\nI am then collecting this flow through compose with `collectAsState(initial = emptyList(), context = Dispatchers.Main)`.\r\nI have allowed queries on the UI thread.\r\n\r\nLooking at RealmResultsExtensions I can see that the `if (!results.isValid) { return@callbackFlow }` is being hit in the debugger, and then the above exception is thrown because `awaitClose` is never called.\r\n\r\nThe debugger seems to suggest that it can't get the results because it throws an exception so I am probably doing something wrong with trying to get the results on the wrong thread, but it would be useful if the error would point at what I am doing wrong (and it probably shouldn't just crash if the results are invalid)\r\n\r\n#### Version of Realm and tooling\r\n\r\nRealm version(s): 10.0.0\r\n\r\nRealm Sync feature enabled: No\r\n\r\nAndroid Studio version: 4.2 canary 15\r\n","comments":["In my case the realm is being closed before the flow callback is started so the results are invalid","Yes, seems like there is an internal `callbackFlow`-check that we haven't been hitting in our test. We actually don't leak any callback as they are not subscripted on this case, but we should of course emit a more appropriate error. We will take it into consideration along with #7164 and #7165. Thanks!"],"labels":["O-Community"]},{"title":"Update examples to not run transactions on UI thread in v10 release","body":"Calling `executeTransaction` from the UI will cause apps to crash in v10. We need to update our examples to reflect that.","comments":["@edualonso since when does call executeTransaction on the UI thread cause apps to crash? The documentation here https:\/\/realm.io\/docs\/java\/latest#transaction-blocks lists that you \"might\" want to execute transactions on a background thread, but not that they will crash the app if you run them on the UIThread.  Is this something that has been changed?","Hi @sipersso. Your app will not crash if you run `executeTransaction` from the UI thread as long as you are running Realm prior to v10. For the upcoming v10 release we are introducing two new settings in `RealmConfiguration.Builder`, namely `allowWritesOnUiThread` and `allowQueriesOnUiThread`, which will allow users to control whether it is allowed to run transactions and\/or queries from the UI thread.\r\n\r\nBy default, `allowWritesOnUiThread` will be set to `false`, i.e. you will *not* be allowed to run blocking transactions with `executeTransaction` from the UI thread, but you can opt in by setting the flag to `true` - though we recommend using `executeTransactionAsync` or delegating calls to `executeTransaction` to non-UI threads.\r\n\r\nSimilarly, `allowQueriesOnUiThread` will allow you to restrict queries from the UI thread. It will default to `true`, i.e. queries will be allowed from the UI thread, but we recommend using `findAllAsync`, or if not possible due to the query using operations like `min`, `max`, etc., we recommend offloading those queries to a different thread.","You can refer to https:\/\/github.com\/realm\/realm-java\/blob\/v10\/CHANGELOG.md for more information on these changes.","@edualonso Thank you for the clarification... and the heads up that this will be changed as it will mean a lot of work on my end. ","@sipersso Note you can just add this to your configuration:\r\n\r\n```\r\nRealmConfiguration config = new RealmConfiguration.Builder()\r\n  .allowWritesOnUiThread(true)\r\n  .build()\r\n```\r\n\r\nAnd it will work like it always has. So you can decide when\/if you want to opt into the new behavior.","> @sipersso Note you can just add this to your configuration:\r\n> \r\n> ```\r\n> RealmConfiguration config = new RealmConfiguration.Builder()\r\n>   .allowWritesOnUiThread(true)\r\n>   .build()\r\n> ```\r\n> \r\n> And it will work like it always has. So you can decide when\/if you want to opt into the new behavior.\r\n\r\nThanks @cmelchior! This will definitely make it easier to adapt to the new API:s step by step. ","Although the code below works. It is important to update the documentation. Realm before mongodb looked more interesting for beginners\r\n\r\n\r\n\/\/  .allowWritesOnUiThread(true)\r\n","I created #7170 to update the documentation. "],"labels":["T-Enhancement"]},{"title":"Lists of Embedded Objects might be cleared when using insertOrUpdate","body":"When calling `realm.insertOrUpdate(object)` with an unmanged object but an managed list. It will not update correctly. Instead the list will be completely cleared. \n\n```kotlin\nrealm.executeTransaction {\n        val parent = EmbeddedTreeParent(_id = \"1\")\n        parent.middleNodeList = RealmList(EmbeddedTreeNode(\"1\"), EmbeddedTreeNode(\"2\"))\n        val managedParent = it.copyToRealmOrUpdate(parent)\n        parent.middleNodeList = managedParent.middleNodeList \/\/ Move managed list to unmanaged object\n\n       \/\/ Update parent again with the same managed list. This will break because there is no easy to check if it\n       \/\/ is the same list or if it is a new list with the same elements.\n       it.insertOrUpdate(parent)\n}\n```\n\nNote: This bug has never been reported.\n\n","comments":["\u27a4 Christan Melchior commented:\n\nNote: This is fairly difficult to solve, so might not be worth the effort, since this use case is pretty exotic.","Hi @cmelchior ,\r\n\r\nI also have a similar problem, when I do a partial update the RealmList properties are deleted to a default null value.\r\n\r\nHave you found a solution since?"],"labels":["T-Bug"]},{"title":"Flaky test: errorHandler_useBackupSyncConfigurationForClientReset","body":"From: https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-6756\/193\/tests\n\n```\n09-17 12:45:43.098 I\/TestRunner( 5032): started: errorHandler_useBackupSyncConfigurationForClientReset(io.realm.mongodb.sync.SessionTests)\n09-17 12:45:43.098 I\/MonitoringInstr( 5032): Activities that are still in CREATED to STOPPED: 0\n09-17 12:45:43.338 F\/REALM_JNI( 5032): An exception has been thrown on the sync client thread:\n09-17 12:45:43.338 F\/REALM_JNI( 5032): open(\"\/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/testapp1-nwlze\/5f633e58e71582372dd83596\/s_default.realm.management\/access_control.write.mx\") failed: No such file or directory Path: \/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/testapp1-nwlze\/5f633e58e71582372dd83596\/s_default.realm.management\/access_control.write.mx\n09-17 12:45:43.338 F\/REALM_JNI( 5032): Exception backtrace:\n09-17 12:45:43.338 F\/REALM_JNI( 5032): <backtrace not supported on this platform>\n--------- beginning of crash\n09-17 12:45:43.347 E\/AndroidRuntime( 5032): FATAL EXCEPTION: Thread-153\n09-17 12:45:43.347 E\/AndroidRuntime( 5032): Process: io.realm.test, PID: 5032\n09-17 12:45:43.347 E\/AndroidRuntime( 5032): io.realm.exceptions.RealmError: An exception has been thrown on the sync client thread:\n09-17 12:45:43.347 E\/AndroidRuntime( 5032): open(\"\/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/testapp1-nwlze\/5f633e58e71582372dd83596\/s_default.realm.management\/access_control.write.mx\") failed: No such file or directory Path: \/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/testapp1-nwlze\/5f633e58e71582372dd83596\/s_default.realm.management\/access_control.write.mx\n```\n\n","comments":["Flakyness maybe related to https:\/\/github.com\/realm\/realm-java\/issues\/5416 ?","Also seen here: https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-7160\/2\/pipeline"],"labels":["T-Internal","Reproduction-Required"]},{"title":"Add RealmConfiguration.enableJavaUTF16CompatibiltyMode","body":"Realm internally only allows UTF8 while Java operates with UTF16. For that reason, we convert Java Strings to UTF8 using the strict rules of UTF16 strings. Unfortunately, this can sometimes cause problems since Java allows illegal UTF16 Strings. For example, see https:\/\/github.com\/realm\/realm-java\/issues\/7081 where an illegal surrogate pair is encountered.\n\nIn Java when an illegal String (like invalid surrogate pair) is encountered and you try to print it, it will just replace the illegal surrogate with a `?` character instead of throwing. This effectively mask that some part of string has not been handled correctly, but also seems like a workable pragmatic approach.\n\nEspecially when you work solely on Android, using this pragmatic approach is probably better as it put how Realm works more in line with Java. For the sake of data consistency, it _should_ be an opt-in behavior though.\n\n### TODO\n- [ ] Figure out the exact name of the option, e.g. `automaticallyConvertIllegalUTF16Strings()`, `enableJavaUTF16CompatibiltyMode()` or something else.\n- [ ] Make sure that the Javadoc for this method thoroughly describe the problem and what might happen if you enable this mode.\n- [ ] Extend our UTF16 -> UTF8 converter to account for this when converting strings and replace illegal surrogates with `?`.\n- [ ] Add entry to our FAQ about it.","comments":[],"labels":["T-Enhancement"]},{"title":"Add support for RealmSet","body":"This issue tracks adding support for a new Set type. Name TBD, but `RealmSet` seems like the most obvious. \n\n## High level API\nSee https:\/\/docs.google.com\/document\/d\/1mvr88l4BAqvLgEaiO41hAfhIhYdVWuu573UaMmVJxlQ\/edit\n\nAPI is not finalized, but this is the first draft:\n\nWe will add a new class `RealmSet<Object>` which implements the standard Set  interface in Java\n\n```\nopen class Person : RealmObject() {\n   val set: RealmSet<String> = RealmSet()\n   val set: RealmSet<Dog> = RealmSet()\n   \/\/ And so on\n   \/\/ Illegal types will be detected at compile time and throw an error\n}\n```\n\nIt is an open question which change listeners to expose. In order to render a Set to the UI I suspect most people will convert it to a List, so we should probably expose something like `set.toList(\u201csortingProperty\u201d)`\n\n```\n\/\/ Set notifications\nval set: RealmSet<Dog> = getSet()\nset.addChangeListener { updatedSet ->\n   \/\/ No finegrained notifications, since it would be unclear how to identity changes\n   \/\/ as primitive types do not have keys and a Set doesn't have indexes.\n  \/\/ Maybe the number of inserts, updates, removals would be interesting, but I\n \/\/ cannot come up with a use case\n}\n\n\/\/ Assumed use for rendering in the UI\nset.toList(\"name\").addChangeListener { changes, updatedList ->\n   \/\/ By converting to a list, we can expose the standard List fine-grained notifications\n}\n```\n\n- [ ] Figure out which methods exist on Set\n- [ ] Figure out which additional methods make sense in a Realm setting: Change listeners, queries.\n- [ ] Sets of Lists, Sets, and Maps are not supported in Phase 1.  Only Sets of primitive, boxed, Mixed, and single object references are supported. Embedded object not supported either.\n- [ ] Figure out how the notifications should look like. Right now we `OrderedCollectionChangeSet`, with sets we should probably add `UnorderedCollectionChangeSet` but it is unclear how that should look like, also when it needs to support both Set and Maps. \n\n## TODO\n\n- [ ] Add support in Annotation Processor.\n- [ ] Add support in copyToRealm(orUpdate)\n- [ ] Add support in insert(OrUpdate)\n- [ ] Add support in copyFromRealm\n- [ ] Add support in `RealmQuery` \n- [ ] Add support in `createFromJson` methods\n- [ ] Add support in `DynamicRealmObject`\n- [ ] RealmSchema","comments":[],"labels":["T-Feature","Design-Required"]},{"title":"Flaky test: uploadDownloadAllChangesWithFloatFails","body":"From https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-6756\/171\n\n```\n09-01 13:51:24.879 D\/REALM_SYNC( 5107): Connection[1]: Session[1]: Upload compaction: original size = 232, compacted size = 232\n09-01 13:51:25.081 I\/REALM_SYNC( 5107): Connection[1]: Session[1]: Received: ERROR(error_code=225, message_size=115, try_again=0)\n09-01 13:51:25.081 D\/REALM_SYNC( 5107): Connection[1]: Session[1]: Suspended\n09-01 13:51:25.089 E\/REALM_JAVA( 5107): Client Reset required for: ws:\/\/127.0.0.1:9090\/\n09-01 13:51:25.089 D\/REALM_SYNC( 5107): Connection[1]: Session[1]: Sending: UNBIND\n09-01 13:51:25.089 D\/REALM_SYNC( 5107): Connection[1]: Session[1]: Initiating deactivation\n09-01 13:51:25.089 D\/REALM_SYNC( 5107): Closing Realm file: \/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/realm-sdk-integration-tests-jvlta\/d00fa208-4732-420e-b378-8fe6c69ab4e8\/s_18547e7d-939e-457b-9269-774750ecb458.realm\n09-01 13:51:25.090 D\/REALM_SYNC( 5107): Connection[1]: Session[1]: Deactivation completed\n09-01 13:51:25.090 D\/REALM_SYNC( 5107): Connection[1]: Allowing reconnection in 432 milliseconds\n09-01 13:51:25.090 I\/REALM_SYNC( 5107): Connection[1]: Disconnected\n09-01 13:51:25.090 D\/REALM_SYNC( 5107): Connection[1]: Destroying connection object\n09-01 13:51:25.091 E\/REALM   ( 5107): \/tmp\/realm-java\/realm\/realm-library\/src\/main\/cpp\/object-store\/src\/sync\/sync_manager.cpp:626: [realm-core-10.0.0-beta.4] Assertion failed: it != m_sessions.end()\n09-01 13:51:25.091 E\/REALM   ( 5107): <backtrace not supported on this platform>!!! IMPORTANT: Please send this log and info about Realm SDK version and other relevant reproduction info to help@realm.io.\n--------- beginning of crash\n09-01 13:51:25.091 F\/libc    ( 5107): Fatal signal 6 (SIGABRT), code -1 (SI_QUEUE) in tid 5126 (roidJUnitRunner), pid 5107 (io.realm.test)\n09-01 13:51:25.180 I\/crash_dump32( 6680): obtaining output fd from tombstoned, type: kDebuggerdTombstone\n09-01 13:51:25.187 I\/\/system\/bin\/tombstoned( 1620): received crash request for pid 5126\n09-01 13:51:25.188 I\/crash_dump32( 6680): performing dump of process 5107 (target tid = 5126)\n09-01 13:51:25.195 F\/DEBUG   ( 6680): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n09-01 13:51:25.195 F\/DEBUG   ( 6680): Build fingerprint: 'Android\/sdk_phone_x86\/generic_x86:10\/QPP6.190730.005.B1\/5775370:userdebug\/test-keys'\n09-01 13:51:25.195 F\/DEBUG   ( 6680): Revision: '0'\n09-01 13:51:25.195 F\/DEBUG   ( 6680): ABI: 'x86'\n09-01 13:51:25.195 F\/DEBUG   ( 6680): Timestamp: 2020-09-01 13:51:25+0200\n09-01 13:51:25.195 F\/DEBUG   ( 6680): pid: 5107, tid: 5126, name: roidJUnitRunner  >>> io.realm.test <<<\n09-01 13:51:25.195 F\/DEBUG   ( 6680): uid: 10106\n09-01 13:51:25.195 F\/DEBUG   ( 6680): signal 6 (SIGABRT), code -1 (SI_QUEUE), fault addr --------\n09-01 13:51:25.195 F\/DEBUG   ( 6680):     eax 00000000  ebx 000013f3  ecx 00001406  edx 00000006\n09-01 13:51:25.195 F\/DEBUG   ( 6680):     edi eadc433e  esi c1916fc0\n09-01 13:51:25.195 F\/DEBUG   ( 6680):     ebp ed783ad0  esp c1916f68  eip ed783ad9\n09-01 13:51:25.383 F\/DEBUG   ( 6680): \n09-01 13:51:25.383 F\/DEBUG   ( 6680): backtrace:\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #00 pc 00000ad9  [vdso] (__kernel_vsyscall+9)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #01 pc 00092328  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (syscall+40) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #02 pc 000ad651  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (abort+193) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #03 pc 0109fb5c  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (please_report_this_error_to_help_at_realm_dot_io+28) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #04 pc 0109ff11  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::util::terminate_internal(std::__ndk1::basic_stringstream<char, std::__ndk1::char_traits<char>, std::__ndk1::allocator<char>>&)+577) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #05 pc 010a0089  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::util::terminate(char const*, char const*, long, std::initializer_list<realm::util::Printable>&&)+329) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #06 pc 005a1f52  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::SyncManager::unregister_session(std::__ndk1::basic_string<char, std::__ndk1::char_traits<char>, std::__ndk1::allocator<char>> const&)+274) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #07 pc 005bf10e  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::SyncSession::unregister(std::__ndk1::unique_lock<std::__ndk1::mutex>&)+302) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #08 pc 005c5ba0  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::_impl::sync_session_states::Inactive::close(std::__ndk1::unique_lock<std::__ndk1::mutex>&, realm::SyncSession&) const+64) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #09 pc 005c127a  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::SyncSession::did_drop_external_reference()+138) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #10 pc 005db500  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::SyncSession::ExternalReference::~ExternalReference()+64) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.383 F\/DEBUG   ( 6680):       #11 pc 005daf1c  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::__shared_ptr_emplace<realm::SyncSession::ExternalReference, std::__ndk1::allocator<realm::SyncSession::ExternalReference>>::__on_zero_shared()+60) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #12 pc 01161dcf  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::__shared_weak_count::__release_shared()+47) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #13 pc 00159e70  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::shared_ptr<realm::SyncSession>::~shared_ptr()+64) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #14 pc 0045d8b3  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::_impl::RealmCoordinator::~RealmCoordinator()+851) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #15 pc 0047593c  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::__shared_ptr_emplace<realm::_impl::RealmCoordinator, std::__ndk1::allocator<realm::_impl::RealmCoordinator>>::__on_zero_shared()+60) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #16 pc 01161dcf  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::__shared_weak_count::__release_shared()+47) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #17 pc 002e7c90  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::shared_ptr<realm::_impl::RealmCoordinator>::~shared_ptr()+64) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #18 pc 003d4989  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (std::__ndk1::shared_ptr<realm::_impl::RealmCoordinator>::operator=(std::__ndk1::shared_ptr<realm::_impl::RealmCoordinator>&&)+121) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #19 pc 003dc294  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (realm::Realm::close()+372) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #20 pc 0017b29c  \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/lib\/x86\/librealm-jni.so (Java_io_realm_internal_OsSharedRealm_nativeCloseSharedRealm+124) (BuildId: 9fa7f3f6d8de57142c5770ef63487614d518e10d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #21 pc 00144f67  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_generic_jni_trampoline+71) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #22 pc 020733a9  \/memfd:\/jit-cache (deleted) (io.realm.internal.OsSharedRealm.close+121)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #23 pc 020951d5  \/memfd:\/jit-cache (deleted) (io.realm.BaseRealm.doClose+85)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #24 pc 0201ae86  \/memfd:\/jit-cache (deleted) (io.realm.RealmCache.release+422)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #25 pc 02015912  \/memfd:\/jit-cache (deleted) (io.realm.BaseRealm.close+226)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #26 pc 020962d6  \/memfd:\/jit-cache (deleted) (io.realm.Realm.close+38)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #27 pc 0013e7d2  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_invoke_stub+338) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #28 pc 00149a69  \/apex\/com.android.runtime\/lib\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+281) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #29 pc 00332502  \/apex\/com.android.runtime\/lib\/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+386) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #30 pc 0032c19c  \/apex\/com.android.runtime\/lib\/libart.so (bool art::interpreter::DoCall<false, false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, art::JValue*)+988) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #31 pc 006834ea  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeInterface+1258) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #32 pc 00138a21  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_interface+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #33 pc 00454640  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (kotlin.io.CloseableKt.closeFinally+12)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #34 pc 00684f6c  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeStatic+1260) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #35 pc 001389a1  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_static+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #36 pc 002cf286  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (io.realm.SyncSessionTests.uploadDownloadAllChangesWithFloatFails+322)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #37 pc 002f8e0a  \/apex\/com.android.runtime\/lib\/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEbb.llvm.6689468213397061768+298) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #38 pc 002ffcc5  \/apex\/com.android.runtime\/lib\/libart.so (art::interpreter::EnterInterpreterFromEntryPoint(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame*)+181) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #39 pc 0066fbd9  \/apex\/com.android.runtime\/lib\/libart.so (artQuickToInterpreterBridge+1209) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #40 pc 0014503d  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_to_interpreter_bridge+77) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #41 pc 0013e7d2  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_invoke_stub+338) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #42 pc 00149a69  \/apex\/com.android.runtime\/lib\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+281) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #43 pc 0055a513  \/apex\/com.android.runtime\/lib\/libart.so (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const&, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+99) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #44 pc 0055c32f  \/apex\/com.android.runtime\/lib\/libart.so (art::InvokeMethod(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, _jobject*, _jobject*, unsigned int)+1327) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #45 pc 004c9153  \/apex\/com.android.runtime\/lib\/libart.so (art::Method_invoke(_JNIEnv*, _jobject*, _jobject*, _jobjectArray*)+83) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #46 pc 000c6bf8  \/system\/framework\/x86\/boot.oat (art_jni_trampoline+168) (BuildId: 4356b7beb1aac85a6f92995bf5ee901be3975d03)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #47 pc 020b47c6  \/memfd:\/jit-cache (deleted) (org.junit.runners.model.FrameworkMethod$1.runReflectiveCall+102)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #48 pc 020babae  \/memfd:\/jit-cache (deleted) (org.junit.internal.runners.model.ReflectiveCallable.run+46)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #49 pc 020b39b4  \/memfd:\/jit-cache (deleted) (org.junit.runners.model.FrameworkMethod.invokeExplosively+100)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #50 pc 020cbfbd  \/memfd:\/jit-cache (deleted) (org.junit.internal.runners.statements.InvokeMethod.evaluate+93)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #51 pc 02073d5f  \/memfd:\/jit-cache (deleted) (androidx.test.internal.runner.junit4.statement.RunBefores.evaluate+495)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #52 pc 020721ca  \/memfd:\/jit-cache (deleted) (androidx.test.internal.runner.junit4.statement.RunAfters.evaluate+90)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #53 pc 020d449b  \/memfd:\/jit-cache (deleted) (org.junit.runners.ParentRunner.runLeaf+123)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #54 pc 020cf908  \/memfd:\/jit-cache (deleted) (org.junit.runners.BlockJUnit4ClassRunner.runChild+120)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #55 pc 020da429  \/memfd:\/jit-cache (deleted) (org.junit.runners.BlockJUnit4ClassRunner.runChild+89)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #56 pc 020de5ca  \/memfd:\/jit-cache (deleted) (org.junit.runners.ParentRunner$3.run+90)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #57 pc 020d6c77  \/memfd:\/jit-cache (deleted) (org.junit.runners.ParentRunner$1.schedule+55)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #58 pc 020c93a8  \/memfd:\/jit-cache (deleted) (org.junit.runners.ParentRunner.runChildren+248)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #59 pc 0013e7d2  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_invoke_stub+338) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #60 pc 00149a69  \/apex\/com.android.runtime\/lib\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+281) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #61 pc 00332502  \/apex\/com.android.runtime\/lib\/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+386) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #62 pc 0032c19c  \/apex\/com.android.runtime\/lib\/libart.so (bool art::interpreter::DoCall<false, false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, art::JValue*)+988) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #63 pc 0068433c  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeDirect+700) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #64 pc 00138921  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_direct+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #65 pc 0009e520  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (org.junit.runners.ParentRunner.access$000)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #66 pc 00684f6c  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeStatic+1260) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #67 pc 001389a1  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_static+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #68 pc 00594384  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (org.junit.runners.ParentRunner$2.evaluate+8)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #69 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #70 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #71 pc 0009e6aa  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (org.junit.runners.ParentRunner.run+26)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #72 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #73 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #74 pc 00162b50  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (androidx.test.ext.junit.runners.AndroidJUnit4.run+4)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #75 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #76 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #77 pc 00594604  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (org.junit.runners.Suite.runChild)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #78 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #79 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #80 pc 005945ea  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (org.junit.runners.Suite.runChild+6)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #81 pc 002f8e0a  \/apex\/com.android.runtime\/lib\/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEbb.llvm.6689468213397061768+298) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #82 pc 002ffcc5  \/apex\/com.android.runtime\/lib\/libart.so (art::interpreter::EnterInterpreterFromEntryPoint(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame*)+181) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #83 pc 0066fbd9  \/apex\/com.android.runtime\/lib\/libart.so (artQuickToInterpreterBridge+1209) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #84 pc 0014503d  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_to_interpreter_bridge+77) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #85 pc 020de5ca  \/memfd:\/jit-cache (deleted) (org.junit.runners.ParentRunner$3.run+90)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #86 pc 020d6c77  \/memfd:\/jit-cache (deleted) (org.junit.runners.ParentRunner$1.schedule+55)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #87 pc 0013e7d2  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_invoke_stub+338) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #88 pc 00149a69  \/apex\/com.android.runtime\/lib\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+281) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #89 pc 00332502  \/apex\/com.android.runtime\/lib\/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+386) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #90 pc 0032c19c  \/apex\/com.android.runtime\/lib\/libart.so (bool art::interpreter::DoCall<false, false>(art::ArtMethod*, art::Thread*, art::ShadowFrame&, art::Instruction const*, unsigned short, art::JValue*)+988) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #91 pc 006834ea  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeInterface+1258) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #92 pc 00138a21  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_interface+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #93 pc 0009e722  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (org.junit.runners.ParentRunner.runChildren+50)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #94 pc 006845ac  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeDirect+1324) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #95 pc 00138921  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_direct+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #96 pc 0009e520  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (org.junit.runners.ParentRunner.access$000)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #97 pc 00684f6c  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeStatic+1260) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #98 pc 001389a1  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_static+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #99 pc 00594384  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (org.junit.runners.ParentRunner$2.evaluate+8)\n09-01 13:51:25.384 F\/DEBUG   ( 6680):       #100 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #101 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #102 pc 0009e6aa  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (org.junit.runners.ParentRunner.run+26)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #103 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #104 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #105 pc 00593136  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (org.junit.runner.JUnitCore.run+50)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #106 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #107 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #108 pc 005930e8  [anon:dalvik-classes2.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk!classes2.dex] (org.junit.runner.JUnitCore.run+8)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #109 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #110 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #111 pc 0003c1c4  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (androidx.test.internal.runner.TestExecutor.execute+52)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #112 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #113 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #114 pc 00040696  [anon:dalvik-classes.dex extracted in memory from \/data\/app\/io.realm.test-IjqcAEBpe0Xbr9HTvAWNtA==\/base.apk] (androidx.test.runner.AndroidJUnitRunner.onStart+250)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #115 pc 00681adc  \/apex\/com.android.runtime\/lib\/libart.so (MterpInvokeVirtual+1612) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #116 pc 00138821  \/apex\/com.android.runtime\/lib\/libart.so (mterp_op_invoke_virtual+33) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #117 pc 001edea6  \/system\/framework\/framework.jar (android.app.Instrumentation$InstrumentationThread.run+94)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #118 pc 002f8e0a  \/apex\/com.android.runtime\/lib\/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEbb.llvm.6689468213397061768+298) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #119 pc 002ffcc5  \/apex\/com.android.runtime\/lib\/libart.so (art::interpreter::EnterInterpreterFromEntryPoint(art::Thread*, art::CodeItemDataAccessor const&, art::ShadowFrame*)+181) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #120 pc 0066fbd9  \/apex\/com.android.runtime\/lib\/libart.so (artQuickToInterpreterBridge+1209) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #121 pc 0014503d  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_to_interpreter_bridge+77) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #122 pc 0013e7d2  \/apex\/com.android.runtime\/lib\/libart.so (art_quick_invoke_stub+338) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #123 pc 00149a69  \/apex\/com.android.runtime\/lib\/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+281) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #124 pc 0055a513  \/apex\/com.android.runtime\/lib\/libart.so (art::(anonymous namespace)::InvokeWithArgArray(art::ScopedObjectAccessAlreadyRunnable const&, art::ArtMethod*, art::(anonymous namespace)::ArgArray*, art::JValue*, char const*)+99) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #125 pc 0055b91a  \/apex\/com.android.runtime\/lib\/libart.so (art::InvokeVirtualOrInterfaceWithJValues(art::ScopedObjectAccessAlreadyRunnable const&, _jobject*, _jmethodID*, jvalue const*)+474) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #126 pc 005aaa51  \/apex\/com.android.runtime\/lib\/libart.so (art::Thread::CreateCallback(void*)+1585) (BuildId: a0a062684495092d1756e30ba2dff37d)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #127 pc 0011a8e5  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (__pthread_start(void*)+53) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:51:25.385 F\/DEBUG   ( 6680):       #128 pc 000af6a7  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (__start_thread+71) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n```\n\nLooks like a problem managing sessions in ObjectStore\n\n","comments":[],"labels":["Reproduction-Required"]},{"title":"Flaky test: addChangeListener_listenerShouldBeCalledIfObjectChangesAfterAsyncReturn","body":"https:\/\/ci.realm.io\/blue\/organizations\/jenkins\/realm%2Frealm-java\/detail\/PR-6756\/170\/tests\n\nFound on the v10 branch\n\n```\n09-01 13:20:41.546 I\/TestRunner( 3643): started: addChangeListener_listenerShouldBeCalledIfObjectChangesAfterAsyncReturn(io.realm.RealmObjectTests)\n09-01 13:20:41.547 I\/MonitoringInstr( 3643): Activities that are still in CREATED to STOPPED: 0\n09-01 13:20:41.572 F\/DEBUG   ( 4773): \n09-01 13:20:41.572 F\/DEBUG   ( 4773): backtrace:\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #00 pc 00000ad9  [vdso] (__kernel_vsyscall+9)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #01 pc 00092328  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (syscall+40) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #02 pc 000ad651  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (abort+193) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #03 pc 000adb88  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (__assert2+56) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #04 pc 00c63404  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (abort_message+116) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #05 pc 00c6356e  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (demangling_terminate_handler()+254) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #06 pc 00c5ff39  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (std::__terminate(void (*)())+25) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #07 pc 00c5f635  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (__cxa_rethrow+229) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #08 pc 003f68ac  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (_ZZN5realm5_impl20ExternalCommitHelper12DaemonThreadC1EvENK3$_0clEv+316) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #09 pc 003f6709  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (_ZNSt6__ndk18__invokeIZN5realm5_impl20ExternalCommitHelper12DaemonThreadC1EvE3$_0JEEEDTclclsr3std6__ndk1E7forwardIT_Efp_Espclsr3std6__ndk1E7forwardIT0_Efp0_EEEOS6_DpOS7_+57) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #10 pc 003f6605  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (_ZNSt6__ndk116__thread_executeINS_10unique_ptrINS_15__thread_structENS_14default_deleteIS2_EEEEZN5realm5_impl20ExternalCommitHelper12DaemonThreadC1EvE3$_0JEJEEEvRNS_5tupleIJT_T0_DpT1_EEENS_15__tuple_indicesIJXspT2_EEEE+69) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #11 pc 003f5d44  \/data\/app\/io.realm.test-YNqWrsqCGjBKWSn7CCfeCQ==\/lib\/x86\/librealm-jni.so (_ZNSt6__ndk114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN5realm5_impl20ExternalCommitHelper12DaemonThreadC1EvE3$_0EEEEEPvSD_+196) (BuildId: afdc8583ea1d57f5853078b2b990be5ba342eb8c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #12 pc 0011a8e5  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (__pthread_start(void*)+53) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:20:41.572 F\/DEBUG   ( 4773):       #13 pc 000af6a7  \/apex\/com.android.runtime\/lib\/bionic\/libc.so (__start_thread+71) (BuildId: 76290498408016ad14f4b98c3ab6c65c)\n09-01 13:20:42.397 E\/\/system\/bin\/tombstoned( 1619): Tombstone written to: \/data\/tombstones\/tombstone_00\n```\n\n","comments":[],"labels":["T-Bug-Crash","Reproduction-Required"]},{"title":"Upgrade Gradle scripts","body":"While updating the latest build tools and Gradle version we noticed that there are some deprecation issues that should be addressed and some improvements.\n\n* Migrate to maven publish plugin\n* Use new Gradle plugin DSL:\n\n```java\nplugin {\r\n    id 'java' version '1.0'\r\n}\n```\n\n* There is a bunch of optional variables hidden in the Gradle files, that aren't defined in the **dependecies.list** file. In order to facilitate its discovery and setup, we should define them in the **dependencies.list** file.\n* ndkVersion variable is not used, and it's defined twice\n* Jenkins file can be upgraded. Use pipeline step\n\n","comments":[],"labels":["T-Internal","Design-Required"]},{"title":"Flaky test: setEncryptionKey_shouldCrashIfKeyNotProvided","body":"```\n08-13 14:42:50.274 I\/TestRunner( 3489): started: setEncryptionKey_shouldCrashIfKeyNotProvided(io.realm.EncryptedSynchronizedRealmTests)\n08-13 14:42:50.275 I\/MonitoringInstr( 3489): Activities that are still in CREATED to STOPPED: 0\n08-13 14:42:50.372 E\/ResolverController( 1555): No valid NAT64 prefix (101, <unspecified>\/0)\n08-13 14:42:50.497 E\/ResolverController( 1555): No valid NAT64 prefix (101, <unspecified>\/0)\n08-13 14:42:50.720 F\/REALM_JNI( 3489): An exception has been thrown on the sync client thread:\n08-13 14:42:50.720 F\/REALM_JNI( 3489): Realm file initial open failed Path: \/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/realm-sdk-integration-tests-nduec\/dc68784b-8f95-4af2-b089-5a10313a66e2\/o_5f35354acc3ff512fbbd9952.realm\n08-13 14:42:50.720 F\/REALM_JNI( 3489): Exception backtrace:\n08-13 14:42:50.720 F\/REALM_JNI( 3489): <backtrace not supported on this platform>\n--------- beginning of crash\n08-13 14:42:50.720 E\/AndroidRuntime( 3489): FATAL EXCEPTION: Thread-8\n08-13 14:42:50.720 E\/AndroidRuntime( 3489): Process: io.realm.test, PID: 3489\n08-13 14:42:50.720 E\/AndroidRuntime( 3489): io.realm.exceptions.RealmError: An exception has been thrown on the sync client thread:\n08-13 14:42:50.720 E\/AndroidRuntime( 3489): Realm file initial open failed Path: \/data\/user\/0\/io.realm.test\/files\/mongodb-realm\/realm-sdk-integration-tests-nduec\/dc68784b-8f95-4af2-b089-5a10313a66e2\/o_5f35354acc3ff512fbbd9952.realm\n08-13 14:42:50.720 E\/AndroidRuntime( 3489): Exception backtrace:\n08-13 14:42:50.720 E\/AndroidRuntime( 3489): <backtrace not supported on this platform>\n```\n\nLooks like a race condition. Probably when using `downloadInitialRemoteData`\n\n","comments":[],"labels":["T-Internal"]},{"title":"JNI crash when logging out when running findAllAsync is running","body":"When I run findAll() on a RealmQuery in the android SDK that yields no results (for instance, if I run realm.where().beginsWith(\"someField\", \"somePrefixThatDoesNotExistInMyPartition\").findAll().... I get a really nasty error. From what I can tell, it's actually breaking somewhere deep down in dalvik, so I guess it's probably a problem with the C++ database engine? Stack trace: https:\/\/github.com\/nathan-contino-mongo\/share\/blob\/master\/findAllEmptyCollectionRealmAndroid.txt\n\n","comments":["\u27a4 Ian Ward commented:\n\nI think this is a bug - [~eduardo.lopezgutierrez]\u00a0Can you confirm?","\u27a4 Eduardo L\u00f3pez Guti\u00e9rrez commented:\n\nIt seems you are using an illegal character in your partition value according to what I see in the log: \"\ufffd\". I tried to use that character as the partition value and it works fine on my Mac (are you running your code on a different platform that uses different encoding?), but if I tamper with the value in runtime in order to not comply with our JNI parsing protocol, then I get the same error you are getting.\n\nIn any case, the problem doesn't seem to stem from executing the query you mentioned - I've also run some of the unit tests we have in that regard and it's not a problem.\n\nIt puzzles me that you have\u00a0somehow managed to fool our JNI parsing protocol. Could you please provide more information to reproduce the bug more \"naturally\"?","\u27a4 Nathan Contino commented:\n\nI'm encountering this issue with android studio on my linux work machine (Ubuntu 20.04). Here's the full file I've been running:\n\nhttps:\/\/github.com\/nathan-contino-mongo\/share\/blob\/master\/MainActivity.kt","\u27a4 Nathan Contino commented:\n\n[~eduardo.lopezgutierrez] would love to hear if I'm doing something wrong here -- I'm just building the quickstart for the Android SDK, so if there's a knowledge gap here I'd like to close it!","\u27a4 Eduardo L\u00f3pez Guti\u00e9rrez commented:\n\n[~nathan.contino]\u00a0we need to revisit this since it doesn't reflect the latest updates regarding multiple tests failing that you mentioned on Slack. Can you find time to go through it with me?","\u27a4 Nathan Contino commented:\n\nAfter touching base on this, [~eduardo.lopezgutierrez] figured out that this \"bug\" was actually triggered by a race condition. Specifically, my code contained a call to the ``logout`` method that executed before all realm transactions finished executing in certain cases. Removing the call to ``logout`` at the end of the code fixed the issue -- since removing it, both eduardo and I have run the code many times each and we haven't seen the error again. I'm updating the quick start to both remove the logout anti-pattern and thoroughly warn users of the dangers of logging out while operations are still completing.","\u27a4 Ian Ward commented:\n\n[~eduardo.lopezgutierrez] shouldn't we handle this under the hood for the developer and not introduce race conditions? For instance, when you call realm.close() I believe that it makes sure to commit writes first and I also think it uploads all the data to Realm Sync if possible - is this not the case?","From @edualonso \r\n\r\n> More precisely, it explodes in OsRealmConfig.cpp when trying to bson'ize the partition key, which is garbage by then"],"labels":["T-Bug-Crash"]},{"title":"Update example. Kotlin high order function not working with Mock RealmList","body":"This code below does not work when using realm-java in a Kotlin project since high order functions from Kotlin are not automatically handled by this solution that uses the interactor:\n\nhttps:\/\/github.com\/realm\/realm-java\/blob\/0ddcc16136d31984aaaec7387a552c1d31a5ccb9\/examples\/unitTestExample\/src\/test\/java\/io\/realm\/examples\/unittesting\/ExampleActivityTest.java#L167\n\nA structure as the example below does not work:\n\n```kotlin\n@RealmClass\nopen class User(val messages: RealmList<Message> = RealmList())\n```\n\n```kotlin\nval realm = \/\/... get mocked realm, Java code, similar to the code from the example in this repo.\n\nval user = mock(User::class.java)\n\nval userQuery: RealmQuery<User> = mockRealmQuery()\n\n`when`(userQuery.findFirst()).thenReturn(user)\n`when`(mockRealm.where(User::class.java)).thenReturn(userQuery)\n\nval message = mock(Message::class.java)\n`when`(message.content).thenReturn(\"Foo\")\n\nval messages: RealmList<Message> = mockRealmList()\nval messagesList = mutableListOf(message)\n\n`when`(messages.iterator()).thenReturn(messagesList.iterator())\n`when`(messages.size).thenReturn(messagesList.size)\n`when`(messages[0]).thenReturn(message)\n`when`(user.messages).thenReturn(messages)\n\nval user = fetchUser(mockRealm)\nuser.messages.forEach { message ->\n  \/\/Not running\n  println(\"message content: ${message.content}\")\n}\n\nval contents = user.messages.map { message ->\n  \/\/Not running\n  return message.content\n}\n\nfun fetchUser(realm: Realm): User {\n    return mockRealm.where(User::class.java).findFirst()!!\n}\n```\n\nI am not sure how this could be sorted, I also opened an issue in the mockito-kotlin repo: https:\/\/github.com\/nhaarman\/mockito-kotlin\/issues\/385\nAlso added a question on StackOverflow: https:\/\/stackoverflow.com\/questions\/63042724\/how-to-mock-kotlins-list-foreach\n\n","comments":["Sorted with the use of `` `when`(messages.iterator()).thenAnswer { messagesList.iterator() }``. Is this correct?","@ppamorim Yes, given the explanation in https:\/\/stackoverflow.com\/a\/63064586\/6834276 that seems correct. \r\n\r\nI guess our example works since it doesn't hit the mocked call multiple times, hence only iterates the list a single time. I guess we should update the example. "],"labels":["O-Community"]},{"title":"[Feature request] Write Realm copy to OutputStream","body":"#### Describe your problem or use case\nI want to allow the user to create a backup of the Realm database. This is already perfectly possible with `writeCopyTo()` and `writeEncryptedCopyTo()`. Due to the new file access limitations in Android 10\/11 I am forced to use the Storage Access Framework (SAF). Because of this I cannot provide an instance of `java.io.File` but a `java.io.OutputStream`.\n\n\n#### Describe the solution you'd like\nI would like to have an overload of `writeCopyTo()` and `writeEncryptedCopyTo()` that takes `java.io.OutputStream` as parameter.\n\n\n#### Additional context\nTo be fair, it is currently possible to work around this issue by creating a copy in internal storage with the existing methods, and to move this copy to external storage via InputStream and OutputStream. But this adds a lot of overhead.","comments":["Yes, the new changes to Storage Access is a bit annoying. It does seem to make sense to expose an OutputStream if possible."],"labels":["T-Enhancement","O-Community"]},{"title":"Debug why CI cache doesn't work","body":"DO NOT MERGE","comments":["We found the root cause. Which was a bug in the `buildDockerEnv` function. It has been fixed, but the network in CPH is currently so slow, it doesn't make sense to cache Docker images while we use these nodes.\r\n\r\nCurrently, there are two paths forward:\r\n\r\n1) Wait for CPH to upgrade the network (which in progress)\r\n2) Wait for AWS enabled nodes with KVM support (also in progress)\r\n\r\nUntil either of those two options are available. This PR is blocked."],"labels":["Blocked"]},{"title":"Fix JavaDoc linking to external classes","body":"In\u00a0[https:\/\/github.com\/realm\/realm-java\/pull\/6929](https:\/\/github.com\/realm\/realm-java\/pull\/6929)\u00a0we disabled Strict mode which is hiding a number of issues. Most importantly is that linking\u00a0 to external classes like those found in the bson dependency does not work.\n\nMost likely we need to add the bson dependency to the classpath, but it isn't clear exactly how:\u00a0[https:\/\/github.com\/realm\/realm-java\/blob\/v10\/realm\/realm-library\/build.gradle#L263](https:\/\/github.com\/realm\/realm-java\/blob\/v10\/realm\/realm-library\/build.gradle#L263)\n\n","comments":["\u27a4 Claus R\u00f8rbech commented:\n\n[~christian.melchior]\u00a0How does this materialize? I re-enabled strict mode locally and do not get any errors generating the Javadoc. Maybe I am not triggering the correct task?\u00a0\n\nAnd do we in fact want linking to external libraries, or was it just due doclint errors?","It does build correctly, but it is links to Android and BSON Types are not working. If configured correctly you should be able to click on those types and hop to their Javadoc.\r\n\r\nAt least it has worked like that in the past. Not sure how much effort we want to put into it, but we should at least look into it at see if there is a quick fix.","\u27a4 Claus R\u00f8rbech commented:\n\nI tried it out, but did not really find any immediate fix. Some observations though:\n\n  * Sometime I got the errors about external links while sometimes I did not. Also from clean builds!?!?\n  * Tried running `javadoc` from the command line with `-link` option and it did not work out\n  * I tried a oneshot with\u00a0https:\/\/github.com\/vanniktech\/gradle-android-javadoc-plugin ( https:\/\/github.com\/vanniktech\/gradle-android-javadoc-plugin )\u00a0which should at least link to Android docs, but it also did not work"],"labels":["T-Bug"]},{"title":"Embedded Objects: Add support for unmanaged DynamicRealmObject","body":"Currently, it is impossible to use the DynamicRealm API to insert embedded objects into lists in other positions than at the end. This is because this requires using the methods `RealmList.add(index, unmanagedObject)` or `RealmList.set(index, unmanagedObject)`.\n\nFor this to work we need to support unmanaged versions of DynamicRealmObject which currently isn't possible and most likely require rethinking the DynamicRealmObject class hiearchy.\n\n","comments":["A workaround for this will be to use `dynamicRealm.createEmbeddedObject(\"EmbeddedClass\", \"ParentClass\", \"parentListProperty\")` (which will create the object in the end of the list) and then use the list API `move()` to reshuffle the list. \r\n\r\nIt isn't ideal but will cover the use case. So we will deprioritize this unless there is significant demand for it."],"labels":["T-Enhancement","MongoDBRealm"]},{"title":"Investigate Scoped Storage in Android 11 and document how it works with Realm","body":"#### Goal\nApp with Realm runs fines on previous and current version of Android except on Android 11. I understand this is a preview OS. I just want to know if this issue is known, if anyone else is experiencing this.\n\n#### Actual Results\n2020-06-02 10:16:31.702 2915-2915\/com.patapon.disconnect E\/REALM_JNI: jni: ThrowingException 5, flock() failed: Function not implemented in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107, .\n2020-06-02 10:16:31.703 2915-2915\/com.patapon.disconnect E\/REALM_JNI: Exception has been thrown: Unrecoverable error. flock() failed: Function not implemented in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\n2020-06-02 10:16:31.704 2915-2915\/com.patapon.disconnect E\/EventBus: Could not dispatch event: class com.patapon.ble.events.TanthenticationState to subscribing class class com.patapon.disconnect.components.AppComponentStore\n    io.realm.exceptions.RealmError: Unrecoverable error. flock() failed: Function not implemented in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 107\n        at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(Native Method)\n        at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:175)\n        at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:251)\n        at io.realm.BaseRealm.<init>(BaseRealm.java:137)\n        at io.realm.BaseRealm.<init>(BaseRealm.java:104)\n        at io.realm.Realm.<init>(Realm.java:163)\n        at io.realm.Realm.createInstance(Realm.java:499)\n        at io.realm.RealmCache.createInstance(RealmCache.java:507)\n        at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:473)\n        at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:414)\n        at io.realm.Realm.getInstance(Realm.java:428)\n        at com.patapon.disconnect.repo.RealmRepository.initialize(RealmRepository.kt:98)\n        at com.patapon.disconnect.components.TKG.createRepo(TKG.kt:40)\n        at com.patapon.disconnect.components.AppComponentStore.onTanthenticationState(AppComponentStore.kt:215)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at org.greenrobot.eventbus.EventBus.invokeSubscriber(EventBus.java:507)\n        at org.greenrobot.eventbus.EventBus.invokeSubscriber(EventBus.java:501)\n        at org.greenrobot.eventbus.HandlerPoster.handleMessage(HandlerPoster.java:67)\n        at android.os.Handler.dispatchMessage(Handler.java:106)\n        at android.os.Looper.loop(Looper.java:223)\n        at android.app.ActivityThread.main(ActivityThread.java:7478)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:549)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:941)\n2020-06-02 10:16:31.704 2915-2915\/com.patapon.disconnect E\/AbbaZaba: [M] Caused by EventBus event: com.patapon.ble.events.TanthenticationState@238c987\n\n#### Steps & Code to Reproduce\nIt crashes when instantiating realm\n\nval config = RealmConfiguration.Builder()\n                    .directory(File(Environment.getExternalStoragePublicDirectory(location + \"\/RealmDb\"))\n                    .name(\"testdb\")\n                    .also {\n                        k?.let { key ->\n                            it.encryptionKey(key)\n                        }\n                    }\n                    .build()\n\nRealm.getInstance(config)\n\n#### Version of Realm and tooling\nRealm version(s): io.realm:realm-gradle-plugin:7.0.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 4.0\n\nAndroid Build Tools version: 28.0.0\n\nGradle version: 3.6.3\n\nWhich Android version and device(s): Android 11 (R) preview, Google Pixel 3\n\n","comments":["That sounds really surprising `flock` is a standard Linux system call. I would be very surprised if they changed anything around this.\r\n\r\nMost likely it is related to using `Environment.getExternalStoragePublicDirectory()`. They introduced a lot of restrictions around how you can access External Storage and there is a chance that Realm will no longer be able to store data there, but we haven't investigated that yet: https:\/\/developer.android.com\/preview\/privacy\/storage","I also encountered this problem. With Android 11 and the scope model we cannot use external storage but only the app's internal space.\r\n\r\nI know that i will migrate all data of the users but at the moment only for test:\r\n\r\nmigrate this:\r\n\r\nFile directory = new File(Environment.getExternalStorageDirectory(), ConstantsApp.ROOT_DIRECTORY_FOLDER);\r\nFile realmDBFolder = new File(directory, ConstantsApp.REALM_ARCHIVE_DIRECTORY_FOLDER);\r\n\r\nto this:\r\n                \r\nFile directory = new File(getExternalFilesDir(null), ConstantsApp.ROOT_DIRECTORY_FOLDER);\r\nFile realmDBFolder = new File(directory, ConstantsApp.REALM_ARCHIVE_DIRECTORY_FOLDER);\r\n\r\nthe app works well after init realm with this file configuration. ","I am experiencing the same issue as originally reported in this ticket under Android 11 on a recent update to a number of customer-owned Samsung devices.\r\n\r\nWhere it gets interesting is that the error does not occur when accessing the built-in external storage, but only the removable external storage (SD card). In both cases, the Realm database should be located under one of the appropriate directories returned by Content.getExternalFilesDirs().\r\n\r\nThe specific error is:\r\n\r\nUnrecoverable error. flock() failed: Function not implemented in \/Users\/cm\/Realm\/realm-java-release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 101\r\n\r\nThe devices models reporting this error so far are:\r\n\r\nSM-N975U\r\nSM-G781V\r\nSM-G975U\r\nSM-N986U1\r\n\r\nAll are Samsung devices running Android 11.\r\n\r\nI will reach out to these customers and investigate this further. What is rather confusing is that this error does not occur when accessing the built-in external storage.","OPPO CPH2043 also have this problem.","An update: I can reproduce this on an emulator running Android API 30 (11) by configuring a secondary SD card as well as forcing my app to use scoped storage in the developer settings.\r\n\r\nAgain, this only occurs when accessing the secondary SD card.","The problem is that flock does not work with fat32 fs. Before Android 11 it was not working too, but without error ret code. Beginning with Android 11 it returns ENOSYS.","> The problem is that flock does not work with fat32 fs. Before Android 11 it was not working too, but without error ret code. Beginning with Android 11 it returns ENOSYS.\r\n\r\n@vok1980 That makes sense, thanks for commenting. Unfortunately the emulator only supports FAT32, but I will try and test with an ext4 format on a physical device. In the meantime, @cmelchior you may want to change the title of this issue again to reflect the need to address the behaviour of flock() on Android 11.","For anyone arriving here: `flock` indeed fails with errno 38, but POSIX advisory locks with `fcntl` work on Emulator + Android 11 + `Environment.getExternalStorageDirectory()` if `MANAGE_EXTERNAL_STORAGE` is requested (and enabled by the user in the settings).","(and be sure to check out the caveats of POSIX advisory locks explained in https:\/\/www.sqlite.org\/src\/artifact\/c230a7a24?ln=994-1081)","Seems like things have changed with the new Android 14 beta. Users are reporting [crashes](https:\/\/github.com\/ppy\/osu\/discussions\/23214#discussioncomment-5702247) when using directories that the app should have access to.\r\n\r\nWe're using [`getExternalFilesDir`](https:\/\/developer.android.com\/reference\/android\/content\/Context#getExternalFilesDir(java.lang.String)) and realm is crashing with the same assertion:\r\n```\r\nAssertion failed: r == 0 && \"File::unlock()\" with (r, (*__errno())) =  [-1, 38]\r\n```\r\n\r\nThe docs mention that there should be no problems with accessing this location:\r\n> Starting in `Build.VERSION_CODES.KITKAT`, no permissions are required to read or write to the returned path; it's always accessible to the calling app.","@Susko3 `getExternalFilesDir` should not have been working since Android 11: https:\/\/developer.android.com\/about\/versions\/11\/privacy\/storage ?","Unless I'm misunderstanding something, the docs you linked [explicitly permit](https:\/\/developer.android.com\/about\/versions\/11\/privacy\/storage#app-specific-external) using `getExternalFilesDirs()` (note the plural):\r\n\r\n> Starting in Android 11, apps cannot create their own [app-specific directory on external storage](https:\/\/developer.android.com\/training\/data-storage\/app-specific#external). **To access the directory that the system provides for your app, call [getExternalFilesDirs()](https:\/\/developer.android.com\/reference\/android\/content\/Context#getExternalFilesDirs(java.lang.String)).**\r\n\r\nIn the `getExternalFilesDirs()` docs, it's mentioned that\r\n>The first path returned is the same as [getExternalFilesDir(java.lang.String)](https:\/\/developer.android.com\/reference\/android\/content\/Context#getExternalFilesDir(java.lang.String)).\r\n\r\nBesides, I can confirm this working fine on an Android 11 devices (the app targets API 31 - Android 12).\r\n\r\nReading the [Android 14 summary](https:\/\/developer.android.com\/about\/versions\/14\/summary) page, I'm not noticing anything that could break this functionality."],"labels":["T-Help","O-Community"]},{"title":"Split up ClassMetaData in parser and data holder","body":"`ClassMetaData` is used by the annotation processor to hold data about a an analyzed class, but currently it is doing to much which both read the readability and maintainability of the class.\n\nWe should consider splitting it in two.\n\nFor reference, see https:\/\/github.com\/realm\/realm-java\/pull\/6730#discussion_r433964884\n\n","comments":[],"labels":["T-Internal","Design-Required"]},{"title":"MongoDB Realm callFunction with explicit timeout","body":"#### Describe your problem or use case\nCurrently timeout for all \n    ```    Functions#callFunction(String, List<?> args, ...)```\nrequests is inherited from the uniform timeout set through \n    ```    RealmAppConfiguration.Builder#requestTimeout(long, TimeUnit)```\n\nStitch API included a  [`callFunction`](https:\/\/docs.mongodb.com\/stitch-sdks\/java\/4\/com\/mongodb\/stitch\/android\/core\/StitchAppClient.html#callFunction(java.lang.String,java.util.List,java.lang.Long)) variant with explicit request timeout. \n\n#### Describe the solution you'd like\nConsider adding a similar variant\/option to set timeout for individual `callFunction` requests.","comments":["\u27a4 Christan Melchior commented:\n\nWe are deprioritizing this unless there is requests for support."],"labels":["MongoDBRealm"]},{"title":"RealmList\/RealmMap in Kotlin does not correct detect nullability of generic type.","body":"Example:\r\n\r\n```\r\nvar dogs: RealmList<ObjectId> = RealmList(),\r\n```\r\n\r\nThis looks like the `ObjectId` is required, but in fact, it is encoded as nullable, as indicated by this error from Sync:\r\n\r\n```\r\n2020-05-19 14:05:50.041 9454-9494\/io.realm.test E\/REALM_SYNC: Connection[2]: Session[2]: Failed to transform received changeset: Schema mismatch: Property 'dogs' in class 'SyncPerson' is nullable on one side and not on the other.\r\n ```\r\n\r\nAlso changing it to this, makes it work:\r\n\r\n```\r\n@Required\r\nvar dogs: RealmList<ObjectId> = RealmList(),\r\n```\r\n\r\nWe should find a way to detect this correctly. Unfortunately this information is most likely encoded in the Kotlin metadata, and last we looked it wasn't easy getting that information out: https:\/\/github.com\/realm\/realm-java\/issues\/5446\r\n\r\nBut we should take a new look at https:\/\/github.com\/JetBrains\/kotlin\/tree\/master\/libraries\/kotlinx-metadata\/jvm and I do recall seeing mentions of other libraries that might help out (but cannot remember what they are named right now).\r\n\r\nAdditionally, the `List.add` and `Map.put` interface methods break the type safety in Kotlin:\r\n```\r\nvar myList: RealmList<Boolean> = RealmList()\r\nmyList.add(null)    \/\/ should NOT be allowed but it is and Core stores null in the list\r\n\r\nvar myDictionary: RealmDictionary<Boolean> = RealmDictionary()\r\nmyDictionary.put(\"hello\", null)    \/\/ should NOT be allowed\r\n```\r\n\r\nThese last two cases are tricky since both implementations of `RealmList` and `RealmMap` (and by extension `RealmDictionary`) allow nullable values to be inserted:\r\n\r\n```\r\n\/\/ RealmList.add\r\npublic boolean add(@Nullable E object)\r\n\r\n\/\/ RealmMap.put\r\npublic V put(K key, @Nullable V value)\r\n```\r\n\r\nIf the `@Nullable` isn't present then inserting null values isn't allowed at all from Kotlin even when using `?` to mark the type as nullable.","comments":["This is similar to https:\/\/github.com\/realm\/realm-java\/issues\/6845 and both can probably be solved together, but it requires us to analyze the Kotlin metadata as the information isn't directly available in the Java bytecode."],"labels":["T-Bug"]},{"title":"Add Support for RxJava 3","body":"#### Describe your problem or use case\nPlease add support for RxJava 3 to Realm 7+\n\nhttps:\/\/github.com\/ReactiveX\/RxJava","comments":["Can also see a dependency on RxAndroid v2 in v7, is this needed?\r\n\r\n```\r\n+--- io.realm:realm-android-library:7.0.0\r\n|    +--- com.google.code.findbugs:jsr305:3.0.2\r\n|    +--- com.getkeepsafe.relinker:relinker:1.4.0\r\n|    +--- io.reactivex.rxjava2:rxandroid:2.1.1\r\n|    \\--- io.realm:realm-annotations:7.0.0\r\n``` ","> Can also see a dependency on RxAndroid v2 in v7, is this needed?\r\n> \r\n> ```\r\n> +--- io.realm:realm-android-library:7.0.0\r\n> |    +--- com.google.code.findbugs:jsr305:3.0.2\r\n> |    +--- com.getkeepsafe.relinker:relinker:1.4.0\r\n> |    +--- io.reactivex.rxjava2:rxandroid:2.1.1\r\n> |    \\--- io.realm:realm-annotations:7.0.0\r\n> ```\r\n\r\n    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'\r\n\r\nThere's a release for rxandroid updated to RxJava3","Rxjava 2 support ends on February 28, 2021. This is becoming more pressing.","An option is also https:\/\/github.com\/akarnokd\/RxJavaBridge#RxJavaBridge","Am I missing something or has this still not happened yet?","Would be good to be updated on that topic @cmelchior. What is the plan about it ?","Any updates on this issue @cmelchior? "],"labels":["Design-Required","O-Community","Pipeline-Idea-Backlog"]},{"title":"Kotlin: Private fields are Nullable in database even if property is marked as non-null","body":"#### Goal\nUse private fields to store custom types or enums.\nFor example: \n\n```\n\/\/Foo.kt\n\nenum class MyEnum {\n    FOO\n}\n\nopen class Foo: RealmObject() {\n\n    private var _enum: String = MyEnum.FOO.name\n    var enum: MyEnum\n        get() { return MyEnum.valueOf(_enum) }\n        set(value) { _enum = value.name }\n    \n\n    var myString : String = \"myString\"\n}\n```\n\n#### Actual Results\nWhen the Kotlin code gets compiled into Java bytecode, the field ```_enum``{{ won't be annotated with }}``@NotNull```. As a consequence the field _enum in the database will be nullable.\n\n#### Steps & Code to Reproduce\nCreate the file Foo.kt in Android Studio and run your project. Afterwards you can copy your ```myRealm.realm``{{ file from }}``\/data\/data\/com.example.myProject\/files\/myRealm.realm``{{ via the Device File Explorer to your computer and open the file via RealmStudio. In the class Foo the field }}``_enum``{{ will not be }}``String``{{, but }}``String?```\n\n#### Version of Realm and tooling\nRealm version(s): 6.1.0\n\nRealm Sync feature enabled: No\n\nKotlin version 1.3.72\n\nAndroid Studio version: 3.6.3\n\nWhich Android version and device: Any device\nminSdkVersion 21\ntargetSdkVersion 29\ncompileSdkVersion 29\n\nAndroid Build Tools version: 29.0.3\n\nGradle version: 5.6.4\n\n","comments":["Hmm, that sounds odd. The String should be non-null in Kotlin. Will investigate.","I also posted a question on SO as to why this occurs, since this happens not only for Realm, but in general when using private properties in a class.\r\n[Private String properties are nullable in decompiled .java class Kotlin](https:\/\/stackoverflow.com\/questions\/61662316\/private-string-properties-are-nullable-in-decompiled-java-class-kotlin)","We can probably detect this by looking at the Kotlin metadata instead of relying on the @NotNull annotation being present.\r\n\r\nIn  the meantime, you can manually add the `@Required` annotation."],"labels":["T-Bug","O-Community"]},{"title":"Typed Query API feature parity","body":"We should attempt to get feature parity with regards to query features. Either through #6116 or new custom predicates.\n\nRight now the most promising approach seems #6116, but this needs to be evaluated.\n\nTODO\n- [ ] Figure out list of missing predicates","comments":[],"labels":["T-Feature","Design-Required"]},{"title":"Consider letting SyncSession.downloadAllServerChanges() also refresh the Realm","body":"Consider the following test code:\n\n```\n        val realm = Realm.getInstance(config2)\n        realm.syncSession.downloadAllServerChanges()\n        \/\/ realm.refresh() Required for below code to work\n        assertEquals(10, realm.where<SyncDog>().count())\n        assertEquals(1, realm.where<SyncPerson>().count())\n```\n\nBy reading it you would assume it would work, but it doesn't. The reason is that `downloadAllServerChanges` run on the Sync Client worker thread and when it completes the caller thread has not been updated yet.\n\nInstead, you manually need to add a `realm.refresh()` after calling `download()`.\n\nWe should consider doing that automatically. Realms normally using this API are not looper threads, so we don't need to be particularly worried about callbacks.\n\nThe only annoying thing is that the Session and Realm are largely uncoupled. The session is e.g. not thread confined, while the Realm is. So we need a clever way of finding any open Realms on the current thread, and there might be multiple (think typed and Dynamic Realm).\n\nBut maybe this is just too confusing...something to ponder.","comments":[],"labels":["T-Enhancement","Design-Required"]},{"title":"Could not find 'librealm-jni.so'. Looked for: [x86], but only found: [].","body":"#### Goal\nI know there are some bugs with missing librealm-jni.so, but this is the biggest issue I have when using Realm and Bundle. \n\n#### Actual Results\nUsers have occurred following error:\nCould not find 'librealm-jni.so'. Looked for: [x86], but only found: [].\n\nDevice:  Nexus 4\nAndroid version:  6.0.1\n\n#### Version of Realm and tooling\nRealm version(s): 6.1.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 4.0\nAndroid Build Tools version: 29.0.2\n\nGradle version: 6.3\n\nWhich Android version and device(s):  Nexus 4 \/ 6.0.1\n\n","comments":["This looks a bit weird. Nexus 4 is not a x86 device. Did this error message come from running on the actual device?\r\n\r\nI have seen that error message a few times before, but only when running apps on the emulator from inside Android Studio. In that case it is important that the ABI matches exactly the ABI of the device.","Yes, it is coming from an actual device. At least no emulator from my side.\r\nHere is the full data of the Crashlytics log:\r\n\r\nBrand: LGE\r\nModel: Nexus 4\r\nOrientation: Portrait\r\nRAM free: 1.07 GB\r\nDisk free: 284.57 MB\r\nOperating System\r\nVersion: 6.0.1\r\nOrientation: Portrait\r\nRooted: No\r\n\r\n\r\nAnother device is the Galaxy J2 Core.\r\n\r\n`Looked for: [armeabi-v7a, armeabi], but only found: []`\r\n\r\nBrand: samsung\r\nModel: Galaxy J2 Core\r\nOrientation: Portrait\r\nRAM free: 229.91 MB\r\nDisk free: 9.82 GB\r\nOperating System\r\nVersion: 8.1.0\r\nOrientation: Portrait\r\nRooted: No\r\n","It is a bit unclear what the issue is and without access to the APK itself, it might be hard to find out.\r\n\r\nWhat the error says though is that the APK doesn't contain any native code for some reason. We have seen various reports of this kind from people using App Bundle, so far no conclusive root cause has been found.","I have the same issue with LGE. so a user cannot use the app because of\r\n **Looked for: [armeabi-v7a, armeabi], but only found: []**\r\n\r\n\r\nBrand: LGE\r\nModel: Nexus 4\r\nOrientation: Portrait\r\nRAM free: 1.1 GB\r\nDisk free: 293.11 MB\r\nOperating System\r\nVersion: 6.0.1\r\nOrientation: Portrait\r\nRooted: No\r\n\r\n","What we know so far:\r\n\r\n1) This error happens if you run your app on an emulator that doesn't match exactly the ABI provided by Realm, e.g. if you try to run `x86_64` code on an `x86` emulator. C\r\n\r\n2) if the app has been created using App Bundles it can also happen when installing the app from Google Play. It is unclear what happens here. In theory, Google Play should ship the correct ABI to the device the APK is being installed on. It could point to an error in how Google Play handles App Bundles, but we have no concrete evidence nor idea how to test this hypothesis.\r\n\r\n3) It might happen if people are sideloading the APK without considering they are different architectures, but in that case, the error would look something like: `Looked for: [armeabi-v7a], but only found: [x86]`\r\n\r\nWe will keep this issue open in order to get more feedback.","I'm also getting this error recently from devices running android 8.1.0. Motorola One Vision (rooted) and Nexus 5X\r\n\r\nNexus 5X android 8.1.0.\r\n`Could not find 'librealm-jni.so'. Looked for: [x86], but only found: [].`\r\n\r\nMotorola One Vision (rooted) android 8.1.0.\r\n`Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: []`\r\n\r\nThis issue has 23 crash events affecting 3 users. I have other native libraries in my app but I didn\u2019t see any errors related to those libs, except the following crash that happened a month ago,\r\n\r\n`Caused by java.lang.UnsatisfiedLinkError: dlopen failed: library \"\/data\/app\/~~9XihzNW7ULPF6yR6-VVj4Q==\/com.myapp.package-mK9ZhQGY7rMRjU2sukTrUA==\/split_config.arm64_v8a.apk!\/lib\/arm64-v8a\/libsecrets.so\" not found`\r\n\r\nCan this happen if someone is trying to modify the apk?\r\n","Hi @SujithManjavana. If somebody repacks the apk it could be an issue, so anything like that would be a possibility and there is even more things that could be off with rooted devices (repackaging on installation ect.). \r\n\r\nIt if get further we insight into what is going on, please feel free to share.","This error is spiking in my Crashlytics dashboard. This issue has 40 crash events affecting 7 users (My app only has less than 3000 installs).\r\nThese are the devices affected,\r\nNexus 5X\r\nHUAWEI WDGF4587\r\nQEMU Standard PC (Q35 + ICH9, 2009) <= Someone experimenting with my apk?\r\nMotorola One Vision\r\n\r\nFor a similar issue, someone suggested to use `android.bundle.enableUncompressedNativeLibs=false`\r\n[https:\/\/github.com\/algolia\/algoliasearch-client-android\/issues\/576#issuecomment-494148605](url)\r\n\r\n[https:\/\/corbt.com\/posts\/2015\/09\/18\/mixing-32-and-64bit-dependencies-in-android.html](url)\r\nThis blog post says that Android won't be able to load 32- and 64-bit native libraries concurrently. In my app, I'm also using other libraries such as uCrop.  The solution he suggested is to simply exclude all 64-bit binaries from your APK. \r\n\r\nDoes anyone know the implications of the above-mentioned fixes?","The same issue as above: Could not find 'librealm-jni.so'. Looked for: [x86], but only found: [].\r\nDevice: Nexus 5X Android 8.1.0","@alexeyVh @SujithManjavana This has started appearing to my app after updating `com.android.tools.build:gradle` to `7.3.1` from version `7.3.0`. Also in that deployment I have updated `com.google.firebase:firebase-crashlytics` to `18.3.1` from version`18.2.13`.\r\n\r\nDoes anything from above seems similar to your case? Have you solved the issue yet?","@farmaker47 absolutely the same for me. The issue not solved, but doesn't seem critical - happens on two devices where one is rooted.","In my case, there were non-rooted phones too. 'com.android.tools.build:gradle:7.2.2'","Similar crash for me: `Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].` \r\nIt's mostly on rooted devices, but is still occurring on a handful of non-rooted devices.\r\nRooted devices:\r\n- Motorola One Vision (Android v8.1.0)\r\n- Galaxy Tab A (Android v7.1.2)\r\n\r\nNon-rooted:\r\n- MOA-LX9N (Android v10)","Unfortunately I had to remove completely the library.","Same issue here, LGE Nexus 5x, Android 8.1.0, not rooted","I have some events in crashlytics logging this error.\r\nThe problem is specific for the LGE Nexus 5.","Sentry reveals that devices which the app crashes from installed the sideloaded apk. It could be a reason.","I also experience the issue in my app, there are quite many crashes for several users. And as mentioned before the issue happens mainly for LGE Nexus 5 Android 8.1.0 (but not only).\r\n\r\nI unpacked the bundle binary and it looks like all required versions of realm library are there. So it's more about serving a proper version of the library from Google Play to devices. But not sure if it depends on any realm and\/or app project settings. I don't see such issue for other used libraries.","I have the same issue, since we switched to app bundles recently.\r\n\r\nMaybe interesting - to use our app, a user needs to be logged in and we're adding the user's id in the crash report.\r\nFor all reported crashes, there was no user logged in, which is very strange (as it is only rolled out to beta users at the moment, and you'd expect them to be logged in). Since APK sideloading was mentioned by others, I was thinking, maybe the crashes could be caused by some of those alternate app stores that exist, which basically grab apps from the playstore, convert into APKs and provide them?","I have seen this issue too for LG Nexus 5","Nexus 5X here, too","Getting reports too with the same device.","Nexus 5 here too. Same issue.","Same issue.\r\n- Huawei Enjoy 9s (Android 8.1.0)\r\n- Nexus 5X (Android 8.1.0)\r\n- OnePlus8Pro (Android 11)","Android Version: 8.1.0\r\nDevice: Samsung Galaxy J2 Core\r\n\r\n`Fatal Exception: java.lang.RuntimeException: Unable to start activity ComponentInfo{activity.MainActivity}: w3.b: Could not find 'librealm-jni.so'. Looked for: [armeabi-v7a, armeabi], but only found: [].\r\n       at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2789)\r\n       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2872)\r\n       at android.app.ActivityThread.-wrap11()\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1595)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:164)\r\n       at android.app.ActivityThread.main(ActivityThread.java:6543)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:440)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:810)`","Same here on Nexus 5X, Galaxy J7 Pro, Android 8.\r\nK30 PRO, Android 12.\r\nFind X6, Poco F5 Pro, Galaxy S23 Ultra, Galaxy S23, Xperia 1 V, Android 13.\r\n\r\nFatal Exception: java.lang.RuntimeException: Unable to create application com.ihad.ptt.App: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [x86], but only found: [].\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5743)\r\n       at android.app.ActivityThread.-wrap1()\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1656)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:164)\r\n       at android.app.ActivityThread.main(ActivityThread.java:6494)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)\r\n\r\nFatal Exception: java.lang.RuntimeException: Unable to create application com.ihad.ptt.App: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [armeabi-v7a, armeabi], but only found: [].\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6100)\r\n       at android.app.ActivityThread.-wrap1()\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1791)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:164)\r\n       at android.app.ActivityThread.main(ActivityThread.java:7000)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:441)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1408)\r\n\r\nFatal Exception: java.lang.RuntimeException: Unable to create application com.ihad.ptt.App: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [arm64-v8a, armeabi-v7a, armeabi], but only found: [].\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:7246)\r\n       at android.app.ActivityThread.-$$Nest$mhandleBindApplication()\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2296)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loopOnce(Looper.java:240)\r\n       at android.os.Looper.loop(Looper.java:351)\r\n       at android.app.ActivityThread.main(ActivityThread.java:8399)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:584)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1013)\r\n\r\n\r\ncom.android.tools.build:gradle:7.4.2\r\nio.realm:realm-gradle-plugin:10.5.1\r\nio.realm:realm-gradle-plugin:10.16.1\r\n\r\n\r\nAndroid app bundle.","We cannot tolerate our app crashing, but this error is so fundamental that our app can't work without a database, so we just catch the error, record the event on crashlytics and finish the application. It's a temporal fix since this error doesn't happen very frequently.\r\n\r\n```\r\ntry {\r\n     Realm.init(context);\r\n} catch (RuntimeException e) {\r\n     FirebaseCrashlytics.getInstance().recordException(e);\r\n     finish();\r\n     return;\r\n}\r\n```","We have received similar [reports](https:\/\/github.com\/realm\/realm-kotlin\/issues\/1202#issuecomment-1609094782) to this one, we think this issue is related to app bundle distribution and is not related to the Realm library. There are other parties affected by it.\r\n\r\nIn version Realm Kotlin SDK`1.10.0` we disabled Relinker on Android SDK >= 23, in an effort of fixing the issue, but unfortunately from your report looks like it didn't.\r\n\r\nThe issue might be caused by users moving the app to the SD card, see  [Google issue](https:\/\/issuetracker.google.com\/issues\/127691101), could you check if any of the solutions discussed there fixes the issue? We are not able to reproduce the issue at our end.\r\n\r\n- setting the gradle property `enableUncompressedNativeLibs=false`, or\r\n- adding the following to your `build.gradle`: \r\n```\r\nandroid {\r\n    packagingOptions {\r\n        jniLibs {\r\n            useLegacyPackaging = true\r\n        }\r\n    }\r\n}\r\n```","> We have received similar [reports](https:\/\/github.com\/realm\/realm-kotlin\/issues\/1202#issuecomment-1609094782) to this one, we think this issue is related to app bundle distribution and is not related to the Realm library. There are other parties affected by it.\r\n> \r\n> In version Realm Kotlin SDK`1.10.0` we disabled Relinker on Android SDK >= 23, in an effort of fixing the issue, but unfortunately from your report looks like it didn't.\r\n> \r\n> The issue might be caused by users moving the app to the SD card, see [Google issue](https:\/\/issuetracker.google.com\/issues\/127691101), could you check if any of the solutions discussed there fixes the issue? We are not able to reproduce the issue at our end.\r\n> \r\n> * setting the gradle property `enableUncompressedNativeLibs=false`, or\r\n> * adding the following to your `build.gradle`:\r\n> \r\n> ```\r\n> android {\r\n>     packagingOptions {\r\n>         jniLibs {\r\n>             useLegacyPackaging = true\r\n>         }\r\n>     }\r\n> }\r\n> ```\r\n\r\nNo, it's not.\r\n\r\n```\r\nFatal Exception: java.lang.RuntimeException: Unable to create application com.ihad.ptt.App: com.getkeepsafe.relinker.MissingLibraryException: Could not find 'librealm-jni.so'. Looked for: [x86], but only found: [].\r\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5743)\r\n       at android.app.ActivityThread.-wrap1()\r\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1656)\r\n       at android.os.Handler.dispatchMessage(Handler.java:106)\r\n       at android.os.Looper.loop(Looper.java:164)\r\n       at android.app.ActivityThread.main(ActivityThread.java:6494)\r\n       at java.lang.reflect.Method.invoke(Method.java)\r\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\r\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)\r\n```","@KimiChiu Thanks for trying, but what did you try that is not working? Was it the `enableUncompressedNativeLibs` or the `useLegacyPackaging`?","> @KimiChiu Thanks for trying, but what did you try that is not working? Was it the `enableUncompressedNativeLibs` or the `useLegacyPackaging`?\r\n\r\nI tried both of them. The downloading size decreased from 42 to 20. I supposed it's working as the member of Google issue expected. So this setting is working but it couldn't fix it. \r\nIn my case, it only happened on specific devices rarely. I have more than 200k active users but this problem only occurs on less than 10 users repeatedly. 1 or 2 devices of them are rooted.","Is there any fix to this, my errors are showing up in Firebase Testlab on a virtual device, no issues testing on through the Android Studio emulator or a real device.  Testlab errors are generally reliable but I'm not sure what to do in this case\r\n\r\nRobo test, Pixel 2, Virtual, API level 30\r\nFailed\r\n05\/10\/2023, 11:44\r\n1 m 10 s\r\nPortrait\r\nEnglish (United States)\r\nTest issues\r\nRobo\r\nLogs\r\nScreenshots\r\nVideos\r\nPerformance\r\nAccessibility\r\n Fatal exception\r\n\tat byj.run(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:2)\r\n     FATAL EXCEPTION: androidmapsapi-Background_2\r\nProcess: com.xxxxx.tracker, PID: 12801\r\nbaw: Exception while extracting native library.\r\n\tat com.google.android.apps.gmm.jni.util.NativeHelper.safeLoadLibrary(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:8)\r\n\tat com.google.android.apps.gmm.jni.util.NativeHelper.ensureLibraryLoaded(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:4)\r\n\tat dcu.run(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:0)\r\n\tat bwx.run(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:0)\r\n\tat byj.run(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:2)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\r\n\tat bxu.run(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:4)\r\n\tat java.lang.Thread.run(Thread.java:923)\r\nCaused by: baw: Zip entry 'lib\/x86_64\/libgmm-jni.so' not found in APK '\/data\/app\/~~PTXqqKq_rCGH4fHKlKfcwQ==\/com.lbrooks.tracker-KlwM1SylzjtTtHxNkd2KQA==\/base.apk'\r\n\tat com.google.android.apps.gmm.jni.util.NativeHelper.safeLoadLibrary(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:6)\r\n\t... 8 more\r\nCaused by: java.lang.UnsatisfiedLinkError: dlopen failed: library \"libgmm-jni.so\" not found\r\n\tat java.lang.Runtime.loadLibrary0(Runtime.java:1087)\r\n\tat java.lang.Runtime.loadLibrary0(Runtime.java:1008)\r\n\tat java.lang.System.loadLibrary(System.java:1664)\r\n\tat com.google.android.apps.gmm.jni.util.NativeHelper.safeLoadLibrary(:com.google.android.gms.policy_maps_core_dynamite@231710109@231710104068.542928491.542928491:1)\r\n\t... 8 more","Update from my previous comment...\r\nI found that Firebase Crashlytics was commented out, after allowing Crashlytics the Firebase Testlab ran successfully"],"labels":["T-Help","Reproduction-Required","O-Community"]},{"title":"Supported encrypted Realms across multiple processes","body":"E\/REALM_JNI: jni: ThrowingException 5, \/storage\/emulated\/0\/AndroidWT\/default.realm: Encrypted interprocess sharing is currently unsupported.SharedGroup has been opened by pid: 6583. Current pid is 6461. in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 101, .\nE\/REALM_JNI: Exception has been thrown: Unrecoverable error. \/storage\/emulated\/0\/AndroidWT\/default.realm: Encrypted interprocess sharing is currently unsupported.SharedGroup has been opened by pid: 6583. Current pid is 6461. in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 101","comments":["Yes, this is currently not supported. It is something we want to add, but I do not have a timeline to share with you. This is currently being tracked here: https:\/\/github.com\/realm\/realm-core\/issues\/1845\r\n\r\nI actually thought we had an Java issue tracking it, but cannot find it. So i'll promote this one to that."],"labels":["T-Feature","O-Community"]},{"title":"Add first-class RxJava support for RealmUser asynchronous methods in v10","body":"There are currently a series of asynchronous methods in the RealmUser class, e.g.\n\n`public RealmAsyncTask logOutAsync(RealmApp.Callback<RealmUser> callback)`\n\nThis method requires passing a callback object and process the result asynchronously. This isn't a problem per se. However, in case this operation is carried out within a reactive stream, users would have to create an observable themselves and deal with the emission themselves as well.\n\nHaving methods like\n\n`public Single<RealmUser> logOut()`\n\nwould simplify things quite dramatically for API consumers.","comments":["\u27a4 Christan Melchior commented:\n\nWe need to determine if this is worth doing. Given that we already have native RxJava support elsewhere it might be, but RxJava3 is also out, and with soon incoming support for Coroutines we should probably evaluate this issue in a larger context."],"labels":["Design-Required"]},{"title":"Add findFirst(int), findLast(int) and findRandom(int)","body":"Fixes #1050","comments":[],"labels":["O-Community"]},{"title":"Make debug symbols available in Google Play or Crashlytics (or improve documentation on how)","body":"#### Goal\nFigure out why Crashlytics cannot find symbols to upload for crashlytics.\n\nFiled a similar issue for Crashlytics here: https:\/\/github.com\/firebase\/firebase-android-sdk\/issues\/1316\n\n#### Actual Results\nThe logs for Crashlytics show that symbol files were not found for the `.so` file.\n\n```\n2020-03-05 11:11:23.406 [DEBUG] (Execution worker for ':' Thread 4) com.crashlytics  - Crashlytics found no symbols for \/productionDebug\/out\/lib\/armeabi-v7a\/libcrashlytics.so, skipping.\n2020-03-05 11:11:23.406 [DEBUG] (Execution worker for ':' Thread 4) com.crashlytics  - Generating cSYM for \/productionDebug\/out\/lib\/armeabi-v7a\/librealm-jni.so\n2020-03-05 11:11:23.418 [DEBUG] (Execution worker for ':' Thread 4) com.crashlytics  - Using ELF data for cSYM generation.\n2020-03-05 11:11:23.418 [DEBUG] (Execution worker for ':' Thread 4) com.crashlytics  - Crashlytics found no symbols for \/productionDebug\/out\/lib\/armeabi-v7a\/librealm-jni.so, skipping.\n```\n\n#### Steps & Code to Reproduce\nFollowed steps with https:\/\/realm.io\/docs\/java\/latest\/#ndk-debugging and the Fabric docs to setup Crashlytics. Had to adjust the NDK out dirs to:\n```\ncrashlytics {\n    enableNdk = true\n    androidNdkOut = \"build\/intermediates\/merged_native_libs\"\n    androidNdkLibsOut = \"build\/intermediates\/stripped_native_libs\"\n}\n```\n\n#### Version of Realm and tooling\n\nRealm version(s): 6.0.1\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 3.6.1\n\nAndroid Build Tools version: 29.0.0\n\nGradle version: 5.4.1 wrapper - 3.5.0 plugin\n\nWhich Android version and device(s): Samsung S9, Android 10","comments":["The Realm .so files are not provided with debug symbols due to size. We do have the unstripped .so files available if you need them though, but you need to download them manually from S3. You can see how we do it here: https:\/\/github.com\/realm\/realm-java\/blob\/master\/tools\/unroll_stacktrace.sh#L66","@cmelchior Thanks this is helpful and we will try to integrate that. \r\n\r\nIs it possible to update the Realm Java docs to include some reference to this. Reading the docs it sounded like support for Crashlytics will be enabled for Realm just by following the steps.\r\n\r\n```\r\nNDK debugging\r\nRealm is a library that contains native code. We recommend that you use a crash reporting tool, such as Crashlytics, to track native errors so we are in a better position to help you if something goes wrong.\r\n\r\nDebugging NDK crashes is usually cumbersome as the default stack trace provides minimal information that can be of use. Crashlytics will allow you to capture valuable NDK crash information. To enable NDK crash reporting in Crashlytics, please follow the steps outlined in this guide.\r\n\r\nTo enable NDK crash reporting for your project, add this to the root of your build.gradle file. Please note, the values androidNdkOut and androidNdkLibsOut are not needed.\r\n\r\ncrashlytics {\r\n  enableNdk true\r\n}\r\n```","Is it possible to create some sort of plugin for Android Studio for this? One which gets the debug symbols and packs them into the Android App Bundle to be used in Android Vitals and Crashlytics etc. but which will not be added to the final APK installed on the device?\r\n\r\nThe new Google Play Console warns about missing debug symbols of the native code. I think, everyone will get this warning in the console when using realm from now on?!","@cmelchior which symbols should I upload to Play Store `base` or `objectSaver`? \r\nI'm using Realm Gradle plugin: `'io.realm:realm-gradle-plugin:7.0.8'`.","@iwo `objectServer` is if you are using sync enabled through the realm closure in Gradle:\r\n\r\n```\r\nrealm {\r\n  syncEnabled = true\r\n}\r\n``` \r\n\r\nIf you don't have that you just need the `base` variant.","> Is it possible to create some sort of plugin for Android Studio for this? One which gets the debug symbols and packs them into the Android App Bundle to be used in Android Vitals and Crashlytics etc. but which will not be added to the final APK installed on the device?\r\n> \r\n> The new Google Play Console warns about missing debug symbols of the native code. I think, everyone will get this warning in the console when using realm from now on?!\r\n\r\nI just found a hint in the release notes for Android Studio 4.1 about \"Symbolication for native crash reports\". Just add the following line to the app's `build.gradle` (having the NDK installed) and it will generate debug symbols into the app bundle. When using this, the PlayStore not longer shows the warning.\r\n\r\n`android.buildTypes.release.ndk.debugSymbolLevel = 'SYMBOL_TABLE'`\r\n\r\nReferences:\r\n- https:\/\/android-developers.googleblog.com\/2020\/10\/android-studio-41.html\r\n- https:\/\/support.google.com\/googleplay\/android-developer\/answer\/9848633\r\n","So my adding the symbol level (see https:\/\/github.com\/realm\/realm-java\/issues\/6773#issuecomment-708202945) just helps with the PlayStore but not with crashlytics.\r\n\r\nCrashlytics seem to need a manual upload of native symbols. But the [documentation at realm](https:\/\/realm.io\/docs\/java\/latest\/#ndk-debugging) is outdated. The [current crashlytics documentation](https:\/\/firebase.google.com\/docs\/crashlytics\/ndk-reports) uses different parameters to set the directories.\r\n\r\nI'm stuck now so it seems this issue still exists using the current crashlytics version. Any updates on this?","Is there any related issue with this : https:\/\/stackoverflow.com\/a\/55969995\/2733216 ? They post upload of symbol will come back with NDK 22 when publishing an app in bundle format.\r\nI saw that realm java is built with NDK 21.\r\n\r\n","I tried to achieve uploading symbol anyhow based on the @cmelchior script link. Here is the gradle code:\r\n\r\n```\r\nandroid {\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled true\r\n            firebaseCrashlytics {\r\n                nativeSymbolUploadEnabled true\r\n                unstrippedNativeLibsDir \"build\/realm\/base\"\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nafterEvaluate {\r\n    \/\/ upload symbol files for Crashlytics NDK reports after generating a release build variant\r\n    assembleProdRelease.finalizedBy(downloadAndUnZipUnstrippedRealmLibrary)\r\n    downloadAndUnZipUnstrippedRealmLibrary.finalizedBy(uploadCrashlyticsSymbolFileProdRelease)\r\n}\r\n\r\ntask downloadAndUnZipUnstrippedRealmLibrary {\r\n    def src = \"https:\/\/static.realm.io\/downloads\/java\/realm-java-jni-libs-unstripped-$rootProject.depRealm\" +\".zip\"\r\n    def destdir = \"build\/realm\"\r\n    def destfile = \"$destdir\/realm-java-jni-libs-unstripped-$rootProject.depRealm\" +\".zip\"\r\n    doLast {\r\n        def url = new URL(src)\r\n        def f = new File(destfile)\r\n        if (f.exists()) {\r\n            println \"file $destfile already exists, skipping download\"\r\n        } else {\r\n            mkdir \"$destdir\"\r\n            println \"Downloading $destfile from $url...\"\r\n            url.withInputStream { i -> f.withOutputStream { it << i } }\r\n        }\r\n        def zipFile = new java.util.zip.ZipFile(new File(destfile))\r\n        zipFile.entries().each {\r\n            def path = java.nio.file.Paths.get(\"$destdir\/$it.name\")\r\n            if(it.directory){\r\n                 java.nio.file.Files.createDirectories(path)\r\n            }\r\n            else {\r\n                def parentDir = path.getParent()\r\n                if (! java.nio.file.Files.exists(parentDir)) {\r\n                     java.nio.file.Files.createDirectories(parentDir)\r\n                }\r\n                java.nio.file.Files.copy(zipFile.getInputStream(it), path)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nWould that be right, enough ? "],"labels":["O-Community"]},{"title":"Core 10: Indexes are not supported on primary keys","body":"With Core 10, Indexes are not supported on primary keys as they are not needed. We should\n\n* Log a warning in the annotation processor if `@Index` is added to primary key properties\n* Throw an exception in `RealmObjectSchema` if adding an Index to a primary key property.\n\nSee https:\/\/github.com\/realm\/realm-java\/pull\/6760\n\n","comments":[],"labels":["T-Bug"]},{"title":"Add support for Sync timeouts","body":"Add support for changing timeouts in a similar way to Cocoa:\u00a0[https:\/\/github.com\/realm\/realm-cocoa\/pull\/6375](https:\/\/github.com\/realm\/realm-cocoa\/pull\/6375)\n\nMost of this should probably live on the SyncManager.\n\n","comments":[],"labels":["Design-Required"]},{"title":"Migration test utility for CI","body":"#### Describe your problem or use case\n- It's difficult to officially test realm migrations, especially in environments without access to a device or emulator. Even with access to a device, performing an end-to-end test (e.g. in a production app version) requires installing an app file on top of a pre-existing app file and opening the app to see if the migration succeeded. \n- Tests can be written & test `Realm`s with injected realm files can be created to validate realm migrations in a testing environment, but there's still a bit of data setup and boilerplate involved\n\n#### Describe the solution you'd like\n- A migration test utility that can perform the same migration checks on initialization that occur when an app (in this case Android) is installed, without a device or emulator required\n- This could be a script\/executable, or a separate Gradle task\/module, etc, that takes two realm files as input and outputs the same information within the `RealmMigrationNeededException` that is printed to the console on startup\n- Ideally this would not depend on the Android framework so it could run in a scripting\/CI environment\n\n#### Additional context\n- We can hack together a CI solution to solve this problem and detect realm migrations as a pull request confirmation step, but it's fairly messy and hard to detect when the app has started up or crashed. \n\n#### Questions\n- Is something like this currently even possible, given how Realm is setup today? \n- If so, is this something that can be accomplished in a 3rd party\/community PR?\n- Is this something that must _always_ rely on the Android framework, given how Realm is setup today? Or is it possible to run as a standalone tool outside of Android?\n\n\nDigging around in the realm repository, looking at [this](https:\/\/github.com\/realm\/realm-java\/blob\/0e1464114782f88165309bd0d73d13a8fde72ab7\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp#L64) makes me think that the migration detection happens in native code. \n\nI'd love to help make this a reality and contribute, and I can provide help in the Gradle\/Android side of things, but my knowledge of CPP is limited.","comments":["We do have Node support, so theoretically it is possible to run some scripts through that.\r\nDetecting schema mismatches might be bit more problematic though because it would also require you having the schema definitions in JavaScript and right now you just have them in Java.\r\n\r\nI'll need to check to see if there is an easy way to export the schema to JS. Realm Studio can do it, but since that is a UI tool, it doesn't really help for automated tests.","Thanks for the info! I'm not familiar at all with Node support in Realm, could you provide some more detail on what that theoretically might look like? What form would the extracted schema export component take? How is it used within Realm Studio?"],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"Specify callback thread for all methods accepting one","body":"We should make sure to specify in the Javadoc for methods accepting a callback on which thread the callback is triggered on.","comments":[],"labels":["T-Doc"]},{"title":"Add API for deleting synchronized Realms","body":"Deleting synchronized Realms using _Realm.deleteRealm(syncConfig)_\u00a0is rather difficult as sync is usually running after the Realm is closed and the underlying Sync Client might not have fully closed yet.\n\nWhile we could somewhat work around this by having users manually closing the sync session or expose the stop policy, it does not remove the async nature of the sync client.\n\nSo in order to better support this use case we probably need to expose an asynchronous delete operation. How exactly this is going to look like is up for debate.\u00a0\n\nCurrent options I could think of :\n\n* Have a _Realm.deleteRealm(config, callback)_ method. It might be confusing with it having different semantics than the synchronous one. We could opt to deprecate the synchronous better, but normally we have both synchronous and asynchronous variants of API methods.\n* Have a specific method only for synchronized Realms. Perhaps on the SyncManager: _SyncManager.deleteRealm(syncConfig, callback) ._ But it is annoying to have delete methods in multiple locations.\n* Some other alternative...\n\n","comments":[],"labels":["Design-Required"]},{"title":"Out of memory: Be able to open large files.","body":"#### Goal\n\nStore 1000 records, each containing two short strings and 1MB byte array.\n\n#### Actual Results\n\nIt seems (from the stack trace below) that it tries to allocate enormous RAM, which is strange to me...\n\nio.realm.exceptions.RealmError: Unrecoverable error. mmap() failed: Out of memory size: 1207959552 offset: 0 in \/Users\/kk\/Desktop\/MbiPersisterStudy\/RealmBuild\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 101\n        at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(Native Method)\n        at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:171)\n        at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:241)\n        at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:231)\n        at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:332)\n        at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:285)\n        at io.realm.Realm.getDefaultInstance(Realm.java:407)\n        at com.thales.gp.mbi.poc.kk.realm.module.b.MbiRealmCitizenTestInteractor.<init>(MbiRealmCitizenTestInteractor.java:47)\n        at com.thales.gp.mbi.poc.kk.realm.module.b.MbiRealmCitizenTestInteractor.lambda$interaction$0(MbiRealmCitizenTestInteractor.java:23)\n        at com.thales.gp.mbi.poc.kk.realm.module.b.-$$Lambda$MbiRealmCitizenTestInteractor$UH_qpTiiS6A-PYDCqBxF2bQysWY.subscribe(lambda)\n        at io.reactivex.internal.operators.completable.CompletableCreate.subscribeActual(CompletableCreate.java:39)\n        at io.reactivex.Completable.subscribe(Completable.java:2302)\n        at io.reactivex.internal.operators.completable.CompletableSubscribeOn$SubscribeOnObserver.run(CompletableSubscribeOn.java:64)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:38)\n        at io.reactivex.internal.schedulers.ScheduledDirectTask.call(ScheduledDirectTask.java:26)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:761)\n\n#### Steps & Code to Reproduce\n\nPlease see the Goal section above. It is a benchmark to consider whether Realm is suitable for us or not: Therefore I can provide the whole Android project for it...\n\nThe fragment of code which creates and verifies the data is hereafter - I HOPE I am doing something wrong:\n\n\n    private static final int HUGE_DATA_RECORDS_COUNT = 500;\n    private static final int HUGE_BINARY_DATA_SIZE = 1000000;\n\n    private void createRecordWithHugeBinaryData(final @NonNull Realm realm) {\n        Log.e(Tag.TAG, \"Creating records with huge binary data...\");\n        final ElapsedTime measure = ElapsedTime.start();\n        for (int index = 0; index < HUGE_DATA_RECORDS_COUNT; index++) {\n            final MbiRealmEntityUser user = new MbiRealmEntityUser();\n            final MbiRealmEntityUserI userI = user;\n            final byte[] customData = new byte[HUGE_BINARY_DATA_SIZE];\n            customData[0] = (byte) (0xFF & index);\n            userI.setUserName(\"UN\" + index);\n            userI.setPassWord(\"PW\" + index);\n            userI.setCustomData(customData);\n            realm.beginTransaction();\n            realm.insertOrUpdate(user);\n            realm.commitTransaction();\n        }\n        Log.e(Tag.TAG, measure.getMessage(\"Creating records with huge binary data: Consumed: %s\"));\n    }\n\n    private void verifyRecordWithHugeBinaryData(final @NonNull Realm realm) {\n        Log.e(Tag.TAG, \"Verifying records with huge binary data...\");\n\n        final ElapsedTime measureTotal = ElapsedTime.start();\n        final ElapsedTime measureFindAll = ElapsedTime.start();\n        final RealmResults<MbiRealmEntityUser> users = realm.where(MbiRealmEntityUser.class).findAll();\n        if (users.size() != HUGE_DATA_RECORDS_COUNT) {\n            throw new IllegalStateException();\n        }\n        Log.e(Tag.TAG, measureFindAll.getMessage(\"Verifying records with huge binary data: Consumed: Find All: %s\"));\n\n        final ElapsedTime measureLoop1 = ElapsedTime.start();\n        for (int index = 0; index < HUGE_DATA_RECORDS_COUNT; index++) {\n            final MbiRealmEntityUserI user = users.get(index);\n            if (user == null) {\n                throw new IllegalStateException();\n            }\n            if (!(\"UN\" + index).equals(user.getUserName())) {\n                throw new IllegalStateException();\n            }\n            if (!(\"PW\" + index).equals(user.getPassWord())) {\n                throw new IllegalStateException();\n            }\n        }\n        Log.e(Tag.TAG,\n              \"Verifying records with huge binary data: Consumed: Per Record: Without Huge Data: \" + (measureLoop1.getElapsed() \/ HUGE_DATA_RECORDS_COUNT)\n              + \" milliseconds\");\n\n        final ElapsedTime measureLoop2 = ElapsedTime.start();\n        for (int index = 0; index < HUGE_DATA_RECORDS_COUNT; index++) {\n            final MbiRealmEntityUserI user = users.get(index);\n            if (user == null) {\n                throw new IllegalStateException();\n            }\n            final byte[] customData = user.getCustomData();\n            if (customData == null) {\n                throw new IllegalStateException();\n            }\n            if (customData.length != HUGE_BINARY_DATA_SIZE) {\n                throw new IllegalStateException();\n            }\n            if (customData[0] != ((byte) (index & 0xFF))) {\n                throw new IllegalStateException();\n            }\n        }\n        Log.e(Tag.TAG,\n              \"Verifying records with huge binary data: Consumed: Per Record: With Huge Data: \" + (measureLoop2.getElapsed() \/ HUGE_DATA_RECORDS_COUNT)\n              + \" milliseconds\");\n\n        Log.e(Tag.TAG, measureTotal.getMessage(\"Verifying records with huge binary data: Consumed: Total: %s\"));\n    }\n\n#### Version of Realm and tooling\n\nRealm version(s): 6.0.1\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 3.5.2\n\nAndroid Build Tools version: com.android.tools.build:gradle:3.5.2\n\nGradle version: ?\n\nWhich Android version and device(s):\n* Android version 7.1.1\n* RAM: 2GB\n* The device is proprietary and special purpose (called Credence Two)","comments":["This typically happens if there are unclosed Realm instances on non-looper background threads (or thread pools \/ schedulers).\r\n\r\nEvery call to `Realm.getDefaultInstance()` should have a matching `.close()`, although in Java you can also use the `try(Realm realm = Realm.getDefaultInstance()) {` for same effect.","I am running all my test (including the two methods above) this way (I believe it should be OK, but you can consider yourself):\r\n\r\n            try (final Realm realm = Realm.getDefaultInstance()) {\r\n                deleteAllData(realm);\r\n            }\r\n            try (final Realm realm = Realm.getDefaultInstance()) {\r\n                createRecordWithHugeBinaryData(realm);\r\n            }\r\n            try (final Realm realm = Realm.getDefaultInstance()) {\r\n                verifyRecordWithHugeBinaryData(realm);\r\n            }\r\n","BTW: The problem happens when reading data back from Realm in a separate realm instance (but the same thread). The write of the data succeeds...\r\n\r\nDo I have to create a new Realm for each read separately?","> Do I have to create a new Realm for each read separately?\r\n\r\nNo, you only need a new Realm instance for each thread. And it should be closed when it is no longer used.","So NO I was wrong in my previous statement: The crash actually happens on the first line of the fragment below (i.e. when opening Realm):\r\n\r\n            try (final Realm realm = Realm.getDefaultInstance()) {\r\n                verifyRecordWithHugeBinaryData(realm);\r\n            }\r\n\r\nAt this moment, the data are already written...\r\n\r\n","Or I can put it other way round: I created a realm file which I can never open again :(\r\n\r\nBecause even restarting the app does not help... The only way how to overcome this is to delete the realm and start over...\r\n\r\nWhich sounds like a show stopper to me...\r\n\r\nWhy is it trying to allocate 1.2GB od RAM???","How big is the file on disk?","> How big is the file on disk?\r\n\r\n1152MB\r\n\r\nAre you suggesting that Realm always allocates RAM for a whole file?","Okay, so the file on disk matches what is trying to be allocated. Realm will memory-map files it opens. It doesn't mean it physically needs that much memory, but we need to be able to allocate that much virtual address space. It sounds like you have a custom build of Android? Perhaps you have a limit that is lower than that.\r\n\r\nGenerally, if the system is a 32-bit device, the limit on normal Android phones is 300-400 MB, but 64-bit devices would run out of disk space before the virtual address limit is reached.\r\n\r\nI'm not sure if that is helpful or not?\r\n\r\nAlso note, that databases in general (SQLite and Realm alike) are not really suited for storing large amounts of binary data. So depending on what you are trying to do, it might be a lot more performant to store a filepath pointing to a file outside the DB.","@cmelchior Thanks for the elaboration. It actually is helpful. And that is why I am doing benchmarks first (we call it pre-study).\r\n\r\nIs there some consolidated report where I would have been able to read these data in advance?\r\n\r\nOn the other hand, I did those tests firstly on my Huawei P20 Pro and even 15GB data file was working surprisingly well (I tend to say like a charm, even with the encryption ON - I actually doubt I can quickly do anything similarly effective with the encryption, HMAC and ACID features). No problem to store a lot of 15MB byte arrays into it and retrieve it back.\r\n\r\nUnlike SQLite which, according to my benchmarks, is much worse (15MB byte array is just impossible due to the read cursor size limit)...","I thought we had the section about 32-bit vs. 64-bit bit devices in the FAQ, but I cannot find it \ud83e\udd14 \r\n\r\nThere are a few sections around file size here: https:\/\/realm.io\/docs\/java\/latest\/#faq-large-realm-file-size\r\n\r\nand if you are building a systems app you might want to read this as well: https:\/\/realm.io\/docs\/java\/latest\/#how-to-use-realm-in-system-apps-on-custom-roms\r\n\r\nBut yes, if you really want to store 2MB+ blob data in the database, then you are probably not going to get anywhere using SQLite due to the Cursor limit.\r\n\r\nOn the other hand. If I remember correctly SQLite does not memory map its files, so if you getting such massive database files, SQLite can still open them where Realm might fail on 32-bit devices (not sure what your custom hardware is running). So either way, you would run into problems.\r\n\r\nBut generally, Realm is much more efficient at loading data as we give you direct access to the data in the file instead of copying it into a Cursor (it is also faster).\r\n\r\nI don't know exactly what you are storing in those binary blobs, but generally, I would recommend you try to store them outside Realm\/SQLite if at all possible.\r\n","One more question: If I am on 64-bits system: With the huge (like I wrote 15GB) data file: Which is definitely out of physical memory limit of any device: Will Realm manage the physical memory allocations effectively (or is it even done by the underlying OS services - I am not any expert to virtual vs physical files mapping)?\r\n\r\nI mean no OOM crashes?","We just rely on the OS for the memory-mapping. But that should work fine for that size. Where you might run into problems is if you try to batch-write too much data, since we need to hold the entire write transaction in physical memory before writing it to disk.","Yes, that limit regarding the write transaction I already experienced myself: Huge data is only possible to write in granular transactions, while a lot of small records is much more effective to write in a single transaction...","Thank you guys for your support... I am now trying to close this ticket (hopefully I am allowed to do so)...\r\n\r\nThe conclusion: As I anticipated in my original post, I am actually misusing Realm...","Sorry, I still had to reopen :)...\r\n\r\nBecause I still think there must be some error in Realm, which I was missing so far...\r\n\r\n\"I was able to create a Realm file using the Realm SDK which Realm SDK subsequently cannot open\" - can you feel there is something wrong in that sentence?\r\n\r\nI would expect Realm to report \"You cannot write anything more to me, because then I would become too big and you would not be able to open me\"...\r\n\r\nThat is a kind of the Realm suicide :)","@JirkaKrivanek I don't think there is any practical way we can handle that. We can't know or detect when we can't open a file as it depends on whatever else is in memory and how fragmented the memory is. That can change over time as well, so if for instance, you turn off\/on the phone it may open perfectly well.","@bmunkholm It is clear that Realm SDK can create a Realm File which the same Realm SDK just cannot read later (note: In my case, the restart of the app or phone did not help) - or rephrased on purpose: Realm SDK corrupts the Realm File by the legal operations.\r\n\r\nSo we need to implement monitoring of the size of the Realm File ourselves (protected with some global lock) and if the file exceeds certain size limit then prevent any more writes to it - am I right?\r\n\r\nDon't you think the best place to keep Realm data consistency is the Realm itself (we, on the client level, have no idea whether the file will grow by the write or will just reuse some previously freed space)?\r\n\r\nOther solution could be having multiple Realm Files (I assume NOT accessing them all simultaneously, rather one at the time only) - am I right - or is there any internal global limit which would prevent me from doing this workaround?","@JirkaKrivanek Well, we are not corrupting the file. You can move the file out of the system an open it with Studio or another desktop application. The file is consistent. But this is more philosophical than practical :-).\r\nIf there was an easy (or any doable) way for us to detect this we could make it a feature request. But it would be one that would have very little priority as very few people hit this. \r\nIt's unlikely you can make your own monitoring, just as it's unlikely we can. So my recommendation is that you follow cmelchiors advice and store the binaries outside of Realm in the filesystem instead.\r\n","> @JirkaKrivanek Well, we are not corrupting the file. You can move the file out of the system an open it with Studio or another desktop application. The file is consistent. But this is more philosophical than practical :-).\r\n\r\nYeah, I am aware of that: My \"rephrase\" was not exactly honest. But practically, it is true.\r\n\r\n> If there was an easy (or any doable) way for us to detect this we could make it a feature request. But it would be one that would have very little priority as very few people hit this.\r\n\r\nShall I raise this feature request?\r\n(or can this ticked be considered as the feature request - by editing the title - it would make sense, as there is the context discussion here)\r\n\r\nNote: In the real world, I can actually imagine the request for something more complex:\r\n- Architecture limit - i.e. the one being discussed here (yes, the device causing troubles to us really is 32 bits - Armv7)\r\n- Disk space limit\r\n\r\n> It's unlikely you can make your own monitoring, just as it's unlikely we can. So my recommendation is that you follow cmelchiors advice and store the binaries outside of Realm in the filesystem instead.\r\n\r\nTrue, doing system level limit\/monitoring is hard on the client level - that should be done by Realm.\r\n\r\nBut what we can do is the functional limit - e.g. max. 30.000 records of known size to be safe...","It is fine to rename this issue. I think we already have an issue tracking \"to large\" files in Core: https:\/\/github.com\/realm\/realm-core\/issues\/1935\r\n\r\nBut ideally, Realm should be able to open files of any size (as long as it fits on the filesystem).","> But ideally, Realm should be able to open files of any size (as long as it fits on the filesystem).\r\n\r\nYES!\r\n\r\nPlus:\r\n- Realm **shall** prevent writing files which Realm cannot subsequently open\r\n- Realm **could** provide configurable guarding of the size (checked against both: the minimum free disk space to leave + the maximum total file size)","REALM_JNI: jni: ThrowingException 5, mmap() failed: Out of memory size: 67108864 offset: 1811939328 in \/tmp\/realm-java@2\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_OsSharedRealm.cpp line 106, .\r\n\r\nI met the same problem,When the  file exceeds 1GB,No matter which version of SDK I use.The terrible thing is that I can't open this file any more.Can you help me analyze the reasons?Best of all, I used it by mistake,It's not an internal error of the SDK.thx","@dakexuan: It is not the worst: According to my experiments long time ago, the more native memory the rest of your application eats, the less memory is available for realm (in other words, your 1GB limit may be dynamic per what else your app is currently doing). Therefore it is hard to try to observe the realm file size and prevent adding more data as soon as it grows over some threshold.\r\n\r\nUnfortunately enough, it is a basic limit of the core realm architecture. Theay are hardly able to fix this serious bug without completely rewriting it... So they have to silently ignore it...\r\n\r\nMy conclusion: Unless your app needs only a small data (let us say to be safe 100MB at maximum), DO NOT USE REALM AT ALL.","@cmelchior It's frustrating.What do you think"],"labels":["Blocked","T-Feature","O-Community"]},{"title":"Write up best practise to ensure encapsulation","body":"Fallout from architectural discussion:\n\nLeaking Internals: \n In addition to the very flat package structure, many of our classes leak their internals. We have many places where instances return their private copy of a mutable container. Lots of fields are public, mutable, and changed by external code. If this ever bites us, it will be hours in the debugger to find and fix.\n\nGBM will write best practice in Wiki. Keep in mind for new PR\/refactors.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Improve encryption example in docs with a best practice solution","body":"The encryption section in Java docs https:\/\/realm.io\/docs\/java\/latest\/#encryption leads to an example that doesn't properly provide a best practice solution for how to store keys used for encryption.\n\n","comments":[],"labels":["T-Doc","First-Good-Issue","Pipeline-Idea-Backlog"]},{"title":"Allow multiple RealmModules of the same name","body":"#### Goal\nI wanted different library modules in my project, containg a @RealmModule class according to the docs, totally isolated from each other.\n\n#### Actual Results\nI got D8 errors containing: Program type already present: io.realm.'NameOfClass'Mediator exceptions, preventing the app to compile\n\n#### Steps & Code to Reproduce\ncreate 2 library modules in a project containing realm, create a @RealmModule class that has the same name in both modules, packages do not matter. Realm will generate an identically named class and thus prevent project compilation.\n\n#### Solution\nAdd to the docs more clearly that when getting the above error, this is due to naming your RealmModule class the same as another dependency using realm, ignoring custom packages\n\nor maybe in generating this class the package can be added in the resulting name\n\n#### Version of Realm and tooling\nRealm version(s): 6.0.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 3.5.0\n\nAndroid Build Tools version: 3.5.1\n\nGradle version: 5.4.1\n\n","comments":["Thanks for reporting this. We are already including the package name in our auto-generated files to allow model classes to have the same name in different packages. I actually thought we did the same for module classes, but it sounds like we are not.\r\n\r\nI would consider this a bug that needs to be fixed."],"labels":["T-Bug-Crash","O-Community"]},{"title":"Automatic convert local Realm to a synchronized Realm","body":"#### Goal\nI have an application that runs with Realm, data is stored locally and it work fine.\nNow I want to add the cloud feature but it's not possible.\n\n#### Actual Results\nWhen I install the new app over the old one, I get this error\nE\/REALM_JNI: jni: ThrowingException 1, Provided schema version 0 is less than last set version 5\nThe problem here is that with Realm Cloud there is no way to set the schema versione, SyncConfiguration doesn't have a method to do it.\nThe only way of making this work is to uninstall the old app, but I need to keep the application data so I can't do it.\n\n#### Version of Realm and tooling\n\nRealm version(s): 5.15.2\n\nRealm Sync feature enabled: Yes\/No\n\nAndroid Studio version: 3.5.1\n\nAndroid Build Tools version: 3.1.4\n\nGradle version: 4.4\n\nWhich Android version and device(s): 4.4","comments":["Unfortunately, there currently doesn't exist a way to automatically upgrade a local Realm to a synchronized Realm with existing data. You need to manually copy all data over. This might or might not be relatively easy depending on your data model.","@cmelchior What do you mean with \"copy all data\"? There a way to transfer data from my local Realm to the copy on cloud before installing the new application?","No, you would need to do it the first time people log into the app after they upgrade","The safest (although not necessarily sanest) way to do it would be to open the Sync Realm using the typed api, and copy the data over from the old Realm if it exists using the DynamicRealm API.\r\n\r\nThat way, even if you make changes to your schema, you won't need to mess with migration of your non-sync Realm. ","Converting this to a feature request for automatically upgrading a local Realm to a synchronized Realm. We should be able to relatively easy make an API for this at the core level that will copy everything from a local Realm to a synchronized Realm thus creating the correct history."],"labels":["T-Feature","O-Community"]},{"title":"Make it easier to work with readOnly Realms","body":"Imagine a case where you have a read only Realm on the server.\n\nRight now this requires something like this:\n```\nSyncConfiguration config = user.createConfiguration()\n  .fullSynchronization()\n  .readOnly()\n  .waitForInitialRemoteData()\n  .build();\n\nRealm.getInstanceAsync(config, callback);\n```\n\nUnfortunately, the callback approach makes code logic rather hard to handle.\nEspecially since a normal flow is to have some sort of login screen that handles asynchronously downloading the Realm with progress bars and then the rest of the app assumes the Realm file is there.\n\nWe should look into ways for improving the API's in this case, so that you can synchronously open an existing Realm even if `waitForInitialRemoteData()` was set on the configuration.\n\nThe issue is probably that the checks for `waitForInitialRemoteData()` and UI thread are done before we even start looking into the file existing or not.\n\nAlternatively, we need to allow multiple different configurations opening the same Realm.\n\nThis needs some thought.","comments":[],"labels":["T-Enhancement","Design-Required"]},{"title":"Sorted realm results slow changeset processing down","body":"When I have a list with a bigger amount of elements (around 7000) and I add sorting to the query, change listeners are getting very slow. This is not the case when only one field is given. From the second field it slows down a lot. It also seems to depend on what field type is given to sorting. Booleans seem to be quite fast. Dates are also slower when only one is used.\n\nLet me show you what I do: very simple query on all objects with multiple sorting elements:\n\n```\nval theList = realm.where(TheObject::class.java)\n    .sort(\n        arrayOf(\"fieldBool\", \"fieldDate\", \"fieldString\"),\n        arrayOf(Sort.DESCENDING, Sort.DESCENDING, Sort.DESCENDING)\n    )\n    .findAllAsync()\n\ntheList.addChangeListener { result: RealmResults<TheObject> ->\n    \/\/ Set the list to the view.\n}\n\n```\n\nNow, when some object in this resulting list is changed, the change listener needs a lot of time to update the data. Also other change listeners on the same table are very slow.\n\neven if I sort the result after adding a changeListener (in the change lsitener):\n\n```\nval theList = realm.where(TheObject::class.java)\n    .findAllAsync()\n\ntheList.addChangeListener { result: RealmResults<TheObject> ->\n    viewToSet.list = result.sort(\n        arrayOf(\"fieldBool\", \"fieldDate\", \"fieldString\"),\n        arrayOf(Sort.DESCENDING, Sort.DESCENDING, Sort.DESCENDING)\n    )\n}\n\n```\n\nthe update happens very slow. I found out that it might has to do with calculating the changeset. If I add a changelistener to the realm instead of the result, it works quite fast. Still what is interesting is that I do not add a changeListener to the sorted list but to the unsorted list. sorting then works quite fast inside of the listener, but as soon as I have a sorted RealmResults living somewhere, the changeset creation seems to take a while... But only for that table. All other tables are working fast.\n\nWhat also is interesting, listening to changes of one object of this table is still fast, but as soon as I have one changelistener somewhere added to a result of that table and (not necessary the same result) a sorted result somewhere living, updating also works for that one object slow...\n\n","comments":["Do all the sorted fields have indexes?","@cmelchior Nope. Let me try this.","@cmelchior Having them changed to indexes does not help. I have the feeling it's a bit faster, still it takes a lot of time...","@cmelchior So what I can say is:\r\nMy feeling is that it depends on the fields I give for sorting. Boolean seem to work better than any other field.\r\nAlso this is not every time... I am clueless why...","@klein-artur Could you be a bit more concrete what \"slow\" means?\r\nHaving a minimal repro case could also be helpful and make things a bit more concrete.","@cmelchior  If I say slow, I mean around 20 seconds.\r\n\r\nI think I now can articulate what the problem is.\r\n\r\nIf a SORTED `RealmResults<TestData>` instance lives somewhere, independently where, all change listeners on any other `RealmResults<TestData>` or on single `TestData` need more time to calculate the changeset\r\n\r\nLet me explain:\r\n\r\nI created a testproject with a repo: \r\nhttps:\/\/github.com\/klein-artur\/realmChangeTest\r\n\r\nThis project has a very simple data structure so the time delays are not really big, but still good to describe. In this project, on first start, I add 1,000,000 elements to a list to have a lot of data. In my real project the data structure is quite complex, so the delays are a lot bigger.\r\nThen there are three scenarios implemented (currently commented so you can try all three one by one). \r\nFirst one is without any sorting: Loading and listening on the million elements works very fast:\r\n```\r\n21:55:25.596 I\/System.out: RealmTest: Fetch starts.\r\n21:55:26.232 I\/System.out: RealmTest: Data emitted.\r\n21:55:39.450 I\/System.out: RealmTest: Data clicked, Update commited.\r\n21:55:39.751 I\/System.out: RealmTest: Data emitted.\r\n```\r\nYou see a delay of milliseconds. Everything nice.\r\n\r\nScenario 2 introduces sorting: Loading takes longer now (makes sense when sorting million elements) In my real project I have only 7000 elements so sorting works quite fast. Now a listener is added to this sorted list. The listener now also needs some time after the update to fire. So I assume calculating the changeset takes time on a sorted list. In my real project this changelistener now needs around 20 seconds to fire.\r\n```\r\n21:32:14.328 I\/System.out: RealmTest: Fetch starts.\r\n21:32:23.855 I\/System.out: RealmTest: Data emitted.\r\n21:33:03.000 I\/System.out: RealmTest: Data clicked, Update commited.\r\n21:33:10.894 I\/System.out: RealmTest: Data emitted.\r\n```\r\n\r\nNow comes the interesting part (Scenario 3).\r\nThe list is fetched unsorded (works very fast again) and sorting is done before the list is set to the adapter (that sorting than takes a bit). \r\nThe listener is added to the unsorted list, so one would assume that the listener might work fast now, because in the changeset of the change has nothing to do with sorting but:\r\n```\r\n22:04:45.312 I\/System.out: RealmTest: Fetch starts.\r\n22:04:45.906 I\/System.out: RealmTest: Data emitted.\r\n22:04:51.793 I\/System.out: RealmTest: Data clicked, Update commited.\r\n22:04:55.139 I\/System.out: RealmTest: Data emitted.\r\n```\r\n\r\nOut of some reason, the changelistener added to this unsorted result now needs 3 seconds (this three seconds in my real project blow up to ca. 20 seconds). And not the sorting takes time, the print happens as the first line of the changelistener. The sort that takes around 7 seconds add on top of this.\r\n\r\nSo long story short:\r\nIf a SORTED `RealmResults<TestData>` instance lives somewhere, independently where, all change listeners on any other `RealmResults<TestData>` or on single `TestData` need more time to calculate the changeset. Complexitiy in data increases the time a lot.\r\n\r\nWhen I have a look into the android profiler, I see that something is calculated on some background thread, but I cannot see what happens, so I'm quite sure that the changeset is calculated in native code.\r\n\r\n","Thanks, I'll take a look at your example.\r\n\r\nHow does your original data model look like?\r\n\r\nEspecially around relationships to other objects? And does it have cycles? We have some known edge cases in our current change detection algorithm that can cause it to become very slow in some cases. The solution here is usually to break up the forward relationships and replace them with `@LinkingObjects`, but if and how that is possible depends very much on the specific data model.","Unfortunately I cannot share the datastructure...\r\n\r\nYes, it has cycles: `ObjectA -> ObjectB -> List<ObjectA>` but they are never set. I think this was the solution before there where `@LinkingObjects`. I could test to break this but it will take a lot of efford. Maybe we can first find something different.\r\n\r\nStill it seems that also uncycling databases do have that behavior (The example database has no relationships at all).\r\n\r\nSo I think the main question is:\r\nWhy does a sorted `RealmResults<T>` slow down all other listeners on `RealmResults<T>` or `T`, even if it has no own listener.\r\n\r\nA solution for this could be to not calculate the changeset for results that have no changelistener attached. Because the calculation of changeset for sorted results seems to be the thing that exceeds in time (in the testproject the calculation of the changeset as long as no sorting happened takes a few milliseconds, but as soon as some sorted list is present takes around 3 seconds).\r\n\r\nIf the calculation of changeset happens only for Results that are listened, I could add a listener to the unsorted list and sort the list after I got the change.","@cmelchior Ok, what makes the update horrible slow is the cycled relation. I had a look into the whole code and found out we do set that relation...\r\nSo for now I can live with remove that.\r\n\r\nStill the question is, why it slows down all changeset calculations, even if the sorted list has no listener.","@tgoyne is probably the best for going into details exactly what is happening.\r\n\r\nBut the reason that all changes listeners are delayed is that we only have one worker thread for calculating the changesets and we want to calculate all of them before they are delivered so you get a consistent view of the object graph.","@cmelchior @tgoyne  But is it also wanted that changesets are calculated for `RealmResults` that not even have changelisteners? \r\n\r\nJust wanted to say that my 20 seconds loading time is fixed with removing those cycles.\r\n\r\nSo this changes from an issue to a improvement proposal. I would be ok if you close it. Or shall I?\r\n\r\nJust a point to think: There might be schemas where cycles exist and those are not able to have sorted results while listening to changes. If Changesets would be calculated only for results that do have listeners, those could fetch the data without sorting, listen to them and sort them in the listener. With the current issue, the sorting, even without an own listener, will effect the listener on the unsorted list.\r\nAlso: Why does it just happen on lists that are sorted by other fields than boolean","We implicitly create a notifier in the background for every RealmResults. After each write, this notifier checks if the results of the previous run of the query were used, and if so reruns the query on the worker thread. The idea here is that if you hold onto a RealmResults and refresh your UI in response to something like a Realm change event, the query will only ever be run on the UI thread the very first time, and after that won't block the UI thread even without the developer doing anything special. If the query results calculated on the background thread are never actually needed by the RealmResults then it stops running the query in the background.\r\n\r\nThe implicit notifier isn't supposed to be doing the full changeset calculation, but it sounds like the logic to check if there's actually any callbacks registered might have been broken at some point."],"labels":["T-Bug","O-Community"]},{"title":"findAll() performance issue on RealmList queries with @Index'ed fields","body":"#### Goal\nI'm developing and Android application and I initially run into this issue while trying to optimize the search time when querying for objects (`Item` objects).\nI was initially running queries using the `sort()` method, which had some performance issues in large databases.\nTrying to solve this issue, I created multiple `ItemPage` objects to hold a list of `Item` objects in their intended order. That way I would be able to search for `Item` objects faster and in a more granular manner (which allowed me to update the UI at a faster rate).\n\nI noticed some inconsistencies (and issues) regarding the performance of `findAll()` when querying the different `ItemPage`'s `RealmList` objects and created a test project to reproduce that issue.\n\n#### Actual Results\nWhen querying for objects in `RealmList`, it seems that:\n\n1. calls to `findAll()` are slower if the fields being queried are `@Index`ed (might be intended)\n1. calls to `findAll()` become really slow if the objects in `RealmList` are also placed out of their natural order\n\n#### Steps & Code to Reproduce\nI have created a simplified Android project to reproduce the issue:\nhttps:\/\/github.com\/jpmcosta\/RealmTestProject\/tree\/98d3bbb24f0c289f1e5d7c987541248ee8a9101c\n\nBelow are the general ideas of the project. They are bit difficult to explain, but it should be easy to understand once you run the project.\n\n* Realm objects: `Item`, `SubItem`, `ItemPage`\n\n```\npublic class Item extends RealmObject {\n\n    @PrimaryKey\n    public Long id;\n\n    public SubItem subItem = null;\n\n    public Boolean isBookmarked = false;\n\n    @Index \/\/ Removing this index seems to speed up findAll().\n    public long removedAt = NO_TIME;\n\n    @LinkingObjects(\"items\")\n    public final RealmResults<ItemPage> itemPages = null;\n}\n```\n\n```\npublic class ItemPage extends RealmObject {\n\n    @PrimaryKey\n    public Long id;\n\n    public RealmList<Item> items;\n}\n```\n\n```\npublic class SubItem extends RealmObject {\n\n    @PrimaryKey\n    public Long id;\n\n    @Index\n    public String name = STRING_EMPTY;\n}\n```\n\n* there are 50_000 `Item` objects\n* each `Item` holds a single `SubItem`\n* the `Item`'s name is held by its `SubItem`\n* there are 10 `ItemPage` objects\n* each `ItemPage` holds 5_000 `Item` objects\n* there are two main actions in the project: **querying** and **moving**\n* **querying** (bottom fab) will query all `ItemPages.items` for items containing \"A\" and not removed (`removedAt != NO_TIME`); it will then toggle their `Item.isBookmarked` flag\n* **moving** (upper fab) will move the last `Item` containing \"A\" to a different `ItemPage` (adding it to the middle of `ItemPage.items`)\n\nSteps to reproduce:\n\n* the first time you run the application run some queries by clicking on the bottom fab\n  * it should show that all `findAll()` calls have similar times (around 20ms)\n* after running some queries start moving the item by clicking on the top fab\n* every time you click on the top fab, the item will be moved to a different `ItemPage`\n* if you run the queries again, by clicking on the bottom fab, you will notice that one of the `findAll()` calls is a lot slower than the others (varies from 115ms, for `ItemPage$0`, to 1100ms!, for `ItemPage$9`); the slower `ItemPage` is the `ItemPage` with the out of order `Item`\n\nExtra:\n\n* if you remove `@Index` from `Item.removedAt` you stop noticing any issues\n  * `findAll()` times decrease to ~8ms for most queries\n  * there is no penalty when you move the `Item`\n* I was initially writing this issue as a \"query\" issue; however, I realized that `findAll()` might be lazy or not depending on whether or not the fields are `@Index`ed; still, I feel this is an issue, because having to wait 1100ms for a call that usually takes 20ms should not be normal\n\n#### Version of Realm and tooling\nRealm version: 5.14.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 3.5\n\nAndroid Build Tools version: 28.0.3\n\nGradle version: 5.4.1\n\n","comments":["Hey - looks like you forgot to add a T-* label - could you please add one (if you have access to add labels)?","Isn't it just the sorting taking time here, and not the querying?","I believe that there's no sorting involved in this issue. This is the transaction at hand:\r\n\r\n```java\r\nfinal RealmResults<Item> items = itemPage.items.where()\r\n        .contains(\"subItem.name\", \"A\")\r\n        .equalTo(\"removedAt\", NO_TIME)\r\n        .findAll();\r\nfor (Item item : items) {\r\n    item.isBookmarked = !item.isBookmarked;\r\n}\r\n```\r\n\r\nAn `Item` is moved between to different `ItemPage.items` lists. If (and only if) its `removedAt` property is indexed, there's a performance penalty depending on which `ItemPage` holds it. The performance decreases as `ItemPage.items` ids are more distant from the original `item.id`.","Sorry, got mislead by @beczesz comment above which mentions sorting.","> Sorry, got mislead by @beczesz comment above which mentions sorting.\r\n\r\nIndeed sorry about that, I just saw that my response was misleading, removed it."],"labels":["O-Community"]},{"title":"Update docs with details on diffed updates","body":"Similar to Cocoa: https:\/\/github.com\/realm\/realm.io\/pull\/4639\n\n","comments":["@bmunkholm The reference link seems to be broken for me. Could you update it or provide more context?","Can you see this now: https:\/\/github.com\/realm\/realm.io\/pull\/4639 @terakilobyte ?","@bmunkholm perfect :+1: "],"labels":["T-Doc"]},{"title":"Breaking changes wishlist for Realm Java 10.0","body":"This ticket is for tracking and general discussion of breaking changes in a future 6.0 release. \n\nPlease edit the main post to add a topic with a sequence number, and we can discuss it in the comments. If the breaking change is decided to be worthy to add, then create a separate issue for it.\n\n#### 1. Upgrade to NDK 21+.  (ACCEPTED)  \nThis will remove MIPS support and bump minimum the minimum SDK level to 16. No-one is using MIPS anyway and bumping the minimum SDK level will affect less than 0.5% of current builders. See https:\/\/github.com\/realm\/realm-java\/pull\/6460\n\n\n\n#### 2. Rework how `RealmQuery.findFirstAsync()` works. \nIt is confusing to use and doesn't support subscriptions. The current best proposal is having a `RealmOptional<Person> obj = realm.where(Person.class).findFirstAsync();`. See https:\/\/github.com\/realm\/realm-java\/issues\/6040 and https:\/\/github.com\/realm\/realm-java\/issues\/5179\n \n#### 3. Consider changing `Realm.getInstance()` to `Realm.open()`. \nTo better represent the `open\/close` paradigm required by Realm instead of `getInstance` which implies a cached value is returned (which it also kinda is).\n\nI'm not 100% convinced it is worth breaking everyone for this, but we should probably take a closer look.\n\nSee https:\/\/github.com\/realm\/realm-java\/issues\/5372#issuecomment-334686564\n\n#### 4. `Realm.init()` should not define a default configuration. \nWe originally did this to make picking up Realm easier and make code snippets easier to copy\/paste. However, in practice, people forget that a default configuration exists which can lead to subtle errors, especially during bootstrap. We have encountered this a number of times working with POC's. Changing this means that setting up Realm will now look like this:\n\n```\nRealm.init(context);\nRealm.setDefaultConfiguration(new RealmConfiguration.Builder(context).build());\n\/\/ or perhaps\nRealm.setDefaultConfiguration(Realm.createDefaultConfiguration());\n```\n\nSee https:\/\/github.com\/realm\/realm-java\/issues\/6385\n\n#### 5. Bumping only the schema version without a migration defined should be allowed and just treated as a no-op migration. \nThis is the behaviour you would expect from the current builder API and we have seen use cases where the DB version number follows the app version.\n\nIf we decide that you always need a migration with a schema version bump we should always require that both properties are defined at the same place, e.g.  `config.schemaVersion(long version, Realm.MigrationCallback migration)`\n\nSee https:\/\/github.com\/realm\/realm-java\/issues\/6353\n\n#### 6. Fix naming of Sync Error Codes\nSee https:\/\/github.com\/realm\/realm-java\/issues\/6387\n\n#### 7. Change default for ImportFlags\n\nRight now, the default is when using `copyToRealmOrUpdate()` to override all fields. This behaviour can be changed by using `copyToRealmOrUpdate(objects, ImportFlag.CHECK_VALUES_BEFORE_SET)`.  We should change the default so this is the default behaviour and you opt into updating all fields by using something like `ImportFlag.SET_ALL_VALUES`.","comments":["These changes are being punted to 7.0 as there will be a small breaking 6.0 release in between with only changes to Object Server permissions. "],"labels":["T-Feature","Breaking","Epic"]},{"title":"Update certificate test","body":"It seems a unit test verifying that SSL verification works is broken because the certificates used during the test have expired. We need to fix this and re-enable the test: https:\/\/github.com\/realm\/realm-java\/pull\/6456\/files#diff-af0bf68b55d38511be8d03bf3c90329bR246\n\n","comments":[],"labels":["T-Internal","Pipeline-Soon-Backlog"]},{"title":"Create error message if private constructors in models.","body":"#### Goal\n<!-- What do you want to achieve? -->\nTrying to create a new instance of an object\n#### Actual Results\n<!-- What happened? If an exception was thrown please copy\/paste the stack trace from Logcat. -->\nI am receiving this error: Attempt to invoke virtual method 'boolean io.realm.ProxyState.isUnderConstruction()' on a null object reference\n#### Steps & Code to Reproduce\n<!-- What steps resulted in the crash? Please show any relevant code or steps that can be used to -->\n<!-- reproduce it, including any Realm model classes used. Even better is a full sample project -->\n<!-- that can reproduce the crash. Code can be shared privately at help@realm.io if needed. -->\nUPDATE:\n\n@Zhuinden , @zaki50 I know you both have been helpful troubleshooting issues like this in other bugs, would really appreciate if either of you could chime in here...\n\nAt this point I can not create any new Realm-based objects. Each and every one fails with the same error, no matter if I clean, rebuild, etc. To test this, I created a new class \"Sample\":\n\n```\n    package com.reddragon.intouch.model;\n    \n    import java.util.UUID;\n    \n    import io.realm.RealmObject;\n    import io.realm.annotations.PrimaryKey;\n    \n    public class Sample extends RealmObject {\n        @PrimaryKey\n        private String id;\n        private String sampleField;\n    \n        public Sample() {\n            this(UUID.randomUUID().toString());\n        }\n        private Sample(String id) {\n            this.id=id;\n        }\n        public String getId(){\n            return id;\n        }\n    \n        public String getSampleField() {\n            return sampleField;\n        }\n    \n        public void setSampleField(String sampleField) {\n            this.sampleField = sampleField;\n        }\n    }\n\n```\nAnd in my MainActivity.java, I try and create a new instance:\n\n```\n        try {\n            MediaDataMgr.get().addSample(new Sample());\n            Timber.d(\"Lifecycle: was able to add Sample\");\n        } catch (Exception e) {\n            Timber.d(\"Got exception instantiating Sample: %s\", e.getMessage());\n        }\n```\n\nThis `addSample()` method uses a similar approach to the two classes in this project that **DO** work:\n\n```\n    public String addSample(Sample s) {\n        boolean success = true;\n        Sample sample;\n        Realm realm;\n        String retVal = null;\n        boolean mainThread = Thread.currentThread().equals(Looper.getMainLooper().getThread());\n        if (mainThread) {\n            realm = mUIThreadRealm;\n        } else {\n            realm = Realm.getDefaultInstance();\n        }\n        try {\n            realm.beginTransaction();\n            sample = realm.createObject(Sample.class,s.getId()); \/\/<--CRASH!!!!\n            sample.setSampleField(s.getSampleField());\n        } catch (Exception e ) {\n            Timber.d( \"Exception adding a Sample: %s\", e.getMessage());\n            success = false;\n        } finally  {\n    \n            if ( success ) {\n                realm.commitTransaction();\n                retVal = s.getId();\n            } else {\n                realm.cancelTransaction();\n            }\n            if (!mainThread) {\n                realm.close();\n            }\n        }\n        return retVal;\n    }\n\n```\nI am completely stuck now on this project.\n\nUPDATE: I completely commented all references to the 'Contact' object in my app, and then deleted Contact.java from my project. I did a full Rebuild, then ran it, and everything worked.\n\nI then created a new class Contact.java and entered the same fields etc. as before, and uncommented references to it. I did a rebuild and ran - and got the same error.\n\nI then refactored the name of the file, thinking there may be name clash somewhere. Rebuild and run and again - same error, this time referencing the new class name.\n\n---\n\nI have been using gradle plugin and annotations processor 5.9.1. I created a new class (\"Contact.java\"), which initially worked ok. I then adjusted the class (removed a couple of fields, added a new field), and I started receiving this error.\n\nI have done all manner of clean, rebuild, invalidate caching and restart, etc. No help. I reviewed bug #3819 and #4579, but nothing in there has helped. I have disabled instant run. No help.\n\nThe stack trace is:\n\n```\nrealmSet$id:111, com_reddragon_intouch_model_ContactRealmProxy (io.realm)\n<init>:30, Contact (com.reddragon.intouch.model)\n<init>:26, Contact (com.reddragon.intouch.model)\n<init>:84, com_reddragon_intouch_model_ContactRealmProxy (io.realm)\nnewInstance:96, DefaultRealmModuleMediator (io.realm)\ncreateObjectInternal:1048, Realm (io.realm)\ncreateObject:1024, Realm (io.realm)\naddContact:877, MediaDataMgr (com.reddragon.intouch.model)\n\n```\n\nThe code in question that causes this (addContact() in MediaDataMgr) is:\n\n```\n    public String addContact(Contact c, int status) {\n        boolean success = true;\n        Contact contact;\n        Realm realm;\n        String retVal = null;\n        boolean mainThread = Thread.currentThread().equals(Looper.getMainLooper().getThread());\n        if (mainThread) {\n            realm = mUIThreadRealm;\n        } else {\n            realm = Realm.getDefaultInstance();\n        }\n        try {\n            realm.beginTransaction();\n            contact = realm.createObject(Contact.class,c.getId()); \/\/ <--CRASH HAPPENS HERE\n            contact.setEmailAddress(c.getEmailAddress());\n            contact.setDisplayName(c.getDisplayName());\n            contact.setStatus(status);\n\n        } catch (Exception e ) {\n            Timber.d( \"Exception adding a contact: %s\", e.getMessage());\n            success = false;\n        } finally  {\n\n                if ( success ) {\n                    realm.commitTransaction();\n                    retVal = c.getId();\n            } else {\n                realm.cancelTransaction();\n            }\n            if (!mainThread) {\n                realm.close();\n            }\n        }\n        return retVal;\n    }\n\n```\nAnd the Contact class referenced in the stack trace is:\n\n```\npublic class Contact extends RealmObject implements CardListable {\n    @PrimaryKey\n    private String id;\n    private String displayName;\n    private String emailAddress;\n    private String pathToProfilePic; \/\/ This will always be a URI, but we have to store it as a string and convert to URI at runtime.\n    @Ignore\n    private int status = STATUS_UNKNOWN;\n\n    public Contact() {\n        this(UUID.randomUUID().toString());\n    }\n\n    private Contact(String id) {\n        this.id = id;\n    }\n\n    public String getId(){\n        return id;\n    }\n\n    public String getDisplayName() {\n        return displayName;\n    }\n\n    public void setDisplayName(String displayName) {\n        this.displayName = displayName;\n    }\n\n    public String getEmailAddress() {\n        return emailAddress;\n    }\n\n    public void setEmailAddress(String emailAddress) {\n        this.emailAddress = emailAddress;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public void setStatus(int status) {\n        this.status = status;\n    }\n\n    public String getPathToProfilePic() {\n        return pathToProfilePic;\n    }\n\n    public void setPathToProfilePic(String pathToProfilePic) {\n        this.pathToProfilePic = pathToProfilePic;\n    }\n\n    public String getFirstLineDesc() {\n        return displayName;\n    }\n\n    public String getSecondLineDesc() {\n        return emailAddress;\n    }\n}\n\n```\nWhen debugging into the Contact proxy class, I find that the null pointer is because the variable 'proxyState' is null when the method public String realmSet$id() is called. \n\n```\n    public void realmSet$id(String value) {\n        if (proxyState.isUnderConstruction()) { \/\/<-- CRASH HAPPENS HERE\n            \/\/ default value of the primary key is always ignored.\n            return;\n        }\n\n        proxyState.getRealm$realm().checkIfValid();\n        throw new io.realm.exceptions.RealmException(\"Primary key field 'id' cannot be changed after object was created.\");\n    }\n\n```\nWhich leads me to believe that the initialization of it in realm$injectObjectContext() is not being called.\n\nThis same approach to creating a new object is working fine with two other classes in this same project which were written some months back, using earlier versions of everything (Gradle, Plugin, Realm, etc.), and I verified that `realm$injectObjectContext()` **IS** being called there. For example, here is the stack trace in the same type of object construction flow for my Media.java class (which works):\n\n```\n    realm$injectObjectContext:105, com_reddragon_intouch_model_MediaRealmProxy (io.realm)\n    <init>:52, Media (com.reddragon.intouch.model)\n    <init>:49, Media (com.reddragon.intouch.model)\n    <init>:99, com_reddragon_intouch_model_MediaRealmProxy (io.realm)\n    newInstance:99, DefaultRealmModuleMediator (io.realm)\n    createObjectInternal:1048, Realm (io.realm)\n    createObject:1024, Realm (io.realm)\n    addMedia:267, MediaDataMgr (com.reddragon.intouch.model)\n```\n\nSo my guess is that something about the edits I made to Contact.java it combined with current versions of Gradle+Android Plugin+Realm plugin is confusing the byte transformer task in Realm to not call that method.\n\n\n#### Version of Realm and tooling\n\nRealm version(s): ?\n5.9.1\n\nRealm Sync feature enabled: Yes\/No\nNo\n\nAndroid Studio version: ?\n3.3.2\n\nAndroid Build Tools version: ?\n28.0.3\n\nGradle version: ?\n4.10.1 with android plugin 3.3.2\n\nWhich Android version and device(s): ?\nI am targeting API 28 with min at API 21. Failure occurs on all devices.","comments":["SOLUTION:\r\n\r\nIn my case I was an unwitting victim of Lint refactoring. It turns out I had run some Lint processes across my classes, and one of the suggested changes was to change certain constructors to be declared private. Apparently Realm doesn't like this in the model classes that take default args in the constructor. So, for example the Contact.java class had this constructor:\r\n\r\n```\r\n    public class Contact extends RealmObject implements CardListable {\r\n        @PrimaryKey\r\n        private String id;\r\n        private String displayName;\r\n        private String emailAddress;\r\n        private String pathToProfilePic; \/\/ This will always be a URI, but we have to store it as a string and convert to URI at runtime.\r\n        @Ignore\r\n        private int status = STATUS_UNKNOWN;\r\n    \r\n        public Contact() {\r\n            this(UUID.randomUUID().toString());\r\n        }\r\n    \r\n        private Contact(String id) { \/\/<--NOTE PRIVATE CONSTRUCTOR\r\n            this.id = id;\r\n        }\r\n    \r\n\r\n```     \r\nChanging to this:\r\n\r\n```\r\n    public Contact() {\r\n        this(UUID.randomUUID().toString());\r\n    }\r\n\r\n    public Contact(String id) { \/\/<--NOTE THIS IS NOW PUBLIC\r\n        this.id = id;\r\n    }\r\n```\r\n\r\nand doing a clean+rebuild solved the problem. ","Well that's nice to know.\r\n\r\nThe proxy state construction is black magic to me, but I will remember that private constructors can mess with it.","Interesting. I suspect it might also work if you make the constructor protected?\r\nBut as a minimum we should detect it and report a more sensible error."],"labels":["T-Enhancement","O-Community"]},{"title":"Fix RealmInterprocessTest","body":"After #6439 is merged the RealmInterprocessTest is broken. We need to re-enable it.\n\n","comments":["Yeah, agreed @cmelchior. Hope you've been able to implement a fix for it? :-)"],"labels":["T-Internal"]},{"title":"Fix updating the Gradle wrapper across all projects","body":"It appears that https:\/\/github.com\/realm\/realm-java\/pull\/6439 broke the automatic update of the Gradle Wrapper across all projects. This should be fixed.\n\n","comments":["Mine's still broken, any suggestions here @cmelchior "],"labels":["T-Internal"]},{"title":"More advanced ObjectServer example","body":"NOTE: No reason to do a thorough review of this PR yet as it still needs to be rebased on master.\r\n\r\n----\r\n\r\nThis PR adds a more complex example showing integration with Realm Object Server.\r\n\r\nIt uses a modern approach to architecture using MVVM with LiveData\/ViewModel. It uses Kotlin.\r\n\r\nIt also shows how you can combine two Results from different Realms using RxJava\/DiffUtil and still get fine-grained animations in RecyclerViews.\r\n\r\nWe haven't released AndroidX Realm Android adapters yet, so the files are copied into this project for now. This should be replaced with a proper 4.0 release of the Andoid Adapters.\r\n\r\nMore details in the README: https:\/\/github.com\/realm\/realm-java\/compare\/cm\/upgrade-gradle...cm\/objectserver-advanced-example?expand=1#diff-a1a06a4605c515bd4c6f46fb0b4bcdf1\r\n\r\nTODO\r\n- [ ] Wait for #6439 to be merged and rebase on `master`\r\n- [ ] Release Realm Android Adapters 4.0 and depend on that.","comments":["Now I know what you've been working on all this time \ud83d\ude2e "],"labels":["T-Doc","Pipeline-On-Hold"]},{"title":"Fix automatic merge between releases and master","body":"The automatic merge script between the branches `releases` and `master` sees to have stopped working. I assume it also doesn't work between `master` and `next-major`.\n\nWe should fix that.\n\n","comments":[],"labels":["T-Internal"]},{"title":"R8 shrinker warnings","body":"#### Goal\nRemove warnings when building with R8\n\n#### Actual Results\n```\nAGPBI: {\"kind\":\"warning\",\"text\":\"Type `io.realm.io_realm_sync_permissions_PermissionUserRealmProxy` was not found, it is required for default or static interface methods desugaring of `java.util.Map io.realm.BaseModuleMediator.getExpectedObjectSchemaInfoMap()`\",\"sources\":[{\"file\":\"\/Users\/Projects\/Wez\/NextEpisode\/app\/build\/intermediates\/transforms\/FirebasePerformancePlugin\/release\/0\/io\/realm\/BaseModuleMediator.class\"}],\"tool\":\"D8\"}\nAGPBI: {\"kind\":\"warning\",\"text\":\"Type `io.realm.io_realm_sync_permissions_RealmPermissionsRealmProxy` was not found, it is required for default or static interface methods desugaring of `java.util.Map io.realm.BaseModuleMediator.getExpectedObjectSchemaInfoMap()`\",\"sources\":[{\"file\":\"\/Users\/Projects\/Wez\/NextEpisode\/app\/build\/intermediates\/transforms\/FirebasePerformancePlugin\/release\/0\/io\/realm\/BaseModuleMediator.class\"}],\"tool\":\"D8\"}\nAGPBI: {\"kind\":\"warning\",\"text\":\"Type `io.realm.io_realm_sync_permissions_ClassPermissionsRealmProxy` was not found, it is required for default or static interface methods desugaring of `java.util.Map io.realm.BaseModuleMediator.getExpectedObjectSchemaInfoMap()`\",\"sources\":[{\"file\":\"\/Users\/Projects\/Wez\/NextEpisode\/app\/build\/intermediates\/transforms\/FirebasePerformancePlugin\/release\/0\/io\/realm\/BaseModuleMediator.class\"}],\"tool\":\"D8\"}\nAGPBI: {\"kind\":\"warning\",\"text\":\"Type `io.realm.io_realm_sync_permissions_PermissionRealmProxy` was not found, it is required for default or static interface methods desugaring of `java.util.Map io.realm.BaseModuleMediator.getExpectedObjectSchemaInfoMap()`\",\"sources\":[{\"file\":\"\/Users\/Projects\/Wez\/NextEpisode\/app\/build\/intermediates\/transforms\/FirebasePerformancePlugin\/release\/0\/io\/realm\/BaseModuleMediator.class\"}],\"tool\":\"D8\"}\nAGPBI: {\"kind\":\"warning\",\"text\":\"Type `io.realm.io_realm_sync_permissions_RoleRealmProxy` was not found, it is required for default or static interface methods desugaring of `java.util.Map io.realm.BaseModuleMediator.getExpectedObjectSchemaInfoMap()`\",\"sources\":[{\"file\":\"\/Users\/Projects\/Wez\/NextEpisode\/app\/build\/intermediates\/transforms\/FirebasePerformancePlugin\/release\/0\/io\/realm\/BaseModuleMediator.class\"}],\"tool\":\"D8\"}\nAGPBI: {\"kind\":\"warning\",\"text\":\"Type `io.realm.io_realm_sync_SubscriptionRealmProxy` was not found, it is required for default or static interface methods desugaring of `java.util.Map io.realm.BaseModuleMediator.getExpectedObjectSchemaInfoMap()`\",\"sources\":[{\"file\":\"\/Users\/Projects\/Wez\/NextEpisode\/app\/build\/intermediates\/transforms\/FirebasePerformancePlugin\/release\/0\/io\/realm\/BaseModuleMediator.class\"}],\"tool\":\"D8\"}\n```\n\n#### Steps & Code to Reproduce\nProduce release build using AS 3.3+ and R8\n\n#### Version of Realm and tooling\nRealm 5.9\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: ? 3.4 Beta4\n\n```\norg.gradle.daemon=true\nandroid.enableBuildCache=true\norg.gradle.caching=true\norg.gradle.jvmargs=-Xmx2g -Dfile.encoding=UTF-8\nandroid.useAndroidX=true\nandroid.enableJetifier=true\nkapt.use.worker.api=true\nandroid.enableR8=true\nandroid.enableR8.fullMode=true\norg.gradle.parallel=true\nkotlin.parallel.tasks.in.project=true\n```","comments":["Yes, I have noticed this as well. We should fix it if possible.","Great hop its fixed now @cmelchior ","still seeing this in v5.10.0"],"labels":["T-Enhancement","O-Community"]},{"title":"EncryptionKey The provided key must be 64 bytes. Yours was: 66","body":"[GOAL]Need encrypt db using a key stored in with NDK\nthe error is contradictory\n[LogCat]\n`   java.lang.RuntimeException: Unable to start activity ComponentInfo{pt.dbmg.mobiletaiga\/pt.dbmg.mobiletaiga.ui.activity.Login}: java.lang.IllegalArgumentException: The provided key must be 64 bytes. Yours was: 66\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2778)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856)\n        at android.app.ActivityThread.-wrap11(Unknown Source:0)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589)\n        at android.os.Handler.dispatchMessage(Handler.java:106)\n        at android.os.Looper.loop(Looper.java:164)\n        at android.app.ActivityThread.main(ActivityThread.java:6494)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)\n     Caused by: java.lang.IllegalArgumentException: The provided key must be 64 bytes. Yours was: 66\n        at io.realm.RealmConfiguration$Builder.encryptionKey(RealmConfiguration.java:554)\n        at pt.dbmg.mobiletaiga.ui.activity.Login.onCreate(Login.kt:71)`\n\n[Steps & Code to Reproduce]\nCan see problem in my git project [https:\/\/github.com\/worm69\/mobiletaiga\/tree\/dev|url](https:\/\/github.com\/worm69\/mobiletaiga\/tree\/dev|url)\n![image](https:\/\/user-images.githubusercontent.com\/12191069\/52849337-ac327c80-3108-11e9-9f22-b9524a09d736.png)\n\nRealm version(s): 5.8.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: \nAndroid Studio 3.3.1\nBuild #AI-182.5107.16.33.5264788, built on January 28, 2019\nJRE: 1.8.0_152-release-1248-b01 amd64\nJVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o\nWindows 10 10.0\n\nAndroid Build Tools version: 28.0.3\n\nGradle version: 4.10.3\n\nWhich Android version and device(s): Any\n\n","comments":["This key doesn't contain 64 bytes, You should generate this randomly from each app install, getting this key from NDK encrypts nothing and can be easily bypassed.","@ppamorim Thx for advice. How i should store after generate randomly?\r\nI am locking for better approach to store any passwords\/secret key\r\nCan explain me better why dont have 64 bytes?","You should store your key on the Keystore, you can create your key using `SecureRandom`, `Cipher` and Android's `KeyStore`.","Hey - looks like you forgot to add a T:* label - could you please add one? ","with [https:\/\/github.com\/realm\/realm-java\/tree\/master\/examples\/encryptionExample](url) example cant open db on windows using realm studio\r\n![image](https:\/\/user-images.githubusercontent.com\/12191069\/52864470-26c3c200-3132-11e9-98d2-485c60fa2a7f.png)\r\nLook like other people have problems with that [https:\/\/github.com\/realm\/realm-js\/issues\/1829](url) ","try with emulator and mi Xiaomi","Isn't the trick that you must provide the hex string to Realm Studio instead of the encryption key directly?","@Zhuinden should by only Copy the key from Logcat, like example said\r\n\r\n>         \/\/ Generate a key\r\n        \/\/ IMPORTANT! This is a silly way to generate a key. It is also never stored.\r\n        \/\/ For proper key handling please consult:\r\n        \/\/ * https:\/\/developer.android.com\/training\/articles\/keystore.html\r\n        \/\/ * http:\/\/nelenkov.blogspot.dk\/2012\/05\/storing-application-secrets-in-androids.html\r\n        byte[] key = new byte[64];\r\n        new SecureRandom().nextBytes(key);\r\n\r\n        \/\/ An encrypted Realm file can be opened in Realm Studio by using a Hex encoded version\r\n        \/\/ of the key. Copy the key from Logcat, then download the Realm file from the device using\r\n        \/\/ the method described here: https:\/\/stackoverflow.com\/a\/28486297\/1389357\r\n        \/\/ The path is normally `\/data\/data\/io.realm.examples.encryption\/files\/default.realm`\r\n        Log.i(\"RealmEncryptionKey\", Util.bytesToHex(key));","This worked fine for me:\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/406066\/52866382-d4d56900-313e-11e9-9f9b-9540c6c1013d.png)\r\n\r\n![image](https:\/\/user-images.githubusercontent.com\/406066\/52866441-f20a3780-313e-11e9-81e8-c6d0455b0509.png)\r\n\r\nMaybe you tried to open the wrong Realm?\r\n","Nop, check video https:\/\/youtu.be\/XmHdQJLF9zc i will try later on linux if work","Hi work on Linux maybe file system problem\r\n![image](https:\/\/user-images.githubusercontent.com\/12191069\/52946070-07fc4000-336b-11e9-924f-720e9e774347.png)\r\n ","Hmm, interesting if this points to a problem on Windows."],"labels":["T-Bug","O-Community"]},{"title":"Remove ObjectListener inside Callback crashes with SIGSEGV","body":"#### Actual Results\nApp is crashing during a transaction. Returning error like `SIGSEGV (signal SIGSEGV: address access protected (fault address: 0x752ff03e90))` I bet it is a crash on the C++ core. My Realm is encrypted.\nI can send a debug APK privately, will this be useful?\n\nList of errors: \n\n```\nSignal: SIGSEGV (signal SIGSEGV: invalid address (fault address: 0x4108f942e508))\nSignal: SIGSEGV (signal SIGSEGV: address access protected (fault address: 0x752ff03e90))\nSignal: SIGSEGV (signal SIGSEGV: invalid address (fault address: 0x4108f942e508))\nlost connection \/\/App closes\n```\n\n![screen shot 2019-02-12 at 17 04 25](https:\/\/user-images.githubusercontent.com\/5521682\/52653688-64cda580-2ee8-11e9-968e-1b428b24fe12.png)\n![screen shot 2019-02-12 at 17 03 48](https:\/\/user-images.githubusercontent.com\/5521682\/52653690-65663c00-2ee8-11e9-9b1f-1464aa1abce1.png)\n\n**EDIT 1:**\n\nI modified the source to have two transactions, like this:\n\n```kotlin\nval realm = Realm.getDefaultInstance()\ngetTask(realm, name)?.let { task ->\n  realm.executeTransaction {\n    task.type = newType \/\/This works perfectly\n  }\n  realm.executeTransaction {\n    task.mode = null\n  }\n}\nrealm.close()\n```\n\nThe crash stopped and the change is being committed. Is there any reason why I can't modify two parameters from the object once?\n\n**EDIT 2:**\n\nI've sent a debug APK to Realm's private email.\n\n#### Steps & Code to Reproduce\n```kotlin\nval realm = Realm.getDefaultInstance()\nrealm.executeTransaction {\n  getTask(realm, name)?.let { task ->\n    task.type = newType \/\/This works perfectly\n    task.mode = null \/\/crash here, mode is optional, setting a non null value doesn't make any difference, if I remove this part of the code the crash stops.\n  }\n}\nrealm.close()\n```\n\n**EDIT 3:**\n\nI confirm that this bug is also happening on version 5.9.0.\n\n**EDIT 4:**\n\nThe location of the error is random, it depends on how many transactions are you doing in a single realm instance, when I call `Realm.close()` I get `Signal: SIGBUS (signal SIGBUS: illegal alignment)`.\n\n**EDIT 5:**\nThe crash is also happening when multidex is disabled.\n\n**EDIT 6:**\nRealmLogger moments before the crash: https:\/\/gist.github.com\/ppamorim\/80768e9882f6dd9a663356deffc872df\nI've sent a new APK on the ticket open on Realm Support. #\u20603077\nDatabase size is about 600kb, the crash happens even on fresh install.\n\n**EDIT 7:**\nNew logs from tombstone: https:\/\/gist.github.com\/ppamorim\/be83f1891e87e6415c14420dfcf7bae2\n\n#### Version of Realm and tooling\nRealm version(s): 5.9.0, 5.8.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 3.3\n\nAndroid Build Tools version: \n\n* com.android.tools.build:gradle:3.3.0\n* ~~multiDexEnabled true~~\n\nGradle version: 5.2.1, 5.1.1, 4.10.2\n\nWhich Android version and device(s): 8.0.0 on One Plus 3T\n\n","comments":["Probably related: https:\/\/github.com\/realm\/realm-core\/issues\/2944","I was able to reproduce the same problem here. As well as @ppamorim commented, the error seems to be random, occurs in different Realm method calls.","@cmelchior I think I have found the issue. I was modifying a specific object in a async thread with this same object loaded in the main thread with a change listener added. When the async thread finishes (commit the realm changes) I was calling a method on the main thread to remove and re-add the change listener, which caused the error. Removing the change listener stopped the error from happening. Shouldn't the change listener be passive?","@cmelchior I will try to replicate this on a sample app.","@ppamorim I assume you are talking about a single object listener, correct?\r\nIt should work, but given that the code around handling notifications for single objects are a bit complex I wouldn't be super surprised if we had a bug in there somewhere. Do you perhaps have a code snippet I can take a look at and see if I can reproduce it on my end?\r\n\r\n","@cmelchior Yes, it's the `RealmObjectChangeListener`.","@cmelchior Here is the reproduction: https:\/\/github.com\/ppamorim\/realm-SIGSEGV-crash\r\nKeep trying compiling it multiple times and uncommenting the lines 45-48 if the crash does not happen. I know, the example is ridiculous but it was the only way I found to simulate it on a example, my app probably was doing the same but in different threads and contexts. All the source is contained on `MainActivity.kt`.","@ppamorim Thank you very much for this. I can reproduce the crash.\r\n\r\nIt happens because you remove the changelistener from inside the changelistener. This should be supported but I guess there is a bug somewhere I have to track down.\r\n\r\nIf you want to work around it, for now, you can try to remove it from outside the callback, e.g. by doing it in a `runOnUiThread()`:\r\n\r\n```\r\n        foo?.addChangeListener<Foo> { _, _ ->\r\n            runOnUiThread { foo?.removeAllChangeListeners() }\r\n            foo?.addChangeListener<Foo> { _, _ -> }\r\n        }\r\n```\r\n\r\nEDIT: Actually scratch that. I suspect that the above just alters the timing. The reason in your example project is that objects are being GC'ed with active change listeners and somehow we still think they are live when in fact they are not. ","@cmelchior Thank you, I have implemented states to prevent unnecessary add and remove of change listeners (I am using the `addChangeListener` with parameter, not a directly lambda on my project). I think I experienced something similar on iOS related to removing change listeners inside a change listener callback, but I am not 100% sure.","@cmelchior I agree with you, preventing any unnecessary update of the variable `foo` during the execution stops the error from happening. I simply have added a `if (foo == null)` to check if the variable is already loaded and the problem has stopped. Unfortunately this is not a solution since the reattribution of values can happen anytime for whatever reason."],"labels":["T-Bug-Crash","O-Community"]},{"title":"Why does Realm.init set default configuration?","body":"Realm.init sets the default configuration. Why is this? In what case would the user of the library not set it's own configuration?\n\nIn my case it has led to a lot of confusion. Since I did not set my own default configuration straight away in my application subclass. For example when using Realm Cloud, you probably want to establish a sync configuration and never use a local configuration at all. And even if you use a local configuration, you probably don't want the default as you probably want custom migrations etc.\n\nWhat I see happening now is that when the app is destroyed and recreated. Realm.init() is called again in application.oncreate. Then the app will crash with a very cryptic error message \"provided schema version 0 is less than last set version\". It took me a long time to understand that this was caused by Realm.init() setting an invalid default configuration.\n\nI would much prefer if the app would crash with the error message \"No default configuration set\".","comments":["You should always set the default configuration, possibly in `Application.onCreate()`, before you actually open the Realm with `getDefaultInstance()`.\r\n\r\nBut you aren't the first one to say that setting a default in `init()` is a mistake: https:\/\/github.com\/realm\/realm-java\/issues\/4844#issuecomment-311713546 ","But what about the case when you are using realm cloud? I certainly cannot set the default configuration if the user is not logged in yet? Running Realm.init() will set a local default configuration, which will always be invalid, and I can't set the SyncConfiguration as default as the user is not signed in yet. \r\n\r\nBut I guess it means that I should always set the configuration whenever I can. When running a local configuration I should set the localConfiguration as default in Application.onCreate() and if I already have a current syncUser, I should be able to set the syncConfiguration in Application.onCreate()\r\n\r\nBut I agree with this being a mistake. The error messages this leads to are very confusing. Took me a long time to figure out that the issue was that Realm.init() sets a default configuration. I had no idea.\r\n\r\n\r\n","The one thing you can do on your side is [wrap the `init`\/`getDefaultInstance()` calls and detect if the configuration is unset](https:\/\/github.com\/Zhuinden\/realm-monarchy\/blob\/67209635e58369b01d4d63b59bd95f917227dac7\/monarchy\/src\/main\/java\/com\/zhuinden\/monarchy\/Monarchy.java#L93-L120).\r\n\r\nBut I'd be the happiest as you can see if they just flat-out made it throw an exception if it's unset. Having a default config like this would be great for first start and it'd crash on the second start. Never understood why it's there. :thinking: ","We set the default configuration because it makes it a lot easier in code snippets and generally picking up Realm for the first time (as you don't have to learn about configurations). So while I have sympathy for the idea, I suspect that more people will get hurt by the change.\r\n\r\nWe could maybe provide an override for `Realm.init()` where you specified the default config or `null` but I suspect that no-one would use it,  until they actually hit what you are hitting and then it would be kinda too late anyway.","Hey - looks like you forgot to add a T:* label - could you please add one?","Actually considering you can end up with an incorrect schema mode, I think if you have a local DB config set when you are trying to use Sync, this is masking a very fatal error and now you also have to mess around with deleting the local file you didn't even intend to create \ud83e\udd14 ","While I understand that you want to get started quickly. I still strongly disagree.\r\n\r\nI suspect most people that have real use cases will have to use something other than the default configuration provided by realm init right? If you need migrations, which you probably will for local realms or if you use a realm cloud it is not a valid configuration.\r\n\r\nIn my case, this has led to a high number of crashes in production. Yes, it was my fault I didn't set my own configuration in Application.onCreate(). It worked fine when the app was stared normally, but whenever the app was restored from being killed in the background and then restarted I would get  \"provided schema version 0 is less than last set version\", which is very confusing. It took me months to figure out that this was due to Realm.init setting a default configuration and that my own default configuration was set too late.\r\n\r\nI'd argue that for most production use cases, setting the Realm default configuration in Realm.init() is not a good idea. But if it won't be changed, at least it would be good if the error message could be a bit more clear?","@Zhuinden I guess that when trying to migrate a local database to a synced one it also leads to confusion. I can't just check if a local database file exists. I also needs to check if it is empty?","If you're trying to \"migrate a local database\" it's done by `Realm.getInstance(config)` (or `Realm.getDefaultInstance()` and opening the Realm will fail with `RealmMigrationNeededException`.\r\n\r\nThe only way to *manually* force this is to open the Realm as a DynamicRealm and check if its schema version is lower than the one you intend to create, CLOSE the dynamic realm and THEN call `Realm.migrateRealm()`.","@Zhuinden bad choice of words from my end. I have a local app now, but want to copy the data over to a synced realm if it has data and then delete the local realm when it is done."],"labels":["T-Enhancement","Breaking","O-Community","Pipeline-Idea-Backlog"]},{"title":"Add support for com.android.dynamic-feature","body":"com.android.dynamic-feature is a new Android library plugin for dynamic feature modules. \n\nRealms plugin needs updating to support this.","comments":["For reference: https:\/\/developer.android.com\/studio\/projects\/dynamic-delivery","hey guys... what's not supported about this?\r\n\r\nI found my app crashes on dynamic features if I don't disable the ABI splits, but wasn't exactly sure why","@kassim As I understand it, applying the realm plugin requires the android library ('com.android.library') or application ('com.android.application') plugin to be applied to the same module that you apply your realm plugin ('realm-android').\r\n\r\nHowever in dynamic modules, the android\/library plugin can't coexist with the dynamic feature plugin ('com.android.dynamic-feature').\r\n\r\nThe end result is that you can't isolate your realm dependency to a dynamic module."],"labels":["T-Feature","O-Community"]},{"title":"RealmQuery.clone(): Support making a copy of a query","body":"Hi, I have a small doubt. My app crashed with the error as shown above. I have realm query of all matching rows and i need to show them under two different headers depending on the time,\n```upcomingReminders = realmQuery.greaterThan(\"reminderTime\", System.currentTimeMillis() \/ 1000).sort(\"reminderTime\", DESCENDING).findAll();\n        pastReminders = realmQuery.lessThan(\"reminderTime\", System.currentTimeMillis() \/ 1000).sort(\"reminderTime\", DESCENDING).findAll();```\nso, my question is can we not use the same realm query and get two different result set.","comments":["The exception says that ever created `realmQuery` already called sort on it and calling sort again would just override the first one. So we throw an exception.\r\n\r\nSo either stop calling sort the first time or you can also create an intermediate query result this way:\r\n\r\n```\r\npastReminders = realmQuery\r\n  .lessThan(\"reminderTime\", System.currentTimeMillis() \/ 1000)\r\n  .findAll()\r\n  .where()\r\n  .sort(\"reminderTime\", DESCENDING)\r\n  .findAll();\r\n```\r\n","@cmelchior basically, i need two result sets from same realm query, instead of creating two query set, i thought i shall reuse the same query, I think I missed it earlier. please check the code below.\r\n```\r\nupcomingReminders = realmQuery.greaterThan(\"reminderTime\", System.currentTimeMillis() \/ 1000).sort(\"reminderTime\", DESCENDING).findAll();\r\n        pastReminders = realmQuery.lessThan(\"reminderTime\", System.currentTimeMillis() \/ 1000).sort(\"reminderTime\", DESCENDING).findAll();\r\n```","Yes, that doesn't work. Think of RealmQuery as a builder, so pastReminders would contain all the predicates you added in `upcommingReminders`. So even if sort didn't threw an exception, it would still be the wrong query.","Ideally, maintaining a copy of realm query is the solution I believe. Thanks @cmelchior ","Yes, right now you would need to manually create two queries, a better solution for this would probably be supporting something like the `Clonable` interface so you could do `query.clone()` to get a copy. I'll convert this issue into a feature request for this.","Cool, thanks!\r\n"],"labels":["T-Enhancement","O-Community"]},{"title":"Field annotated as @Ignored is not ignored on annotation processing","body":"#### Goal\nCompile project\n\n#### Actual Results\n`error: Field \"status\" of type \"UserStatus\" is not supported.`\n\n#### Steps & Code to Reproduce\nRealm class:\n\n```\n@RealmClass\nopen class AppUserRealm : RealmModel, ConvertableToModel<AppUserModel> {\n ...\n    private var statusStr: String = UserStatus.ACTIVE.name\n\n    @Ignore\n    var status: UserStatus = UserStatus.ACTIVE\n        get() = RealmUtils.enumValueOf(field, statusStr)!!\n        set(value) {\n            field = value\n            statusStr = value.name\n        }\n...\n}\n```\n\nUserStatus is an enum.\n\nError happens in time of kapt processing.\n\nGradle file plugins block:\n\n```\nplugins {\n    id \"com.android.library\"\n    id \"kotlin-android\"\n    id \"kotlin-android-extensions\"\n    id \"kotlin-kapt\"\n    id \"realm-android\"\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s): 5.8.0\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: 3.2.1\n\nAndroid Build Tools version: 28.0.3\n\nGradle version: 4.10.1\n\nWhich Android version and device(s): all\n\n","comments":["Have you tried `@field:Ignore`?","> Have you tried `@field:Ignore`?\r\n\r\nyes, but no results","@olmur What version of Kotlin do you use?\r\nI have got the very same problem after switching from 1.2.27 to 1.3.11.\r\nIt seems to be a kapt problem, the corresponding field in java-generated file is not annotated with @Ignore. \r\nThis problem I see only when var\/val field has get() implementation.\r\n","Yeah, the issue happening on 1.3.11 when field has getter also. I made a workaround but that's sad :(","Was facing similar error. Compilation failed stating error mentioned above along with a warning: 'Unclosed files for the types '[io.realm.....RealmProxy]'; these types will not undergo annotation processing'. I noticed that the RealmProxy file generated for my RealmObject was literally unclosed. i.e. with partial generated code.\r\n\r\nIn my case, attribute with @Ignore annotation had a custom getter\/setter. However, the setter was redundant and hence not necessary. Removing the setter fixed the problem. But it is weird since it worked fine till now and only failed after upgrading gradle wrapper, gradle plugin and kotlin version. Also weird is why it fails for custom setter and not the getter.\r\n\r\nGradle wrapper: 5.1.1\r\nGradle plugin: 3.3.0 \r\nKotlin: 1.3.11\r\nRealm: 5.9.0","Any updates? Unfortunately Kotlin 1.3 is required when you want to use Gradle plugin 3.3.0  ","Same issue.\r\nUnclosed files for the types '[]'; these types will not undergo annotation processing\r\n\r\nGradle wrapper: 4.6, 4.10.1, 5.1.1\r\nGradle plugin: 3.3.0\r\nKotlin: 1.3.20, 1.3.21\r\nRealm: 5.8.0, 5.9.0\r\n\r\n@Zhuinden can you give some advice or estimates?","@yu2z I'm not a Realm member and I am not working on Realm and therefore I certainly won't know anything about estimates; but my only guess would be to try `@field:Ignore @get:Ignore @set:Ignore` and if it still doesn't work then... well, try something else? You could try marking it `@Transient`.","@Zhuinden Hi I tried marking  the properties `@Transient`, which also did not solve the problem.\r\n\r\nGradle: 4.10.1\r\nKotlin: 1.3.11\r\nRealm: 5.8.0","Yeah, no idea from me.\r\n\r\n@cmelchior ?","```\r\nopen class Test: RealmObject() {\r\n\r\n    enum class MyEnum {\r\n        Test\r\n    }\r\n\r\n    private var strField: String = MyEnum.Test.name\r\n\r\n    var enumField: MyEnum\r\n        get() = MyEnum.values().first { it.name == strField }\r\n        set(value) { strField = value.name }\r\n}\r\n```\r\n\r\nThis works for me in Kotlin 1.3.21\r\n\r\nIn the above case the `enumField` do not have a backing field (which is what trips Realm up), so no `@Ignore` annotation is needed.\r\n\r\nIt is because you refer to the `field` that causes Kotlin to create the backing field which is picked up by the Realm annotation processor","I couldn't find a way to set an annotation on the backing field itself in the Kotlin documentation, so I don't know if that is possible.\r\n\r\nIn any case, trying to store a quick reference to the enum value is going to bite you as the RealmObject is live, so the underlying String value for the enum can change while the cached value will not. So I would not recommend that.\r\n\r\nI suspect this is something we would want to document in the Kotlin section of our docs as this is rather non-obvious if you don't know the intimate details of both Kotlin and Realm.","@cmelchior I think that's a reasonable solution, I would suggest adding into the doc (sorry if it already is). I guess there is not a neater way of solving this issue.\r\n\r\nCheers! "],"labels":["T-Doc","O-Community","Pipeline-Soon-Backlog"]},{"title":"Document Realm Best Practices","body":"Hi,\nI have scoured the internet for realm best practices but they are scattered and inconsistent.\n\nIt would be great if the realm team came up with a repo of gists or samples to illustrate realm best practices for java.\n\nSome areas would be-\n1)Realm Initialisation\n2)Realm Compaction\n3)Realm closing and app exit best practices\n4)Realm bulk multi insert best practices\n5)Realm fetch best practices\n6)Realm backup db best practices\n7)How to prevent Realm DB from getting corrupted.\n8)How to model Realm DB schema's (When to create separate realms etc.)\n9)Realm DB optimisation.\n\n","comments":["<s> Also best practice for deep cloning a RealmList so that modifications on original RealmList wont affect cloned RealmList. <\/s>\r\nEdit: I guess the answer to that is `realm.copyFromRealm(Iterable<Item>)`","um, what? I agree with the initial premise, but that is just not how RealmLists work. Managed RealmLists belong to the object itself.","@MkazemAkhgary \r\n> Also best practice for deep cloning a RealmList so that modifications on original RealmList wont affect cloned RealmList.\r\n\r\nYou cannot clone objects with primary keys. By definition there is only one of them. For all other types, simply copying it should work fine.","Any update on this?","I never seem to have read the initial question for some reason, but I know some things off the top of my head..\r\n\r\n> 1) Realm Initialisation\r\n\r\nYou can set the default realm configuration in `Application.onCreate`.\r\n\r\nIf you are writing a library project, then DO NOT SET the default configuration.\r\n\r\nThen you generally either want a single instance for the UI thread based on Activity ref counting, OR you can open a Realm instance in each Activity\/Fragment directly (this is documented).\r\n\r\nBackground threads require their own instances, and those instances should (must?) be closed when you are no longer using them. `close()` must be called as many times as you called `getInstance` on that given thread.\r\n\r\nHopefully, one day `getInstance()` will be called `open` to reflect this.\r\n\r\n> 2) Realm Compaction\r\n\r\nCompaction opens the Realm, writes a compacted copy of it, then replaces the original file; so it's best to ensure that this happens only in one process. I used to compact when the application was closing (Activity ref count reached 0 so UI thread Realm was closed).\r\n\r\nCompaction is available only if the global instance count is 0 (there is no open Realm on any threads in any processes).\r\n\r\n> 3) Realm closing and app exit best practices\r\n\r\nThis is already documented.\r\n\r\n> 4)Realm bulk multi insert best practices\r\n\r\nSee https:\/\/stackoverflow.com\/questions\/29214236\/how-to-add-1-milion-items-in-realm-correctly\/38891222#38891222 or https:\/\/stackoverflow.com\/a\/39385985\/2413303\r\n\r\n> 5)Realm fetch best practices\r\n\r\nDefine a `RealmResults` as a field, initialize it from the Realm instance for this given thread with `findAllAsync` (on UI thread). On UI thread, add a RealmChangeListener.\r\n\r\nYou will retrieve the data from Realm when query is complete, and all future changes so that you don't need to wonder how to keep your data in sync with the db.\r\n\r\nOn background thread, open an instance, close it when it is no longer needed, and inbetween use the synchronous Realm query api.\r\n\r\n> 6)Realm backup db best practices\r\n\r\ndunno \r\n\r\n> 7) How to prevent Realm DB from getting corrupted.\r\n\r\nuh, don't use encryption? \ud83e\udd14 i dunno, I'm not a realm member\r\n\r\n> 8)How to model Realm DB schema's (When to create separate realms etc.)\r\n\r\nI wouldn't create separate Realms at all, especially now with the partial Realm api for sync (query-based Realms).\r\n\r\nGenerally you want to minimize the number of links between objects and bundle them all together, because link queries are restrictive, bi-directional links can slow down change notifications, and cascade deletion is not available in the bindings.\r\n\r\n> 9)Realm DB optimisation.\r\n\r\nNot sure what this means"],"labels":["T-Doc","O-Community"]},{"title":"Schema version bump without schema change doesn't require migration","body":"#### Goal\nGetting a `RealmMigrationNeededException` exception in case of a schema version bump without migration, even without schema changes.\n\n#### Actual Results\nNo exception is thrown.\n\n#### Steps & Code to Reproduce\nThe following test case fails.\n```\n    @Test\n    fun schemaVersionBumpRequiresMigration() {\n        val realmV0config = RealmConfiguration.Builder()\n            .build()\n\n        Realm.getInstance(realmV0config).close()\n\n        val realmV1config = RealmConfiguration.Builder()\n            .schemaVersion(1)\n            .build()\n\n        var realm: Realm? = null\n\n        try {\n            realm = Realm.getInstance(realmV1config)\n            fail()\n        } catch (expected: RealmMigrationNeededException) {\n        } finally {\n            realm?.close()\n        }\n    }\n```\nIf I add a migration to `realmV1config` it actually get's called - this behavior seems inconsistent. I think if Realm sees a schema version bump it should require a migration and throw if it's missing instead of deciding that it is optional. If the current behavior is expected, the Javadoc of `RealmConfiguration.Builder.schemaVersion` should reflect that.\n\n#### Version of Realm and tooling\n\nRealm version(s): 5.8.0\nRealm Sync feature enabled: No\nAndroid Studio version: 3.2.1\nAndroid Build Tools version: 3.2.1\nGradle version: 4.6\nWhich Android version and device(s): n\/a","comments":["I think the thinking originally was that providing a new schema version without a migration most likely was a bug. However, you are not the first to run into this, so I think we should change the behavior so this use case is allowed.\r\n\r\nThis also fits the API better where `schemaVersion` and `migration` are actually two different methods. If we wanted to truly force them together it should only be one API call.","Same issue here. In my case, i'm testing a migration  just setting a higher schema version before to change the current model. According to `RealmConfiguration.Builder.schemaVersion(int)` documentation, if a higher schema version is set (compared to the current realm file schema version), then a migration is needed but the expected `io.realm.exceptions.RealmMigrationNeededException` is never thrown. \r\n\r\nI'm glad that this behaviour is taken into account for a future enhancement of the API."],"labels":["T-Enhancement","O-Community"]},{"title":"Update LiveData value when becoming active","body":"Allow LiveData to stay up to date, especially when resuming an activity\r\n\r\nIt solves this issue: https:\/\/stackoverflow.com\/questions\/49981734\/observer-for-android-livedata-not-called-but-it-is-with-observeforever","comments":["@cmelchior Looks like this needs another review "],"labels":["T-Bug","O-Community"]},{"title":"Files generated by viewing a Realm with Realm Studio causes Gradle builds to hang","body":"#### Goal\nEnsure builds complete properly when bundling an existing Realm database with an Android application.\n\n#### Actual Results\nTo bundle an existing Realm database with an Android application, the database file is often place in an `\/assets` directory. If Realm Studio is used to inspect this database, a few files will be generated in the same directory, namely:\n\n* A `.realm.lock` file.\n* A `.realm.note` file.\n* A `.realm.management` directory containing:\n  * A `access_control.control.mx` file.\n  * A `access_control.new_commit.cv` file.\n  * A `access_control.pick_writer.cv` file.\n  * A `access_control.write.mx` file.\n\nAttempting to build the application after these files have been generated in the `\/assets` directory will cause the build to hang.\n\n#### Steps & Code to Reproduce\n1. Create an Android application, and create an `\/assets` directory in `app\/src\/main\/`.\n1. Add a pre-exiting Realm database to the newly created `\/assets` directory and rebuild the application, ensuring that it completes.\n1. View the Realm database in`\/assets` with Realm Studio, and observe the Realm specific files generated.\n1. Attempt to rebuild and run the application, and note that the build hangs.\n\n#### Version of Realm and tooling\nRealm version(s): `\"io.realm:realm-gradle-plugin:5.4.2\"`\n\nRealm Sync feature enabled: No\n\nAndroid Studio version: `3.1.4`\n\nAndroid Build Tools version: `3.2.1`\n\nGradle version: `4.6`\n\nWhich Android version and device(s): N\/A\n\n**Note:** This issue is identical to #4787, which was closed last year. Please merge these issues as needed.\n\n","comments":["I'm not sure so this is something we can do anything about since this is Gradle acting up. Besides, you don't want to ship those files with your app anyway, so you should delete them from the `\/assets` folder when done.\r\n\r\nThat said, I have noticed something similar so we should probably figure out exactly what is going on so we can report a bug report with Google.","@cmelchior This is a common issue during development of the application. Yes, the files may simply be deleted before building, however a common workflow is to view the contents of the database while writing application logic. These temporary files disrupt that workflow by (somehow) disrupting the `mergeDebugAssets` task during build time.\r\n\r\nThis issue was independently discovered by multiple Realm users, as shipping a local Realm database is somewhat common.\r\n\r\nA Gradle task may be implemented to delete the files generated by Realm Studio before every build, though it would be preferable to simply have them be ignored. Perhaps a similar task can be included with the Realm plugin.\r\n\r\n```\r\ntask cleanupRealm(type: Delete) {\r\n    delete project.projectDir.path + \"\/src\/main\/assets\/appData.realm.management\"\r\n    delete project.projectDir.path + \"\/src\/main\/assets\/appData.realm.lock\"\r\n    delete project.projectDir.path + \"\/src\/main\/assets\/appData.realm.note\"\r\n}\r\n\r\ntasks.whenTaskAdded { task ->\r\n    if (task.name == \"preDebugBuild\" || task.name == \"preReleaseBuild\") {\r\n        task.dependsOn cleanupRealm\r\n    }\r\n}\r\n```"],"labels":["T-Bug","O-Community"]},{"title":"Batch updates should support linked fields","body":"https:\/\/github.com\/realm\/realm-java\/pull\/5133 added support for batch updating fields using a `RealmResults`. However, the implementation doesn't support linked fields, you can only update fields directly on the queried object.\n\nIt would be nice if it was also possible to update linked objects.\n\n```\npublic class MyData extends RealmObject {\n  public String name;\n  public MetaData metadata; \/\/ 1-1 relation\n}\n\npublic class MetaData extends RealmObject {\n  public boolean read;\n\n  @LinkingObjects(\"metadata\")\n  public RealmResults<MyData> data; \n}\n\nRealmResults<MyData> persons = realm.where(Person.class).equalTo(\"name\", \"Jane\").findAll();\npersons.setBoolean(\"metadata.read\", true);\n```\n\nTheoretically, you can achieve the same using queries on the inverse relationship, but it requires you to add the `@LinkingObjects` property and reverse the logic, which in some types of object graphs can be problematic (e.g. if multiple objects can point to the child object).\n\n```\nRealmResults<Metadata> data = realm.where(MetaData.class).equalTo(\"data.name\",  \"Jane\").findAll();\ndata.setBoolean(\"read\", true);\n```","comments":[],"labels":["T-Enhancement"]},{"title":"Add support for ImportFlag to all API's","body":"Fallout from https:\/\/github.com\/realm\/realm-java\/issues\/6224\n\nWe should add support for `ImportFlag` to all other API's beside `copyToRealm` and `copyToRealmOrUpdate` that import data:\n\n* `Realm.insert(...)`\n* `Realm.insertOrUpdate(...)\n* `Realm.createObjectFromJson(...)`\n* `Realm.createOrUpdateObjectFromJson(...)`\n* `Realm.createAllFromJson(...)`\n* `Realm.createOrUpdateAllFromJson(...)`\n\nNote that adding support for it in the streaming version of `createOrUpdate` is very easy as it uses `copyToRealmOrUpdate` under the hood. The others will require more work.\n\nWorking with JSON is already fairly slow, so performance is not much of a concern for those API's, but I suspect that adding support for `insertOrUpdate` will be very difficult. The reason being that this API is already hyper-optimized meaning we cannot use the Object Store implementation for diffed updates if we want to retain that (which we do, it is the whole reason that method exists in the first place).\n\nSo a roadmap could look like:\n1) Convert JSON methods\n2) Evaluate if we even need to support this when using `insertOrUpdate()`. Only if there is a true need for it, should we look into ways of accomplishing it.","comments":[],"labels":["T-Enhancement"]},{"title":"Diffed updates: Throw proper RealmPrimaryKeyConstraintException from ObjectStore","body":"Fallout from https:\/\/github.com\/realm\/realm-java\/pull\/6224#discussion_r229832784\n\nDoing pattern matching on an error message is very brittle. We should make sure that Object Store throws a specialized enough exception that we can convert it correctly at the JNI boundary.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Update query backing RealmResults for correct notifications when incrementally improving a query.","body":"#### Describe your problem or use case\nI have a search input and a list rendered with `RealmRecyclerViewAdapter` (or a simple recylerview adapter for that matter, but getting changes from `asChangesetObservable()`). I want to filter that list based on user's input and get granular notifications for the adapter. \n\nWhy am I using Realm? Because the chat-app I'm building is supposed to support lists with 2-3k items and I like the idea of not copying data into memory when rendering 3 of those lists in a viewpager.\n\nWhat I'm doing right now:\n```\nfun observeCampaigns(nameQuery: String): Flowable<RealmResults<CampaignRealm>> =\n    Realm.getDefaultInstance().use { realm ->\n        realm.where<CampaignRealm>()\n            .contains(CampaignRealmFields.NAME, nameQuery, Case.INSENSITIVE)\n            .findAllAsync()\n            .asFlowable()\n            .filter { it.isLoaded }\n    }\n```\nI'm executing the `observeCampaigns` function each time the query changes and pass the RealmResults to the adapter.\n\nThis doesn't work because I'm creating a new RealmResults each time and I'll always get `changeSet.getState() == OrderedCollectionChangeSet.State.INITIAL` inside the `OrderedRealmCollectionChangeListener` of the adapter.\n\n#### Describe the solution you'd like\nI need a way to filter RealmResults, or have the same query re-executed with different parameters so I get proper change notifications.\n\n#### Additional context\nI also wrote a [stackoverflow question](https:\/\/stackoverflow.com\/questions\/52615547\/filter-realmresults-with-string-query-and-get-recyclerview-granular-animations#52621607).\n\nOne bypass solution would be to use realm-monarchy to detach realm objects & get an Architecture Components PagedList. This seems counterintuitive and defeats the purpose of using Realm in the first place. I also made an [issue on realm-monarchy for feedback](https:\/\/github.com\/Zhuinden\/realm-monarchy\/issues\/22).\n\nI'm sorry for the ranty tone, but this seems such a trivial thing & I can't be the first person who wants to do this, right?","comments":["In retrospect, it sounds really nice and also more efficient to filter a RealmResults in place, instead of creating a new RealmResults each time and hoping for GC to eliminate previously created result sets that may or may not have to be updated when a new version arrives (background thread write)","Yes, I can definitely see the use case for filter UI's that incrementally changes while you want to retain nice animations. \r\n\r\nYou are right that this is not supported very well in the current Java API's. I believe we discussed the use case internally at some point, but I cannot remember the conclusion right now, so I'll have to dig it up","@cmelchior any updates? \ud83d\ude04 ","Yes, sorry for not writing it up. \r\n\r\nAfter a little digging, we don't have direct support for it right now, but nothing in the notification implementation should prevent us from doing this.. However, I cannot give you a concrete timeline at this point.\r\n\r\nFor the matter of API I'm thinking something along the line of:\r\n\r\n```\r\nRealmResults.updateQuery(Query);\r\n\r\nExample:\r\nRealmResults<Person> p = realm.where(Person.class).startsWith(\"name\", \"chr\").findAllAsync();\r\np.addChangeListener(...);\r\np.updateQuery(realm.where(Person.class).startsWith(\"name\", \"christian\"));\r\n````\r\n\r\n","Hey - looks like you forgot to add a T:* label - could you please add one?"],"labels":["T-Enhancement","O-Community"]},{"title":"Support OFFSET","body":"Followup from #544 and #6126 \n\n#6126 introduces support for LIMIT, this makes it possible to do keyed pagination as described in the JetPack pagination documentation (ItemKeyedDataSource):\n\nhttps:\/\/developer.android.com\/reference\/android\/arch\/paging\/DataSource\nhttps:\/\/developer.android.com\/reference\/android\/arch\/paging\/ItemKeyedDataSource\n\nHowever, Positional or tiled paging require OFFSET to function correctly:\nhttps:\/\/developer.android.com\/reference\/android\/arch\/paging\/PositionalDataSource\n\nThis issue tracks adding OFFSET support to the query language and thus notification system. Some primitive form of OFFSET can already be implemented using the standard `List.subList()` API: https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/List.html#subList(int,%20int) \n\nImplementation notes:\nOFFSET on a local dataset would be very simple to do, but _very hard_ in Query-based Realms as the device Realm might not have the complete view, meaning the query will have to adjust for potential objects still not synchronized. See the internal design document for further details: https:\/\/docs.google.com\/document\/d\/11KAjdw4nxJtv2fq7JPuWhy4tuKOtoyiJlnoOnEEgXUc\/edit#heading=h.c3uxob836ny1","comments":[],"labels":["T-Feature"]},{"title":"Realm initialization unnecessarily uses reflection, impacting startup performance","body":"I was profiling the startup performance of my app, and found that initializing Realm took around 100ms, and half of that time was spent on a single reflection call\n\nWhen calling `Realm.init()`, the following line is executed:\nhttps:\/\/github.com\/realm\/realm-java\/blob\/afc79e568d3f710fcdf99d30bf67b33c8134f6c6\/realm\/realm-library\/src\/main\/java\/io\/realm\/Realm.java#L270\n\nBecause this configuration is created empty, `build()` is forced to call `isRxJavaAvailable()`\nhttps:\/\/github.com\/realm\/realm-java\/blob\/afc79e568d3f710fcdf99d30bf67b33c8134f6c6\/realm\/realm-library\/src\/main\/java\/io\/realm\/RealmConfiguration.java#L812-L814\nhttps:\/\/github.com\/realm\/realm-java\/blob\/afc79e568d3f710fcdf99d30bf67b33c8134f6c6\/realm\/realm-library\/src\/main\/java\/io\/realm\/RealmConfiguration.java#L422-L432\n\nWe can avoid this reflection call when creating our own `RealmConfiguration` by providing it with an `RxObservableFactory`, but we don't have access to the one that's created inside of `Realm.init()`, forcing us to waste 50ms at app startup\n\n## Proposed solution\n\nIf we could provide our own `RealmConfiguration` to be used for `Realm.init()`, then this should help improve startup performance for apps who know that they will be using RxJava","comments":[],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"Calling RealmQuery.or() twice in a row causes a native crash","body":"Hello, I am trying to debug an app that we outsourced. Unfortunately I know very little about the intentions behind the code and such.\n\nI can see that the realm library is having some trouble and crashes the app. I don't know how to deal with this issue because I've never come across NDK type stuff before now. Is this a realm bug? \n\nI am using io.realm:realm-gradle-plugin:5.5.0\nBut I tried every version I can and the crash happens every time.\n\nI am using android studio 3.1.4 and I'm on a Samsung s8 with Android version 8.0.0\n\nUnfortunately I really cant pinpoint what part of the app crashes because the debugger just takes me to a lot of internal Android files.\n\n**Error log:**\n\n> 09-17 16:28:50.802 11131-11131\/? A\/DEBUG: \n\n- - -\n>     Build fingerprint: 'samsung\/dreamltexx\/dreamlte:8.0.0\/R16NW\/G950FXXU3CRGH:user\/release-keys'\n>     Revision: '10'\n>     ABI: 'arm64'\n>     pid: 10588, tid: 10588, name: orlobet.testing  >>> com.example.app.testing <<<\n>     signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x78\n>     Cause: null pointer dereference\n>         x0   0000000000000070  x1   0000007ff81f9f88  x2   0000000000000000  x3   0000000000000008\n>         x4   0000000000000000  x5   000000720327c2c4  x6   0000000070c01fe8  x7   0000000000000000\n>         x8   b9cff98c1c9e7bbf  x9   b9cff98c1c9e7bbf  x10  0000000000000003  x11  000000721d00d5e8\n> 09-17 16:28:50.807 11131-11131\/? A\/DEBUG: backtrace:\n>         #00 pc 00000000001af4ac  \/data\/app\/com.example.app.testing-iPhr1XyBcWheyQgchPeqDw==\/lib\/arm64\/librealm-jni.so\n>         #01 pc 00000000001b097c  \/data\/app\/com.example.app.testing-iPhr1XyBcWheyQgchPeqDw==\/lib\/arm64\/librealm-jni.so\n>         #02 pc 00000000001b4628  \/data\/app\/com.example.app.testing-iPhr1XyBcWheyQgchPeqDw==\/lib\/arm64\/librealm-jni.so\n>         #03 pc 0000000000088864  \/data\/app\/com.example.app.testing-iPhr1XyBcWheyQgchPeqDw==\/lib\/arm64\/librealm-jni.so (Java_io_realm_internal_TableQuery_nativeOr+180)\n>         #04 pc 0000000000034cd4  \/data\/app\/com.example.app.testing-iPhr1XyBcWheyQgchPeqDw==\/oat\/arm64\/base.odex (offset 0x21000)\n\n","comments":["Wow. Ok I just had a breakthrough.\r\nAfter I meditated a bit and did another round of thorough debugging, I found this code:\r\n`     RealmResults<AnswerImageData> answerImgDataList = realm\r\n                .where(AnswerImageData.class)\r\n                .equalTo(\"id\", questionData.getFalse1_id())\r\n                .or()\r\n                .or().equalTo(\"id\", questionData.getFalse2_id())\r\n                .or().equalTo(\"id\", questionData.getFalse3_id())\r\n                .or().equalTo(\"id\", questionData.getCorrect_id()).findAll();`\r\n\r\nIt seemed weird to me that there should be 2 `.or()`'s after one another. So i removed one and now the app finally works :)\r\n\r\nI'd like to get a confirmation. Is two `.or()`'s in a row cause of bugging in realm? I don't want to remove that only to realize that i removed legitimate code.\r\n\r\nIf it's a bug, how can I better detect such errors in the future? :)","Yes, calling `or().or()` is not a valid query, but ideally, we would throw a much better exception message if it happened.\r\n\r\nHowever, it seems we do crash in the native code. At least I'm getting the following exception:\r\n\r\n```\r\n09-16 10:01:40.817 11841-11857\/? E\/REALM: \/home\/jenkins\/workspace\/lm_realm-core_release_5.8.0-WNQBV7C77QKZDCVNM3JGU7TWI2TAI6NYMGETFCZRYCCOCOCMZT2A@9\/src\/realm\/query.cpp:1727: [realm-core-5.8.0] Assertion failed: dynamic_cast<OrNode*>(current_group.m_root_node.get())\r\n    !!! IMPORTANT: Please send this log and info about Realm SDK version and other relevant reproduction info to help@realm.io.\r\n09-16 10:01:40.817 11841-11857\/? A\/libc: Fatal signal 6 (SIGABRT), code -6 in tid 11857 (roidJUnitRunner)\r\n09-16 10:01:40.874 11861-11861\/? A\/DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\r\n    Build fingerprint: 'Android\/vbox86p\/vbox86p:7.1.1\/NMF26Q\/genymo09291150:userdebug\/test-keys'\r\n    Revision: '0'\r\n    ABI: 'x86'\r\n    pid: 11841, tid: 11857, name: roidJUnitRunner  >>> io.realm.test <<<\r\n09-16 10:01:40.875 11861-11861\/? A\/DEBUG: signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------\r\n        eax 00000000  ebx 00002e41  ecx 00002e51  edx 00000006\r\n        esi d519c978  edi d519c920\r\n        xcs 00000023  xds 0000002b  xes 0000002b  xfs 0000006b  xss 0000002b\r\n        eip f2b63bb9  ebp d5194de8  esp d5194d8c  flags 00000296\r\n09-16 10:01:40.877 11861-11861\/? A\/DEBUG: backtrace:\r\n        #00 pc 00000bb9  [vdso:f2b63000] (__kernel_vsyscall+9)\r\n        #01 pc 0007a30c  \/system\/lib\/libc.so (tgkill+28)\r\n        #02 pc 00075b55  \/system\/lib\/libc.so (pthread_kill+85)\r\n        #03 pc 0002786a  \/system\/lib\/libc.so (raise+42)\r\n        #04 pc 0001ee46  \/system\/lib\/libc.so (abort+86)\r\n        #05 pc 00682bf6  \/data\/app\/io.realm.test-2\/lib\/x86\/librealm-jni.so (please_report_this_error_to_help_at_realm_dot_io+23)\r\n        #06 pc 00682d32  \/data\/app\/io.realm.test-2\/lib\/x86\/librealm-jni.so (_ZN5realm4utilL18terminate_internalERSt18basic_stringstreamIcSt11char_traitsIcESaIcEE+260)\r\n        #07 pc 00682e13  \/data\/app\/io.realm.test-2\/lib\/x86\/librealm-jni.so (_ZN5realm4util9terminateEPKcS2_lOSt16initializer_listINS0_9PrintableEE+224)\r\n        #08 pc 0059a824  \/data\/app\/io.realm.test-2\/lib\/x86\/librealm-jni.so (_ZN5realm5Query8add_nodeESt10unique_ptrINS_10ParentNodeESt14default_deleteIS2_EE+400)\r\n        #09 pc 005992e6  \/data\/app\/io.realm.test-2\/lib\/x86\/librealm-jni.so (_ZN5realm5Query2OrEv+136)\r\n        #10 pc 0011f4e1  \/data\/app\/io.realm.test-2\/lib\/x86\/librealm-jni.so (Java_io_realm_internal_TableQuery_nativeOr+268)\r\n        #11 pc 00b22e64  \/data\/app\/io.realm.test-2\/oat\/x86\/base.odex (offset 0xa97000)\r\n```\r\n\r\nThis is a bug that should be fixed"],"labels":["T-Bug","O-Community"]},{"title":"Support for Hooks","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\n\n\n```java\nExample: \n\nnew RealmConfiguration()\n        .registerHook(User.class, new Hook<User> () {\n                 @Override\n                  public User onBeforeSave(User model, Realm realm) {\n                             \/\/ do something;\n                             return model;\n                   }\n\n                   @Override\n                  public User onBeforeDelete(User model, Realm realm) {\n                             FileUtils.deleteFile(model.getPhotoPath());\n                             return model;\n                   }\n         });\n\nUser user = realm.where(User.class).findFirst();\nuser.deleteFromRealm();\n\n```","comments":["Hmm, interesting use case.\r\n\r\nFor this to truly work we would probably need Core support since things can get deleted in a multiple of ways, especially when we consider sync support where a deletion might have happened on another device. For this reason alone I doubt that hooks are something we can implement easily.\r\n\r\nNext comes the question of how many hooks are needed. You just list two here associated with manipulating objects, but one could probably expand the list indefinitely.\r\n\r\nFinally, it seems to me that both of these hooks could be implemented yourself by providing wrapper methods. I do agree it requires more code on your part, but since this is the first time we heard this use case in 4 years, I'm not sure it would be worth the cost to add them.\r\n\r\nI'll keep the issue open and put it on the backlog so we can track interest.\r\n\r\n","I though there was something like that yet, because it's so useful, nice request ;)"],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Document how to run integration tests with Realm","body":"#### Goal\nTo document how to write integration tests using Realm.\n\n#### Expected Results\nDevelopers to easily get up and running an integration test.\n\n#### Why\nI'm looking to build a PoC using a ports and adapters setup, where I have a set of interfaces that another module will implement. This module should ideally be isolated and have as single responsibility the implementation of the port.\n\nIn order to prove that this library works, I'd like to write integration tests where the adapters are executed against Realm, and I can assert it behaves as any other adapter should.\n\n","comments":["If Realm is isolated inside a module and the module just exposes standard interfaces I don't see any reason why it shouldn't \"just work\" like any other integration test setup.\r\n\r\nBut maybe I'm not fully understanding what you are trying to do?\r\n","@cmelchior sorry it wasn't clear enough, I spent some more time over the weekend and manage to get the tests I was looking for.\r\n\r\nTo be more concrete, my proposal would add to this [section(https:\/\/realm.io\/docs\/java\/latest\/#testing-and-debugging):\r\n\r\n* How to mock Realm (already had a sample [here](https:\/\/github.com\/realm\/realm-java\/blob\/master\/examples\/unitTestExample\/src\/test\/java\/io\/realm\/examples\/unittesting\/ExampleRealmTest.java))\r\n** Add as a caveat that you shouldn't mock classes you don't own, with a link to something along the lines of [this](https:\/\/github.com\/testdouble\/contributing-tests\/wiki\/Don't-mock-what-you-don't-own).\r\n* How to run an integration test where you prove your code + Realm mets the requirements you have.\r\n** In the testing samples, only unit tests and espresso test are presen\r\n\r\nAnd to add in the test samples an example of an instrumentation test. I will do a PR for this.\r\n","@cmelchior run into some issues I'm afraid due to my AS being newer than the version used to maintain this project (3.1.4):\r\n\r\nhttps:\/\/github.com\/realm\/realm-java\/pull\/6129\r\n\r\nCould you look into running the tests? I think it should be fine but unfortunately didn't manage to test it properly :("],"labels":["T-Doc","O-Community"]},{"title":"Allow Realm model classes to not be public","body":"#### Goal\n\nI want my Realm models to **not** be visible outside their module.\nE.g. I'm trying to remove the `public` keyword in front of all classes extending `RealmObject`.\n\n#### Expected Results\n\nMy code should compile with non-public `RealmObject`-extending classes or `@RealmClass` annotated, non-public classes implementing the `RealmModel` interface.\n\n#### Actual Results\n\nI get the following error from the Java compiler when I remove the `public` keyword:\n\n`error: Class \"ClassName\" must declare a public constructor with no arguments if it contains custom constructors.`\n\nAlthough my classes do not contain custom constructors. When I add the `public` keyword again - everything works fine.\n\n#### Code Sample\n\nHere's a simple non-public RealmObject that causes the error, but this happens with any model.\n\n```java\nclass ScoreModel extends RealmObject implements Score {\n    @SerializedName(\"min\")\n    private int min;\n    @SerializedName(\"max\")\n    private int max;\n\n    public int getMin() {\n        return min;\n    }\n\n    public void setMin(int min) {\n        this.min = min;\n    }\n\n    public void setMax(int max) {\n        this.max = max;\n    }\n\n    public int getMax() {\n        return max;\n    }\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s): 5.3.1\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 3.1.3","comments":["I fully understand the sentiment. Unfortunately, supporting it will be rather difficult. The reason is that Realm generates a Proxy class that extends your model class, so the class must as a minimum be package private.\r\n\r\nWhile we easily could change the annotation processor to create the proxy class in the package where you model class lives, the problem then comes as the proxy class uses a number of package methods that reside in the `io.realm` package. The reason for this is that we want to keep our public API as clean as possible and supporting proxies in other packages would mean we would have to make a ton of internal methods public.\r\n\r\nI have not looked much into modules from Java 9, but supposedly that might solve some of this, but since it isn't supported by Android it wouldn't be useful anyway.\r\n\r\nSo right now, there probably isn't much we can do about this, but I'll keep the issue open as a way to track interest and possible future solutions."],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Proposal: Deprecate or change RealmQuery.findFirstAsync()","body":"There is no safe way to use `findFirstAsync`. If the object is deleted, you'll get an invalid object, and you'll need a results change listener to know if you need to re-execute the object query to find the object. \n\nIt would be much safer to provide a RealmOptional, which you could register change listener to, which is added to the object if it's found and present, or just \"kept for later\" if doesn't. And the RealmOptional would be based on a results listener that \"if empty, then not present, else first element of result\". This way it would be kept up to date like a RealmResults except it is single element.","comments":["Ref: https:\/\/github.com\/realm\/realm-java\/issues\/5179\r\n\r\nFirst, I would say I probably agree with you. Secondly, I actually tried looking into this a couple of months back there is at least two corner case that is slightly annoying\r\n\r\nConsider:\r\n```\r\nRealmOptional<Person> personOpt = realm.where(Person.class).equalTo(\"name\", \"Jane\").findFirst();\r\npersonOpt.addChangeListener((person, changeset) -> {\r\n  \/\/ 1) Person might be null, and current change listeners do not allow null\r\n \/\/  2) How should the changeset look like when switching between objects?\r\n \/\/     The current behaviour will be emitting an empty changeset when a new object is found.\r\n \/\/     This might be fine though.\r\n});\r\n```\r\n\r\nBehind the scenes, the `RealmOptional` would just be wrapping `findAll()` which is fairly easy, but having to create entirely new listener interfaces `NullableRealmChangeListener and `NullableRealmObjectChangeListener` is fairly annoying, but I'm not sure I see a way around it.","> \/\/ 1) Person might be null, and current change listeners do not allow null\r\n\r\nTechnically you *could* emit the invalid object when item is not found, it's already pretty much a placeholder for `null` anyways in case object was deleted.\r\n\r\n> \/\/  2) How should the changeset look like when switching between objects?\r\n> \/\/     The current behaviour will be emitting an empty changeset when a new object is found.\r\n> \/\/     This might be fine though.\r\n\r\nEmpty change set would make sense, the trickier part is the changeset state that I believe comes from OS. \r\n","Another crazy idea I had was that RealmOptional could be used synchronously too, but `findFirst` already has its uses, so I'm not lobbying to change *that*. In which case the question is naming. ","`RealmObjectChangeSet` is just an interface, so creating an empty implementation would be trivial, but looking at the interface definition it seems we return `null` the first time the object is loaded, so we would just return null whenever a new object replaced the old one.\r\nSo an acceptable API would be the below?\r\n\r\n```\r\n\/\/ Will never return `null`\r\npublic class RealmOptional<T extends RealmModel> {\r\n  T get(); \/\/ Return matching or object or invalid object if not found\r\n  boolean isPresent(); \/\/ true if object is there and valid\r\n  T orElse(t other); \/\/ Return other if isPresent() returns false\r\n  void addChangeListener(RealmChangeListener listener);\r\n  void addChangeListener(RealmObjectChangeListener listener);\r\n  void removeChangeListener(RealmChangeListener listener);\r\n  void removeChangeListener(RealmObjectChangeListener listener);\r\n  void removeAllChangeListeners();\r\n```\r\n\r\nUsage\r\n\r\n```\r\n\/\/ New behaviour where you just want _some_ object to match your \r\n\/\/ query (i.e. continuously evaluate query).\r\n\r\nRealmOptional<Person> p = realm.where(Person.class).equaTo(\"name\", \"Jane\").findFirstAsync();\r\np.addChangeListener((person, changeset) -> {\r\n  if (changeset == null) \r\n     \/\/ We only emit null the first time the object is loaded\r\n     refreshPerson(p); \/\/ Fully refresh the person \r\n  } else if (person.isValid()) {\r\n    \/\/ updatePerson(person, changeset); \/\/ Current person was updated\r\n  } else {\r\n    \/\/ Person was deleted and no new object matched the query, optional is empty\r\n  }\r\n});\r\n\r\n\/\/ Opting in to the old behaviour is one extra method call\r\nRealmOptional<Person> p = realm.where(Person.class).equaTo(\"name\", \"Jane\").findFirstAsync();\r\nPerson per = p.get();\r\nper.addChangeListener(...); \/\/ Like normal\r\n```\r\n\r\nDoes this look acceptable @Zhuinden? \r\n\r\nWe would either need to break the API if we replace `findFirstAsync()` or find another name like `findFirstOptionalAsync()` \ud83e\udd22 . I would probably be fine with breaking `findFirstAsync()` since it would also enable us to make subscriptions work with it. Implementation wise the above would be fairly trivial as we are just wrapping `findAllAsync()` and object listeners once an object is found.\r\n\r\nThoughts @nhachicha \r\n\r\nFor reference, the Android version of Optional is here: https:\/\/developer.android.com\/reference\/java\/util\/Optional\r\n\r\nGuava version is here:\r\nhttps:\/\/google.github.io\/guava\/releases\/22.0\/api\/docs\/com\/google\/common\/base\/Optional.html\r\n\r\nJava 8 version is here:\r\nhttps:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/Optional.html\r\n","Pretty much what I was thinking of, yes :+1:\r\n\r\n> findFirstOptionalAsync()\r\n\r\nOr just `findOne`\/`findOneAsync` \ud83d\ude04  no that'd be confusing, dammit\r\n\r\n`findOptional` \/ `findOptionalAsync`? I'm bad with names.","Any comments on this @nhachicha ?","@cmelchior having `findAllAsync` as the underneath implementation could indeed solve the subscription issue we have in the query based Realm https:\/\/github.com\/realm\/realm-java\/issues\/5938\r\n\r\nI'm in favour of breaking the API rather then introducing a new method, since this fixes the behaviour of the current implementation (+ Sync issue). \r\n\r\nDo you plan to wrap `findFirst` as well with RealmOptional? my guess is yes to make the API symmetric ?\r\n\r\nDo you think we should extend the use of `RealmOptional` to wrap nullable fileds as well in the model, obviously you can not register listeners, but you can benefit from the `isPresent\/orElse` syntax? \r\n","I'm still on the fence regarding letting `findFirst()` return `RealmOptional` as the synchronous methods pretty much work as we expect and @Zhuinden also seems to prefer to keep it as it is.\r\n\r\nAllowing `Optional` for properties makes sense, but there we should just add support for the standard Optional classes IMO,  because as you point out, listeners probably don't make sense. This is already being tracked here: https:\/\/github.com\/realm\/realm-java\/issues\/1260 and doesn't seem to be highly requested.","The only oddity in retrospect is that\r\n\r\n```\r\np.addChangeListener((person, changeset) -> {\r\n  if (changeset == null)  \/\/ <-- this here\r\n     \/\/ We only emit null the first time the object is loaded\r\n```\r\n\r\nRealm 5.0+ made `changeSet` non-null because it emits a `.INITIAL` instead of `null` changeset.\r\n\r\n> the synchronous methods pretty much work as we expect and @Zhuinden also seems to prefer to keep it as it is.\r\n\r\nYes, `findFirst()` is predictable. `findFirstAsync()` is just awkward.","Also, we are close to merging `LIMIT` support in Core, which means that `query.limit(1)` can easily replace the current code and be fully serializable with regard to subscriptions.","Oooh that's cool!\r\n\r\nWait a second, if you have LIMIT, can you do skip\/take? "],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"TestHelper#isSelinuxEnforcing crashing on Android 8","body":"To reproduce run `RealmTests#namedPipeDirForExternalStorage()` on API 27 (make sure `adb shell getenforce` returns `Enforced`)\n\n```\njava.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.String java.lang.String.toLowerCase(java.util.Locale)' on a null object reference\nat io.realm.TestHelper.isSelinuxEnforcing(TestHelper.java:1206)\nat io.realm.RealmTests.namedPipeDirForExternalStorage(RealmTests.java:4287)\nat java.lang.reflect.Method.invoke(Native Method)\nat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\nat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\nat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\nat android.support.test.internal.runner.junit4.statement.RunBefores.evaluate(RunBefores.java:80)\nat android.support.test.internal.runner.junit4.statement.RunAfters.evaluate(RunAfters.java:61)\nat io.realm.rule.TestRealmConfigurationFactory$1.evaluate(TestRealmConfigurationFactory.java:64)\nat org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:239)\nat org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:48)\nat android.support.test.internal.runner.junit4.statement.UiThreadStatement.evaluate(UiThreadStatement.java:66)\nat org.junit.rules.RunRules.evaluate(RunRules.java:20)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runners.Suite.runChild(Suite.java:128)\nat org.junit.runners.Suite.runChild(Suite.java:27)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:115)\nat android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:58)\nat android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:375)\nat android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2075)\n```\n\nIt looks like invoking the process\/command `\/system\/bin\/getenforce` to get the SELinux status fails which result on the NPE above, we need to find a new robust way to detect if SELinux is enforced\n\n","comments":[],"labels":["T-Internal"]},{"title":"Reload Realm file from assets","body":"#### Goal\n\n> What do you want to achieve?\n\nI have some (readonly) Realm databases that ship with the app and load from assets. I want to be able to reflect data changes (i.e. I added new rows, deleted some rows, or modified some rows, without changing the schema) in new APKs.\n\n> How do you try to achieve this?\n\nI bump `.schemaVersion()` on the `RealmConfiguration` object.\n\n#### Expected Results\n\n> ?\n\nI expect a `RealmMigrationNeededException` so I can handle it by doing something like:\n\n```java\n  private static Realm loadRealm(RealmConfiguration configuration) {\n    try {\n      return Realm.getInstance(configuration);\n    } catch (RealmMigrationNeededException e) {\n      Realm.deleteRealm(configuration);\n      return loadRealm(configuration);\n    }\n  }\n```\n\nNote that I expect this due to the documentation on `schemaVersion`, which says:\n\n> Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.\n\n#### Actual Results\n\n>  E.g. full stack trace with exception\n\nThe `Realm` instance is returned without any complaints at all - no errors, etc - it's also the stale (old) version. You can then update the code to decrease the `schemaVersion` again and re-run it, and it will also run with no issues. It's as if the `schemaVersion` doesn't even matter at all in these cases.\n\n#### Steps & Code to Reproduce\n\n> Describe your current debugging efforts.\n\nCopy the below code into a project. Run it (and make sure the app does a Realm call when the app runs). Change the line for `.schemaVersion(2)` to `.schemaVersion(3)` without making any other changes (without modifying the database, etc). Run the app again. Expect the app to crash - it doesn't. Change it to `.schemaVersion(1)`. Re-run the app again. Expect a crash. No crash.\n\nNote that, while playing with this in the same app (this app has different databases, all read only, and all read from assets), and I try the steps with one of the databases (that is accessed much more frequently), I observe the following thrown exception:\n\n```\n2018-06-16 20:02:01.867 23764-23812\/? E\/REALM_JNI: Exception has been thrown: Realm at path '\/data\/data\/com.ayah\/files\/main.realm' already opened with different schema version.\n2018-06-16 20:02:01.880 23764-23812\/? E\/realm: loadingRealm. failed.\n    java.lang.IllegalStateException: Realm at path '\/data\/data\/com.ayah\/files\/main.realm' already opened with different schema version.\n        at io.realm.internal.OsSharedRealm.nativeGetSharedRealm(Native Method)\n        at io.realm.internal.OsSharedRealm.<init>(OsSharedRealm.java:171)\n        at io.realm.internal.OsSharedRealm.getInstance(OsSharedRealm.java:241)\n        at io.realm.BaseRealm.<init>(BaseRealm.java:136)\n        at io.realm.BaseRealm.<init>(BaseRealm.java:105)\n        at io.realm.Realm.<init>(Realm.java:164)\n        at io.realm.Realm.createInstance(Realm.java:435)\n        at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:342)\n        at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:282)\n        at io.realm.Realm.getInstance(Realm.java:364)\n```\n\nSome interesting observations about the above trace -\n\n1. if I try again with a debugger attached, a `Realm` is always silently returned with no complaints and no crash. If I try again without a debugger, I get the same crash as above.\n\n2. if I log instead, I can see that one of the `Realm.getInstance` calls silently succeeds before one of the next ones fail with this exception.\n\n#### Code Sample\n\n```java\nclass RealmUtils {\n  public static Realm getDatabase(Context context) {\n    return Realm.getInstance(getDatabaseConfiguration());\n  }\n\n  private static RealmConfiguration getDatabaseConfiguration() {\n    return new RealmConfiguration.Builder()\n        .assetFile(REALM_DB_PATH)\n        .name(REALM_DB_NAME)\n        .schemaVersion(2)\n        .readOnly()\n        .modules(new Module())\n        .build();\n  }\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s): 5.3.0\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 3.2 Canary 18\n\nWhich Android version and device: Emulator, Nexus 5x, API 27, Google Play Image","comments":["@ahmedre thanks for the detailed report \r\n\r\n1- Currently bumping the `schemaVersion` only without having actual schema changes will not trigger a migration.\r\n2- Combining `schemaVersion` with `readOnly` doesn't really make sense \r\n\r\nI think what you're looking for could be handled by an overload of `asset` which should indicate whether to delete the existing Realm then copy the new one, something like: \r\n```\r\nconfig.assetFile(\"file\", new ReloadRealmFromAssetsCallback() {\r\n  public boolean reloadRealm(Realm currentRealm) {\r\n    return currentRealm.getVersion() <= 2;\r\n  }\r\n}\r\n```\r\n\r\nIn the meantime, you can work around this issue by creating a new Realm file with a different version (to be shipped inside the assets) then use `getVersion` to detect the new Realm in order to manually delete then open the Realm again:\r\n```Java\r\nRealmConfiguration conf = new RealmConfiguration.Builder()\r\n                    .assetFile(\"new_version.realm\")\r\n                    .name(\"my_realm\")\r\n                    .modules(new Module()).build();\r\n\r\n            RealmConfiguration existingConf = new RealmConfiguration.Builder()\r\n                    .name(\"my_realm\")\r\n                    .modules(new Module()).build();\r\n\r\n            Realm existingRealm = Realm.getInstance(existingConf);\r\n            if (existingRealm.getVersion() < 2) {\r\n                \/\/ new Realm was not installed yet \r\n                existingRealm.close();\r\n                Realm.deleteRealm(existingConf);\r\n            }\r\n            \r\n            \/\/ now open new version of Realm    \r\n            Realm.getInstance(conf);\r\n```","Thanks Nabil!\r\n\r\nPlease consider the `assetFile`\/`ReloadRealmFromAssetsCallback` example a feature request then :) In the meanwhile, I'll work around it.","Actually. Version checking should happen with DynamicRealm API. then there is no schema verification. "],"labels":["T-Enhancement","O-Community"]},{"title":"Open realm files as readonly","body":"#### Goal\nI'm using realm databases as separate files downloaded from server and use their MD5 hash to check if file needs to be updated or downloaded again. \nBut when realm upgrades, internal format will change and this can cause problem.\nI didn't upgraded realm from version 2 until now because of this. I saw there's a readonly() future so I upgraded my realm and I noticed that it's only for assets!\n1- In documents I never saw anything about this error :\nOnly Realms provided using 'assetFile(path)' can be marked read-only. No such Realm was provided.\n\nThis is documents for readonly : \nSetting this will cause the Realm to become read only and all write transactions made against this Realm will fail with an IllegalStateException.\nThis in particular mean that initialData(Realm.Transaction) will not work in combination with a read only Realm and setting this will result in a IllegalStateException being thrown.\nMarking a Realm as read only only applies to the Realm in this process. Other processes can still write to the Realm.\n\n#### Expected Results\n\nRealmConfiguration.Builder()\n.name(name)\n.encryptionKey(k)\n.modules(new MyModules())\n.readOnly()\n.build());\n\nThis should work for every realm file! not just for assets","comments":["Yes, you are right. The restriction on `readOnly` is probably a bit too much. I believe we added it to prevent people from shooting themselves in the foot by marking empty Realms read-only, but as you demonstrated, there are use cases where marking \"normal\" files read-only. We should fix this.","We need this feature too for our offline database.","Any news on this issue? We also would like to have the option of downloadable read-only Realms and not only as asset files..."],"labels":["T-Enhancement","First-Good-Issue","O-Community"]},{"title":"Fix tools\/unroll_stacktrace script","body":"Running the following \n\n```\n.\/tools\/unroll_stacktrace.sh objectServer 5.2.0 arm64-v8a .\/dump.txt\nUnrolling \/Users\/Nabil\/Dev\/realm\/master\/realm-java\/.\/dump.txt from Realm Java 5.2.0 (objectServer) using ABI arm64-v8a\n```\n\nwill fail with \n\n```\n.\/tools\/unroll_stacktrace.sh: line 57: REALM_CORE_DOWNLOAD_DIR: unbound variable\n```\n\nI needed to disable the `#set -euo pipefail` to be able to run the script \n\nAlso the script by default needs to be `chmod a+x`\n\nAlso unrolling the following stack will throw an error \n\n```\n.\/tools\/unroll_stacktrace.sh objectServer 5.2.0 arm64-v8a .\/dump.txt\nUnrolling \/Users\/Nabil\/Dev\/realm\/master\/realm-java\/.\/dump.txt from Realm Java 5.2.0 (objectServer) using ABI arm64-v8a\n********** Crash dump: **********\npid: 0, tid: 0 >>> com.app <<<\nStack frame #00  pc 0000000000123ecc  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so: Routine ndk-stack: \/tmp\/realm-java-jni-libs-unstripped-5.2.0\/objectServer\/arm64-v8a\/librealm-jni.so: File format not recognized\n```\n\n```\n*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\npid: 0, tid: 0 >>> com.app <<<\nbacktrace:\n #00  pc 0000000000123ecc  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #01  pc 000000000012a0b4  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #02  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #03  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #04  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #05  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #06  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #07  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #08  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #09  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #10  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #11  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #12  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #13  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #14  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #15  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #16  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #17  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #18  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #19  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #20  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #21  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #22  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #23  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #24  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #25  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #26  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #27  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #28  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #29  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #30  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #31  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #32  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #33  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #34  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #35  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #36  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #37  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #38  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #39  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #40  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #41  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #42  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #43  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #44  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #45  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #46  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #47  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #48  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #49  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #50  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #51  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #52  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #53  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #54  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #55  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #56  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #57  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #58  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #59  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #60  pc 000000000012a084  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #61  pc 000000000012a0c8  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #62  pc 000000000012a118  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n #63  pc 0000000000071ed0  \/data\/app\/com.app-1\/lib\/arm64\/librealm-jni.so\n```\n\ncc @cmelchior\n\n","comments":[],"labels":["T-Bug","T-Internal"]},{"title":"ProgressListener updated very infrequently","body":"\n#### Goal\n\nI want to monitor the progress of the first time a fully synchornized realm is downloaded from the server. My realm file size is about 2MB and downloading it takes about 12 seconds on my old Google Nexus 5X. \n\n#### Expected Results\nDownload progress should be updated frequently so I can show the progress to the user.\n\n#### Actual Results\nDownload progress is zero the first 10 seconds, then a progress update a couple of times the last few seconds\n#### Code Sample\n\n```java\nval realm = Realm.getDefaultInstance()\nsyncUser.allSessions().forEach {\n     it.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, progressListener)\n}\ndoAsync {\n    try {\n        syncUser.allSessions().forEach {\n            it.downloadAllServerChanges()\n        }\n    } finally {\n        uiThread {\n            realm.close()\n        }\n    }\n}\n\n```\n\n#### Version of Realm and tooling\nRealm version(s): 5.2.0\n\nRealm sync feature enabled: yes\n\nAndroid Studio version: 3.1.2\n\nWhich Android version and device: Nexus 5x, Android 8.0","comments":["Hi @sipersso \r\nThank you for reporting this. Can you try to enable debug logging when this is happening and post the results. You can do so by setting \r\n\r\n```\r\nRealm.init(context);\r\nRealmLog.setLevel(LogLevel.DEBUG);\r\n```\r\n","```\r\n06-08 13:27:21.503 9623-9623\/com.myapp D\/RealmFunctionsKt: Realm.getRealmInstance() InitViewModel 1\r\n06-08 13:27:21.672 9623-10200\/com.myapp D\/REALM_JAVA: AuthenticateResponse. Identity KoDw8u4EhCOo7Whby7DQLJcytyi1; Path \/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default\r\n06-08 13:27:21.673 9623-10200\/com.myapp D\/REALM_JAVA: Session[\/data\/data\/com.myapp\/files\/realm-object-server\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default]: Access token acquired\r\n06-08 13:27:21.676 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: WebSocket::Websocket()\r\n    Connection[1]: Session[1]: Binding '\/data\/data\/com.myapp\/files\/realm-object-server\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default' to '\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default'\r\n    Connection[1]: Session[1]: Activating\r\n    Opening Realm file: \/data\/data\/com.myapp\/files\/realm-object-server\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default\r\n06-08 13:27:21.676 9623-10200\/com.myapp D\/REALM_JAVA: Scheduling an access_token refresh in 427324 milliseconds\r\n06-08 13:27:21.677 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Progress handler called, downloaded = 0, downloadable = 0, uploaded = 0, uploadable = 730, progress version = 0, snapshot version = 2\r\n06-08 13:27:21.678 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Progress handler called, downloaded = 0, downloadable = 0, uploaded = 0, uploadable = 730, progress version = 0, snapshot version = 2\r\n    Connection[1]: Resolving 'myapp-alpha-2.us1a.cloud.realm.io:443'\r\n06-08 13:27:21.684 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Connecting to endpoint 'x' (1\/3)\r\n06-08 13:27:21.875 9623-10201\/com.myapp I\/REALM_SYNC: Connection[1]: Connected to endpoint 'x' (from 'y')\r\n06-08 13:27:22.070 9623-10201\/com.myapp D\/REALM_JNI: Callback to Java requesting certificate validation for host myapp-alpha-2.us1a.cloud.realm.io\r\n06-08 13:27:22.076 9623-10201\/com.myapp I\/chatty: uid=10225(com.myapp) Thread-12 identical 2 lines\r\n06-08 13:27:22.078 9623-10201\/com.myapp D\/REALM_JNI: Callback to Java requesting certificate validation for host myapp-alpha-2.us1a.cloud.realm.io\r\n06-08 13:27:22.449 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: WebSocket::initiate_client_handshake()\r\n06-08 13:27:22.649 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: WebSocket::handle_http_response_received()\r\n    Connection[1]: Will emit a ping in 600000 milliseconds\r\n    Connection[1]: Session[1]: Sending: BIND(path='\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default', signed_user_token_size=633, need_client_file_ident=1)\r\n06-08 13:27:22.845 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Received: IDENT(client_file_ident=45, client_file_ident_salt=1387998351971089699)\r\n06-08 13:27:22.869 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Sending: IDENT(client_file_ident=45, client_file_ident_salt=1387998351971089699, scan_server_version=0, scan_client_version=0, latest_server_version=0, latest_server_version_salt=0)\r\n06-08 13:27:22.870 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Fetching: UPLOAD changeset(client_version=2, server_version=0, changeset_size=730, origin_timestamp=108386841488, origin_file_ident=0)\r\n06-08 13:27:22.871 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Log compaction: original size = 730, compacted size = 730\r\n    Sending: UPLOAD(session_ident=1, num_changesets=1, is_body_compressed=0, body_size=753, compressed_body_size=0)\r\n06-08 13:27:22.872 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Sending: MARK(request_ident=1)\r\n06-08 13:27:26.427 9623-9653\/com.myapp D\/FA: Logging event (FE): session_start(_s), Bundle[{firebase_event_origin(_o)=auto, firebase_screen_class(_sc)=InitActivity, firebase_screen_id(_si)=8852641464706457254}]\r\n06-08 13:27:26.510 9623-9653\/com.myapp D\/FA: Connected to remote service\r\n06-08 13:27:34.761 9623-10201\/com.myapp D\/REALM_SYNC: Download message compression: is_body_compressed = 1, compressed_body_size=4242266, uncompressed_body_size=9098120\r\n06-08 13:27:34.762 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Received: DOWNLOAD(download_server_version=22, download_client_version=0, latest_server_version=65, latest_server_version_salt=6946208583356865015, upload_client_version=0, upload_server_version=0, downloadable_bytes=33333627, num_changesets=22, ...)\r\n06-08 13:27:38.183 9623-9623\/com.myapp D\/myappApplication: InitActivity\r\n06-08 13:27:38.210 9623-9653\/com.myapp D\/FA: Logging event (FE): user_engagement(_e), Bundle[{firebase_event_origin(_o)=auto, engagement_time_msec(_et)=19735, firebase_screen_class(_sc)=InitActivity, firebase_screen_id(_si)=8852641464706457254}]\r\n06-08 13:27:38.362 9623-9653\/com.myapp D\/FA: Connected to remote service\r\n06-08 13:27:44.398 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: 22 remote changesets integrated, producing client version 4\r\n    Connection[1]: Session[1]: Progress handler called, downloaded = 22210955, downloadable = 33333627, uploaded = 0, uploadable = 730, progress version = 1, snapshot version = 4\r\n06-08 13:27:44.626 9623-10201\/com.myapp D\/REALM_SYNC: Download message compression: is_body_compressed = 1, compressed_body_size=2497830, uncompressed_body_size=6736663\r\n    Connection[1]: Session[1]: Received: DOWNLOAD(download_server_version=65, download_client_version=0, latest_server_version=65, latest_server_version_salt=6946208583356865015, upload_client_version=0, upload_server_version=0, downloadable_bytes=33333627, num_changesets=43, ...)\r\n06-08 13:27:48.359 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: 43 remote changesets integrated, producing client version 5\r\n06-08 13:27:48.360 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Progress handler called, downloaded = 33333627, downloadable = 33333627, uploaded = 0, uploadable = 730, progress version = 1, snapshot version = 5\r\n    Download message compression: is_body_compressed = 0, compressed_body_size=0, uncompressed_body_size=0\r\n    Connection[1]: Session[1]: Received: DOWNLOAD(download_server_version=66, download_client_version=2, latest_server_version=66, latest_server_version_salt=6946208583356865015, upload_client_version=2, upload_server_version=0, downloadable_bytes=33333627, num_changesets=0, ...)\r\n06-08 13:27:48.366 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Progress handler called, downloaded = 33333627, downloadable = 33333627, uploaded = 730, uploadable = 730, progress version = 1, snapshot version = 6\r\n    Connection[1]: Session[1]: Received: MARK(request_ident=1)\r\n06-08 13:27:48.373 9623-10193\/com.myapp D\/RealmFunctionsKt: Realm.getRealmInstance() InitViewModel 2\r\n06-08 13:27:48.420 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Initiating deactivation\r\n    Connection[1]: Session[1]: Sending: UNBIND\r\n06-08 13:27:48.421 9623-10201\/com.myapp D\/REALM_SYNC: Closing Realm file: \/data\/data\/com.myapp\/files\/realm-object-server\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default\r\n06-08 13:27:48.423 9623-9623\/com.myapp D\/REALM_JAVA: last session dropped, remove network listener\r\n06-08 13:27:48.431 9623-10202\/com.myapp D\/REALM_JAVA: first session created add network listener\r\n06-08 13:27:48.432 9623-10202\/com.myapp D\/REALM_JAVA: Scheduling an access_token refresh in 400568 milliseconds\r\n06-08 13:27:48.435 9623-10202\/com.myapp D\/REALM_JNI: Callback to Java requesting token for path\r\n06-08 13:27:48.437 9623-10201\/com.myapp D\/REALM_SYNC: Connection[2]: WebSocket::Websocket()\r\n    Connection[2]: Session[2]: Binding '\/data\/data\/com.myapp\/files\/realm-object-server\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default' to '\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default'\r\n    Connection[2]: Session[2]: Activating\r\n    Opening Realm file: \/data\/data\/com.myapp\/files\/realm-object-server\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/KoDw8u4EhCOo7Whby7DQLJcytyi1\/default\r\n06-08 13:27:48.438 9623-10201\/com.myapp D\/REALM_SYNC: Connection[2]: Session[2]: Progress handler called, downloaded = 33333627, downloadable = 33333627, uploaded = 730, uploadable = 730, progress version = 0, snapshot version = 6\r\n    Connection[2]: Resolving 'myapp-alpha-2.us1a.cloud.realm.io:443'\r\n```","Not sure if this helps. If there is anything else I can do let me know. Seems like it takes a bit longer than I thought. Judging by the logs, the first progress notification is after 20 seconds.","Yes, it appears that way. The interesting parts are here:\r\n\r\n```\r\n06-08 13:27:21.677 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Progress handler called, downloaded = 0, downloadable = 0, uploaded = 0, uploadable = 730, progress version = 0, snapshot version = 2\r\n06-08 13:27:21.678 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: Progress handler called, downloaded = 0, downloadable = 0, uploaded = 0, uploadable = 730, progress version = 0, snapshot version = 2\r\n06-08 13:27:44.398 9623-10201\/com.myapp D\/REALM_SYNC: Connection[1]: Session[1]: 22 remote changesets integrated, producing client version 4\r\n    Connection[1]: Session[1]: Progress handler called, downloaded = 22210955, downloadable = 33333627, uploaded = 0, uploadable = 730, progress version = 1, snapshot version = 4\r\n```\r\n\r\nI'll run this past our server team to hear if they have any explanation on why this happens.\r\n\r\n","@sipersso @cmelchior \r\nWhat happens is that the server bundles many changesets together, in this case 22 changesets.\r\nYou only get progress for the first 22 changesets at once. They occupy 4242266 bytes after compression.\r\nThere is a server config parameter, called \"maxDownloadSize\" which defaults to 16MB. It determines how much data is lumped together. By lowering it, you will get progress sooner. By lowering it, our log compaction is not quite as good however. I would try to lower it and experiment with it.\r\n\r\nLater, we might change the protocol to avoid this issue, but right now modifying maxDonwloadSize seems to be the best option.","@morten-krogh I am using Realm Cloud. Is this parameter available there? What effect does it have if your log compaction is not as good? More data usage? \r\n\r\nWaiting 20 seconds for getting the first progress notification in a mobile app is not really acceptable. If it takes that long for the progressbar to start moving, users will assume that the app has stopped responding and close it. ","@sipersso \r\n\r\nThe effect of worse log compaction could be longer download in total. However, in your case our trade off does not seem good.\r\n\r\nI agree. We will have to come up with a solution.","An intermediate solution might also be to switch to an indeterminate progress loader. It isn't ideal I know, but at least you don't get the impression that things are stuck","@morten-krogh Just to clarify. I add the progress notification only when the realm is synchronized for the first time, i.e when a user switches between devices, so this is a not a common operation. On the other hand, it is probably the only time in the app that I need the progressnotification ;)\r\n\r\n@cmelchior Agreed that it is not ideal, but I will skip the progress notifications for now and use an indeterminate progress loader couple with a message that the operation might take quite som time. \r\n\r\n","Any updates @morten-krogh? I have found that the initial load.. i.e. first time logging on to a new device can be very very slow. I have a 3MB realm and it takes 13 seconds until I have fully downloaded the results of the first query. And this is a simple query for my root user object by id. So either I have to do something about my initial query, or I really need the progress updates.","As per the comment by @cmelchior in https:\/\/github.com\/realm\/realm-java\/issues\/5931. I understand that queries are lazy in iOS, but not in Android. In combination with the issues with progress listeners, this can be quite problematic. \r\n\r\nI have a root user object, which contains all data from that particular user. When the app is started I check if this user object exists locally. If so, I continue and everything is fine. However, when switching to a new device, the user object will not exist locally, so I query for it and wait for the result. On iOS, this is fine, but on Android it can take 10+ seconds and I get no progress notifications. \r\n\r\nThe reason for it taking so long is that Realm is downloading, not only the object I queried for, but also all its children and all objects they contain. I have noticed that the time it takes for the query to complete is directly proportional to the amount of data of the user, even if the bulk of the data is several levels down. \r\n\r\nIn my case, the user data can range from just a couple of kb to around 5MB. The 5MB database query will take so long to complete that the user will think it is broken and probably abort. ","The queries download all children recursively. If you just need a little bit of meta data, you would need to restructure your schema such that the user object does not have any children. You could use ids instead. \r\n\r\nRegarding progress notifications, you will sometimes get all the downloaded data from a query in one chunk, and our current progress notification system does not handle partial updates for that. It should preferably do that in the future. \r\n","@morten-krogh unfortunately I am not able to restructure the query to use ids. This is because Realm for Java does not allow for adding Permission classes to local schemas. \r\n\r\nWhat I am doing is to migrate a local app to a synced app. To do this I have to be able to use the same objects locally and synced. I did achieve this by adding a root user and add the permissions there. Permissions cannot be added to the objects I want to query since they need to be accessible on both the local and synced realm. I have written about this in the comments here [https:\/\/forums.realm.io\/t\/synced-fine-grained-permissions-and-local-realm-what-is-the-best-practice-for-models\/1492\/9](https:\/\/forums.realm.io\/t\/synced-fine-grained-permissions-and-local-realm-what-is-the-best-practice-for-models\/1492\/9) and here [https:\/\/forums.realm.io\/t\/unit-testing-and-synced-realms\/1762\/3](https:\/\/forums.realm.io\/t\/unit-testing-and-synced-realms\/1762\/3)\r\n\r\nOf course I could add a third object to detect if the user has been migrated to a synced user or not instead of querying for the root user object which contains all the data. However, I would have to do the same query later anyway and I would get the same issue again. \r\n\r\nYes, I do see that I get the data in a big chunk. But this also makes the progressnotification pretty useless in my case. I guess I will have to fake them somehow and rotate the loading messages to give the impression of progress, but it won't be a great user experience. Especially since the migration process from local to sync is very critical."],"labels":["T-Enhancement","Blocked","O-Community"]},{"title":"Use realm along Parcelize from kotlin experiments.","body":"Possibility to use realm with Parcelize annotation from kotlin experiments.\nhttps:\/\/github.com\/Kotlin\/KEEP\/blob\/master\/proposals\/extensions\/android-parcelable.md","comments":["It should be possible: https:\/\/stackoverflow.com\/questions\/49455684\/realmlist-with-parcelize-annotation","Ok, this looks a lot of work to be Done. It was easier to write parcelable implementation. Am asking for out of box solution. "],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"Cancel ongoing async query","body":"#### Goal\nThe ability to cancel an ongoing query.\n\n#### Expected Results\nAdding a '.cancelQuery()' function to the RealmQuery class, that would cancel the underlying query and release the database resources.\n\nQ1 created\nQ1 starts (async)\nQ2 created\nQ1 removeChangeListener\nQ1 cancelQuery\nQ2 starts (async)\nQ3 created\nQ2 removeChangeListener\nQ2 cancelQuery\nQ3 starts (async)\nQ3 finished\n\nPerhaps the 'removeChangeListener' is not needed if cancelQuery is implemented, it could simply ignore the changeListener,\n\n#### Actual Results\nThe queries that are created after the first query aren't started until the first query is finished, which makes it extremely slow when starting many queries in a row.\n\nCurrently (using .findAllAsync()):\n\nQ1 created\nQ1 starts (async)\nQ2 created\nQ1 removeChangeListener\nQ3 created\nQ2 removeChangeListener\nQ1 finished\nQ2 starts (async)\nQ2  #finished\nQ3 starts (async)\nQ3 finished\n\n#### Steps & Code to Reproduce\nI have a search field that queries a table of items. I currently have roughly 6000 items in this table.\n\nWhenever the user types in 1 character, i start a query (for live-search).\nIf the user types fast, i start more and more queries, possibly before the first query has finished. Whenever a new query is started, i call '.removeAllChangeListeners()' from the RealmResults<Item> that i got from the last query i started.\nThis works as expected, and i don't get any callbacks for these items, but it does not stop the underlying query, it simply ignores the result.\nThis causes the performance issues.\n\n#### Version of Realm and tooling\nRealm version(s): 5.1.0\n\nRealm sync feature enabled: No\n\nAndroid Studio version: 3.1.2 Stable\n\nWhich Android version and device: Android 4.4.2, a Samsung Galaxy S2. This is simply the slowest device i have available that have a high enough minimum API for my application. The issue is much easier to notice and test on a really slow device.\n\nI found a similar post here regarding the same feature\/issue, but it was closed due to inactivity from the user: https:\/\/github.com\/realm\/realm-java\/issues\/5029","comments":["consider debouncing input by about 300ms","Thats more of a bandaid than a proper fix though. I'm fairly certain that my case is not the most extreme, as i still have a rather \"small\" data set compared to some other people.\r\n\r\nIt could potentially work for some devices, but not all.\r\n\r\nOn a Samsung Galaxy S2, a query takes about 2 seconds. If the user takes more than 300 ms to type each character, it would still start multiple queries that would be quite slow.\r\nBut on a newer device, such as my own OnePlus 5, the queries takes 100-150 ms, and then this entire thing is not needed.","Hi @Moonbloom \r\nThanks for the detailed description. Unfortunately, there are currently no great solutions to fix this.\r\n\r\nThere are multiple reasons this is becoming a problem:\r\n\r\n1) The native query is not cancelable, just like SQLite queries. So once a query is running the thread running it is blocked.\r\n\r\n2) We only have one background worker thread for queries as having too many open background Realms is also draining system resources (most noticeably file descriptors).\r\n\r\nOne solution from our end could be to have threadpool with worker threads that were killed rather quickly and then have a reasonable cap on how many background threads could be created, but that would just move the needle for when it became a problem, e.g. if you canceled 5 queries quickly you might still deplete the thread pool.\r\n\r\nAnother option would be for you to create your own threadpool system where you controlled how many cancelled queries would be allowed, but because we currently don't offer any great way to move RealmResults across threads, this would probably be quite annoying to implement as you would have to copy all results into memory (https:\/\/github.com\/realm\/realm-java\/issues\/4059 and #1208 would both solve this). No matter what, implementing something like this wouldn't be trivial.\r\n\r\nRight now I would seriously consider debouncing as this is a normal strategy to throttle access to a shared limited or expensive resource.\r\n\r\n\r\n "],"labels":["T-Enhancement","O-Community"]},{"title":"Document what overriding field names mean","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\n#### Goal\nFilter table by field names specified with **RealmField**.\n\n#### Expected Results\nNo crashes.\n\n#### Actual Results\nApp crashes:\n\n```\nCaused by: java.lang.IllegalArgumentException: Invalid query: field '_id' not found in class 'cards'.\n   at io.realm.internal.fields.CachedFieldDescriptor.compileFieldDescription(CachedFieldDescriptor.java:80)\n   at io.realm.internal.fields.FieldDescriptor.compileIfNecessary(FieldDescriptor.java:292)\n   at io.realm.internal.fields.FieldDescriptor.getColumnIndices(FieldDescriptor.java:185)\n   at io.realm.RealmQuery.equalToWithoutThreadValidation(RealmQuery.java:309)\n   at io.realm.RealmQuery.in(RealmQuery.java:551)\n   at io.realm.RealmQuery.in(RealmQuery.java:531)\n   ...\n```\n\n#### Steps & Code to Reproduce\n1. Create a class with a custom table name and a custom field name.\n1. Try to query for items using field name passed to **RealmField**.\n\n#### Code Sample\nConstants replaced with values.\n\n```java\n@RealmClass(name = \"cards\")\npublic class CardModel implements RealmModel {\n\n    @PrimaryKey\n    @Required\n    @RealmField(name = \"_id\")\n    private String mKey;\n\n    \/\/ getters and setters\n}\n\n...\n\ntry (final Realm realm = mRealmProvider.get()) {\n\tfinal RealmResults<CardModel> all1 = realm.where(CardModel.class)\n\t\t\t.in(\"mKey\", map(keys)) \/\/ will NOT crash here\n\t\t\t.findAll();\n\tfinal RealmResults<CardModel> all2 = realm.where(CardModel.class)\n\t\t\t.in(\"_id\", map(keys)) \/\/ will crash here\n\t\t\t.findAll();\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s): 5.0.0\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 3.0.1\n\nWhich Android version and device: API 24, Emulator\n\n","comments":["[`ColumnInfo`](https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/java\/io\/realm\/internal\/fields\/CachedFieldDescriptor.java#L77) has both custom field name and Java field name:\r\n\r\n![1](https:\/\/user-images.githubusercontent.com\/3605857\/37727826-71c81e86-2d41-11e8-95a5-055958a0592d.PNG)\r\n","I think typed realm uses field names for the queries, while dynamic realm uses internal names. ","@Iojjj This is working as intended. Queries on typed Realms are done using the name defined in Java, not the name in `@RealmField`, which is how it is stored on disk. This should also be described in https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm-annotations\/src\/main\/java\/io\/realm\/annotations\/RealmNamingPolicy.java#L51 \r\n\r\nLike @Zhuinden correctly says, the internal name is only used in the dynamic API which has no knowledge about the Java model class.\r\n\r\nWe, unfortunately, haven't written that up for the website yet.","Hi @Zhuinden @cmelchior \r\n\r\nthanks for you replies. So this is an expected behavior. \r\n\r\nAre you planning to allow Realm instances to use internal names instead of Java ones? Right now if I try to refactor field names (change `mKey` to `mId` IDE will not find any usages of string literal `mKey`). Because `ColumnInfo` has both mappings of internal and Java names it can do conversion between internal and Java names in the way it can be used by `Query`.\r\n\r\nFor example:\r\n```java\r\nclass TestModel implements RealmModel {\r\n    @RealmField(name = \"id\")\r\n    private long mId;\r\n    @RealmField(name = \"not_id\")\r\n    private String mNotId;\r\n}\r\n\r\n...\r\n\r\n\/\/ somewhere in ColumnInfo\r\n\/\/ check if passed name is an internal name. If 'yes' return column info\r\n\/\/ check if passed name is a Java field name. If 'yes' return column info\r\n\/\/ thrown an exception otherwise\r\n\r\n...\r\n\r\nfinal TestModel r1 = mRealm.where(TestModel.class).equalsTo(\"id\", 1).findFirst();\r\nfinal TestModel r2 = mRealm.where(TestModel.class).equalsTo(\"mId\", 1).findFirst();\r\n```\r\nso that `r1` and `r2` will represent the same object. From my point of view this is a valid way of accessing table row values with typed `Realm` instance.\r\n\r\nWhat do you think about this approach? \r\n","No, there is no such plans as that wasn't a use case we considered when implementing this. Also, I'm not sure what you are trying to accomplish? If you want to use the internal name for queries, why use the internal name at all? Why not just call your fields `not_id` in Java?\r\n\r\nWe cannot allow using both internal and Java queries because there might be conflicts, e.g:\r\n\r\n```\r\npublic class Foo extends RealmObject {\r\n  @RealmField(name = \"foo\")\r\n  public String bar;\r\n\r\n  @RealmField(name = \"bar\") \r\n  public boolean foo;\r\n}\r\n```\r\n\r\nYou can use use the `DynamicRealm` API to use the internal name, but that will make accessing properties much more annoying, e.g. `obj.getLong(\"id\")` vs. `obj.getId()`","If it is because you are in the middle of a refactoring searching for the string `\"mKey\"` will do the trick (but of course you need to check it isn't mKey from another class).\r\n\r\nThis is also why we in a lot of internal tests have the best practice of static fields in the model class:\r\n\r\n```\r\npublic class Person extends RealmObject {\r\n  public static final FIELD_NAME = \"name\";\r\n  public String name;\r\n}\r\n\r\nrealm.where(Person.class).equalTo(Person.FIELD_NAME, \"Jane\").findAll();\r\n```\r\n","> Why not just call your fields not_id in Java?\r\n\r\nOur naming convention allows only camel case with Hungarian notation.\r\n\r\n> We cannot allow using both internal and Java queries because there might be conflicts, e.g:\r\n\r\nYes, I though about it as well. But annotation processor can handle this:\r\n1. Find all fields in class.\r\n2. Filter all fields without `RealmField` annotation or with an empty `name` in annotation. Use Java names as keys.\r\n3. Check all other fields for any conflicts. If conflict detected, raise an exception with explanations.\r\n\r\nIn this case you'll have a single map with field mappings. \r\n\r\n> I'm not sure what you are trying to accomplish\r\n\r\nI have an implementation of generic storage class that has basic functionality for CRUD operations (get, put, delete, simple filter):\r\n\r\n```java\r\npublic abstract class Storage<T extends RealmModel> {\r\n    private final Class<T> mTClass;\r\n\r\n    public void deleteByIds(final List<String> ids) {\r\n        \/\/ assume that deletion is performed in transaction\r\n        mRealm.where(mTClass).in(ModelContract.ID, ids).deleteAllFromRealm();\r\n    }\r\n}\r\n```\r\n\r\nAll my models have an ID field (`mId` in Java, \"id\" as internal Realm field name). This is my model's Contract. In case if at some point of time I decide to rename `mId` field, I don't need to rename Contract name and fix all of my queries. This is similar to what you proposed with `FIELD_NAME`. But:\r\n1. I can't define a `BaseModel` class where I can define a single entry point for an ID field and its internal name constant. You're not allowing models classes to extend any other classes even if base classes extend `RealmObject` or implement `RealmModel`.\r\n2. That's why I need to track all Java and internal names and keep them synced. For example, if I rename an ID field in a `ClassA`, I need also rename them in all of my models classes so that my generic storage continue working without any issues.\r\n\r\n","Yes, I can see the problem. Honestly, I think a better solution to your problem would be if we started allowing non-polymorphic inheritance, which would allow for a base class with shared fields. So far we have not done that because we feared that not having polymorphism would really trip people up but both our Cocoa binding and ObjectBox do this, so we should probably revisit that decision.\r\n\r\nThe reason I'm hesitant about \"just\" allowing queries on both internal and Java names is that it muddles the layers between Java defined names and internal names and we need to enforce that you cannot use an internal name that is already being used in the Java model class.\r\n\r\nI'll need to think a little about this.\r\n\r\n","> If it is because you are in the middle of a refactoring searching for the string `\"mKey\"` will do the trick (but of course you need to check it isn't mKey from another class).\r\n> \r\n> This is also why we in a lot of internal tests have the best practice of static fields in the model class:\r\n> \r\n> ```\r\n> public class Person extends RealmObject {\r\n>   public static final FIELD_NAME = \"name\";\r\n>   public String name;\r\n> }\r\n> \r\n> realm.where(Person.class).equalTo(Person.FIELD_NAME, \"Jane\").findAll();\r\n> ```\r\n\r\nThis is exactly the reason why it should be used in typed queries as well, because when you (accidentally) rename the java field `name` to e.g. `firstName`, you'll still have the proper `FIELD_NAME` for realm queries.\r\n\r\nIf you have it this way, then there's no IDE help and you may easily end up having `FIELD_NAME` different than java `name`.\r\n\r\n---\r\n\r\nAlso another use case for using it in queries is, that then you can have (in kotlin) something like this:\r\n```kotlin\r\nconst val TYPE_FIELD = \"type\"\r\n\r\n@RealmField(TYPE_FIELD)\r\nprivate var _type: String\r\n\r\nvar type: TypeEnum\r\n  get() = _type.toString()\r\n  set(value) {\r\n     _type = TypeEnum.valueOf(value)\r\n  }\r\n```\r\n\r\nAnd you can still use:\r\n```kotlin\r\nrealm\r\n  .where<MyClass>()\r\n  .equals(TYPE_FIELD, TypeEnum.TYPE_A)\r\n  .findAll() \r\n```\r\n\r\nWhich then provides more type-safety, because from code you may access whatever name you added, but in queries you use fields you defined in annotation."],"labels":["T-Doc","O-Community"]},{"title":"fix wait_for_download behaviour with permission schema","body":"After the fix in [Sync](https:\/\/github.com\/realm\/realm-sync\/pull\/2051) we should no longer need the hack that registers a subscription and wait for `Update` to be triggered in order to start locking the schema. \r\nIt should only require an `asyncOpen` with a `waitForInitialData` for the Realm to synchronise the permission schema from Sync (the one that includes the correction without duplicates), we can then start modifying it to lock the schema for instance.\r\n\r\nHowever, this was not working in Android as opposed to iOS. Basically we were doing a `waitForDownload` on an empty schema, this causes the local Realm to not upload the local Realm with the default permissions populated from the ObjectStore to Sync which will apply the permissions corrections. (i.e `waitForInitialData` was useless after at this level.)\r\n\r\nThis PR, moved waitForInitialData to be performed on the Realm opened with the full schema.\r\n\r\nSince this is the `next-major` I removed the workarounds we had on different old versions 0.8x & 2.x (PK migration, index etc ..)\r\n","comments":["Isn't it necessary to wait for the initial download with an empty schema in order to support opening synced Realms that the user has read-only access to?","Does that mean that if you follow one of those silly tutorials from the internet that tells you to use 0.82.2 then Realm no longer automatically upgrades the Realm to a compatible format from 5.0.0+?","@Zhuinden Yes, but most of the bugs where only relevant if you attempted to read a Realm file created by Cocoa, so I doubt it will affect anyone.","Ah, that's super-rare at this point, you are right.","This will be revisited once https:\/\/github.com\/realm\/realm-java\/issues\/5812 is implemented to solve the Readonly use case highlighted in https:\/\/github.com\/realm\/realm-java\/pull\/5791#issuecomment-370124297","@nhachicha I imagine this can be closed now?"],"labels":["T-Enhancement"]},{"title":"Realm.deleteAll() is trying to delete RealmObjects across module boundaries","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\nI have a project with multiple modules using Realm. I was hoping that I could just call `deleteAll()` on a `Realm` for one of the modules, but it seems to be trying to delete `RealmObjects` from the other modules, leading to a runtime exception.\n\n#### Expected Results\n> I'd expect `deleteAll()` to only delete the `RealmObject`s within the associated `Realm`.\n\n#### Actual Results\n>  When the code runs, I get the following runtime exception when calling `deleteAll()` on the library `Realm` instance:\n\n```\nCaused by: io.realm.exceptions.RealmException: 'AppModel' doesn't exist in current schema.\n          at io.realm.internal.ColumnIndices.getColumnInfo(ColumnIndices.java:112)\n          at io.realm.RealmSchema.getColumnInfo(RealmSchema.java:250)\n          at io.realm.ImmutableRealmSchema.get(ImmutableRealmSchema.java:41)\n          at io.realm.RealmSchema.getAll(RealmSchema.java:88)\n          at io.realm.BaseRealm.deleteAll(BaseRealm.java:602)\n          at io.realm.Realm.deleteAll(Realm.java:135)\n          at com.johnpetitto.realmbug.MainActivity.lambda$onCreate$1$MainActivity(MainActivity.java:30)\n          at com.johnpetitto.realmbug.MainActivity$$Lambda$1.execute(Unknown Source:0)\n          at io.realm.Realm.executeTransaction(Realm.java:1394)\n          at com.johnpetitto.realmbug.MainActivity.onCreate(MainActivity.java:30)\n          at android.app.Activity.performCreate(Activity.java:6998)\n          at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1230)\n          at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2899)\n```\n\n#### Steps & Code to Reproduce\n> I created a sample project to reproduce this. Basically there is an app module and a library module. The library module has a `@RealmModule` in order to differentiate itself from the app code. Both modules contain a single `RealmObject`. [Here is a repository with the full code.](https:\/\/github.com\/jpetitto\/realm-delete-bug)\n\n#### Code Sample\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    Realm.init(this);\n\n    try (Realm realm = Realm.getDefaultInstance()) {\n        realm.executeTransaction(r -> r.deleteAll());\n    }\n\n    RealmConfiguration libraryConfig = new RealmConfiguration.Builder()\n            .deleteRealmIfMigrationNeeded()\n            .modules(new LibraryModule())\n            .build();\n\n    try (Realm realm = Realm.getInstance(libraryConfig)) {\n        realm.executeTransaction(r -> r.deleteAll());\n    }\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s): 4.3.3\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 3.0\n\nWhich Android version and device: Android 8 on a OnePlus 3T\n\n","comments":["I would think that currently, `Realm.deleteAll()` tries to delete the items for all currently existing classes that are in the schema of the existing Realm file.\r\n\r\nI'm actually more surprised that \r\n\r\n\r\n     try (Realm realm = Realm.getInstance(libraryConfig)) {\r\n\r\nI would have expected this to have a schema mismatch and delete the Realm because migration was needed, after which it SHOULD allow deleting items. So there could be a bug there with schema caching ","Hi @jpetitto Thanks for the nice example project. I'm able to reproduce the behaviour and something indeed looks fishy. I'm looking into it.","I found the issue(s).\r\n\r\n1) You are re-using the underlying file between the two Realm instances. This means that when you open the library instance, the class \"AppModel\" is already in there. Currently, we don't treat extra tables as an error as long as they don't conflict with the schema you define.\r\n\r\n2) The problem arises when you call `schema.getAll()` (which `deleteAll()` does). This method dynamically tries to load the schema information, but it will ask the Java module for information about all classes it finds including \"AppModule\", but that doesn't exist since it isn't part of the module, so the method crashes with the exception you see. This kinda conflicts with 1.\r\n\r\nI suspect this error can also show up in other ways, e.g. through the `Realm.isEmpty()` method which will return the wrong result.\r\n\r\nI'll need to dig a little further, but it looks like we need to fix `schema.findAll()` method to only return the classes in the defined schema for typed Realms and everything when using `DynamicRealm`.\r\n\r\n3 workarounds exist right now:\r\n\r\n```\r\n\/\/ Manually delete objects of a given type. You need to call this for all types in your module.\r\nrealm.delete(LibraryModule.class);\r\n\r\n\/\/ Use different names for files used by app \/ libraries\r\nRealmConfiguration libConfig = new RealmConfiguration.Builder()\r\n  .name(\"library.realm\")\r\n  .build()\r\n\r\nRealmConfiguration appConfig = new RealmConfiguration.Builder()\r\n  .name(\"app.realm\")\r\n  .build()\r\n\r\n\/\/ Use DynamicRealm to delete everything\r\nDynamicRealm dynamicRealm = DynamicRealm.getInstance(config);\r\ndynamicRealm.executeTransaction(r -> r.deleteAll());\r\n```\r\n\r\n\r\n","Oh hey, it'd work with DynamicRealm? that's pretty cool, I didn't think of that.","Thanks for investigating this @cmelchior - I like the solution of using separate files for each module. I'm currently manually deleting each model type, which can be a bit error prone if I forget to update it. Glad I could help surface the issue with `schema.findAll()` and using multiple modules.","Would this issue be related to what I am seeing here? - https:\/\/stackoverflow.com\/questions\/49164180\/need-help-understanding-how-to-remove-realm-models-from-schema?noredirect=1#comment85351896_49164180"],"labels":["T-Bug-Crash","O-Community"]},{"title":"Print annotation processor info as INFO instead of WARN","body":"Anytime I do a clean build I get a warning per model that looks like:\n\n> w: Note: Processing class <model class>\n\nI'm assuming this is related to the incremental builds change (which is great), but this might be better off as a different log level.","comments":["We are using `Diagnostics.NOTE` to emit that information, so I'm actually a bit surprised if that turns out as warnings in the log. I'll take a closer look.","~~My bad, the icon in AS looks like a warning. Still not great that it shows up by default though.~~ Derp, forgot about the `w:` prefix. Carry on.","@cmelchior I wasn't saying this isn't an issue, just that it actually is being logged as a warning, contrary to what I thought earlier. ","Ah sorry, misunderstood","Hi, any updates on this?"],"labels":["T-Enhancement","O-Community"]},{"title":"Support sort across @LinkingObjects","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\n#### Goal\n\n> What do you want to achieve?\n\n``` java\npublic class Person extends RealmObject {\n    private String name;\n\n    private List<Dog> dogs;\n}\n\npublic class Dog extends RealmObject {\n    @LinkingObjects(\"dogs\")\n    private final RealmResults<Person> owners = null;\n}\n```\n\n\n#### Expected Results\n\nThen\n\n    RealmResults<Dog> dogs = realm.where(Dog.class).sort(\"owners.name\").findAll();\n\nshould work\n\n#### Actual Results\n\nit doesn't.\n\n>  * Sort descriptors do not support Linking Objects, either internally or as terminal types.\n\nSee [here](https:\/\/github.com\/realm\/realm-java\/blob\/e77be95f69a98f94d5049423c883ee342f83b24c\/realm\/realm-library\/src\/main\/java\/io\/realm\/internal\/SortDescriptor.java#L40).\n\n#### Version of Realm and tooling\nRealm version(s): 4.3.1\n\nRealm sync feature enabled: no","comments":["Any prediction about this enhancement?","It's been a year and you're the first one around here, so I'd assume about 4 years. ","It's a common feature. I don't know why people haven't asked before :(\r\n","I'm from realmjs, but I also strongly want this feature.","Maybe the issue should be opened in either `realm-object-store` or `realm-core` so that the people who know how to undo this limitation would be aware that this is something people care about."],"labels":["T-Enhancement","O-Community"]},{"title":"Add support for Weak\/Strong links aka. Cascading Deletes","body":"Closes #1104\r\n\r\nThis PR adds support for the Core concepts of Weak\/Strong links or effectively Cascading deletes.\r\n\r\nThe semantics are:\r\n- Default relationship  are \"weak\"\r\n- If A has a strong relationship with B, then B is automatically deleted if A removes it's reference or is deleted itself.\r\n- Multiple A's can hold a strong reference to B. B is only deleted when the final A is.\r\n\r\nIn particular, this solves the most common cascading delete problems we have seen:\r\n\r\n- Nested hierarchies of objects where parents own their children.\r\n- Updating list problem: I.e. how to delete objects no longer part of a list after the list has been modified due to a network request.\r\n\r\nThe public API is a new annotation:\r\n\r\n```\r\n\/\/ Model classes\r\n@StrongRelationship\r\npublic Person person;\r\n\r\n@StrongRelationship\r\npublic RealmList<Dog> dogs;\r\n\r\n\/\/ DynamicRealmObject\r\nboolean DynamicRealmObject.isStrongRelationship(\"linkField\");\r\n\r\n\/\/ RealmObjectSchema\r\nboolean RealmObjectSchema.isStrongRelationship(String fieldName);\r\nRealmObjectSchema.setStrongRelationship(String fieldName, boolean isStrongRelationship);\r\n\r\n```\r\n**API Thoughts:**\r\nCycled through a few ideas before ending on a single `@StrongRelationship`. This mimics the current behavior of e.g `@Required` where we only annotate things if different from default behavior. It restricts the number of \"types\" of relationships we can support, but I don't think that is a problem for the foreseeable future.\r\n\r\nOther things attempted:\r\n```\r\n\/\/ More descriptive, can also set it explicitly to weak\r\n@Relationship(RelationshipType.STRONG) \r\n\r\n\/\/ Reducing the number of annotations by adding it to other annotation proposed in PR about naming\r\n@RealmField(relationship = Relationship.STRONG)\r\n```\r\nShould we add a `@WeakRelationship`? Nice for symmetry ala `@Nullable\/@NonNull` but our own API does not have the precedence. \r\n\r\nTODO:\r\n- [ ] Flesh out annotation processor unit tests\r\n- [ ] Add DynamicRealm API + tests\r\n- [ ] Add Migration API + tests\r\n- [ ] Merge Sync upgrade from `master`","comments":["Oooo this is great \ud83d\ude04  I wonder if this will be in 5.0 along with all the other goodies","Where can we find what release this will be in or what will be in the next release?","\u00af\\\\_(\u30c4)_\/\u00af","Sorry. This was put on hold due as we discovered we needed a few more internal changes before it made sense to release this. I don't have a new timeline unfortunately \ud83d\ude22 ","Oh I see now :(\r\n\r\nhttps:\/\/github.com\/realm\/realm-object-store\/pull\/622#issuecomment-385618340","Realm 5.8.0.  - not found cascade delete.\r\nWhen you implement cascade delete in Realm?\r\nThanks.\r\n","Hi, \r\nwe are using realm for database. We have created Realm classes as per our application database design. In this, There are some models which are having inter related dependancy. But they won't have primary and foreign key relation. \r\n\r\nThey add row as per defined with db structure but when deletion comes we need to manage that for every model. does realm provides cascasde deletion ?\r\n","disclaimer: I am not a member of Realm\r\n\r\n> They add row as per defined with db structure but when deletion comes we need to manage that for every model. \r\n\r\nyep\r\n\r\n> does realm provides cascasde deletion ?\r\n\r\nnope\r\n","According to @roberhofer, this is coming. See https:\/\/github.com\/realm\/realm-java\/issues\/761#issuecomment-499296327.","any progress?","No progress on that yet. We will however release \"Embedded Objects\" very soon. They will automatically \"cascade delete\". That will however not cover all needs."],"labels":["Pipeline-On-Hold"]},{"title":"Fixes #5666","body":"Renamed directory to realm-gradle-plugin to keep it consistent with realm-gradle-plugin.\r\nRemoved Android APT Plugin and some minor refactors.\r\nAdded gen\/ and \/out to gitignore\r\nFixes #5666\r\n","comments":["@cmelchior @nhachicha "],"labels":["O-Community","Pipeline-On-Hold"]},{"title":"Android APT dependency can be removed since latest Android Gradle plugin has now built in support for annotation processors","body":"https:\/\/github.com\/realm\/realm-java\/blob\/39f7232699fe789bfcbe366ae110499a94071897\/gradle-plugin\/build.gradle#L54\n\n    \/*Note: the latest Android Gradle plugin has now built in support for annotation processors and warns and\/or blocks android-apt,\n     see this https:\/\/bitbucket.org\/hvisser\/android-apt\/wiki\/Migration page on how to migrate\n     and this https:\/\/www.littlerobots.nl\/blog\/Whats-next-for-android-apt\/ for more info.\n   *\/","comments":[],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Crash in rxJavaExample","body":"clone Latest Realm Examples and Run rxJavaExample -> ANIMATION activity.\n\njust wait for about 2-3 minutes ,then Crash:\n\n```\nio.realm.examples.rxjava E\/AndroidRuntime: FATAL EXCEPTION: RxComputationThreadPool-1\n                                                                      Process: io.realm.examples.rxjava, PID: 14058\n                                                                      java.lang.IllegalStateException: Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.\n                                                                          at io.realm.BaseRealm.checkIfValid(BaseRealm.java:426)\n                                                                          at io.realm.RealmResults.checkForAddRemoveListener(RealmResults.java:220)\n                                                                          at io.realm.RealmResults.removeChangeListener(RealmResults.java:244)\n                                                                          at io.realm.rx.RealmObservableFactory$6$2.run(RealmObservableFactory.java:171)\n                                                                          at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:30)\n                                                                          at io.reactivex.disposables.RunnableDisposable.onDisposed(RunnableDisposable.java:20)\n                                                                          at io.reactivex.disposables.ReferenceDisposable.dispose(ReferenceDisposable.java:43)\n                                                                          at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)\n                                                                          at io.reactivex.internal.disposables.SequentialDisposable.dispose(SequentialDisposable.java:73)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableCreate$BaseEmitter.cancel(FlowableCreate.java:276)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableFlatMap$MergeSubscriber.cancel(FlowableFlatMap.java:353)\n                                                                          at io.reactivex.internal.subscriptions.SubscriptionHelper.cancel(SubscriptionHelper.java:189)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.cancel(FlowableZip.java:399)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.cancelAll(FlowableZip.java:159)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.drain(FlowableZip.java:188)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableZip$ZipCoordinator.error(FlowableZip.java:151)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableZip$ZipSubscriber.onError(FlowableZip.java:388)\n                                                                          at io.reactivex.internal.operators.flowable.FlowableInterval$IntervalSubscriber.run(FlowableInterval.java:87)\n                                                                          at io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:39)\n                                                                          at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428)\n                                                                          at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278)\n                                                                          at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:273)\n                                                                          at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n                                                                          at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n                                                                          at java.lang.Thread.run(Thread.java:761)\n```\n\n","comments":["I guess\r\n\r\n> `.zipWith(Flowable.interval(1, TimeUnit.SECONDS), (person, tick) -> person)`\r\n\r\nChanges the unsubscribe thread to RxComputation scheduler.\r\n\r\nAdding `subscribeOn(AndroidSchedulers.mainThread()).unsubscribeOn(AndroidSchedulers.mainThread())` after `asFlowable()` would fix it. ","@Zhuinden  thank you.\r\nIt works!\r\nAnd add `onError` handling or `BackpressureStrategy` better!","Ups. Yes, we should fix that."],"labels":["T-Bug-Crash","O-Community"]},{"title":"Release RunTestInLooperThread as a separate artifact","body":"#### Goal\n\n> What do you want to achieve?\n\nVerify RealmResults containing expected data in automated integration tests\n\n#### Expected Results\n\nThis should be easy\n\n#### Actual Results\n\nYou need to copy out a bunch of Realm internal stuff! \ud83d\ude04 \n\nIt'd be nice if Realm either ran in JVM without Android (but that won't happen anytime soon, ofc)\n\n or could provide a plug-and-play \"testing\" helper with which you can verify Realm notification after transactions and query results.\n\n#### Version of Realm and tooling\nRealm version(s): 4.3.1\n\nRealm sync feature enabled: no","comments":["Can you elaborate a bit more on the use case? JVM aside (which would be nice for speed reasons), then I would assume you could just do normal JUnit asserts?","I mean using https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/androidTest\/java\/io\/realm\/RealmResultsTests.java#L61-L66 from an ptional component. ","Ah, like that. Yeah, we have considered doing that actually, but it has rather low priority, unfortunately. \r\n\r\nBut yes, callback testing in unit tests is rather annoying. I'm actually a bit surprised that no-one has created a generalized library for that yet. We cannot be the only one with that requirement."],"labels":["T-Enhancement","O-Community"]},{"title":"Tutorial \/ Step by step guide for how to open Realm in AS and contribute to Realm and run tests","body":"#### Goal\n> What do you want to achieve?\n\nContribute to Realm\n\n#### Expected Results\nBe able to import Realm into AS, modify source code, run tests\n\n#### Actual Results\nI have no idea what I'm doing :smile: \n\n#### Version of Realm and tooling\nRealm version(s): 4.3.1\n\nAndroid Studio version: 3.0.1\n\nOperating System: Windows 7 x64\n\n- - -\nJokes aside, I'm not sure how to open the `realm-java` repository contents in AS so that I can run the tests and etc. I have a wild guess that I need to be on either an Ubuntu 16.04 x64 or a Mac OS, though?\n\nYou guys should get a guide for this, it'd make it easier for people to contribute stuff.\n\n","comments":["I was kinda hoping that all of this information was covered by our README: https:\/\/github.com\/realm\/realm-java\/blob\/master\/README.md, but I do agree that there is a lot of information in there and it isn't exactly a 1-2-3 guide.\r\n\r\nI'm not 100% if the repo actually builds on Windows or not since none of the regular contributors actually use Windows. I should probably find a Windows machine to verify.","Don't think it does because assembleCoreDebug runs Linux specific make script. \r\n  \r\nwhat I miss in the Readme is how you typically open the Realm repository contents in AS. There are a *lot* of subdirectories and I remember having quirks about running examples and running tests and stuff.","Actually, the tricky thing is that \r\n\r\n1.) you need to fork Realm first\r\n\r\n2.) you need to check it out with  `git clone https:\/\/github.com\/[youruser]\/realm-java.git --recursive`"],"labels":["T-Doc","O-Community"]},{"title":"Nested query crashes when String field is null","body":"#### Goal\nNested query should return all ExerciseSets that is of Exercise if this Exercise is performed yet.\n\n#### Expected Results\nAn empty list if this Exercise is not performed yet.\n\n#### Actual Results\nThe app crashes with an error that doesn't make sense to me. setNumber is not queried.\n\nFatal Exception: java.lang.IllegalArgumentException: Illegal Argument: This field(setNumber) is not nullable.\n       at io.realm.internal.TableQuery.nativeEqual(TableQuery.java)\n       at io.realm.internal.TableQuery.equalTo(TableQuery.java:328)\n       at io.realm.RealmQuery.equalToWithoutThreadValidation(RealmQuery.java:302)\n       at io.realm.RealmQuery.equalTo(RealmQuery.java:297)\n       at io.realm.RealmQuery.equalTo(RealmQuery.java:282)\n       at io.strongapp.strong.data.RealmDB.getCommonExerciseSetQuery(RealmDB.java:1155)\n       at io.strongapp.strong.data.RealmDB.getPersonalRecordExerciseSets(RealmDB.java:1046)\n       at io.strongapp.strong.common.exercises.exercise_detail.records.ExerciseRecordsPresenter.<init>(ExerciseRecordsPresenter.java:32)\n       at io.strongapp.strong.common.exercises.exercise_detail.records.ExerciseRecordsFragment.onCreateView(ExerciseRecordsFragment.java:68)\n       at android.support.v4.app.Fragment.performCreateView(Fragment.java:2261)\n       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1419)\n       at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1750)\n       at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1819)\n       at android.support.v4.app.BackStackRecord.executeOps(BackStackRecord.java:797)\n       at android.support.v4.app.FragmentManagerImpl.executeOps(FragmentManager.java:2590)\n       at android.support.v4.app.FragmentManagerImpl.executeOpsTogether(FragmentManager.java:2377)\n       at android.support.v4.app.FragmentManagerImpl.removeRedundantOperationsAndExecute(FragmentManager.java:2332)\n       at android.support.v4.app.FragmentManagerImpl.execSingleAction(FragmentManager.java:2209)\n       at android.support.v4.app.BackStackRecord.commitNowAllowingStateLoss(BackStackRecord.java:649)\n       at android.support.v4.app.FragmentPagerAdapter.finishUpdate(FragmentPagerAdapter.java:145)\n       at android.support.v4.view.ViewPager.populate(ViewPager.java:1238)\n       at android.support.v4.view.ViewPager.populate(ViewPager.java:1086)\n       at android.support.v4.view.ViewPager$3.run(ViewPager.java:267)\n       at android.view.Choreographer$CallbackRecord.run(Choreographer.java:871)\n       at android.view.Choreographer.doCallbacks(Choreographer.java:683)\n       at android.view.Choreographer.doFrame(Choreographer.java:616)\n       at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:857)\n       at android.os.Handler.handleCallback(Handler.java:751)\n       at android.os.Handler.dispatchMessage(Handler.java:95)\n       at android.os.Looper.loop(Looper.java:154)\n       at android.app.ActivityThread.main(ActivityThread.java:6123)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:867)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:757)\n\n#### Steps & Code to Reproduce\nThis happened after I updated realm from 2.3.0 to 4.1.1.\nThis only happens if exercise.getObjectId() is null.\nThis doesn't happen if I remove the 3rd equalTo(), or if I keep the query and its fieldName but changes the value from exercise.getObjectId() to exercise.getUniqueId(). \n\n#### Code Sample\n```java\n\/\/The query that crashes.\nprivate RealmQuery<ExerciseSet> getCommonExerciseSetQuery(Realm realm, Exercise exercise) {\n        return realm.where(ExerciseSet.class)\n                .equalTo(\"setGroup.user.objectId\", getUser().getObjectId())\n                .equalTo(\"setGroup.exercise.uniqueId\", exercise.getUniqueId())\n                .equalTo(\"setGroup.exercise.objectId\", exercise.getObjectId())\n                .equalTo(\"setGroup.isHidden\", false)\n                .isNotNull(\"setGroup.completionDate\");\n }\n\npublic class ExerciseSet extends RealmObject {\n    @Required\n    private String id;\n    private int setNumber; \/\/Only local on Android\n    private Integer reps;\n    private Integer expectedReps;\n    private Double kilograms;\n    private Double expectedKilograms;\n    private Double meters;\n    private Double expectedMeters;\n    private Integer seconds;\n    private Integer expectedSeconds;\n    private SetGroup setGroup;\n    ... \n}\n\npublic class Exercise extends RealmObject {\n   @Index\n    private String uniqueId;\n    @Index\n    private String objectId;\n    private RealmList<SetGroup> setGroups;\n    ...\n\n    public String getObjectId() {\n        return objectId;\n    }\n}\n\npublic class SetGroup extends RealmObject {\n    @Index\n    private String uniqueId;\n    private User user;\n\n    @Index\n    private String objectId;\n    ...\n    private Exercise exercise;\n    private Workout workout;\n    private RealmList<ExerciseSet> exerciseSets;\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s): 4.1.1\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 2.3.3\n\nWhich Android version and device: 7.0 Moto G5 Plus\n\n","comments":["If exercise.uniqueId or user.objectId is null it crashes with message \" This field(id) is not nullable.\"\r\nBoth fields id and setNumber is on ExerciseSet.class","you are query by check if `setNumber` equals to `null`, which is surely not, since `setNumber` is a `int` field and it is not nullable.\r\n\r\nIf the `setNumber` could be `null`, you should declare it as boxed type `Integer`.","It can't be null, and as far as I know I never query it. All the .equalTo() checks exerciseSet.setGroup, and not exerciseSet.id of .setNumber. Isn't it weird that the error message changes if I force some of the other nested fields to be null? ","Sorry that i didn't read your description carefully. I can confirm it is bug in our side.\r\n\r\n\r\ntest case to reproduce it:\r\n\r\n```java\r\n    @Test\r\n    public void equalTo_nullValueLinkedField() {\r\n        realm.beginTransaction();\r\n        DogPrimaryKey dog = realm.createObject(DogPrimaryKey.class, 42);\r\n        dog.setName(null);\r\n        Cat cat = realm.createObject(Cat.class);\r\n        cat.setScaredOfDog(dog);\r\n        Owner owner = realm.createObject(Owner.class);\r\n        owner.setCat(cat);\r\n        realm.commitTransaction();\r\n\r\n        Owner owner1 = realm.where(Owner.class).equalTo(\"cat.scaredOfDog.name\", (String) null).findFirst();\r\n        assertNotNull(owner1);\r\n    }\r\n```","Thanks for quick responses! \r\nI guess that test will crash the app.\r\nFor now I work around this by not querying this field if it's null."],"labels":["T-Bug","O-Community"]},{"title":"Add MVP with Dagger sample in examples","body":"#### Goal\n\n> Please add MVP with Dagger sample in examples.\n\n#### Expected Results\n\n> How to use Realm in MVP Architecture via Dagger 2.","comments":["We need to know if the data set exposed by the Repository is a Flowable, a LiveData; or a List (which is not recommended).","BTW this sample https:\/\/github.com\/zaki50\/realm_template\/blob\/master\/app\/src\/main\/java\/com\/example\/realm_template\/MainActivity.java injects Realm from Dagger, if that helps "],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Caused by: io.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/data\/com.appname\/files\/notes.db': Realm file has bad size.","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\n### Goal:\n\n- App Version: **2.2.0.0**\n- Build: **Release**\n- Users: **Playstore (Google Play App Signing= enabled)**\n- Realm: **4.1.1**\n- Original Database Location (Internal Storage): **\/data\/data\/com.appname\/files\/notes.db**\n- Backup Database Location (External Storage): **\/storage\/emulated\/0\/AppName\/Database\/notes.db**\n\nApp has backup functionality,\n\n**When click on backup:**\n_App copies\/replaces database from Internal Storage to External Storage_\n\n**When click on restore:**\n_App copies\/replaces database from External Storage to Internal Storage_\n\n**_The app is working great on production._**\n\n### Issue:\n\n I personally was using the debug(not release) build of the app on my phone.\n\n- App Version: **1.0.0**\n- Build: **Debug**\n- User: **Only Me**\n- Realm: **Unknown (< 4.1.1)**\n\nI had around **_500_** messages that was backed up on External Storage.\n\nToday, I accidentally uninstall the app. :cry: \n\n### Expected Results:\nNow, on installing latest version  2.2.0.0(either debug\/release build), it should automatically backup the messages, but its is giving following error.\n\n**I am not sure know whether the notes.db file is corrupted or what happened**\n\n### Stack Trace:\n````\nFATAL EXCEPTION: main\n                                             Process: com.appname, PID: 6831\n                                             java.lang.RuntimeException: Unable to start activity ComponentInfo{com.appname\/com.appname.mvp.activities.Chat}: io.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/data\/com.appname\/files\/notes.db': Realm file has bad size. (Realm file has bad size) (\/data\/data\/com.appname\/files\/notes.db) in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_SharedRealm.cpp line 252 Kind: ACCESS_ERROR.\n                                                 at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2416)\n                                                 at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2476)\n                                                 at android.app.ActivityThread.-wrap11(ActivityThread.java)\n                                                 at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1344)\n                                                 at android.os.Handler.dispatchMessage(Handler.java:102)\n                                                 at android.os.Looper.loop(Looper.java:148)\n                                                 at android.app.ActivityThread.main(ActivityThread.java:5417)\n                                                 at java.lang.reflect.Method.invoke(Native Method)\n                                                 at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)\n                                                 at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n                                              Caused by: io.realm.exceptions.RealmFileException: Unable to open a realm at path '\/data\/data\/com.appname\/files\/notes.db': Realm file has bad size. (Realm file has bad size) (\/data\/data\/com.appname\/files\/notes.db) in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_SharedRealm.cpp line 252 Kind: ACCESS_ERROR.\n                                                 at io.realm.internal.SharedRealm.nativeGetSharedRealm(Native Method)\n                                                 at io.realm.internal.SharedRealm.<init>(SharedRealm.java:186)\n                                                 at io.realm.internal.SharedRealm.getInstance(SharedRealm.java:239)\n                                                 at io.realm.internal.SharedRealm.getInstance(SharedRealm.java:202)\n                                                 at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:298)\n                                                 at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:284)\n                                                 at io.realm.Realm.getInstance(Realm.java:301)\n                                                 at com.appname.mvp.activities.Chat.getChatList(Chat.java:447)\n                                                 at com.appname.mvp.activities.Chat.onCreate(Chat.java:95)\n                                                 at android.app.Activity.performCreate(Activity.java:6251)\n                                                 at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)\n                                                 at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2369)\n                                                 at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2476) \n                                                 at android.app.ActivityThread.-wrap11(ActivityThread.java) \n                                                 at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1344) \n                                                 at android.os.Handler.dispatchMessage(Handler.java:102) \n                                                 at android.os.Looper.loop(Looper.java:148) \n                                                 at android.app.ActivityThread.main(ActivityThread.java:5417) \n                                                 at java.lang.reflect.Method.invoke(Native Method) \n                                                 at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) \n                                                 at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)\n````\n### Code Sample:\n\n**_Code for backup_**\n```java\npublic static void backupDB() {\n    Realm realm = Realm.getInstance(DBUtil.getRealmConfiguration());\n    File f = PathUtil.createExternalDatabaseFile();\n    StorageUtil.delete(f); \/\/[mandatory_: java.lang.IllegalArgumentException: The destination file must not exist]\n    realm.writeCopyTo(f);\n    realm.close();\n}\n```\n\n**_Code for restore_**\n```java\npublic static void restoreDB() {\n    \/\/realm.getPath()  ->   \/data\/data\/com.appname\/files\/notes.db\n    Realm realm = Realm.getInstance(DBUtil.getRealmConfiguration());\n    File fromFile = PathUtil.getExternalDatabaseFile();\n    File toFile = new File(realm.getPath());\n    if (fromFile.exists())\n        StorageUtil.copy(fromFile, toFile);\n    realm.close();\n}\n```\n\n**_Utilities_**\n```java\npublic static RealmConfiguration getRealmConfiguration() {\n    return new RealmConfiguration\n            .Builder()\n            .name(\"notes.db\")\n            .schemaVersion(1)\n            .modules(new SchemaNotesDB())\n            .build();\n}\n\npublic static void copy(File fromFile, File toFile) {\n    try {\n        FileInputStream is = new FileInputStream(fromFile);\n        FileChannel src = is.getChannel();\n        FileOutputStream os = new FileOutputStream(toFile);\n        FileChannel dst = os.getChannel();\n        dst.transferFrom(src, 0, src.size());\n        src.close();    is.close();\n        dst.close();    os.close();\n    } catch (Exception ignored) {\n    }\n}\n````\n\n#### Version of Realm and tooling\nRealm version(s): 4.1.1\n\nRealm sync feature enabled: false\n\nAndroid Studio version: 3.0.0\n\nWhich Android version and device: ? Nexus 5 (Marshmallow), Nexus 6P (Oreo)\n\nRealm Backed Up Database Size (External Storage): 83.8 KB","comments":["    Realm realm = Realm.getInstance(DBUtil.getRealmConfiguration());\r\n        StorageUtil.copy(fromFile, toFile);\r\n\r\nDo not overwrite open Realm file.","well its a production code, and is working well on 2.2.0.0\r\n```java\r\npublic static void restoreDB() {\r\n    \/\/realm.getPath()  ->   \/data\/data\/com.appname\/files\/notes.db\r\n    Realm realm = Realm.getInstance(DBUtil.getRealmConfiguration());\r\n    File fromFile = PathUtil.getExternalDatabaseFile();\r\n    File toFile = new File(realm.getPath());\r\n    if (fromFile.exists())\r\n        StorageUtil.copy(fromFile, toFile);\r\n    realm.close();\r\n}\r\n```\r\n\r\nNevertheless, changing it to below, is not helping either\r\n```java\r\npublic static void restoreDB() {\r\n    RealmConfiguration configuration = DBUtil.getRealmConfiguration();\r\n    Realm realm = Realm.getInstance(configuration);\r\n    String path = realm.getPath();\r\n    realm.close();\r\n    Log.e(\"---->\", Realm.getGlobalInstanceCount(configuration) + \"\"); \/\/0\r\n    File fromFile = PathUtil.getExternalDatabaseFile();\r\n    File toFile = new File(path);\r\n    if (fromFile.exists())\r\n        StorageUtil.copy(fromFile, toFile);\r\n}\r\n```\r\n\r\n**Same error,  I think there is an issue with my backed up database at external storage**\r\n\r\n","Have you tried opening the external storage Realm file in the Realm Browser?\r\n\r\nOr as an asset file directly (instead of through restoration)?","I am on windows, I'll try in few hours, then comment.","It is giving [**_Please enter valid encryption key for realm file_**](https:\/\/stackoverflow.com\/questions\/39942561\/encryption-key-to-view-realm-file-on-mac-using-realm-browser)\r\n\r\nIs there any way from which I can recover my data from database of version 1.0.0?\r\nHow to check that whether database file is not corrupted?","```\r\npublic static void restoreDB() {\r\n    \/\/realm.getPath()  ->   \/data\/data\/com.appname\/files\/notes.db\r\n    Realm realm = Realm.getInstance(DBUtil.getRealmConfiguration());\r\n    File fromFile = PathUtil.getExternalDatabaseFile();\r\n    File toFile = new File(realm.getPath());\r\n    if (fromFile.exists())\r\n        StorageUtil.copy(fromFile, toFile);\r\n    realm.close();\r\n}\r\n```\r\n\r\n\r\nYour restore function has a very big chance to damage the db file. Do **never ever** delete\/overwrite the Realm file while there are Realm instances opened.\r\n\r\nWe might be able to supply a safe restore function with proper locks.","It might make sense to add a new API\r\n\r\n```\r\nRealm.restore(RealmConfiguaration config, File backupRealmFile)\r\n```\r\n\r\nfor the restore purpose.\r\n@realm\/java ?","How to check that whether my backed up database file (external storage) is corrupted or not?\r\n\r\nIs there any way to view data from corrupted file, I can see *gibberish + messages* when opening db in text editor.","@shanraisshan \r\n\r\nWe will supply an API for restoring, something like:\r\n\r\n```\r\nRealmConfiguration.Builder()\r\n  .restoreFile(File path)\r\n  .build();\r\n```\r\n\r\nIt will restore the Realm file if the `config.getPath()` doesn't exist.\r\n\r\n> How to check that whether my backed up database file (external storage) is corrupted or not?\r\n\r\nIt should not be corrupted if you are using `Realm.writeCopyTo()` and didn't change it manually. But if it is corrupted, `getInstance()` will throw.","Okay, I will wait, I hope everything goes well.\r\nThank you.","@beeender we can return a`SHA` hash of the backup file, the user can provide it back when trying to restore again, this way we can ensure that the backup file was not tampered with.\r\n```Java\r\n\/\/ backup\r\nString hash = realm.writeCopyTo(path);\r\n\/\/ developer responsibility save the hash somewhere (Global SharedPref, text file, Drive etc...) \r\n\r\n\/\/ restore\r\nRealmConfiguration.Builder()\r\n  .restoreFile(File path, hash\/*optional*\/)\r\n  .build();\r\n```","> this way we can ensure that the backup file was not tampered with.\r\n@nhachicha is there any issue if file is tampered?\r\n\r\nFor Example:\r\nIf user backed up a database with **_1000 records_**, open it on MAC browser, insert **_2500 more records_**, and wanted it to restore database with **_3500 records_**.\r\n\r\nIs this a problem?","@shanraisshan \r\nIn theory, no, the hash should be used optionally as I mentioned, if you explicitly update the Realm then you lose the feature obviously.\r\n\r\nThe idea here is to give the developer options whether he\/she wants to use the hash or not  \r\n\r\n(Note: you can still hash the file manually after you update the Realm `shasum -a 256 backup.realm` then use it to restore the backup)"],"labels":["T-Enhancement","O-Community"]},{"title":"Consider integration with Paging library once it is stable","body":"See https:\/\/medium.com\/@Zhuinden\/live-paged-lists-architecture-components-and-room-or-realm-268c9299a661\n\nand\n\nhttps:\/\/github.com\/Zhuinden\/realm-helpers\/blob\/4b83911b20304355e95870e51a1743bc141a36fd\/realm-pagination-example\/src\/main\/java\/com\/zhuinden\/realmpaginationexample\/data\/dao\/TaskDao.java#L25-L28\n\n------------\n\nAlthough I'm sure the API can be nicer (not having to explicitly open\/close, and while keep the notification could be moved to a background handler thread, but otherwise use `refresh()` in the `do { while` loop on the `io()` scheduler of the computable live data.","comments":["I've talked to @ericmaxwell2003 and he said he'll look into it later.","Paging is 1.0 as of may 8th ","Yeah I have to do it here too https:\/\/github.com\/Zhuinden\/realm-monarchy\/issues\/3","Any plans to support paging?! ","Slightly experimental, but [Monarchy](https:\/\/github.com\/Zhuinden\/realm-monarchy) supports it now.\r\n\r\n``` java\r\n DataSource.Factory<Integer, RealmDog> realmDataSourceFactory = monarchy.createDataSourceFactory(realm -> realm.where(RealmDog.class)); \r\n dataSourceFactory = realmDataSourceFactory.map(input -> Dog.create(input.getName())); \r\n dogs = monarchy.findAllPagedWithChanges(realmDataSourceFactory, \r\n                                         new LivePagedListBuilder<>(dataSourceFactory, 20)); \r\n```\r\n\r\n> (not having to explicitly open\/close, and while keep the notification could be moved to a background handler thread\r\n\r\nWell would you look at that, that's what Monarchy does \ud83d\ude04 I'm surprised I eventually sat down and made a library for it.","@mhdtouban Out of curiosity, what is the use case for wanting to implement the Paging Library? With Realms lazy-loading architecture you don't actually need it since Realm doesn't have a cursor limit?\r\n","It's for people who want to read pages of data from Realm on a background thread and passed to UI thread, instead of having lazy-accessed cursor where the actual read happens on UI thread.\r\n\r\nThe cool thing is that this mechanism supports projection via `DataSource.Factory`'s `map()` function.","@cmelchior I want to use paging for many reasons, first we now officially have a way for pagination in Android instead of relying on recycling view scroll listener which has downsides, second paging offers cool features like a placeholder and continuous loading mechanism etc.","@Zhuinden I guess that is a valid point. I still haven't seen it being demonstrated as a problem in practice though, so IMO the problem is largely theoretical. But I guess the paging library also provides an abstraction for the underlying data source if you want to swap them later.\r\n\r\n@mhdtouban My point was that you don't need those loading mechanisms and placeholders with Realm. Our lazy-loading works very differently than how SQLite does it. ","Note, It isn't that we don't want to support paging, but I strongly suspect that the majority of cases don't actually need it and people are just using patterns from elsewhere that doesn't really apply to Realm.","Am not quite sure I get you with \"don't need those loading mechanisms with realm\", let's say I want to fetch data through an API with pagination. How would realm help in lazy loading? I mean I understand that it will help if am hitting the database, but what if am getting the data from API?","Personally I started investigating the background thread read because of [this](https:\/\/github.com\/realm\/realm-java\/issues\/5328). `realm.refresh()` is a bit less free than it used to be.\r\n\r\n> \"don't need those loading mechanisms with realm\", let's say I want to fetch data through an API with pagination. How would realm help in lazy loading? I mean I understand that it will help if am hitting the database, but what if am getting the data from API?\r\n\r\nTechnically you get the benefits of BoundaryCallback being called for zero items loaded and for item at end loaded. Previously you had to intercept zero-loaded in the Results change listener, and you had to know you reached the end if RecyclerView could no longer scroll down. \r\n\r\nBoundaryCallback does wrap these cases. ","@mhdtouban Sorry, I was mainly thinking about the use case where you had all data stored locally. I do agree that the paging library nicely provides a lot of utility where you need to fetch the data from the server first.","Guys great work!\r\n\r\nCan I suggest examples explaining how exactly pagination is not needed with Realm?\r\nSorry but this is not sufficient\r\n\r\n> Since queries in Realm are lazy, performing this sort of paginating behavior isn\u2019t necessary at all, as Realm will only load objects from the results of the query once they are explicitly accessed.\r\n> \r\n> If for UI-related or other implementation reasons you require a specific subset of objects from a query, it\u2019s as simple as taking the IQueryable object, and reading out only the objects you need.\r\n> \r\n\r\nI mean this problem of pagination with Realm gets most new users stumped, and there's no example!\r\nHonestly it's a hard concept telling users to replace well known pagination routines with a loop...\r\n\r\nMost of the UI controls and grid\/list display routines out there have callbacks that include query, sort parameters...**and pagination parameters**.\r\nA simple example would have clarified this feature of not needing \"those loading mechanisms with realm\".\r\nWould it be too much work to add a few lines of examples to your documentation showing exactly how it's done? \r\n\r\nIt's clear the use case being referenced in your documentation is not sufficient to cater to the majority of pagination use cases out there. \r\n\r\n**You do need a way to execute SKIP, TAKE, TOP, LIMIT routines.** \r\nIf Realm already does that for local data, can we see how?\r\n\r\nThanks.","Technically what they mean by not needing pagination is that data is lazy-loaded so that means you can access any item at any index, and that item will only be loaded on access. This lazy loading means that you don't need to \"load more\" because you can just throw everything into the list regardless of result size, and it'll be fine.\r\n\r\nBut Realm doesn't actually support \"SKIP\" at this time. ","@Zhuinden \r\nThanks for the response!\r\n\r\nHowever, I'm afraid my concerns were not addressed.\r\nI do understand lazy loading and proxying virtual objects.\r\n**That use case does not address the majority of the scenarios out there where pagination parameters come into play.**\r\nI am talking about scenarios where **pagination parameters ARE NEEDED.**\r\n\r\nFor example, say you have this API or databound control that allows you implement a call back to retrieve a window of rows. \r\nYou are passed these set of parameters\r\nint Page =234, int PageSize=30\r\n\r\nThat is after you have applied very specific sorting and filtering parameters to the data.\r\nThis is an example from a Xamarin Forms app:\r\n\r\n```\r\nOnLoadMore = async () =>\r\n                {\r\n                    IsBusy = true;\r\n                    if (TotalRows > 0 || DataList.Count > 0)\r\n                    {\r\n                        if (!(DataList.Count < TotalRows))\r\n                        {\r\n                            return null;\r\n                        }\r\n                    }\r\n\r\n                    int page = DataList.Count \/ PageSize;\r\n\r\n                    PageSize = PageSize;\r\n\r\n                    CurrentPage = PageSize * page;\r\n\r\n                    \/\/This is what I should do... LINQ style...\r\n                    var tableData = DbContext.LocationUpdates.OrderBy(r => r.DateUpdatedUtc).Skip(CurrentPage).Take(PageSize);\r\n\r\n                    PageCount = tableData.Count;\r\n                    TotalRows = tableData.LongCount();\r\n                    return new InfiniteScrollCollection<LocationUpdate>(tableData);\r\n\r\n\r\n                \/\/This is what I should not have to do. Is this the Realm way of pagination data?\r\n                  var tableData = DbContext.LocationUpdates.OrderBy(r => r.DateUpdatedUtc).ToList();\r\n                  List<LocationUpdate> rows = new List<LocationUpdate>();\r\n\r\n                    \/\/faulty pagination logic I know\r\n                    for (int count = CurrentPage; count < tableData.Count(); count++)\r\n                    {\r\n                        rows.Add(tableData[count]);\r\n                    }\r\n\r\n                    PageCount = rows.Count;\r\n                    TotalRows = tableData.LongCount();\r\n                    return new InfiniteScrollCollection<LocationUpdate>(rows);\r\n\r\n```\r\n\r\nFor emphasis, you cannot pass an List, Map, IQueryable to a control or API that is expecting a specific number of rows. \r\nIf its an API call, say a REST service response where the app has to sync a subset of rows to the backend server in the background, I'm hoping you're not suggesting just lazy loading a List or IQueryable??\r\n\r\nIf it's local data and you have to deal with pagination call backs, then Realm simply does not support pagination or so it seems.\r\n\r\nIn the case of IQueryable, the documentation makes it clear that Skip, Take are not supported.\r\nSo the option of doing a ToList() just increases the confusion, since the databound control still has to call Take and Skip on something. \r\nHow do you track just how many rows have been loaded as the user scrolls down or up? It doesn't matter??\r\n\r\n **You need  a way to reason abount the logic of batching rows, it is the most popular use case.**\r\n\r\nAn example would have sufficed I think, you're assuming data pagination is not a valid use case.\r\nEven if Realm returns a lazy loaded List, and I absolutely need to paginate it for whatever reason, how do I get it done? \r\nSay the app specs requires an auto pull to refresh after the first 2,000 rows?\r\nOr in response to a DataGrid call back with filter and page parameters?\r\nLooking forward to your response.\r\n\r\nThanks.","Hi everyone,\r\n\r\nTo be consistent and use support libraries, I'm wanting to implement Paging support library because I need to fetch data from the API when needed.\r\n`LivePagedListBuilder` require `DataSource` and `PagedList.BoundaryCallback` implementations.\r\n\r\nBecause previous comments are 5 months old, I just wanted to know if an official `RealmDataSource` is on a way or not at all ?\r\n\r\nI think it would be nice to have one, like ObjectBox do for example.\r\n\r\nThanks.\r\n\r\n![Paging-01](https:\/\/user-images.githubusercontent.com\/4005409\/54219508-f2a0ae80-44ef-11e9-9605-44a4daf401d2.png)\r\n","Any update on this issue as it's very crucial.\r\nI am fetching items from realm asynchronously using livedata (as per given sample), there's no lag in fetching the data, but when I update the recyclerview using **notifiydatasetchanged** with the fetched data of size 400 items the **UI freezes** with black screen. Paging  would solve this.\r\nIs there any workaround of this.","@deepakkumardk if your UI freezes on `notifyDataSetChanged`, your RecyclerView probably is inside a `NestedScrollView` or has nested scrolling disabled, and therefore doesn't actually recycle.\r\n\r\nAlso, Paging 3.x will be so vastly different from Paging 2.x, that there is no point in creating an integration. ","@Zhuinden Yes, I am using the `NestedScrollView` and to support the pagination and remove the autoscroll to top or in between them in recyclerview (I had to disable nestedscrolling) on updating the recyclerview, same [issue#144](https:\/\/github.com\/realm\/realm-android-adapters\/issues\/144) as of **`RealmAndroidAdapters`** but I am not using this instead I am getting this issue in standard recyclerview.\r\nI am just observing the db and loading the data from db only.\r\nIs there any workaround to prevent both of this issues?","You need to remove the NestedScrollView and whatever it's currently solving you have to most likely solve with item view types.","I just published [Compass](https:\/\/github.com\/arunkumar9t2\/compass) which provides set of APIs to integrate Realm with Jetpack Paging 3.\r\n\r\nThe API looks like this:\r\n\r\n```kotlin\r\nval pagedPersons = RealmQuery { where<Person>() }.asPagingItems()\r\n```\r\n\r\nHere `asPagingItems()` will internally maintain an active realm instance, lazily load items in response to paging lib callbacks in a dedicated worker thread and automatically cleans up once `Flow` collection is stopped.\r\n\r\nIt also provides a way to read only subset of data into memory with the overload:\r\n\r\n```kotlin\r\nval pagedPersonNames = RealmQuery { where<Person>() }.asPagingItems { it.name }\r\n```\r\n\r\nExample with Android ViewModel:\r\n\r\n```kotlin\r\nclass MyViewModel: ViewModel() {\r\n\r\n    val results = RealmQuery { where<Task>() }.asPagingItems().cachedIn(viewModelScope)\r\n}\r\n```\r\n\r\nIt can support transforms, caching and seperators from Paging lib as described [here](https:\/\/developer.android.com\/topic\/libraries\/architecture\/paging\/v3-transform). Any feedback appreciated."],"labels":["T-Enhancement","O-Community"]},{"title":"Changed Notification raised even when the value is the same","body":"\nI have a RealmObject with a private property with get \/ set accesor.\n```java\npublic class Dog extends RealmObject\n{\n\tprivate String name;\n\tpublic String getName()\n\t{\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name)\n\t{\n\t\tthis.name = name;\n\t}\n}\n```\n(Nothing fancy there).\nI have a subscritor to a list of dogs:\n```Java\nRealmResults<Dog> mydogs = realm.where(Dog.class).findAll();\nmydogs.addChangeListener((dogs, changeSet) -> \/\/any update stuff);\n```\nAs expected, anytime the name of any dog is changed the listener is hit, however what I didn't expect is that the listener is hit everytime I assign a name to the name field even if it is the same as it has, I don't know if this behavior is by design, so I had to add something like this:\n```Java\n       public void setName(String name)\n\t{\n                if (!this.name.equals(name)\n\t\t     this.name = name;\n\t}\n```\nI know that this is an easy solution, but I wonder why the listener is launched even if the underlined data is not changed. \nIs this the expected behavior?\n(I'm using Realm 4.1.0 on a 6.0 Android emulated device)","comments":["Yes, this is by design. The checking can be moved to the Realm side so you don't have to do it every time. But that may slow down other cases since for every setters Realm will do a equality check. I am not quite sure we will change the design.\r\n\r\nSo for now, i think you still need to do the check in your setters manually.","I understand that to make checks every time is expensive, but it is a bit \"unnatural\" to receive notifications when they are not expected.\r\nThe problem is that sometimes to process the notification logic is even more expensive, in my case I'm refreshing a view. I could try to manage the check logic on the notification, to review if anything has really changed on the changeset, but the problem is that as the RealmResults already have the last values, so I can't compare before applying the changes.\r\nBeing said that, I will just add the setters checks on those fields that could be problematic in my case.\r\nHowever this would prevent me to use a direct use of the property without a setter, and I wonder if it would affect it in Kotlin (I'm start to think on moving my base code to kotlin)","Having a custom setter doesn't effect Realm as long as the standard getter is still there. See https:\/\/medium.com\/@nomanr\/backing-field-in-kotlin-explained-9f903f27946c\r\n\r\nWe have an issue discussing what to do about the situation as it isn't entirely trivial. Not receiving updates about overriding the same field makes sense for UI components, but might be relevant in other cases. If I can just remember where we had that discussion \ud83d\ude44 \r\n","See https:\/\/github.com\/realm\/realm-core\/issues\/2787 for a discussion of this on Realm Core level.\r\n\r\nSo this means that you get notification because a `set` operation is logged by Core which is indeed a requirement not to miss changes in a synchronized setting.\r\n\r\nWhich is why only the user knows if \"not setting the value\" is not necessary. ","Thanks for the insight about the current status. From that thread, It seems that the decision have been made more for a technical problem, as even in the discussion is stated that it strange to receive notifications even when there is not change made.\r\nThe problem with the \"only the user knows\" approach is that, for example, I have more than 30 classes on my model and there are a lot of properties to check and that could be cumbersome to add all the guards just to make my code to behave the \"expected way\" from the user point of view. Also the other approach would be to \"check\" when the notification is received, but again as realm has the latest changes already \"loaded\" on my collection I don't have the data to compare if the field values are the same or not. \r\nJust to be clear, I'm not complaining, realm is amazing and you guys are doing and great work and this\r\nis a tricky situation and I guess one of the payloads of using sync.\r\n\r\nThank you for taking the time to find and post the thread discussion.","It is indeed tricky unfortunately, personally I was wondering about the possibility of creating some kind of generated \"merge\" method that only calls the setter if it's not equal. But then you'd have another new method to save a RealmObject, there are already 3 of them :D","I think any elegant solution will probably be implemented at Core level (to have old\/new value) this requires stable ID work to be completed first https:\/\/github.com\/realm\/realm-core\/issues\/1971","@nhachicha Row-level stable IDs? that'll take a while \ud83d\ude04  I'm not even sure if Realm-Java has stable ID support for table in non-sync mode","We are using realm extensively in quite a number of projects both in java & swift. While swift object change has new\/old value support. In android we would like something along those lines if possible.","@softwarejoint you should bring that to https:\/\/github.com\/realm\/realm-java\/issues\/4366","+1 for a way to get notified of actual changes of the model. The update functionality is great because it saves a lot of code that is boilerplate, but if there is no way of knowing whether it modified the model, we can not use it to update views. In our case we query our server every second for a JSON of the model. I would love to just refresh the view in the on change notification but it will trigger every second regardless of changes to the JSON from the server.","Here is my case of that problem with gif:\r\n1) I fetch existing in realm data an show it.\r\n2) Load new data from the server.\r\n3) It comes the SAME data, but the realm still sends modification changes in it's notification.\r\nBecause of that the tableView jumps up, when the data return from the server and notification block fired.\r\n![glitch](https:\/\/user-images.githubusercontent.com\/16647690\/50424848-7eedee80-087c-11e9-87ff-ee3e70eb106e.gif)\r\n","You can use the new ImportFlags to change this behavior ","Does it have the analog in swift? ","All I know is that it was merged in Java here https:\/\/github.com\/realm\/realm-java\/pull\/6224\r\n\r\nI don't see anything similar on realm-cocoa which is odd. "],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"OrderedRealmCollection get is Nullable","body":"I'm migrating my app (100% Kotlin) to Realm 4.0 which seems to have made `OrderedRealmCollectionImpl.get` and `Collection.Iterator.get` nullable. It seems like the only reason for this is because of the following lines in `OrderedRealmCollectionImpl.get`:\n\n```\nif (forValues) {\n  \/\/ TODO implement this\n  return null;\n}\n```\n\n`forValues` is final and set to false. I now have hundreds of call points where I have to take nullability into account (I don't like using `!!` unless I absolutely need to) because of something that will never return null.\n\nDoes this actually have to be nullable, or is it really a placeholder for something else? Because that would be a really inconvenient placeholder.","comments":["I believe that is a mistake. @zaki50 @beeender It is because when implementing `RealmList<Primitive>`, originally the intention was to add that to `OrderedRealmCollectionImpl`, but all relevant logic is in `RealmList` instead, so... I don't think that should be there!","It is another inconsistent API :( \r\n\r\nThe `RealmList<RealmObject>` doesn't support null element which is a realm-core restriction, see issue https:\/\/github.com\/realm\/realm-core\/issues\/1866 . And it should support!\r\n\r\nBut `RealmList<Integer>` supports it. which makes this API has to be marked as `@Nullable` in case in the future we can support null values in the `RealmList<RealmObject>` as well.\r\n\r\nI don't have a good idea to work around this right now. Does anyone have any suggestions?","@beeender what if each subclass overrides `get` and marks it as nullable or not?","but the subclass is using generic types :( \r\n\r\nlike\r\n`RealmList<Integer>` and `RealmList<RealmObject<Xxx>>` \r\n\r\nso we cannot override the `RealmList.get()` .","Kotlin solves it through: `List<Person?>` and `List<Person>` which does the right thing in Kotlin. The problem is that Java cannot express that in the type system, so no matter what we probably need to introduce inconsistencies somewhere. Not exactly sure what the best approach is here, to be honest \ud83d\ude22 ","It looks like we might be able to muck about with annotations enought to make this work: https:\/\/kotlinlang.org\/docs\/reference\/java-interop.html#jsr-305-support\r\n\r\nIf we specially set `RealmList` to be `@NonNullable(when = When.UNKNOWN)` it should be nullable in Java and non-null in Kotlin as a default, but I have not tested it.","I'm confused. If `RealmList` can contain null objects that's fine (not really, because I feel like that's a really weird use case and maybe should use a different object so as not to cause inconvenience to the rest of the realm user base).\n\nWhy does `OrderedRealmCollectionImpl.get` need to be nullable?","Because that is our internal backing code for RealmLists.","`@Nonnull(when = When.UNKNOWN)` really does seem to do exactly what's required here, according to docs anyways","@cmelchior maybe I'm missing something? I don't see any references to `OrderedRealmCollectionImpl` in `RealmList`.","@beeender this logic is directly in `RealmList`, the `OrderedRealmCollectionImpl` is only used by RealmResults and OrderedRealmCollectionSnapshot.","FWIW `first` and `last` have the same issue.","This is really causing a lot of issues in any Kotlin project that uses Realm."],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"Support Projections (incl. View Models and AutoValue)","body":"When it comes to displaying data on the UI thread there are roughly 3 approaches in the current database eco-system on Android:\n\n1) Copy database entities directly into memory, with some rules on how to handle relationships (Most ORM's).\n\n2) Allow you map entities and queries to projection classes (Room),\n\n3) Expose entities, but lazy-load everything (Realm).\n\nAll of the above has advantages and disadvantages, some more than others, but I'll focus specifically on the differences between 2) and 3).\n\n**Room Projection Classes**\n- Each class has a single responsibility.\n- Only loading the properties needed makes it memory-efficient.\n- You need to modify the projection class every time the UI requirements change. \n- More classes in the system. \n- All work is guaranteed to be run on background threads.\n- Decoupling from Cursor makes it hard to do \"infinite scrolling\"\n\n**Realm Lazy-loaded entities**\n- Fewer classes overall in the system.\n- Lazy-loading all properties makes it memory-efficient (with a caveat around deeply nested object hierarchies).\n- Exposing Realm data directly makes it very easy to do \"infinite scrolling\".\n- Tighter coupling between model and UI layer.\n- Rely on the operating system to do memory-mapping efficiently (This works in practice but corner cases might exists).\n- Realm behavior leak into other parts of the architecture (like threading constraints).\n\nAs seen above there are both advantages and disadvantages to both approaches, but one key complaint we do hear from people not wanting to adopt Realm is how it tends to creep into all layers of the architecture. This proposal is thus an attempt to add the concept of Projections to Realm. \n\n\n### Use cases supported\n\n* Decouple Realm classes from the UI layer. \n\n* Add support for AutoValue. See https:\/\/github.com\/realm\/realm-java\/issues\/2538\n\n* Add support for Kotlin data classes.\n\n* Prevent unnecessary allocations when fetching objects from deep object hierarchies.\n\n* Make it possible to bulk-load data, like e.g. ObjectBox does it. \n\n* Move _all_ work to a background thread.\n\n\n### Proposed solution\n\nAdd two annotations: `@RealmProjection` and `@RealmField` annotation that makes it possible to map fields from a RealmObject to a standalone in-memory class, only copying the fields defined.\nThis makes it possible for Realm to efficiently move all of these through JNI using only one method call as well as decoupling the UI from the Database.\n\nProjections are _not_ lazy-loaded, they are full in-memory copies.\n\n\n### Examples\n\n```\npublic class Person extends RealmObject {\n    @PrimaryKey public String id;\n\tpublic String name;\n\tpublic int age;\n\tpublic String socialSecurityNumber;\n\tpublic RealmList<Person> children;\n\tpublic RealmList<Pet> pets;\n}\n\n\npublic class Pet extends RealmObject {\n        @PrimaryKey public String id;\n\tpublic String name;\n}\n\n\n\/\/ Simple Projection Class\n\n@RealmProjection(Person.class)\npublic class MyViewModel {\n\tpublic String name;\n\tpublic int age;\n}\n\nList<MyViewModel> persons = realm.where(Person.class).findAll().asProjection(MyViewModel.class);\n\n\n\/\/ Only return a single primitive type\n\nList<String> names = realm.where(Person.class).findAll().asProjection(String.class, \"name\");\n\n\n\/\/ Simple magic syntax for selecting child objects.\n\n@RealmProjection(Person.class)\npublic class MyAdvancedViewModel {\n\n\t@RealmField(\"name\") \/\/ use different variable name than stored in Realm\n\tpublic String fullName;\n\n\t@RealmField(\"children[0].name\") \/\/ Magic syntax for selecting objects in the object graph\n\tpublic String firstChildName;\n}\n\n\n\/\/ We quickly end up where full querying support are needed in the annotation\n\/\/ Question: Could this be described using @LinkingObjects and other concepts?\n\n@RealmProjection(Person.class)\npublic class MyOtherAdvancedViewModel {\n\n\t@RealmField(\"name\") \/\/ use different variable name than stored in Realm\n\tpublic String fullName;\n\n\t@RealmField(\"children.name = 'John' AND max(children.age)\")\n\tpublic int oldestChildNamedJohn;\n}\n\n```\n\n### API concerens that needs to be addressed\n\n* More advanced use cases needs to be described, especially queries with dynamic input cannot be expressed in an annotation.\n\n* How should the API look for doing the projection class conversion on a background thread?\n\n\n### Disadvantages\n\n* Unknown syntax for specifying properties in the object hierachy, especially advanced cases might be difficult \n\n* The tradeofs using a ViewModel approach is different from using a normal Realm, especially if they are copied into memory.\n\n* Realm annotations still creep into the UI layer.\n\n* No changelisteners on projections\n\n* It becomes more difficult to update the Realm data.\n\n* Maintaining the Projection class might be difficult as the entity changes.","comments":["> Decoupling from Cursor makes it hard to do \"infinite scrolling\"\r\n\r\nNot true though with its integration with Pagination library using `LivePagedListProvider`","Depends on the definition of \"hard\" and \"easy\" :smile:, but yes, \"hard\" might be too strong a word because the paging library do massively improve the situation. Example is here: https:\/\/developer.android.com\/reference\/android\/arch\/paging\/PagedListAdapter.html ","I don't think this approach is the right way to go because:\r\n\r\n- You don't necessarily want to create a VM on top of your existing data-model\r\n- You wont be able to make dynamic projections this way\r\n- You will drown in magic syntax which is static, not debuggable, and must be defined in the annotation descriptor which wouldn't scale\/work for big queries\r\n- You will not solve anything (?) for the recursively nested objects\r\n\r\nThis is not an easy case of course, yet I think the better approach would be to go the graphQL way of doing queries.\r\n\r\nSuppose you have a model:\r\n\r\n```kotlin\r\nopen class Module : RealmObject() {\r\n    var id: String\r\n    var data: Data\r\n    var children: RealmList<Module>? = null\r\n}\r\n```\r\nWhere's `data` is also a huge object with its own dependencies (say, with the depth of `6`).\r\nYour overall hierarchy, starting from a root-module to the very bottom level modules, consists of (`N`), say, 200 levels.\r\n\r\n- **Now how would you make a projection (a copy) of this data that only holds a 3rd level module and its immediate (4th lvl subset) children?**\r\n\r\nLooking at the examples you provided I have no idea how to do that... Without having a some kind of way to define local depth restrictions on fields it seems impossible.\r\n\r\nRather than force queries' job on annotations, how about improving on your actual queries and cursor?\r\nWhat if we  would be able to do a query like this:\r\n\r\n```kotlin\r\nrealm.where(Module::class.java)\r\n    .equalTo('id', moduleId)\r\n    .toProjection('\r\n        data: {\r\n             id\r\n             type\r\n             ... \/\/ other data-object fields\r\n        }\r\n        children: [\r\n             \/\/ realm does not support (polymorphism)\r\n             \/\/ heterogeneous lists yet, but maybe it will at some point\r\n             ... on Module {\r\n                  data: {\r\n                     id\r\n                     type\r\n                     ... \r\n                  } \r\n                  \/\/ notice we are not requesting childrens here\r\n             }\r\n        ]\r\n     ')\r\n```\r\nSo with this query (`toProjection`) we are requesting a `Module` with an id `moduleId` and we are telling the cursor to copy only those fields that are present in a `toProjection` query and only as deep as the query defined. \r\n\r\nThe fields that are not defined in a query should be returned with a `null` value.\r\n\r\n**To ease the pain of merging** (updating) these objects back to the DB you could generate a marker (`is<Field>Requested`) for every field that will tell the cursor that if the fields are not requested, then they will simply not be updated.\r\n\r\nTo ease this even more for yourselves, rather than entierly generating a marker you could force a convention for users to define a map:\r\n```kotlin\r\nopen class Module : RealmObject() {\r\n    var id: String\r\n    var data: Data\r\n    var children: RealmList<Module>? = null\r\n    \r\n    \/\/ a map that will hold markers { <field>: true\/false, ... }\r\n    \/\/ that will state whether or not a field was requested\r\n    \/\/ with toProjection query\r\n    @RealmProjectionFields\r\n    var isRequestedForProjection: RealmMap<String, Boolean>? = null\r\n}\r\n```\r\n\r\nWith the solution like this you will be able to generate any projection you like on the same RealmObjects (data-models). And whats even better - you will be able to potentially merge them back in the DB without breaking anything.","Well, if you actually want to map to a VM, maybe you should go like this:\r\n```kotlin\r\n@RealmProjection\r\nopen class VM {\r\n    @RealmField\r\n    var data: Data\r\n    @RealmField\r\n    var children: RealmList<Data>? = null\r\n    @RealmField\r\n    var someVmValue: String? = null\r\n    \/\/ do you really need these annotations ?\r\n}\r\n```\r\n```kotlin\r\nrealm.where(Module::class.java)\r\n    .equalTo('id', moduleId)\r\n    .toProjection(VM::class.java, '\r\n        data@<vm-field-name-for-data>: {\r\n             id\r\n             type\r\n             value@someVmValue\r\n        }\r\n        children: [\r\n             {\r\n                  data@<vm-field-name-for-children-data>: {\r\n                     id\r\n                     type\r\n                     value\r\n                  } \r\n             }\r\n        ]\r\n     ')\r\n```\r\nA little magic'ky but will scale better. Hard to tell what to do with these `@RealmField(\"children.name = 'John' AND max(children.age)\")` kind of restrictions though. A hybrid solution?\r\n\r\nAnd you wont be able to merge these back probably. Or it will be very tricky and will require of you to save PKs to your `VM projection` (with the `RealmObject's projection` **PK obviously should not be affected by the query**):\r\n```kotlin\r\nrealm.copyToRealmFromProjection(Module::class.java, VM::class.java, VM, '\r\n        id@<vm-field-for-id>\r\n        data@<vm-field-name-for-data>: {\r\n             id\r\n             type\r\n             value\r\n        }\r\n        children: [\r\n             {\r\n                  data@<vm-field-name-for-children-data>: {\r\n                     id\r\n                     value\r\n                  } \r\n             }\r\n        ]\r\n     ')\r\n```","@MrNovado Interesting ideas, and thank you for the feedback. The one major problem I have with re-using the model classes for projections is that a bunch of the fields in the class is then unused and it is up to consumers to know how the class was constructed. This really breaks any kind of layered architecture. \r\n\r\nSo having an individual class for each projection is still a lot better for a type-safe perspective, but there is definitely a non-trivial mapping problem that needs to be solved.","@cmelchior \r\n\r\n> The one major problem I have with re-using the model classes for projections is that a bunch of the fields in the class is then unused and it is up to consumers to know how the class was constructed. This really breaks any kind of layered architecture.\r\n\r\nWell, I kind of agree with the first part, but I disagree with the last one. The thing is, the consumer always has a strong opinion on how to use the data its requesting, right? The consumer will always use only whatever parts of the data-model that they need, and will not use the other parts of the data at all.\r\n\r\nThe VM' job for the most part is to solidify these needs in a particular structure - most of the time it's a quality of life thing and not something you must! provide.\r\n\r\nSo if the consumer already knows on how will he use and what parts of the data, - why wouldn't you allow them to specify their needs into a query?\r\n\r\nMind you, I'am not against the idea of mapping projections to VM at all, I'm just pointing out that projecting on the data-class itself could be just fine (and probably much easier as well).\r\n\r\nAnd from the `type-safe perspective` all of the data-class fields in realm are inherently `nullable` anyway (or at least they can be), so... why not?","Hmmm...\r\n\r\n> Realm is how it tend to creep into all layers of the architecture. \r\n\r\nThat's because of the thread-local Realm instance that you need to *pass* to methods because it is thread-local reference counted.\r\n\r\nPeople often don't end up creating their own thread-local to access a single open Realm without incrementing the ref count, so any query\/write will need a Realm method argument, from the outside, so that it belongs to the right thread. \r\n\r\nThen you must keep it alive to close it at the right time, when it is no longer needed. So scope management is up to the user.\r\n\r\n-----------------\r\n\r\nI managed to bind Realm and Pagination together on a background looper thread, so technically I *could* get notifications for projections for paged lists using arch comps.\r\n\r\nSee https:\/\/github.com\/realm\/realm-java\/issues\/5486","I used an in-memory realm instance to store projections in RealmObject like this.\r\n\r\n```java\r\npublic interface RealmObjectProjection extends BaseModel64 {\r\n    RealmList<RealmObject> getObjects();\r\n}\r\n```\r\n\r\nHow ever in order to get managed RealmList from a custom array projection, you need a simple container.\r\n\r\n```java\r\npublic class ItemProjection extends RealmObject implements RealmObjectProjection {\r\n    public ItemProjection() {\r\n    }\r\n\r\n    public ItemProjection(RealmList<Item> items) {\r\n        this.items = items;\r\n    }\r\n\r\n    @PrimaryKey\r\n    private long id;\r\n\r\n    private RealmList<Item> items;\r\n\r\n    \/\/ id getter and setter\r\n\r\n    public RealmList<Item> getItems() {\r\n        return items;\r\n    }\r\n\r\n    @Override\r\n    public RealmList<RealmObject> getObjects() {\r\n        return (RealmList) items;\r\n    }\r\n}\r\n```\r\n\r\nafter copying this simple object into the in-memory realm (*with unique id), you will get a managed realm list. then you can attach\/detach listeners to it. you can easily chain listeners from source to the projected view.\r\n\r\n```\r\nsource => listeners => projection => listeners\r\n```\r\n\r\nHere if source (RealmList\/RealmResults) is changed, it will notify it's listeners. those listeners will then modify the projection list which will then cause it to notify the projection listeners.\r\n\r\nyou have to be aware of memory leaks tho, you must detach listeners as soon as objects are no longer needed. also you must make sure that in-memory realm is valid while the projection is being used.\r\n\r\nI used this in a RecyclerView Adapter and its working so far. `onAttachedToRecyclerView` and `onDetachedFromRecyclerView` must be used to attach\/detach listeners. just like in RealmRecyclerViewAdapter.","Always test against process death with in-memory things"],"labels":["T-Feature","Design-Required","Pipeline-Idea-Backlog"]},{"title":"Need a way to ensure the Realm instance on the sync client thread has been closed","body":"`SyncSessionStopPolicy::Immediately` is supposed to close the Realm instance on the sync client thread before the `close()` call on the last Realm instance returned. But it seems it is not doing correctly.\n\nThis results:\n\n1. `Realm.deleteRealm()` cannot apply to synced Realm.\n1. `RealmCache.doCreateRealmOrGetFromCache()` for `downloadRemoteChanges()` cannot clean the Realm file if the downloading failed.\n\n","comments":["Hey @beeender, will this issue be fixed soon? I currently have a login screen where the user logs into their Google account to sync all their data from Realm. If the user backs out of the login activity, I cancel the RealmAsyncTask which should close the Sync realm and delete the sync realm. I instead get a crash saying \"It's not allowed to delete the file associated with an open Realm. Remember to close() all the instances of the Realm before deleting its file\"","Hello everybody, is there an update on this issue? I'm currently observing this behavior on my Android 9 device.","\u27a4 Brian Munkholm commented:\n\nClosing as it's related to legacy sync.","This is still an issue as the same architecture is present in newer releases.","In 2023, this is still an issue. Will this be fixed?"],"labels":["T-Bug"]},{"title":"Array of Primitives: Support queries","body":"Split from https:\/\/github.com\/realm\/realm-java\/pull\/5031\n\nWe need to add support for arrays of values to `RealmQuery`. Based on API discussions we don't want to add a ton of extra methods, so instead we are going to use the empty field name `\"\"` when querying arrays of primitives.\n\nE.g\n\n```\npublic class Person extends RealmObject {\n  public RealmList<String> names;\n}\n\n\/\/ Query list in object\nRealmResults<Person> results =  realm.where(Person.class).equalTo(\"names\", \"John\").findAll();\n```\n\nThis also include support for `RealmList.min()\/max()\/average()\/sum()\/minDate()\/maxDate()` which depends on the query system\n\n\n### Out of scope for now\n\n```\n\/\/ Query list directly\nPerson p = getPerson();\nRealmResults<String> results = p.names.where().like(\"\", \"Jo*\").findAll();\n```","comments":["I actually think\r\n\r\n```\r\n\/\/ Query list in object\r\nRealmResults<Person> results =  realm.where(Person.class).equalTo(\"names\", \"John\").findAll();\r\n```\r\n\r\nhas a higher importance than the others, so that you can replace `RealmString` link queries with it.","Yes. No doubt about that","Any progress\/updates on this? I am eagerly waiting for this feature to support the primitive list from my Wordpress API the native way without a wrapper. :)","Agreed, I was hoping for end of 2017, but maybe this year :smile: \r\n\r\nSurprised it's blocked, I thought [subtable query](https:\/\/github.com\/realm\/realm-core\/issues\/2910) does this.","+1, I have to use `.findAll()` and filter in java :(","@mgohin another option of course is to map the list into a single string field with some convention like `|value1|value2|value3|` and then `contains(\"flatList\", \"|${searchValue}|\")`\r\n\r\nBut that's lame that we still have to do that, i agree","+1","Hi,\r\nAny update on this much needed feature? It's 2019 and I don't think using a wrapper seems agreeable anymore.\r\nIf anyone has a workaround apart from flatlists, I would love to learn!","Hi @Zhuinden \r\n\r\nAny updates for this or what is the best workaround that u suggest for this \r\n\r\n","It's something we expect to prioritize \"soonish\" - but we are currently prioritizing getting Core6 tested, integrated and rolled out. I know that doesn't say much in terms of timeline, but it's unlikely to happen on this side of New Year.","@bmunkholm \r\nCan you suggest a workaround for this other than writing a custom deserializer which we removed after the introduction of primitive data realm list ","@ismdcf I've already posted the workaround, as unfortunate as it is: https:\/\/github.com\/realm\/realm-java\/issues\/5361#issuecomment-384979058\r\n\r\nFor Realm's roadmap, take a look at https:\/\/www.mongodb.com\/realm#roadmap \r\n\r\n> Estimated January 2020 through July 2020\r\n\r\n> Realm Database and Realm Cloud\r\n\r\n> After releasing Realm Database (Core) 6.0, we\u2019ll be able to start building exciting new functionality that we\u2019ve heard requested from the Realm community.\r\n\r\n> In Realm Database 6.1 and 6.2 expect to see features like:\r\n\r\n> - Support for embedded objects, dictionaries, and mixed types in the Realm Schema: have more flexibility in how you map, store, and interact with your data so that you can build a highly performant app.\r\n> \r\n> - **Support for Query Operators on Single-Typed Arrays: interact with arrays in Realm to run more powerful queries, meaning faster data processing and simpler code.**\r\n>\r\n> - Realm sharing between apps: allow a device to share one Realm across multiple apps, making it simple to keep data consistent across a suite of apps regardless of connectivity.\r\n\r\nSo you should probably map them to a single String field with separators and expect the feature for July 2020.\r\n\r\nThe good old `RealmList<RealmString>` also works but I recommend against it.","This has now been implemented in Core and ObjectStore, awaiting implementation here.","\u27a4 Claus R\u00f8rbech commented:\n\nThe currently used old syntax for queries does not support querying on primitive list elements. Filed this with core in RCORE-309.","> \u27a4 Claus R\u00f8rbech commented:\r\n> \r\n> The currently used old syntax for queries does not support querying on primitive list elements. Filed this with core in RCORE-309.\r\n\r\nSince we have migrated to use the query parser API internally we could maybe revisit this \ud83e\udd14 \r\n"],"labels":["T-Enhancement"]},{"title":"Add hint to documentation that RealmMigration implementation should override equals() and hashCode()","body":"#### Problem\nI don't understand the reason, but under some circumstances concerning multithreading the following exception will not be printed:\n\n```\njava.lang.IllegalArgumentException: Configurations cannot be different if used to open the same file. The most likely cause is that equals() and hashCode() are not overridden in the migration class: package.MigrationClass\n                                                       at io.realm.RealmCache.validateConfiguration(RealmCache.java:450)\n                                                       at io.realm.RealmCache.doCreateRealmOrGetFromCache(RealmCache.java:339)\n                                                       at io.realm.RealmCache.createRealmOrGetFromCache(RealmCache.java:281)\n                                                       at io.realm.Realm.getInstance(Realm.java:346)\n```\n\nInstead the background thread will get terminated without any feedback. I produced this stacktrace by accident, while making a call to my realm database on the main thread instead of on a background thread. Even if you can't figure out the reason for this either it would be awesome to have an hint in the documentation that an implementation of \"RealmMigration\" should override equals and hashcode. This would have saved me a couple of hours :grinning:\n\nGreets,\ndjuelg\n\n#### Version of Realm and tooling\nRealm version(s): 3.7.2\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 2.3.3\n\nWhich Android version and device: OnePlus 3T (API 25), Emulator (API26)\n\n","comments":["The reason is that you are creating multiple instances of the same RealmConfiguration most likely doing something like:\r\n\r\n```\r\n\/\/ This is done twice\r\nRealmConfiguration config = new RealmConfiguration.Builder()\r\n  .migration(new MyMigration())\r\n  .schemaVersion(2)\r\n  .build();\r\n```\r\n\r\nInternally we compare the configuration with any existing ones used to open the same Realm and `new MyMigration().equals(new MyMigration())` is false unless you override `equals` and `hashcode`, so theoretically it could be two totally different implementations.\r\n\r\nIt is really an anti-pattern to generate the configuration twice since it is immutable, so you should just store a reference to the first one you generate.\r\n\r\nI do agree that would could probably document this better.","@cmelchior do we really have to disallow different migration blocks for the \"same\" Realm config? it feels harmless to allow that.","It is often a source of confusion, I agree, which is also why the exception is so explicit about it, but consider the following case:\r\n\r\n```\r\n\/\/ This is done twice\r\nRealmConfiguration config1 = new RealmConfiguration.Builder()\r\n  .migration(new MyMigration(true))\r\n  .schemaVersion(2)\r\n  .build();\r\n\r\nRealmConfiguration config2 = new RealmConfiguration.Builder()\r\n  .migration(new MyMigration(false))\r\n  .schemaVersion(2)\r\n  .build();\r\n\r\npublic class MyMigration implements RealmMigration {\r\n\r\n   private final boolean ignore;\r\n\r\n   public MyMigration(boolean ignore) {\r\n     this.ignore = ignore;\r\n   }\r\n\r\n  @Override\r\n  public void migrate(DynamicRealm, long oldVersion, long newVersion) {\r\n    if (!ignore) {\r\n       \/\/ Run migration\r\n    }\r\n\r\n  }\r\n\r\nRealm realm1 = Realm.getInstance(config1);\r\nRealm realm2 = Realm.getInstance(config2); \/\/ throws currently\r\n}\r\n```\r\n\r\nThis is of course constructed but shows that you might parse in two different implementations of a migration if we just compare e.g. the class. Some really subtle bugs could happen because of this.\r\n\r\nI don't recall ever seeing a RealmMigration class with state like that though, so one could argue that we should just check for the class and document the corner case.\r\n\r\nOn the other hand, people should not be creating multiple RealmConfigurations in the first place.","Thank's for your help. I'm storing the RealmConfigurations in my database class. And I don't use multiple RealmConfigurations. What I do is calling `Realm realm = Realm.getInstance(this.config);` multiple times. Is this an anit-pattern, too?\r\n\r\nFurther information about concrete implementation here: [https:\/\/github.com\/djuelg\/Neuronizer\/blob\/master\/app\/src\/main\/java\/de\/djuelg\/neuronizer\/storage\/PreviewRepositoryImpl.java](PreviewRepositoryImpl.java)","[https:\/\/github.com\/djuelg\/Neuronizer\/blob\/master\/app\/src\/main\/java\/de\/djuelg\/neuronizer\/storage\/PreviewRepositoryImpl.java](https:\/\/github.com\/djuelg\/Neuronizer\/blob\/master\/app\/src\/main\/java\/de\/djuelg\/neuronizer\/storage\/PreviewRepositoryImpl.java) ","Migration is an interface, and the RealmConfiguration checks against equality of two RealmConfigurations.\r\n\r\nIf one wants to make two migrations equal, it makes sense to override hashCode and equals accordingly. "],"labels":["T-Doc","O-Community"]},{"title":"AuthenticationListener and logout","body":"Using `SyncManager.addAuthenticationListener()` it is possible to listen to events about users e.g. when a user is logged into ROS and logged out again.\n\nThe logout case is a bit tricky as we have multiple stages of logout:\n\n1) Soft logout (A users refreshtoken expires)\n2) Local logout (A users calls `user.logout()`. This clears all access tokens, stop sync and try to revoke the token, but other devices can still log the user in.\n3) Global logout: Token is revoked, logging the user out across all devices\n\nEspecially 3) causes problems for the authentication listener as Device A do not know if Device B revokes the refresh token, except from the fact that various `ACCESS DENIED` errors will start happening.\n\nThis makes it unclear when to actually trigger `AuthenticationListener.userLoggedOut(User)`  \n\n1) Trigger on local logout -> Do we really need the auth listener in that case then?\n2) Trigger on global logout locally -> Current behavior. Acceptable? We should probably clarify in docs\n3) Try to detect more cases where `logout` is called. The biggest problem there is that we cannot tell the difference between \"true\" INVALID ACCESS and a token that has expired.  \n\nWe also have a problem with the token revocation. That REST call is entirely hidden, so if there are any problems with it, users are currently not notified.\n\nThe original implementation was here: https:\/\/github.com\/realm\/realm-java-private\/pull\/104\/files#diff-b3972ee02a88870c7ea29f6a00540d05R201\n\nBack then, users could not log out locally, so a log out could not happen until after talking to the server, which made the case for the `AuthenticationListener` stronger. Also, the primary source of inspiration was https:\/\/firebase.google.com\/docs\/reference\/android\/com\/google\/firebase\/auth\/FirebaseAuth.AuthStateListener I do not know how Firebase handles the case where another devices logs the user out.","comments":["@cmelchior Was this ever addressed?","No. We have an AuthenticationListener, but it is right now only triggered on explicit logouts. All the special cases in this issue are not handled."],"labels":["T-Enhancement","Design-Required"]},{"title":"\"Re-use RealmResults and RealmObjects\" documentation example uses non-existent method","body":"In https:\/\/realm.io\/docs\/java\/latest\/#reuse-realmresults-realmobjects\n\n```java\npublic class MyActivity extends Activity {\n    private Realm realm;\n    private RealmResults<Person> allPersons;\n    private RealmChangeListener realmListener = new RealmChangeListener() {\n        @Override\n        public void onChange(Realm realm) { \/\/\/\/ <-- if RealmChangeListener is raw, this is Object\n            \/\/ Just redraw the views. `allPersons` already contain the\n            \/\/ latest data.\n            invalidateView();\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        realm = Realm.getDefaultInstance();\n        realm.addRealmChangeListener(listener); \/\/\/\/ <-- it's called \"addChangeListener\"!\n        allPerson = realm.where(Person.class).findAll(); \/\/ Create the \"live\" query result\n        setupViews(); \/\/ Initial setup of views\n        invalidateView(); \/\/ Redraw views with data\n    }\n\n    \/\/ ...\n}\n```\n\nAlso, why use Realm notification here instead of adding change listener to results? Just wondering\n\n","comments":[],"labels":["T-Doc","O-Community"]},{"title":"java.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction. But isInTransaction() -> False","body":"#### Goal\n\nAvoid crashes.\n\n#### Expected Results\n\nCrashes do not happen. Transactions completes successful without crashes.\nAlso I want to know what kind of code can lead to this crash.\n\n\n#### Actual Results\n\nError. StackTrace:\n```java\njava.lang.IllegalStateException: java.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 320\n\tat io.realm.internal.Collection.nativeStartListening(Native Method)\n\tat io.realm.internal.Collection.addListener(Collection.java:490)\n\tat io.realm.internal.Collection.addListener(Collection.java:497)\n\tat ...\n```\n#### Steps & Code to Reproduce\n\n100% Reproduce.\nOpen any file -> share to app -> app try save event to DB -> crash\n\n\n#### Code Sample\n\nCode transaction:\n```java\n\/\/(DataBase.java:767)\npublic void saveEventSync(Event event) {\n\tRealm realmOut = Realm.getDefaultInstance();\n\tTimber.d(\"saveEventSync realmOut.isInTransaction(): \" + realmOut.isInTransaction() + \" thread: \" + Thread.currentThread().getName()); \n\t\/\/Log: saveEventSync realmOut.isInTransaction(): false thread: main\n\trealmOut.close();\n\n\ttry (Realm realmIn = getRealm()) {\n\t\tTimber.d(\"saveEventSync realmIn.isInTransaction(): \" + realmIn.isInTransaction() + \" thread: \" + Thread.currentThread().getName());\n\t\t\/\/Log: saveEventSync realmIn.isInTransaction(): false thread: main\n\t\trealmIn.executeTransaction(realm -> {\n\t\t\t\/\/Crash Cannot create asynchronous query while in a write transaction in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 320\n\t\t\tTimber.d(\"saveEventSync executeTransaction start\");\n\t\t\tChat chat = realm.where(Chat.class)\n\t\t\t\t\t.equalTo(\"peer.uniquePeerId\", event.getPeer().getUniquePeerId())\n\t\t\t\t\t.findFirst();\n\t\t\tEvent eventRealm = realm.copyToRealmOrUpdate(event);\n\t\t\tif (chat != null) {\n\t\t\t\tchat.setLastEvent(eventRealm);\n\t\t\t}\n\t\t\tTimber.d(\"saveEventSync executeTransaction finish\");\n\t\t});\n\t}\n}\n \n```\n\n StackTrace:\nhttps:\/\/gist.github.com\/andrey7mel\/2bb88820aad15faf819547a0201eccf6\n```java\nD\/DataBase.saveEventSync()[769]: saveEventSync realmOut.isInTransaction(): false thread: main\nD\/DataBase.saveEventSync()[773]: saveEventSync realmIn.isInTransaction(): false thread: main\nE\/REALM_JNI: jni: ThrowingException 8, Cannot create asynchronous query while in a write transaction in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 320, .\nE\/REALM_JNI: Exception has been thrown: Cannot create asynchronous query while in a write transaction in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 320\nD\/DataBase.l()[775]: saveEventSync executeTransaction start\nD\/DataBase.l()[783]: saveEventSync executeTransaction finish\nE\/ChatPresenter$$Lambda.call()[0]: java.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 320\nE\/ChatPresenter$$Lambda.call()[0]:     at io.realm.internal.Collection.nativeStartListening(Native Method)\nE\/ChatPresenter$$Lambda.call()[0]:     at io.realm.internal.Collection.addListener(Collection.java:490)\nE\/ChatPresenter$$Lambda.call()[0]:     at io.realm.internal.Collection.addListener(Collection.java:497)\nE\/ChatPresenter$$Lambda.call()[0]:     at ...\n```\n \n\n#### Version of Realm and tooling\nRealm version(s): 3.5.0\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 2.3.3\n\nWhich Android version and device: Android 5 - 6 - 7, all devices","comments":["it is expected\r\n\r\n1. `addChangeListener()` cannot be called if the Realm is in transaction.\r\n2. the `beginTransaction()` will trigger all the listeners on the same thread to avoid inconsistent data.\r\n3. `RealmObject.asObservable` is based on the `addChangeListener`\r\n\r\n\r\nthe easiest way to to solve this:\r\n- just change the `executeTransaction` to `executeTransactionAsync`","But I dont use RealmObject.asObservable() or addChangeListener(), check my code please\r\n","```\r\n09-11 12:45:41.961 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:155)\r\n09-11 12:45:41.961 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:77)\r\n09-11 12:45:41.961 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\r\n09-11 12:45:41.961 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at rx.internal.operators.OperatorCast$CastSubscriber.onNext(OperatorCast.java:69)\r\n09-11 12:45:41.961 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\r\n09-11 12:45:41.961 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]: at io.realm.rx.RealmObservableFactory$10$1.onChange(RealmObservableFactory.java:293)\r\n```\r\n\r\nBefore the `beginTransaction()` , have you ever called `RealmObject.asObservable()`?","ehhh only now do I see the complete stack trace\r\n\r\n```\r\n09-11 12:45:41.968 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.internal.OsObject.notifyChangeListeners(OsObject.java:244)\r\n09-11 12:45:41.969 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.internal.SharedRealm.nativeBeginTransaction(Native Method)\r\n09-11 12:45:41.969 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.internal.SharedRealm.beginTransaction(SharedRealm.java:257)\r\n09-11 12:45:41.969 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.BaseRealm.beginTransaction(BaseRealm.java:348)\r\n09-11 12:45:41.969 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.BaseRealm.beginTransaction(BaseRealm.java:343)\r\n09-11 12:45:41.969 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.Realm.beginTransaction(Realm.java:132)\r\n09-11 12:45:41.970 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at io.realm.Realm.executeTransaction(Realm.java:1401)\r\n09-11 12:45:41.971 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.model.database.DataBase.saveEventSync(DataBase.java:774)\r\n09-11 12:45:41.971 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.presenter.FileUploadManager.uploadFileAsync(FileUploadManager.kt:47)\r\n09-11 12:45:41.971 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.presenter.chat.ChatPresenter.uploadFile(ChatPresenter.java:484)\r\n09-11 12:45:41.972 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.presenter.chat.ChatPresenter.handleSendIntent(ChatPresenter.java:673)\r\n09-11 12:45:41.972 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.view.chat.ChatFragment.handleSendIntent(ChatFragment.java:501)\r\n09-11 12:45:41.972 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.view.chat.ChatFragment.handleBundle(ChatFragment.java:467)\r\n09-11 12:45:41.976 9809-9809\/ru.techops.brief.debug E\/ChatPresenter$$Lambda.call()[0]:     at ru.techops.brief.view.chat.ChatFragment.onViewCreated(ChatFragment.java:434)\r\n```\r\n\r\nIt says here that calling `uploadFileAsync()` is triggered **synchronously** in `ChatFragment.onViewCreated()` which tries to do **synchronous** UI thread transaction (so much for that \"async\"!), which triggers change listeners which seem to cause a `switchMap()` to unsubscribe and resubscribe, but resubscription fails because it's in a transaction.\r\n\r\nSo somewhere `RealmObject.asObservable()` is used in an odd way","When the listeners get triggered, the transaction hasn't been started actually.\r\nSo maybe we should support this case.","@Zhuinden \r\n\r\nI'm facing issue like realm is already in write transaction. \r\n\r\nI'm deleting all the database files and re-creating again. After this operation I'm trying to insert records in the table. By this time I'm getting exception like above. Please let me know your thoughts on this. \r\n\r\nI understand it's because realm is loading all the datas takes some time on the mean while if I do insertion process I'm getting this issue.\r\n\r\nAsync request also not working","After a long time I've managed to figure out that this tends to happen if someone is adding a change listener to a RealmResults, inside a RealmChangeListener.\r\n\r\nI've NEVER had an actual usecase where this is something I needed.\r\n\r\nIf this is done by hand. It's possible to do `handler.post()` because transaction will finish by next loop. \r\n\r\nI'd need to see your stack trace to know more info where to look. ","Yes I tried with handler already by delaying then it's working fine. I'm just thought if there is any right way for doing this.","I just never add a change listener inside a change listener. :smile: \r\n\r\nAlthough I guess that could be tricky for the case of fine-grained object notifications.","override fun deleteDatabase() {\r\n        realm = Realm.getDefaultInstance()\r\n        try {\r\n            realm.beginTransaction()\r\n            realm.deleteAll()\r\n            realm.cancelTransaction()\r\n\r\n            createDatabase()\r\n        } catch (e: Exception) {\r\n            Log.e(Constant.LOGGER_TAG, \"Received an exception\", e)\r\n        } finally {\r\n            realm.close()\r\n        }\r\n    }\r\n\r\nprivate fun createDatabase() {\r\n        realm = Realm.getDefaultInstance()\r\n        try {\r\n            realm.beginTransaction()\r\n            initialDataDump.execute(realm)\r\n            realm.cancelTransaction()         \r\n        } catch (e: Exception) {\r\n            Log.e(Constant.LOGGER_TAG, \"Received an exception\", e)\r\n        } finally {\r\n            realm.close()\r\n        }\r\n    }\r\n\r\nopen class InitialDataDump: Realm.Transaction{\r\n    @Inject\r\n    lateinit var gson: Gson\r\n    @Inject\r\n    lateinit var commonMethods: CommonMethods\r\n    @Inject\r\n    lateinit var databaseHelper: DatabaseBoy\r\n    @Inject\r\n    lateinit var databaseHelperGirl: DatabaseGirl\r\n\r\n    override fun execute(realm: Realm) {\r\n            \/\/Store NotificationMenu Master Record\r\n            realm.copyToRealm(commonMethods.constructNotificationMenuData())\r\n\r\n            \/\/Store LessonBoy Category Master Record\r\n            realm.copyToRealmOrUpdate(commonMethods.constructLessonCategoryData())\r\n\r\n\r\n            \/\/Store Diaper Table Master Record\r\n            realm.copyToRealm(commonMethods.constructDiaperData())\r\n\r\n            \/\/Store Lessons BOY Master Record\r\n            realm.createAllFromJson(LessonBoy::class.java, databaseHelper.lessonsBoy)\r\n\r\n            \/\/Store Lesson Girl Master Record\r\n            realm.createAllFromJson(LessonGirl::class.java, databaseHelperGirl.lessonsGirl)\r\n    }\r\n\r\n    init {\r\n        AppController.appComponent.inject(this)\r\n    }\r\n}\r\n\r\nAfter doing all this I'm executing this statemnt which throws me the error\r\noverride fun save(user: User) {\r\n        realm = Realm.getDefaultInstance()\r\n        try {\r\n            realm.beginTransaction()\r\n            realm.copyToRealm(user)\r\n            realm.cancelTransaction()\r\n        } catch (e: Exception) {\r\n            Log.e(Constant.LOGGER_TAG, \"Received an exception\", e)\r\n        } finally {\r\n            realm.close()\r\n        }\r\n    }\r\n @Zhuinden "],"labels":["T-Enhancement","O-Community"]},{"title":"Gradle build crashes if there will be a Class named variable in your class that extends from RealmObject","body":"#### Goal\ni have asked this question and answered them https:\/\/stackoverflow.com\/questions\/46113644\/can-not-gradle-build-project-when-i-add-chatinformation-kotlin-class-that-extend \n\nIt was hard to me to detect that this error was from RealmObject's -> Class variable\nIt will be better if you add some hints that we can't use Class named variable in class that extends from RealmObject or correct this error\n\n#### Expected Results\nsuccess gradle build\n\n#### Actual Results\nError:Execution failed for task ':app:compileDebugJavaWithJavac'.Compilation failed; see the compiler error output for details.\n\n#### Code Sample\n```java\nopen class ChatInformation(\n        var Id: Int = 0,\n        var TopicId: Int = 0,\n        var CreateTime: String? = null,\n        var StartTime: String? = null,\n        var EndTime: String? = null,\n        var StatusId: Int = 0,\n        var Duration: String? = null,\n        var TeacherId: String = \"\",\n        var LearnerId: String = \"\",\n        var SubjectName: String = \"\",\n        var TopicTitle: String = \"\",\n        var Class: Int = 0,\n        var Learner: String = \"\",\n        var Teacher: String = \"\",\n        var TeacherReady: Boolean = false,\n        var LearnerReady: Boolean = false\n) : RealmObject()\n\n\n```\n\n#### Version of Realm and tooling\nRealm version(s): i have tried on 3.5.0 and 3.7.1\n\n","comments":["I wonder if it would still crash if it was called `class` instead of `Class`.","Hi @BMukhtar \r\nYes, that looks like a bug  on our part and something we should fix \ud83d\udc4d \r\n","Hi @cmelchior Thanks for reply, Hi @Zhuinden it can not be named as class ","I have a completely same error.Did you solve it?","@enofeb you should use `@RealmField` annotation and name your field something different ","package com.example.enes.cinemaapp.data.model;\r\n\r\n\r\nimport android.os.Parcel;\r\nimport android.os.Parcelable;\r\n\r\nimport com.google.gson.annotations.SerializedName;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport io.realm.Realm;\r\nimport io.realm.RealmObject;\r\nimport io.realm.annotations.PrimaryKey;\r\nimport io.realm.annotations.RealmField;\r\n\r\n\r\n\r\npublic class Movie extends RealmObject implements Parcelable {\r\n\r\n\r\n        @PrimaryKey\r\n        @SerializedName(\"realm _id\")\r\n        private String realId;\r\n\r\n        @SerializedName(\"id\")\r\n        private Integer id;\r\n\r\n        @SerializedName(\"title\")\r\n        private String title;\r\n\r\n        @SerializedName(\"overview\")\r\n        private String overView;\r\n\r\n        @SerializedName(\"release_date\")\r\n        private String releaseDate;\r\n\r\n        @SerializedName(\"vote_count\")\r\n        private Integer voteCount;\r\n\r\n        @SerializedName(\"poster_path\")\r\n        private String imagePath;\r\n\r\n        @SerializedName(\"adult\")\r\n        private Boolean adult;\r\n\r\n        @SerializedName(\"video\")\r\n        private Boolean video;\r\n\r\n        @SerializedName(\"genre_ids\")\r\n        private List<Integer>genreIds=new ArrayList<>();\r\n\r\n        @SerializedName(\"vote_average\")\r\n        private Double voteAverage;\r\n\r\n        @SerializedName(\"popularity\")\r\n        private Double popularity;\r\n\r\n        @SerializedName(\"original_language\")\r\n        private String originalLanguage;\r\n\r\n        @SerializedName(\"original_title\")\r\n        private String originalTitle;\r\n\r\n        @SerializedName(\"backdrop_path\")\r\n        private String backdropPath;\r\n\r\n        @SerializedName(\"credits\")\r\n        private CastGetting castGetting;\r\n\r\n        public Movie(){}\r\n\r\n    public Movie(Integer id, String title, String overView, String releaseDate, Integer voteCount,\r\n                 String imagePath, Boolean adult, Boolean video, List<Integer> genreIds, Double voteAverage,\r\n                 Double popularity, String originalLanguage, String originalTitle, String backdropPath) {\r\n        this.id = id;\r\n        this.title = title;\r\n        this.overView = overView;\r\n        this.releaseDate = releaseDate;\r\n        this.voteCount = voteCount;\r\n        this.imagePath = imagePath;\r\n        this.adult = adult;\r\n        this.video = video;\r\n        this.genreIds = genreIds;\r\n        this.voteAverage = voteAverage;\r\n        this.popularity = popularity;\r\n        this.originalLanguage = originalLanguage;\r\n        this.originalTitle = originalTitle;\r\n        this.backdropPath = backdropPath;\r\n    }\r\n\r\n    public String getRealId() {\r\n        return realId;\r\n    }\r\n\r\n    public void setRealId(String realId) {\r\n        this.realId = realId;\r\n    }\r\n\r\n\r\n\r\n    public Boolean getAdult() {\r\n        return adult;\r\n    }\r\n\r\n    public void setAdult(Boolean adult) {\r\n        this.adult = adult;\r\n    }\r\n\r\n    public Boolean getVideo() {\r\n        return video;\r\n    }\r\n\r\n    public void setVideo(Boolean video) {\r\n        this.video = video;\r\n    }\r\n\r\n    public List<Integer> getGenreIds() {\r\n        return genreIds;\r\n    }\r\n\r\n    public void setGenreIds(List<Integer> genreIds) {\r\n        this.genreIds = genreIds;\r\n    }\r\n\r\n    public Double getVoteAverage() {\r\n        return voteAverage;\r\n    }\r\n\r\n    public void setVoteAverage(Double voteAverage) {\r\n        this.voteAverage = voteAverage;\r\n    }\r\n\r\n    public Double getPopularity() {\r\n        return popularity;\r\n    }\r\n\r\n    public void setPopularity(Double popularity) {\r\n        this.popularity = popularity;\r\n    }\r\n\r\n    public String getOriginalLanguage() {\r\n        return originalLanguage;\r\n    }\r\n\r\n    public void setOriginalLanguage(String originalLanguage) {\r\n        this.originalLanguage = originalLanguage;\r\n    }\r\n\r\n    public String getOriginalTitle() {\r\n        return originalTitle;\r\n    }\r\n\r\n    public void setOriginalTitle(String originalTitle) {\r\n        this.originalTitle = originalTitle;\r\n    }\r\n\r\n    public String getBackdropPath() {\r\n        return backdropPath;\r\n    }\r\n\r\n    public void setBackdropPath(String backdropPath) {\r\n        this.backdropPath = backdropPath;\r\n    }\r\n\r\n\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getTitle() {\r\n        return title;\r\n    }\r\n\r\n    public void setTitle(String title) {\r\n        this.title = title;\r\n    }\r\n\r\n    public String getOverView() {\r\n        return overView;\r\n    }\r\n\r\n    public void setOverView(String overView) {\r\n        this.overView = overView;\r\n    }\r\n\r\n    public String getReleaseDate() {\r\n        return releaseDate;\r\n    }\r\n\r\n    public void setReleaseDate(String releaseDate) {\r\n        this.releaseDate = releaseDate;\r\n    }\r\n\r\n    public int getVoteCount() {\r\n        return voteCount;\r\n    }\r\n\r\n    public void setVoteCount(int voteCount) {\r\n        this.voteCount = voteCount;\r\n    }\r\n\r\n    public String getImagePath() {\r\n        return \"https:\/\/image.tmdb.org\/t\/p\/w185\"+imagePath;\r\n    }\r\n\r\n    public void setImagePath(String imagePath) {\r\n        this.imagePath = imagePath;\r\n    }\r\n\r\n    public CastGetting getCasting(){return  castGetting;}\r\n\r\n    public void setCredits(CastGetting castGetting) {\r\n        this.castGetting =castGetting;\r\n    }\r\n\r\n    @Override\r\n    public int describeContents() {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public void writeToParcel(Parcel dest, int flags) {\r\n        dest.writeInt(id);\r\n        dest.writeString(title);\r\n        dest.writeString(overView);\r\n        dest.writeString(releaseDate);\r\n        dest.writeInt(voteCount);\r\n        dest.writeString(imagePath);\r\n        dest.writeValue(adult);\r\n        dest.writeValue(video);\r\n        dest.writeList(genreIds);\r\n        dest.writeDouble(voteAverage);\r\n        dest.writeDouble(popularity);\r\n        dest.writeString(originalLanguage);\r\n        dest.writeString(originalTitle);\r\n        dest.writeString(backdropPath);\r\n    }\r\n\r\n    public Movie(Parcel in) {\r\n        id = in.readInt();\r\n        title = in.readString();\r\n        overView = in.readString();\r\n        releaseDate = in.readString();\r\n        voteCount = in.readInt();\r\n        imagePath = in.readString();\r\n        adult = (Boolean) in.readValue(Boolean.class.getClassLoader());\r\n        video = (Boolean) in.readValue(Boolean.class.getClassLoader());\r\n        genreIds = new ArrayList<Integer>();\r\n        in.readList(this.genreIds,Integer.class.getClassLoader());\r\n        voteAverage = in.readDouble();\r\n        popularity = in.readDouble();\r\n        originalLanguage = in.readString();\r\n        originalTitle = in.readString();\r\n        backdropPath = in.readString();\r\n    }\r\n\r\n    public static final Parcelable.Creator<Movie> CREATOR = new Parcelable.Creator<Movie>() {\r\n        @Override\r\n        public Movie createFromParcel(Parcel source) {\r\n            return new Movie(source);\r\n        }\r\n\r\n        @Override\r\n        public Movie[] newArray(int size) {\r\n            return new Movie[size];\r\n        }\r\n    };\r\n}\r\n","This is my model class and I get the same error @Zhuinden ","     @SerializedName(\"genre_ids\")\r\n     private List<Integer>genreIds=new ArrayList<>();\r\n\r\n`List` is not supported in RealmObject, you need to use RealmList ","I applied that your notice  but I still have same problem.When the class extend RealmObject,I have that problem.THIS IS BELOW @Zhuinden \r\n---------------------------------------------------------\r\norg.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:compileDebugJavaWithJavac'.\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:103)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:73)\r\n\tat org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)\r\n\tat org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)\r\n\tat org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\r\n\tat org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\r\n\tat org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\r\n\tat org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\r\n\tat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\r\n\tat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\r\n\tat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:256)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:249)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:238)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:663)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:597)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\r\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\nCaused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output for details.\r\n\tat org.gradle.api.internal.tasks.compile.JdkJavaCompiler.execute(JdkJavaCompiler.java:52)\r\n\tat org.gradle.api.internal.tasks.compile.JdkJavaCompiler.execute(JdkJavaCompiler.java:37)\r\n\tat org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.delegateAndHandleErrors(NormalizingJavaCompiler.java:98)\r\n\tat org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.execute(NormalizingJavaCompiler.java:51)\r\n\tat org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.execute(NormalizingJavaCompiler.java:37)\r\n\tat org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:35)\r\n\tat org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:25)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalResultStoringDecorator.execute(IncrementalResultStoringDecorator.java:41)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalResultStoringDecorator.execute(IncrementalResultStoringDecorator.java:27)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalAnnotationProcessingCompiler.execute(IncrementalAnnotationProcessingCompiler.java:50)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalAnnotationProcessingCompiler.execute(IncrementalAnnotationProcessingCompiler.java:36)\r\n\tat org.gradle.api.tasks.compile.JavaCompile.performCompilation(JavaCompile.java:156)\r\n\tat org.gradle.api.tasks.compile.JavaCompile.compile(JavaCompile.java:126)\r\n\tat com.android.build.gradle.tasks.factory.AndroidJavaCompile.compile(AndroidJavaCompile.java:92)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\r\n\tat org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:124)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:113)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:95)\r\n\t... 33 more\r\n-------------------------------------------\r\n\r\norg.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output for details.\r\n\tat org.gradle.api.internal.tasks.compile.JdkJavaCompiler.execute(JdkJavaCompiler.java:52)\r\n\tat org.gradle.api.internal.tasks.compile.JdkJavaCompiler.execute(JdkJavaCompiler.java:37)\r\n\tat org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.delegateAndHandleErrors(NormalizingJavaCompiler.java:98)\r\n\tat org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.execute(NormalizingJavaCompiler.java:51)\r\n\tat org.gradle.api.internal.tasks.compile.NormalizingJavaCompiler.execute(NormalizingJavaCompiler.java:37)\r\n\tat org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:35)\r\n\tat org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:25)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalResultStoringDecorator.execute(IncrementalResultStoringDecorator.java:41)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalResultStoringDecorator.execute(IncrementalResultStoringDecorator.java:27)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalAnnotationProcessingCompiler.execute(IncrementalAnnotationProcessingCompiler.java:50)\r\n\tat org.gradle.api.internal.tasks.compile.incremental.IncrementalAnnotationProcessingCompiler.execute(IncrementalAnnotationProcessingCompiler.java:36)\r\n\tat org.gradle.api.tasks.compile.JavaCompile.performCompilation(JavaCompile.java:156)\r\n\tat org.gradle.api.tasks.compile.JavaCompile.compile(JavaCompile.java:126)\r\n\tat com.android.build.gradle.tasks.factory.AndroidJavaCompile.compile(AndroidJavaCompile.java:92)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\r\n\tat org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\r\n\tat org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:124)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:113)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:95)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:73)\r\n\tat org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)\r\n\tat org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)\r\n\tat org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\r\n\tat org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\r\n\tat org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\r\n\tat org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\r\n\tat org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\r\n\tat org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\r\n\tat org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\r\n\tat org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\r\n\tat org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:256)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\r\n\tat org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:249)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:238)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:663)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:597)\r\n\tat org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)\r\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\r\n\tat org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\r\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\r\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\r\n\tat org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n\r\n\r\n","> Compilation failed; see the compiler error output for details.\r\n\r\nHave you tried checking the compiler error output for details? "],"labels":["T-Bug-Crash","O-Community"]},{"title":"Support a RealmOptional for single results","body":"#### Goal\n\nAs discussed in https:\/\/github.com\/realm\/realm-java\/issues\/4826, it is currently somewhat awkward to correctly handle the case of single item queries that might return null. When running `findFirst`, if the object doesn't exist yet, the query returns null - and you can't register a listener on a null object.\n\nThis is totally solvable today by using a RealmResults and `findAll` instead (with documentation that the size of the list is expected to be 0 or 1), but that's somewhat awkward code. It doesn't look or feel right.\n\n#### Expected Results\n\nA better solution would be to leverage something like Optional, where the query can return an object that holds either the actual value or `null`. This Optional could have a RealmListener applied to it which would allow the developer to receive callbacks when the item is created or updated. This allows code to preserve the look and feel of returning a single object while correctly leveraging query listeners.","comments":["`RealmOptional` would definitely make the intention of `findFirstAsync()` (but maybe even `findFirst()`) much clearer, as it would be listening for a \"single-element collection\" that can later be updated, deleted, and a new element added which would still also call the added change listener.","I do agree that the use case of `finding item X and only that` is one that isn't that well supported right now, and we did have quite a lot of talks about the semantics of `findFirst()` vs. `findAll()` . \r\n\r\nPersonally, I think having something like a specific `RealmOptional<Class> obj  = realm.get(Class, id)` method is probably the best way to support this, since `findFirst` primary use case seems to be to lookup objects by their id. @tmtrademarked This was also your use case, right?\r\n\r\nBut in general having `RealmOptional` would definitely encode the intent much much better.\r\n","Yup, that was our use case - although it wasn't specifically by their primary key, but rather a different field. (Various internal reasons for that particular requirement, but we could probably re-work that without too much trouble)"],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"Changeset for Object returns all fields","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\n#### Goal\n\n> Changeset for a given object (ObjectChangeSet) should return only those fields that actually changed from the original value. \n\nExample:\n\n```\npublic class Session extends RealmObject {\n    @PrimaryKey\n    private String id;\n    @Index\n    private String name;\n    private String sessiondate;\n    private String starttime;\n    private String endtime;\n    private String sessiontype;\n    private String location;\n    private String description;\n    private boolean isBookmarked;\n\n    \/\/getter and setters............\n}\n```\nSuppose, now I update the object using the following:\n\n```\nSession session = getSessionFromRemoteDBonUpdate();\nrealm.insertOrUpdate(session);\n```\nAll fields are returned as changeset even when not all have different values from what they currently have.\n#### Expected Results\n\n> Only the fields that actually differ should be returned.","comments":["Right now it is working as intended as we parse the transaction log and we just check if you write to a field, not what value was written. We do realise that this behaviour is normally not what you want when it comes to updating UI elements, but it might be the desired behaviour when it comes to conflict resolution across multiple devices.\r\n\r\nWe have an issue tracking reporting the old and new value here: https:\/\/github.com\/realm\/realm-java\/issues\/4366 With this you could solve it by manually comparing the old and new value.\r\n\r\nBut we are also considering changing the underlying semantics. You can follow the discussion here: https:\/\/github.com\/realm\/realm-core\/issues\/2787\r\n\r\nI'll keep this issue open as a reminder that solving any of the above 2 issues would also solve this use case.\r\n\r\n\r\n","Thank you @cmelchior. I spent hours figuring out why this was happening. Thought probably something is wrong with my code. Maybe you can add this in the documentation though? Or did I miss that out?"],"labels":["T-Enhancement","O-Community"]},{"title":"Support Java 8 time API's","body":"<!---\n\n**Questions**: If you have questions about how to use Realm, ask on\n[StackOverflow](http:\/\/stackoverflow.com\/questions\/ask?tags=realm).\nWe monitor the `realm` tag.\n\n**Feature Request**: Just fill in the first two sections below.\n\n**Bugs**: To help you as fast as possible with an issue please describe your issue\nand the steps you have taken to reproduce it in as many details as possible.\n\n-->\n\n#### Goal\n\n> I'd like to be able to restore `java.util.Date` instance from realm db with time offset value it was stored.\n\n#### Expected Results\n\n> `java.util.Date` object has the same time offset as it was at the moment of writing it to realm db.\n\n#### Actual Results\n\n>  `java.util.Date` object has zero time offset (+00:00) even if it was non zero (for instance +03:00) at the moment of writing it to realm db.\n\n#### Steps & Code to Reproduce\n\n> parse \"2017-08-14T12:33:00.000+03:00\" string into `java.util.Date` property of RealmObject using `java.text.SimpleDateFormat.(\"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ\", Locale.US)\n\n> perform `copyToRealm` for that RealmObject\n\n> read this object from realm\n\n> write to console this date using `java.text.SimpleDateFormat.(\"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ\", Locale.US).format(data.time)\n\n> you will get date time with zero time offset\n#### Code Sample\n\nThis code will not run as it is but I've got an idea\n\n```kotlin\nimport java.util.*\nimport java.text.SimpleDateFormat\n\nopen class DateWrapper: RealmObject() {\n    var date: Date? = null\n}\n\nfun main(args: Array<String>) {\n    val pattern = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n    val formatter = SimpleDateFormat(pattern, Locale.US)\n\n    val zonedDateTimeString = \"2017-08-14T12:33:00.000+0300\"\n\n    val date: Date = formatter.parse(zonedDateTimeString)\n    println(formatter.format(date))\n    \/\/2017-08-14T12:33:00.000+0300\n    \n    val dw = DateWrapper()\n    dw.date = date\n    \n    Realm.getDefaultInstance().use {\n        it.executeTransaction {\n            it.copyToRealm(dw)\n        }\n    }\n\n    Realm.getDefaultInstance().use {\n        println(formatter.format(it.where(DateWrapper::class.java).findFirst().date)\n        \/\/ 2017-08-14T12:33:00.000+0000\n    }\n}\n\n```\n\n#### Version of Realm and tooling\nRealm version(s): 3.1.4\n\nAndroid Studio version: 3.0 alpha9","comments":["This is by design. Timestamps are stored in Realm in GMT (calling `date.getTime()`). If you want to store the time zone for presentation purposes, it needs to be stored in a separate field and you can then convert the Date in a custom getter, but you will need to use `Calendar` as `Date` does not enable you to set time zones.\r\n\r\nWe have talked about adding support for more timezone aware datatypes, mostly Java 8 time API's. But that is still a bit further out.\r\n","`Date` does not contain any data about timeZone but it contains data about timeOffset (Although there is no way to set it except parse it from string, at least I did not found)\r\n\r\nThe reason of storing timeZone\/timeOffset is not only presentation purpose but sorting and filtering to. We are getting wrong results of queries filtered by time due to appearance of records that has different date because they are in different time zone.\r\n\r\nUnfortunately java 8 is not for the rescue as it is not available on android. So we are forced to use `three-ten-bp` or `joda-time`.\r\n\r\n> We have talked about adding support for more timezone aware datatypes, mostly Java 8 time API's. But that is still a bit further out.\r\n\r\nIs there any issue I can track to keep myself up to date ?","> The reason of storing timeZone\/timeOffset is not only presentation purpose but sorting and filtering too. We are getting wrong results of queries filtered by time due to the appearance of records that have different date because they are in different time zone.\r\n\r\nYes, I could imagine. But `date` and `time` are two different concepts. Which is also the reason that Java 8 has `LocalDate` and `LocalDateTime`. `Date` is a really awful class to describe `LocalDate` semantics.\r\n\r\nIf you want to query for specific dates, I would recommend storing the date (`dd-mm-yyyy`) representation in a specific field instead as trying to calculate the correct `Date` values as doing that is neigh impossible due to the rules for timezones\/daylight savings.\r\n\r\nI don't think we have a public issue for tracking Java 8 time support, so I guess we can promote this one.\r\n","Are you planning to release something about this in the near future?","Hi,\r\nI have the same issue, I want to save only `time`, and not the `date` part of it, something like this:\r\n```\r\n'14:30:59'\r\n'14:30'\r\n```\r\nAnd I would like to be able to sort query with this field.\r\nAlso there is a duplicated closed issue [here](https:\/\/github.com\/realm\/realm-java\/issues\/6476),\r\n\r\nIn `Django`, there are three separated fields related to date and time:\r\n\r\n- [DateTimeField](https:\/\/docs.djangoproject.com\/en\/2.2\/ref\/models\/fields\/#django.db.models.DateTimeField)\r\n- [DateField](https:\/\/docs.djangoproject.com\/en\/2.2\/ref\/models\/fields\/#django.db.models.DateField)\r\n- [TimeField](https:\/\/docs.djangoproject.com\/en\/2.2\/ref\/models\/fields\/#timefield) \r\n\r\nDo you have any suggestions to store time now? \r\n\r\nFor example using `Date` field but set date section to the fixed date for example:\r\n`\"01\/01\/2000 14:30:00\"`\r\n\r\nOr use `Integer` field and store time as milliseconds.\r\n","So is java.time.LocalDate support added already ?"],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Combining React Native and NodeJS in single fat client Android app using Realm DB","body":"I am investigating [viable options for running NodeJS on Android](https:\/\/stackoverflow.com\/a\/45649995\/8295283) and then [combining React Native and NodeJS in single fat client Android app using Realm DB](https:\/\/stackoverflow.com\/q\/45530635\/8295283). The node side of the application is involved in complex [decentralized P2P networking](https:\/\/stackoverflow.com\/a\/45323665\/8295283) (the rationale for having node on android).\n\nI know Realm supports NodeJS on a server, but does it also run the node version on an android device?\n\n---\n\n**Background info**\n\nI am musing on a CQRS-style design that does not need node realm support currently:\n\n![realm-rn-node_arch-concept](https:\/\/user-images.githubusercontent.com\/5111931\/29264649-2a05c9c8-80de-11e7-82c1-21fdc9fd63f9.png)\n\nApplication UI (react):\n- probably ddd-driven using [cqrs-react-router](https:\/\/github.com\/MichalPaszkiewicz\/cqrs-react-router)\n- realm client queries view projections from DB Realm (realm-java)\n- sends commands, receives events from NodeJS Background service\n\nBackground Service (node):\n- communicates via Java J2V8 glue code with the DB Realm to perform writes (of messages)\n  - but maybe using a realm storage implementation for [node-eventstore](http:\/\/eventstore.js.org\/)\n- no realm client to conserve `node_modules` space (even though node app will be bundled)\n\nDB\n- the main Realm that handles the actual data storage\n- uses realm-java; neatly aligns with Java glue \/ communication layer binding everything together\n\n---\n\nI thought this was a feasible design, but if there is no great overhead or large benefit to having realm-js on the node side I'd be glad to hear.","comments":["It isn't a combination that we officially support, nor have we heard of anyone else doing, so I'm afraid you will have to try for yourself.\r\n\r\nOne thing that concerns me a little is that if you run both Realm Java and Realm JS they will both try to load some of the same native code. This might or might not work. If you run them in different processes, then loading the native code shouldn't be an issue.\r\n\r\nUnfortunately Realm Java is not fully process safe yet, and you might run into schema issues if you load the same Realm file in Java and Node in two different processes.","Thanks @cmelchior good points!\r\n\r\nI expect this node-on-android use case to become more common as mobile devices get more powerful. I know of a number of people planning implementations.\r\n\r\nThe sharing of native code is something to avoid. An alternative in this design would be to have only a single realm package, either realm-js in RN _or_ node, _or_ a single realm-java bridging to both node and RN (where the bridges are also java).\r\n\r\nI know this is a peculiar use case, but to a Realm expert what would seem the best choice in this?\r\nPersonally I incline to realm-java as it provides the most stable foundation for the DB layer, I would think.","Some needed things for support realm-java and realm-js in one apk\r\n\r\n- Fully multi-processes support (need core release of https:\/\/github.com\/realm\/realm-core\/pull\/2864)\r\n- the native library issue (realm-js and realm-java are separated release)\r\n- unify the `SharedGroupOptions::set_sys_tmp_dir()` for both which is needed to make notification across both to work."],"labels":["T-Enhancement","O-Community"]},{"title":"Support lexicographically sorting of Strings","body":"We had a handful of questions now around our support for lexicographically sorting of strings. More commonly people want to do something like `realm.where(Person.class).greaterThan(\"name\", \"abc\").findAll()`.\n\nOne example: https:\/\/stackoverflow.com\/questions\/44581878\/realm-string-greaterthan\n\nSupporting this will be trivial if\/when Realm Core adds support for it: https:\/\/github.com\/realm\/realm-core\/issues\/2786","comments":["@cmelchior @bmunkholm any news on this?","was also requested here https:\/\/github.com\/realm\/realm-java\/issues\/4283","@cmelchior bump"],"labels":["T-Enhancement"]},{"title":"Extend the Notifications section of the documentation","body":"The documentation here:\nhttps:\/\/deploy-preview-3643--realm.netlify.com\/docs\/java\/latest\/#notifications\n\n.. could be improved.  The distinctions between the two kinds of notification: one with a list of changes and the other with an updated object could be clarified.  The current doc separates the description of the latter into two sections, divided by a description of the former.  ... and it never describes registering a listener for a `RealmResults` at all.\n\n","comments":[],"labels":["T-Doc"]},{"title":"[Sync] avoid creating duplicate SyncSession when opening a Realm","body":"During initialisation when opening a Realm the first time `doCreateRealmOrGetFromCache` will call `SharedRealm.getInstance(configuration)` then later `Realm.createInstance(this)` which will cause another implicit call to `SharedRealm.getInstance(configuration)`.\n\nCurrently, a `SyncSession` is created via the ObjectStore when creating a `SharedRealm`. This doesn't affect the syncing logic but creates overhead (double query for refresh and access token for example). \n\nWe should probably detach the creation of the `SharedRealm` instance, and the `SyncSession`","comments":["What exactly is mean't, when you refer that syncSession is created via the ObjectStore? Could you elaborate more. Please."],"labels":["T-Enhancement","T-Internal"]},{"title":"Realm.executeTransactionAsync loses some Exceptions","body":"This code:  \n```\nfinal Future<?> pendingTransaction = asyncTaskExecutor.submitTransaction(new Runnable() {\n  @Override\n  public void run() {\n    \/\/ ...\n\n    Throwable exception = null;\n\n    final Realm bgRealm = Realm.getInstance(realmConfiguration);\n    bgRealm.beginTransaction();\n    try {\n      \/\/ ...\n\n    } catch (final Throwable e) {\n      exception = e;\n    } finally {\n      try {\n        if (bgRealm.isInTransaction()) {\n          bgRealm.cancelTransaction();\n        }\n      } finally {\n        bgRealm.close();\n      }\n    }\n```\n\n... in the `Realm.executeTransactionAsync` will cause `Exception`s thrown in `Realm.getInstance` or `Realm.beginTransaction` to be swallowed by the Executor.  They should be passed to the `onError` handler.","comments":[],"labels":["T-Bug"]},{"title":"Support MutableRealmIntegers in RealmLists","body":"As part of primitive type support, for RealmLists, we should support lists of MutableRealmIntegers.\n\nSee #4266","comments":[],"labels":["T-Enhancement","T-Feature"]},{"title":"Support Mutable Realm Integers in the Dynamic API","body":"MutableRealmIntegers are not supported in Dynamic Realm.  They should be.\n\nSee #4266","comments":[],"labels":["T-Enhancement"]},{"title":"Report if default configuration is used during migration errors","body":"We had a number of support issues lately where people called `Realm.getDefaultInstance()` before calling `Realm.setDefaultInstance(config)`. This could e.g. happen if people didn't have a full understanding of the rather complicated lifecycle of Android components. Like e.g ContentProviders running before `Application.onCreate()`\n\nThis commonly resulted in `RealmMigrationNeededError` which was a bit hard to reason about if you didn't understand the root cause.\n\nIt has been suggested a number of times that we should require people _always_ calling `Realm.setDefaultInstance(config)` before `Realm.getDefaultInstance()` could be called. This idea has some merit, but at the same, it will using Realm for the first time slightly harder, but it would complicate much of our demo code.\n\nI still think that supporting a great first-time experience is key, but at the same time, we should also help users that are transitioning from novice to more experienced Realm users (which migration errors indicate).\n\nSo instead I will suggest that whenever a `RealmMigrationNeededException` is thrown during initialization, we check if the default configuration is used and if yes, we extend the error with something like:\n\nSomething like\n\n```\nThe Realm was opened with the default configuration which does not support \nmigrations.  Most likely 'Realm.setDefaultInstance(RealmConfiguration)' was not \ncalled before 'Realm.getDefaultInstance()'. <OriginalExceptionMessage>\n```\n\nWe could also create an FAQ entry with more details and reference that \n\nFor further context:\nhttps:\/\/github.com\/realm\/realm-java\/issues\/4844#issuecomment-311912232\n\n","comments":["I approve of this ","Just ran into this same problem in https:\/\/stackoverflow.com\/questions\/45613100\/realm-migration-needed-exception-after-adding-new-realmobject-class"],"labels":["T-Doc"]},{"title":"Allow primitive fields to have @Required annotation","body":"I got a request from a user.\n\nI think that just ignoring `@Required` annotation is fine if the field has primitive type.\nWhat do you think? @realm\/java","comments":["I think so ... do we throw in current release?","I don't see the purpose of it - it's implicitly `@Required`  if it's `long` instead of `Long`.","What @Zhuinden said. What would the use case be for wanting this? That said, allowing it is probably not harmful so :man_shrugging: \r\n\r\n","I heard the following case.\r\n\r\nAt first, they defined a field `@Required Long id;` in a model class .\r\nThen they made a refactoring that contains a change that field to `@Required long id;` and introduced Dagger.\r\n\r\nAfter that, build failure happened with bunch of Dagger errors.\r\nI guess errors contained Realm's one, but they couldn't find it since they didn't think\r\nthat primitive's having `@Required` is prohibited (I also felt it natural that primitive field is **Required**).\r\n\r\nI didn't have the reason why we didn't accept for primitive fields to have `@Required`.\r\n\r\nWhat do you think?\r\n","I would say we accept pull requests :) TBH I don't think it is something we should prioritize. ","I would love to contribute. Is this still valid?","I think now that both `Int?` and `Int` describe this case in Kotlin, and `Integer\/int` in Java "],"labels":["T-Enhancement","First-Good-Issue"]},{"title":"Document how objects merge using createObject and copyToRealm","body":"From this SO answer:\nhttps:\/\/stackoverflow.com\/questions\/44854060\/realm-doesnt-find-existing-items\/44880742?noredirect=1#comment76805067_44880742\n\nWe need to very clearly document how objects merge. Especially for initial data objects, it is very easy to accidentally override data you didn't intend to override.\n\n","comments":[],"labels":["T-Doc"]},{"title":"Check and print version when Realm.init() called.","body":"When the realm is used in multiple sub projects, it is an common issue that different modules are using different realm lib versions.\n\nSo we could inject the version string to both JNI and Java during build. Compare the both version values to see if they are the same, then show the version number in log.\n\nThis could be helpful for case like https:\/\/github.com\/realm\/realm-java\/issues\/4849#issuecomment-313018465","comments":[],"labels":["T-Enhancement"]},{"title":"Internal Lint check preventing leaking Java references in C++","body":"A common pattern in our C++ code is something like:\n\n```\nenv->CallVoidMethod(clazz, method_id, env->NewStringUTF(str));\n```\n\nIf the thread this is called on is a Java thread, this isn't a problem since the String will be GC'ed, but if the thread is a C++ thread, it will not, and we risk filling the local reference table, resulting in things like #4888 .\n\nIt would be nice if we could implement a local Lint check or somilar that warned against such cases and made us use the `JavaLocalRef` class instead as that will ensure the string is GC'ed when the ref goes out of scope no matter which thread the code is running on.\n\n```\nJavaLocalRef<jstring> java_str(env, env->NewStringUTF(str));\nenv->CallVoidMethod(clazz, method_id, java_str.get());\n```\n\n","comments":[],"labels":["T-Internal"]},{"title":"Managed and Unmanaged annotations","body":"**Feature Request**\nWould it be possible to add @ManagedObject @UnmanagedObject annotations?\n\npublic void task1(@ManagedObject object){\n} \n\npublic void task2(@UnmanagedObject object){\n}","comments":["The same object can both be managed and unmanaged, so an annotation, which is compile time information, is not enough. We have `RealmObject.isManaged()\/RealmList.isManaged()` that can provide this information.","So in plain java\r\n```\r\nvoid rootMethod(Object o){\r\n   if(o==null){\r\n      task1(o) \/\/task1(@Nullable Object o)\r\n   }else{\r\n     task2(o)}  \/\/task2(@Nonnull Object o)\r\n   }\r\n}\r\n```\r\n\r\ncan be annotated, but in can't be done with realm\r\n```\r\nvoid rootMethod(Object o){\r\n   if(o.isManaged()){\r\n      task1(o) \/\/task1(@Managed Object o)\r\n   }else{\r\n     task2(o)}  \/\/task2(@Unmanaged Object o)\r\n   }\r\n}\r\n```\r\n?","Ah, like that. I misunderstood you then. That might be possible, yes, but it will require an IntelliJ plugin + Lint checks to function, which we don't currently have."],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"ByteBuffer object is mistakenly considered as a valid value for binary fields.","body":"`RealmFieldType.BINARY.isValid(Object)` returns `true` against `ByteBuffer` object.\nHowever, we actually don't accept `ByteBuffer` as a value of binary field for now.\n\nhttps:\/\/github.com\/realm\/realm-java\/blob\/v3.4.0\/realm\/realm-library\/src\/main\/java\/io\/realm\/RealmFieldType.java#L88\n\n","comments":[],"labels":["T-Bug"]},{"title":"Document file system layout","body":"When sync is enabled, the layout of the file system is following some strict rules. In order for people to find their Realm files while developing\/debugging, we should document it.\n\nFor an app with two users (one with permission to read the other user's Realm), the layout is:\n\n```\n|____:\n| |____realm-object-server:\n| | |____225d59c688d1c5c5d7a40446afab24da:\n| | | |____225d59c688d1c5c5d7a40446afab24da:\n| | |     __management\n| | |     __management.lock\n| | |     __management.management\n| | |     default\n| | |     default.lock\n| | |     default.management\n| | |____7f974624dce40d7b16db2ba6cf30c654:\n| | | |____225d59c688d1c5c5d7a40446afab24da:\n| | |      default\n| | |      default.lock\n| | |      default.management\n| | | |____7f974624dce40d7b16db2ba6cf30c654:\n| | |      default\n| | |      default.lock\n| | |      default.management\n| | |____io.realm.object-server-utility:\n| | | |____metadata:\n| | |      sync_metadata.realm\n| | |      sync_metadata.realm.lock\n| | |      sync_metadata.realm.management\n| | |      sync_metadata.realm.note\n```\n\nIt will probably also be worth to mention that `io.realm.object-server-utility` will only be deleted when the app is uninstalled.\n\n","comments":[],"labels":["T-Doc"]},{"title":"Multi processes support for sync realm","body":"Needs #1300 to be closed first.\n\nCurrently running multiple processes in the same apk with sync enabled will be problematic:\n1. They both will start a sync client thread.\n2. They both have `SyncManager` initialized with the same directory.\n\nThis feature seems to be supported by sync already, but we need to enable it with some modification in Object Store.\n\nfrom @simonask \n> It has been fixed, but I don't think Object Store exposes an API to enable it (it has to set a flag to tell Sync that it should not start a sync agent)\n\nfrom @morten-krogh \n> But if you make Realm changes in another process, you must make sure to call nonsync_transact_notify() on the session object in the process where the sync client lives. Otherwise the changes will not be uploaded immediately.\n\nDiscussion thread on slack https:\/\/realmio.slack.com\/archives\/C04LCFHDL\/p1497861349294960","comments":[],"labels":["T-Enhancement"]},{"title":"Object changelisteners does not trigger if a linked object changes","body":"#### Goal\n\nDetect changes of nested objects of a single `RealmObject` using `RealmChangeListener` .\nUnderstand the differences between `RealmChangeListener` on `RealmObject` and `RealmResults`.\n\n#### Expected Results\n\n`RealmChangeListener` of a single `RealmObject` would listen to changes of its nested objects.\n`RealmChangeListener` of a single `RealmObject` would listen to more changes than the `RealmChangeListener` of `RealmResults`.\n\n#### Actual Results\n\n`RealmChangeListener` of a single `RealmObject` doesn't listen to changes of its nested objects.\n`RealmChangeListener` of `RealmResults` listens to changes of its children's nested objects.\n\n#### Steps & Code to Reproduce\n\nI created a simple Android project to reproduce my use case:\nhttps:\/\/github.com\/jpmcosta\/RealmTestProject\/tree\/262ee9099b47852c2b26bc2f7e3874c8670e6264\n\nSchema:\n- `App` object contains a `RealmColor` property. That's just a (bad) pattern to illustrate the issue.\n\nHow to reproduce the issue:\n- there's a list with a single `App` object\n- click on that object to randomly change the `value` of its `RealmColor` property\n- when `RealmColor.value` changes we want to:\n  - change the `App` text color\n  - change the FAB color\n\nTo change the `App` text color we add `RealmChangeListener` to `RealmResults<App>` and call `notifyDatasetChanged` when a change is detected.\nTo change the FAB color we add a `RealmChangeListener` to the `App` object and update its color when a change is detected.\n\nIssue:\n- The FAB color is not updated properly.\n\n#### Version of Realm and tooling\nRealm version: 3.3.2","comments":["I guess what I'm requesting is to have a way of listening to nested objects changes when adding a `RealmChangeListener` to a single `RealmObject`. A parameter would suffice.","> To change the FAB color we add a RealmChangeListener to the App object and update its color when a change is detected.\r\n\r\nYou need to add it to the `RealmColor` object, which also needs to be retained as field reference.\r\n\r\nhttps:\/\/github.com\/realm\/realm-java\/issues\/4598#issuecomment-299401156","@Zhuinden yes, that would work. I understand that `App` itself has not changed. But then, why does the `RealmChangeListener` in `RealmResults<App>` detect a change? Also, if I have 10 nested objects, should I need to add 10 different listeners?","Well as you said, you could also refer to your single object with a `RealmResults` and then you'll get nested link notifications, as specified in that comment I linked.\r\n\r\nOf course, I personally don't know why this is how the notification behavior works.","@Zhuinden for some reason I missed the comment you linked. Sorry about that.\r\nRegarding to referring to my single object with a `RealmResults`, how would that work? Would I need to query for the object with a `findAll` call, or is there a better way?\r\nIn my real use case I want to update a state based on the first element of a list. That could complicate things quite a bit.","Yeah, `realm.where(MyObject.class).equalTo(\"id\", myObjectId).findAll();` works, and if it's empty then it's not there, and if it's not empty then the first object is your object.","Thanks for your help, but I'm still not sure about using a query to keep a deep listener on the first item of a list.\r\nThat would require to requery every time the first item changes (it's common), and I'm not sure about the implications on performance.\r\nI still think it would be best to have a parameter to specify whether or not the listener should detect nested objects changes, but that would require some changes to realm-java.\r\nThanks for the answer. \ud83d\ude42\r\n\r\nEdit: if you don't think it's worth discussing `RealmChangeListener` behavior at the current time, feel free to close the issue, as my use case is already solved. \ud83d\udc4d ","I believe we have an issue somewhere for listening to specific fields, including linked fields. That sounds like something similar to this.  I'll try to find it.","@cmelchior I think I detected a case where `RealmChangeListener` is called, but there weren't any changes to the object (or its children for that matter).\r\nI still haven't found time to reproduce it consistently. If I do, should I update this issue, or open a new one?","Current Object Store implementation doesn't support notifications of `Object`'s linked field changes. Maybe there are some concerns from @tgoyne to support that?","I've come along this and want to get notified if a nested object changes (so I can update the UI showing the nested object).\r\n\r\nI had the listener attached to `RealmObject` (just like in the question here) which does not work (as mentioned) *but* when using `findAllAsync()` to get a `RealmResult` it doesn't get notified either.\r\n\r\nSo no luck for me using this workaround \ud83d\ude22.\r\nI'm using Realm ~~2.0.1~~ 4.3.0.\r\n\r\n---\r\n\r\nHas this changed lately? How can I get notified about changed on nested objects?\r\n\r\nIs it related to the use of `findAllAsync()` instead of the normal `findAll()`? I've linked the async-result to be a `LiveData` so it can be used with a `ViewModel` (which works nice except of this nested-listener-problem).","2.0.1 is like super old o_o\r\n\r\nIn fact, in Realm before 3.0.0, all change listeners that belong to a RealmResults should have been called for the change of any linked object property change. ","Oh yea, my fault - using 4.3.0 (copy & paste error...)","`findAllAsync` should be called for linked objects. Do you have a sample that reproduces this? How deep links are we talking about? ","Basically I have the following:\r\n\r\n```\r\n- Foo\r\n - id\r\n - name\r\n - RealmList<Bar>\r\n\r\n- Bar\r\n - id\r\n - name\r\n```\r\n\r\nI'm fetching all Foo with `findAllAsync()` and hook the listener to this result.\r\nWhen now `Bar.name` changes, I want the listener to be called (which it isn't). This does not work for `findFirstAsync()` nor `findAllAsync()`.","Ok, some updates:\r\n\r\nI've tried `findFirst()`, `findFirstAsync()`, `findAll()` and `findAllAsync()` and it looks like **only `findAll()`** calls the listener for changes on the nested object.\r\n\r\nSo I'd like to extend this issue to also update the `...Async()`-methods to call the listener like the non-async version.","@beeender can this be possible? ","@hardysim @Zhuinden \r\n\r\nThis is documented, but maybe it is a bit difficult to find?\r\n\r\n>  If a field points to another RealmObject this listener will only be triggered if the field is set to a new object or null. Updating the referenced RealmObject will not trigger this listener.\r\n\r\n> If a field points to a RealmList, this listener will only be triggered if one or multiple objects are inserted, removed or moved within the List. Updating the objects in the RealmList will not trigger this listener. \r\n\r\nhttps:\/\/realm.io\/docs\/java\/4.3.1\/api\/io\/realm\/RealmObjectChangeListener.html#onChange-T-io.realm.ObjectChangeSet-","Ah, ok - I had a look at the `addListener()`-Methods only and not at the doc of the listener itself (hard to see using lambdas).\r\n\r\nSo no chance for the listeners on single objects (hence this issue here).\r\n\r\n---\r\n\r\nBut for the lists: It's working for the non-async-method - can we get it for async as well? Should I open a new issue for this?","@beeender my question was that they say Async method doesn't get called for linked object change, but that's not expected behavior. Especially considering internally the only difference is whether query is immediately loaded or not. ","@Zhuinden \r\n> my question was that they say Async method doesn't get called for linked object change, but that's not expected behavior. Especially considering internally the only difference is whether query is immediately loaded or not.\r\n> I've tried findFirst(), findFirstAsync(), findAll() and findAllAsync() and it looks like only findAll() calls the listener for changes on the nested object.\r\n\r\nThis doesn't seem to be possible ","Then it's probably just that `findAllAsync` was tested in such a way that RealmResults was not stored as field variable and then GC ate it and notification didn't happen ","Any solution I have the same problem, there is object class with field RealmList, listener on query of the highest hierarchy object with findAllAsync, but not register changes on the the field RealmList, and the results of the query, when I get RealmList from the object is very messed. \r\nWith query with findAll is worked correctly.\r\n","You probably just don't keep a strong reference to the RealmList. ","How it should keep strong reference, I am new in Realm","Just like https:\/\/stackoverflow.com\/a\/43178078\/2413303 it also applies for RealmList ","I see, but I think that's not my case, let say I use the previous example\r\n- Foo\r\n - id\r\n - name\r\n - RealmList<Bar> bars\r\n\r\n- Bar\r\n - id\r\n - name\r\n\r\nI make query RealmResults<Foo> results=  realm.where(Foo.class).findAllAsync().\r\nThen I add listener on results when onChange event is triggered, in the event body I try to access results.getbars(), the list of Bar is messed\r\n    ","I don't understand what `is messed` means, please provide a definition or a reproducible sample. ","Messed means. when I try to get the bar list and read, one time the name of bar is AtJohny, the other time is Anthony, I get objects in realmlist not like I put, I get them randomly","Does this happen in RealmChangeListener? Because that should be impossible on UI thread unless you do it in onPostExeute ","Yes that's happen on RealmChangeListener, in the method onChange, the listener is in onCreate method of activity. I get RealmList not consistent, I get in object's field RealmList elements from other RealList that are in realmbase.  If it's form help I can send link from the files.","@ileste your problem doesn't seem to be (entirely?) related to this issue. You should probably create a new issue explaining it.","I have similar problem, I suppose, like @hardysim","You need to keep a strong reference to the RealmList.\r\n\r\nWithout code, I can't tell if you're messing something up, otherwise.\r\n\r\nIt should be **impossible** that the RealmList is inconsistent in RealmChangeListener. Notifiers are called only when the queries are all refreshed, I think? Although of course, object-store can verify this. \r\n\r\nIf you can provide a reproducible sample, that is great!","I need put let say like the example, in Bar class @LinkingObjects(\"bars\") private final RealmResults<Order> foos = null; and everything is ok,  good","I want to warm up this a bit because I just realized that my latest update on realm broke this for me (we're not sure why it worked for me but it did). Now, it behaves just like documented:\r\n\r\n> If a field points to another RealmObject this listener will only be triggered if the field is set to a new object or null. Updating the referenced RealmObject will not trigger this listener.\r\n\r\n---\r\n\r\nTo sum it up (and get back to the original topic here):\r\nI want to get notified, when a *nested* object changes. Is this possible?",">we're not sure why it worked for me but it did\r\n\r\nYou probably were updating the parent object in the same transaction, without really thinking about it.\r\n\r\n> I want to get notified, when a _nested_ object changes. Is this possible?\r\n\r\nMy ugly solution is to update the parent object \"manually\". Usually, I have an `updatedAt: Long` property in the parent, which the child object is responsible to update whenever it is updated.","I've just realized that my new way of dealing with Realm + LiveData is a workaround (in some cases) as well:\r\n\r\nI'm calling `RealmChangeListener.onChange()` manually in `LiveData.onActive()`. This way, my listener in Activity A gets notified when I update the model in Activity B and get back. See https:\/\/stackoverflow.com\/a\/53336629\/2170109.\r\n\r\nBut this is just coincidence (because I get a notification on the parent-object and not the nested-one). Therefore, this is *no solution* to this issue here (but a workaround for my use case).","With the changes introduced to ObjectStore as part of https:\/\/github.com\/realm\/realm-cocoa\/pull\/7249, it should be possible for us to add support for this. We would need to evaluate if it requires any API changes."],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Converting ByteCodeTransformer plugin to Kotlin","body":"ButterKnife converted its Groovy-based Gradle Plugin to Kotlin in this commit: https:\/\/github.com\/JakeWharton\/butterknife\/commit\/398301377783a79485799a55a0333467d2ecc400\n\nMaybe Realm could also update the ByteCodeTransformer to Kotlin, and ditch Groovy?\n\n","comments":["mmmmm.... What a lovely idea."],"labels":["T-Internal","O-Community"]},{"title":"Better ability to completely reset Sync tests","body":"Fallout from #4760 \n\nRight now it is rather hard to do a full reset of tests involving synchronized Realms as it involves calling both `SyncManager.reset()` and nulling out `BaseRealm.applicationContext`. This also means that artifacts on the filesystem are left behind after each sync test, which is a weird test failure waiting to happen.\n\nWe should expose one single method that would completely wipe all Realm instances + re-initialize everything correctly. \n\nPerhaps something like:\n\n```\nRealm.resetAndInit(Context context); \/\/ package protected\n```\n\n","comments":["it is much better to just pass a new temp dir to init the `SyncManager`.\r\nAlso, creating a JUnit4 Rule `SyncManagerRule` to handle those may look cleaner and better.","It is more than just creating a dir, e.g Sync has some codepaths that are not touched until certain variables are reset. Same with `Realm.init()` .. This is also being tracked here: https:\/\/github.com\/realm\/realm-object-store\/issues\/207\r\n\r\nExample. If you don't set `BaseRealm.applicationContext = null`, calling `Realm.init()` multiple times does nothing, and if you don't reset Object Store users, the filesystem folders and the meta Realms used by Object Store will not be re-created."],"labels":["T-Internal"]},{"title":"Retire C++ macros for type conversion","body":"Fallout from internal architecture discussion.\n\nRight now we have a number of macros for converting to commonly used Core classes:\n\n* TBL\n* ROW\n* SG\n* and more (see https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/cpp\/util.hpp#L77)\n\nWith C++ 14 and the introduction of `auto` we can instead make the callsites more explicit and readable by replacing. \n\n```\n\/\/ Current\nRow* row = ROW(ptr);\n\/\/ with new\nauto row = reinterpret_cast<Row*>(ptr)\n```\n\n","comments":["I always wondered; that's longer, so why?\r\n\r\nBecause macros are magic?"],"labels":["T-Internal"]},{"title":"Support queries across backlinks using the DynamicRealm API","body":"#4704 added support for queries in typed model classes\n\nWe still need to add support for this in DynamicRealmObjects. A proposed syntax for this was given in #2904. \n\nWe already have support for getting a linking object view using `dynamicRealmObject.linkingObjects(\"class\", \"field\")`, so it is possible to query directly on it. Support for combining queries on the backlinks with other fields are still missing though, e.g.\n\n````\nrealm.where(\"Dog\")\n  .equalTo(\"linkingObjects(Person.dog).name), \"john\") \/\/ Syntax from #2904\n  .equalTo(\"name\", \"Fluffy\")\n  .findAll()\n```\n\nIs not possible","comments":["> It isn't possible to combine queries on the backlinks with other fields though\r\n\r\nis this a general limitation of backlink queries? You can combine normal link queries with field queries, so that would strike me as odd.","Technically I think you could probably still do\r\n\r\n``` java\r\nrealm.where(\"Dog\")\r\n  .equalTo(\"linkingObjects(Person.dog).name\", \"john\") \/\/ Syntax from #2904\r\n  .findAll()\r\n  .equalTo(\"name\", \"Fluffy\")\r\n  .findAll()\r\n```","Sorry, wrong wording by me. This is just tracking dynamically specifying a linking object field (which `linkingObjects(Class.linkField).field` does). As soon that is implemented you should have the exact same query capabilities across Dynamic and normal Realms.","Ah, so you can't have unnamed backlinks yet. That's a shame, it looks funky \ud83d\ude1c \r\n\r\n`@LinkingObjects(\"dogs\")` it is then, glad to see it got merged! \ud83d\ude42 ","I really hate the syntax, but all alternative ideas I have all seems worse \ud83d\ude22 ","I actually like the syntax, it just requires you to wrap your head around it properly \ud83d\ude04 ","```\r\nbacklinks using the @links.Class.property syntax.\r\nAdd support for @links.@count which gives the count of all backlinks to an object.\r\n```\r\n\r\nParserssss"],"labels":["T-Enhancement"]},{"title":"Lint Checks: Threading warnings + wrong copy of unmanaged objects.","body":"There are no lint warnings on mistakes from developers when using realm-managed objects.\n\nPlease show a warning, to start with when:\n\n1. a setter of a managed model object is called without being in a transaction.\n2. a transaction is started within a transaction.\n\nThese 2 are vital. \n\nIt would be great if you could also show a warning when:\n\n1. When you use a model object on a different thread than it was created on.\n2. When you use a Realm object on a different thread than it was created on.\n3. CopyFromRealm() is called on an unmanaged object.\n\nIt is a real problem at the moment because we get crashes on code that is not accessed frequently, which makes us quite insecure about our codebase. Unit testing this, to find these bugs, on Realm seems impossible as well, unless I use instrumentation tests, which are slow and cumbersome.\n\nPlease add lint warnings for this.","comments":["We have a growing number of lint checks we do want to add, so thank you for the input. \r\n\r\nNote however that the errors you describe cannot be detected in all cases by static analysis. We might be able to detect it in the more simple cases though.\r\n"],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Different modes when updating lists using copyToRealmOrUpdate","body":"From https:\/\/forums.realm.io\/t\/how-realmlist-update-work\/342\n\nThe basic problem is that updating lists using `copyToRealmOrUpdate` will always replace the entire list since the list is considered a field just like any others. This has the advantage of being easy to implement and explain (delete content, then insert new), but sometimes it is not the behavior needed. \n\nSometimes you will want to append to an existing list. Think API's that return partial updates that should be combined into full results locally (like paged requests).\n\n```\n\/\/ Rest API \/user\/tweets?page=1&size=10\n{\n  \"userId\" : 1\n  \"userName\" : \"John\"\n  \"tweets\" : [\n     {  tweet1 },\n     {  tweet2 },\n     {  tweet3 },\n     ...\n  ]\n} \n\n\/\/ Realm model class\npublic class User extends RealmObject {\n  @PrimaryKey long userId;\n  String userName;\n  RealmList<Tweet> tweets;\n}\n\n \/\/ This would override the the list of tweets every time a page is loaded, whic is not the intended behaviour\nrealm.copyToRealmOrUpdate(restApi.getTweets(page));\n```\n\nOne solution could be to have an extra mode `UpdateMode`:\n\n```\nrealm.copyToRealmOrUpdate(restApi.getTweets(page), UpdateMode.APPEND_LISTS);\n```\n\nThis approach isn't without problems though:\n* How many different modes do we need to support: `APPEND_TO_LISTS`, `REPLACE_LISTS` (default)`, others? I could worry this would open a can of worms in terms of complexity.\n\n* This should also be implemented for `insertOrUpdate` and all our JSON methods\n\n\nOther ideas?","comments":["this is so beautiful idea\r\nhow many developers I have to get here to move this task from backlog to current? :)"],"labels":["T-Feature","Pipeline-Idea-Backlog"]},{"title":"RealmConfiguration.Builder with DocumentFile","body":"#### Goal\n\nWe can't get write access to some paths on SD card using File object. It can be done only using DocumentFile. The problem is that RealmConfiguration do not take DocumentFile as parameter. Of course, by the way, it is impossible to create directory inside of \"unwritable using File\" directory and then use those as path for new File object - it won't have write access too.\n\nHere is a problem on stackoverflow: [LINK](https:\/\/stackoverflow.com\/questions\/44215174\/realmconfiguration-builder-with-documentfile)\n\n#### Expected Results\nI want RealmConfiguration.Builder to use DocumentFile\n\nWhich Android version and device: android 7. Any device","comments":["Hi @MykhIvanov \r\n\r\nReal doesn't support `DocumentFile` at this point in time, so I'm afraid you are currently out of luck unless you can find a way to map a DocumentFile to a local File reference.\r\n\r\nAlso one of the problems with DocumentFile is that it might reference a file that doesn't exist locally, which would prevent Realm from using it. So it is unclear if Realm could ever support this.\r\n\r\nNote that we recently added `readOnly()` to the `RealmConfiguration`. So if you can construct a File reference and mark it as `readOnly()` it might work?\r\n\r\n\r\n"],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"java.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 310","body":"#### Goal\nAvoid crashes.\n\n#### Expected Results\nCrashes do not happen. Transactions completes successful without crashes.\nAlso I want to know what kind of code can lead to this crash.\n\n#### Actual Results\nError. StackTrace:\n\n```java\njava.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 310\n\tat io.realm.internal.Collection.nativeStartListening(Native Method)\n\tat io.realm.internal.Collection.addListener(Collection.java:490)\n\tat io.realm.internal.Collection.addListener(Collection.java:497)\n\tat ...\n```\n\n#### Steps & Code to Reproduce\nI do not know how to reproduce it.\nI haven't got anything helpful after searching all the issues and in stackoverflow.com. And I also searched the crash message Cannot create asynchronous query while in a write transaction in realm source code but found nothing. It's not a new issue and I first found this crash about one month ago.\nI found some similar problems in I-OS Realm, but there is no information about the solution\nhttps:\/\/github.com\/realm\/realm-cocoa\/issues\/4539\nhttps:\/\/github.com\/realm\/realm-cocoa\/issues\/4231\nhttps:\/\/stackoverflow.com\/questions\/42012222\/realm-why-are-notification-blocks-triggered-when-a-write-transaction-begins \n\n#### Code Sample\nI've read the doc and cannot find what's wrong with my code. I know how to avoid common problems like nested transactions. But this one is killing me.\nOur application (en.techops.brief) uses several threads and asynchronous transactions.\nThe problem periodically occurs in different parts of the code, here are two cases and a stacktrace:\n\n**Case 1: Useq**\nStackTrace:\nhttps:\/\/gist.github.com\/andrey7mel\/e121d0e856bb20d536d970a314bdf3b0 \nRealm 3.3.0\n\n```java\n05-25 18:25:02.659 15486-15486\/ru.techops.brief.debug E\/REALM_JNI: jni: ThrowingException 8, Cannot create asynchronous query while in a write transaction in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 310, .\n05-25 18:25:02.659 15486-15486\/ru.techops.brief.debug E\/REALM_JNI: Exception has been thrown: Cannot create asynchronous query while in a write transaction in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 310\n05-25 18:25:02.666 15486-15486\/ru.techops.brief.debug E\/ChatPresenter.l()[351]: Error while getting chat events: \njava.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 310\n\tat io.realm.internal.Collection.nativeStartListening(Native Method)\n\tat io.realm.internal.Collection.addListener(Collection.java:490)\n\tat io.realm.internal.Collection.addListener(Collection.java:497)\n\tat io.realm.RealmResults.addChangeListener(RealmResults.java:171)\n\tat io.realm.rx.RealmObservableFactory$6.call(RealmObservableFactory.java:153)\n\tat io.realm.rx.RealmObservableFactory$6.call(RealmObservableFactory.java:137)\n\tat rx.Observable.unsafeSubscribe(Observable.java:10256)\n\tat rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:45)\n\tat rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:30)\n\tat rx.Observable.unsafeSubscribe(Observable.java:10256)\n\tat rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n\tat rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n\tat rx.Observable.unsafeSubscribe(Observable.java:10256)\n\tat rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:155)\n\tat rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:77)\n\tat rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n\tat rx.internal.operators.OperatorCast$CastSubscriber.onNext(OperatorCast.java:69)\n\tat rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n\tat rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n\tat io.realm.rx.RealmObservableFactory$10$1.onChange(RealmObservableFactory.java:293)\n\tat io.realm.rx.RealmObservableFactory$10$1.onChange(RealmObservableFactory.java:289)\n\tat io.realm.ProxyState$RealmChangeListenerWrapper.onChange(ProxyState.java:46)\n\tat io.realm.internal.OsObject$ObjectObserverPair.onChange(OsObject.java:69)\n\tat io.realm.internal.OsObject$Callback.onCalled(OsObject.java:88)\n\tat io.realm.internal.OsObject$Callback.onCalled(OsObject.java:73)\n\tat io.realm.internal.ObserverPairList.foreach(ObserverPairList.java:108)\n\tat io.realm.internal.OsObject.notifyChangeListeners(OsObject.java:236)\n\tat io.realm.internal.SharedRealm.nativeBeginTransaction(Native Method)\n\tat io.realm.internal.SharedRealm.beginTransaction(SharedRealm.java:262)\n\tat io.realm.BaseRealm.beginTransaction(BaseRealm.java:348)\n\tat io.realm.BaseRealm.beginTransaction(BaseRealm.java:343)\n\tat io.realm.Realm.beginTransaction(Realm.java:131)\n\tat io.realm.Realm.executeTransaction(Realm.java:1441)\n\tat ru.techops.brief.model.database.DataBase.executeTransaction(DataBase.java:1720)\n\tat ru.techops.brief.model.database.DataBase.lambda$null$1(DataBase.java:149)\n\tat ru.techops.brief.model.database.DataBase$$Lambda$160.call(Unknown Source)\n\tat rx.internal.operators.OnSubscribeCreate.call(OnSubscribeCreate.java:72)\n\tat rx.internal.operators.OnSubscribeCreate.call(OnSubscribeCreate.java:32)\n\tat rx.Observable.unsafeSubscribe(Observable.java:10256)\n\tat rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)\n\tat rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144)\n\tat rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:224)\n\tat rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\n\tat android.os.Handler.handleCallback(Handler.java:751)\n\tat android.os.Handler.dispatchMessage(Handler.java:95)\n\tat android.os.Looper.loop(Looper.java:154)\n\tat android.app.ActivityThread.main(ActivityThread.java:6688)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1468)\n\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1358)\n```\n\nCode transaction:\n\n```java\n\/\/ ru.techops.brief.model.database.DataBase.lambda$null$1(DataBase.java:149)\nsaveUseqSubject\n                .onBackpressureLatest()\n                .concatMap(useq -> Observable.create(emitter -> {\n                    executeTransaction(realm -> {\n                        Useq useqObj = realm.where(Useq.class).findFirst();\n                        if (useqObj == null) {\n                            useqObj = new Useq();\n                        }\n                        useqObj.setUseq(useq);\n                        realm.insertOrUpdate(useqObj);\n                        emitter.onNext(useq);\n                    });\n                }, Emitter.BackpressureMode.BUFFER))\n                .subscribe(useq1 -> Timber.v(\"Saved to database Useq=\" + useq1),\n                        e -> Timber.e(e, \"Error while saving useq to Realm\"));\n\n\/\/ru.techops.brief.model.database.DataBase.executeTransaction(DataBase.java:1720)\nprivate void executeTransaction(Realm.Transaction transaction) {\n   try (Realm realm = getRealm()) {\n       realm.executeTransaction(transaction);\n   }\n}\n \n```\n\n**Case 2:  SaveEvents**\nStacktrace:\nhttps:\/\/gist.github.com\/andrey7mel\/10e6b54e741d99d08bd2f6174cece094 \nRealm 3.1.4\n\n```java\nNon-fatal Exception: java.lang.IllegalStateException: Cannot create asynchronous query while in a write transaction in \/home\/cc\/repo\/realm\/release\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_Collection.cpp line 310\n   at io.realm.internal.Collection.nativeStartListening(Collection.java)\n   at io.realm.internal.Collection.addListener(Collection.java:490)\n   at io.realm.internal.Collection.addListener(Collection.java:497)\n   at io.realm.RealmResults.addChangeListener(RealmResults.java:136)\n   at io.realm.rx.RealmObservableFactory$6.call(RealmObservableFactory.java:153)\n   at io.realm.rx.RealmObservableFactory$6.call(RealmObservableFactory.java:137)\n   at rx.Observable.unsafeSubscribe(Observable.java:10346)\n   at rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:45)\n   at rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:30)\n   at rx.Observable.unsafeSubscribe(Observable.java:10346)\n   at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n   at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n   at rx.Observable.unsafeSubscribe(Observable.java:10346)\n   at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:155)\n   at rx.internal.operators.OperatorSwitch$SwitchSubscriber.onNext(OperatorSwitch.java:77)\n   at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:77)\n   at rx.internal.operators.OperatorCast$CastSubscriber.onNext(OperatorCast.java:69)\n   at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n   at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onNext(OnSubscribeFilter.java:76)\n   at io.realm.rx.RealmObservableFactory$10$1.onChange(RealmObservableFactory.java:293)\n   at io.realm.rx.RealmObservableFactory$10$1.onChange(RealmObservableFactory.java:289)\n   at io.realm.ProxyState$RealmChangeListenerWrapper.onChange(ProxyState.java:46)\n   at io.realm.internal.OsObject$ObjectObserverPair.onChange(OsObject.java:67)\n   at io.realm.internal.OsObject$Callback.onCalled(OsObject.java:86)\n   at io.realm.internal.OsObject$Callback.onCalled(OsObject.java:71)\n   at io.realm.internal.ObserverPairList.foreach(ObserverPairList.java:108)\n   at io.realm.internal.OsObject.notifyChangeListeners(OsObject.java:149)\n   at io.realm.internal.SharedRealm.nativeBeginTransaction(SharedRealm.java)\n   at io.realm.internal.SharedRealm.beginTransaction(SharedRealm.java:246)\n   at io.realm.BaseRealm.beginTransaction(BaseRealm.java:309)\n   at io.realm.Realm.beginTransaction(Realm.java:128)\n   at io.realm.Realm.executeTransaction(Realm.java:1408)\n   at ru.techops.brief.model.database.DataBase.executeTransaction(DataBase.java:1729)\n   at ru.techops.brief.model.database.DataBase.saveEventsSync(DataBase.java:636)\n   at ru.techops.brief.model.Model.lambda$saveEventsSync$85(Model.java:888)\n   at ru.techops.brief.model.Model$$Lambda$70.call(Unknown Source)\n   at rx.internal.operators.OnSubscribeMap$MapSubscriber.onNext(OnSubscribeMap.java:69)\n   at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276)\n   at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:126)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.setProducer(OnSubscribeConcatMap.java:329)\n   at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102)\n   at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138)\n   at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129)\n   at rx.Observable.unsafeSubscribe(Observable.java:10346)\n   at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)\n   at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)\n   at rx.Observable.unsafeSubscribe(Observable.java:10346)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n   at rx.observers.SerializedObserver.onCompleted(SerializedObserver.java:176)\n   at rx.observers.SerializedSubscriber.onCompleted(SerializedSubscriber.java:64)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:246)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n   at rx.observers.SerializedObserver.onCompleted(SerializedObserver.java:176)\n   at rx.observers.SerializedSubscriber.onCompleted(SerializedSubscriber.java:64)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:246)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.innerCompleted(OnSubscribeConcatMap.java:209)\n   at rx.internal.operators.OnSubscribeConcatMap$ConcatMapInnerSubscriber.onCompleted(OnSubscribeConcatMap.java:345)\n   at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:656)\n   at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)\n   at rx.internal.operators.OperatorMerge$MergeSubscriber.onCompleted(OperatorMerge.java:281)\n   at rx.internal.operators.OnSubscribeMap$MapSubscriber.onCompleted(OnSubscribeMap.java:97)\n   at rx.internal.operators.OperatorOnErrorResumeNextViaFunction$4.onCompleted(OperatorOnErrorResumeNextViaFunction.java:101)\n   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.checkTerminated(OperatorObserveOn.java:281)\n   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.call(OperatorObserveOn.java:216)\n   at rx.android.schedulers.LooperScheduler$ScheduledAction.run(LooperScheduler.java:107)\n   at android.os.Handler.handleCallback(Handler.java:815)\n   at android.os.Handler.dispatchMessage(Handler.java:104)\n   at android.os.Looper.loop(Looper.java:207)\n   at android.app.ActivityThread.main(ActivityThread.java:5896)\n   at java.lang.reflect.Method.invoke(Method.java)\n   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:948)\n   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:809)\n```\n\nCode:\n\n```java\n\/\/ ru.techops.brief.model.Model.lambda$saveEventsSync$85(Model.java:888)\n public Completable saveEventsSync(List<WsUpdateEventNew> updates) {\n        List<Event> events = new ArrayList<>();\n        for (WsUpdateEventNew update : updates) {\n            events.add(update.getEvent());\n        }\n        return Observable.from(events)\n                .concatMap(event -> {\n                    Observable<Object> res = Observable.empty();\n                    User sender = dataBase.getUserSyncFromRealm(event.getSenderId());\n                    if (sender == null) {\n                        res = res.concatWith(getUserInfoFromServer(event.getSenderId()));\n                    }\n                    Peer fwdSenderPeer = event.getFwdSenderPeer();\n                    if (fwdSenderPeer != null) {\n                        User fwdSender = dataBase.getUserSyncFromRealm(fwdSenderPeer.getPeerId());\n                        if (fwdSender == null) {\n                            res = res.concatWith(getUserInfoFromServer(fwdSenderPeer.getPeerId()));\n                        }\n                    }\n                    Peer peer = event.getPeer();\n                    Const.NotifyMode notifyMode = dataBase.getPeerNotifyMode(peer);\n                    if (notifyMode == Const.NotifyMode.NOTIFY_UNKNOWN) {\n                        switch (peer.getType()) {\n                            case PeerType.USER:\n                                res = res.concatWith(getUserInfoFromServer(event.getPeer().getPeerId()));\n                                break;\n                            case PeerType.GROUP:\n                                res = res.concatWith(getGroupInfoFromServer(event.getPeer().getPeerId()));\n                                break;\n                        }\n                    }\n                    if (event.getReplyToId() != 0) {\n                        res = res.concatWith(loadEventIfNeed(event.getPeer(), event.getReplyToId()).ignoreElements());\n                    }\n                    return res;\n                })\n                .concatWith(Observable.just(events)\n                        .map(e -> {\n                        \/\/ (Model:888)       \n                            dataBase.saveEventsSync(e);\n                            return e;\n                        }))\n                .toCompletable();\n    }\n \n \n\/\/ru.techops.brief.model.database.DataBase.saveEventsSync(DataBase.java:636)\n@WorkerThread\npublic void saveEventsSync(List<Event> events) {\n    executeTransaction(realm -> {\n       for (Event event : events) {\n           saveEventToRealm(event, realm);\n       }\n   });\n}\n\n\n\/\/ ru.techops.brief.model.database.DataBase.executeTransaction(DataBase.java:1729)\n    private void executeTransaction(Realm.Transaction transaction) {\n        try (Realm realm = getRealm()) {\n            realm.executeTransaction(transaction);\n        }\n    }\n```\n\n#### Version of Realm and tooling\nRealm version(s): 3.1.4 - 3.3.0\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 2.3.2\n\nWhich Android version and device: Android 5 - 6 - 7, many devices\n![image](https:\/\/cloud.githubusercontent.com\/assets\/5254885\/26503522\/b535c6ac-4249-11e7-8fe0-be1cf08786cb.png)\n\n","comments":["Well the error technically means that you have synchronous Realm write on the UI thread, and at some point it tries to call `asObservable` in a switchMap operation on an async query results, and it breaks. \r\n\r\nBut I'm not sure exactly where it happens, except that `beginTransaction` wants to call the change listeners, and that's when the crash is triggered. \r\n\r\nI am not a Realm person, by the way, so this is by no means the official support response. ","This looks weird to me.  I've asked some of our ObjectStore experts to have a look.  Unfortunately, we have holidays in the US, Denmark, and the UK, on Monday, so this may not get attention until mid next week.","Previously it just silently converted async query to sync query, it didn't throw exception :D","It is a known restriction from Object Store that `Results.addChangeListener()` cannot be called in the transaction now. This needs to be documented in the javadoc.","@beeender Adding that restriction to `findAllAsync()` would probably be more appropriate?\r\n@andrey7mel Can you also post the `saveEventToRealm(event, realm);` method in your code above?","@cmelchior due to the nature of how Object Store running the queries, even `findAll()` will be put into background thread if it is possible. That means calling `findAll().addChangeListener()` inside a transaction is not allowed as well.","@cmelchior \r\n```java\r\nprivate void saveEventToRealm(Event event, Realm bgRealm) {\r\n        User sender = bgRealm.where(User.class).equalTo(\"id\", event.getSenderId()).findFirst();\r\n        if (sender != null) {\r\n            event.setSender(sender);\r\n        }\r\n        if (event.getFwdSenderPeer() != null) {\r\n            User fwdUser = bgRealm.where(User.class).equalTo(\"id\", event.getFwdSenderPeer().getPeerId()).findFirst();\r\n            if (fwdUser != null) {\r\n                event.setFwdSender(fwdUser);\r\n            }\r\n        }\r\n\r\n        ServiceAction action = event.getAction();\r\n        if (action != null && action.getUserId() != 0) {\r\n            User actionUser = bgRealm.where(User.class).equalTo(\"id\", action.getUserId()).findFirst();\r\n            if (actionUser != null) {\r\n                action.setUser(actionUser);\r\n                event.setAction(action);\r\n            }\r\n        }\r\n\r\n        if (event.getReplyToId() != 0) {\r\n            setReplyEvent(event, bgRealm);\r\n        }\r\n\r\n        event.setState(Event.EventState.SENT);\r\n\r\n        FileBrief file = event.getFile();\r\n        if (file != null && event.getFile() != null) {\r\n            file.setId(event.getFile().getId());\r\n        }\r\n\r\n        Event eventRealm = bgRealm.copyToRealmOrUpdate(event);\r\n\r\n        Chat chat = bgRealm.where(Chat.class)\r\n                .equalTo(\"peer.uniquePeerId\", event.getPeer().getUniquePeerId())\r\n                .findFirst();\r\n\r\n        if (chat != null) {\r\n            if (event.getSenderId() != getSelfUserId() && event.getId() > chat.getReadEventId()) {\r\n                int unreadCount = chat.getUnreadCountSafe();\r\n                chat.setUnreadCount(unreadCount + 1);\r\n            }\r\n            Timber.d(\"Chat \" + chat.getChatName() + \" , set last  event - \" + event.getText());\r\n            chat.setLastEvent(eventRealm);\r\n\r\n        } else {\r\n            Timber.i(\"Chat == null in saveEvent => create new chat\");\r\n            if (event.getPeer().getType().equals(PeerType.USER)) {\r\n                User user = bgRealm.where(User.class).equalTo(\"id\", event.getPeer().getPeerId()).findFirst();\r\n                if (user != null) {\r\n                    chat = new Chat(event.getPeer(), eventRealm, user);\r\n                    bgRealm.insertOrUpdate(chat);\r\n                } else {\r\n                    Timber.e(\"Chat == null, user == null, can't create Chat\");\r\n                }\r\n            } else {\r\n                Group group = bgRealm.where(Group.class).equalTo(\"id\", event.getPeer().getPeerId()).findFirst();\r\n                if (group != null) {\r\n                    chat = new Chat(event.getPeer(), eventRealm, group);\r\n                    bgRealm.insertOrUpdate(chat);\r\n                } else {\r\n                    Timber.e(\"Chat == null, group == null, can't create Chat\");\r\n                }\r\n            }\r\n\r\n            if (chat != null) {\r\n                if (event.getAction() != null) {\r\n                    if (ServiceAction.ACTION_GROUP_CREATED.equals(event.getAction().getType())\r\n                            && event.getSenderId() != getSelfUserId()) {\r\n                        \/\/ \u0435\u0441\u043b\u0438 \u0433\u0440\u0443\u043f\u043f\u0443 \u0441\u043e\u0437\u0434\u0430\u043b \u043d\u0435 \u044f\r\n                        chat.setUnreadCount(1);\r\n                    }\r\n                    if (!ServiceAction.ACTION_GROUP_CREATED.equals(event.getAction().getType())) {\r\n                        chat.setUnreadCount(1);\r\n                    }\r\n                }\r\n                bgRealm.insertOrUpdate(chat);\r\n            } else {\r\n                Timber.e(\"Chat == null or group == null, can't create Chat in saveEventToRealm\");\r\n            }\r\n        }\r\n    }\r\n```"],"labels":["T-Doc","O-Community"]},{"title":"Run unit tests with Proguard","body":"#4673 identified a problem in our testing procedure, namely that we need to do more thorough testing with Proguard enabled.\n\nRight now we have one example: https:\/\/github.com\/realm\/realm-java\/blob\/master\/examples\/moduleExample\/app\/build.gradle#L27 that uses proguard and this is tested during the release process. \n\nThis has a number of problems:\n\n* The example isn't run as a release build until after we deployed to Bintray, so any bugs found will require us to either pull the release from Bintray or release a patch version immediately.\n* We are not catching bugs during development\n* The example does not touch all parts of the code that could be effected by Proguard doing the wrong thing.\n\nIt is apparently possible to enable ProGuard when unit testing: https:\/\/stackoverflow.com\/questions\/26482119\/android-unit-tests-with-proguard-enabled, but doing so would seriously prohibit normal debugging.\n\nInstead, we should create a special debug build flavor that can be used by CI, so we ensure that all unit tests can be run with ProGuard enabled.\n\n","comments":[],"labels":["T-Test"]},{"title":"Callback for Realm file events: Created\/deleted\/migrated","body":"#### Goal\n\nMy goal is to run `initialData` transaction asynchronously. However, given my Android application use case, I don't think the new `Realm.getInstanceAsync` is the best fit.\n\n#### Expected Results\n\nGet Realm instance synchronously, but execute `initialData` transaction asynchronously.\n\n#### Actual Results\n\nWith `Realm.getInstanceAsync`, introduced in Realm 3.2.0, a Realm object is not returned synchronously. \n\nThat has implications when you are using **dependency injection** for the Realm instance, as it would make the workflow much more complex than it needs to be (should I not be using it at all?).\n\nRight now, to initialize data, I'm simply making use of `SharedPreferences` and running a transaction asynchronously.\n\n#### Version of Realm\nRealm version: 3.2.0","comments":["Hey Jo\u00e3o!  I think I don't quite understand the question. `initialData` is a way of guaranteeing that the realm is initialized, before anyone sees it.  That implies that that nobody can have the realm, before the `initialData` operation is complete.  ... and *that* implies that if you do it asynchronously, your DI can't be static.\r\n\r\nCan I ask you a favor?  Can you take this issue to StackOverflow.  Totally happy to try to answer it there... and if we come up with something that works for you, it will probably help a bunch of others, too!\r\n\r\n-blake","@bmeike I see. I was using `initialData` to populate the database initially, but not necessarily as a \"way of guaranteeing that the realm is initialized, before anyone sees it.\" I will update my code to reflect that. Thanks.","@bmeike this was a somewhat specific question that was meant to discuss the initial data features of Realm and ultimately propose changes based on my use case and your feedback. \r\nUnless I was missing something obvious, which was a real possibility and one of the reasons why I opened the issue, I never expected to receive a StackOverflow kind of answer, as my use case is already working and is simple enough.\r\n\r\nStill, I wrote a draft of a question I could post on StackOverflow, but I'm not too sure about posting it.\r\nHowever, if you think it's a question you would like to answer, I'll post it.\r\n\r\n> **Title:** Realm initial data asynchronous workflow\r\n> **Question:**\r\n>My goal would be to implement a simple workflow to pre-populate a Realm database, without mandatory data. Example: Reddit's initial subreddits \u2014 the app can perfectly work without them, but they are populated initially.\r\n> \r\n>`RealmConfiguration`'s `initialData` method assumes the initial data is mandatory, and won't return a Realm instance until the data is ready, which causes the UI to freeze.\r\n> \r\n>With the release of Realm `3.2.0`, Realm has introduced `Realm.getInstanceAsync()`, which theoretically should solve the issue, but that method returns a `RealmAsyncTask`, instead of a Realm instance, calling `Callback.onSuccess(Realm)` once finished.\r\n>\r\n>That's an issue, because that would make my dependency injection workflow unnecessarily complex.\r\n> \r\n> Currently, I'm making use of `SharedPreferences` to determine if the initial data needs to be set, and initializing it with a simple async transaction. Is there a better alternative?\r\n\r\nCheers!","Hi @jpmcosta \r\nNo, feature requests should go here :)\r\n\r\nIt is an interesting use case. By doing an async transaction it also means that you are OK with the Realm instance not being \"fully\" initialized?\r\n\r\nThe natural option would be to add something like `RealmConfiguration.initialDataAsync()` but calling something \"initial*\" kinda implies that it is setup when the Realm is opened, so that doesn't feel right to me.\r\n\r\nIf I remember correctly we have heard other use cases for doing other things when a Realm is created, like resetting SharedPrefs or similar (need to dig those up). So I'm thinking that perhaps we should expose a lifecylecallback whenever the Realm is created\/reset, and then you could do whatever. Something like:\r\n\r\n```\r\nRealmConfiguration config = new RealmConfiguration.Builder()\r\n  .realmHandler(new RealmCreatedCallback() {\r\n      @override\r\n      public void onRealmCreated(RealmConfiguration config) {\r\n         \/\/ Callback when the Realm file is created the first time. Called after inititialData\/assetFile has been executed\r\n      }\r\n  })\r\n .build();\r\n```\r\n\r\nNaming and scope is up for debate of course:\r\n\r\nName:\r\n- `.realmHandler(...)`\r\n- `.onRealmCreated(...)`\r\n- `.lifecycleHandler(...)`\r\n- `.realmFileHandler(...)`\r\n- `.eventHandler(...)`\r\n- Other ideas?\r\n\r\nPossible scope:\r\n- `onRealmCreated`\r\n- `onRealmMigrated`\r\n-  `onRealmDeleted`\r\n- others?\r\n\r\nWould something like that work for you?",">Would something like that work for you?\r\n\r\n@cmelchior Yes, that would be perfect! I also envisioned something like `initialDataAsync`, but the lifecyclecallback should work much better.\r\n\r\nEdit: I didn't read the comma! Thanks for your answer.","#4083 described a use where this type of closure would make sense:\r\n\r\n```\r\nRealmFileEventHandler handler = new RealmFileEventHandler() {\r\n  @Override\r\n  public void onRealmDeleted(RealmConfiguration config) { ... }\r\n\r\n  @Override\r\n  public void onRealmCreated(RealmConfiguration config) { ... }\r\n\r\n  \/\/ Use case in #4083\r\n  @Override\r\n  public void onRealmMigrated(long from, long to, RealmConfiguration config) { ... }\r\n};\r\n```"],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"readOnly Realms should mock non-existing classes","body":"`readOnly()` was added in #4575.\n\nRight now the Schema of a read-only Realm must strictly match the provided schema. If it doesn't a `RealmMigrationNeededException` is thrown. Which it is impossible to react to since the Realm is read-only.\n\nCocoa (and Object Store) has slightly different semantics. They will allow classes to be missing and will instead mock them if queried i.e. they will allow queries on non-existing tables (in read-only mode), but just always return the empty set.\n\nThis makes sense if the cases where you don't want to force people to re-create the assetFile every time they add new model classes.\n\nHowever, in Java you could also accomplish the same by creating a RealmModule:\n\n```\n@RealmModule(classes = { MyModel.class })\npublic class MyModule() {\n\n}\n\n\/\/ This schema is restricted to only the classes in the assetFile\nRealmConfiguration config = new RealmConfiguration.Builder()\n  .modules(new MyModule()) \/\/ Restrict schema\n  .assetFile(\"my.realm\")\n  .readOnly()\n  .build();\n```\n\nConsidering that mocking a missing class would have major ramifications on our `RealmQuery` class, I'm not convinced that adopting the same semantics is worthwhile, but it does mean the behavior will be slightly different from Cocoa. Thoughts @realm\/java ?","comments":["It doesn't seem to be a normal use case at all. Maybe we should just wait until users asking for it."],"labels":["T-Enhancement","Design-Required","Pipeline-Idea-Backlog"]},{"title":"Better support for upgrading realms using assetFile()","body":"`assetFile(path)` has been along for a while and copies the file if nothing yet exists on disk. Like a bundled `initialData()`.\n`readOnly()` was added in #4575.\n\nA really common use case is shipping a read only Realm with the app, think static data like zip codes and such.\n\n### Use case 1\n\n```\nRealmConfiguration config = new RealmConfiguration.Builder()\n  .assetFile(\"my.realm\")\n  .readOnly()\n  .build();\n```\n\nIn that case it would be nice if the assetFile was automatically copied again if a newer version was shipped with the app. Right now people have to track that manually. \n\n### Use case 2\n\nA writeable Realm that is marked as volatile (deleteRealmIfMigrationNeeded), but at the same time can start from an assetFile.\n\n```\nRealmConfiguration config = new RealmConfiguration.Builder()\n  .assetFile(\"my.realm\")\n  .deleteRealmIfMigrationNeeded()\n  .build();\n```\n\nIn this case, it would be nice if the assetFile was copied again if `deleteRealmIfMigrationNeeded` was invoked. Right now that doesn't happen.\n\n### User case 3\n\n```\nRealmConfiguration config = new RealmConfiguration.Builder()\n  .assetFile(\"my.realm\")\n  .deleteRealmIfMigrationNeeded()\n  .readOnly()\n  .build();\n```\nIs effectively just Use Case 1, since hopefully the user has provided a new asset if the schema was changed.\n\nTODO\n- [ ] Copy assetFile again if a newer is present (if the realm is marked read-only).\n- [ ] Copy the assetFile again if `deleteRealmIfMigrationNeeded()` is triggered.","comments":["I find this to be very important, is there any progress on it?"],"labels":["T-Enhancement","Design-Required"]},{"title":"Support for importing relation objects by ID from json file","body":"Hi,\n\nThe `createOrUpdateAllFromJson` method or similar other methods, \nsupport for importing objects by putting only `id` for relation objects, \ninstead of putting whole object data on the json file.\n\nFor example when we have these two  `Dog` and  `Person` models:\n\n\n```java\npublic class Dog extends RealmObject {\n    @PrimaryKey\n    private int id;\n    private String name;\n\n}\n\npublic class Person extends RealmObject {\n    @PrimaryKey\n    private int id;\n    private String name;\n    private RealmList<Dog> dogs;\n\n}\n```\n\nAnd assumed we currently have these records on the `Dog` model on the database:\n\n![table-diagram](https:\/\/cloud.githubusercontent.com\/assets\/397672\/25946665\/6d7ffbfa-3661-11e7-8b22-435453fd6af6.png)\n\n\nNow, we want to able to import `Person` model from this `Person.json` file:\n\n```[{\"id\":1, \"name\": \"Jane\", \"dogs\": [1,2]]```\n\nInstead of this `Person.json` file:\n\n```[{\"id\":1, \"name\": \"Jane\", \"dogs\": [{\"id\": 1, \"name\": \"Fido\"}, {\"id\": 2, \"name\": \"Fluffy\"}]```\n\n\nby doing:\n\n\n```java\nInputStream stream = getAssets().open(\"Person.json\");\nRealm realm = Realm.getDefaultInstance();\nrealm.beginTransaction();\nrealm.createOrUpdateAllFromJson(Person.class, stream);\nrealm.commitTransaction();\n```","comments":["Yes, a similar idea has been raised here as well: https:\/\/github.com\/realm\/realm-java\/pull\/3758. Personally, I find the idea compelling and would definitely ease integration with a lot of REST API's that just send ID's.","I've just created #6666 before finding this but it seems we're having the same problem. Maybe you can use the workaround mentioned there until realm adds this functionality."],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Configuration Builders fail a different times","body":"Right now it is fairly inconsistent when our Builders fail (`RealmConfiguration.Builder` and `SyncConfiguration.Builder` throws). Some errors are thrown when setting a value like `assetFile()` others are thrown when calling `build()`.\n\nWe should make this consistent. I propose the following:\n- Individual builder methods will only throw on Illegal input, e.g a String being `null` or something like that.\n- Any logic that depends on other parameters should first be thrown when calling `build()`\n\nThis is obviously a breaking change and should wait for a suitable time.","comments":[],"labels":["T-Enhancement","Design-Required","Breaking","Pipeline-Idea-Backlog"]},{"title":"Tool support for catching breaking API changes","body":"Fallout from internal Architectural discussion:\n\nWe need to make sure we are aware if we are breaking any public API signatures. Apparently, AOSP has tools in place that allows you to generate a list of all public API methods and compare them to a \"valid\" list. If these two lists are not identical it should result in CI breaking.\n\nTODO:\n\n* [ ] Figure out which tools can be used for this\n* [ ] Figure out cost\/benefit of doing it, i.e. having to do it every time we _add_ methods might be annoying, but we definitely want to catch changes to signatures.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Remove unit test classes no longer needed","body":"Fallout from internal architectural discussion: \n\nWe have old unit tests of internal classes (JNI*Test). Most of these should probably just go away. All unit testing should happen as part of the public API. This both increase the confidence of the public API and help us detect parts of the code that is no longer used.\n\nWe have extensive coverage of the public API at this point, but it is important to verify that we are not loosing code coverage when doing this.\n\n","comments":[],"labels":["T-Test"]},{"title":"Refactor internal packages","body":"Fallout from internal Architectural discussion: The difference between Core and ObjectStore needs to be more visible in the code base. We would like to refactor the `io.realm.internal` package into 3 parts: \n\n`io.realm.internal`: Contain internal classes relevant to Realm Java\n\n`io.realm.internal.objectstore`: Contain all wrapper classes from Object Store, like SharedRealm, Collection, etc. There is already an issue here for renaming\/prefixing them with `Os` https:\/\/github.com\/realm\/realm-java\/issues\/4215\n\n`io.realm.internal.core`: Contain all wrapper classes from Core. At some point this will probably go away if Core ends up being a complete layer behind Object Store, but we are not there yet.\n\n","comments":[],"labels":["T-Internal"]},{"title":"getInstance refactor","body":"The design of `Realm`\/`DynamicRealm`\/`RealmCache` is a long story,  and also be noticed that there is a similar thing inside the Object Store which is doing the same for caching Realm instances called `RealmCoordinator`. We are not using it just because of `RealmCache` was added before that existed in Object Store, and there would be some breaking changes I would like to have to redesign the Realm instances mechanism:\n\n* Semantics of `Realm.close()`\nCurrent `Realm.close()` is a confusing API, eg:\n\n```java\n  Realm realm1 = Realm.getDefaultInstance();\n  Realm realm2 = Realm.getDefaultInstance();\n  realm1.close();\n  print(\"Is realm1 closed?\" + realm1.isClosed()) \/\/ false, confusing\n  realm2.close();\n  print(\"Is realm1 closed?\" + realm1.isClosed()) \/\/ true, OK, the thread ref count reaches 0\n```\n\nit would be much clearer if:\n\n```java\n  Realm realm1 = Realm.getDefaultInstance();\n  Realm realm2 = Realm.getDefaultInstance();\n  realm1.close();\n  print(\"Is realm1 closed?\" + realm1.isClosed()) \/\/ true\n  print(\"Is realm2 closed?\" + realm2.isClosed()) \/\/ false\n  realm2.close();\n  print(\"Is realm2 closed?\" + realm1.isClosed()) \/\/ true\n\n  \/\/ ...\n  realm1.addChangeListener(listener1);\n  realm2.addChangeListener(listener2);\n  realm2.removeAllChangeListeners(); \/\/ The listener1 will be removed as well!!\n```\n\nWe can just using the OS `RealmCoordinator` to achieve this quite easier, then also it is possible to have more debug information for users to check which specific Realm instance is leaked.\n\n* `DynamicRealm` and `Realm` should \nCurrently `DynamicRealm` and `Realm` can be created at the same time, and even on the same thread, they are using different `SharedRealm` instance. There was a reason that which i don't recall :grinning: And that creates complexity for the cache management. Also, it creates lot more corner cases we are not handled well right now: think about Realm instance and DynamicRealm instance both exist, then the DynamicRealm changes the schema and typed Realm won't be aware of that, the column indices will be wrong then. (I have seen a user on SO is doing that)\nThis behavior should be change, allowing them both exist is not a valid use case at all, we should just disallow that.\n* Garbage collect Realm instance\nby fixing the semantics of `Realm.close()`, we might be able to support GC better which is always a headache for users to remember to call `close()`. But this need to be investigated more since I don't really know if the GC is stressed enough to collect un-refed Realm instances on time\n* `Realm.deleteRealm()` \nThis API heavily relies on the `RealmCache` and it is not multi-processes safe. It is not ideal at all. But actually the implementation of it should exist in core to have a proper multi-processes support. See core issue https:\/\/github.com\/realm\/realm-core\/issues\/2165\n\nwe need to introduce some breaking changes in the API level (and I think they are good breaking changes) also a few dependencies from others.\n\n","comments":["We talked about using phantom references for Realm instances as well, which would make `close()` optional. The biggest drawback is that we might \"leak\" older Realm versions for a lot longer than desired. We would need to test this on real world apps in order to evaluate how such a change would affect file sizes.\r\n\r\nAt this stage in the Realm life cycle I would be _very_  hesitant about changing how `close()` works. It might be a bit quirky, but changing the behaviour would be an _extremely_ breaking change for a lot of apps, so the benefits would have to be massive I think.\r\n\r\nI do generally agree with the concerns here, but it is changes we need to think really careful about.","I would point out that the semantics of the Realm DB are very similar to\nthose of Android's SQLite DBs.\n\nYou actually *can* close a SQLite DB, but the framework does everything it\ncan, to hold one open, behind your back and return refs to the single\ncached instance for all requests.\n\nThe surprise with the built-in is that, if we both have refs to a DB, and I\nclose mine, yours is closed. It is very difficult to get around this. Best\npractice suggests that you *not* close a DB without a very good reason.\n\nThe Realm approach of reference counting is just the other side of the\ncoin.  It seems somewhat friendlier to me.  Not that we couldn't do\nbetter....  Bet current behavior is relatively easy to explain and I think\npeople are used to it.\n\n-blake\n\n\nOn Apr 27, 2017 8:07 PM, \"Chen Mulong\" <notifications@github.com> wrote:\n\n> The design of Realm\/DynamicRealm\/RealmCache is a long story, and also be\n> noticed that there is a similar thing inside the Object Store which is\n> doing the same for caching Realm instances called RealmCoordinator. We\n> are not using it just because of RealmCache was added before that existed\n> in Object Store, and there would be some breaking changes I would like to\n> have to redesign the Realm instances mechanism:\n>\n>    - Semantics of Realm.close()\n>    Current Realm.close() is a confusing API, eg:\n>\n>   Realm realm1 = Realm.getDefaultInstance();\n>   Realm realm2 = Realm.getDefaultInstance();\n>   realm1.close();\n>   print(\"Is realm1 closed?\" + realm1.isClosed()) \/\/ false, confusing\n>   realm2.close();\n>   print(\"Is realm1 closed?\" + realm1.isClosed()) \/\/ true, OK, the thread ref count reaches 0\n>\n> it would be much clearer if:\n>\n>   Realm realm1 = Realm.getDefaultInstance();\n>   Realm realm2 = Realm.getDefaultInstance();\n>   realm1.close();\n>   print(\"Is realm1 closed?\" + realm1.isClosed()) \/\/ true\n>   print(\"Is realm2 closed?\" + realm2.isClosed()) \/\/ false\n>   realm2.close();\n>   print(\"Is realm2 closed?\" + realm1.isClosed()) \/\/ true\n>\n>   \/\/ ...\n>   realm1.addChangeListener(listener1);\n>   realm2.addChangeListener(listener2);\n>   realm2.removeAllChangeListeners(); \/\/ The listener1 will be removed as well!!\n>\n> We can just using the OS RealmCoordinator to achieve this quite easier,\n> then also it is possible to have more debug information for users to check\n> which specific Realm instance is leaked.\n>\n>    -\n>\n>    DynamicRealm and Realm should\n>    Currently DynamicRealm and Realm can be created at the same time, and\n>    even on the same thread, they are using different SharedRealm\n>    instance. There was a reason that which i don't recall :) And that creates\n>    complexity for the cache management. Also, it creates lot more corner cases\n>    we are not handled well right now: think about Realm instance and\n>    DynamicRealm instance both exist, then the DynamicRealm changes the schema\n>    and typed Realm won't be aware of that, the column indices will be wrong\n>    then. (I have seen a user on SO is doing that)\n>    This behavior should be change, allowing them both exist is not a\n>    valid use case at all, we should just disallow that.\n>    -\n>\n>    Garbage collect Realm instance\n>    by fixing the semantics of Realm.close(), we might be able to support\n>    GC better which is always a headache for users to remember to call\n>    close(). But this need to be investigated more since I don't really\n>    know if the GC is stressed enough to collect un-refed Realm instances on\n>    time\n>    -\n>\n>    Realm.deleteRealm()\n>    This API heavily relies on the RealmCache and it is not\n>    multi-processes safe. It is not ideal at all. But actually the\n>    implementation of it should exist in core to have a proper multi-processes\n>    support. See core issue realm\/realm-core#2165\n>    <https:\/\/github.com\/realm\/realm-core\/issues\/2165>\n>\n> So, yes, redesign is something I want to do as well, but then we need to\n> introduce some breaking changes in the API level (and I think they are good\n> breaking changes) also a few dependencies from others.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/realm\/realm-java\/issues\/4573>, or mute the thread\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AAQ9WGiLAIxD5X9Yak2EKSU0XJWFOKmzks5r0VfjgaJpZM4NLALv>\n> .\n>\n","I was thinking about some wicked ideas about auto close the Realm instance.\r\nThe major problem is about Realm instances on the background thread, so if we know the thread has been terminated, it is actually safe to just close the Realm instance. There are only two key points of this:\r\n\r\n1. When to check if the thread has been terminated.\r\n2. What to do with the thread pool.\r\n\r\nFor 1) it is actually quite doable, we have a daemon thread to send notifications when Realm changes. When Realm is changed on any thread, it is actually a good timing to check if there are any thread Realm instances bond to are closed. So:\r\n\r\n```java\r\nThread thread = new Thread( -> {\r\n    Realm realmBG = Realm.getInstance();\r\n    \/\/ Do something...\r\n};\r\n\r\n\/\/ On the daemon thread:\r\n{\r\n    pipe.pollEvent(); \r\n    for (Realm realm : realms) {\r\n        if (realm.thread.getState() == TERMINATED) {\r\n            \/\/ realmBG will be closed here since the thread is terminated.\r\n            realm.close();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nFor 2), I don't have good idea yet, since the thread won't be terminated if it was retrieved from a thread pool. Then only thing i can come up with is supply our own implementation of thread pool."],"labels":["T-Enhancement"]},{"title":"Equals for RealmObject should check for isValid() result","body":"**Feature Request**\n\n#### Goal\nSimply use \n`if (object1.equals(object2))` \ninstead of \n`if ((object2 != null) && object2.isValid() && object1.equals(object2))`\n\n#### Expected Results\n\nCorrect behavior of an app\n\n#### Actual Results\n\nApp crashes without any error message in logcat\n\n#### Steps & Code to Reproduce\n\nI use ExpandableListView with custom adapter derived from BaseExpandableListAdapter.\nIn order to provide group and child selection indicator I keep a reference in adapter to selected RealmObject and use condition \n`group.equals(mSelected)` \nwhere **group** and **mSelected** the instances of the same class derived from RealmObject.\n\nWhen I delete the selected object from Realm then mSelected become invalid and equals crashes the app.\n\n#### Version of Realm and tooling\nRealm version(s): 3.1.3\n\nRealm sync feature enabled: no\n\nAndroid Studio version: \nAndroid Studio 2.3.1\nBuild #AI-162.3871768, built on April 1, 2017\nJRE: 1.8.0_112-release-b06 amd64\nJVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o\n\nWhich Android version and device: any","comments":["If you delete the object then you're supposed to synchronize the ExpendableListAdapter's contents by listening to the results with a `RealmChangeListener` (i'm not sure if RealmBaseAdapter handles ExpendableListAdapter, because I haven't used that thing in a long long time)","Source code of test project can be found here: https:\/\/github.com\/RuslanPrimak\/RealmAdapterExpandableList","@RuslanPrimak I relabel the issue as I think we should call `isValid()` in `equals()`."],"labels":["T-Enhancement","O-Community"]},{"title":"Better Databinding Support","body":"Playing around with databinding in a side project made me think about this a bit more. Sorry for the wall of text :)\n\nDatabinding is a fairly complex topic especially on when you want to support field change notifications. Right now it requires quite a lot of boilerplate: https:\/\/github.com\/Zhuinden\/realm-databind-experiment\/blob\/master\/app\/src\/main\/java\/com\/zhuinden\/realmdatabind\/realm\/objects\/Post.java\n\nAnd property notifications needs to be called from a custom listener as well:\n\n```\n\/\/ Notify about writes should be done from listeners\nPerson p = realm.where(Person.class).findFirst();\np.addChangeListner(new RealmObjectChangeListener() {\n    @Override\n    public void onChange(Person p, ObjectChangeSet changeSet) {\n        if (changeSet.isFieldChanged(\"name\")) {\n            p.notifyPropertyChanged(BR.name);\n        }\n    }\n});\n```\n\nThere is at least 3 ways we can improve this, 2 that are very easy, and one slightly more difficult, but it would make databinding support rather nice.\n\n## 1. Support BaseObservable class\n\n```\npublic class Person extends BaseObservable implements RealmModel {\n\n    private String name;\n\n    @Bindable\n    public String getName() {\n        return name;\n    }\n\n    @Bindable({\"name\"})\n    public String getDisplayName() {\n        return name.toLowerCase();\n    }\n}\n\n\/\/ Usage\nMyFragmentBinding binder = MyFragmentBinding.inflate(inflater);\nbinder.setPerson(realm.where(Person.class).findFirst());\n\n```\n\nRequirements:\n1) We must allow people to extend from BaseObservable, or more generally from any non-realm super class. Right now this would actually also work with our type system rather nicely, since people couldn't query for the abstract classes since they wouldn't be implementing `RealmModel`. This will probably change with #575 though where we would loosen the generics. The quick solution would be to just make an exception for `BaseObservable`.\n2) People must use the `RealmModel` interface approach (annoying if you don't use Kotlin).\n\n\n## 2. Support new RealmBaseObservable class  \n\nMore convenient:\n\n```\npublic class Person extends RealmBaseObservable {\n\n    private String name;\n\n    @Bindable\n    public String getName() {\n        return name;\n    }\n\n    @Bindable({\"name\"})\n    public String getDisplayName() {\n        return name.toLowerCase();\n    }\n}\n```\n\nRequirements:\n1) We must provide a `RealmBaseObservable` class that is our implementation of `BaseObservable` which also extends RealmObject. This means people could still use the more fluent methods on `RealmObject`.\n2) This class should probably be in `realm-android-adapters`.\n3) We need to extend the annotation processor to be aware of this class, and we need to prevent people from making queries on it.\n\n\n## 3. Automatically create RealmObjectChangelistener\n\nDatabinding annotation processors will consume the `@Bindable` annotations which prevents us from creating one that process only those classes, but we can create one similar to https:\/\/github.com\/cmelchior\/realmfieldnameshelper that will process all Realm Model class and check for the @Bindable annotation that way.\n\nField observing in databinding would be a 1-liner and really showcase how useful object listeners can be.\n\n\n```\n\/\/ This class could be created by an annotation processor since we ca deduce the field\/BR name from the @Bindable method\npublic class PersonObjectChangeListener implements RealmObjectChangeListener<Person> {\n    @Override\n    public void onChange(Person obj, ObjectChangeSet objectChangeSet) {\n        if (objectChangeSet.isFieldChanged(\"name\")) {\n            obj.notifyPropertyChanged(dk.ilios.realmviewmodels.example.BR.name);\n        }\n    }\n}\n\n\/\/ Usage options\n\/\/ Like asObservable() but will automatically attach the listener\n\/\/ Will mean our core library need to know about Databinding\nPerson p = person.asViewModel(); \n\n\/\/ This could be implemented as a completely seperate project or more likely in realm-android-adapters\nPerson p = ViewModelFactory.create(person); \n\n\/\/ Perhaps instead\nPerson p = RealmAndroid.getViewModel(person);\n\n\/\/ Just create public classes and let people hook them up themselves\nPerson p = getPerson();\np.addChangeListener(new PersonObjectChangeListener());\n\n\/\/ Example of usage in a fragment\/activity\nMyFragmentBinding binder = MyFragmentBinding.inflate(inflater);\nbinder.setPerson(realm.where(Person.class).findFirst().asViewModel());\n```\n\nRequirements:\n1) We need an extra annotation processor somewhere. Either as part of our standard one or a new one in realm-android-adapters.\n2) That annotation processor need to know the manifest package name which is rather hard without hacks or a gradle plugin, which only our main project uses. See e.g. https:\/\/github.com\/androidannotations\/androidannotations\/blob\/558b9088fdc2cd82988445ed86d60340b143a95f\/AndroidAnnotations\/androidannotations-core\/androidannotations\/src\/main\/java\/org\/androidannotations\/internal\/helper\/AndroidManifestFinder.java\n\n## Conclussion\n\n1\/2 seems rather straight forward and easy to implement. 3) is doable as well, the biggest issue is around how we actually want to distribute it and how much we want to expose Android specific concepts in our API's.","comments":["on top of 1), what I initially wanted to do in order to reduce boilerplate was to do this:\r\n\r\n    public class RealmBaseObservable extends RealmObject implements Observable {\r\n        \/\/ stuff from `BaseObservable` goes here, all fields are transient or marked with `@Ignore`\r\n    }\r\n\r\n    public class Post extends RealmBaseObservable { \r\n        \/\/ ...\r\n    }\r\n\r\nthat way `implements RealmModel` is not needed, but there are still no inherited fields that would mess with the realm schema.","Yup that is actually what 2) describes.","Except personally I was thinking that if the parent classes have no inherited fields, then this class would work even without it being explicitly provided by Realm - the support for extending abstract classes with no fields that extend from RealmObject  :) \r\n\r\nBut I don't know if the annotation processor has that sort of power. ","The annotation processor can detect that. At that point we are losing the help from the type system though and might as well just allow all abstract classes with fields. We would still not support polymorphism (i.e. multiple types in the same collection), but it the feature would be the same as what Cocoa does right now.","Hi guys,\r\n\r\nI have an app with a huge form and I'm using two-way data binding. Considering that I'm pretty new to Android development (so pretty slow to implement basics things), Is it worth spending the time to understand this POC https:\/\/medium.com\/@Zhuinden\/realm-1-2-0-android-data-binding-1dc06822287f and implement it in my app ? \r\n\r\nAny bits of advice would be greatly appreciated.\r\n\r\nThanks","Considering that example assumes that you only do two-way databinding only with unmanaged objects, it's a bit tricky. All modifications of RealmObjects must be done in a transaction after all. ","Thanks for your quick reply.\r\n\r\nI'm thinking of using an intermediate Model between my view and my RealmObject. The realmObject and my intermediate Model would have the same attributes. \r\nThat way I can still be using two-way data binding with my intermediate Model and when the user validates the form I can transfer all the attribute in a transaction to my RealmObject.\r\n\r\nI know this is not the best solution but it's really easy to implement. Do you think this is really bad if I do that ? ","Depends. If you use an intermediate object, it may as well be an unmanaged RealmObject. ","From Realm.NET:\r\n\r\n> Additionally, we're releasing a new platform specific DataBinding package that contains helper methods that enable two-way databinding scenarios by automatically creating transactions when setting a property.\r\n\r\nApparently they have some sort of magic going on where they automatically begin and commit a transaction whenever a property is changed in databinding.\r\n\r\nI can't help but feel like that would be wasteful, hence why I'm surprised to see it.","As the person who was driving the databinding support for .NET, I can briefly explain the motivation for our decisions. Databinding is somewhat magical in Xaml - there's a set of interfaces you need to implement (that Realm objects and collections implement those out of the box) and the databinding engine will subscribe for events, update the view and so on. On the other hand, when the UI changes, it will call the property setters directly, and those are generated by the Realm SDK, so the user can't add their custom logic there. This leaves users with no opportunity to begin\/commit transactions in response to databinding events, which would be very poor experience.\r\n\r\nThe way two-way databinding works in the .NET SDK is, we implement an additional interface that is used by the Xaml engine and provide custom property setters that the databinding engine will invoke instead of the regular ones. In those property setters, we check if the Realm is in transaction and if it is, we just call the original setter. If it's not, we wrap the setter call in a transaction, that is committed immediately.\r\n\r\nOur reasoning was that\r\n1. We still give people chance to \"optimize\" their transactions. If you expect a lot of properties to be changed and don't care for preserving partial changes\/drafts (e.g. create new User screen), you can begin a transaction when the screen is displayed, have the user set all fields and commit the transaction on save button click. In that case, you'll group everything in a single transaction, and if the user clicks cancel, or leaves the app, nothing will be persisted in Realm.\r\n\r\n2. We allow people to not worry about starting transactions when they are on a screen where they don't expect a lot of data changes or they are interested in persisting every change - e.g. settings screen. Regarding performance, it's a bit wasteful to do that, indeed, but the performance cost of starting and committing a transaction is negligible compared to the cost of user interaction and the binding engine redrawing stuff.\r\n\r\nIn conclusion, we feel that the potential performance hit from automating transactions in databinding scenarios is many times offset by the ease of use of the SDK. [Here's a blog post](https:\/\/academy.realm.io\/posts\/nikola-irinchev-observable-models-with-realm-for-xamarin\/) I wrote around the time we launched this feature, that showcases the simplicity of the API when using this feature. Hope this helps :)"],"labels":["T-Enhancement"]},{"title":"Diacritic-insensitive search","body":"Hi,\n\nI saw that [Realm cocoa v2.5.0](https:\/\/github.com\/realm\/realm-cocoa\/releases\/tag\/v2.5.0) added support for diacritic-insensitive search.\n\nAre you planning to make this available in a future release of Realm Android?\n\nI know that a normalised column could be added to implement this feature (see this [Realm Android issue](https:\/\/github.com\/realm\/realm-java\/issues\/1418) and [stackoverflow issue](http:\/\/stackoverflow.com\/questions\/28294809\/get-diacritic-insensitive-results-from-realm-database-query)) but would this be the most efficient way of doing it?\n\nThanks","comments":["We'll talk this over and see what kind of priority that we can give it. Thank you for showing your interest in having it added to the Java binding.","Yes, this is something we want to add, but we don't have a timeline yet.\r\n\r\nThe API is probably going to be slightly challenging.\r\n\r\nRight now we have\r\n```\r\nrealm.where(Person.class).equalTo(String field, String value, Case casing);\r\n```\r\n\r\nThat leaves use with a few options\r\n\r\n1) Add `Diacritic` enum\r\n\r\n```\r\nrealm.where(Person.class).equalTo(\"name\", \"John\");\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", Case.INSENSITIVE, Diacritic.SENSITIVE);\r\n\r\n\/\/ Should we also add only a diacritic option ? The combinatorial explosion makes me think no.\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", Diacritic.SENSITIVE);\r\n```\r\n* (+) NSPredicate only seem to support Case\/Diacritric as well.\r\n* (+) Works without breaking existing API.\r\n* (-) Doesn't scale very well if we add more options. We need to consider if full-text search might do that.\r\n* (-) Diacritic searches must also specify the Case setting\r\n\r\n2) Replace enum with bit flags:\r\n\r\n```\r\npublic class QueryOption {\r\n  public final static int CASE_SENSITIVE = 0x01;\r\n  public final static int CASE_INSENITIVE = 0x02;\r\n  public final static int DIACRITIC_SENSITIVE = 0x04;\r\n  public final static int DIACRITIC_INSENSITIVE = 0x08;\r\n}\r\n\r\nrealm.where(Person.class).equalTo(\"name\", \"John\");\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", QueryOption.CASE_INSENTIVE | QueryOption.DIACTRIC_INSENTIVE);\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", QueryOption.DIACRITIC_INSENITIVE);\r\n```\r\n\r\n* (+) Much more flexible, also in terms of adding new features\r\n* (-) We replaced the original case boolean with an enum because of readability and auto-complete issues. Using bit flags will put us back into that position.\r\n* (-) Breaking change, so must either wait for 4.0 or we need to duplicate a lot of methods.\r\n\r\n3) Other options\r\n\r\nNot sure what those could be?\r\n\r\n\r\nI probably lean towards 1) with the acceptance that for diacritic insensitive searches you also need to supply the case parameter. Thoughts @realm\/java ?","What about this:\r\n\r\n```java\r\n\r\npublic class SortParam {\r\n    Case caseParam;\r\n    public SortParam(Case caseParam) {\r\n       this.caseParam = caseParam;\r\n    }\r\n}\r\n\r\npublic enum Case {\r\n    CASE_SENSITIVE(true),\r\n    CASE_INSENSITIVE(false);\r\n\r\n    private final boolean value;\r\n    public static final SortParam SENSITIVE = new SortParam(CASE_SENSITIVE);\r\n    public static final SortParam INSENSITIVE = new SortParam(CASE_INSENSITIVE);\r\n}\r\n\r\nRealmQuery equalTo(String, String, SortParam);\r\n\r\n\/\/ It will still compile with old code although the API signature changed\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", Case.INSENSITIVE);\r\n\r\n\/\/ It also has some flexibility to support more sort params:\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", new SortParam(Case.CASE_INSENSITIVE, Diacritic.DIACRITIC_SENSITIVE));\r\n```","I guess it could work, and even though it is API breaking, most will probably not have to do any changes. I would be a bit concerned about how complicated it becomes to combine options (even more than both options I outlined).","@cmelchior how about:\r\n\r\n``` java\r\n    public class StringFilter {\r\n         final Case case;\r\n         final Diacritic diacritic;\r\n\r\n         public static class Builder {\r\n              private Case case = Case.SENSITIVE;\r\n              private Diacritic diacritic = Diacritic.INSENSITIVE;\r\n\r\n              public Builder withCase(Case case) {\r\n                   checkNotNull(case);\r\n                   this.case = case;\r\n                   return this;\r\n              }\r\n\r\n              public Builder withDiacritic(Diacritic diacritic) {\r\n                   checkNotNull(diacritic);\r\n                   this.diacritic = diacritic;\r\n                   return this;\r\n              }\r\n\r\n              public StringFilter build() {\r\n                   return new StringFilter(case, diacritic);\r\n              }\r\n         }\r\n\r\n         private StringFilter(Case case, Diacritic diacritic) {\r\n              this.case = case;\r\n              this.diacritic = diacritic;\r\n         }\r\n    }\r\n```\r\n\r\nAlthough still a breaking change; adding `Diacritic` to `Case` wouldn't really make sense","@Zhuinden Have you tried using that?\r\n\r\n```\r\nrealm.where(Person.class).equalTo(\"name\", \"John\", new StringFilter.Builder().withCase(Case.SENSITIVE).withDiacritic(Diacritic.INSENSITIVE).build();\r\n```\r\nLooks extremely long and complicated to me :)",".....ah, then I think you should probably just add `Diacritic` enum for now\r\n\r\n(i didn't think of the outrageous length XD)\r\n\r\n--------\r\n\r\nactually, that makes the bit-wise operators much easier to reason about.","Blocking this pr: https:\/\/github.com\/realm\/realm-core\/issues\/1082","Hey guys! Any update on this? Do you have a timeline for this feature ? Thanks!","@RobinCaroff Sorry. There is no timeframe yet. Unicode libraries on our supported platform are slightly different, so it needs some discussions and time to support it by core.\r\nhttps:\/\/github.com\/realm\/realm-core\/issues\/1082","Hello, after almost one year, any update on this?","Almost a year and a half now. Has this been considered for a future roadmap?","Eh. I personally do the same approach as with SQLite: create a new field that stores the normalized (accent-less) value, and query against that.\r\n\r\n(i am not a realm member)","Any news about this one?","Not to forget...\r\nAny news on this 5-years old request?"],"labels":["T-Feature","Design-Required","O-Community","Pipeline-On-Hold"]},{"title":"Enable isNotNull() query for nested link fields","body":"With the commit of https:\/\/github.com\/realm\/realm-cocoa\/pull\/4743 , there is now support for `isNotNull()` query for nested link fields.\n\nExpose new functionality and enable this test:\nhttps:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/androidTest\/java\/io\/realm\/RealmQueryTests.java#L2340","comments":[],"labels":["T-Enhancement"]},{"title":"Default values instead of `null` for max\/min","body":"When writing code that depend on e.g max value being set you often end up having to do something like:\n\n```\nNumber maxValue = realm.where(Person.class).max(\"id\");\nlong id = (maxValue != null) ? maxValue.longValue() : -1;\nnew Person(++id)\n```\n\nWe added default values to `first()\/last()` when the collection was empty and doing the same for `max\/min\/average` would help removing annoying code like the above:\n\nLike this:\n```\nNumber maxValue = realm.where(Person.class).max(\"id\", -1)\nnew Person(++maxValue);\n```\n\nProposed API changes\n```\n\/\/ Add 4 new methods to RealmQuery\nNumber max(String fieldName, Number defaultValue);\nNumber min(String fieldName, Number defaultValue);\nDate minimumDate(String fieldName, Date defaultValue);\nDate maximumDate(String fieldName, Date defaultValue);\n\n\/\/ Add 4 new methods to RealmCollection\nNumber max(String fieldName, Number defaultValue);\nNumber min(String fieldName, Number defaultValue);\nDate minDate(String fieldName, Date defaultValue);\nDate maxDate(String fieldName, Date defaultValue);\n```","comments":[],"labels":["T-Enhancement","Design-Required"]},{"title":"Sorting results by child RealmList size","body":"I love the addition of sorting by linked fields, but I find myself needing a sort by child list size as well.\n\nFor example:\n```\npublic class Person extends RealmObject {\n    private String name;\n    private RealmList<Dog> dogsList;\n}\n\npublic class Dog extends RealmObject {\n    private String name;\n    private int age;\n}\n```\n\nI want to get the list of Persons sorted by the number of dogs they own. Something like this:\n`personsList = personsList.sort(\"dogsList.size\", Sort.DESCENDING);`\n\nCurrently I'm stuck with using redundant fields such as \"dogsCount\" and updating these fields at each add\/delete operation which is a real pain. Any chance to get this kind of sort? :)","comments":["Well it would be nice but it is tracked by https:\/\/github.com\/realm\/realm-java\/issues\/1598 currently","Hi @cioraneanu \r\n\r\nAs @Zhuinden said, we don't have a feature for that for now.\r\nYou need to maintain count field as you said.\r\n\r\nI'll close this as a duplicate of #1598.","Ah, sorry.  #1598 is for query, not for sorting.\r\nI'm reopening this.\r\n","I don't suppose there's been any progress on this in 4 years? It's a very large pain point in an otherwise excellent framework.","Unfortunately not. The Core issue to track is this one: https:\/\/github.com\/realm\/realm-core\/issues\/4586.\r\n\r\nRight now the work-around would be to maintain a separate property with the size information, e.g `list` and `listSize` But I can see that being annoying to do."],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Support expressions in aggregate functions","body":"It would be really nifty if, given:\n\nclass RightTriangle {\n   long base;\n   long altitude;\n}\n\n... we could support:\n\n `realm.where(RightTriangle.class).max((t) -> Math.sqrt((t.base * t.base) \/ (t.altitude * t.altitude)))`","comments":["This is in the same ballpark as https:\/\/github.com\/realm\/realm-java\/issues\/2744\r\n\r\nThere are basically two solutions:\r\n1) Have Core callback to Java for each object in table that is being queried. This would probably be extremely slow.\r\n\r\n2) Use a custom query language like proposed in https:\/\/github.com\/realm\/realm-java\/issues\/1573 that can be converted to a C++ expression.\r\n\r\nWe are slowly moving towards 2) anyway.","For a second I thought this was about https:\/\/github.com\/realm\/realm-java\/issues\/1598 but I guess not, heh.\r\n\r\nEven with the custom query language, Realm-Core would need to know how to evaluate `Math.sqrt` and stuff, so that looks tricky"],"labels":["T-Enhancement","Pipeline-Idea-Backlog"]},{"title":"Observe link field changes in one listener","body":"change OrderedRealmCollectionChangeListener to support notification about specific items changes,\nfor now the OrderedRealmCollectionChangeListener has ability to notify only about that some items has changes,\nand is not specificy what parameters in each item change, maybe it will be better to provide also infromation about what parameters change in each item?","comments":["@idok595 I am sorry but I don't quite get your idea. Is #4366 what you want?","was a mistake, i mean OrderedRealmCollectionChangeListener not RealmObjectChangeListener ","I assume something like how if there is any object that has changed, then for those objects also provide a `List<ObjectChangeSet>`","Wouldn't register a `RealmObjectChangeListener` on the relevant `RealmObject` solve the problem? And IMO separated listeners fit RecycleView + ViewHodler better. `OrderedRealmCollectionChangeListener` to update RecycleView and `RealmObjectChangeListener` to update the individual view holder.","Note that it is partly performance related that we don't provide object change information for collections. Imagine you had a list of 1000+ tweets and marked them all as read. That would result in a massive overhead.\r\n\r\nThat said we want our change listeners to be as useful as possible, so we definitely want feedback such as this, but could your provide more information about your exact use case?","If the RealmResults listeners are called before the RealmObject listeners, then this should work just fine if the view holder keeps the field reference to its actual RealmObject on a given index, and a listener (field in viewholder) is added to the realmObject when it is bound (and removed from the previously bound item) ","yes, you see in recyclerViewAdapter there is build in functionality to update specific things using \r\nRecyclerView.Adapter.notifyItemRangeChanged(int positionStart, int itemCount, Object payload), in order to performe that and not rebind the all obejct, i need to get notification about the specific change, yes it is possible to mange it and create wrapper to OrderedRealmCollectionChangeListener + ObjectChangeListener, but in terms of performance better to do it on the core side...\r\n","Parse all child links change will be a lot of overhead in the Realm side, consider below object\r\n```\r\npublic class GrandChild {\r\n    RealmList<GrandChild> grandChildren;\r\n}\r\npublic class Parent {\r\n    String name;\r\n    RealmList<Child> children;\r\n}\r\n```\r\n\r\nFor above model, we need to check if any relevant `Child` changes and as well as the any `GrandChild` changes. Depends on the size of the list, it could be painfully slow.\r\n\r\nHowever, maybe something like:\r\n```java\r\ncollection.addChangeListener(listener, linkFieldToObserve = {\"children\", \"children.grandChilden\"})\r\n```\r\nwould help in this case? So it will avoid unnecessary overhead and still give user ability to observe link fields changes in a unique listener."],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Annotation processor should consider RealmObjects that were generated by other annotation processors","body":"Currently the processor runs only once, but as multiple rounds are executed, it would be possible to generate RealmProxy classes for RealmObjects that were generated by other annotation processors.","comments":["Yeah. We should do this.  I came really close to doing it when I refactored the processor, a few weeks ago, but I didn't understand the impact completely.","It is not as trivial as it sounds. I originally investigated that route when doing the initial implementation of modules. There are a few challenges:\r\n\r\n- We want to support ProGuard as much as possible, which means we want to allow obfuscating model classes. This, in turn, makes finding model classes non-trivial when doing multiple rounds.\r\n- We want to minimise reflection.\r\n\r\nThe current approach solves both of these constraints quite nicely in the sense that _only_ the `DefaultRealmModule` must be accessible through reflection. All the other information can then be read through this class including how to find obfuscated model classes.\r\n\r\nOne solution that comes to my mind could perhaps be to create a `RealmDefaultModuleMediator_Round<X>` class instead and then combine those at runtime through the `CompositeMediatorClass`.\r\n\r\nCompared to the current approach it would add one extra reflection lookup + handling the associated `ClassNotFoundException`. That would probably be acceptable, especially considering that we only need minimal changes to do it. \r\n ","Are there any plans to implement this \"minimal\" solution in the near future? I just started working with realm and some custom annotation processors. With the ability of generating RealmObjects I could get rid of some boilerplate."],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"@LinkingObjects should automatically detect the field in the parent object","body":"For the new `@LinkingObjects` annotation, there is no reason the user has to define the parent field. Since we could automatically detect it:\n\n```\npublic class Person {\n  private Dog dog;\n}\n\npublic class Dog {\n  @LinkingObjects \/\/ The annotation processor can automatically detect the field\n  private final RealmResults<Person> owners = null;\n} \n```\n\nThe only case where you would want to name the field is if you have multiple references:\n\n```\npublic class Person {\n  private Dog dog1;\n  private Dog dog2;\n\n}\n\npublic class Dog {\n  @LinkingObjects(\"dog1\") \/\/ With multiple fields we need to disambiguate\n  private final RealmResults<Person> owners = null;\n} \n```\n\nThoughts @bmeike \/ @realm\/java ?","comments":["We also need to disambiguate, once we add inheritance? ","I don't see how inheritance would impact it? Unless of course the base class have a reference to the same child class?","If the base class of `Person` is also defining a `Dog` I think you'll end up with the use case with multiple references (`dog1`, `dog2`)","Sure, but in many (most?) cases that will probably not happen?","I don't really see the value in this.  ...And by that, I merely mean that I\ndon't see it, not that I suspect that it doesn't exist.\n\nPutting that field name in there is good documentation, and makes your\nintentions as a coder clear.  I remember all sorts of confusion caused by\nSpring's auto-wiring.\n\nNone the less, it certainly could be elided in unambiguous cases.  I would\nput this as a low priority feature.  It would be fun to implement, though,\nand would probably only take a day or two, with tests.\n\n-blake\n\nOn Mar 30, 2017 5:47 AM, \"Christian Melchior\" <notifications@github.com>\nwrote:\n\n> Sure, but in many (most?) cases that will probably not happen?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https:\/\/github.com\/realm\/realm-java\/issues\/4403#issuecomment-290399966>,\n> or mute the thread\n> <https:\/\/github.com\/notifications\/unsubscribe-auth\/AAQ9WEgs6IADk-RQOPnhGhVZTk3jSn7-ks5rq6RWgaJpZM4MuOxc>\n> .\n>\n","I always like when we can remove redundant information (5th normal form is awesome). Once we have released inverse relationships, we can ask users how they feel.","hi guys. Nice to part of this community","This is now supported for Embedded Objects. We should consider extending the support to normal model classes as well."],"labels":["T-Enhancement"]},{"title":"Avoid switching UserStore implementation on the fly","body":"Currently we can choose to use the `SecureUserStore` to encrypt `SyncUser` tokens, by invoking `SyncManager.setUserStore(userStore);`\n\nHowever switching implementation (from default `RealmFileUserStore`) to `SecureUserStore` or vice-versa, after we open the Realm could be disastrous, as we might end up trying to decrypt a previously clear token, or trying to use an encrypted token.\n\nwe should find a way to prevent the user from changing the UserStore, after the Realm was opened the first time.\n\n_Note:_\n\n* This can not be part of the `SyncConfiguration` as the user store strategy applies for the entire `SyncManager`.\n* We may leverage `RealmCache` to track if the Realm was already opened, then throw an `IllegalStateException: Not possible to change UserStore when Realms are open`\n* Since the underlying ObjectStore uses a global table\/realm to store `SyncUsers` across different Realm, it will not be possible to mix in the same app, Synced Realms that uses  `RealmFileUserStore` (default) vs `SecureUserStore`. (need to document it?)\n\n","comments":[],"labels":["T-Internal"]},{"title":"Old\/New values pairs for Single Object Notifications","body":"This is for following enhancement of #4101 which are not implemented in #4331 \n\nCocoa API will notify user when the object changes with old\/new value pair:\n```objc\n@interface RLMPropertyChange : NSObject\n\n\/**\n The name of the property which changed.\n *\/\n@property (nonatomic, readonly, strong) NSString *name;\n\n\/**\n The value of the property before the change occurred. This will always be `nil`\n if the change happened on the same thread as the notification and for `RLMArray`\n properties.\n\n For object properties this will give the object which was previously linked to,\n but that object will have its new values and not the values it had before the\n changes. This means that `previousValue` may be a deleted object, and you will\n need to check `invalidated` before accessing any of its properties.\n *\/\n@property (nonatomic, readonly, strong, nullable) id previousValue;\n\n\/**\n The value of the property after the change occurred. This will always be `nil`\n for `RLMArray` properties.\n *\/\n@property (nonatomic, readonly, strong, nullable) id value;\n@end\n\n```\n\nBy extending current java interface `ObjectChangeSet`, realm-java could have something similar.\n\nThe proposed API 1:\n\n```java\npublic interface ObjectChangeset {\n  boolean isDeleted();\n  String[] getChangedField();\n  isFieldChanged(String fieldName);\n \n  public static class FieldChange<T> {\n    T oldValue;\n    T newValue;\n  }\n\n  \/\/ This will always return null for RealmList field.\n  <E> FieldChange<E> getChange(E type, String fieldName);\n}\n```\n\nThe proposed API 2:\n\n```java\npublic interface ObjectChangeset {\n  boolean isDeleted();\n  String[] getChangedField();\n  isFieldChanged(String fieldName);\n \n  Long getOldLongValue(String fieldName);\n  Long getNewLongValue(String fieldName);\n  Date getOldDateValue(String fieldName);\n  Date getNewDateValue(String fieldName);\n  \/\/ ... Other getters\n}\n```\n\nPotential problems & limitations:\n\n- [ ] Storing old values requires memory and potentially both memory & cpu consuming operation since there might be big strings needed to be converted from `StringData` to Java `String`. We may want to give user an option to disable the old\/new values in the notification. Something like `RealmObject.addChangeListener(RealmObjectChangeListener listener, boolean needValues)`.\n- [ ] Same like cocoa,  the value of the property before the change occurred. This will always be `nil`\n if the change happened on the same thread as the notification. \n- [ ] All primitive types will be returned as boxed type. This is because of we have to use generic for `FieldChange<T>`.\n- [ ] `short`\/`byte`\/`int`\/`long` values will always be reported as `FieldChange<Long>` since they are all stored as `long` underneath.  From this perspective, the API 2 might be safer for users.","comments":["1) Allowing opt-in of the new\/old values sounds like a good idea. Having a boolean parameter is probably fine, although we should probably provide a default value for it:\r\n\r\n```\r\nobj.addChangeListener(new RealmObjectChangeListener() { ... }) ; \/\/ Default to sending the new\/old?\r\nobj.addChangeListener(new RealmObjectChangeListener() { ... }, false) ; \/\/ Disable new\/old calculation.\r\n```\r\n\r\nTrying to do something like `obj.addNoCompareChangeListener(new RealmObjectChangeListener() { ... }` looks very cumbersome at least.\r\n\r\n2) Having the diff being null for local commits still makes no sense to me. It means you need to coordinate between the change listener and you commit instead of being able to keep them separately. It sounds more like a limitation of the current implementation to me, but I'm fine with shipping with the same limitation as Cocao and then we can re-evaluate.\r\n\r\n3) If people know they want a Long, they should be able to do `getFieldChange(Short.class, \"field\")`?\r\n\r\nAlso we should IMO ship ` isFieldChanged(String fieldName);` as part of #4331, it doesn't have to be part of this.","> If people know they want a Long, they should be able to do getFieldChange(Short.class, \"field\")?\r\nYes, we can do that. The only problem is we won't be able to do type checks:\r\n```java\r\npublic class extends RealmObject {\r\n    public int age;\r\n}\r\n\r\n\/\/ We can convert the long to short here, but we are not able to warn user that the original field is an int\r\ngetFieldChange(Short.class, \"age\");\r\n\r\n```","I think `obj.addChangeListener(new RealmObjectChangeListener() { ... }) ;` should be identical to `obj.addChangeListener(new RealmObjectChangeListener() { ... }, false) ;`. Opt-in for old\/new value is better. When user call `ObjectChangeset.getChange(...)` without enabling old\/new value feature, we can throw `IllegalStateException` since it's a program error (and user is able to know the feature is opt-in). ","After initial investigation by @beeender, it was determined that this feature would need to undergo major rewrite after moving the our schema to the Object Store, so we are moving this out of scope for 3.2 and waiting for https:\/\/github.com\/realm\/realm-java\/pull\/3800 to be complete instead","Original query [5451](https:\/\/github.com\/realm\/realm-java\/issues\/5451)\r\n\r\nAny update on this? This could really help in alot of places to us.\r\nElse will have to resort to keeping object copy and using diff utils in onchange. This mutes the point of the change listener\r\n","Will this be worked on?","At some point, yes, but I cannot give you any timeline right now."],"labels":["T-Enhancement","Blocked"]},{"title":"[Sync] Remove reflection code from `SyncObjectServerFacade`","body":"We should refactor the sync code, to separate the `SyncManager` interface from the implementation for example to try to remove the reflection code needed to hide some method from the public API, (like `SyncManger#removeSession`).","comments":[],"labels":["T-Enhancement","First-Good-Issue"]},{"title":"Support for Object Changesets as part of Finegrained Collection Notifications (Payloads)","body":"From https:\/\/github.com\/realm\/realm-android-adapters\/issues\/21#issuecomment-285349284\n\nRecyclerView animations have support for partial updates (payloads). This requires that our Finegrained Collection Notifications can provide individual Object Changesets for each individual object instead of just the index changed.\n\nSupport for object notifications will be implemented in #4101, and quite possible we could leverage that to provide payloads to the collection notifications. \n\nIt is unclear how expensive calculating the diff for each object in a big query result would be, but a hunch would be very. , so it is a bit unclear how the API could look like.\n\nSome ideas below. Any others?\n\n**Option A: Automatically calculated as part of the standard Changeset**\n```\npublic interface OrderedCollectionChangeSet() {\n  \/\/ ... old methods\n  \n  \/\/ Return changeset for the given index in the new array.\n  ObjectChangeset getChangePayload(long index); \n}\n\n\/\/ Usage\nRealmResults<Person> persons = realm.where(Person.class).findAll();\npersons.addChangeListener(new OrderedRealmCollectionChangeListener() {\n  @Override\n  public void onChange(RealmResults<Person> persons, OrderedCollectionChangeSet changeset) {\n    for (int index : changeset.getChanges()) {\n      adapter.notifyItemChanged(index, changeset.getChangePayload(index));\n    }\n  }\n});\n```\n\n* Advantage: Easy to use for developers and only require one smal change to a public interface\n* Disadvantage: Always calculating the object diff might be very expensive. I don't think we can lazily evaluate it, but we could probably keep the result on the C++ side until needed in Java.\n\n**Option B: Parameter to addChangeListener**\n```\n\/\/ Same change to OrderedCollectionChangeSet\n\n\/\/ Usage\nRealmResults<Person> persons = realm.where(Person.class).findAll();\nboolean calculatePayload = true;\npersons.addChangeListener(new OrderedRealmCollectionChangeListener() {\n  @Override\n  public void onChange(RealmResults<Person> persons, OrderedCollectionChangeSet changeset) {\n    for (int index : changeset.getChanges()) {\n      adapter.notifyItemChanged(index, changeset.getChangePayload(index));\n    }\n  }\n}, calculatePayload);\n```\n\n* Slightly more annoying setup, but object diff only calculated if specifically required.\n\nTODO\n- [ ] Design exact API\n- [ ] Blocked by Single Object Notifications #4101\n- [ ] Blocked by Object Store needing to support this","comments":[],"labels":["Blocked","T-Feature","Design-Required","Pipeline-Idea-Backlog"]},{"title":"Merge two RealmResult","body":"> We LOVE to help with any issues or bug you have!\n\n> **Questions**: If you have questions about how to use Realm, please ask on [SO](http:\/\/stackoverflow.com\/questions\/ask?tags=realm) - we monitor the Realm tag.\n\n> **Feature Request**: Just fill in the first two sections below.\n\n> **Bugs**: To help you as fast as possible with an issue or bug please describe your issue and the steps you have taken to reproduce it in as many details as possible.\n>\n> Thanks for helping us help you :-)\n>\n> Remove this and above before submitting.\n\n#### Goal\n\n> What do you want to achieve?\nI want to merge two result of Table User in RealmResult.\n`RealmResults<User> r1 = realm.where(User.class)\n                .equalTo(some condition)\n                .findAllSorted(\"timestamp\", Sort.ASCENDING);`\n`RealmResults<User> r2 = realm.where(User.class)\n                .equalTo(some condition)\n                .findAllSorted(\"timestamp\", Sort.DESCENDING);\n`\n#### Expected Results\nr=r1+r2\n> ?\n\n#### Actual Results\n\n>  E.g. full stack trace with exception\n\n#### Steps & Code to Reproduce\n\n> Describe your current debugging efforts.\n\n#### Code Sample\n\n```java\n\n> Your code here. Bigger samples should ideally be as separate Android Studio project, \n> in gists\/repositories or privately at help@realm.io)\n\n```\n\n#### Version of Realm and tooling\nRealm version(s): ?\n2.2.1\n\nRealm sync feature enabled: yes\/no\ndon't know\nAndroid Studio version: ?\n2.3\n\nWhich Android version and device: ?\n6 Moto X Play","comments":["Hi @DastanIqbal \r\nInteresting, sort of like a `CompositRealmResults`, but can you explain more about your use case? \r\n\r\n- Should the merged result be auto-updated?\r\n- How should the elements be merged? Just `[result1, result2]` or possibly mixed somehow?\r\n\r\nNote, it can already be accomplished today using:\r\n```\r\nList<User> combined = new ArrayList();\r\ncombined.addAll(result1);\r\ncombined.addAll(result2);\r\n```\r\n\r\nYou would miss out on some of the `RealmResults` special features, though. \r\n\r\n\r\n","@DastanIqbal You are looking for http:\/\/stackoverflow.com\/a\/34976540\/2413303 (although he is missing the `RealmChangeListener`)","Realm Core does not provide this functionality currently.","Thanks for the response guys.\r\n\r\n@cmelchior \r\n    Should the merged result be auto-updated?\r\n   ya it will but the end result will be result1+result2.\r\n\r\n    How should the elements be merged? Just [result1, result2] or possibly mixed somehow?\r\n    No, it will be just result1+result2.\r\n\r\nActually my first result1,  Users based on status like new,ongoing in ascending order(by timestamp) and then result2, Users based on status like canceled,resolved in descending order(by timestamp). \r\n\r\nits means new,ongoing will be on top, and then others.\r\n\r\nand my RecylcerViews Adapter are total depend on RelamResult. so I can't use ArrayList for now.\r\n\r\n@Zhuinden Ya I am using `RealmChangeListener` when anything changes in list.\r\n\r\n@kneth Thanks kneth, but Can you consider this issue in future release build?\r\n","You could conceivably implement this yourself, by creating a `CompositeRealmResults` class that extended `RealmResults` and accepts two or more RealmResults as input. You would then need to override all methods to account for the change in semantics, e.g `addChangeListener` should add the listener to more than one `RealmResults`, `first()` should only pick the result from the first RealmResults and so on.\r\n\r\nI won't rule out we can provide an implementation of this at one point, but it will unfortunately not have a high priority unless there is a big demand for it.","k thanks @cmelchior  let me try what you explained \r\n\r\nAnd realm is awesome. :)","@cmelchior RealmResults is a final class, can't extend.","It was made non-final in 2.2.2","@DastanIqbal [no it's not](https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/java\/io\/realm\/RealmResults.java#L53) since I think something like Realm ~~2.2.0~~ 2.2.2\r\n\r\nBut even then, you conveniently skipped this answer http:\/\/stackoverflow.com\/a\/34976540\/2413303","@Zhuinden I checked that answer, but not helping, my adapter using RealmResult, cannot migrate to List. :(  ","That statement is false.","@cmelchior How do I access BaseRealm its local class, require in constructor\r\nand constructor is also local.\r\nv3.0.0","Just created local package `io.realm`, everything is accessible now. ","@DastanIqbal Any progress? I'm interested in what you were able to implement.","I have a use case for this also; 'pinning' items to the top of an adapter.","Hi @rscottcarson,\r\nSorry for late reply,\r\n\r\nI used Arraylist to combined the result as @cmelchior mentioned in above comment\r\n```\r\npublic ArrayList<RealmResults<Bean>> getXObject() {\r\n        RealmResults<Bean> withName = realm.where(Bean.class).isNotNull(\"name\").findAllSorted(\"name\");\r\n        RealmResults<Bean> withOutName = realm.where(Bean.class).isNull(\"name\").findAllSorted(\"phoneno\");\r\n\r\n        ArrayList<RealmResults<Bean>> xInvites = new ArrayList<>();\r\n        xInvites.add(withName);\r\n        xInvites.add(withOutName);\r\n\r\n        return xInvites;\r\n    }\r\n```\r\nand I used @Zhuinden [link ](http:\/\/stackoverflow.com\/a\/34976540\/2413303) modified little for RealmAdapter\r\n```\r\npublic abstract class RealmMultiAdapter<T extends RealmObject> extends RecyclerView.Adapter {\r\n\r\n    protected List<RealmResults<T>> realmResults;\r\n    protected Context context;\r\n    private RealmBaseAdapter<T> realmBaseAdapter;\r\n\r\n    public RealmMultiAdapter(Context context) {\r\n        this.context = context;\r\n    }\r\n\r\n    public void setRealmList(List<RealmResults<T>> realmResults) {\r\n        this.realmResults = realmResults;\r\n    }\r\n\r\n    \/**\r\n     * Returns how many items are in the data set.\r\n     *\r\n     * @return count of items.\r\n     *\/\r\n    public int getCount() {\r\n        if (realmResults == null) {\r\n            return 0;\r\n        }\r\n        int count = 0;\r\n        for (RealmResults<T> realmResult : realmResults) {\r\n            count += realmResult.size();\r\n        }\r\n        return count;\r\n    }\r\n\r\n    \/**\r\n     * Returns the item associated with the specified position.\r\n     *\r\n     * @param i index of item whose data we want.\r\n     * @return the item at the specified position.\r\n     *\/\r\n    public T getItem(int i) {\r\n        if (realmResults == null || realmResults.size() == 0) {\r\n            return null;\r\n        }\r\n        int count = 0;\r\n        for (RealmResults<T> realmResult : realmResults) {\r\n            if (i < realmResult.size() + count) {\r\n                return realmResult.get(i - count);\r\n            }\r\n            count += realmResult.size();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    \/**\r\n     * Returns the current ID for an item. Note that item IDs are not stable so you cannot rely on the item ID being the\r\n     * same after {@link #notifyDataSetChanged()} or {@link #updateRealmResults(List<RealmResults<T>>)} has been called.\r\n     *\r\n     * @param i index of item in the adapter.\r\n     * @return current item ID.\r\n     *\/\r\n    @Override\r\n    public long getItemId(int i) {\r\n        \/\/ TODO: find better solution once we have unique IDs\r\n        return i;\r\n    }\r\n\r\n    \/**\r\n     * Updates the RealmResults associated to the Adapter. Useful when the query has been changed.\r\n     * If the query does not change you might consider using the automaticUpdate feature.\r\n     *\r\n     * @param queryResults the new RealmResults coming from the new query.\r\n     *\/\r\n    public void updateRealmResults(List<RealmResults<T>> queryResults) {\r\n\r\n        this.realmResults = queryResults;\r\n        notifyDataSetChanged();\r\n    }\r\n\r\n    public RealmBaseAdapter<T> getRealmAdapter() {\r\n\r\n        return realmBaseAdapter;\r\n    }\r\n\r\n    public void setRealmAdapter(RealmBaseAdapter<T> realmAdapter) {\r\n\r\n        realmBaseAdapter = realmAdapter;\r\n    }\r\n}\r\n```\r\nthen after you can extend RealmMultiAdapter with your adapter. \r\n```\r\npublic class BeanAdapter extends RealmMultiAdapter<Bean>{\r\n```\r\nafter that same rule as you follow for other realm adapter.\r\n\r\nPS: I was expecting something else, but I compromised with this solution.","EDITED according to @Zhuinden \r\nI know this may look very hacky but this is how I managed to do it:\r\n```\r\n    public Observable<ArrayList<Project>> getUserProjects(int userId) {\r\n        return getDatabase()\r\n                .where(User.class)\r\n                .equalTo(\"id\", userId)\r\n                .findFirstAsync()\r\n                .asObservable()\r\n                .doOnUnsubscribe(()->closeConnections(1))\r\n                .filter(result -> result.isLoaded() && result.isValid())\r\n                .cast(User.class)\r\n                .map(user -> {\r\n                    ArrayList<Project> projects= new ArrayList<>();\r\n                    projects.addAll(user.getProjectsJoined());\r\n                    projects.addAll(user.getProjects());\r\n                    Collections.sort(projects, (o1, o2) -> -o1.getCreatedAt().compareTo(o2.getCreatedAt()));\r\n                    return projects;\r\n                });\r\n    }\r\n```","I don't see why you would map them to a `RealmList` if it's not actually a managed link between managed objects.\r\n\r\nIt would make more sense for it to be \r\n\r\n``` java\r\nList<Project> projects = new ArrayList<>(user.getProjectsJoined().size() + user.getProjects().size());\r\n```","You're absolutely right. I just did it that way because all of my adapters inherit from RealmAdapter, I know ArrayList is lighter... I am not even using auto update... otherwise it wouldn't have made any sense.","Another use case: showing user search results, with any matching at the start showing first, and any matching anywhere in the word showing second. ","\u27a4 Edwin Monk-Fromont commented:\n\nAnother use case: showing user search results, with any matching at the start showing first, and any matching anywhere in the word showing second.","> I have a use case for this also; 'pinning' items to the top of an adapter.\r\n\r\nYes i have the same requirement, do we have any direct method available from realm other than the workarounds suggested by [DastanIqbal](https:\/\/github.com\/DastanIqbal) commented [on May 23, 2017](https:\/\/github.com\/realm\/realm-java\/issues\/4301#issuecomment-303274243) "],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Better RxJava support","body":"Right now the interop between RxJava and Realm is not as good as it could be, which is also the feedback we are constantly getting.\n\nThis issue is mostly an attempt at summarizing the situation and making sure we have the information in one place instead of being spread out across multiple issues that do not address the full picture.\n\n# The Current Situation\nCurrently, we have 3 major issues preventing great compatibility with RxJava:\n\n1. No support for [Schedulers](https:\/\/github.com\/ReactiveX\/RxJava\/wiki\/Scheduler).\n2. Streams work on immutable objects. Realm uses [live objects](https:\/\/realm.io\/news\/live-objects-fine-grained-notifications-realm-update\/).\n3. Thread confinement makes it hard to move work across threads.\n\nI'll try to describe each case below and possible solutions. \n\n# Challenges\n\n## 1. Custom Schedulers\n\nRealm's async query methods do not allow the use of custom schedulers.\n\nTake this example.\n\n```java\nrealm.where(Person.class).findAllAsync().asObservable()\n  .subscribeOn(Schedulers.io())\n  .subscribe(...);\n```\n\nThis will not run the query on the `io()` thread as one might expect, but on Realm's worker thread. \nOn closer inspection though, this is natural, as `findAllAsync()` is executed outside the \ncontext of RxJava.\n\nThe obvious solution is to make `RealmQuery` observable.\n\n```java\nrealm.where(Person.class).asObservable()\n  .flatMap(new Func1<RealmQuery<Person>, Observable<RealmResults<Person>>>() {\n        @Override\n        public Observable<RealmResults<Person>> call(RealmQuery<Person> query) {\n            return query.findAll().asObservable();\n        }\n    })\n  .subscribeOn(Schedulers.io())\n  .subscribe(...);\n```\n\nAn implementation was started, but never completed here: https:\/\/github.com\/realm\/realm-java\/pull\/1978\n\nThis implementation has a lot of benefts:\n- The flatmap function could also do a `copyFromRealm` for those who wants that. And it would happen on a background thread.\n- The flatmap operation decide if `findAll\/findAllSorted\/...` is used. The alternative would be to duplicate all `find*` methods as `find*Observable()`, which feels like overkill, especially considering RxJava2 which have more stream types.\n- Full interop with all RxJava Schedulers, also test schedulers.  \n- `findAllAsync` and friends would still be available to those not caring about schedulers or uses RxJava.\n\n**Challenges**\n- Annoying to force flatmap onto everyone. Perhaps we could convert `realmResults.asObservable()` to an observable on the query behind the scenes. Every RealmResults tracks it's original query anyway, at least on a native level. This could be a v2 of his API. The downside is that it would waste work with `findAll().asObservable()` as the observable would discard the original query result and rerun the query in the observable. \n- We need to solve the thread confinement issue (See below) in order to make it easy to move the query object across threads.\n\n\n## 2. Event streams vs. live objects\n\nRxJava exposes data as streams. This naturally promotes immutable objects as any change should be represented by another event being pushed down the stream. This conflicts with Realms \"live\" nature where objects are being updated behind the scenes.\n\nSpecifically, it causes problems with RxJava operators like `buffer()` (or any operator that caches items), as the object in the cache might be updated when the developer doesn't expect it.\n\nThe obvious solution is of course to provide the capability of creating \"snapshots\" or \"pinned\" versions of Realm objects.\n\nThis is not trivial, so I'll try to sketch a few solutions:\n\n\n### 1) Use [`copyFromRealm()`](https:\/\/realm.io\/docs\/java\/latest\/api\/io\/realm\/Realm.html#copyFromRealm-E-)\n\nThis will obviously work since it caches the data in memory, but detaching objects from Realm comes with a real cost in terms of memory and performance. Copying an entire object graph can be potentially very expensive and you might end copying a lot of data not really needed.\n\nPeople going down this route should probably consider mapping Realm objects to View models instead. Since View models only contain the data actually required by the UI, nothing will thus be lost by fetching that data ahead of time. \n\nThis approach has problems for very large query results where it will not be possible to copy them into memory.\n\n```java\nrealm.where(Person.class).asObservable()\n    obs.flatMap(new Func1<RealmQuery<Person>, Observable<RealmResults<Person>>>() {\n        @Override\n        public Observable<RealmResults<Person>> call(RealmQuery<Person> query) {\n            \/\/ Copy into memory before sending data further down the stream\n            \/\/ Possible this could be done one internally in the `asObservable()` method\n            \/\/ TODO solve thread confinement for `realm`.\n            return query.findAll().asObservable()\n                .map(result -> realm.copyFromRealm(result));        \n        }\n    })\n  .subscribe(...);\n```\n\n\n### 2) Frozen\/pinned objects\n\nFrozen objects as a concept has been discussed here: https:\/\/github.com\/realm\/realm-java\/issues\/1208\n\nThe basic idea is that it should be possible to \"freeze\" or \"pin\" a RealmResults or RealmObject to a specific version of Realm. With the snapshot concept implemented in Core\/ObjectStore, the native memory concern described in #1208 is now solved.\n\nThe problem with pinning versions is that it can lead to file size explosions since Realm must track the difference between the oldest and newest version of the Realm. So if a version is pinned for a long time it could lead to file size issues. Core is thinking about improving this situation (https:\/\/github.com\/realm\/realm-core\/issues\/984) and Java could implement automatic compaction when opening the Realm file (https:\/\/github.com\/realm\/realm-java\/issues\/3739), but neither would solve the underlying problem completely.\n\n**Important: We miss real-world information about how the filesize will be impacted in RxJava heavy apps if we introduce versioning pinning. This would need further investigation.**\n\n`ThreadSafeReference` as implemented by Cocoa (https:\/\/realm.io\/docs\/swift\/latest\/api\/Classes\/ThreadSafeReference.html) and tracked for Java here: https:\/\/github.com\/realm\/realm-java\/issues\/4059 will also pin versions, so the concept might be used as a substitute for the API proposed in #1208.\n\nCompared to `copyFromRealm()`, pinning exchanges memory pressure for disk pressure. \n\n```java\nrealm.where(Person.class).asObservable()\n   .flatMap(new Func1<RealmQuery<Person>, Observable<RealmResults<Person>>>() {\n        @Override\n        public Observable<RealmResults<Person>> call(RealmQuery<Person> query) {\n            \/\/ Pin the version before sending sending data further down the stream\n            \/\/ Possible this could be one internally in the `asObservable()` method\n            \/\/ TODO solve thread confinement for `query`.\n            return query.findAll().asObservable().map(result -> result.freeze());        \n        }\n    })\n  .subscribe(...);\n```\n\n**Challenges**\n- With the current proposed API. You cannot tell the difference between frozen\/non-frozen objects unless you call `isFrozen()\/isPinned()`. This is, however, the same for managed\/unmanaged objects.\n- We would also have to introduce pinning for `RealmQuery` and `Realm` classes.\n\n### 3) Autovalue\n\nPeople into RxJava frequently ask for Autovalue support, since it gives immutable objects with no setters (unlike standard Realm model classes) and final fields.\n\nNative support for AutoValue would be extremely hard and would under the hood either be implemented as 1) or 2) anyway. Also, updates to an object would be equivalent to a `copyToRealm` which would be extremely wasteful. See https:\/\/github.com\/realm\/realm-java\/issues\/2538. For now, the advice would be that if you really want AutoValue support you should make a new class with conversion functions between Realm and the AutoValue object. Effectively splitting your domain into \"Entity classes\" and \"View model classes\" as promoted by the Clean Architecture proponents.\n\n```java\nrealm.where(Person.class).asObservable()\n  .flatMap(new Func1<RealmQuery<Person>, Observable<RealmResults<Person>>>() {\n        @Override\n        public Observable<RealmResults<Person>> call(RealmQuery<Person> query) {\n            \/\/ Convert to AutoValue object before sending sending data further down the stream\n            return query.findAll().asObservable()\n                .map(result -> \n                    List l = new ArrayList();\n                    for (Person p : result) {\n                      l.add(AutoValuePerson.from(p));\n                    } \n                    return l;\n                );        \n        }\n    })\n  .subscribe(...);\n```\n\n## 3. Thread Confinement\n\nRealm's thread confinement and RxJava's streams both attempt to solve the problem of \"Concurrent access is really, really hard\". Unfortunately, the two approaches are not really compatible. The primary motivating case is:\n\n```java\nrealm.where(Person.class).asObservable()\n   .flatMap(new Func1<RealmQuery<Person>, Observable<RealmResults<Person>>>() {\n        @Override\n        public Observable<RealmResults<Person>> call(RealmQuery<Person> query) {\n            return query.findAll().asObservable();\n        }\n    })\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(...);\n```\n\nHere we want to do the work on the `io()` thread and get the results on the UI thread, but this will throw the dreaded `llegalStateException: Realm access from incorrect thread.` exception. \n\nBefore discussing solutions I would like to iterate how Realm and RxJava respectively solve the concurrent modifications problems:\n\n**Realm**\nEach thread operates on its own version of Realm data (MVCC). This gives each thread a fully consistent view of the entire object graph.\nIf we allowed different versions of data to be read on the same thread, it would increase the chance of accidentally trying to operate or compare two objects of different versions which can easily lead to subtle bugs. Each thread advances to the next version at well-defined times (Looper event, transactions) and change listeners are used to notify the user about these events.\n\nBy definition, thread-confined object cannot be accessed by multiple threads. \n\n**RxJava**\nAll data is exposed as a stream of events. Single objects are not modified, but transformed. This means that any change to data will be modeled as a new event being put into the stream. RxJava does not prevent you from accidentally composing streams that operate on different versions of some data. Because changes should be represented as transformations that result in new objects (events), this naturally promotes immutable objects. Data should only be manipulated inside the stream, never from the outside.\n\nBy definition, transforming immutable objects inside a stream, cannot cause concurrent modifications.\n\n**Takeaway**\nOne observation from this is that allowing mutable Realm data to be read from any thread is a very huge anti-pattern. It will conform to neither the original Realm design nor the stream approach. This leads to the conclusion that any solution to thread confinement must operate on a pinned version of the Realm data.\n\nSome of the solutions that exist for this:\n\n### 1. Use `copyFromRealm()`\n\nCopying the data from Realm will prevent them from being updated by Realm. Immutability is not guaranteed since the Realm Model class most likely will have mutator methods. If that is a concern then people should map the classes to a ViewModel class that is immutable. \n\n-  `copyFromRealm()` does not solve the problem on how to move e.g queries and Realm instances across threads as described for custom schedulers.\n\n- `copyFromRealm()` exchanges memory for disk space.\n\n- We already have it today, so it is a pragmatic solution.\n\n\n### 2. `ThreadSafeReference`\n\n`ThreadSafeReference` (https:\/\/realm.io\/docs\/swift\/latest\/api\/Classes\/ThreadSafeReference.html) as designed in Cocoa only works once, but we could change semantics so it could be used multiple times.\n\nThe idea is that all observables are changed, so instead of returning live objects, they returned pinned objects wrapped in a `ThreadSafeReference<?>`.\n\n```java\n\/\/ Variant A: ThreadSafeReferencs in the entire chain\n\/\/ The Generic arguments gets insanely complicated\n\/\/ Forced to use `x.get().y` for all interactions\nrealm.where(Person.class).asObservable()\n    .flatMap(new Func1<ThreadSafeReference<RealmQuery<Person>>, Observable<ThreadSafeReference<RealmResults<Person>>>>() {\n        @Override\n        public Observable<ThreadSafeReference<RealmResults<Person>>> call(ThreadSafeReference<RealmQuery<Person>> query) {\n            \/\/ .get() resolves the reference.\n            return query.get().findAll().asObservable();\n        }\n    })\n    .filter(results -> results.get().isLoaded()) \/\/ Common to only continue when loaded. This is the reason .get() must work multiple times.\n    .map(results -> results.get().first()) \/\/ Fetch first object\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(...);\n\n\/\/ Variant B: ThreadSafeReferences for query, then copyToRealm\nrealm.where(Person.class).asObservable()\n    .flatMap(new Func1<ThreadSafeReference<RealmQuery<Person>>, Observable<ThreadSafeReference<RealmResults<Person>>>>() {\n        @Override\n        public Observable<ThreadSafeReference<RealmResults<Person>>> call(ThreadSafeReference<RealmQuery<Person>> query) {\n            return query.get().findAll().asObservable();\n        }\n    })\n    .map(results -> results.getRealm().copyFromRealm(results.get()))\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(...);\n```\n\n- Would solve the problem and would expose \"pinned\" objects in the type system.\n- Calling `get()` everywhere would be a bit annoying.\n- The downside is that it would force everyone into the ThreadSafeReference class even if not needed.\n- Lifecycle management of pinned Realms would depend on the GC. It is unclear how many issues this would cause. From Java's perspective a Realm is just a long pointer, but it might hold 10's of MB's of native memory.\n\n\n### 3. `.pin()` or `.freeze()`\n\nAs discussed here https:\/\/github.com\/realm\/realm-java\/issues\/1208\n\nThe downside is it was originally meant for RealmObject\/RealmResults\/RealmList classes. It is not clear how well it would work for e.g Realm\/RealmQuery classes.\n\nEffectively it would take the `ThreadSafeReference` concept and implement it behind the scenes\n\n\n```java\nrealm.where(Person.class).asObservable()\n   .flatMap(new Func1<RealmQuery<Person>, Observable<RealmResults<Person>>>() {\n        @Override\n        public Observable<RealmResults<Person>> call(RealmQuery<Person> query) {\n            \/\/ query.isPinned() == true;\n            return query.findAll().asObservable().map(results -> results.pin());\n        }\n    })\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(...);\n````\n\nThe internal code changes required to support frozen objects will probably be quite large and could have a quite big impact on performance as all accessors most likely will require additional logic.  \n\n\n### 4. Other solutions\n\nNo other solution has been thoroughly thought through yet, so a number of solutions could be found here:\n\n- Implement `PinnedRealmResults`, `PinnedRealmList`, `PinnedRealm`, etc. versions. Could result in quite a lot of new classes\n- Others?\n\n# Conclussion \/ TLDR\n\n- We need to implement `RealmQuery.asObservable()`. Solving how to move queries across threads will have a lot of influence on how pinning\/thread confinement should be solved as well.\n- We need to investigate how pinning versions in RxJava heavy apps effect the file size. This should drive the decision for choosing pinning or `copyFromRealm` as the default solution. Most likely we will have to offer both in any case. Having the `RxObservableFactory` interface is nice here as we can easily provide multiple solutions that people can swap easily.\n- `copyFromRealm()` might not be the \"pure\" solution, but it is pragmatic.\n- `ThreadSafeReference` as implemented by Cocoa is not suited for RxJava support. As a minimum we must provide the option of getting the value multiple times on multiple threads.\n\n\nI'll try to keep this post updated with more information and QA.","comments":["cool","ThreadSafeReference makes sense :smile: \r\n\r\nSometimes I wonder how one could force only the Nth and N-1th Realm version to exist, but release the previous ones while freezing.\r\n\r\nI think a lot of people had issues with Rx mostly because they misunderstood what the Rx support does.","Frozen Object support has been merged to the Core-6 branch: https:\/\/github.com\/realm\/realm-java\/pull\/6107. This should make it a lot easier to make immutable Realm objects and transfer them across threads while still retaining the lazy-loading properties. The API is still in beta so any feedback is appreciated.","@cmelchior thank you and really appreciate for making #6107 happen. I am currently trying to apply Core-6 to our current project. I have a couple of questions for you base on your changelogs about `Equality and hashcode`\r\n1. Why equality currently depends on versionID? (Sorry I am pretty new Realm)\r\n2. Does frozen object do deep comparison inside equals and hashcode?\r\n","Question here on trying to schedule our team's adoption of the much-needed frozen objects solution: any idea when the iOS and\/or .NET\/Xamarin implementations will hit public availability? (even in beta form)\r\n\r\nWe won't hold you hostage to it, but it would really help to have a general idea (ie: is it March\/spring-time VS later)","[Frozen objects for obj-c\/swift are just awaiting review](https:\/\/github.com\/realm\/realm-cocoa\/pull\/6427), so you could potentially start trying it out now. We're expecting it to be very quick and easy to do in .NET (as all of the problems should have been sorted out while implementing it for the other SDKs and it just needs to be exposed in the C# API), but I think it hasn't been started yet.","@tgoyne Thomas thanks a ton for the super expedient reply. That\u2019s extremely comforting to know. Excited for what this enables for Realm - particularly with multi-tier \/ apps that have separate presentation and domain layers.\r\n\r\nCheers!"],"labels":["T-Feature","Pipeline-Idea-Backlog"]},{"title":"Implement method createRealmIfMigrationNeeded()","body":"#### Goal\n\nUse of `deleteRealmIfMigrationNeeded()` can be error prone, in applications that the data is critical, this method can be a big problem. Removing this method will force the app crash and doesn't sound a good solution to maintain the data.\n\nOne of the apps that I developed, for example, allow a internal backup of data. This method would be useful to export the old version database and verify what is wrong, restoring the user data if needed.\n\n#### Expected Results\n\nImplement a new method called `createRealmIfMigrationNeeded()` that creates a new Realm database file and rename the old one for future restore of data during the migration. The developer must know that it would be a security and storage problem, so this method doesn't come enabled by default.\n\nThank you very much.","comments":["@ppamorim Thanks for the suggestion.","@ppamorim\r\nWhy are you using `deleteRealmIfMigrationRequired()`?\r\nIn your case it sounds like you should define a migration function instead? If you are concerned about something going wrong during the migration, you can catch the `RealmMigrationNeededException` and backup the file then?\r\n","It is possible to check schema version through DynamicRealm API, and use `migrateRealm(RealmConfiguration)` method to handle migration manually if needed","@cmelchior Our application must be available 100% of the time, even for new updates or not. so as a workaround, I added this method but appeared error prone. The method `RealmMigrationNeededException` could not be used because it will generate a invalid state of application.\r\n@Zhuinden This is post migration."],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Fine-grained Collection Notifications: Detect moves","body":"Right now moves are reported as delete\/add pairs in our OrderedRealmCollectionChangeListener interface. We should report these correctly as moves since e.g `RecyclerView` will animate these differently. \n\nBlocked on: https:\/\/github.com\/realm\/realm-object-store\/issues\/391","comments":[],"labels":["T-Enhancement","Blocked"]},{"title":"Improve native crash reporting & enable assertions","body":"As per the weekly Java meeting discussion (21\/02\/2017), in order to increase stability and make it easy for users to track and report native crashes,  we suggest to add a flag via the Realm gradle DSL to enable and facilitate debugging and gathering of native crashes.\n\nThis could be in the form of \n```groovy\nrealm {\n  syncEnabled = true;\n  enableAssertions = true;\n}\n```\nwhich should download the Realm dependencies with symbols, and assertions enabled, and probably in the future a helper to unwind the native stack trace.\n\nUsers could use progressive rollout (or A\/B testing) to ship this version of Realm in order to investigate a native crash on a specific device. So far, this process has been tedious & subject to user feedback & device availability.\n\nThis issue helps gathering ideas, constraints and limitations","comments":["cc @realm\/java ","Realm Core and Object Store have many assertions,  but we can also add some in our C++ code. @beeender suggested that we don't convert all C++ exceptions to Java exceptions. The error states, he wishes to see, might be better caught as an assertion."],"labels":["T-Enhancement"]},{"title":"find method to look up object by primary key","body":"Right now to look up a single object by primary key, you have to make a full query and then do a `findFirst()`.\n\nIt would be nice if you could do a direct lookup with a method like:\n\n```java\nMyObject obj = realm.find(MyObject.class, objId);\n```\n\n(the Swift, C# and Javascript bindings all have methods like this)","comments":["This was already partly tracked here: https:\/\/github.com\/realm\/realm-java\/issues\/2166, just called `get()`. We should probably use the same name as the other bindings though."],"labels":["T-Enhancement","Design-Required"]},{"title":"Use FieldDescriptor instead of `getColumnIndexForSort` in OrderedRealmCollectionImp","body":"remove `getColumnIndexForSort` and use `FieldDescriptor`. Also need to check the exception message. Or maybe just `RealmObjectSchema` like `RealmQuery`?\n\n","comments":[],"labels":["T-Internal"]},{"title":"Support IdelingResource (Espresso)","body":"When UI testing using Espresso, it can automatically detect when all async work has completed. This way it knows when the system is \"stable\" so it can query the UI state. This is done using a concept known as `IdelingResource`: https:\/\/developer.android.com\/reference\/android\/support\/test\/espresso\/IdlingResource.html\n\nTo ease Espresso UI testing with Realm we should expose our internal thread pools in such a way that they can be made compatible with this interface. \n\nI can see us doing it in 2 steps:\n\n1) Make our executors public somehow, either through public fields or getters. Not sure how  #3834 will effect this. @beeender ?\n\n2) Provide some copy-paste snippet code on the website showing how to use it. \n\nImplementing `IdelingResource` directly ourselves is probably not possible as we do not want to depend on the Espresso dependency outside testing.\n\nExample of this being used here:\nhttp:\/\/blog.sqisland.com\/2015\/04\/espresso-custom-idling-resource.html\nhttps:\/\/github.com\/chiuki\/espresso-samples\/blob\/master\/idling-resource-intent-service\/app\/src\/androidTest\/java\/com\/sqisland\/espresso\/idling_resource\/intent_service\/IntentServiceIdlingResource.java\nhttps:\/\/github.com\/chiuki\/espresso-samples\/blob\/master\/idling-resource-intent-service\/app\/src\/androidTest\/java\/com\/sqisland\/espresso\/idling_resource\/intent_service\/MainActivityTest.java","comments":["https:\/\/github.com\/AzimoLabs\/ConditionWatcher this is much more reliable than IdlingResource imo","After #3834, only the async transaction will be using executors, and from the executor perspective, it will have no difference compared with before.","So for us to support this I would assume we need to expose information from the ObjectStore worker thread somehow?","yeah, but i am not quite sure if it is doable. The \"worker thread\" in the Object Store is actually a daemon thread which lives always. And it is waiting on `epoll` events when it is in idle."],"labels":["T-Enhancement"]},{"title":"Support Kotlin delegated properties for Realm objects","body":"Realm objects do not support Kotlin delegated properties, making it impossible to add custom setters (ie: observable) to Realm properties.\n\nThis seems to be due to the limitation that the annotation processor tries to prevent final fields from being mapped to Realm fields. Instead it should be made smart enough to recognize if the value is a delegated property and allow the delegate to assign the value on its own. The delegated object will take care of storing the value internally and doing the right thing.\n\nNote the related issue https:\/\/github.com\/realm\/realm-java\/issues\/2921 which makes it unable to assign the \"@Ignore\" annotation to a delegated property either (big limitation) which means you cannot use delegated properties for even NON-Realm properties. This related issue should be a P1 since it effectively makes Realm incompatible with Kotlin - as is likely less effort than adding proper support for delegated properties.","comments":["Hi @marchy \r\n\r\nI was looking a bit at this. A few observations:\r\n\r\n**First:** \r\n```\r\n@Ignore open var foo: String by Delegate()\r\n```\r\nIs not prevented by Realm. Android Studio tells me \"[WRONG_ANNOTATION_TARGET] This annotation is not applicable to Member property with Delegate\". I don't fully understand yet why since our annotation has the `ElementType.FIELD` target specifier. Possible some limitation in Kotlin?\r\n\r\n**Second:**\r\nGiven this sample class:\r\n```\r\nopen class Dog : RealmObject() {\r\n    open var del: String by Delegate()\r\n}\r\n```\r\n\r\nThe resulting java code is\r\n```\r\npublic class Dog extends RealmObject {\r\n   @NotNull\r\n   private final Delegate del$delegate = new Delegate();\r\n   \/\/ $FF: synthetic field\r\n   private static final KProperty[] $$delegatedProperties = new KProperty[]{(KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Reflection.getOrCreateKotlinClass(Dog.class), \"del\", \"getDel()Ljava\/lang\/String;\"))};\r\n\r\n   @NotNull\r\n   public String getDel() {\r\n      return this.del$delegate.getValue(this, $$delegatedProperties[0]);\r\n   }\r\n\r\n   public void setDel(@NotNull String <set-?>) {\r\n      Intrinsics.checkParameterIsNotNull(<set-?>, \"<set-?>\");\r\n      this.del$delegate.setValue(this, $$delegatedProperties[0], <set-?>);\r\n   }\r\n}\r\n```\r\n\r\nTo me it looks like the easiest way to support delegates would just be to treat any field with the `Delegate` class as automatically having the `@Ignore` annotation? Since the delegate has setter\/getter methods, it will be responsible for getting\/storing the data and if it does this by using another field in the Realm Model class that should work just fine.\r\n\r\nThat would also conveniently get us around the first problem. Would this solve your problem?\r\n\r\n","Digging a little further. Detecting when something is a delegate is not straight forward it seems: https:\/\/kotlinlang.org\/api\/latest\/jvm\/stdlib\/kotlin.properties\/-read-write-property\/\r\n\r\nIt looks like we cannot just check if a class implements the `ReadWriteProperty` since that is optional. That leaves us with a few ways of solving it:\r\n\r\n1) Just detect the naming pattern \"<fieldName>$delegate\" . This means we depend on an implementation detail though that might change without notice.\r\n\r\n2) Detect if the Delegate class implements `ReadWriteProperty`. People are not required to implement `ReadWriteProperty` though.\r\n\r\n3) We need to check for the presence of two methods in the class: `public String getValue(@NotNull Dog thisRef, @NotNull KProperty property)` and `public void setValue(@NotNull Dog thisRef, @NotNull KProperty property, @NotNull String value)`\r\n\r\nNeither of the 3 is 100% foolproof although I would guess the chance of the last one actually matching a wrong class as being virtually 0.","Some empirical testing shows that it isn't possible to annotate a delegated field, period. I tried allowing every `ElementType` option for the annotation and it still wasn't possible to add it. This means that this problem needs to be solved by one or some of the above options.","@marchy Have you had a chance to try any of the options?","@kneth I don't think this is on us to try the options. These options were referring to the Realm team implementing the annotations in different ways, right?","Yes, the above is something that we must implement","Hi,\r\n\r\nI was thinking that something like annotating a whole type to be ignored by realm could work.\r\n\r\nMaybe I'm wrong and you've considered that too, but adding a new annotation like for instance `@IgnoreType` targeting just _Types_ would render any property of that type to be `@Ignored`.\r\n\r\nMay that work? How does it sound to you @cmelchior ? ","Hi Again\r\n\r\nActually I think that it currently is supported annotating a property as follows\r\n\r\n```kotlin\r\n@delegate:Ignore val whatever by Delegate()\r\n```"],"labels":["T-Enhancement","O-Community"]},{"title":"Add example for showing how to store encryption key","body":"","comments":["Some more examples from @kotomisak \r\n\r\nhttps:\/\/github.com\/kotomisak\/db-showcase-android\r\n\r\nMore specifically:\r\n- https:\/\/github.com\/kotomisak\/db-showcase-android\/blob\/develop\/mobile\/src\/main\/java\/cz\/koto\/misak\/dbshowcase\/android\/mobile\/model\/ModelProvider.java\r\n- https:\/\/github.com\/kotomisak\/db-showcase-android\/blob\/develop\/mobile\/src\/main\/java\/cz\/koto\/misak\/dbshowcase\/android\/mobile\/ui\/control\/ControlRootViewModel.java\r\n\r\n","Is this related to https:\/\/github.com\/realm\/realm-android-user-store ?","Not really, although it uses the same concept. The idea is to show how to use a double layered key approach to store Realm encryption keys since the keystore does not allow you to extract the key material again, which is required by Realm.\r\n\r\nSo you \r\n1) Create a keystore and secure it using a fingerprint (because it's fun\/easy to show, but you can use pin or whatever)\r\n\r\n2) Then create a AES key outside the keystore and put the key inside the keystore. From the keystores point of view it will just see random bytes which it stores quite fine.\r\n\r\n3) Show that on startup you can use the fingerprint to get the Realm key out of the keystore again and you can now use it to unlock the Realm.\r\n\r\nThis works quite nicely offline and _is_ secure _if_ you trust that the keystore does its job correctly."],"labels":["T-Enhancement","Pipeline-On-Hold"]},{"title":"RFC: Primitive List API","body":"With work in Core slowly picking up speed regarding Primitive List support, we need to start thinking about how the public API is going to look like. Also, so it can guide the underlying implementation.\r\n\r\nThis document tries to flesh out the various proposals that have been discusse so we can get feedback on the direction as well as guide Cores design decisions.\r\n\r\nThoughts @realm\/java ?\r\n\r\nReferences #575 ","comments":["I prefer option 1. From a user's perspective is it easier: `RealmList<Long>` and `RealmList<Cat>` are \"just\" lists. Forcing the users to think about details of the types (`Long` and `Cat`) feels wrong.\r\n\r\nWe are pushing the fluent interface of the query engine. `RealmQuery` is becoming more and more bloated, and I think it is worth considering switching to the same query system as Realm JS. ","I think laxing the `extends RealmModel` and just using `Object` instead will help with and is actually a requirement of https:\/\/github.com\/realm\/realm-java\/issues\/1694\r\n\r\nBut if I have to write Realm queries by hand in Strings, I may as well go back to SQLite \r\n\r\nEDIT from the future: although I wouldn't mind an optional raw query api.","Depending on how Type Adapters are implemented that might not be necessary, but it would probably make a lot of things easier. Good point. \r\n\r\nRegarding the query system. We won't remove the typed API, but it is starting to squeak a bit under the weight of operators. So a string based API would live next to the typed one. At least that is the current idea.","For .NET, option 1 will probably work better - we use the standard `IList<T>` on which we can relax the generic constraint to allow all types, naturally, issuing a compile time error if used with anything other than `RealmObject` or valid primitive type. Since we're using LINQ, the RealmQuery method explosion doesn't concern us. The API will be type-safe, but it might be harder to expose some functionality, e.g. `like` searches.\r\n\r\nFrom an end-user POV, I too like 1 more, due to @kneth's argument.\r\n\r\ncc @kristiandupont @fealebenpae ","I'm in favour of relaxing the type requirement on `RealmList`. As discussed with Zaki we can still check at compile time (using the annotation processor) that the user doesn't abuse the generic, by using an unsupported type.\r\n\r\nExample: we can detect at compile time this `RealmnList<BigInteger>` and throw an exception","Good point. We should be able to catch all wrong types used in the annotation processor. Didn't think of that \ud83d\udc4d \r\n\r\nIf we relax the type parameters, I'm also secretly playing around with the idea of splitting out DynamicRealmObject from RealmObject since having to deal with both of them everywhere is a big hassle and put some rather annoying restrictions on what we can do in both classes.","Ah, then ability to get Realm \/ DynamicRealm from their corresponding classes will be a possibility :3","OK, I will start adding APIs with `option 1`.\r\n","In regards to `Design1, 4a`, how about accepting `null` as field name for primitive queries instead of adding new methods? @realm\/java ","> In regards to Design1, 4a, how about accepting null as field name for primitive queries instead of adding new methods?\r\n\r\nI can accept it. Feels kind of nature to me.","I think the 4a) option was not thought through. Querying would have to work like you would do with a `RealmIntegerWrapper` today but without the linked query.  Consider\r\n```\r\npublic class ListDemo extends RealmObject {\r\n  public RealmList<String> firstNames;\r\n  public RealmList<String> lastNames;\r\n  public String name;\r\n}\r\n\r\n\/\/ Currently with a wrapper type it would be \r\nrealm.where(ListDemo.class).equalTo(\"firstNames.value\", \"John\").findAll(); \r\n\r\n\/\/ With primitive support it would be\r\nrealm.where(ListDemo.class).equalTo(\"firstNames\", \"John\").findAll();\r\n\r\n\/\/ Breaks if you have multiple primitive lists\r\nrealm.where(ListDemo.class).equalTo(\"John\").findAll();\r\n```","Ah crap, now I remember:\r\n\r\n```\r\ndemo.firstNames.where().equalTo(null, \"John\");\r\n```\r\nSo I guess you are advocating for 4B with `null` as the secret keyword? What are you thoughs on the tradeoffs discussed?\r\n\r\nOne thing missing from the design doc description is that the extra methods are _only_ needed when querying the list directly. Something which I assume is done less frequently than the model in general. This at least means that adding a lot of extra methods have a bigger drawback","I made two PRs to define Primitive List API.\r\nOne is Design 1 (#5145) and another is Design 2 (#5139).\r\n\r\nI was thinking that I had a problem in `Design 1`, but now I solved most of them and now I'm leaning towards `Design 1`.","I strongly prefer Design 1 as well. There are a few caveats like `findFirstAsync()` not working on value lists and nullability annotations forcing null checks more places than strictly needed, but I think that is acceptable.","OK, I start implementing the feature on `Design 1`.\r\nI split the PR into smaller PRs.\r\n\r\n#5145: Part1: API changes (This PR)\r\n#5150: Nullability changes\r\n#5151: Solve compilation errors\r\n#5152: Tests\r\n#5168: RealmList's type check in Annotation Processor\r\n\r\nAnd I'll add a PR for annotation processor."],"labels":["T-Feature","Pipeline-On-Hold"]},{"title":"Optimize RealmCollection.contains()","body":"Fallout from #4111 \n\nIn the previous implementation we could optimize `contains` by checking the underlying indexes in the backing Table: `(table.sourceRowIndex(proxy.realmGet$proxyState().getRow$realm().getIndex()) != TableOrView.NO_MATCH);`\n\nHowever, this optimization did not work if people have had custom `equals` methods. In #4111 we always use `equals`, which however is quite slow for larger collections as we need to create an object for each entry in order to call `equals` on it.\n\nWe could optimize this by extending our proxy class with information about the existence of custom `equals` methods and if one doesn't exist, we can use the optimized variant.\n\n","comments":[],"labels":["T-Internal","Pipeline-Idea-Backlog"]},{"title":"Checkstyle should fail on missing space after assignment =","body":"Checkstyle doesn't seem to catch\n\n```\nFoo foo =new Foo();\n```\n\nThis should be fixed. Discovered while reviewing #3834\n\n","comments":[],"labels":["T-Internal"]},{"title":"Supports OkBuck build","body":"add a constructor to RealmTransformer which takes file path of configuration in order to support [OkBuck](https:\/\/github.com\/uber\/okbuck)\r\n\r\nfixes #3971 \r\n\r\nTODOs\r\n\r\n- [x] removing dependency to gradle from RealmTransformer\r\n- [x] added a constructor for OkBuck to RealmTransformer\r\n- [ ] changeling\r\n- [ ] need to solve the error https:\/\/github.com\/realm\/realm-java\/issues\/3971#issuecomment-276593640","comments":["There seems to be a problem in OkBuck. \r\nhttps:\/\/github.com\/realm\/realm-java\/issues\/3971#issuecomment-276593640\r\n\r\nBuild with OkBuck currently fails.","@malbano would you like to chime in on this?","@zaki50 I created https:\/\/github.com\/realm\/realm-java\/tree\/cm\/okbuck-example to have an example we could point to in the repo, but ran into https:\/\/github.com\/uber\/okbuck\/issues\/380 and https:\/\/github.com\/uber\/okbuck\/issues\/381 ","@cmelchior @zaki50 I posted the configuration fix in https:\/\/github.com\/uber\/okbuck\/issues\/380#issuecomment-277288291\r\n\r\nThe setup currently for the example is not correctly configured","Any luck with this? Or maybe when the RealmTransformer becomes Kotlin? :D","any progress?","Hi @meierjan Unfortunately not. We ran into some issues and figuring a way around those doesn't have a high priority right now. ","@meierjan (the current priority is preparing for RMP 2.0 scheduled for the end of ~~September~~ October, bringing in new features like primitive list support) \r\n\r\nAlso if I gathered it right, the problem is that OkBuck can execute transform task only if it is written with non-Groovy things. "],"labels":["T-Feature"]},{"title":"When print the exception message, it should print the line number with relative source path","body":"For example, when native exception happens, the java exception message will be formatted like:\n```\nException io.realm.exceptions.RealmError: Unrecoverable error. Failure when converting short string to UTF-16 error_code = 1; retcode = 0; StringData.size = 32; StringData.data =; in_begin = 7e6088a7e590165; in_end = ; out_curr = 0xffa95ffa; out_end = 0xffa96038; in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_UncheckedRow.cpp line 136\n```\n\nHere is showing the full path of the source code file `\/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_UncheckedRow.cpp`. It should be avoided by using a relative path instead.","comments":["Any reason why printing the full path is bad? I would imagine it is nice when it happens on a device?","@cmelchior because it looks weird that the crash originates from code that is apparently in `\/Users\/cm\/Realm\/` on your personal MacOSX PC device thing in the office"],"labels":["T-Enhancement"]},{"title":"Feature request - Soundex in Realm","body":"Would it be possible to implement something like this in Realm?\n\n```\nSELECT * FROM table WHERE name SOUNDS LIKE 'foo' ; \n```","comments":["Hi @mihirjoshi21 \r\nI assume you are talking about something equivalent to this MySQL function: http:\/\/www.w3resource.com\/mysql\/string-functions\/mysql-sounds_like-function.php ?\r\n\r\nThat isn't possible right now, and would have to be implemented in Realm Core first. I have created an issue there to track it: https:\/\/github.com\/realm\/realm-core\/issues\/2405\r\n\r\n"],"labels":["T-Feature","O-Community","Pipeline-On-Hold"]},{"title":"Support for ThreadSafeReference","body":"Hi,\n\nI have a question about ThreadSafeReference. This feature appeared recently for Objective-C and Swift: https:\/\/realm.io\/news\/obj-c-swift-2-2-thread-safe-reference-sort-properties-relationships\/.\nIs this feature planned also for Java in any of future releases?\n\nBest regards\nAleksander Mielczarek","comments":["I believe it depends on https:\/\/github.com\/realm\/realm-java\/pull\/3834 but it'll be pretty cool when it arrives \ud83d\ude04 ","Yup, surely we will support this in java!\r\nOne issue currently in my mind is, to support this, we will have to pin a `Realm` version to the `ThreadSafeRealmObject` (must be a better name than this!), unlike cocoa, we rely on GC to control the life cycle of the object, which means the pinned version will not be released until that thread-safe-object get GCed. potentially increase the Realm file size if there are many leaked thread-safe-objects belong to different Realm versions.\r\n\r\nBut let's see, it will be a very cool and important feature!","@beeender that sounds oddly reminiscient for https:\/\/github.com\/realm\/realm-java\/issues\/1208","Yes, depending on how the API ends up looking this might very well replace #1208, at this point we need to spec out the specifics though","The principle behind this doesn't look too difficult though, it seems this is for passing **1** object between two threads, so that you don't need to get the ID and requery the object on the other thread anymore.\r\n\r\nI'm probably missing the complexity at initial glance, though. This will be useful!"],"labels":["T-Feature","Design-Required","O-Community"]},{"title":"ProxyState should not be public","body":"ProxyState is public because of RealmObjectProxy is in the internal package.\n\nNeed to fix this after #3834 merged.\n\n","comments":[],"labels":["T-Bug"]},{"title":"Publish Doc\/UnitTest hybride app on Google Play to improve Realm QA","body":"The 2.0 cruise ship has sailed, and I suggest the following or something similar to be implemented so future releases don't have the same fate when it comes to QA. \n\n1) Realm should publish on Google Play a hybrid Doc\/Test app. The doc part includes some useful documentation which is just a webview that points to the website so Google think the app has some en-user \"value\". The app is frequently updated with latest weekly\/on-demand \"pre-release\"  realm-java\/realm-core beta code with unit tests complete with test results and pass\/fail count. Let everyone pitch in. Test results are pushed to realm after execution and all crashes are pushed\/logged as well. Only after enough users have hit the \"test\" button on the app for the beta branch and passed without crashing does the beta branch move to release. There is even a beta channel on Play that can be used to instantly push private beta releases to testers. With the beta channel feature, I would even suggest daily-per-commit uploads of apks to Play store beta channel. \n\n2) Compile and release beta-apk used to push to (1) in a beta branch. Sometimes, there is limited access to Google Play and beta testers can just visit github and click download\/install. Devs are humans and we are lazy. We want to test, but we don't want to spend 10 minutes to git pull and compile an apk. We got tv shows to catch. It takes 30 seconds for us to download a beta, install, and click run tests if available on Google Play or Github. \n\nNothing in house can match the device diversity of the devs. Let us help you test.","comments":["I like the testing part a lot. I am not sure if there is an existing easy way to run all unit test in a Activity based apk, but if we can do that, the apk can also be used in the testing farms.\r\nAnother thing is a logger write to local files will be very useful to debug.\r\n\r\nJust need time to proceed all those ...","It sounds like an appealing idea. Beside the actual app, it requires a lot of automation - otherwise we will either spend too much time looking at logs or ignore the logs.","I am thinking about making a phone benchmark tool which is based on all the Realm operations, something like the benchmark form 7zip and other zip tools.\r\nSo it is not only useful for testing Realm on different phones, but also useful for benchmarking the CPU\/DISK IO\/MEM for different devices. So there would be more motivation for people to download and use it."],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Javadoc for getGlobalInstanceCount and getLocalInstanceCount","body":"I tried to understand the methods `Realm.getLocalInstanceCount()` and `Realm.getGlobalInstanceCount()`. Shouldn't value returned from `getLocalInstanceCount()` always lower or equal to `getGlobalInstanceCount()`?\n\n![screen shot 2560-01-11 at 4 11 24 pm](https:\/\/cloud.githubusercontent.com\/assets\/2402083\/21842408\/346275a6-d819-11e6-8cf3-c12e82884a6f.png)\n\n","comments":["We are doing reference counting for Realm instances.\r\neg.:\r\n`Realm realm1 = Realm.getInstance(config1);`\r\nthis will create one global instance and on local instance since there is no Realm with config 1 opened before.\r\nIf you run ``Realm realm1 = Realm.getInstance(config1);`` on the SAME THREAD again, you will get still 1 global instance, but 2 local instances. And both of the local instances actually ref to the same `Realm` object.\r\n\r\nIf you run ``Realm realm1 = Realm.getInstance(config1);`` on a DIFFERENT THREAD (thread 2), a new global instance will be created and the local instances count for thread 1 stays the same, local instances count for thread 2 become 1.","Global instance count refers to the thread-specific Realm instance count. As in, how many open Realms exist globally across all threads.\r\n\r\nLocal instance count refers to the number of times this thread's thread-specific Realm instance was opened with `Realm.getInstance()` call.\r\n\r\nFor example, if you open Realm with `Activity.onCreate()` and close in `Activity.onDestroy()` and you have 3 open activities, then you'll see `global count 1, local count 3`.\r\n\r\nIt's because Realm instances are cached for a given thread, and they are closed when `local count` is 0.","Gotcha! Thanks for lightning fast responses @beeender @Zhuinden.","Re-opening so we can adjust the Javadoc for the methods, to better describe this."],"labels":["T-Doc","O-Community"]},{"title":"Investigate using native method to discover device CPU config","body":"This issue:\n\nhttps:\/\/github.com\/realm\/realm-java\/issues\/3810\n\n... was closed with a relatively unsatisfactory solution, here:\n\nhttps:\/\/github.com\/realm\/realm-java\/pull\/3997\n\nWe should explore an explicit native solution.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Unify Android & iOS Realm API","body":"Realm should make app development easier. App development today means crafting a native Android **and** iOS app (or webapp...). With that in mind, Realm gives the developers a very valuable tool. \n\nAs a developer, I want to write and understand Android and iOS code. Sadly Realm has a very different API for querying or modifying data. Some of those differences are really platform specific (consider object lifetime in garbage collecting vs. reference counting), but some of those differences are not necessary:\n\n1. Querying\n`realm.where(Dog.class).findAll()` vs `realm.objects(Dog.self)`\n\n2. Migration logic: \nSelect one style, see #2530 \n\n3. Filtering\n`.filter(\"color == brown\")`vs `.equalTo(\"color\", \"brown\")`\n\n\nIn all mentioned cases (and all further onces), please support either both ways in both platforms or decide on one way.","comments":["+1","@vonox7 the query differences stem from the fact that [iOS has \"NSPredicates\"](http:\/\/stackoverflow.com\/a\/27219973\/2413303) while Android does not.\r\n\r\nSo it would be a rather awkward API in Java to use a feature that is otherwise alien to any Java API.\r\n\r\nI am not a Realm member. But **any** iOS or Android code looks completely different. It is no wonder that an API designed for their respective platforms would also look different.","@Zhuinden: Supporting NSPredicates on Android would probably not be a good decision. But Swift supports functional programming, especially the [filter](https:\/\/developer.apple.com\/reference\/swift\/sequence\/1641239-filter) statement too. The same applies to [Java Streams](https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/util\/stream\/Stream.html) or [Kotlins filter](https:\/\/kotlinlang.org\/docs\/reference\/lambdas.html). With that in mind, Sequence\/Iterable operations on Android and iOS look exactly the same.\r\n\r\nThink about [RxAndroid](https:\/\/github.com\/ReactiveX\/RxAndroid) and [RxSwift](https:\/\/github.com\/ReactiveX\/RxSwift): ReactiveX is so popular because it allows a developer to think the same way, no matter which platform they are currently working on.","I am half way on this topic. One side, I like platform optimized coding. On the other hand I see this type of swift code in our code base:\r\n\r\nswift\r\n\r\n```swift \r\n.filter(SELECTED_COLUMN + \" > 0\")\r\n```\r\n\r\nvs  java\r\n\r\n```java\r\n.greaterThan(SELECTED_COLUMN, 0)\r\n```\r\n\r\nAnd at this point, I agree with @vonox7  that the java way is better. With dynamic query construction, NsPredicts is like half baked SQL construction with useless string allocations along the way. ",">  I see this type of swift code in our code base:\r\n> `.filter(SELECTED_COLUMN + \" > 0\")`\r\n> With dynamic query construction, NsPredicts is like half baked SQL construction with useless string allocations along the way.\r\n\r\nJust a side note, but you should consider using NSPredicate's keypath substitution to avoid the useless string allocations:\r\n\r\n`.filter( \"%K > 0\", SELECTED_COLUMN)`","+1","At Realm, we have two goals which not always are the same:\r\n\r\n * Enable developers to work cross-platform\r\n * Be ideomatic (Java and Objective C are very different)\r\n\r\nThe advantage of the current query system is that Android Studio provides completion which is a nice thing to have. A unified query language could be awesome as it will enable developers to work cross-platform :-)\r\n\r\nManual migrations are more flexible (e.g., combining two string properties into one is hard without manually moving data). For sync, all products are using the same migration mechanism (auto\/additive).\r\n","I think Realm-cocoa would benefit from such a nice query builder that Java has, and the dynamic realm api makes migrations easy\r\n\r\n","This seems odd because the RealmJS querying language is `NSPredicate` compatible? Correct me if I'm wrong.  \r\n\r\nThis is from the JS doc:\r\n```javascript\r\nlet dogs = realm.objects('Dog');\r\nlet tanDogs = dogs.filtered('color = \"tan\" AND name BEGINSWITH \"B\"');\r\n```\r\n\r\n@kneth The unified API is probably a superior experience. It'd make a lot of blogging and documentation consolidated into one language. ","@mbalex99 A unified API for queries has positive sides, and it isn't alien to us. See also #3351. \r\n\r\nCocoa and Java have different approaches to migrations, and you could also wish for a unified approach:#2530"],"labels":["T-Enhancement","Design-Required","O-Community"]},{"title":"OkBuck support","body":"#### Goal\n\n> Build my app that uses Realm with OkBuck.\n\n#### Expected Results\n\n> Build and runs normally as if I had built with Gradle.\n\n#### Actual Results\n\n>  The build and APK are successfully generated, but when I run the app an error is raised, forcing close the app. If I build the same dependencies with Gradle, not using [OkBuck](https:\/\/github.com\/uber\/okbuck), it runs perfectly. Logcat:\n\n```\nE\/AndroidRuntime( 3447): FATAL EXCEPTION: main\nE\/AndroidRuntime( 3447): Process: mobile.nonaka.com.nonakaapp.ci, PID: 3447\nE\/AndroidRuntime( 3447): java.lang.ExceptionInInitializerError: RealmTransformer doesn't seem to be applied. Please update the project configuration to use the Realm Gradle plugin. See https:\/\/realm.io\/news\/android-installation-change\/\nE\/AndroidRuntime( 3447): \tat io.realm.RealmConfiguration.<clinit>(RealmConfiguration.java:77)\nE\/AndroidRuntime( 3447): \tat io.realm.RealmConfiguration$Builder.initializeBuilder(RealmConfiguration.java:428)\nE\/AndroidRuntime( 3447): \tat io.realm.RealmConfiguration$Builder.<init>(RealmConfiguration.java:391)\nE\/AndroidRuntime( 3447): \tat mobile.nonaka.com.nonakaapp.NONAKAApplication.onCreate(NONAKAApplication.java:44)\nE\/AndroidRuntime( 3447): \tat android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1007)\nE\/AndroidRuntime( 3447): \tat android.app.ActivityThread.handleBindApplication(ActivityThread.java:4344)\nE\/AndroidRuntime( 3447): \tat android.app.ActivityThread.access$1500(ActivityThread.java:135)\nE\/AndroidRuntime( 3447): \tat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1256)\nE\/AndroidRuntime( 3447): \tat android.os.Handler.dispatchMessage(Handler.java:102)\nE\/AndroidRuntime( 3447): \tat android.os.Looper.loop(Looper.java:136)\nE\/AndroidRuntime( 3447): \tat android.app.ActivityThread.main(ActivityThread.java:5017)\nE\/AndroidRuntime( 3447): \tat java.lang.reflect.Method.invokeNative(Native Method)\nE\/AndroidRuntime( 3447): \tat java.lang.reflect.Method.invoke(Method.java:515)\nE\/AndroidRuntime( 3447): \tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)\nE\/AndroidRuntime( 3447): \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)\nE\/AndroidRuntime( 3447): \tat dalvik.system.NativeStart.main(Native Method)\n```\n> https:\/\/realm.io\/news\/android-installation-change did not help.\n\n#### Steps & Code to Reproduce\n\n> Build any app with Realm with [OkBuck](https:\/\/github.com\/uber\/okbuck) and run it.\n\n#### Code Sample\n\n> NONAKAApplication.java line 44 has this code:\n```java\n            RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this)\n                    .schemaVersion(1)\n                    .encryptionKey(realmKeyProvider.getRealmKey())\n                    .deleteRealmIfMigrationNeeded()\n                    .build();\n```\n\n> This is my Gradle configuration that I used to generate the Buck files:\n```\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath \"io.realm:realm-gradle-plugin:2.2.1\"\n    }\n}\n\napply plugin: 'realm-android'\n```\n\n#### Version of Realm and tooling\nRealm version(s): 2.2.1\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 2.2.3\n\nWhich Android version and device: Any device\nminSdkVersion 18\ntargetSdkVersion 25\ncompileSdkVersion 25\nbuildToolsVersion '25.0.2'\n\nOkBuck: 0.13.1\n\nGradle: 3.2\n\nAndroid Gradle Plugin: 2.2.3\n\nThanks a lot.","comments":["That's because OkBuck doesn't support the Transform API yet.\r\n\r\n![image](https:\/\/cloud.githubusercontent.com\/assets\/11718392\/21581482\/be1602ec-d033-11e6-977e-ab1489a63cfa.png)\r\n","@Zhuinden didn't notice that. Thanks a lot! Does anyone know though if it is possible to use Realm without this Transform API (maybe a older version of Realm)?","The last Realm that does not use the Realm-Transformer and the Transform API is `compile \"io.realm:realm-android:0.87.5\"`\r\n\r\nIn that version of Realm, RealmObjects cannot have custom methods, and custom logic in getters\/setters.\r\n\r\nAlso, RealmResults are live in transactions, so you need to reverse iterate them instead of using `for(Blah blah: blahs)`.","@Zhuinden thanks man. It helped me a lot!","Transform api support is actually available in okbuck, but it is not documented yet. It's a bit of work to setup right now, so we are working to make it more plug and play and will document it fully at that point.","Thanks for the info @kageiit \ud83d\udc4d ","Just for future reference:\r\nhttps:\/\/github.com\/uber\/okbuck\/issues\/305","Question for Realm maintainers. The way transforms work in buck is that they do not have access to the gradle project model as they are run like commandline applications. This would require the RealTransformer to provide an alternate constructor that can accept a config file as an input for various configuration options instead of relying on the gradle plugin extension. Would like your thoughts on the matter","Given the above, and that support for Transformers have been merged in OkBuck I'm re-opening this as a feature request for adding support for OkBuck. We would have to look more closely at how specifically the  config file looks like, but just browsing our RealmTransformer we only use two things from the Gradle project:\r\n\r\n1) We have a custom `realm` closure with a setting `syncEnabled`. I don't know how OkBuck handles custom configuration closures, but we would have to migrate that anyway.\r\n\r\n2) We access `project.android.bootClasspath` to acquire a reference to the `android.jar`. This would have to be provided by Buck somehow I think.\r\n\r\n@zaki50 Do you have any input to this?\r\n\r\n\r\n","okbuck takes care of passing in the android bootclasspath as a java system property.\r\n\r\nThe syncEnabled setting can be in the config file.\r\n\r\nOkbuck transform CLI can create a transform in two ways.\r\n\r\n- A class name with an empty constructor\r\n- A class name with a `java.io.File` argument constructor\r\n\r\nThe file can contain anything in it. In Realm's case it can be a simple config file like\r\n\r\n`realm.config`\r\n```\r\nrealm.syncEnabled=true\r\n```\r\n\r\nThe transform can then read the file and parse it in whichever format it wants it in.","I also noticed that the extension is the only reason the transform relies on the gradle api. If it were possible to specify the configuration through a simple file, that dependency can be completely removed and the transform can be a 100% pure java project then. The configuration file can be created on the fly by the plugin and passed to the `registerTransform()` call without breaking existing users.","@cmelchior I feel supporting `OkBuck` is not so difficult, I'm not familiar with it.\r\n\r\nI'll spend a bit of my time more to investigate `OkBuck`.","I wrote another transformer (`RealmTransformerOkBuck `) whose constructor accepted a `File` parameter.\r\n\r\nI didn't test it at all, but is it what you mean?\r\n\r\n```\r\n\/\/ diff was removed\r\n```","I would assume we could re-use the same transformer class and just keep the differences in the constructors? In our case it is just two variables, so should be doable? ","@cmelchior Ah, yes.","I've updated the diff\r\n```\r\ndiff --git a\/gradle-plugin\/src\/main\/groovy\/io\/realm\/gradle\/Realm.groovy b\/gradle-plugin\/src\/main\/groovy\/io\/realm\/gradle\/Realm.groovy\r\nindex 43bf3f89c..bf932bf30 100644\r\n--- a\/gradle-plugin\/src\/main\/groovy\/io\/realm\/gradle\/Realm.groovy\r\n+++ b\/gradle-plugin\/src\/main\/groovy\/io\/realm\/gradle\/Realm.groovy\r\n@@ -54,7 +54,13 @@ class Realm implements Plugin<Project> {\r\n             usesAptPlugin = true\r\n         }\r\n \r\n-        project.android.registerTransform(new RealmTransformer(project))\r\n+        def syncEnabled = project?.realm?.syncEnabled != null && project.realm.syncEnabled\r\n+        def bootClassPathList = new ArrayList<String>()\r\n+        project.android.bootClasspath.each {\r\n+            bootClassPathList.add(it.absolutePath)\r\n+        }\r\n+\r\n+        project.android.registerTransform(new RealmTransformer(syncEnabled, bootClassPathList))\r\n \r\n         project.repositories.add(project.getRepositories().jcenter())\r\n         project.dependencies.add(\"compile\", \"io.realm:realm-annotations:${Version.VERSION}\")\r\ndiff --git a\/realm-transformer\/src\/main\/groovy\/io\/realm\/transformer\/RealmTransformer.groovy b\/realm-transformer\/src\/main\/groovy\/io\/realm\/transformer\/RealmTransformer.groovy\r\nindex e6e481355..cf03de5d6 100644\r\n--- a\/realm-transformer\/src\/main\/groovy\/io\/realm\/transformer\/RealmTransformer.groovy\r\n+++ b\/realm-transformer\/src\/main\/groovy\/io\/realm\/transformer\/RealmTransformer.groovy\r\n@@ -26,8 +26,6 @@ import io.realm.annotations.Ignore\r\n import io.realm.annotations.RealmClass\r\n import javassist.ClassPool\r\n import javassist.CtClass\r\n-import javassist.LoaderClassPath\r\n-import org.gradle.api.Project\r\n import org.slf4j.Logger\r\n import org.slf4j.LoggerFactory\r\n \r\n@@ -44,12 +42,36 @@ import static com.android.build.api.transform.QualifiedContent.*\r\n class RealmTransformer extends Transform {\r\n \r\n     private Logger logger = LoggerFactory.getLogger('realm-logger')\r\n-    private Project project\r\n+    private boolean syncEnabled;\r\n+    private List<String> bootClassPathList;\r\n \r\n-    public RealmTransformer(Project project) {\r\n-        this.project = project\r\n+    public RealmTransformer(boolean syncEnabled, List<String> bootClassPathList) {\r\n+        this.syncEnabled = syncEnabled\r\n+        this.bootClassPathList = bootClassPathList\r\n     }\r\n \r\n+    \/\/ constructor for OkBuck\r\n+    public RealmTransformer(File configFile) {\r\n+        if (!propertiesFile.exists()) {\r\n+            throw new FileNotFoundException(configFile.absolutePath)\r\n+        }\r\n+        Properties properties = new Properties()\r\n+        configFile.withInputStream {\r\n+            properties.load(it)\r\n+        }\r\n+        syncEnabled = Boolean.valueOf(properties.getProperty(\"realm.syncEnabled\", \"false\"))\r\n+        def bootClassPath = properties.getProperty(\"realm.bootClassPath\")\r\n+        if (bootClassPath == null || bootClassPath.empty) {\r\n+            throw new Exception(\"realm.bootClassPath is not set in the configuration file.\")\r\n+        }\r\n+\r\n+        bootClassPathList = new ArrayList<>()\r\n+        bootClassPath.split(',').each {\r\n+            bootClassPathList.add(it.trim())\r\n+        }\r\n+    }\r\n+\r\n+\r\n     @Override\r\n     String getName() {\r\n         return \"RealmTransformer\"\r\n@@ -177,8 +199,7 @@ class RealmTransformer extends Transform {\r\n         def env = System.getenv()\r\n         def disableAnalytics = env[\"REALM_DISABLE_ANALYTICS\"]\r\n         if (disableAnalytics == null || disableAnalytics != \"true\") {\r\n-            boolean sync = project?.realm?.syncEnabled != null && project.realm.syncEnabled\r\n-            def analytics = new RealmAnalytics(packages as Set, containsKotlin, sync)\r\n+            def analytics = new RealmAnalytics(packages as Set, containsKotlin, this.syncEnabled)\r\n             analytics.execute()\r\n         }\r\n     }\r\n@@ -291,8 +312,8 @@ class RealmTransformer extends Transform {\r\n     \/\/ See https:\/\/code.google.com\/p\/android\/issues\/detail?id=209426\r\n     private void addBootClassesToClassPool(ClassPool classPool) {\r\n         try {\r\n-            project.android.bootClasspath.each {\r\n-                String path = it.absolutePath\r\n+            this.bootClassPathList.each {\r\n+                String path = it\r\n                 logger.debug \"Add boot class \" + path + \" to class pool.\"\r\n                 classPool.appendClassPath(path)\r\n             }\r\ndiff --git a\/realm\/realm-library\/build.gradle b\/realm\/realm-library\/build.gradle\r\nindex ac7f1affb..94f4be798 100644\r\n--- a\/realm\/realm-library\/build.gradle\r\n+++ b\/realm\/realm-library\/build.gradle\r\n@@ -117,7 +117,12 @@ coveralls.jacocoReportPath = \"${buildDir}\/reports\/coverage\/debug\/report.xml\"\r\n \r\n import io.realm.transformer.RealmTransformer\r\n \r\n-android.registerTransform(new RealmTransformer())\r\n+def syncEnabled = false\r\n+def bootClassPathList = new ArrayList<String>()\r\n+project.android.bootClasspath.each {\r\n+    bootClassPathList.add(it.absolutePath)\r\n+}\r\n+android.registerTransform(new RealmTransformer(syncEnabled, bootClassPathList))\r\n \r\n repositories {\r\n     maven { url \"https:\/\/jitpack.io\" }\r\n```","@kageiit How can I test transformer-enabled OkBuck?\r\nAnd currently I wrote a code to get boot class path from the configuration file.\r\nWhich system property should we use for bootclasspath?","@zaki50 the android bootclasspath is already passed in the transform invocation as a referenced input jar.\r\n\r\nTo test it just add to your root build.gradle:\r\n\r\n```\r\nokBuck {\r\n...\r\n    experimental {\r\n        transform = true\r\n    }\r\n\r\n    transform {\r\n        transforms = [\r\n                'APP-FLAVOUR'     : [\r\n                        [transform : \"FULL_QUALIFIED_CLASS_NAME\",\r\n                         configFile: \"CONFIG_FILE_PATH\"]\r\n                ],\r\n        ]\r\n    }\r\n}\r\n\r\ndependencies {\r\n    transform REALM_DEPENDENCY\r\n}\r\n```","I also just cut and released `v0.17.0` of okbuck that has support for the transforms baked in. You can use the configuration snippet @malbano posted above to test it out.\r\n\r\nMore details in the release notes: https:\/\/github.com\/uber\/okbuck\/releases\/tag\/v0.17.0","@kageiit @malbano Thanks. I'll test my code and make a PR for this.","I've got some errors.\r\n\r\n```\r\n+ java -Dokbuck.inJarsDir=\/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/bin\/app\/java_classes_preprocess_in_bin_debug -Dokbuck.outJarsDir=\/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/bin\/app\/java_classes_preprocess_out_bin_debug -Dokbuck.androidBootClasspath=\/usr\/local\/Cellar\/android-sdk\/24.4.1_1\/platforms\/android-24\/android.jar:\/usr\/local\/Cellar\/android-sdk\/24.4.1_1\/platforms\/android-24\/optional\/org.apache.http.legacy.jar -Dokbuck.configFile=\/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/gen\/.okbuck\/cache\/transform\/realm.config -Dokbuck.transformClass=io.realm.transformer.RealmTransformer -cp \/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/gen\/.okbuck\/cache\/transform\/okbuck_transform.jar com.uber.okbuck.transform.CliTransform\r\nPicked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8 -Dgroovy.source.encoding=UTF-8\r\njava.io.IOException: Stream closed\r\n\tat java.io.BufferedInputStream.getInIfOpen(BufferedInputStream.java:159)\r\n\tat java.io.BufferedInputStream.fill(BufferedInputStream.java:246)\r\n\tat java.io.BufferedInputStream.read(BufferedInputStream.java:265)\r\n\tat java.io.DataInputStream.readUnsignedShort(DataInputStream.java:337)\r\n\tat java.io.DataInputStream.readUTF(DataInputStream.java:589)\r\n\tat java.io.DataInputStream.readUTF(DataInputStream.java:564)\r\n\tat org.codehaus.groovy.reflection.GeneratedMetaMethod$DgmMethodRecord.loadDgmInfo(GeneratedMetaMethod.java:177)\r\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerMethods(MetaClassRegistryImpl.java:186)\r\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:96)\r\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:74)\r\n\tat groovy.lang.GroovySystem.<clinit>(GroovySystem.java:36)\r\n\tat org.codehaus.groovy.runtime.InvokerHelper.<clinit>(InvokerHelper.java:65)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:75)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat io.realm.transformer.RealmTransformer.<init>(RealmTransformer.groovy:44)\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:74)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:96)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:51)\r\nException in thread \"main\" java.lang.RuntimeException: groovy.lang.MissingMethodException: No signature of method: java.util.LinkedList.each() is applicable for argument types: (io.realm.transformer.RealmTransformer$_getClassNames_closure16) values: [io.realm.transformer.RealmTransformer$_getClassNames_closure16@2a17b7b6]\r\nPossible solutions: wait(), wait(long), add(java.lang.Object), add(java.lang.Object), add(java.lang.Object), push(java.lang.Object)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:98)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:51)\r\nCaused by: groovy.lang.MissingMethodException: No signature of method: java.util.LinkedList.each() is applicable for argument types: (io.realm.transformer.RealmTransformer$_getClassNames_closure16) values: [io.realm.transformer.RealmTransformer$_getClassNames_closure16@2a17b7b6]\r\nPossible solutions: wait(), wait(long), add(java.lang.Object), add(java.lang.Object), add(java.lang.Object), push(java.lang.Object)\r\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:58)\r\n\tat org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:49)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat io.realm.transformer.RealmTransformer.getClassNames(RealmTransformer.groovy:247)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)\r\n\tat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerce.invoke(StaticMetaMethodSite.java:151)\r\n\tat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.callStatic(StaticMetaMethodSite.java:102)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:56)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:194)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:206)\r\n\tat io.realm.transformer.RealmTransformer.transform(RealmTransformer.groovy:110)\r\n\tat com.android.build.api.transform.Transform.transform(Transform.java:308)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:104)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:80)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:96)\r\n\t... 1 more\r\n\r\nBUILD FAILED: \/\/app:bin_debug failed with exit code 1:\r\ngenrule\r\nstderr: + java -Dokbuck.inJarsDir=\/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/bin\/app\/java_classes_preprocess_in_bin_debug -Dokbuck.outJarsDir=\/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/bin\/app\/java_classes_preprocess_out_bin_debug -Dokbuck.androidBootClasspath=\/usr\/local\/Cellar\/android-sdk\/24.4.1_1\/platforms\/android-24\/android.jar:\/usr\/local\/Cellar\/android-sdk\/24.4.1_1\/platforms\/android-24\/optional\/org.apache.http.legacy.jar -Dokbuck.configFile=\/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/gen\/.okbuck\/cache\/transform\/realm.config -Dokbuck.transformClass=io.realm.transformer.RealmTransformer -cp \/Users\/zaki\/fromgit\/realm\/realm_template\/buck-out\/gen\/.okbuck\/cache\/transform\/okbuck_transform.jar com.uber.okbuck.transform.CliTransform\r\nPicked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8 -Dgroovy.source.encoding=UTF-8\r\njava.io.IOException: Stream closed\r\n\tat java.io.BufferedInputStream.getInIfOpen(BufferedInputStream.java:159)\r\n\tat java.io.BufferedInputStream.fill(BufferedInputStream.java:246)\r\n\tat java.io.BufferedInputStream.read(BufferedInputStream.java:265)\r\n\tat java.io.DataInputStream.readUnsignedShort(DataInputStream.java:337)\r\n\tat java.io.DataInputStream.readUTF(DataInputStream.java:589)\r\n\tat java.io.DataInputStream.readUTF(DataInputStream.java:564)\r\n\tat org.codehaus.groovy.reflection.GeneratedMetaMethod$DgmMethodRecord.loadDgmInfo(GeneratedMetaMethod.java:177)\r\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerMethods(MetaClassRegistryImpl.java:186)\r\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:96)\r\n\tat org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:74)\r\n\tat groovy.lang.GroovySystem.<clinit>(GroovySystem.java:36)\r\n\tat org.codehaus.groovy.runtime.InvokerHelper.<clinit>(InvokerHelper.java:65)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:75)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat io.realm.transformer.RealmTransformer.<init>(RealmTransformer.groovy:44)\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:74)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:96)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:51)\r\nException in thread \"main\" java.lang.RuntimeException: groovy.lang.MissingMethodException: No signature of method: java.util.LinkedList.each() is applicable for argument types: (io.realm.transformer.RealmTransformer$_getClassNames_closure16) values: [io.realm.transformer.RealmTransformer$_getClassNames_closure16@2a17b7b6]\r\nPossible solutions: wait(), wait(long), add(java.lang.Object), add(java.lang.Object), add(java.lang.Object), push(java.lang.Object)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:98)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:51)\r\nCaused by: groovy.lang.MissingMethodException: No signature of method: java.util.LinkedList.each() is applicable for argument types: (io.realm.transformer.RealmTransformer$_getClassNames_closure16) values: [io.realm.transformer.RealmTransformer$_getClassNames_closure16@2a17b7b6]\r\nPossible solutions: wait(), wait(long), add(java.lang.Object), add(java.lang.Object), add(java.lang.Object), push(java.lang.Object)\r\n\tat org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:58)\r\n\tat org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:49)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\r\n\tat io.realm.transformer.RealmTransformer.getClassNames(RealmTransformer.groovy:247)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)\r\n\tat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerce.invoke(StaticMetaMethodSite.java:151)\r\n\tat org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.callStatic(StaticMetaMethodSite.java:102)\r\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:56)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:194)\r\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:206)\r\n\tat io.realm.transformer.RealmTransformer.transform(RealmTransformer.groovy:110)\r\n\tat com.android.build.api.transform.Transform.transform(Transform.java:308)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:104)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:80)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:96)\r\n\t... 1 more\r\n```\r\n\r\nOne is `java.io.IOException: Stream closed` at the line `private Logger logger = LoggerFactory.getLogger('realm-logger')` in RealmTransformer.groovy\r\n\r\nAnother is `groovy.lang.MissingMethodException: No signature of method: java.util.LinkedList.each()` at https:\/\/github.com\/realm\/realm-java\/blob\/v2.3.0\/realm-transformer\/src\/main\/groovy\/io\/realm\/transformer\/RealmTransformer.groovy#L227\r\nWe are expecting groovy's list, but actual instance from `CliTransform` seems an instance of ` java.util.LinkedList`.\r\n\r\n@kageiit What do you think? Can you fix it in OkBuck?","@zaki50 It's easier to review if you just push a Pull Request and mark it as \"In Progress\" \ud83d\ude04 ","@zaki50 I think the problem lies here: https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm-transformer\/build.gradle#L50\r\n\r\nthe `gradleApi()` and `localGroovy()` declarations basically do not get packaged into the pom of the transform becuase they are expected to be provided by the upstream project's gradle installation\r\n\r\nso when you do \r\n```\r\ndependencies {\r\n  transform 'realm-transform'\r\n}\r\n```\r\n\r\nOkbuck will pull in real-transform and its pom dependencies to make a fat jar that can be run via the transform-cli in buck. Since buck itself does not have a groovy installation, that needs to be packaged into the fat jar as well, so there are a couple of options\r\n\r\n- Add groovy and gradle as transform dependencies as well\r\n\r\n```\r\ndependencies {\r\n  transform 'real-transform'\r\n  transform localGroovy()\r\n  transform gradleApi()\r\n}\r\n```\r\n\r\n- Make the `realm-transformer` a pure java project and remove dependencies on groovy and gradle api completely. I think with #4133 the gradleAPi() dpenednecy is no longer required as you have a provider interface. You really only need the groovy dependency","Thanks @kageiit \r\nI tried the first option last week but no success (IIRC). I'll confirm that later.\r\nI'd like to avoid the second option. We are using groovy methods in many places...\r\n\r\n","I think `import groovy.io.FileType` is the only actual groovy-specific thing.\r\n\r\nI'm sure this could be rewritten to Java without *too much* trouble.\r\n\r\nHmm...","Do you think adding the incremental support could have also solved this one? ","There is only one groovy file left - https:\/\/github.com\/realm\/realm-java\/blob\/539054e7923f7efda693733344a5cf436d377b0e\/realm-transformer\/src\/main\/groovy\/io\/realm\/transformer\/GroovyUtil.groovy\r\n\r\nIf this is moved over, then there is no reliance on groovy types and it could enable okbuck support","Opened https:\/\/github.com\/realm\/realm-java\/pull\/6025 to address the move","I'm getting the same error with the following okbuck configuration:\r\n\r\n\r\n```\r\nokBuck {\r\n...\r\n    experimental {\r\n        transform = true\r\n    }\r\n    transform {\r\n        transforms = [\r\n                'debug'     : [\r\n                        [transform : \"io.realm.transformer.RealmTransformer\",\r\n                ],\r\n        ]\r\n    }\r\n}\r\ndependencies {\r\n    transform \"io.realm:realm-gradle-plugin:5.3.1\"\r\n}\r\n```\r\n\r\nIs there something I'm missing?","@jtrouvere you need to try with `5.4.0-SNAPSHOT`\r\n\r\nAnd you also need to run it for `release` if that's a thing","I still get the error even though i use `5.5.0-SNAPSHOT` ..\r\nHmmm, how can i setup realm transformer on my project ?\r\nIs there any instruction to do that ? I've tried @jtrouvere solution, but app still crashing ..\r\nThank you ","Theoretically, 5.4.0 is supposed to work with OkBuck.\r\n\r\nIf something is failing, you need to be specific about the actual crash and stuff.","@Zhuinden okay, i got this error ..\r\n```\r\njava.lang.ExceptionInInitializerError: RealmTransformer doesn't seem to be applied. Please update the project configuration to use the Realm Gradle plugin. See https:\/\/realm.io\/news\/android-installation-change\/\r\n        at io.realm.RealmConfiguration.<clinit>(RealmConfiguration.java:80)\r\n        at io.realm.RealmConfiguration$Builder.initializeBuilder(RealmConfiguration.java:501)\r\n        at io.realm.RealmConfiguration$Builder.<init>(RealmConfiguration.java:487)\r\n        at io.realm.Realm.init(Realm.java:273)\r\n        at id.xcromez.what2watch.What2Watch.onCreate(What2Watch.java:23)\r\n        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1012)\r\n        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4553)\r\n        at android.app.ActivityThread.access$1500(ActivityThread.java:151)\r\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1364)\r\n        at android.os.Handler.dispatchMessage(Handler.java:102)\r\n        at android.os.Looper.loop(Looper.java:135)\r\n        at android.app.ActivityThread.main(ActivityThread.java:5254)\r\n        at java.lang.reflect.Method.invoke(Native Method)\r\n        at java.lang.reflect.Method.invoke(Method.java:372)\r\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\r\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\r\n```\r\n\r\nAnd the crash come from this file `What2Watch.java:23` which is `Realm.init(this);` :\r\n```\r\n@Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        if (!BuildConfig.DEBUG) {\r\n            Fabric.with(this, new Crashlytics());\r\n        }\r\n        Realm.init(this);\r\n        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder().deleteRealmIfMigrationNeeded().build();\r\n        Realm.setDefaultConfiguration(realmConfiguration);\r\n    }\r\n```\r\n\r\nAnd i put this on my `build.gradle` :\r\n```\r\nokbuck {\r\n    buildToolVersion = \"27.0.3\"\r\n    target = \"android-26\"\r\n    buckBinary = \"com.github.facebook:buck:v2018.07.23.01@pex\"\r\n    lint {\r\n        disabled = true\r\n    }\r\n    experimental {\r\n        transform = true\r\n    }\r\n    transform {\r\n        transforms = [\r\n                'debug': [\r\n                        [transform: \"io.realm.transformer.RealmTransformer\",\r\n                        ],\r\n                ]\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\nIs there something that i missed ?\r\nThanks ..","@aldochristiaan any chance you have a small repro project that you can put on github? Will help diagnose the issue faster","@kageiit i don't have it at this moment, but i'll try to create one and come back here later ..","Have you tried with\r\n\r\n```\r\n    transform {\r\n        transforms = [\r\n                'appDebug' : [\r\n                        [transform : \"io.realm.transformer.RealmTransformer\"]\r\n                ],\r\n'appRelease' : [\r\n                        [transform : \"io.realm.transformer.RealmTransformer\"]\r\n                ]\r\n        ]\r\n    }\r\n\r\n    experimental {\r\n        transform = true\r\n    }\r\n}\r\n\r\ndependencies {\r\n    transform \"io.realm:realm-transformer:5.4.0\"\r\n}\r\n```","@Zhuinden i got this error :\r\n```\r\nInput jars dir: \/Users\/bukalapak\/Documents\/Aldo\/What2Watch\/buck-out\/bin\/app\/bin_debug#class_file_to_dex_processing\/non_predexed_root\/bin\/java_classes_preprocess_in\r\nOutput jars dir: \/Users\/bukalapak\/Documents\/Aldo\/What2Watch\/buck-out\/bin\/app\/bin_debug#class_file_to_dex_processing\/non_predexed_root\/bin\/java_classes_preprocess_out\r\n\r\nException in thread \"main\" java.lang.NoClassDefFoundError: org\/gradle\/api\/Project\r\n\tat java.lang.Class.getDeclaredConstructors0(Native Method)\r\n\tat java.lang.Class.privateGetDeclaredConstructors(Class.java:2671)\r\n\tat java.lang.Class.getConstructor0(Class.java:3075)\r\n\tat java.lang.Class.newInstance(Class.java:412)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:75)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:96)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:51)\r\nCaused by: java.lang.ClassNotFoundException: org.gradle.api.Project\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\t... 7 more\r\n\r\nBuild failed: Command failed with exit code 1.\r\nstderr: Exception in thread \"main\" java.lang.NoClassDefFoundError: org\/gradle\/api\/Project\r\n\tat java.lang.Class.getDeclaredConstructors0(Native Method)\r\n\tat java.lang.Class.privateGetDeclaredConstructors(Class.java:2671)\r\n\tat java.lang.Class.getConstructor0(Class.java:3075)\r\n\tat java.lang.Class.newInstance(Class.java:412)\r\n\tat com.uber.okbuck.transform.TransformRunner.runTransform(TransformRunner.java:75)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:96)\r\n\tat com.uber.okbuck.transform.CliTransform.main(CliTransform.java:51)\r\nCaused by: java.lang.ClassNotFoundException: org.gradle.api.Project\r\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\r\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)\r\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\r\n\t... 7 more\r\n\r\n    When running <genrule>.\r\n    When building rule \/\/app:bin_debug#class_file_to_dex_processing.\r\n```\r\n\r\nHere is my `build.gradle` file:\r\n```\r\n\/\/ Top-level build file where you can add configuration options common to all sub-projects\/modules.\r\n\r\nbuildscript {\r\n\r\n    repositories {\r\n        jcenter()\r\n        google()\r\n        mavenCentral()\r\n        maven {\r\n            url 'https:\/\/maven.fabric.io\/public'\r\n        }\r\n        maven { url \"https:\/\/oss.sonatype.org\/content\/repositories\/snapshots\" }\r\n    }\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:3.1.3'\r\n        classpath 'io.fabric.tools:gradle:1.+'\r\n        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.2.51'\r\n        classpath 'com.jakewharton:butterknife-gradle-plugin:9.0.0-SNAPSHOT'\r\n        classpath 'com.uber:okbuck:0.40.0'\r\n        classpath 'io.realm:realm-gradle-plugin:5.4.0'\r\n\r\n        \/\/ NOTE: Do not place your application dependencies here; they belong\r\n        \/\/ in the individual module build.gradle files\r\n    }\r\n}\r\n\r\nallprojects {\r\n    repositories {\r\n        jcenter()\r\n        google()\r\n        maven {\r\n            url 'https:\/\/maven.fabric.io\/public'\r\n        }\r\n        maven { url \"https:\/\/oss.sonatype.org\/content\/repositories\/snapshots\" }\r\n    }\r\n}\r\n\r\napply plugin: 'com.uber.okbuck'\r\n\r\nokbuck {\r\n    buildToolVersion = \"27.0.3\"\r\n    target = \"android-26\"\r\n\/\/    buckBinary = \"com.github.facebook:buck:v2018.07.23.01@pex\"\r\n    lint {\r\n        disabled = true\r\n    }\r\n    transform {\r\n        transforms = [\r\n                'appDebug' : [\r\n                        [transform : \"io.realm.transformer.RealmTransformer\"]\r\n                ],\r\n                'appRelease' : [\r\n                        [transform : \"io.realm.transformer.RealmTransformer\"]\r\n                ]\r\n        ]\r\n    }\r\n    experimental {\r\n        transform = true\r\n    }\r\n}\r\n\r\ndependencies {\r\n    transform 'io.realm:realm-transformer:5.4.0'\r\n}\r\n\r\ntask clean(type: Delete) {\r\n    delete rootProject.buildDir\r\n}\r\n\r\next {\r\n    \/\/ Sdk and tools\r\n    minSdkVersion = 19\r\n    targetSdkVersion = 26\r\n    compileSdkVersion = 26\r\n    buildToolsVersion = '27.0.3'\r\n\r\n    \/\/ App dependencies\r\n    supportLibraryVersion = '27.1.1'\r\n    constraintLayoutVersion = '1.1.2'\r\n    guavaVersion = '18.0'\r\n    junitVersion = '4.12'\r\n    mockitoVersion = '1.10.19'\r\n    powerMockito = '1.6.2'\r\n    hamcrestVersion = '1.3'\r\n    runnerVersion = '1.0.0'\r\n    rulesVersion = '1.0.0'\r\n    espressoVersion = '3.0.1'\r\n    rxjavaVersion = '2.1.3'\r\n    rxandroidVersion = '2.0.1'\r\n    multiDexVersion = '1.0.2'\r\n}\r\n```","@aldochristiaan  In a way, that is much more interesting, because now it tries to apply the transform, but I don't know why it fails.\r\n\r\nWhat is your Gradle version?","@Zhuinden i tried gradle version 4.6 , 4.7, 4.9 but it didn't work :(\r\nThe build succeed tho \ud83d\ude05"],"labels":["T-Feature","O-Community"]},{"title":"Log the native backtrace when exception throws","body":"It is always a pain for us that after converting c++ exception to\njava's, all the native backtrace just lost.\nThis tries to hook into the __cxa_throw to log the native backtrace PCs\nwhen exception throws.\nThe pc address can be then decoded through addr2line like:\naddr2line -C -f -e librealm-jni.so 0xa0293 0xa0548 0xb8cd1 0x3acb3 0x15611\n\nA more wicked idea would be totally implement a __cxa_throw function and\nconvert exceptions from there and unwind the callstack to where JNI borders\nthen return to java peacefully. It seems to be doable and we can get rid of\nthe `try CATCHSTD` blocks for every JNI call. Need more investigations.","comments":["It might be worth comparing with https:\/\/github.com\/realm\/realm-core\/blob\/master\/src\/realm\/util\/terminate.cpp","We must also investigate how it works together with Crashlytics: https:\/\/docs.fabric.io\/android\/crashlytics\/ndk.html","Despite my concerns and comments, I like the idea!","Might be useful: http:\/\/stackoverflow.com\/questions\/8115192\/android-ndk-getting-the-backtrace","According to http:\/\/stackoverflow.com\/a\/35585744\/1396606 , it seems it is safe for us to use `<unwind.h>` -- we are using gnustl static linked. Also, we are using `visibility=hidden` for build, but we don't need to parse symbols inside the `so`. Just get the backtrace addresses are good enough for us.","Some ideas in #813","I think I have heard rumours that the NDK team is working on a new `libunwind`."],"labels":["T-Internal"]},{"title":"Cannot backup using BackupManager","body":"When developers use this library, it create some directories and files in app data area(eg. \/data\/data\/[package name]\/files).\nand it seems create pipe file also.\n\nBackupManager which is provided by Google Android to backup the app date copies all the files in app data area and zips.\nAs you know, copy is read and write.\nAs my guess, it makes problem.\nBackupManager tries to read pipe file when backups the app data, but there's nothing to read for pipe file, so it stucks.\nStucks forever.\n\nYes, it seems google's bug, but every packages which uses this library and wants to allow backup by Google playstore will be problem.\n\nSo the pipe file should be in app data area(files)?\nCan't be it in cache area?\n\n\n> We LOVE to help with any issues or bug you have!\n\n> **Questions**: If you have questions about how to use Realm, please ask on [SO](http:\/\/stackoverflow.com\/questions\/ask?tags=realm) - we monitor the Realm tag.\n\n> **Feature Request**: Just fill in the first two sections below.\n\n> **Bugs**: To help you as fast as possible with an issue or bug please describe your issue and the steps you have taken to reproduce it in as many details as possible.\n>\n> Thanks for helping us help you :-)\n>\n> Remove this and above before submitting.\n\n#### Goal\n\n> What do you want to achieve?\n\n#### Expected Results\n\n> ?\n\n#### Actual Results\n\n>  E.g. full stack trace with exception\n\n#### Steps & Code to Reproduce\n\n> Describe your current debugging efforts.\n\n#### Code Sample\n\n```java\n\n> Your code here. Bigger samples should ideally be as separate Android Studio project, \n> in gists\/repositories or privately at help@realm.io)\n\n```\n\n#### Version of Realm and tooling\nRealm version(s): ?\n\nRealm sync feature enabled: yes\/no\n\nAndroid Studio version: ?\n\nWhich Android version and device: ?","comments":["Thanks a lot for the detailed description, I think you made a valid point. We will have a discussion about what we should do with it.\r\n@finnschiermer Any comments? Shall we move the pipe files to the android cache directory?","I think you can exclude the pipe from being backed up, no? ","No, i can't. Maybe google can but google do not... :(","We can set [android:backupAgent](https:\/\/developer.android.com\/reference\/android\/app\/backup\/BackupManager.html#attr_android:backupAgent). Is there possibility to exclude some files here? If it is possible, we can make a sub-class of [BackupAgent](https:\/\/developer.android.com\/reference\/android\/app\/backup\/BackupAgent.html).","Is this still an issue?"],"labels":["T-Enhancement","O-Community"]},{"title":"Realm is still not mockable with Mockito after 2.2.2 change","body":"So, as discussed here: https:\/\/github.com\/realm\/realm-java\/issues\/3869 and implemented since 2.2.2 (https:\/\/github.com\/realm\/realm-java\/pull\/3911\/files), the removal of the final modifier would allow mocking Realm without the use of PowerMock. Needless to say, after spending so much time trying to make Realm + PowerMock + Roboelectric work (and failing to do so), I was ecstatic to hear about aforementioned changes. But...\n\nIt was still impossible to mock Realm.class:\n`Mockito.mock(Realm.class)` would end up\n```\norg.mockito.exceptions.base.MockitoException: \nMockito cannot mock this class: class io.realm.Realm.\n\nMockito can only mock non-private & non-final classes.\nIf you're not sure why you're getting this error, please report to the mailing list.\n\n\nJava               : 1.8\nJVM vendor name    : Oracle Corporation\nJVM vendor version : 25.112-b15\nJVM name           : Java HotSpot(TM) 64-Bit Server VM\nJVM version        : 1.8.0_112-b15\nJVM info           : mixed mode\nOS name            : Windows 7\nOS version         : 6.1\n```\n\nMy guess is it's because Realm.class still has a private constructor.\n\nAm I doing something wrong and there is a more elaborate way to set things up? Is there still a way to mock stuff without PowerMock? If not, what is the point of https:\/\/github.com\/realm\/realm-java\/pull\/3911\/files change?\n\nThings I used in my code: \n- `io.realm:realm-gradle-plugin:2.3.0-SNAPSHOT`\n- `org.mockito:mockito-core:2.4.0`\n- `com.google.dagger:dagger:2.8`\n- `org.robolectric:robolectric:3.1.4`\n\nOh, and all the production and test code is written in Kotlin.","comments":["Have you made sure you are using the latest SNAPSHOT by using `.\/gradlew clean assemble --refresh-dependencies` ?","@cmelchior Yes. In fact, I completely cleaned everything, including the Gradle cache during one of the attempts. Nonetheless, just to be sure, I did `.\/gradlew clean assemble --refresh-dependencies` just now. Still the same result.","@cmelchior OK, I see the problem. It doesn't work with Mockito 2.x and works with 1.x. The similar issue can be seen here: https:\/\/github.com\/mockito\/mockito\/issues\/701\r\n\r\nThis is such a great pity to have to use much older and inferior version of Mockito... Can anything possibly be done to make it work with 2.x?","A small update. I did make it work with the old Mockito 1.10.19 version, but even then trying to stub mocked Realm's #close() still calls the real method right when I try to stub it:\r\n\r\n```\r\nval realmMock = Mockito.mock(Realm::class.java)\r\nMockito\r\n  .doNothing()\r\n  .`when`(realmMock)\r\n  .close()\r\n```\r\n\r\nThe above crashes on the spot as it tries to call the real method and throws `throw new IllegalStateException(INCORRECT_THREAD_CLOSE_MESSAGE)` as the Realm was never really opened.\r\n\r\nThis behaviour is usually experience if the method is not public, but this doesn't seem to be the case: `public void close()`...","@NeverwinterMoon Great to hear that you got it to work with an older version.\r\n\r\nI am by no means a Mockito expert but can't you use partial mocking so `close()` isn't really called?","@kneth Sorry for the delay with my response, but that is exactly what I was trying to do.\r\n\r\nFrom office Mockito docs on partial mocking (https:\/\/static.javadoc.io\/org.mockito\/mockito-core\/2.4.2\/org\/mockito\/Mockito.html#16):\r\n```\r\n\/\/you can enable partial mock capabilities selectively on mocks:\r\nFoo mock = mock(Foo.class);\r\n\/\/Be sure the real implementation is 'safe'.\r\n\/\/If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\r\nwhen(mock.someMethod()).thenCallRealMethod();\r\n```\r\n\r\nThat is pretty much what I was doing - I wanted to `doNothing` if realm.close() was called.\r\n\r\nUsually, if the class is public but the method that is being mocked is not public, Mockito would not throw any exceptions but will call that method immediately when trying to mock it. I am having a similar behaviour, although I see that Realm#close is public...","It could be interesting to get some insights from the Mockito community on this.","Guys, do we have any updates on this?\r\n\r\n@NeverwinterMoon were you able to fix it? What did you accept as a solution to this? I am looking to fix a similar situation albeit a more complex one (rxjava slides in) and I am refraining from using `powermock` for now.","@The0ldM0nk \r\n\r\nI did try to go with PowerMock but soon gave up - the whole idea of PowerMock is not very appealing to me. The Mockito way wasn't working for me completely, too, when trying to run tests with Robolectric.\r\n\r\nSo, I ended up going with the Instrumented tests for pretty much everything. There, I used Mockito to mock only my own modules (all were injected with the Dagger in production code, so it was easy to mock them in tests) but used the actual Realm database.\r\n\r\nAVD emulator got very fast lately, so running the instrumented tests on the emulators locally (or even Firebase test lab) is pretty fast. Also, it allows to run those tests on even the latest APIs. Robolectric was still limited to API level 21, the last time I checked. There are plenty of changes in the newer APIs...","PowerMock should work with Robolectric 3.3.1+.\r\n\r\nIf you want to avoid powerMock, then you need to use an interface and hide the static method calls to Realm under an interface."],"labels":["T-Enhancement","O-Community"]},{"title":"Add a callback in RealmConfiguration.deleteRealmIfMigrationNeeded","body":"#### Goal\n\nThe idea is to get notified when the realm get deleted because a migration was needed. We would like to track it in our dashboards.\n\nSo it could be an extra parameter in the `RealmConfiguration` builder method, ex :\n\n`public Builder deleteRealmIfMigrationNeeded(RealmConfiguration.Callback callback) { ... }`\n\nThanks","comments":["@eboudrant Thanks for the suggestion. I can understand that in some cases you might need to track what kind of migration is triggered (including deleting a Realm). I add your idea to our backlog.","This is probably also relevant as input to #4083 ","I think will be a great Feature. Thanks for all!","@jposes22 you could use `initialData()` although that is also called on first init, not just recreation ","Is this still in the backlog?  I'm finding myself in need of this."],"labels":["T-Feature","Design-Required","O-Community","Pipeline-Idea-Backlog"]},{"title":"Mocking unmanaged RealmObject observable","body":"#### Goal\nI want to make mock object of asObservable() about findFirstAsync.\nI found a comment in RealmObject.\n```\n\/\/ TODO Is this true? Should we just return Observable.just(object) ?\n throw new IllegalArgumentException(\"Cannot create Observables from unmanaged RealmObjects\");\n```\nIs there any other way to make mock observable?\n\n#### Expected Results\nCreate mock observable object.\n\n#### Actual Results\n```\njava.lang.IllegalArgumentException: Cannot create Observables from unmanaged RealmObjects\n```\n\n#### Code Sample\n\n```kotlin\nPowerMockito.`when`(realmQuery.findFirstAsync()).thenReturn(realmObject)\nPowerMockito.`when`(realmObject.asObservable<Object()).thenReturn(Observable.just(realmObject))\n```\n\n#### Version of Realm and tooling\nRealm version(s): 2.2\n\nRealm sync feature enabled: no\n\nAndroid Studio version: 2.2\n\nWhich Android version and device: nexus 5x","comments":["@leesunghyun No current plan but we accept pull request :-)\r\n\r\nI move it to our backlog and mark it as an enhancement."],"labels":["T-Enhancement","O-Community"]},{"title":"Avoid modifying managed RealmList when user executes a query.","body":"WIP\n\nIn model's constructor, calling mutator methods of managed `RealmList` must be ignored if `getAcceptDefaultValue$realm()` is `false` or the name of the field is in the ignore list.\n\nHowever, `RealmList` has many methods which is meant to modify itself and that is very hard to provide a natural non-op behavior. Of course it breaks expected `List` behavior, too.\n\nFor example:\n```java\nprivate RealmList<Dog> dogs;\n\n\/\/ default constructor of DogOwner model\npublic DogOwner() {\n    dogs = new RealmList<Dog>();\n    dogs.add(new Dog());\n\n    Dog dog = dogs.get(0); \/\/ this line throws an exception or returns unexpected object when a code above is non-op.\n}\n\n```\n\nFor that reason, I'm leaning toward adding a method `public static boolean RealmObject#acceptsDefaultValue(RealmModel)` which returns `false` when the assigned values are ignored in the constructor.\nAnd when that method returns `false`, all mutator methods in `RealmList` throws an exception (this is not an breaking chance since we are already throwing `IllegalStateException` now).\n\nAfter introducing `acceptsDefaultValue(RealmModel)`, users can skip any assignment of default values like:\n\n```java\nprivate RealmList<Dog> dogs;\n\n\/\/ default constructor of DogOwner model\npublic DogOwner() {\n    if (!acceptsDefaultValue(this)) {\n        return;\n    }\n    dogs = new RealmList<Dog>();\n    dogs.add(new Dog());\n\n    Dog dog = dogs.get(0);\n}\n```\n\nAs Christian commented on https:\/\/github.com\/realm\/realm-java\/pull\/3812#issuecomment-263500408, I think  we can automatically add the check by our transformer in most cases. We need to check that adding the code to the following constructor is valid.\n\n```\npublic class Foo extends RealmObject {\n    final int BAR;\n    public Foo() {\n        BAR = 1;\n    }\n\n    public void printBar() {\n        Log.d(\"baz\", \"BAR is \" + BAR ); \/\/ This must print \"BAR is 1\"\n    }\n}\n```\n\nfixes #3809","comments":["Remind me why do we need to transform all the getter\/setters in the constructor? Can we just skip the transforming for the constructor (at least the default one)?\r\n\r\nAsk user to have check of `acceptsDefaultValue` in the model constructor doesn't look good :(","@beeender mainly for `Realm.createObject(Class)` to respect the default values.","You have provided a workaround to #3809, but I believe that Realm Java should be as easy to use as possible. From that point of view, I think this proposal makes sense.","I would really like to avoid anything like the above. It doesn't really solve the problem of being intuitive to use since you would need to read the documentation for both this and doing the work-around in #3809. If given a choice between the two I would probably prefer to just document the current bug and how to work around it instead of introducing new methods of questionable value?\r\n\r\nHowever, could it be possible to inject that code using our transformer? That way people wouldn't need to do anything?","@cmelchior That's a great idea.\r\nI think it's possible.","Adding `if (!acceptsDefaultValue(this)) { return; }` is possible but the following code does not work as expected.\r\n\r\n```\r\npublic class Foo extends RealmObject {\r\n    @Ignore\r\n    final int BAR;\r\n    public Foo() {\r\n        BAR = 1;\r\n    }\r\n\r\n    public void printBar() {\r\n        Log.d(\"baz\", \"BAR is \" + BAR ); \/\/ This must print \"BAR is 1\"\r\n    }\r\n}\r\n```\r\n\r\n`printBar()` prints `0` instead of `1`.\r\n\r\nMy current conclusion is that we should not inject `if (!acceptsDefaultValue(this)) { return; }`  by our transformer.\r\n"],"labels":["T-Bug"]},{"title":"RFC for Import\/Export API","body":"Spinoff from #1470 \r\n\r\nThis RFC tries to describe two possible approaches to the problem, but perhaps I am missing something even better. \r\n\r\nWhat do you think @realm\/java @TR4Android","comments":["@cmelchior Thanks for the detailed proposal, I would almost say that option B is better as it's more concise if the import is done directly one the Realm database object. A few suggestions though:\n- Just name the methods `importData` or similar. I think the keyword `import` conveys what those methods are meant to do: import data from another format into the database. (I would advise against the method name `import` itself as it's a reserved keyword in most languages.)\n- Don't try to auto-detect the type in the import API. Most, if not all, developers know the type they're importing, adding detection just increases the likelihood that a developer uses the less efficient version of the API and introduces a lot of code that needs to be maintained.\n- Make the imported type an enum, that way it's pretty clear what types are supported for importing and there's no need to check for invalid types as would be the case for `String`.\n\nAlso, still an open question for me is how to guarantee the order of execution of the annotation processors involved. We need to somehow make sure that the proxy classes get generated first, so the import\/export processor can add its code to it.\n","> Just name the methods importData or similar. I think the keyword import conveys what those methods are meant to do: import data from another format into the database. (I would advise against the method name import itself as it's a reserved keyword in most languages.)\n\n`importData` is an option as well. My primary concern was the distinction between update or not. Right now most of our apis are called e.g `insertOrUpdate\/createOrUpdate`, `importOrUpdate` just sounds wrong? \n\n> Make the imported type an enum, that way it's pretty clear what types are supported for importing and there's no need to check for invalid types as would be the case for String.\n\nI also like a enum a lot more, but it makes the API less flexible since you are then constrained to the types we define. I'm not sure it is a problem in practise though as `XML\/JSON\/CSV` would probably support 99% of export formats.\n","> XML\/JSON\/CSV would probably support 99% of export formats.\r\n\r\nI could define flatbuffer or something ridiculous like [flatbuffers](https:\/\/github.com\/square\/wire)\r\n\r\n---\r\n\r\n~~as for JSON support, we should also take into consideration the fact that [you still can't directly map between `RealmList<RealmInteger>`](https:\/\/github.com\/realm\/realm-java\/issues\/575), so you'd need custom serialization logic for array of integers to either convert to that, or  join them into a single String field like `|5|7|10|` if you so desire.~~\r\n\r\n---\r\n\r\n---\r\n\r\nI have this wild guess that the right direction would be something like the Retrofit2 [Converter.Factory](https:\/\/github.com\/square\/retrofit\/blob\/master\/retrofit-converters\/gson\/src\/main\/java\/retrofit2\/converter\/gson\/GsonConverterFactory.java) approach.\r\n","> I have this wild guess that the right direction would be something like the Retrofit2 Converter.Factory approach.\n\nRetrofit has the luxury of making the users define the interface, so they can annotate their API with `@json \/ @xml` if I remember correctly. I really like the factory approach as well, but there will be cases where it is impossible to tell the difference, e.g If I'm importing a String is that a json or xml string.\n","@cmelchior \n\n> there will be cases where it is impossible to tell the difference, e.g If I'm importing a String is that a json or xml string.\n\nuh... isn't that why [the converter factory gets a list of annotations](https:\/\/github.com\/aurae\/retrofit-logansquare\/blob\/master\/converter-logansquare\/src\/main\/java\/com\/github\/aurae\/retrofit2\/LoganSquareConverterFactory.java#L42) which can be used to determine if it's for `@Root` annotation (SimpleXML) or `@JsonObject` annotation (LoganSquare) for example?\n","Yes, and that is a great idea, but users doesn't control the Realm API, so they cannot annotate the import method.\n","They can annotate RealmObjects though. Maybe that changes things? The key here is \"automating\"  batch insertion, or so I would think. Although I do wonder how relationships would be handled, or custom serialization like for RealmList of RealmInts. \n\nThis is a difficult issue, I'll try to think about it; although my wild guess is that you'll come up with something even better than any idea I'd have. :D \/sleeptime\n","I like @zhuinden idea of a retrofit-esque solution. Define an interface in realm for importing data, create a library with implementations using popular 3rd party libraries (gson, Moshi, something for XML, etc...), and let the user pass an instance of that implementation to the import method."],"labels":["T-Feature","Design-Required","Pipeline-On-Hold"]},{"title":"Replace Context with ContextWrapper","body":"Fixes  #3530 \n\nThis PR replaces our stored `Context` with a `ContextWrapper`. This means we use the parsed Context when calling `init` to retrieve the needed information and then store that.\n\nIt has the following benefits:\n- Should make Realm works better with Instant Run (Cannot find solid proof of this, but there was a warning in IntelliJ about it)\n- Will remove the Android Context from `RealmConfiguration\/SyncConfiguration\/BaseRealm` making it easier to support JVM in the future.\n","comments":[],"labels":["T-Internal","Pipeline-On-Hold"]},{"title":"Test if a encryption key is correct","body":"#### Goal\n\nI want to be able to test if a encryption key is correct. Right now I have to get a Realm instance using a RealmConfiguration and check if it throws a RealmFileException and just assume that the issue is a wrong encryption key.\n\nThe exception message suggests that it is somehow possible to detect this, at least in Realm core:\n\n> io.realm.exceptions.RealmFileException: Unable to open a realm at path '...': Realm file decryption failed. in \/Users\/cm\/Realm\/realm-java\/realm\/realm-library\/src\/main\/cpp\/io_realm_internal_SharedRealm.cpp line 81 Kind: ACCESS_ERROR.\n#### Expected Results\n\nSome way of identifying the exact cause of the RealmFileException, maybe a specific exception subclass like RealmFileEncryptionException.\n#### Version of Realm and tooling\n\nRealm version(s): 2.0.2","comments":["Hi! . We understand the there are use cases for this, but the major difficulties for the specific exception to indicate the wrong key is it is very difficult to distinguish a corrupted Realm file and a valid encrypted Realm file with a wrong key. I am sorry but we will give this feature a low priority to implement.\n","Actually as far as I know it is impossible to tell the difference between a wrong encryption key and a corrupted Realm file. You can try to guess based on the entropy of the bytes in the file as all encryption schemes will try to make that even, but that would be a fairly heavyweight operation to do.\n"],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"NPE compiling subclass of RealmObject that uses generics","body":"I get a NPE during build time when I compile this subclass of RealmObject:\n\n```\npublic class PersistentList<T extends RealmObject> extends RealmObject {\n    private String mTitle;\n    private RealmList<T> mValue;\n\n    public PersistentList(){\n    }\n\n    public PersistentList(String title, RealmList<T> value) {\n        mTitle = title;\n        mValue = value;\n    }\n\n    public RealmList<T> getValue() {\n        return mValue;\n    }\n\n    public void setValue(RealmList<T> value) {\n        mValue = value;\n    }\n\n    public void setValue(int[] itemClassesDisplayOrder) {\n        mValue = new RealmList<>();\n        for (int i=0;i<itemClassesDisplayOrder.length;i++){\n            mValue.add((T) new RealmInt(itemClassesDisplayOrder[i]));\n        }\n    }\n}\n```\n\nHere is the error thrown by the `Realm` code:\n\n```\nCaused by: java.lang.NullPointerException\n    at io.realm.processor.ClassMetaData.checkListTypes(ClassMetaData.java:175)\n    at io.realm.processor.ClassMetaData.generate(ClassMetaData.java:118)\n    at io.realm.processor.RealmProcessor.process(RealmProcessor.java:146)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.callProcessor(JavacProcessingEnvironment.java:794)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.discoverAndRunProcs(JavacProcessingEnvironment.java:705)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.access$1800(JavacProcessingEnvironment.java:91)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment$Round.run(JavacProcessingEnvironment.java:1035)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.doProcessing(JavacProcessingEnvironment.java:1176)\n    at com.sun.tools.javac.main.JavaCompiler.processAnnotations(JavaCompiler.java:1170)\n    at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:856)\n    at com.sun.tools.javac.main.Main.compile(Main.java:523)\n```\n\nIs there something I'm obviously doing wrong here?","comments":["Using generic type there is not supported.\nWe need to fix the target class of the RealmList as part of the schema.\n\nI think we can improve the error message to make it clear that the generic type is not supported.\n","Any update on the status of this? It seems to be related to (or the same as) #3218 and #2265, but it looks like the improved error message hasn't been implemented yet."],"labels":["T-Enhancement","O-Community"]},{"title":"Allow updating of primary keys","body":"#### Goal\n\nThere should be a method for updating the primary key of an object after it has been created. Previously one could update it using e.g. `object.setId(newId)`, but starting with Realm 2.0.0 this throws an exception to keep it in line with the Realm API in other languages. See the dicussion in Pull Request #3418. The workflow of my app is similiar to the following:\n1. User creates a new object in the database while offline\n2. This object gets a temporary (negative) id, as the app does not yet know what final id the server will assign to the object\n3. User\/app syncs the database when online again\n4. The server receives the new object and assigns a final id to it\n5. The app receives the final id from the server and updates the objects id to the final one (this is currently not directly supported by Realm)\n#### Expected Results\n\nI personally see 2 options going forward with this:\n- **Reallow changing primary key fields:** this would basically put it in the same state as previously with the following code to update an objects primary key:\n  \n  ``` java\n  TestObject object = realm.where(TestObject.class).equalTo(\"mId\", oldId).findFirst();\n  object.setId(newId);\n  ```\n- **Add dedicated method for changing primary keys:** this probably makes more sense if you want to align it more with the Realm API in other languages:\n  \n  ``` java\n  realm.updatePrimaryKey(TestObject.class, oldId, newId);\n  ```\n#### Actual Results\n\nCurrently only a rather ugly and not very performant workaround does the job, basically bypassing the check by making an in-memory copy of the object:\n\n``` java\nprivate static <E extends RealmObject> void updatePrimaryKey(Realm realm, Class<E> type, long oldId, long newId) {\n    E object = realm.where(type).equalTo(\"mId\", oldId).findFirst();\n    E copy = realm.copyFromRealm(object);\n    copy.setId(newId);\n    realm.insertOrUpdate(copy);\n    object.deleteFromRealm();\n}\n```\n\nI'm really looking forward to seeing this fixed in a future update (though I absolutely acknowledge that you have lots of other issues to attend to \ud83d\ude09)\n#### Version of Realm and tooling\n\nRealm version(s): >2.0.0\nAndroid Studio version: all\nWhich Android version and device: all\n#### References\n\nrealm-cocoa: https:\/\/github.com\/realm\/realm-cocoa\/issues\/4194","comments":["Well, I do think this restriction is somewhat odd when you're not actually using `sync` and the Realm Mobile Platform.\n","@Zhuinden Are you referring to the Realm Mobile Platform sync? I'm not using that, and for a couple of reasons won't be able to do so in the near future. So I'll always need to maintain my own sync code and there's no reasonable way around the temporary ids, unfortunately (don't know how the Realm Mobile Platform actually solves this).\n","@TR4Android I mean that this restriction is done to support the Realm Object Server's sync.\n\nSo if you don't have sync, it's weird that we are limited by it.\n","@Zhuinden Yes, I agree. It's a strange limitation to have, especially when writing your own sync code. Though I understand their current focus on the Realm Mobile Platform, it seems kind of odd to me to introduce regressions to the Realm Mobile Database in order to support it.\n","We decided to add this restriction in 2.0.0 of two reasons. First, the Objective-C\/Swift product already had the restriction, and it is important to agree on the behaviour of primary keys. Second, we have to change the behaviour for Realm Mobile Platform. Changing the value of a primary key on one device may lead to inconsistencies on another device. And we don't wish to avoid the behaviour in one set up, and disallow it in another. If you have an standalone app, moving to Realm Mobile Platform must be as easy as possible.\n\nBesides that, it is not recommended to change the value of primary keys in relational databases (see for example http:\/\/stackoverflow.com\/questions\/2499246\/how-to-update-primary-key) since values foreign keys also have to be updated. One could argue that allowing changing the value of a primary key prior to 2.0.0 was a mistake at our side.\n\nIt is much better to add a new object and then remove the old one.\n","@kneth I'm well aware of the reasons for adding the restrictions, but still I think there should be an easier way for updating the primary keys that does not need copying and deleting. Let me respond to a few of your words inline:\n\n> First, the Objective-C\/Swift product already had the restriction, and it is important to agree on the behaviour of primary keys\n\nI agree, that's why I've opened a similiar issue in the realm-cocoa repo (issue https:\/\/github.com\/realm\/realm-cocoa\/issues\/4194).\n\n> Second, we have to change the behaviour for Realm Mobile Platform.\n\nI understand the reasoning behind it, but this shouldn't affect users of the library not using the Realm Mobile Platform, in my opinion. Writing custom sync code is that much harder without having a way of updating primary keys.\n\n> If you have an standalone app, moving to Realm Mobile Platform must be as easy as possible.\n\nUnfortunately the Realm Mobile Platform will never be a viable option for this app, for a couple of reasons:\n- We already have an existing MySQL database on our server (though with some effort it's probably possible to migrate all the data to a Realm database)\n- The server database is quite large and it's not possible to store the complete database on our clients (Android and iOS). Instead we only sync a partial dataset (i.e. a few months worth of data).\n- We don't have the concept of user data. All entries are visible to all users, regardless of who entered it.\n- Clients can also sync across devices using Bluetooth. Chances are that this will break the automatic sync system of the Realm Mobile Platform.\n- We also have a website and as far as I know Realm doesn't support usage with the PHP language.\n- We need to be able to react to events (for merging duplicates and sending push notifications to all registered clients), but can't afford the Enterprise edition as we're an NGO with a free app.\n- Probably a couple of other reasons that would pop up during development.\n\nAs such we can not invest the resources needed to switch to the Realm Mobile Platform, as much as I like the prospect of never having to write a single line for sync anymore. And it's probably very unlikely that the Realm Mobile Platform will support such complex requirements in the near future.\n\n> Besides that, it is not recommended to change the value of primary keys in relational databases.\n\nThat's correct, but it's unavoidable in our case as we need stable ids generated by our server. Besides, I though the whole point of Realm is that it's an object store, as such changing an id shouldn't affect the relations pointing to that object \ud83d\ude09!\n\n> It is much better to add a new object and then remove the old one.\n\nBetter in regards to what? In terms of API required it is definitely better that way. In terms of usability and performance not that much. As such I'd really welcome a `updatePrimaryKey()` method \ud83d\udc4d. It forces users to reflect on changing their primary key and should probably throw an exception if used in conjunction with the Realm Mobile Platform, but it'd make a developers life that much easier if it's absolutely required (as in my case).\n\nAgain and again, thanks for all the hard work and the time you invest in listening to the users of your library!\n","@TR4Android \n\n> Realm is that it's an object store, as such changing an id shouldn't affect the relations pointing to that object \ud83d\ude09!\n\nLet's forget about `PrimaryKey` thingy, and say we have two objects with exactly the same values except different `id`s. Now, I make the two `id`s identical. Are they then different objects? \n\n---\n\nBelieve it or not, the very idea of database is built on top of [**Set Theory**](http:\/\/plato.stanford.edu\/entries\/set-theory\/). It could be defined that If a set is any collection of definite distinguishable things, we can conceive of the set as a whole<sup>[1](https:\/\/mariadb.com\/kb\/en\/sql-99\/set-theory\/)<\/sup>. When a database is to be considered as an universe, we should be able to tell if an entity, an object - in the case of Realm, of the database is distinguishable. \n\nIn order to meet an expected performance for distinction in the presence of large number of entities, one should have an attribute with which no two are the same in the database. With the attribute, an entity or an object becomes one and one only in the database. If the attribute of two \nentities are the same, we tell they are identical. Whatever name the attribute bears, the nature of its role won't change and is commonly known as PrimaryKey.\n\nWhether one recognizes the theoretical debate or not, it is clearly an indecent idea to update PrimaryKey, which increases chances of PK duplication that would lead to mangle the uniqueness of an entity. That's the primary motivation behind many suggestions against updating PK.\n\nOther battle-hardened (or battle-shredded) databases also suggest not to; Oracle advises against updating PK,  IBM DB2 considers update on PK as deletion of an entry, and MariaDB wants PKs to be as stable as possible. \n\nThey also recommend to design PK immutable from the get-go;  should PKs need to change frequently, it is a good indication of schema design flaws.\n\n(*You might argue that surrogate keys might do the job. Firstly, it most likely won't, and I don't believe that's feasible in a constraint environment like mobile devices. I don't know about you, but I cannot become gentle when a database hogs down my phone's resource just for searching keys.)\n\n---\n\nBelow is my 2 cents and is my personal opinion only. I believe restricting update on PK is more of a progression than a regression as it fills up the previously existing gap and promotes a good practice rather than an easy-get-around.\n","@TR4Android you could just replace your current `@PrimaryKey` with an `@Index @Required` field, no?\n\nAlthough in that case, you would have to check if there's already a managed object by the same \"indexed field\", rather than just put `insertOrUpdate()` based on primary key value regardless of whether it is managed or not.\n","@stk1m1 I understand the purpose and value of primary keys, but still I have to update my primary key once (and only once). Call it bad design, but it's **_required**_ in my case. In the current library I have to do workarounds, which is ugly to say the least.\n\nLet me reiterate this: I totally agree that primary keys normally shouldn't be updated, there's no doubt about that. But in my case there's no other way. Being offline, a client can't tell the next id that's usable in the server database. As such, it has to assign a temporary id to the object, of which it is sure that it won't clash with any server objects already synced with the client database (i.e. negative ids in my case). One could theoretically try to generate unique ids on the device, but there's currently no reliable way to do this. Generating temporary ids is such the best a client can do. In order to keep everything consistent though, the client has to update the primary key after the server has assigned the final id though. That is unavoidable and currently unsupported by Realm, which is why I created this issue. I hope I could shed some more light on the use case.\n","@TR4Android Thanks a LOT for the detailed descriptions and also needs in terms of sync - thats  really helpful for us to understand our current limitations!\nI just want to throw one argument into the mix here: In terms of API design we strive to avoid having methods that works in some situations and not in others - it's just leads to really bad API's.\n\nAs we all agree that this is a bad design to include it, I think it's worth exploring if an alternative solution could solve your needs. I obviously don't know how you make your keys, but if you use UUIDs or generate the id's with some part of it including a client unique ID, you could ensure it would be unique.\nAnother alternative is maybe (not sure the team would accept this!) to make a PR with a constant that enabled this, and you could then compile it yourself.\n\nI surely empathize with the annoyance since this already worked, and now we pulled the plug on it :-( But our motivation is just for the greater good of mankind :-)\n","@bmunkholm Yes, I agree that methods that work in some cases, but not in others are bad API design. Still, I see no way around this, at whatever angle I look at this.\n\nGoing down the path of unique device ids, a couple of issues pop up:\n- There's no way of generating unique ids across platforms (i.e. Web, Android and iOS) that I know of, which makes it entirely impossible to rely on unique ids.\n- Android unique ids are hard to get to in a reliable way (see the extensive discussion in this [StackOverflow thread](http:\/\/stackoverflow.com\/questions\/2785485\/is-there-a-unique-android-device-id)).\n- Queries are slower when using `VARCHAR`s as primary keys, especially for more complex queries with lots of `JOIN`s (on the server database).\n- I already have an existing framework that works with `Integer` primary keys (but this shouldn't really be an argument in this discussion, that's just additional work and time required on my side :wink:).\n\nAll in all I think temporary ids are still the best approch in my case, even though I generally try not to change my primary keys. So I'm still hoping that one day Realm will reallow this. Thanks for the consideration!\n","I would be glad if this post have more attention :)","I am facing the same issue related to sync process that TR4Android is facing.\r\nDo we have any solution yet ?","In the meantime, has `setId` been completely removed from the API?\r\nThis makes even @TR4Android 's workaround a PITA to use...\r\nHow can we now write a generic method to do this?\r\n\r\nNote that our Java objects have to extend `RealmObject` **DIRECTLY**.\r\nSo, our only choice is to use the `RealmModel` interface?","The `setId()` was his own method.\r\n\r\nGeneric method to do what exactly? Interfaces work. ","@Zhuinden in Kotlin, I am not allowed to inherit from my own base class and, say, implement `RealmModel`. I get a compilation error (Even with cleaning and rebuilding the project).\r\n\r\n```\r\n:app:kaptGenerateStubsDebugKotlin\r\n:app:kaptDebugKotlin\r\ne: \/Users\/nk\/Projects\/android\/FieldObservations\/app\/build\/tmp\/kapt3\/stubs\/debug\/fieldobservations\/model\/Trap.java:5: error: Valid model classes must either extend RealmObject or implement RealmModel.\r\ne: \r\n\r\ne: public class Trap extends fieldobservations.model.ModelObject implements io.realm.RealmModel {\r\ne:        ^\r\ne: java.lang.IllegalStateException: failed to analyze: org.jetbrains.kotlin.kapt3.diagnostic.KaptError: Error while annotation processing\r\n\tat org.jetbrains.kotlin.analyzer.AnalysisResult.throwIfError(AnalysisResult.kt:57)\r\n\tat org.jetbrains.kotlin.cli.jvm.compiler.KotlinToJVMBytecodeCompiler.compileModules(KotlinToJVMBytecodeCompiler.kt:138)\r\n```\r\n\r\nSo, how can I write the following code only **once** ?\r\n```\r\nopen class ModelObject : RealmModel {\r\n    @PrimaryKey\r\n    open var id : Long = -1\r\n\r\n    open var createdAt = Date()\r\n    open var updatedAt : Date? = null\r\n    open var synced : Date? = null\r\n\r\n\r\n    fun <E : RealmObject> updatePrimaryKey(realm: Realm, type: Class<E>, oldId: Long, newId: Long) {\r\n        val realmObject = realm.where(type).equalTo(\"id\", oldId).findFirst()\r\n        val copy = realm.copyFromRealm(realmObject)\r\n        id = newId\r\n        realm.insertOrUpdate(copy)\r\n        realmObject.deleteFromRealm()\r\n    }\r\n}\r\n```\r\n","@nkanellopoulos you cannot extend a *class* that isn't specifically `RealmObject` in Realm model classes see https:\/\/github.com\/realm\/realm-java\/issues\/761\r\n\r\nBut you can do `extends RealmObject implements HasId<Long>` or something like that. ","Granted @Zhuinden, I can do this (which is exactly what I was contemplating to do).\r\nBut it feels like a hack to me, when I face too many restrictions that seem arbitrary. \r\n\r\n`HasId<Long>`\r\n`CreatedAt<Date>`\r\nand the list goes on...\r\n","I mean if there are multiple fields shared across pretty much all entities then you can put them into a single interface.\r\n\r\nI do admit that inheriting accessors isn't ideal, but I don't have a better alternative at the moment","The main problem is that I cannot have a base class for common stuff. \r\nIt makes perfect sense to share the implementation, when it is exactly the same.\r\n\r\nWhy is there the restriction that my Realm objects should be **direct** subclasses of `RealmObject` ?","@nkanellopoulos because then Core would need to support sharing fields across classes and queries that return the superclass of your concrete objects from all \"tables\". And it doesn't do that yet. ","@Zhuinden I am not requesting the sophisticated behaviour you describe. I probably do not even want it. \r\nI just want to be able to have a base class. It would be perfectly fine with me if \"Core\" would replicate the the fields of the base class in all \"tables\".\r\n\r\nThe base class does not even need to be a `RealmObject`. I think I have tried to extend a POJO and implement `RealmModel`, but this does not work either.","@nkanellopoulos \r\n\r\n> I just want to be able to have a base class.\r\n\r\nThat means Realm needs to support the \"sophisticated behavior\" I described, and it doesn't yet, so it doesn't allow it until it does.\r\n\r\nI admit, inheriting accessors is not that ideal, but that's one option, the other is to make your DAO classes have a shared `getId()\/setId` method  that is implemented for each class in each Dao, or you can also use reflection.\r\n\r\nYou'll still need to copy the fields across the RealmObjects to make them be part of the schema definition for each class, until polymorphism is supported anyways. Which will probably take a while, so I wouldn't sit idly till then.","Any update on this issue? This is still a huge pain point for me. I love Realm and it is making lots of progress, yet this limitation has continued to annoy me. Currently I just copy the fields and then delete the old object, but unfortunately this triggers the change listener with a deletion and not with the new updated fields. \ud83d\ude22\r\n\r\nI would be glad if you could tell me what would I need to do to remove this limitation? What parts of the code would need to be changed. Would you be interested in a pull request (that e.g. ties this limitation to the `syncEnabled` variable)? Thanks in advance!","I am facing the same issue related to sync process that TR4Android is facing.\r\nDo we have any solution yet ?","@celesteshire Unfortunately no official solution, yet \ud83d\ude22. The current workarounds are:\r\n* Copy the object in-memory (`copyFromRealm()`), change the primary id there, insert the new object and then finally delete the old object. However, this makes actual updates appear as deletions in any attached change listeners. You can find a short, generic code snippet in the issue description.\r\n* Remove the `@PrimaryKey` annotation from your field and replace it with `@Required @Index` annotations. However, this requires you to do primary key validation yourself! Depending on your project size and the associated risk of accidentally overwriting an existing object, this might be also be a valid solution.","I am facing this issue when moving to Realm Mobile Platform as well, so it is not just a problem when using custom sync. My app was local and preloaded with a default realm file. The user was then free to modify the data as they wish. Now I want to move to Realm Mobile Platform. This would mean that multiple users have objects with the same primary key, which means I can't just upload the user data to Realm Mobile Platform.","well i mean if they shouldn't overwrite each other then the user could have their GUID and then the actual item primary key could be `userguid_itempk` string value \ud83d\ude44 ","@Zhuinden yes, but then the userguid_itempk would have to be in the default realm file too, which it wasn't. In my case though, I guess I could just change the field used as primary key and generate a new one using UUID.randomUUID or a combination of the current id and the userId\r\n\r\n@TR4Android In your case, wouldn't just using UUID.randomUUID() suffice to generate a unique identifier on the client? \r\n","Still a big pain to this day. No updates whatsoever? \ud83d\ude1e ","I guess you could theoretically close all Realm instances on all threads, open the Realm with a DynamicRealm, remove the primary key constraint from your object field, change the value, then add the primary key constraint \ud83e\udd14","Thanks @Zhuinden for the response!\r\nTheoretically, should that work if I do it in the migration function? I also have a dynamic realm instance there... ","Update: \r\nWhat @Zhuinden suggested did the trick.\r\nAnd it does work also in a migration instance.\r\nJust make sure you don't use \r\n`schema?.addField(\"id\", String::class.java, FieldAttribute.PRIMARY_KEY).tranform...`\r\nbut instead, you do the addField + transform first and then at the end you do\r\n`schema?.addPrimaryKey(\"id\")`\r\n\r\nBut still, this is something that is missing from the library... ","something like this\r\n```\r\nrealmSchema.get(DocUrlMetadata::class.java.simpleName)\r\n            ?.removePrimaryKey()\r\n            ?.addField(DocUrlMetadata::id.name, String::class.java)\r\n            ?.transform { data ->\r\n                data.set(DocUrlMetadata::id.name, data.get(DocUrlMetadata::url.name))\r\n            }\r\n            ?.addPrimaryKey(DocUrlMetadata::id.name)\r\n```"],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog","gathering-interest"]},{"title":"Avoid storing reference to ApplicationContext","body":"Right now we store a reference in the ApplicationContext which should be avoided due to InstantRun.\n\nInstead we could:\n\n* Just get the reference to `context.getFilesDir()` and save that\n* get AssetManager and save that\n* Register the network receiver on `init()` without saving the context\n\nI don't think we use it for anything else, but this approach would also work for any future additions.\n\nPerhaps we could wrap it in a `AndroidContext<Wrapper\/Facade\/Mediator>` class ?\n\n","comments":["`Register the network receiver on init() without saving the context` was done in https:\/\/github.com\/realm\/realm-java\/pull\/3529\n"],"labels":["T-Internal"]},{"title":"@Ignore fields should be changeable in objects in RealmResults list without persistance","body":"There is no way to update **@ignored** fields in RealmResults, which has many use cases to carry processing logic on `RealmResults` from method to method.\n\nIn the case of RealmResults update, we have two options, they should remain unchanged or change to default value. But if there is no change it is clear, RealmResults should persist the `@ignore` for that session of results (not to database but list).\nAs discussed in #923","comments":["This requires core to have some feature to support a `in-mem` column, which won't be stored on the disk but will be carried with the row as long as the Realm file is opened.  \n"],"labels":["Blocked","T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Unit tests should support global init","body":"Fallout from #3457 \n\nTesting this is non-trivial since the Context is now saved in a system-wide Singleton that remains between unit tests.\n\nWe need to refactor to allow the following:\n\n* Add tests for `Realm.init()` not called\n* Don't require all unit tests to specifically require setting this. \n\nA solution I think will work is:\n\n1) Introduce a new `RealmUnitTestRunner` that extends `AndroidJUnit4` runner. It will be responsible for calling `Realm.init(InstrumentationTarget.getTargetContext())`\n\n2) Add a protected `Realm.resetInit()` method that allows specific unit tests to reset the state if needed.\n\n","comments":[],"labels":["T-Test"]},{"title":"Improve performance of creating proxy object.","body":"To support default value feature (#777), #3397 changes the way to create the proxy instance.\nThat introduced about 10-15% unexpected overhead for creating proxy instance.\n\nOne of the reason of performance degrade is accessing the thread local.\nI modified #3397 no to use thread local and it improves the performance about 7-10%.\n\nThe idea is\n1.  Making a state class for each proxy class\n2. Move the proxy class to inner class of its state class\n3. Create State instance first, and then create proxy instance.\n\nI think proxy classes can obtain object context information from its enclosing instance.","comments":["This matters only in case of `realm.createObject()`, right?\n\nSo `realmResults.get(i)` is not impacted?\n","@Zhuinden Unfortunately, it affects all APIs that create proxy object.\n\nIf my idea works as expected, I think that almost all overhead will be removed.\n"],"labels":["T-Enhancement"]},{"title":"Align PrimaryKey related exceptions","body":"When `createObject(Class,Object)` is called and the `Class` does not have any primary key, it throws `IllegalStateException`.\nOn the other hand, if `createObject(Class)` is called and the `Class` has a primary key, it throws `RealmException`.\n\nTyped `RealmObject` throws `RealmException` but `DynamicRealmObject` throws `IllegalArgumentException` when setter is called a against primary key.\n\nShouldn\u2019t we align the exception about primary key?\n\n","comments":["Current conclusion of our internal discussion is that we will align them to `RealmException`.\n"],"labels":["T-Bug"]},{"title":"Throw only C++ exceptions in JNI","body":"We catch C++ exceptions at the border between Java and C++ using the `CATCH_STD()` macro. The C++ exceptions originate from runtime libraries, core and object store. Currently we throw Java exception in the binding using `ThrowException()`. This includes the many parameter checking macros\/functions. That gives us code line:\n\n```\nJNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn\n  (JNIEnv *env, jobject, jlong nativeTablePtr, jint colType, jstring name, jboolean isNullable)\n{\n    if (!TABLE_VALID(env, TBL(nativeTablePtr)))\n        return 0;\n    if (TBL(nativeTablePtr)->has_shared_type()) {\n        ThrowException(env, UnsupportedOperation, \"Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.\");\n        return 0;\n    }\n    try {\n        JStringAccessor name2(env, name); \/\/ throws\n        bool is_column_nullable = isNullable != 0 ? true : false;\n\n        DataType dataType = DataType(colType);\n        if (is_column_nullable && dataType == type_LinkList) {\n             ThrowException(env, IllegalArgument, \"List fields cannot be nullable.\");\n        }\n        return TBL(nativeTablePtr)->add_column(dataType, name2, is_column_nullable);\n    } CATCH_STD()\n    return 0;\n}\n```\n\nUsing only C++ exceptions, we could simplify the above to:\n\n```\nJNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn\n  (JNIEnv *env, jobject, jlong nativeTablePtr, jint colType, jstring name, jboolean isNullable)\n{\n    try {\n        TABLE_VALID(env, TBL(nativeTablePtr)),\n        if (TBL(nativeTablePtr)->has_shared_type()) {\n           throw unsupported_operation(\"Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.\");\n        }\n        JStringAccessor name2(env, name); \/\/ throws\n        bool is_column_nullable = isNullable != 0 ? true : false;\n\n        DataType dataType = DataType(colType);\n        if (is_column_nullable && dataType == type_LinkList) {\n             throw invalid_argument(\"List fields cannot be nullable.\");\n        }\n        return TBL(nativeTablePtr)->add_column(dataType, name2, is_column_nullable);\n    } CATCH_STD()\n}\n```\n\n","comments":[],"labels":["T-Internal"]},{"title":"Adding another RealmQuery#in() methods that accepts values as List","body":"From #3403\n\nCurrently we only provide `RealmQuery#in()` which accepts values as an array.\n\nIn many cases, `List` is used to handle multiple values and `RealmQuery#in()`  that accepts values as List is useful for many developers.\nHowever, we can't provide `RealmQuery#in(String, List<String>)`, `RealmQuery#in(String, List<Date>)` and other variants int the same class  because those have the same method signature.\n\nSo we need to find a way to provide these methods.","comments":[],"labels":["T-Enhancement","Design-Required","Pipeline-Idea-Backlog"]},{"title":"Realm model must extend RealmObject to be considered a valid model class, even if parent extends it","body":"#### Goal\n\n> What do you want to achieve?\n\nCreate a class like this one\n\n``` java\npublic class Post extends RealmDataBindObject {\n```\n\nwith\n\n``` java\npublic class RealmDataBindObject extends RealmObject implements RealmDataBinding, Observable {\n```\n#### Expected Results\n\nInherit `@RealmClass` and `RealmModel` from `RealmObject` while working with databinding too\n#### Actual Results\n\n> Realm model classes must either extend RealmObject or implement RealmModel to be considered a valid model class\n#### Steps & Code to Reproduce\n\n> Describe your current debugging efforts.\n#### Code Sample\n\n``` java\npublic class RealmDataBindObject extends RealmObject implements RealmDataBinding, Observable {\n    @Ignore\n    private transient PropertyChangeRegistry mCallbacks;\n}\n\npublic class Post extends RealmDataBindObject {\n    @PrimaryKey\n    private long id;\n\n    private String text;\n}\n```\n#### Version of Realm and tooling\n\nRealm version(s): 1.2.0\n\nAndroid Studio version: 2.1.2\n\nWhich Android version and device: 6.0.1","comments":["By the way, the only inherited property is ignored. So this isn't directly \"[polymorphism duplicate](https:\/\/github.com\/realm\/realm-java\/issues\/761)\".\n\nRelated to https:\/\/github.com\/realm\/realm-java\/issues\/2716 and additional context [here](https:\/\/medium.com\/@Zhuinden\/realm-1-2-0-android-data-binding-1dc06822287f#.yvnt75lt7)\n","Hmm I wonder if this is same as https:\/\/github.com\/realm\/realm-java\/issues\/2643","I actually should have wanted\r\n\r\n``` java\r\npublic abstract class RealmDataBindObject implements Observable {\r\n    @Ignore\r\n    private transient PropertyChangeRegistry mCallbacks;\r\n}\r\n\r\n@RealmClass\r\npublic class Post extends RealmDataBindObject implements RealmModel {\r\n    @PrimaryKey\r\n    private long id;\r\n\r\n    private String text;\r\n}\r\n```","Hi,\r\n\r\nAny idea when would this be implemented? Just an idea?","Hi @zaheerahmad \r\nUnfortunately not as we have other priorities on the roadmap right now. \r\n\r\nThe easiest solution for this would probably be to create a `RealmDataBindObject` class or similar in https:\/\/github.com\/realm\/realm-android-adapters and then extend the annotation processor so it accepts that class as a valid Realm class (basically just modify the inheritance check for the class). \r\n\r\nBut we do accept pull requests."],"labels":["T-Enhancement","Design-Required","O-Community","Pipeline-Idea-Backlog"]},{"title":"Clean up JNI exceptions","body":"Currently we are trying to convert all JNI exceptions to java exceptions to make it more readable for users. But the disadvantage is we could not see the native backtrace anymore which makes the native debug even more difficult.\n\nSo we should categorize the JNI exceptions a bit:\n\n* Exception caused by wrong java input, misuse of the API, and others which is not a Realm side issues, those thing should be converted to a java exception.\n* Exception like fatal issue, system API misbehaviour or others which is probably caused by Realm or system bugs, a native crash should just happen in case we can get more native backtrace to debug.\n\nAlso merge #3348 into this one.\n\n* Remove ClassNotFound. It is not something should ever happen.\n* Better converter logic, use a map for cpp class -> java class string maybe?\n* Format the exception string in a better way\/a unique way.\n* Refactor the test -- it should have input as a cpp exception and output as a java exception.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Provide ability to create new RealmConfiguration.Builder from an existing realm configuration","body":"#### Goal\n\n> I want to be able to take my production `realm` instance and recreate it, but change the file name. Useful for testing. Yes, this is doable without violating DRY (do not repeat yourself), but requires unnecessary manual effort.\n#### API proposal\n\n> `realm.getConfiguration.newBuilder()` returns a new builder from the existing configuration, similar  [Moshi](https:\/\/github.com\/square\/moshi\/blob\/master\/moshi\/src\/main\/java\/com\/squareup\/moshi\/Moshi.java)'s implementation","comments":["Yes, I can see this being useful.\n"],"labels":["T-Enhancement","First-Good-Issue","O-Community"]},{"title":"Feature Request: Hot-Backups of open realm","body":"**What:**\n\nExpose per realm write locking feature or introduce dedicated api for hot-backs of open realms. \n\n**Why**\n\nThere are currently cases of realm db corruption that cannot be debugged without actually sending the corrupted db file to realm devs. However, the simple case of copying these files might cause secondary corruption of copy db and is non-trivial in the android lifecycle. \n\nExample:\n\nCorruption detected on UI thread via model getXXX(). Corruption for a few rows of data only and not the entire realm db. We now need to copy\/backup the realm file in Background thread. However, we want the app to be responsive so app behaves as normal (realm open\/closes via random nav paths) and user might still issue write operations which is sent to a background thread to be written to realm via transactions. In such case, new user write transactions might overlap manual file copy which causes the destination duplicate db to further corrupted. The larger the realm file, the likely case of this happening increases. \n\n**Notes**\n\n1) Related to https:\/\/github.com\/realm\/realm-java\/issues\/1372\n\n2) Closing all instances of realm before copying is not applicable since that would imply\n\na) a user-api wrapped Realm open\/transaction that does another level of ref counting. Realm can be opened anywhere in the threaded android life cycle: frag\/activity\/service\/custom threads\nb) blocking the entire app (since ui depends on realm  open\/read) and risking ANR due to large realm size even though app is 95% read and 5% write and 5% are background queued tasks.\n\nEdit: simplify the request since what I am really suggesting is hot-backups of open realms or write locking apis to allow us to perform such function.","comments":["@diegomontoya Thanks for suggestion. I'll label it as an enhancement but I cannot see a particular date for releasing it.\n","Would require core support","this is actually possible now with new API `callWithLock()` https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/java\/io\/realm\/internal\/OsObjectStore.java#L85"],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"RealmQuery.equalsTo()\/notEqualsTo() support comparing to RealmObjects","body":"Primary keys aren't necessary in many cases because objects can link directly to other objects without referencing properties, but you're forced to generate an ID if you want to refer to an object in an `equalTo` call. Instead, querying using objects could be easier:\n\n```\nDog fluffy = realm.where(Dogs.class)\n    .equalTo(\"name\", \"Fluffy\")\n    .findFirst();\n\n\/\/ ... later ...\n\nRealmResults<Person> results = realm.where(Persons.class)\n    .equalTo(\"dogs\", fluffy)\n    .findAll();\n```","comments":["I like the idea, but it would only work if `fluffy` was a managed object right? \n","It could also work if `Dog` had a primary key, I would imagine.\n","@cmelchior The snippet in the description indicates that it requires a managed object. By as @6bangs points out, the case where a class is annotated with `@PrimaryKey`, `fluffy` doesn't have to be a managed object as we can query the value of the primary key only.\n","Has this enhancement been made in someway? I was trying to query someobjects like that, using equalsTo(\"fieldName\", objInstance). \r\n\r\nMaybe the only alternative is equalsTo(\"objectIdReference\", objectInstance.getId()), using primary keys and keeping id references in the objects which I might need to query."],"labels":["T-Enhancement","Design-Required","Pipeline-Idea-Backlog"]},{"title":"Computed fields \/ Subqueries as a supported field type","body":"> **Feature Request**: Just fill in the first two sections below.\n#### Goal\n\n> What do you want to achieve?\n\nSet the elements of a RealmObject to be the objects returned by a query without having to explicitly map the proxies of the RealmResults into a RealmList\n\nSomething like this\n#### Code Sample\n\n``` java\n    public class SomeObject extends RealmObject {\n         public OrderedRealmCollection<OtherObject> others;\n    }\n\n    realm.executeTransaction((realm) -> {\n        SomeObject someObject = new SomeObject();\n        someObject.others = realm.where(OtherObject.class).equalTo(\"someObjectId\", someId).findAll();\n        realm.insertOrUpdate(someObject);\n    });\n```\n\nThis would avoid having to explicitly map all elements of a RealmResults into a RealmList before saving a one-many (or many-many) relationship.","comments":["@Zhuinden \n\nI think it would make our API leaner. Since this needs further discussion I'll keep this open until enough opinion gets collected. Thanks for the contribution!\n\nEDIT > `OrderedRealmCollection` was firstly implemented in #2345, which indicated there would come more collection APIs and this suggestion would perhaps need to be considered in a context that combines the future, upcoming collection APIs.\n\nEDIT >> I'll put `enhancement` tag to trace the progress on this suggestion. Hope this is ok with you.\n","Well, the real question is whether it's even possible :) \n\nBut it would definitely greatly simplify mapping one-many and many-many relationships. Currently that's the most memory-intensive operation when using Realm. \n","I think it is possible and I'd be glad to see something that reduces lines and make things clear.\n\nWhat I'm wondering is the point when you get results from Realm. Suppose I have a RealmObject like below.\n\n``` java\npublic class User extends RealmObject {\n    @PrimaryKey\n    private String name;\n    public OrderedRealmCollection<Dog> dogs; \n}\n```\n\nOnce you saved `dogs` field with `OrderedRealmCollection` it would work great for now. In the future, however, what should I expect for `dogs` field when `RealmSet` API is available? \ud83d\ude05 \n\nIt's just one concern, but I think the idea is something we'd like to consider when expanding out API.\n","@stk1m1 \n\n> what should I expect for dogs field when RealmSet API is available?\n\nI'd expect it to be a `RealmList` at the moment when obtained with `findAll()` :tongue: \n","We have talked internally about computed fields which is a broader concept than what is described here, but it would probably look something like this:\n\n```\npublic class Person extends RealmObject {\n  private String firstName;\n  private String lastName;\n\n  @Query(\"name == 'Fido\") \/\/ Text based query language shared between all Realm bindings.\n  RealmResults<Dog> dogs;\n\n  @Computed(\"$firstName $lastName\") \/\/ Basic math + string manipulation\n  private String displayName;\n}\n```\n\nThough none of this is very concrete yet. I actually thought we had an issue for it, but I couldn't find it. So might as well just use this one.\n\nPersonally I think it is a good idea, although `@Computed` might just as well be replaced by a custom getter in Java. We just need to prioritize looking at it.\n","Well if this proposition could do something like\r\n\r\n``` java\r\npublic class Person extends RealmObject {\r\n  @PrimaryKey\r\n  private String userId;\r\n\r\n  @Query(\"Dog.personId == $userId\") \/\/ Text based query language shared between all Realm bindings.\r\n  RealmResults<Dog> dogs;\r\n}\r\n```\r\n\r\nThen that would be rather powerful.\r\n\r\nInitially my premise was to solve the issue that in order to map one-many and many-many relations, you need to obtain each element and put them in the list, which scales `O(n)` in memory use.\r\n\r\nBut this might solve that and be possibly even more powerful. Declarative `join`s available as List lazy evaluated? That's rad. Of course, the question does arise whether you'd be able to do `realm.where(Person.class).equalTo(\"dogs.name\", \"Fido\").findAll();`.\r\n","@Zhuinden \n\n> > what should I expect for dogs field when RealmSet API is available?\n> \n> I'd expect it to be a `RealmList` at the moment when obtained with `findAll()` :tongue: \n\nI was pointing what I should expect when there are `RealmResults`, `RealmList` and `RealmSet` when you retrieve values from Realm (i.e. `RealmResults<Person> people = realm.where(Person.class).findAll()`) If _computed field_ is to be implemented anyway, we can perhaps find a way to identify what type of collection we'd look for.\n\n``` java\npublic class User extends RealmObject {\n    @PrimaryKey\n    private String name;\n\n    @CollectionType(RealmSet)\n    public OrderedRealmCollection<Dog> dogs; \n}\n```\n\n> Initially my premise was to solve the issue that in order to map one-many and many-many relations, you need to obtain each element and put them in the list, which scales O(n) in memory use.\n\n~~Could you elaborate on this one? I thought it's more of O(n^2) though.~~\nActually, it should be O(n) if modles are copied.\n\n> But this might solve that and be possibly even more powerful. Declarative joins available as List lazy evaluated? That's rad. \n\n\ud83d\udc4d \n","@cmelchior I actually found the issue, it's https:\/\/github.com\/realm\/realm-java\/issues\/615"],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Sorting NULL first\/last","body":"When sorting it would be nice to be able to specify if NULL values in the column should be at the beginning or end of the results.\n\nThe current behaviour is for NULLs to be at the beginning of the results if ASC and end if DESC.\n\nIn my application I am querying a list of records by \"date due descending\". \nThe requirement for the UI is to display records without a due date first followed by those with a due date. Currently all those without a due date appear at the bottom of the list.\n\nTo make it easy to use I would just suggest enhancing the io.realm.Sort enum by adding ASCENDING_NULLS_FIRST\/LAST and DESCENDING_NULLS_FIRST\/LAST.","comments":["In the meantime, you can construct your displayed elements from multiple RealmResults.\n\nhttp:\/\/stackoverflow.com\/a\/34976540\/2413303\n","@JM-Agrimap \n\nIt saddens me to tell you the feature you've sought after is not currently supported. I'll place this suggestion in `enhancement` to track in the future. Thanks!\n\nEDIT > You might want to take a look at @Zhuinden's suggestion to combine two results. i.e. The one sorted witout NULL and the one with NULL only.\n","**Internal Note**\n\nIt looks like this issue has been discussed about an year ago here https:\/\/github.com\/realm\/realm-java\/issues\/3209 but revoked due to be aligned with other databases.\n","It's almost 2019 :(","And you're pretty much the third person in almost 4 years to ask for it so far, so don't keep your hopes up.","Well I'll be the fourth; I'm currently in need of exactly this capability.","I'm sure the number is a lot more than four. Everybody is just hacking it with multiple RealmResults.","You can solve the issue with two fields in your object instead of using multiple lists, which is much easier if you can update both fields simultaneously.\r\n\r\n- For example one for your date and one if it is available\r\n```\r\nclass RealmMediaWrapper {\r\n    val releaseDate: Long\r\n    val hasReleaseDate: Boolean\r\n}\r\n```\r\n\r\n- Sort first whether the date is available and then the date itself. For example:\r\n```\r\nif(sort == Sort.ASCENDING)\r\n   results.sort(RealmConstant.HAS_RELEASE_DATE, Sort.DESCENDING, RealmConstant.RELEASE_DATE, sort)\r\nelse\r\n   results.sort(RealmConstant.RELEASE_DATE, sort)\r\n```\r\n\r\n- Migrate old objects if necessary\r\n```\r\ntransform {\r\n   val value = it.getLong(\"releaseDate\")\r\n   it.setBoolean(\"hasReleaseDate\", value != 0L)\r\n}\r\n```","Thanks for the trick @chrisbln - just tried it out and it's working great for now. A little annoying to add an extra field for this, but sorting in realm is so much faster than trying to sort in memory.","Bump. Would be nice to have this feature.\r\nFor now we should create extra sorting fields or concat multiple lists","Yeah, having that feature would be great because sorting in memory is way slower."],"labels":["T-Enhancement","O-Community","Pipeline-Idea-Backlog"]},{"title":"Feature Request: Expose some general\/resource stats from Realm core.","body":"What:\n\nExpose global Resource usage summary from the realm core (which is currently a black box) at the point of the call. For example:\n\n1) How many files\/fds are currently opened\/held by realm core. \n2) How many active mmap() are there and the size of each call.\n2) How many realms are currently open.  For each realm, how many different versions are currently open but not closed due to each thread\/transaction holding on a different version?\n3) How many realm queries are active (not released)\n4) Any other stats info that may be relevant to the dev to understand resource usage of the non-java portion of the library. \n\nThe above are some things just came to to the top of my head. It may or may not be possible but any info would be great. Think of this as a overview resource usage point-in-time for Realm core. \n\nWhy:\n\nA) General stats. regardless how minimal,  can really reveal an implementation bug by the end user. Realms not closing correctly, queries held and not released, too many different threads are opening realms. \n\nB) This would also help developer create better android tests when we know at a specific point, barring GC and finalizer lag, that there should be X realms open, X for other stats. It help devs create better tests for code using realm library by comparing current values to expected internal states. \n\nC) It is sometimes extremely difficult to debug bugs caused by resource usage caused by  a .so library: too much ram used, too many fds, etc, if the library does not expose some stats info.  Android and especially version <= 4.X can behave wildly under extremely resource exhaustion and crash at points that has no relevancy due to the core cause. If we can log the crashes with the the realm core internal stats, it would help give devs get  a closer version of the 100% view of the issue at hand and not just where it crashed, which sometimes is really useless. \n\nSome the above is possible by extending Realm or wrapping realm opens\/closes transaction\/open\/close\/do our own ref\/stat counting but that's a lot of abstraction when the core has already all the info plus other info we can't possibly get currently. \n\nSorry for the verbosity but hopefully the above gives a general idea of what I propose and reasoning behind it.","comments":["I totally agree. Although most of data you asked can be recorded in java layer, it is still good to have the feature implemented in our underlying engine. I will create an issue in our storage engine repo.\n","> B) This would also help developer create better android tests when we know at a specific point, barring GC and finalizer lag, that there should be X realms open, X for other stats. It help devs create better tests for code using realm library by comparing current values to expected internal states. \n\nBTW, Finalizer will be killed soon by #3144 \n","@beeender Awesome! Very much looking forward to #3144. \n\n>  Although most of data you asked can be recorded in java layer, it is still good to have the feature implemented in our underlying engine. \n\nThe stats can be added\/recorded by the java layer but the direct core stats would be best since it is not dependent on any wrapper code which can introduce bugs themselves by losing objects that hold the native refs. Might even help unit testing the library itself as well post #3144. \n","This would be super useful for debugging an issue where Realm's db file keeps increasing in size when it's running in the background for a long time. For instance, now that core can report on aggregate table size, can that be exposed as part of this? https:\/\/github.com\/realm\/realm-core\/pull\/2591.","@nateridderman Maybe https:\/\/github.com\/realm\/realm-java\/pull\/4857 would help your case?"],"labels":["Blocked","T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Document adding a single, optional field to a RealmObject subclass","body":"#### Goal\nLearn what is necessary for migration (if anything) when adding a single, optional (i.e. may be `null`) field (e.g. a `String`, `Long`, or other `RealmObject`) to a `RealmObject` subclass. For example, I add a field as follows:\n\n```diff\n public class C extends RealmObject {\n     @PrimaryKey private long id;\n+    private String name;\n }\n```\n\nI believe this is a very simple case with a possibly simple solution. Either I don't need to do anything or I need to add a migration using `addField()`.\n\n#### Expected Results\nI expected to find the answer in the [Migrations section](https:\/\/realm.io\/docs\/java\/1.1.0\/#migrations) of the documentation. If not there, I expected to find it in the [`Migration.java`](https:\/\/github.com\/realm\/realm-java\/blob\/2b22ca765f885b6fd6985d9ef5618041f551a3ae\/examples\/migrationExample\/src\/main\/java\/io\/realm\/examples\/realmmigrationexample\/model\/Migration.java) of the migration example.\n\n#### Actual Results\nI found some possibly related statements and examples, but there was too much ambiguity to determine whether they applied in my case.\n\nConsider the opening text in the Migrations section of the documentation:\n\n> If you have no data stored on disk under the old database schema, just changing your code to the new definition will work fine.\n\nWell, I do have data stored for the object. But I don't have data for this particular new field. The field is optional, so that's okay for the application. But I don't know how Realm works if I just add the field to the class and don't do a migration of the schema.\n\nThe two migration code examples shown (adding a new class and adding a new primary key field) are somewhat more complicated than mine, so I'm not sure. The same holds for the larger migration example application.\n\n#### Suggestions\nI can imagine one of two straightforward statements will help alleviate my concern:\n\n1. A migration must be done for _every_ schema change, _even_ including something as simple as adding an optional field.\n1. Some schema changes, such as adding an optional field, do not need a migration. Realm automatically adds the field to the schema.\n\nIf you add a statement like one of these to the documentation, it would help to clarify how migration works.\n\n","comments":["If you add a new field to your object (to the Java class), then on next `Realm.getInstance()` call, schema validation will fail, and you'll get a migration needed exception.  You have to bump the schema version and add the field. \n","@Zhuinden Just in case it's not clear, I'm talking about adding a field only in code (statically), not using `DynamicRealmObject`. I actually have code in which I've added a new field, and I didn't get a `RealmMigrationNeededException`.\n","You probably had `deleteIfMigrationNeeded` on your configuration? That's my guess. \n","@Zhuinden Hmm, that's true. It was there before. I've changed it since, though. Thanks for the insightful help.\n\nNonetheless, I think my own problem doesn't diminish the need to add a bit of clarification to the documentation. I would add a line to add some stress that every schema change requires migration. Also, by demonstrating it with the simplest possible change \u2013\u00a0in particular, with a change that would _not_ require a schema change in less schema-strict databases \u2013 would help highlight this.\n\nFinally, in a pedagogical sense, the simplest change helps to introduce the issue of migration slowly, to help develop intuition. Starting with a more complicated change can introduce confusion, as it did with me.\n","Hi @spl Yes, it sounds like we should clarify that.\n"],"labels":["T-Doc","O-Community"]},{"title":"Add example of a primary key migration","body":"#### Goal\n\nLearn how to migrate a `@PrimaryKey`-annotated field.\n#### Expected Results\n\nI expected to find an example of it [here](https:\/\/github.com\/realm\/realm-java\/blob\/2b22ca765f885b6fd6985d9ef5618041f551a3ae\/examples\/migrationExample\/src\/main\/java\/io\/realm\/examples\/realmmigrationexample\/model\/Migration.java).\n#### Actual Results\n\nInstead, I found an example at #3068.","comments":["Some things that could be clarified:\n1. What is the minimum required migration for a simple change to the primary key? Say you wanted to, for example, increment every `long` by 1.\n2. What do you need to do to change the type of the primary key? I suppose the answer is in the example of #3068.\n\nAlso, while looking into this, I see that a bug was fixed in #2920. That might also be mentioned in the example code. (And it looks like I should upgrade from 1.0.0.)\n","Since the question has come up a few times. I agree, we should update the example to include this information.\n"],"labels":["T-Enhancement","O-Community"]},{"title":"Using static code checking tool for GCed ref problem in tests","body":"See https:\/\/github.com\/realm\/realm-java\/pull\/3135#issuecomment-230484300\n\n","comments":["I think you can create custom checks with FindBugs.\n"],"labels":["T-Test","Pipeline-Idea-Backlog"]},{"title":"Log a warning if a Realm is closed with uncompleted async transactions","body":"Spinoff from #1893 \n\nRight now it is possible to start an async transaction and then immediately close the Realm and exit the app. In the best case, the transaction completes, but doesn't notify anyone. In the worst case the transaction isn't completed and the user is unaware.\n\nRight now we store all async transactions in a static executor, so it will continue to run while the process is still active, but it still seems like an anti-pattern to allow un-completed jobs to hang around after the Realm is closed.\n\nIMO we should do 2 things:\n1) Track which transactions belong to which Realm in `RealmThreadPoolExecutor`\n2) If a Realm is fully closed we should purge all jobs belonging to that Realm.\n3) If we remove any non-canceled jobs we should log a warning about it.\n\n```\nRealm realm = Realm.getDefaultInstance();\nrealm.executeTransactionAsync(...);\nrealm.close();\n```","comments":[],"labels":["T-Enhancement"]},{"title":"Documentation: Note the type of files that Realm may create and what they do","body":"I just noticed that realm is also creating \".management\" files in-addition to .lock, .log, .note files. I don't think the files and their use are documented. This would would be a good addition to documentation.\n\nWould also be good to note if each file is safe to remove if the realm is not open.\n\n","comments":["Yes, that sounds like something we should document. All auxiliary files are safe to delete if the Realm is no longer open. If you delete them while it is open you risk corrupting the file, sinc threads or processes can no longer see that others are working on the file.\n"],"labels":["T-Doc","O-Community"]},{"title":"JNI clean up - almost all JNI method should be static","body":"See \nhttps:\/\/developer.android.com\/training\/articles\/perf-jni.html\n\n> In JNI_OnLoad, register all of your native methods. You should declare the methods \"static\" so the names don't take up space in the symbol table on the device.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Support `null` element in `RealmList`","body":"like this \n\n```\npublic class Dog extends RealmObject {\n    private String name;\n    private int age;\n\n    \/\/ ... Generated getters and setters ...\n}\n\nRealmList<Dog > dogs= new RealmList<>();\ndogs.add(null);\n```\n\nbut I can't use \"dogs.add(null);\"\n\n```\n Caused by: java.lang.IllegalArgumentException: RealmList does not accept null values\n                                                                 at io.realm.RealmList.checkValidObject(RealmList.java:733)\n                                                                 at io.realm.RealmList.add(RealmList.java:187)\n```","comments":["Adding `null` to `RealmList` is not supported yet :( . What you can do is create a dummy `Dog` object to indicate it is a `null` `Dog` for now.\nlike:\n\n```\npublic class Dog extends RealmObject {\n    private String name;\n    private int age;\n    private boolean isNull;\n    \/\/ ... Generated getters and setters ...\n}\n```\n","OK,I know\n"],"labels":["T-Enhancement","Blocked","O-Community","Pipeline-Idea-Backlog"]},{"title":"@Ignore and kotlin property delegate","body":"```\nopen class EnabledEngine : RealmObject {\n    \/\/@Ignored cannot be applied here\n    val engine: SearchEngine by lazy {\n        searchEngines[id]!!\n    }\n}\n```\n\nWithout `@Ignore` a build error will occur since final property cannot pass annotation process","comments":["This is a huge limitation. It seems you cannot use delegated properties with ANY Realm properties \u2013 making Realm effectively incompatible with Kotlin.\r\n\r\nNot only do Realm annotations not work on (Annotation processor error: \"This annotation is not applicable to target 'member property with delegate'\"), but because Delegated properties are themselves final (the delegated property proxy object does not itself get changed after initial assignment), Realm throws annotation processing error: \"Final fields are not allowed. Class: Chat, Field: messages$delegate\"\r\n\r\nHow are you supposed to do custom setters on Realm objects?","As @davidgarciaanton mentioned in https:\/\/github.com\/realm\/realm-java\/issues\/4185, you can use `@delegate:Ignore` like this:\r\n```\r\nopen class EnabledEngine : RealmObject {\r\n    @delegate:Ignore\r\n    val engine: SearchEngine by lazy {\r\n        searchEngines[id]!!\r\n    }\r\n}\r\n```\r\nCheck the Kotlin docs on [Annotation Use-site Targets](https:\/\/kotlinlang.org\/docs\/reference\/annotations.html#annotation-use-site-targets)","Not working in the latest with \"'@delegate:' annotations could be applied only to delegated properties\". Any workaround for this?\r\n\r\n"],"labels":["T-Feature"]},{"title":"Import\/Export Support","body":"> **Feature Request**: Just fill in the first two sections below.\n> \n> **Bugs**: To help you as fast as possible with an issue or bug please describe your issue and the steps you have taken to reproduce it in as many details as possible.\n> \n> Thanks for helping us help you :-)\n> \n> Remove this and above before submitting.\n#### Goal\n\n> What do you want to achieve?\n\nWe would like to more easily be able to export data from a realm database and import it in. Right now realm does not have any official import\/export support like other databases do. \n\nBasically something like this would be nice https:\/\/github.com\/realm\/realm-cocoa-converter or baked right into realm. Right now its hard to get data in and out of realm in formats other than .realm which is proprietary and not very portable.\n\nIn order to export more easily to formats like CSV, XLS, PDF we will need this support added\n#### Expected Results\n\nEasy data import\/export in multiple formats","comments":["Yes, this is definitely something we want to add, however we prioritise fixing features that doesn't have work-arounds currently, and import\/export is something that should be possible using our existing API's. Although I fully agree it would be nicer if Realm had API's in place for making it easier.\n\nOne thing to keep in mind is that Realm is an Object Store which means that the data might not be immediate serialisable into tabular form, e.g. what should we do with circular references. Most likely we will make up \"fake\" keys for all objects, but it needs to be discussed first.\n","waiting......\n","Still waiting....\nIs any idea, when you are going to add this feature?\n\nAnd how i can import a big table in CSV file to my .realm database?\n","Sorry we don't have a timeframe yet.\n","@cmelchior We have been successful at exporting the realm database as csv or .realm but we feel like there may be some issues with the workaround as some people report the file is sometimes empty when there should be data.\n\nOne thing we have not yet figured out is importing as an example csv into the realm database. If at the very least Realm could produce an example on importing workaround that would probably be very helpful for all the devs using it right now.\n","@cmelchior Any update on this? ","I assume you just need to read the CSV into an unmanaged RealmObject and insert that into your DB in a transaction, just like you would with any batch inserts from any data source, including REST APIs.\r\n\r\nSee https:\/\/stackoverflow.com\/a\/39385985\/2413303","Would prefer official support like other databases offer ","Why is this feature taking so long? Is there a reason not to support it?","Mostly because it doesn't have a high priority, compared to other features on our list.","I think realm should atleast have a documentation page on how one can implement import\/export on their own. \r\n\r\nThis is a much needed feature for any database. ","Worst case scenario it is possible using the DynamicRealm API","any update on this? I need to use this feature in my android application..","Honestly guys, I'm not even sure what you guys need here :D\r\n\r\nBut supposedly realm studio can import CSV, I'm a bit confused by how to actually set up the schema though with it, seems to think everything is a string ","Any update on this feature? ETA?","I support the backend of a mobile application. The apps teams for android and ios use realm. My interest in this is for when something goes wrong and a user needs to export their data from their phone. I load their exported realm db up in realm browser then manually compare with our data on the backend. I want to be able to automate that task. I'm sure there are many reasons for a programatic export of data from realm. The closed nature of realm and your unwillingness to make something like this a priority makes me want to move away from this technology and recommend other things.","@RohitSurwase what exactly do you need? As I said, people are like +1 but what do they need?\r\n\r\nWhat is their goal? What format to what format? How do they intend to preserve the links of objects without primary keys?  How do they intend to portray links in CSV??? ","@Zhuinden  My requirement is very basic, all I need is .realm file to any lighter readable file format (like .csv).  Additionally, even if the exported file could not maintain the relationship without primary IDs, I would manage with that.","Do you need to do this on Android or on Windows or also on Mac?\r\n\r\n Although I think on Android  that should be easy with the DynamicRealm API, excluding links because that sounds hard ","@Zhuinden  For Android. I'll also look into DynamicRealm API.","@RohitSurwase `Set<Class<? extends RealmModel>> latestRealmObjectClasses = realmConfiguration.getRealmObjectClasses();` is the magical component, imo.\r\n\r\nActually I started writing it but are you supposed to create a CSV per each table? I assume so because of how you can't really do it any other way, right?","@Zhuinden Yes, I want to create CSV per each table. Is there any API\/function to export a table to CSV in Realm?","@cmelchior what would it take to get official import and export support? All major android databases offer it. We made a workaround for export but it isn't pretty and importing is still almost impossible.","@cmelchior Is that export workaround publicly available? Can you please provide a link to do so? Let me check if it fits my use case.","Realm Studio does have an import\/export feature that you can use, but that obviously wouldn't work programmatically in an app, which I assume you are requesting?\r\n\r\nThis is a feature that is very well suited for anyone to take on by using the public dynamic API zhuinden referred to. It doesn't really require any knowledge of Realm implementation details. It can be implemented using just public APIs. There are however details and compromises that need to be considered about what exactly is needed in particular with relationships.\r\nThere are many other features that would be much harder to do for someone not intimately into the codebase, so I think it's better for Realm engineers to focus on those features and ask for help from others on this feature. Alternatively, if this is an important business feature it's always a possibility to fund the development by talking to sales@realm.io.\r\n","@bkerensa \r\n\r\n> All major android databases offer it. \r\n\r\nI am not aware of this, can you show an example API?\r\n\r\nI mean, Stack Overflow shows that for SQLite, people also wrote their own export function: https:\/\/stackoverflow.com\/a\/47464560\/2413303\r\n\r\nOn that level, it ***is*** possible with Realm's APIs.\r\n\r\nImporting is tricky because CSV won't show relationships. You have an object graph and not just foreign keys. But that's why there is no overhead of JOIN.","This is never gonna happen, right? :\/","@hernangonzalez probably not, no\r\n\r\nI really am not sure how you'd do the relationships in the CSV. Unless you \"add foreign keys\" to the exported file, but you can't really do that without internals (object id) for relations to RealmObjects that have no primary key.","seems like realm-cocoa-converter just [exports into multiple cvs files](https:\/\/github.com\/realm\/realm-cocoa-converter\/blob\/45b0ee22ac69f9621cccb7087315f7851306b8c8\/RealmConverter\/Exporter\/CSVDataExporter.swift#L54) (per object). Would that also work for you? \r\n"],"labels":["T-Feature","First-Good-Issue","O-Community","Pipeline-Idea-Backlog"]},{"title":"Add ability to perform custom query logic","body":"Not sure if something like this will be possible based on how realm is designed but I have a model class that has fields: firstName and lastName and my model has a method getFullName().\n\nI have search functionality that relies on the full name to search for results. Currently (it seems) that the only way to make this work would be to add a field fullName and keep that updated whenever the first or last name is updated.\n\nIt would be convenient if you could do something like this:\n\n```\nRealm realm = Realm.getDefaultInstance();\nfinal String searchText = \"John R\";\nrealm.where(User.class).findAndFilterAsync(new Realm.Filter() {\n    @Override\n    public Boolean execute(User user) {\n\n        String fullName = user.getFullName();\n        if (fullName.indexOf(searchText) != -1){\n            return true;\n        }\n\n        return false;\n\n    }\n});\n```\n\nIf there's any other way of accomplishing something similar that would be great too.\n\nThanks!","comments":["For your spesific example, i think you should use Contains, it accepts (@NotNull fieldname, fieldvalue) or (@NotNull String fieldname, String fieldvalue,Case casing).\nBut +1 for the idea :)\n:+1: \n","@hay12396 how does that solve the problem if the realm object doesn't have that field saved? In my example the full name is computed based the first and last names, so using contains wouldn't work. \n","As it is now, you will need to split the text to first&last name and use contains twice.\n","Ok, i still think this is a useful feature for searching a realm. For instance if the example was changed to some other type of non-text based search where the value being searched needs to be derived from fields it would be difficult to do. \n","@johnryan I think this is a great feature to have aswell :+1: \n","Unfortunately it is not supported by our underlying storage engine (which is not open-sourced yet) right now :( \nAnd the major pain point is since our underlying storage engine is written in C++, the query condition might need to be run as a callback from C++ to java which will be slow. (#2313 with the same problem)\n\nBut it would be a very useful feature!\n","Cocoa is tracking a similar feature here: https:\/\/github.com\/realm\/realm-cocoa\/issues\/1265\n"],"labels":["T-Feature","O-Community","Pipeline-Idea-Backlog"]},{"title":"Date type compatibility from Cocoa to Java","body":"#### Goal\nMake sure `Date` type is compatible from Cocoa to Java.\n\n#### Expected Results\nAdd unit tests for reading `Date` type data from Cocoa to its original.\n\n#### Version of Realm and tooling\nRealm version(s): 0.90.0\n\n","comments":["### Timestamp Getter\n\n[**Cocoa Timestamp -> NSDate**](https:\/\/github.com\/realm\/realm-cocoa\/blob\/master\/Realm\/RLMUtil.hpp#L162)\n\n``` c++\n\/\/ Date convertion utilities\n\/\/ These use the reference date and shift the seconds rather than just getting\n\/\/ the time interval since the epoch directly to avoid losing sub-second precision\nstatic inline NSDate *RLMTimestampToNSDate(realm::Timestamp ts) NS_RETURNS_RETAINED {\n    if (ts.is_null())\n        return nil;\n    auto timeInterval = ts.get_seconds() - NSTimeIntervalSince1970 + ts.get_nanoseconds() \/ 1'000'000'000.0;\n    return [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:timeInterval];\n}\n```\n\n[**Java Timestamp -> milliseconds**](https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-jni\/src\/util.hpp#L672)\n\n``` c++\ninline jlong to_milliseconds(const realm::Timestamp& ts)\n{\n    \/\/ From core's reference implementation aka unit test\n    \/\/ FIXME: check for overflow\/underflow\n    const int64_t seconds = ts.get_seconds();\n    const int32_t nanoseconds = ts.get_nanoseconds();\n    const int64_t milliseconds = seconds * 1000 + nanoseconds \/ 1000000; \/\/ This may overflow\n    return milliseconds;\n}\n```\n\n---\n\n### Timestamp Setter\n\n[**Cocoa NSDate -> Timestamp**](https:\/\/github.com\/realm\/realm-cocoa\/blob\/master\/Realm\/RLMUtil.hpp#L169)\n\n``` c++\nstatic inline realm::Timestamp RLMTimestampForNSDate(__unsafe_unretained NSDate *const date) {\n    auto timeInterval = date.timeIntervalSinceReferenceDate;\n    if (isnan(timeInterval))\n        return {0, 0}; \/\/ Arbitrary choice\n\n    \/\/ Clamp dates that we can't represent as a Timestamp to the maximum value\n    if (timeInterval >= std::numeric_limits<int64_t>::max() - NSTimeIntervalSince1970)\n        return {std::numeric_limits<int64_t>::max(), 1'000'000'000 - 1};\n    if (timeInterval - NSTimeIntervalSince1970 < std::numeric_limits<int64_t>::min())\n        return {std::numeric_limits<int64_t>::min(), -1'000'000'000 + 1};\n\n    auto seconds = static_cast<int64_t>(timeInterval);\n    auto nanoseconds = static_cast<int32_t>((timeInterval - seconds) * 1'000'000'000.0);\n    seconds += static_cast<int64_t>(NSTimeIntervalSince1970);\n\n    \/\/ Seconds and nanoseconds have to have the same sign\n    if (nanoseconds < 0 && seconds > 0) {\n        nanoseconds += 1'000'000'000;\n        --seconds;\n    }\n    return {seconds, nanoseconds};\n}\n```\n\n[**Java Date.getTime() -> Timestamp**](https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-jni\/src\/util.hpp#L682)\n\n``` c++\ninline realm::Timestamp from_milliseconds(jlong milliseconds)\n{\n    \/\/ From core's reference implementation aka unit test\n    int64_t seconds = milliseconds \/ 1000;\n    int32_t nanoseconds = (milliseconds % 1000) * 1000000;\n    return realm::Timestamp(seconds, nanoseconds);\n}\n```\n1. As one can see from the snippets above, Cocoa adds `NSTimeIntervalSince1970` (978307200.0) to [`seconds`](https:\/\/github.com\/realm\/realm-core\/blob\/master\/src\/realm\/timestamp.hpp#L64) part of Timestamp while Java doesn't. \n   If we're to store a timestamp from Cocoa side and read from Java, we'll have a timestamp with `978307200` added. Meanwhile, cocoa would have a timestamp with `978307200` subtracted if it reads a timestamp value from Java.\n2. Cocoa filters timestamp from `std::numeric_limits<int64_t>::max() - NSTimeIntervalSince1970` (a positive figure) to `std::numeric_limits<int64_t>::min() + NSTimeIntervalSince1970` (a negative figure), and clamps it. Since `std::numeric_limits<int64_t>::max()\/min()` are big numbers, it is hardly likely that this filtering would be recognized as an incompatibility. It would nevertheless cause an issue when a timestamp value gets exchanged between platforms. \n3. Futher, `static_case<int64_t>` in cocoa could cause [the same issue](https:\/\/github.com\/realm\/realm-java\/pull\/1529#issuecomment-183219989) Realm-Java had. \n\nCould this be move to OS for better compatibility?\n"],"labels":["T-Internal","Pipeline-Idea-Backlog"]},{"title":"Rename RealmConfiguration.Builder.name() to filename()","body":"We had a couple of cases where people have been confused by the `RealmConfiguration.Builder.name()` parameter. Especially they expected the filename to end with `.realm`.\n\nWe don't have any techical requirements for enforcing that realm files end with `.realm`, and the only advantage would be that e.g. any stand-alone browser could more easily identify the file as a Realm file.\n\nIMO we could do a number of things to make this slightly easier:\n\n1) Automatically append `.realm` to any name if it doesn't have it already. \n\n2) Always append `.realm`. This means that existing apps might start seeing `foo.realm.realm`. Would also make upgrading a bit tricky as it would be easy to forget. \n\n3) Keep current behaviour, but change the method to `filename(String)` instead of `name(String)` as that would make the intent more clear.\n\nI would probably lean towards 3) as that makes the intent clear without breaking any existing files. I could be convinced that 1) also might be okay, since having well defined file extensions is always a plus if people are managing the file themselves somehow.\n\nWhat do you think @realm\/java ?","comments":["I agree: option 3 is best. Maybe we need to update the documentation too?\n","Yeah, we should clarify in the javadoc as well\n","I prefer 1), but 1) may cause some problems.\n\nSo, I vote 3)\n","As a conservative, my vote goes to :three: \n","I prefer option 3.\n","I like 3.\n"],"labels":["T-Enhancement","Breaking"]},{"title":"Increase test coverage for RealmResults<DynamicRealmObject>","body":"After merging https:\/\/github.com\/realm\/realm-java\/pull\/2620 we have lost test coverage for almost all `distinct*\/findAll*` methods that have `DynamicRealmObject` as a return type.\n\nInput errors should already be covered by other tests, but we need to ensure that the happy path still works. Look for use of `isDynamicQuery()` in `RealmQuery`\n\n","comments":[],"labels":["T-Test"]},{"title":"Refactor RealmProxyClassGenerator to have clean control statements","body":"#### Goal\nFrom #2515, it is observed that we have some clutter in our [`RealmProxyClassGenerator.java`]() that it generates logics like following.\n\n```java\npublic void realmSet$columnString(String value) {\n     ((RealmObject) this).realm.checkIfValid();\n     if (value == null) {\n         ((RealmObject) this).row.setNull(columnInfo.columnStringIndex);\n         return;\n    }\n    ((RealmObject) this).row.setString(columnInfo.columnStringIndex, value);\n}\n```\n\nThis should be refactored into `if`\/`else` clause.\n\n#### Expected Results\n```java\npublic void realmSet$columnString(String value) {\n     ((RealmObject) this).realm.checkIfValid();\n     if (value == null) {\n         ((RealmObject) this).row.setNull(columnInfo.columnStringIndex);\n     } else {\n         ((RealmObject) this).row.setString(columnInfo.columnStringIndex, value);\n     }\n}\n```\n\n#### Version of Realm and tooling\nRealm version(s):  0.88.3\n\nAndroid Studio version: 2.0\n\nWhich Android version and device: N\/A\n\n","comments":[],"labels":["T-Internal","Pipeline-Idea-Backlog"]},{"title":"Request: Document best practices for Android Backup service","body":"#### Goal\nRecent versions of Android now do full backups of any app created data by default.  This seems to include any realm databases and their associated working files. This does not seem like a recipe for success. It would be useful to have documentation on:\n\n* how to force a particular realm db to be ignored by Android backups (e.g. the \"read-only product catalogue scenario\") (_How I stumbled into this..._)\n* how to use Android's backup service to effectively backup a realm database\n\nE.g. see https:\/\/stackoverflow.com\/questions\/30804168\/what-does-it-mean-should-explicitly-set-androidfullbackupcontent-to-avoid-ba\/31984792 and https:\/\/github.com\/realm\/realm-java\/issues\/2552, which I came across when trying to solve this same problem (and then realized that it was even more complicated than I expected).\n\n","comments":["Yes, it sounds like something that would make sense to document as part of the website documentation\n","From https:\/\/developer.android.com\/guide\/topics\/data\/autobackup.html\r\n> During Auto Backup, the system shuts down the app to make sure it is no longer writing to the file system. By default, the backup system ignores apps that are running in the foreground because users would notice their apps being shut down. You can override the default behavior by setting the backupInForeground attribute to true.\r\n\r\nFrom the doc, if `backupInForeground` is true, Android auto backup could backup Realm file while the app is running. So there is chance it will restore a corrupted Realm file.\r\n\r\nneed to check the behaviour and doc this.","> android:backupInForeground\r\n> Indicates that Auto Backup operations may be performed on this app even if the app is in a foreground-equivalent state. The system shuts down an app during auto backup operation, so use this attribute with caution. Setting this flag to true can impact app behavior while the app is active. \r\n\r\nHmm, might be my misunderstanding. It should mean that if this is true, Android will force stop the app even when it is in foreground. If that is the case, then it is OK.","from #2603\r\n> While adding a section about `writeCopyTo` for the docs I started thinking about Google Play Services Backup\/Restore.\r\n\r\n> We should investigate how it actually works in detail. If it takes a backup of an open file or restore it overriding an existing file, it might explain some of the weird Illegal File errors we are seeing from time to time.\r\n\r\n> Also having it documened how it actually works also be beneficial.\r\n"],"labels":["T-Doc","O-Community"]},{"title":"List-of-Lists: RealmList<RealmList<?>>","body":"From http:\/\/stackoverflow.com\/questions\/36358347\/realm-object-and-deserialize-array-containing-arrays-with-integer-and-string-for\n\n`RealmList` should be able to represent a list-of-lists:\n\n```\n\/\/ 1 level deep\nRealmList<RealmList<? extends RealmObject>>\n\n\/\/ Also with arbitrary depth\nRealmList<RealmList<RealmList<? extends RealmObject>>>\n\n\/\/ Future: With the new RealmCollection API, ideally we should also be able to support any type of collection\nRealmList<OrderedRealmCollection<? extends RealmObject>> \n```","comments":["I don't know if it's just me, but a workaround using simple generics doesn't work either.\n\n```\nRealmList<RealmListAsObject<Category>> listInList = new RealmList<>();\n.\n.\n.\npublic class RealmListAsObject<T extends RealmObject> extends RealmObject {\n\n    private RealmList<T> objectList = new RealmList<>();\n\n    public RealmListAsObject(){\n\n    }\n\n    public T get(int pos){\n        return objectList.get(pos);\n    }\n\n    public void add(T object){\n        objectList.add(object);\n    }\n\n    public void remove(T object){\n        objectList.remove(object);\n    }\n\n    public void remove(int position){\n        objectList.remove(position);\n    }\n\n    public int size(){\n        return objectList.size();\n    }\n\n\n}\n```\n\nNote: Processing class RealmListAsObject\nFAILURE: Build failed with an exception.\n- What went wrong:\n  Execution failed for task ':mobile:compileDebugJavaWithJavac'.\n  > java.lang.NullPointerException\n\nBut after getting rid of the generics it works perfectly.\n"],"labels":["Blocked","T-Feature","Pipeline-Idea-Backlog"]},{"title":"Android Migration like Cocoa\/Swift","body":"Hi,\n\nI just have a request, \n\nwhy migration code is different from ios to android? in ios they just increasing the schema version and the altered table structure is updated automatically, but in android we have to write the migrate code for altered table as well as the schema version to be increased. Can u make in android too just increasing the schema number is able to alter the table? now its horrible to write migrate code for changes, and that too we have to make a track for what columns added, deleted and updated. Pls consider this..","comments":["Hi @bsmn99 \n\nIt is also an discussion we had internally and there are good arguments for both types of migrations. \n\nBe aware that the iOS migrations are not automatic in all cases and those corner cases are non-trivial to solve and will have to be maintained even for future migrations.\n\nThe Android migrations require more boilerplate code for sure, but they are write-once. After that you can forget about them and they will continue to work. Also we have plans for creating an IntelliJ plugin that can help with creating the migration code, making it less painful. \n\nNote that if you do not want to keep your data across schema changes, you can always use `RealmConfiguration.deleteRealmIfMigrationRequired()`. For some use cases like offline caches, that is a lot easier as you don't have to write any migration code.\n\nFor the current future we plan to let iOS and Android behave differently in this area. That also enable us to gather more realworld input about both approaches.\n","Hi @cmelchior \n\nThanks for the clarification, expecting that IntelliJ plugin!..\n","@cmelchior \n\n> _Be aware that the iOS migrations are not automatic in all cases and those corner cases are non-trivial to solve and will have to be maintained even for future migrations._\n\nCan u explain what kind of corner cases for iOS?\n","A couple of cases:\n\na) \nv1: Add new field `name`\nv2: Remove field `name`.\nv3: Add field `name` again. `name` should be empty here, not contain all the v1 data.\n\nb) \nv1: Add field `email`\nv2: Rename `email` to `contact`\nv3: Add field `email` again. This should now be empty while contact contains all the data\n\nA good way to think about is that iOS always go from `currentVersion -> latestVersion` skipping any intermediate calculations while Android always go `v1 -> v2 -> latestVersion`, which means that all steps are applied. So if you are changing the same field across multiple migrations on iOS you usually have to be a bit careful. This is also described in their docs btw: https:\/\/realm.io\/docs\/objc\/latest\/#linear-migrations\n","> For the current future we plan to let iOS and Android behave differently in this area.\r\n\r\n@cmelchior: As an app development company, we have to support of course both Android and iOS. Every difference between those two platforms makes our work much harder. Realm should make lives as a developer easier. Easier means less things to think about. So please decide on one way, but be consistent for all platforms.  ","One way to get around this could perhaps be to add two different RealmMigration interfaces:\r\n\r\n```\r\npublic interface RealmMigration {\r\n   public void migrate(DynamicRealm realm, long fromVersion, long toVersion);\r\n}\r\n\r\npublic interface RealmAutomaticMigration {\r\n  public void migrate(Migration migration, long fromVersion);\r\n}\r\n\r\npublic class Migration {\r\n  \/\/ Mimic Swift class: https:\/\/realm.io\/docs\/swift\/2.4.0\/api\/Classes\/Migration.html\r\n}\r\n\r\n\r\n```\r\n\r\nThat would allow us to support both ways of doing it without breaking existing support.","A lot of people seem to claim that \"automatic schema migration is something they miss in Realm\", so this is a good idea.","As a new Realm user, I can indeed confirm I was very surprised (and disappointed) to see this is necessary.  I was expecting some code to be needed for cases like adding\/removing fields in a model.  But the \"new models\" case should be automatic - after all, Realm knows everything that needs to be known about them!  \r\nAt least, could we need `schema.create(\"NewModel\")`, but not having to do all the `addField`? :) ","Is there any hint if this will be included in development for the near future versions?","You know, after having worked with SQLite as well this summer, in which case you need to bump the schema version and add the new columns and new tables as part of a migration; this behavior is pretty much exactly the same.","@davidgarciaanton We will probably add it at some point as a complementary way of doing migrations, but it does not have a very high priority so I cannot give you any timeframe.","Honestly, the real deviant here is the cocoa migration.\r\n\r\nI think .NET also has the DynamicRealm thing going on.","Ok @cmelchior good to know.\r\n\r\n@Zhuinden not sure what do you mean, do you suggest this is not a needed feature? Actually, the only thing I'm missing is auto-creation of *brand new entities* (for possibly big new additions to the Persisted data model). For any change on existing model classes current behaviour seems nice to me already.\r\n\r\nI'd only like to avoid some _boilerplate_ code creating a migration for a new entity (_from scratch_). See my StackOverflow question [here](https:\/\/stackoverflow.com\/q\/45483308\/5998142)","@davidgarciaanton I used to expect automatic migrations too, but once you start migrating SQLite databases you realize this is a necessary evil in any database.\r\n\r\nOtherwise, how will you define a migration from version 3 to version 5 in a reliable manner? Even for \"just new classes\", you end up with having to define additional fields between 4->5 and stuff.\r\n\r\nThat's why personally I'm not sure how one would simplify the needed boilerplate.\r\n\r\n--------\r\n\r\nTechnically Realm has a schema mode called \"additive\" when connected with a ROS, which is automatic, but that doesn't allow destructive operations on the schema. I think that is trickier.\r\n\r\n----\r\n\r\nWhat I'm saying is that this is not as much of a \"dealbreaker\" as some people tend to suggest: the other alternative requires the exact same steps to change the database, just with different syntax.","@Zhuinden I totally understand what you say, I'm only requesting some entry point that allows to create the whole entity with a single call within the migration itself. That's what I was using the family of `createRealmObjectSchema` methods for. \r\n\r\nI knew that I had some weird code within the migration, but in an ongoing project that required several new model classes to be added it payed the difference.\r\n\r\nI'm not the kind of person that likes magic behind the scenes for an _auto_ migration, but I'd like to have some public accessor to force entity creation.","@davidgarciaanton the problem with that is that later in the project it won't be fool proof. Let's say you add to schema in version 4, and you remove a field in version 5.\r\n\r\nAlthough I guess you *could* just put a \"if(has field)\" check before removing, and \"if(!has field)\" before adding. ","I just spent a day fighting with realm to migrate db and hitting issues in an app which used to use `deleteRealmIfMigrationRequired` before. \r\nNow after moving to migrate we had implement migration for users all the way to back to first release to support it.\r\n\r\n`addField` looked like a generic method that can work for every object; but turns out we have to use `addRealmObjectField` for Realm objects ;(\r\n\r\nBest part is there is was no auto update for a schema change which only added new fields.\r\n\r\nI guess we at-least need an option to to auto migrate on purely additive changes.","@davidgarciaanton and @AamirAbro \r\n\r\nI've put together this heavily experimental thing called [AutoMigration](https:\/\/github.com\/Zhuinden\/realm-helpers\/tree\/master\/realm-auto-migration), which removes the fields no longer in your models, and adds the fields that are in the models but not in the schema.\r\n\r\nPlease note the use of annotations that you need to apply, otherwise it won't work. Also it is experimental so not a library yet, because of how you need to add things like `@AutoMigration.MigratedField` essentially duplicating attributes (follow in https:\/\/github.com\/realm\/realm-java\/issues\/5344 )\r\n\r\nAlso worth noting that `rename` == `remove + add`, so you might want to apply your own migration logic first?\r\n\r\n**EDIT from 2020: Also, I don't even know if it handles all edge cases. I don't actually support this thing anymore. Beware.**","Thanks @Zhuinden I'll give it a try as soon as I have the opportunity.","@cmelchior Checking out this discussion, did the IntelliJ migration generator plugin ever materialize? I use Realm on iOS and indeed we find the auto-migrations there are the typical case (with well-designed data model evolution), and the lack of auto-migrations on Android are a lot less developer friendly. \r\n\r\n>Also we have plans for creating an IntelliJ plugin that can help with creating the migration code, making it less painful."],"labels":["T-Feature","Design-Required","O-Community","Pipeline-Idea-Backlog"]},{"title":"Integrate coveralls with CI","body":null,"comments":["@emanuelez Is this still relevant?","Yeah it needs to be done, but nowadays [codecov](https:\/\/codecov.io\/) seems to be the de-facto standard in the fields."],"labels":["T-Internal"]},{"title":"Support Maven","body":"Right now we only support Gradle as a build system as it is the official build system for Android. However some people still use other systems like Maven.\n\nGiven enough interest we should support Maven as well, but it is not without hurdles as we right now depend on the Transform API that as far as I know is only supported in Gradle.","comments":["What a lightning fast answer! :+1: Thanks a lot!\nI was just curious because we consider to move from gradle to maven at the moment to end all this gradle pain.\n","Maven also has it share of pains, just different ones :)\n","I'd rather have well documented maven pains shared by many other mavenmavens than be forced to use the build-system-du-jour. Really a pity that Realm Java now is not supported for the myriad of products and libraries that are maven based. Find a better solution. Supporting only gradle is wrong. Supporting a maven build artifact really opens realm to a much larger ecosystem. Which is right.\n","https:\/\/github.com\/icon-Systemhaus-GmbH\/javassist-maven-plugin this project might help, http:\/\/stackoverflow.com\/questions\/12423157\/integrating-javassist-byte-code-manipulation-with-maven-compilation\n","Hey, I am also checking out about does realm support maven ? [Here](http:\/\/stackoverflow.com\/questions\/40094632\/realm-support-maven-or-having-jar-of-its-latest-source) is my use case.\n","@cmelchior can you please help to figure out, how to support realm with sharable project lib models in android and java server projects? \n","@cmelchior now that Realm supports Linux (with RealmJS) and Win32 (with RealmJS), once https:\/\/github.com\/realm\/realm-java\/issues\/2339 is done, you also need to consider that most not-Android projects use Maven, not Gradle.","Sometimes we need to provide a jar to a third party, so the realm plugin does not support so that we can not use","Hi, any news?","Javassist seems to be supported with Maven, but I think the BytecodeTransformer was written in Groovy"],"labels":["T-Feature","Pipeline-Idea-Backlog"]},{"title":"Verify code samples compile in docs by CI","body":null,"comments":[],"labels":["T-Test","Pipeline-Idea-Backlog"]},{"title":"GROUP BY","body":"We should add support for GROUP BY. Not entirely sure about the API as you usually want to supply a aggregate function at the same time. Also the return type will be a bit tricky, as the data is a lot more dynamic (and DynamicRealmObject doesn't fit). If we had a Sorted RealmMap it might make sense, although exposing as a List would probably be the more expected.\n\n```\n\/\/ Brainstorm ideas\nRealmResults<Pair<String, Number>> results = query.groupBy(\"field\", Function.AVERAGE);\nRealmMap<String, Number> results = realmresult.groupBy(\"fieldName\", Function.SUM);\n```\n\nhttp:\/\/stackoverflow.com\/questions\/35533550\/is-it-possible-to-use-group-by-concept-in-realm-mobile-database","comments":["I think there are tow very distinct use cases here. One is grouping because you need the objects within each group (like in segmented view), and the other one is the aggregates, which is more of a pivot table functionality.\n\nThe pivot table functionality is actually likely to be the easiest to implement, as there already are native support for that in core.\n\nThe grouping is a bit more difficult, mostly because of the question of what you should return. The most natural would be a `RealmResults` containing a new type, composed of the value being grouped on and a `RealmList` of the matching objects. This would either have to be accessed with the dynamic API, or the user should predeclare a matching type:\n\n``` java\npublic class PersonGroupByAge extends RealmObject {\n    private int age;\n    private RealmList<Person> persons;\n}\n\nRealmResults< PersonGroupByAge > ages = realm.where(Person.class).groupBy(\"age\").findAll();\n```\n"],"labels":["T-Feature","Design-Required","Pipeline-On-Hold"]},{"title":"sort by columns with CASE_INSENSITIVE","body":"Is there a way to sort by columns with case sensitive or case insensitive?\n\nex)\n\n```\nrealm.where(MyTable.class)\n    .equalTo(\"column1\", \"value1\")\n    .findAllSorted(\"column2\", Sort.ASCENDING, CASE.SENSITIVE);\n```\n\nif no, I hope this function with non-ASCII strongly :)","comments":["Unfortunately sorting with case insensitive is not supported right now :(\n","@beeender Is there any good workaround you could suggest for this? i.e., some way to make the values all upper-\/lower-case before the sort happens (but not persist that change to the actual objects)?\n\nMy only idea was storing an extra copy of such fields that I'd converted to all lower-case, but that seemed like overkill just to provide case-insensitive sorting, so I figured I'd ask.\n","> My only idea was storing an extra copy of such fields that I'd converted to all lower-case, but that seemed like overkill just to provide case-insensitive sorting, so I figured I'd ask.\n\n@bkromhout Yeah, this is what comes to my mind as well... I don't have other better workaround right now...\n","That's fine, I've implemented it that way and it works, just have to remember to update that extra sort field if I update the real one.\n","Have there been any updates to this issue?"],"labels":["T-Enhancement","O-Community"]},{"title":"Ignored fields list for copyToRealmOrUpdate","body":"User case from SO:\nhttp:\/\/stackoverflow.com\/questions\/35244823\/realm-for-android-how-to-sync-server-data-to-realm-database\n\nIf one field is stored locally, it would be convenient to ignore the local field while updating the existing RealmObject.\n\nAPI proposal:\n\n```\npublic <E extends RealmObject> E copyToRealmOrUpdate(E object, String... ignoredFields)\n```","comments":["It also could be something like creating a separate class that contains only the fields needed for the update and maybe it could be annotated something like `@RealmUpdate(City.class)` to point out what class it updates. Though sometimes this would require morphing some objects like `City` to `CityUpdate`, etc.. Ignored fields would ease a lot of update logic.\n","IMO this could probably be solved more elegantly be a new annotation like `@LocalField` or similar. \n\n```\npublic class Foo extends RealmObject {\n\n  @PrimaryKey \n  private long id;\n\n  private String name;\n\n  @LocalField \n  private boolean isDirty;\n}\n```\n\nThis would enable our annotation processor to just remove the code from our proxy classes instead of having users specifying the field each time. The above of course depends on the assumption that you only use `copyToRealm` when working with the network layer. I suspect that assumption is OK, but it needs to be validated.\n","Would the `@LocalField` be ignored from updates but still saved to database? it would help where data is not synced, like user favorites, etc.. but how would it help with explicit updates? e.g. the first time I download the whole `Foo` list and want everything to be created, then, I already have a full `Foo` list, give me only a list of `id` and `enabled` columns, so I can update it on my side. I would like to use `copyToRealmOrUpdate` on the list and have only the enabled column updated (let's not get into details how something like updateIfExists would be better :) ). I don't think this would let you include\\exclude the field when needed.\n","@donnysim Your right. My proposal would not allow different behaviour in two different code paths, so if that is a use case then it won't work. Note we already have an issue for `createIfNotExists`: #900 \n\nIt is slightly different than only updating some fields though.\n","@cmelchior Though `@LocalField` would still be useful if it does save to database :D\n","Yes, it is a fine balance. Trying to make first-class support for all these ways of updating can increase the complexity of the API quite quickly.\n","This is related to the issue #2179 I opened. I see 2 use-cases (both of them I am currently facing and solving via inconvenient helper methods):\n1. To be able to create specific local fields that are never updated via copyToRealmOrUpdate. In this case, the proposed `@LocalField` can work.\n2. To be able to partially update a model explicitly specifying fields. E.g. i have \"compact\" models coming from some endpoints and \"extended\" models coming from others (think of extended user model with tons of information vs a tiny user model with username and avatar to include in other objects like posts and replies). Problem i faced is that saving \"compact\" models using copyToRealmOrUpdate() will destroy all the information  already saved in \"extended\" models. In this case `@LocalField` approach is not enough. Via annotations, i can thing of something like `@DontOverwriteIfNull` but as we discussed in other issues, null sometimes can be a desired value. I like the proposed `public <E extends RealmObject> E copyToRealmOrUpdate(E object, String... ignoredFields)`\n","Thanks for the reminder @guillermomuntaner . I will merge the two issues so we only have the discussion in one place.\n\nCopy paste from #2179 \n\n---\n\n### Feature request:\n\n**Partial updates**\n\n### How?\n\nRelated to issue #1853 \nI agree that only updating not-null values is not a correct approach, since null can be sometimes a desired value and also because of not nullable primitive types with default values.\n\nBut, what about a call to specify a list of the fields that one want to overwrite (or preserve)?\n`copyToRealmOrUpdateOverwritingFields(\"field1\",\"field2\")`\n`copyToRealmOrUpdatePreservingFields(\"field1\",\"field2\")`\n`copyToRealmOrUpdate(obj).preserve(\"field1\",\"field2\")`\n\nIn case the object does not exist in realm, the \"fields to be preserved\" can be initialized with default values, which i think is quite solid from a design pov.\n\nThoughts on this?\n\n### My issue scenario:\n\nIm doing a cache with Realm where objects from one class can be updated online or locally based on user interaction. This is a problem, because every single online update using copyToRealmOrUpdate() will overwrite all the local updates which i would like to keep. The option to use json would work for me, but since im dealing with complex json and doing custom deserialization plus other manipulations in order to get the POJO i am storing, having to serialize to Json just to update feels a bit excessive. \n\nAs reference found also other related issue with a scenario like mine #1540\n","Interesting use case with a REST API that provides both compact \/ extended models. It does make sense though.\n\nWouldn't inheritance solve this quite elegantly though?\n\n```\npublic class ExtendedFoo extends SimpleFoo {\n  private Date birthday;\n}\n\npublic class SimpleFoo extends RealmObject {\n  @PrimaryKey\n  private long id;\n  private String name;\n  private String avatar;\n}\n\n\/\/ Option A) Automatically ignore any sub type properties\n<E extends RealmObject> copyToRealmOrUpdate(E object);\nrealm.copyToRealmOrUpdate(simpleFoo); \/\/ Ignores all fields in ExtendedFoo\n\n\/\/ Option B) Provide a boolean for controlling it \n<E extends RealmObject> copyToRealmOrUpdate(E object, boolean ignoreSubTypeFields);\nrealm.copyToRealmOrUpdate(simpleFoo, true); \/\/ Ignores all fields in ExtendedFoo\n```\n\nSomehow having to maintain a list of fields to ignore just seems very manual and very error prone to me, so brainstorming a bit for other ideas.\n","@cmelchior At first the idea looked great and elegant to me, but after thinking a bit I don't get how inherited models would be stored. The optimal way would be to store the \"expanded\" model and cast to \"compact\" models, but this does not fit well with inheritance nature, where several \"expanded\" models can exist.\n- Models can have several \"compact\" submodels. One model lead to several smaller and uncomplete models.\n- Classes can have several inherited subclases. On class lead to several expanded classes.\n\nThus, the proper way to handle your inheritance proposal would be to store base class info in one table and extended models info into another table and be able to merge to produce final objects. Not sure if Realm is capable of it.\n\nActually im doing something similar to this idea manually, but it would be nice to access parent class properties directly by inheritance.\n\n```\npublic class ExtendedFoo extends RealmObject {\n  private Date birthday;\n  private SimpleFoo simpleFoo;\n}\n\npublic class SimpleFoo extends RealmObject {\n  @PrimaryKey\n  private long id;\n  private String name;\n  private String avatar;\n}\n```\n","I am currently using 2 classes, one is a small compact model, and the other contains extended info with id to the compact one. I don't really like this way, you constantly have to think about two classes. If you add a link from compact to extended model, then updating compact will still remove that link and removing that compact entry will leave extended info floating around, so it still provides more work than is really necessary. I liked how in one SQL ORM I just create a new compact and extended\/update class and just point to the same table.\n","@donnysim Indeed I faced same linkage issues. I ended up doing 1 big class and helper method to partialy update. What i am doing now to update is just manually searching if the object already exists and update only specific fields:\n\n```\nClass1 object = customWayToGetANonRealmObject();\nClass1 realmObject = instance.where(Class1.class).equalTo(\"id\",object.getId()).findFirst();\nif(realmObject!=null) {\n    \/\/ Write possible updated fields\n    realmObject.setField1(object.getField1());\n    realmObject.setField2(object.getField2());\n    .... \n}\nelse {\n    \/\/If object not found in realm, just copy it.\n    realmObject = instance.copyToRealm(object);\n}\n```\n\nAnd what i would like to do is something as proposed:\n`realmObject = instance. copyToRealmOrUpdate(object,\"field1\",\"field2\");`\n\n@cmelchior Another advantage of field name lists vs using subclasses is that you can dynamically adjust them. Think of APIs with more than 1 \"compact\" version or with dynamic fields, like the Facebook Api where you can set the specific fields you want returned. I agree that using field names as strings is error prone, but currently this is how the query filtering and sorting works in Realm too.\n","I also have similar issues with copyToRealmOrUpdate and relations. The idea is this: I fetch data from server which contains relationship information as a primary key:\n\n```\n{\n\"id\": 1,\n\"relatedObject\": 101\n}\n\npublic class Item extends RealmObject {\n    @PrimaryKey private int id;\n    private RelatedObject relatedObject;\n}\n```\n\nAnd I already have related objects stored locally. So when I call copyToRealmOrUpdate I get empty related objects (i.e. only PK is stored, all other fields become nulls).\n\nAs a workaround I use \"raw\" POJOs to decode for Retrofit and then manually process them, establishing relations and creating\/updating RealmObjects from those POJOs. It's very annoying and introduces a lot of boilerplate code.\n\nSo, how about an option to turn off _deep copying_, i.e. `copyToRealmOrUpdate(object, deep=false)`?\n\nI mean, we're on mobile, so sending full relationship objects with each data update via network is very unhealthy.\n\n**Note**: it's different from just ignoring some fields, because I can obviously receive relationship update (i.e. different PK) which must be reflected locally.\n","It is very important to support partial update.\r\n```Java\r\ncopyToRealmOrUpdate(T extends RealmObject item);\/\/ this function is exist in current realm\r\ncopyToRealmOrUpdate(T extends RealmObject item, String... ignoredFields);\r\ncopyToRealmOrUpdate(List<T extends RealmObject> list, String... ignoredFields);\r\n```\r\n\r\nexample:\r\nThis object need fetch from remote server by JSON(it is not designed by me, so I don't know how many all fields is):\r\n```Java\r\npublic class Dog {\r\n    private String name;\r\n    private int age;\r\n    ... \/\/ other fields\r\n    \/\/ ... Generated getters and setters ...\r\n}\r\n```\r\n\r\nthen, I create an object like this:\r\n```Java\r\npublic class Dog extends RealmObject {\r\n    @PrimaryKey\r\n    private String name;\r\n    private int age;\r\n    private int localCage;\/\/ this is local field to store dog's cage number  :)\r\n    \/\/ ... Generated getters and setters ...\r\n}\r\n```\r\n\r\nfetching json objects and save to realm:\r\n```JSON\r\n[{\"name\":\"John\",\"age\":3},{\"name\":\"Peter\",\"age\":2},{...}...]\r\n\/\/ all localCage was set to 0(default value) by using Gson.fromJson(json....)\r\n\/\/ copyToRealmOrUpdate(List<Dog> list)\r\n```\r\n\r\nuser can rest dog's cage like this:\r\n```JSON\r\n{\"name\":\"John\",\"age\":3,\"localCage\":6}\r\n```\r\n\r\nThe problem is: when user fetching dogs list again(ex. using SwipeRefreshLayout\/RecyclerView), all local fields are reset to 0(by using copyToRealmOrUpdate(List<Dog> list);). because that remote json has no  field named \"localCage\", the local fields will be set to default value(integer type will set to 0, boolean type will set to false, string type will set to null.....)\r\n```Java\r\n\/\/ JSON is not include field \"localCage\", so all dogs field \"localCage\" will be set to 0 at this line.\r\nList<Dog> dogs = gson.fromJson(jsonString, new TypeToken<List<Dog>>() {}.getType());\r\n\/\/ realm.copyToRealmOrUpdate(dogs);\/\/ this place cannot use copyToRealmOrUpdate(dogs)\r\nrealm.copyToRealmOrUpdate(dogs, \"localCage\");\/\/ good, we will not change field \"localCage\" this time\r\n```\r\n\r\nin current realm, I doing this to avoid loss local fields value;\r\n```Java\r\nList<Dog> dogs = gson.fromJson(json, new TypeToken<List<Dog>>() {\r\n}.getType());\r\nfor(Dog dog : dogs){\r\n    Dog exist = getDogFromRealm(dog.getName());\/\/ realm.where(Dog.class).equal.......\r\n    if (null != exist) {\r\n        dog.setLocalCage(exist.getLocalCage());\r\n        \/\/ ... other local fields\r\n        \/\/ this place decided by your local fields, \r\n        \/\/ if local fields less than remote json object, use unmanaged object,\r\n        \/\/ otherwise, use managed object. \r\n        \/\/ if it has dozens local fields and remote fields, GOD, it's hard to say\r\n    }\r\n}\r\nrealm.copyToRealmOrUpdate(dogs);\r\n```\r\n\r\nOther way to fix it?\r\n```Java\r\npublic class Dog extends RealmObject {\r\n    @PrimaryKey\r\n    private String name;\r\n    private int age;\r\n    @Ignore \/\/ or @LocalField ???(@LocalField is not support yet)\r\n    private int localCage;\r\n}\r\n```","@HsiangLeekwok \r\n\r\nAlthough i consider it a hack, along with any realm implementation at this point, i use the following method to 'update' an object.\r\n\r\n```java\r\n\r\npublic void updateUser(Realm realm, String userAsJson){\r\n    realm.executeTransaction(realm1 -> realm1.createOrUpdateAllFromJson(User.class, userAsJson));\r\n}\r\n\r\n```\r\n\r\n**[createOrUpdateAllFromJson](https:\/\/realm.io\/docs\/java\/latest\/api\/io\/realm\/Realm.html#createOrUpdateAllFromJson-java.lang.Class-java.io.InputStream-)** will basically update the object while it ignores null values\r\n\r\nNow what happens if you use custom serializers\/deserializers while parsing.\r\nFor example\r\n**RealmList\\<RealmString\\>** needs custom deserialization since realm can't handle a list of primitive values.\r\n\r\nWell, in that case you do something like this:\r\n```java\r\npublic void updateUser(Realm realm, String userAsJson){\r\n    User user = gson.fromJson(userAsJson, User.class); \/\/ gson that runs custom deserialization\r\n    String deserializedUserAsJson = gson.toJson(user); \/\/ now we can insert user into realm without issues\r\n    realm.executeTransaction(realm1 -> realm1.createOrUpdateAllFromJson(User.class, deserializedUserAsJson));\r\n}\r\n```\r\n\r\nA nice solution from the realm team would be one or all of the following:\r\n\r\n- Gson uses [**TypeAdapter** & **TypeAdapterFactory**](https:\/\/google.github.io\/gson\/apidocs\/com\/google\/gson\/TypeAdapter.html) to customize serialization\/deserialization behaviour, introduce something similar. This would basically allow us to write custom rules when inserting\/retrieving data from realm.\r\n- Allow realm to update objects, while ignoring null values from the updating source","Great! Thanks! Helpful! @ArthurSav \r\n\r\nSorry, I haven't read the realm documents carefully than you, I never use _createOrUpdateAllFromJson_ yet :)\r\n\r\nCheck myself....","Are there any plans to implement this, or is the official solution to use `createOrUpdateAllFromJson`?","The official solution is only set the fields on the managed object what you want persisted, instead of just overwriting the currently existing one.","@Zhuinden does that mean I'm not going to be able to use `insertOrUpdate`? That would be a pretty big performance hit.\r\n\r\nUse case is I get a model from the network, and I automatically store it in realm. Now I would have to check to see if it's already in realm, and if it is, only update the fields I want. Otherwise, create a new object. Is that correct?","``` java\r\nMyObj obj = realm.where(MyObj.class).where(\"id\", id).findFirst();\r\nif(obj == null) {\r\n    obj = realm.createObject(MyObj.class, id); \/\/ or realm.copyToRealmOrUpdate(unmanagedObj);\r\n}\r\n\/\/ ... set things up\r\n```\r\n\r\nYou can't really tell the difference for if a field should be set to null, or if it is \"not set\". So Realm defaults to that if your object has `null` set as value, then it will be set as `null`.","I don't think `createOrUpdateAllFromJson` is an acceptable solution, I feel this completely breaks any implementation of retrofit + converters (for example) in your network layer, as is my case. I can't use retrofit 2.0 and moshi to deserialize  json objects into model classes i can work with, if I am forced to use `createOrUpdateAllFromJson`. Otherwise we have to hard code so many things. ","Any update on this ? \r\n\r\nIt's been almost a year I'm waiting for this improvement. \r\n\r\nI always optimise my API calls for a quick and fast browsing in apps, but because of this limitation, the API has to fetch full data for every items called, otherwise the user would lose its \"cache\" every time he gets back on the main activity (which is querying the \"lightweight\" api). ","We are not going to implement an ignore list of fields. Our JSON methods already support partial updates, so you can use those if you want. Also, there are a number of other features on our roadmap that would be better suited for this without inflating our API surface and complicate our existing `copyToRealm` methods considerably.\r\n\r\n1) Inheritance ( #761 ) -> `FullClass extends PartialClass`\r\n2) Support for @SerializableName or similar ( #2476 ) to allow our JSON methods to be used more easily.\r\n\r\nI completely understand why you would want to Use Retrofit\/GSON, but there is something fundamentally wrong if you first want to deserialize a \"partial\" object into the \"full\" Java definition and then expect other layers of your application to understand that the object isn't what it claims to be. \r\n\r\nWe do realize the experience can be frustrating right now as you are basically forced to implement the partial update yourself and we do hope to improve on the situation, but it will not be as an \"ignore\" list.\r\n\r\n","If it is a partial object, then you're the only one who knows which fields are meant to exist and which do not exist in the partial object.","@Zhuinden Not really, if the collection is null, it means it hasn't been set by retrofit (and thus, it shouldn't change anything in Realm). If the collection is empty is means it has been set by retrofit and then it should erase that in Realm. \r\n\r\nAm I missing something that makes it so hard to implement ? I'm by no mean a DB expert","@NinoDLC collection sure, other fields (string, date, etc.) definitely not. Even then whether `null == empty collection` is up for interpretation. The official answer was [above my answer](https:\/\/github.com\/realm\/realm-java\/issues\/2288#issuecomment-324175605)","@cmelchior @beeender while watching [this video](https:\/\/youtu.be\/ZTzg6lOgYiI?t=10m27s) I was kinda wondering - while you can't really use an `ignore fields exclusion list` because Proguard can eat your model class (unless you use the original field name during annotation processing, I guess) ~ I was wondering about an easier option\r\n\r\n    realm.insertOrUpdate(item); \/\/ persists nulls by default\r\n    realm.insertOrUpdate(item, true); \/\/ true being the default, \"persist nulls\"\r\n    realm.insertOrUpdate(item, false); \/\/ ignores null values\r\n\r\nThat way it's actually +1 method for `realm.insertOrUpdate` and I'm guessing +1 for each proxy, which is okay, and not that complex?\r\n\r\nIs this a bad idea? It's 2 AM, I might be full of terrible ideas.","> while you can't really use an ignore fields exclusion list because Proguard can eat your model class (unless you use the original field name during annotation processing, I guess) \r\n\r\nYes, proguard is a problem, we have it for the class name as well. The proxy will generate a map of `Class` to the realm name by annotation processor, and we access the map on runtime through https:\/\/github.com\/realm\/realm-java\/blob\/master\/realm\/realm-library\/src\/main\/java\/io\/realm\/internal\/RealmProxyMediator.java#L78\r\n\r\nOr maybe the API could be more generic to have even more flexibility:\r\n\r\n```java\r\ninterface RealmInsertionFilter<T extends RealmModel> {\r\n    boolean shouldInsert(T objectToBeInserted, String fieldName);\r\n}\r\n\r\nRealmInsertionFilter insertionFilter = new RealmInsertionFilter() {\r\n    boolean shouldInsert(Foo foo, String fieldName) {\r\n        if (fieldName.equals(\"noPersist\")) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nrealm.insertOrUpdate(item, insertionFilter);\r\n```","I think the filter parameter is overkill, people seem to just want to be able to ignore null values, lol.\r\n\r\nAlthough I guess \r\n\r\n``` java\r\nRealmInsertionFilter insertionFilter = new RealmInsertionFilter() {\r\n    boolean shouldInsert(Foo foo, String fieldName) {\r\n        if (foo == null) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\nwould work, too!\r\n\r\n----\r\n\r\nEDIT: wait a second, this would work only with reflection. Am I blind? a `fieldValue` parameter would be nice. Maybe `oldValue`, `newValue`","Just to let you know I am migrating to Room due to this feature.So much boilerplate code I need to write for this implementation.","@asbadve I'm pretty sure Room handles partial updates the same way if you use conflict resolution strategy REPLACE.","@Zhuinden I am having a specific reason for partial updates not because of null values. I am having some extra field in pojo than the web API which I want to maintain at the client side. Every time I need to get those value from DB before updating of the whole pojo and then based on that then I updated the value in DB. Which is a lot of boilerplate code and plus use Gson and retrofit2 so there is no point in converting pojo to json and then update.","@asbadve so how exactly will Room help with this? `@UPDATE` statement for each property?","@Zhuinden not with @UPDATE statement but with @QUERY . And I know that I need to mention all the fields in it but it only for once in Dao. \r\nI know that can also be achieved using realm with repository pattern.","Any Update on this or was it decided to use `createOrUpdateAllFromJson`. If there are any other ways can anyone explain as I'm also using retrofit\r\nCheers","@ismdcf `findFirst()\/createObject()` and then set the expected fields ","5 Years afterwards and it's not implemented, any chance to get such feature?"],"labels":["T-Enhancement","Design-Required"]},{"title":"Roboelectric support for Windows & Linux","body":null,"comments":[],"labels":["T-Feature"]},{"title":"Cache referenced RealmObject in proxy classes","body":"Currently we cache constructed RealmLists in the proxy, so we don't keep creating new ones:\n\n```\n        \/\/ use the cached value if available\n        if (columnRealmListRealmList != null) {\n            return columnRealmListRealmList;\n        } else {\n            LinkView linkView = row.getLinkList(columnInfo.columnRealmListIndex);\n            columnRealmListRealmList = new RealmList<Dog>(Dog.class, linkView, realm);\n            return columnRealmListRealmList;\n        }\n```\n\nWe should do the same for referenced single objects, which are currently created on each access:\n\n```\n        realm.checkIfValid();\n        if (row.isNullLink(columnInfo.columnRealmObjectIndex)) {\n            return null;\n        }\n        return realm.get(io.realm.entities.Dog.class, row.getLink(columnInfo.columnRealmObjectIndex));\n```\n\nThere might be some corner cases regarding accessing deleted objects though.\n\n","comments":[],"labels":["T-Internal"]},{"title":"Optimize copyToRealm \/ copyToRealmOrUpdate","body":"It doesn't happen on genymotion, only on a physical Android device.\n\nFrom my logs:\n\n```\nBenchmark realm clear: 73ms\nBenchmark realm create 1183 objects: 398ms\nBenchmark realm remote: 642ms\nBenchmark realm local clear: 0ms\nBenchmark realm local create: 11ms\nBenchmark realm local: 26ms\nBenchmark card listener: 20025ms\n```\n\nAs you can see, the actual calls to clear existing objects, and then even construct and copy the new objects, take around 1s. Then it churns for anywhere from 20-45(!!!!!) seconds on a lot of ART gc calls.\n\nWe were ready to ship to production and now we may have to scrap a week's worth of work, please advise.\n\nIncluding the top level RealmObject description below. Note that there are mutiple possible sub-objects that are declared inside the top level. It should only ever actually contain one of them.\n\n```kotlin\n@RealmClass\nopen class DisplayCard() : RealmObject() {\n\n    @PrimaryKey\n    open var id: String = \"\"\n\n    open var sort: Long = 0L\n    open var typeOrdinal: Int = 0\n    open var dismissible: Boolean = false\n    open var local: Boolean = false\n    open var protoBytes: ByteArray? = null\n    open var data: ByteArray? = null \/\/ Currently only used for CardOptions class\/proto\n    open var relevantTids: RealmList<RealmString> = RealmList()\n    open var relevantBids: RealmList<RealmString> = RealmList()\n\n    \/\/ Sub Cards\n    open var normie: DisplayCardNormie? = null\n    open var recur: DisplayCardRecur? = null\n    open var track: DisplayCardTracker? = null\n    open var transfer : DisplayCardTransfer? = null\n    open var suggestedBucket: DisplayCardSuggest? = null\n    open var suggestedExisting: DisplayCardSuggestExisting? = null\n    open var text: DisplayCardText? = null\n    open var adjust: DisplayCardAdjust? = null\n    open var newMonth: DisplayCardNewMonth? = null\n    open var link: DisplayCardLink? = null\n    open var explainer: DisplayCardExplainer? = null\n}\n```\n\n","comments":["Hi @asarazan \nSorry to hear that. That amount of GC sounds really strange though. Can you share a sample project that reproduces this? and can you share the details of exactly what device you where testing on?\n","I'm testing on a Nexus 5X running stock Marshmallow. If you give me an email address I'm happy to send you a full list of class definitions and my allocation capture file.\n","Thank you. You can send it to help@realm.io\n","Sent.\n","It's possible that this is specific to Marshmallow's implementation of ART. It doesn't appear to happen on our lollipop samsung devices. About to test on a Lollipop Sony.\n\nEdit: Eh still 20 seconds on a Lollipop Z3 Compact\n","Did some testing with the following unit test (using classes from out unit test suite)\n\n```\n        List<OwnerPrimaryKey> owners = new ArrayList<>();\n\n        for (int i = 0; i < 10000; i++) {\n            OwnerPrimaryKey owner = new OwnerPrimaryKey(i + 1, \"Owner:\" + i);\n            owner.setDogs(new RealmList<Dog>());\n            DogPrimaryKey dogPk = new DogPrimaryKey(i + 10000, \"Dog\");\n            owner.setDog(dogPk);\n\n            for (int j = 0; j < 10; j++) {\n                Dog dog = new Dog(\"Dog\" + i + \" - \" + j);\n                owner.getDogs().add(dog);\n            }\n\n            owners.add(owner);\n\n        realm.beginTransaction();\n        long start = System.currentTimeMillis();\n        realm.copyToRealmOrUpdate(owners);\n        long end = System.currentTimeMillis();\n        Log.e(\"Bench\", \"copyToRealmOrUpdate_manyObjects: \" + (end - start));\n        realm.commitTransaction();\n```\n\nIt takes about 27 seconds to insert 100.000 objects on my Nexus 7 (6.0.1) and about 1.7 seconds on a Genymotion x86 emulator. The change seems to be linear though as 10.000 objects take about 2.7 seconds.\n\n@asarazan Do you know how many objects in total you are importing, also including referenced objects. You main model reference at least to RealmLists so I'm guessing it is a potentially quite large set?\n","Digging further into this, it doesn't look like it's a bug. The amount of GC is actually very small, so this is a function of a relatively slow `copyOrUpdate` method that does a lot of things that could be optimised. In no prioritised order:\n- Avoid allocating RealmObjects that are not returned to the user (beyond depth 0)\n- Adding elements to RealmLists adds a big overhead in terms of additional checks.\n- Disable thread check while inserting objects.\n- Consider a `copyOrUpdate` method that doesn't return any objects. That way we can remove allocations for depth 0 as well. \n- See also https:\/\/github.com\/realm\/realm-java\/issues\/1684\n\nThis also means that there currently is no easy work-around. Some suggestions could be:\n\n1) Prepare realm files that can be downloaded instead of doing it on the device.\n2) Use `createOrUpdateUsingJson*` methods to skip intermediate steps.\n","Hey Christian, thanks for looking so deeply into this. Regarding your\nprevious question, I did an object count a couple days ago and I think it\nwas around 4,300 total. \nOver the weekend, I've been attempting to find workarounds-- non-blocking\nsmall-batch processing, null instead of empty realmlists, etc. I came away\nwith roughly unchanged results.\n\nSince it seems like my use case isn't well supported at the moment, and we\ndon't use json in our Android app, I'll probably just roll back to our old\ncursor structure from before the refactor.\n\nThanks for all your help!\n","No problem, and sorry I didn't have a better answer to this.\n","```\npublic <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects) {\n        if (objects == null) {\n            return new ArrayList<E>(0);\n        }\n        ArrayList<E> realmObjects = new ArrayList<E>();\n        for (E object : objects) {\n            realmObjects.add(copyToRealmOrUpdate(object));\n        }\n        return realmObjects;\n    }\n```\n\n@cmelchior I can't find any method that returns `void` instead of a collection. I just want to add all objects into realm but I don't want return any objects. I think it's better and faster for my case. Do you have any idea?\n","@thuat26 No such method exists currently. This will most likely come as part of of #1684 . For now I would just ignore the returned collection.\n","This was released in v1.1.0\n","Both yes and no. `insertOrUpdate()` could be optimized to a much larger degree than `copyToRealm` ever could be, at the expense of returning `void`. We still have room to optimize `copyToRealm()`, but it probably has a lot lower priority now.\n","I used copyToRealmOrUpdate, but changed it to insertOrUpdate as per this thread. However, the Items I want to insert have a two way releation. In the case of copyToRealmOrUpdate it works, but the insertOrUpdate results in a stackoverflow error. Do I have to use copyToRealmOrUpdate if I have bidirectional relations in the object I want to insert?\n","You would need to insert them with `copyToRealmOrUpdate` in order to receive a managed proxy that you can use to set each other as each other's links\n\n(but it's worth noting that you shouldn't get `stack overflow error` anywhere, so that's a bug)\n","@sipersso It could be a bug. Could you create an separate issue with code to reproduce it?\n","@Zhuinden I don't understand. The objects I try to insert already have their relations set, although they were set in a separate realm file. copyOrUpdate works just fine and sets the relations correct. It's just a little slow.\n\n@cmelchior Sure, I'll see if I can set up a simple example to reproduce it.\n","I created a separate issue for the StackOverflowError at https:\/\/github.com\/realm\/realm-java\/issues\/3732\n"],"labels":["T-Internal","O-Community","Pipeline-Idea-Backlog"]},{"title":"RealmResults.collect()","body":"Sometimes you really want to get some other objects than the one you are querying. Example from link queries:\n- I want to find all Persons with a dog that is brown and called Fluffy.\n\nThat is currently only possible when querying Persons:\n\n```\nRealmResults<Owner> r2 = realm.where(Owner.class)\n.equalTo(\"dogs.name\", \"Fluffy\")\n.findAll()\n.where()\n.equalTo(\"dogs.color\", \"Brown\")\n.findAll();\n```\n\nWith a `collect` operator you could do instead:\n\n```\nRealmResults<Owner> = realm.where(Dog.class)\n  .equalTo(\"name\", \"Fluffy\")\n  .equalTo(\"color\", \"Brown\")\n  .findAll()\n  .collectAll(Owner.class, \"owner\") \/\/ Dog needs a owner field\n```\n\nOverriding `findAll` could also be an option, although I probably like the `collect` operator more as it is also a well known functional method.\n\n```\nRealmResults<Owner> = realm.where(Owner.class)\n  .equalTo(\"name\", \"Fluffy\")\n  .equalTo(\"color\", \"Brown\")\n  .findAll(Owner.class, \"owner);\n```\n\nWhat do you think @realm\/java \n\nEDIT: Or maybe the above is just a symptom that the current query language are missing some features since `findAll` already is a collect statement, so we should fix that instead.","comments":["The case you present can be solved by back links (#607) that is, `collectAll()` is close to be the same. \n\nAnother case is to concatenate `RealmResults`. If you wish to find all dogs who have an owner named Pete, you will have to do:\n\n```\nRealmResults<Owner> owners = realm.where(Owner.class).equalTo(\"name\", \"Pete\").findAll();\nfor (Owner owner : owners) {\n    RealmList<Dog> dogs = owner.getDogs();\n    for (Dog dog : dogs) {\n        \/\/ access dog's fields\n    }\n}\n```\n\nWith `collectAll()`, it could be possible to write\n\n```\nRealmResults<Dog> dogs = realm.where(Owner.class).equalTo(\"name\", \"Pete\").findAll().collectAll(Dog.class, \"dogs\");\nfor (Dog dog : dogs) {\n    \/\/ access dog's fields\n}\n```\n\nIn short: I like it!\n","Another example of how useful this could be: https:\/\/stackoverflow.com\/questions\/45529557\/realm-querying-with-two-conditions-at-the-same-time\/45659934#45659934"],"labels":["Blocked","T-Feature","Pipeline-Idea-Backlog"]},{"title":"Use Realm.executeTransaction() in examples.","body":"We should update our examples to use `Realm.executeTransaction()` as that ensures they are correctly canceled if something goes wrong. We should also stress in our documentation that `cancelTransaction` has to be canceled if doing a manual transaction:\n\n* [ ] Update examples to use `Realm.executeTransaction()`\n* [ ] Ensure that the website doc recommends using executeTransaction\n* [ ] Make sure that we stress in the Javadoc that `cancelTransaction` is required in case of failures.\n\n","comments":["@cmelchior is there any way I can somehow do \n\n> Ensure that the website doc recommends using executeTransaction\n\n? \n\nIt really bugs me that the docs says `beginTransaction()` and `commitTransaction()` in almost all of its basic examples even though the approach is very error-prone in case of error.\n","I cited the [main site example from Realm.io](http:\/\/realm.io) in [my article on common Realm mistakes](https:\/\/medium.com\/@Zhuinden\/how-to-use-realm-for-android-like-a-champ-and-how-to-tell-if-youre-doing-it-wrong-ac4f66b7f149#.kazb8rauo) for being a bad example (I didn't specify it's from there, but it's from there).\n"],"labels":["T-Doc"]},{"title":"Reenable `between()` for link queries","body":"Realm core 0.96.0 has an implementation of `between()` for link queries.","comments":["So how can I retrieve data from Item table based on date which is store in Record Table .. \r\nIs any logic help to solve this issue.. Please help me..Thank you,","If your `Item` has a `Record record;` field, then you can use `lowerThan` and `greaterThan` with a link query\r\n\r\n    realm.where(Item.class).greaterThan(\"record.date\", someDate).lessThan(...).findAll();","@Zhuinden \r\n**realm.where(Item.class).greaterThanOrEqualTo(\"record.date\",beforeDate).lessThanOrEqualTo(\"record.date\",curDate).findAll();**\r\n\r\nIts not worked..  i have tried lot..please help..","Please define \"not worked\", I do not know what went wrong. \ud83d\ude15 ","getting RealmList size zero.. though it has records to display..","you mean `RealmResults`\u02d9?","yes..please help..","@dtmandroid At first, link queries often don't work as excepted. The reason is that a link query returns a parent object if at least one child object is meeting the query condition. We have documented this behaviour in https:\/\/realm.io\/docs\/java\/latest\/#link-queries. Rewriting `between()` and `greaterThanOrEqual().lessThanOrEqual()` will not produce the result as you though you would get.","@kneth ah, you're right >.< I made that mistake, he'd have to do\r\n\r\n\r\n``` java\r\n realm.where(Item.class)\r\n     .greaterThanOrEqualTo(\"record.date\",beforeDate)\r\n     .findAll()\r\n     .where()\r\n     .lessThanOrEqualTo(\"record.date\",curDate)\r\n     .findAll();\r\n```","The description indicates that Realm Core has support for it but not through a simple function. We can draw inspiration from Realm Cocoa's implementation: https:\/\/github.com\/realm\/realm-cocoa\/blob\/master\/Realm\/RLMQueryUtil.mm#L743","@Zhuinden It is necessary to call findAll() twice?\r\n>  ah, you're right >.< I made that mistake, he'd have to do\r\n> \r\n> ```java\r\n>  realm.where(Item.class)\r\n>      .greaterThanOrEqualTo(\"record.date\",beforeDate)\r\n>      .findAll()\r\n>      .where()\r\n>      .lessThanOrEqualTo(\"record.date\",curDate)\r\n>      .findAll();\r\n> ```\r\n\r\n","Yes"],"labels":["T-Enhancement"]},{"title":"executeTransactionAsync using handover","body":"Using handover we can make async transactions much easier and nicer to use. It would also eliminate the need for primary keys on objects.\n\n```\nFoo obj = foo;\nrealm.executeTransactionAsync(foo, new Realm.Transaction() {\n  @Override\n   public void execute(Realm realm, Foo foo) {\n     foo.setX(\"X\");  \/\/ foo has been handed over\n  }\n});\n\n\/\/ Also\nrealm.executeTransactionAsync(RealmResults results, Realm.Transaction transaction);\n\n\/\/ And perhaps\nrealm.executeTransactionAsync(RealmObject[] objects, Realm.Transaction transaction);\n```\n\nInstead of \n\n```\nString key = foo.getKey();\nrealm.executeTransactionAsync(new Realm.Transaction.Callback() {\n  @Override\n   public void execute(Realm realm) {\n      Foo foo = realm.where(Foo.class).equalsTo(\"Key\", key).findFirst();\n      foo.setX(\"X\");\n  }\n});\n```\n\nWhat do you think @realm\/java?","comments":[":+1:\n","see Cocoa realm\/realm-cocoa#3136\n","This would make asynchronous operations 10X easier!! \n\nThis workaround is exactly what I have to do in all my database methods. It's slightly frustrating and I ended up creating a helper class that captures the ID of the items and re-queries them when inside the async. transaction.\n\nPlease make this possible :pray: \n\n**Update**: In some cases, I've to update multiple objects in a single async. transaction. Will handover be of any use in those situations?\n","Something like what is described above could do that:\n\n```\nrealm.executeTransactionAsync(RealmObject[] objects, Realm.Transaction transaction);\n\/\/ or\nrealm.executeTransactionAsync(Iterable<RealmObject> objects, Realm.Transaction transaction);\n```\n",":+1: \n","See also #4059, which might impact the design of this"],"labels":["T-Enhancement","Design-Required"]},{"title":"Add primary key on migration","body":"I want to add new field as primary key to old model (there was no primary key in my model but the contents are unique), \nbut in migration i got this error:\n\n```java\njava.lang.IllegalArgumentException: Illegal Argument: Field \"projectUniqueKey\" cannot be a primary key, it already contains duplicate values: \n```\n\nThis is the new model\n\n```java\nclass Project extends RealmObject {\n   @PrimaryKey @Index\n   private String projectUniqueKey;\n   ...\n}\n```\n\nThis is my migration code\n\n```java\nRealmObjectSchema projectSchema = schema.get(\"Project\");\n        projectSchema.addField(\"projectUniqueKey\", String.class, FieldAttribute.PRIMARY_KEY)\n                .transform(new RealmObjectSchema.Function() {\n                    @Override\n                    public void apply(DynamicRealmObject obj) {\n                        obj.set(\"projectUniqueKey\", getUniqueKey());\n                    }\n                });\n```\n\nI'm using 0.87.3\n\n","comments":["Can you please share the source code of `getUniqueKey`?\n","Ah, getUniqueKey just pseudo function, but i got exception before calling this line\n\n``` Java\nobj.set(\"projectUniqueKey\", getUniqueKey());\n```\n\nI added some log to print into logcat but never called.\nThen i changed to addField without setting it as primary and set it later. The exception was gone.\n\n``` Java\nprojectSchema.addField(\"projectUniqueKey\", String.class)\n                .transform(new RealmObjectSchema.Function() {\n                    @Override\n                    public void apply(DynamicRealmObject obj) {\n                        Log.d(\"realm\", \"Set the unique key\"); \/\/this line never called in above codes.\n                        obj.set(\"projectUniqueKey\", getUniqueKey());\n                    }\n                });\nRealmResults<DynamicRealmObject> projectResults = realm.allObjects(\"Project\");\n\/\/Do something with the result\n...\n\/\/Then add the primary key\nprojectSchema.addPrimaryKey(\"projectUniqueKey\").addIndex(\"projectUniqueKey\");\n```\n","Thanks a lot! I think it is a bug that if there are objects exist, when adding a field as primary key, the primary key checking will fail because of all primary key will be empty string in this case before `transform` called.\n\nI am not sure if it can be fixed, but at least a more user friendly message should be printed.\n\nAnd your workaround should work well. Thanks!\n","Right now it is actually working as intended and your work-around is the correct one.\nThat said, I fully understand your use case, but to generalize it a bit: You are actually asking for something like \"Default values\" for fields. We have a issue tracking that here: https:\/\/github.com\/realm\/realm-java\/issues\/777\n","Another workaround is using renameField then addPrimaryKey, addIndex using new field name.\nI did rename field from my old @Required field(not needed in new model) to 'projectUniqueKey'. The error also gone.\n","@cmelchior I don't think use the default value to solve this is the way to go.\nFor the PrimaryKey:\n1. it has to be unique, which means we need supply a generator callback with the object as the input\n2. if the pk generator logic exists in the child RealmObject, that means we are coupling RealmObject with migration, and the RealmObject needs to hold version information which should be ideally only exist in the migration block.\n","A generator is just a generalisation of a single default value, and I wouldn't add the generator logic to the ReamClass. A quick idea below:\n\n```\n@PrimaryKey\n@DefaultValue(generator = PrimaryKeyGenerator.class)\nprivate String id;\n\n@PrimaryKey( = \"42\")\n@DefaultValue(value = \"42\")\nprivate String id\n\npublic class PrimaryKeyGenerator implements DefaultValueGenerator<String, Foo> {\n  @Override\n  public String generateValue(Foo object) {\n    return UUID.getRandom().toString();\n  } \n}\n\npublic class SingleValueGenerator implements DefaultValueGenerator<String, Foo> {\n  @Override\n  public String generateValue(Foo object) {\n    return \"42\"\n  } \n}\n```\n\nI am not sure that just holding the PK generator in the migration is a good idea. It sounds like we are trying to solve a really small sub-problem that is covered by other use cases: Default Values and Calculated Fields. If we just try to solve that without thinking about the others, we probably end up having to redesign the API. Right now our migration API also has a small problem in that it doesn't really support annotation parameters. In order to do that we need to add another layer of abstraction. Cocoa calls this RealmProperty (I think).\n","Working as intended, but we need to document it.\n"],"labels":["T-Doc","O-Community"]},{"title":"New method `getOrCreate(RealmObject.class, primaryKey)","body":"Suggestion from SO\nhttp:\/\/stackoverflow.com\/questions\/35017640\/realmobject-with-primarykey-only\n\n> Here I figured out that there is method realm.objectForPrimaryKey(User.self, key: \"key\") for swift but I did not fund analog in java version.\n> It would be nice to have in this situation something like realm.getOrCreate(Cat.class, c.id) method. Is there any","comments":["We actually already have something almost like it `createObject(Class clazz, Object primaryKeyValue)`. It is used internally by the copyOrUpdate methods. It is not public right now because I was a bit concerned how well it would work with composite primary keys + It isn't very type safe. If you put in the wrong value it will crash. \n\nThat said, I seen this feature being request a couple of times as well, so maybe it is worth looking into how we can add it to the public API.\n","What about\n\n```\n<E extends RealmObject> E getOrCreateObject(Class<E> clazz, String primaryKeyValue) { }\n<E extends RealmObject> E getOrCreateObject(Class<E> clazz, byte primaryKeyValue) { }\n<E extends RealmObject> E getOrCreateObject(Class<E> clazz, short primaryKeyValue) { }\n<E extends RealmObject> E getOrCreateObject(Class<E> clazz, int primaryKeyValue) { }\n<E extends RealmObject> E getOrCreateObject(Class<E> clazz, long primaryKeyValue) { }\n```\n\nFor the composite primary keys, something like, and check the input during run time\n\n```\n<E extends RealmObject> E getOrCreateObject(Class<E> clazz, Map<String, Object> primaryKeyValue) { }\n```\n","Better, but I would hate having to add so many overloaded methods, but yeah it is a trade-off between method count and safety.\n","just realized we need boxed type as well... which means there are going to be 9 methods....\nby allowing null values for primary key, we probably just want methods with boxed types and checking nullability in run time\n","This might be an excellent time to start looking into implementing Lint checks? i.e. we only add:\n\n```\nRealm.createOrGet(Class<? extends RealmObject> clazz, Object primaryKey);\n```\n\nand then use a Lint check on \"compiletime\". \n\nThat would also mean we could get starting exploring what is possible with Lint checks since there is a bunch that would make a lot of sense (checking query parameters is a good one). \n","Also, we need a method only returns without creating, (return `null` if it doesn't exist) like:\n\n```\nRealmObject realmObject = Realm.get(Class<? extends RealmObject> clazz, Object primaryKey);\n```\n\n+1 from http:\/\/stackoverflow.com\/questions\/38109905\/proper-way-to-get-realm-object-by-its-primary-key-in-android-java\n","I've came up with a helper class which will help get any Realm object by key (returning null if there are no primary key or the object is not found). Here is the code:\n\n``` java\npublic final class Find {\n    \/\/ shared cache for primary keys\n    private static Hashtable<Class<? extends RealmModel>, String> primaryKeyMap = new Hashtable<>();\n\n    private static String getPrimaryKeyName(Realm realm, Class<? extends RealmModel> clazz) {\n        String primaryKey = primaryKeyMap.get(clazz);\n        if (primaryKey != null)\n            return primaryKey;\n        RealmObjectSchema schema = realm.getSchema().get(clazz.getSimpleName());\n        if (!schema.hasPrimaryKey())\n            return null;\n        primaryKey = schema.getPrimaryKey();\n        primaryKeyMap.put(clazz, primaryKey);\n        return primaryKey;\n    }\n\n    private static <E extends RealmModel, TKey> E findByKey(Realm realm, Class<E> clazz, TKey key) {\n        String primaryKey = getPrimaryKeyName(realm, clazz);\n        if (primaryKey == null)\n            return null;\n        if (key instanceof String)\n            return realm.where(clazz).equalTo(primaryKey, (String)key).findFirst();\n        else\n            return realm.where(clazz).equalTo(primaryKey, (Long)key).findFirst();\n    }\n\n    public static <E extends RealmModel> E byKey(Realm realm, Class<E> clazz, String key) {\n        return findByKey(realm, clazz, key);\n    }\n\n    public static <E extends RealmModel> E byKey(Realm realm, Class<E> clazz, Long key) {\n        return findByKey(realm, clazz, key);\n    }\n}\n```\n\nI've updated the Stack Overflow question: [http:\/\/stackoverflow.com\/questions\/38109905\/proper-way-to-get-realm-object-by-its-primary-key-in-android-java\/38136597#38136597](http:\/\/stackoverflow.com\/questions\/38109905\/proper-way-to-get-realm-object-by-its-primary-key-in-android-java\/38136597#38136597)\n"],"labels":["T-Enhancement","Design-Required"]},{"title":"RxJava support for executeTransaction","body":"It would be nice to have an async executeTransaction method in Realm-class which returns an Observable since we RxJava-users don't like callables ;)\nMaybe something like:\n\n```\nObservable<void> executeTransaction(Realm.Transaction transaction)\n```\n\nUsage would be:\n\n```\nObservable<void> transaction = realm.executeTransaction(new Realm.Transaction() {\n            @Override\n            public void execute(Realm bgRealm) {\n                User user = bgRealm.createObject(User.class);\n                user.setName(\"John\");\n                user.setEmail(\"john@corporation.com\");\n            }\n        });\ntransaction.subscribe(new rx.Subscriber<T> {\n           @Override public void onCompleted() {\n                 \/\/do your stuff here, if transaction was successful\n            }\n\n           @Override public void onError(Throwable e) {\n                 \/\/cleanup\n            }\n\n            @Override public void onNext(T t) {\n                 \/\/nothing.\n            }\n        });\n```","comments":["Yes, that is a good idea and something we have been considering ourselves.\n","Copy from #2272:\n\n---\n\n### Background\n\nThe first class support for RxJava in Realm is great, however that said I couldn't find a way to make writes work with the current API. As a result using callbacks rather than reactive seemed to be the sensible choice with the current setup.\n\n### Proposal\n\nThe `Completion` or `Single` APIs of RxJava map well to the `Callback` object created as part of the asynchronous write transaction. Could the callback be abstracted or replace with one of the aforementioned types of `Observable`?\n\nThe Single API defines the same methods as the Callback. This is documented here http:\/\/reactivex.io\/documentation\/single.html\n\nThe process would only emit one item therefore the use of Single seems like a logical fit.\n","Any update on this?  I would love to help with this.  Just not sure what the current status is.\n","Hi @jophde \n\nWe are currently focusing on other issues, so would gladly accept any PR's for this. The current tasks for this should be:\n- [ ] Add support for `Realm.asObservable(Transaction)`\n- [ ] Add support for `DynamicRealm.asObservable(Transaction)`\n- [ ] Extend the RxObservableFactory interface with two new methods:\n  - `.from(Realm realm, Realm.Transaction)`\n  - `.from(DynamicRealm realm, DynamicRealm.Transaction)`\n- [ ] Implement functionality in `RealmObserverableFactory`.\n- [ ] Add unit tests to `RxJavaTests`.\n\nAll implementation should reside inside the `RealmObservableFactory` class. Ideally it should be a one-shot operation that just executes the transaction them completes. Ideally using `defer`.\n\nWhile `Completable` is theoretically the more correct to return it is still so new that we would rather let people convert it to that themselves (also it still has bugs).\n","+1\n","+1\n","+1\n","+1\n","Copied from #3213 \n\n---\n\n@cvoronin wrote, \n\n#### What\n\nI would like to have ability to get result of a query not only as Observable, but also as [Single](http:\/\/reactivex.io\/documentation\/single.html)\n\n#### Why\n\nOur Retrofit API often returns results as Single. \nIf I had the ability to get query results as Single, it were possible to use those results in [concat:](http:\/\/reactivex.io\/documentation\/operators\/concat.html)\n\n```\nSingle\n  .concat(getFromRealm(), getFromServer())\n  .first()\n  .subscribe(...)\n```\n\nNow I have to use something like this:\n\n```\n    fun loadAll(): Single<List<Item>> {\n        return Single.just(\n                with(realmProvider.get()) {\n                    use { realm ->\n                        realm.copyFromRealm( realm.where(Item::class.java).findAll() )\n                    }\n                }\n        )\n    }\n```\n","+1\n","+1\n","Best thing about this is that `Observable<Void>` won't be a valid thing with RxJava2 because only possible value for `Void` is `null`, and RxJava2's contract (the Reactive-Streams specification) says that `Observable.just(null)` is an immediately thrown NPE.\n","Are you sure about this on rxjava2? \nThat is a big change then. As other example onErrorResumeNext() wont be available or a backport should be available, as avoiding errors you need Observable.just(null) on RxJava2\nThanks didn't knew about that fact\n","RxJava has `Completable` which should be used for cases like this. It will either complete or error.\nRxJava2 is indeed incompatible with RxJava1, which means we also need to look at how to support both versions going forward. This is covered by #3497 \n","+1","+1","Personally I think this is not realm's responsibility, if people need an Rx wrapper around Realm's methods (even for things that are technically just synchronous method call), then it's up to them, really."],"labels":["T-Enhancement","O-Community"]}]