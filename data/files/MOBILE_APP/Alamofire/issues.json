[{"title":"WebSocketRequest Should Support Validation","body":"## Problem\r\n\r\nCurrently, `validation()`'s variants don't exist for `WebSocketRequest` (as discussed in #3851). Validation should be added to ensure parity with other requests and allow customized handling.\r\n\r\n","comments":[],"labels":["feature request"]},{"title":"Add Conformance To ClientTransport From swift-openapi-generator","body":"* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## Problem\r\n\r\nCurrently Alamofire doesn't have conformance to `ClientTransport` which is needed if we want to use the new swift-openapi-generator: https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10171\/\r\n\r\n## Feature Request\r\n\r\nIf we want to continue to use Alamofire in conjunction with the swift-openapi-generator, `ClientTransport` conformance is needed, as we need to supply it to the generated Client as a valid transport type to perform http operations: https:\/\/github.com\/apple\/swift-openapi-generator\/tree\/7bd8dadd99daafca1ece911209863124a07621f1?tab=readme-ov-file#using-a-generated-api-client\r\n\r\n## Value to Alamofire\r\n\r\nSince this is an apple supported plugin, continuing to use the same Http library is going to be invaluable, and since alamofire is supported by openapi's cli, the next step would be to support it as a part of apple's tools as well.\r\n","comments":["I've never seen client API generators generate any API code I'd ever want to use, but I'll leave this here in case anyone wants to pick it up as a new feature. It seems rather involved, especially for the streaming version."],"labels":["feature request"]},{"title":"Multiple AF.upload cannot be concurrent","body":"> \u2139 Please fill out this template when filing an issue.\r\n> All lines beginning with an \u2139 symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.\r\n>\r\n> Per our [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md), we use GitHub for\r\n> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.\r\n>\r\n> Please remove this line and everything above it before submitting.\r\n\r\n* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\nWhen I use AF.upload to initiate multiple upload tasks, the multiple upload tasks are always executed serially. As a result, other requests I want to execute after the upload is successful must also be executed after all uploads are completed. In other words, upload seems to be blocking other requests. But this is not the case when I use AFNetwork\r\n\r\n## What did you expect to happen?\r\n\r\nWhen I use AF.upload to initiate multiple upload tasks, they can be executed concurrently without blocking other requests.\r\n\r\n## What happened instead?\r\n\r\nBlocking other requests\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire Version: 5.8.1\r\n**Dependency Manager: cocoapods\r\n**Xcode Version: 15.1\r\n**Swift Version:  Swift 5\r\n**Platform(s) Running Alamofire: 17.1\r\n**macOS Version Running Xcode: 14.2.1\r\n\r\n## Demo Project\r\n\r\n```\r\n        DispatchQueue.global().async {\r\n            AF.upload(\r\n                    multipartFormData: {\r\n                        $0.append(fileData, withName: name, fileName: fileName, mimeType: mimeType)\r\n                    },\r\n                    to: uploadURL,\r\n                    headers: headers)\r\n                .responseDecodable(of: APIResponse<APIResult>.self) { response in\r\n                    DispatchQueue.main.async {\r\n                        \/\/\/ other request\r\n                    }\r\n                }\r\n        }\r\n```\r\n","comments":["There's nothing in Alamofire that triggers this behavior. If you're seeing this it's likely `URLSession` is attempting to optimize your connectivity or otherwise preventing the app from overloading the network connections. Or it may be that your server doesn't allow multiple uploads at the same time.\r\n\r\nP.S. The `DispatchQueue` usage you have here is unnecessary. Neither the `global()` or the call back to `main` does anything. Alamofire completion handlers are on `main` by default."],"labels":["needs investigation"]},{"title":"Memory leak from RequestInterceptor.swift file","body":"* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\nI utilized the leak instrument and detected the memory leak originating from the function `adapt` in the file `RequestInterceptor.swift`. In fact, this function failed to add a weak reference in its closure.\r\n\r\n![image](https:\/\/github.com\/Alamofire\/Alamofire\/assets\/143064266\/8811e728-63fe-4c87-b1bd-6e799753f071)\r\n![image](https:\/\/github.com\/Alamofire\/Alamofire\/assets\/143064266\/98cca7ad-06e1-49a4-b55b-bb21c5f31d9d)\r\n\r\n\r\n## What did you expect to happen?\r\n\r\nI expected to add weak or unowned into the `adapt` function's closure, as this would prevent the memory leak from occurring.\r\n\r\n## What happened instead?\r\n\r\nIt still retained the reference that caused the memory leak.\r\n\r\n## Alamofire Environment\r\n\r\nAlamofire Version: 5.7.1\r\nDependency Manager: SPM\r\nXcode Version: 14.3.1 (14E300c)\r\nSwift Version: 5\r\nPlatform(s) Running Alamofire: iOS Simulator\r\nmacOS Version Running Xcode: 13.5.1 Ventura\r\n","comments":["Can you provide an example project that reproduces this leak? There really shouldn't be a leak here, as all of the captures should be released once the nested adapt calls are complete."],"labels":["needs investigation"]},{"title":"Multiple token refresh issue in AuthenticationInterceptor","body":"* [X] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\n\u2139 Replaced private and public keys for JWT token (on the server).\r\nBefore that everything was working as it should be and it's working fine for different host. It's just not working on the host where we changed public and private keys for JWT.\r\n\r\n## What did you expect to happen?\r\n\r\n\u2139 Alamofire request will attach Authorization token in request header  \r\n\r\n## What happened instead?\r\n\r\n\u2139 Authenticator \"func refresh\" triggered 5 times (with success response with token) and after that triggered next API call without authorization header and response of that call is:\r\n`Alamofire.AFError.requestAdaptationFailed(error: Alamofire.AuthenticationError.excessiveRefresh)`\r\n\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire Version:**5.4.3\r\n**Dependency Manager:**Pod\r\n**Xcode Version:**14.3.1\r\n**Swift Version:**5.8.1\r\n**Platform(s) Running Alamofire:** iOS\r\n**macOS Version Running Xcode:**Ventura 13.4 \r\n\r\n## Demo Project\r\n\r\n\u2139 Please link to or upload a project we can download that reproduces the issue.\r\n","comments":["Sorry, there's not enough here for us to investigate. It sounds like you're using the `AuthenticationInterceptor` and changed how authentication works, so it's likely you need to update some of your other logic for detecting auth errors or detecting that the credential is attached to the request. I suggest you investigate further and, if you can't solve it, attach your `AuthenticationInterceptor` implementation or a reproducible project so we can better investigate what's going on."],"labels":["needs investigation"]},{"title":"Not all types of errors should count against RefreshWindow count","body":"* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## Problem\r\n\r\nWhenever an access token refresh request\/operation fails, it counts in the RefreshWindow. Using a RefreshWindow will eventually cause excessiveRefresh errors to be thrown. If the errors refreshing the access token are related to network problems (as it will come to pass on a mobile platform), the RefreshWindow can fill up rather quickly. I like the idea of excessiveRefresh errors, but only when it's related to actual errors concerning authentication - not timeouts and reachability.\r\n\r\n## Feature Request\r\n\r\nIt could be nice to be able to configure what types of errors count in the refresh window. A suitable default would obviously be all errors, so that not-configured RefreshWindows continue to operate as they do already.\r\n","comments":["Hi there,\r\n\r\nI\u2019ve begun resolving this issue and have developed a feature that allows users to configure which types of errors count towards the refresh window. The default behavior remains unchanged, counting all errors, while users can now provide a closure to specify their error handling logic.\r\n\r\nI'm in the process of writing tests and updating the documentation to reflect this new feature. I plan to submit a draft PR soon to get feedback on the implementation.\r\n\r\nCould this issue be assigned to me to avoid duplicate work?\r\n\r\nThank you!","Issue assignments aren't used like that, and there's no one else working on the issue, so feel to work as you want."],"labels":["feature request"]},{"title":"Crash - CompositeEventMonitor.request<A>(_:didParseResponse:)  ","body":"> \u2139 Please fill out this template when filing an issue.\r\n> All lines beginning with an \u2139 symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.\r\n>\r\n> Per our [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md), we use GitHub for\r\n> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.\r\n>\r\n> Please remove this line and everything above it before submitting.\r\n\r\n* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\nI've created and publish an application on iOS, this application use Alamofire v5.4.3 to communicate with the restful api. We also shipped the application with Firebase Crashlytics, and I received some crash logs which related to Alamofire. I've attached the crash log below. Please check it for me. \r\n\r\niPhone 12 Pro\/ iOS 16.0.0\r\n\r\n## What did you expect to happen?\r\n\r\nNo crash\r\n\r\n## What happened instead?\r\n\r\nCrash\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire Version:** 5.4.3\r\n**Dependency Manager:** Swift Package Manager\r\n**Xcode Version:** XCode 14.1\r\n**Swift Version:** Swift 5.7\r\n**Platform(s) Running Alamofire:** iOS 16.0.0\r\n**macOS Version Running Xcode:** 12.6.1\r\n\r\n## Demo Project\r\n\r\n> Crashed: com.apple.main-thread\r\n> \r\n> 0  libobjc.A.dylib                0x21f94 objc_class::isInitialized() + 36\r\n1  libobjc.A.dylib                0x794c lookUpImpOrForward + 60\r\n2  libobjc.A.dylib                0x20c4 _objc_msgSend_uncached + 68\r\n3  CoreFoundation                 0x7a6f8 __CFBasicHashDrain + 320\r\n4  CoreFoundation                 0x7ed20 _CFRelease + 316\r\n5  CFNetwork                      0x5da80 CFHTTPCookieStorageCreateFromFile + 4332\r\n6  CoreFoundation                 0x7ed20 _CFRelease + 316\r\n7  CFNetwork                      0x167c8 CFURLRequestSetURL + 6816\r\n8  CoreFoundation                 0x7ed20 _CFRelease + 316\r\n9  CFNetwork                      0x1070cc _CFURLConnectionCopyTimingData + 16068\r\n10 libobjc.A.dylib                0x14a4 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n11 libobjc.A.dylib                0x621c objc_destructInstance + 80\r\n12 libobjc.A.dylib                0xf9d0 _objc_rootDealloc + 80\r\n13 CFNetwork                      0x832fc CFURLResponseCreateWithHTTPResponse + 69584\r\n14 CFNetwork                      0x84834 CFURLResponseCreateWithHTTPResponse + 75016\r\n15 CFNetwork                      0x83e34 CFURLResponseCreateWithHTTPResponse + 72456\r\n16 CFNetwork                      0x479dc CFURLCacheRemoveAllCachedResponses + 11992\r\n17 libobjc.A.dylib                0x14a4 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n18 libobjc.A.dylib                0x621c objc_destructInstance + 80\r\n19 libobjc.A.dylib                0xf9d0 _objc_rootDealloc + 80\r\n20 CoreFoundation                 0x6b5b0 __RELEASE_OBJECTS_IN_THE_ARRAY__ + 112\r\n21 CoreFoundation                 0x6b720 -[__NSArrayM dealloc] + 268\r\n22 CFNetwork                      0xe770 CFURLCacheSetMemoryCapacity + 3764\r\n23 libobjc.A.dylib                0x14a4 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n24 libobjc.A.dylib                0x621c objc_destructInstance + 80\r\n25 libobjc.A.dylib                0xf9d0 _objc_rootDealloc + 80\r\n26 libobjc.A.dylib                0x14a4 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n27 libobjc.A.dylib                0x621c objc_destructInstance + 80\r\n28 libobjc.A.dylib                0xf9d0 _objc_rootDealloc + 80\r\n29 MyApp                       0x1398c8c CompositeEventMonitor.request<A>(_:didParseResponse:) + 4324576396\r\n30 libswiftCore.dylib             0x3da1d4 _swift_release_dealloc + 56\r\n31 MyApp                       0x13a1e44 outlined init with copy of AFError? + 4324613700\r\n32 libswiftCore.dylib             0x3da1d4 _swift_release_dealloc + 56\r\n33 libsystem_blocks.dylib         0x2124 _call_dispose_helpers_excp + 48\r\n34 libsystem_blocks.dylib         0x1d54 _Block_release + 252\r\n35 libdispatch.dylib              0x3fdc _dispatch_client_callout + 20\r\n36 libdispatch.dylib              0x127f4 _dispatch_main_queue_drain + 928\r\n37 libdispatch.dylib              0x12444 _dispatch_main_queue_callback_4CF + 44\r\n38 CoreFoundation                 0x9aa08 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 16\r\n39 CoreFoundation                 0x7c368 __CFRunLoopRun + 2036\r\n40 CoreFoundation                 0x811e4 CFRunLoopRunSpecific + 612\r\n41 GraphicsServices               0x1368 GSEventRunModal + 164\r\n42 UIKitCore                      0x3a2d88 -[UIApplication _run] + 888\r\n43 UIKitCore                      0x3a29ec UIApplicationMain + 340\r\n44 libswiftUIKit.dylib            0x352a0 UIApplicationMain(_:_:_:_:) + 104\r\n45 MyApp                        0x8abc main + 4304063164 (IdeasAnalystCallScreen.swift:4304063164)\r\n46 ???                            0x1b1609948 (Missing)\r\n","comments":["Are you using any `EventMonitor`s? If not, you can essentially turn the feature off by passing an empty array when you create your `Session` instance: `Session(..., eventMonitors: [])`. This may prevent capture by by the `CompositeEventMonitor` that may be the cause of this issue. \r\n\r\nIf you are using `EventMonitor`s, an example of your usage may help investigate what's happening.","> Are you using any `EventMonitor`s? If not, you can essentially turn the feature off by passing an empty array when you create your `Session` instance: `Session(..., eventMonitors: [])`. This may prevent capture by by the `CompositeEventMonitor` that may be the cause of this issue.\r\n\r\n@jshier I'm witnessing a similar crash in the `CompositeEventMonitor`'s iteration of monitors. The app is specifying an empty event monitors array (`Session(..., eventMonitors: [])`) yet an a [`CompositeEventMonitor` is still created with the `defaultEventMonitors` (`AlamofireNotifications`)](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/Source\/Session.swift#L134). There currently is no way to avoid making the `CompositeEventMonitor` and `AlamofireNotifications` in order to avoid the crash. Would it be possible to make the default `eventMonitors` parameter value be `defaultEventMonitors` instead of always prepending the `defaultEventMonitors` to the supplied `eventMonitors` array? That would allow callers to prevent initializing event monitors they do not intend on using.\r\n\r\n<img width=\"949\" alt=\"EventMonitor CallStack\" src=\"https:\/\/user-images.githubusercontent.com\/915431\/216847660-316eb11b-2664-43a9-a813-a8afc6b21ae5.png\">"],"labels":["awaiting response"]},{"title":"Failure: org.alamofire.session.rootQueue.requestQueue SIGSEGV 0x0000ab6b47bd0dd0","body":"\u2139  I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\nI logged into my application and started a session using AuthenticationInterceptor, and it failed.\r\n\r\n## What did you expect to happen?\r\nThat the app follows its default flow without failing.\r\n\r\n## What happened instead?\r\n\r\nApp crashed and closed \r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire Version:** 5.6.2\r\n**Dependency Manager:** SPM\r\n**Xcode Version:** 14.1 \r\n**Swift Version:** 5\r\n**Platform(s) Running Alamofire:** iPhone 11 iOS 15.6.1\r\n**macOS Version Running Xcode:** Ventura 13.0\r\n\r\nThe problem in question was reported by Firebase below the logs generated.\r\n\r\n![Captura de Tela 2022-11-16 a\u0300s 14 24 16](https:\/\/user-images.githubusercontent.com\/31930009\/202250839-dba8f38e-bc20-44f6-85fa-4cb6916d28d9.png)\r\n\r\n[Full error log](https:\/\/github.com\/Alamofire\/Alamofire\/files\/10024245\/br.com.project.error_issue_c0876f388f3a74e193803719a16b4fd5_crash_session_bc6cec94c5774615aaa4a949d8ab8a1d_DNE_0_v2_stacktrace.txt)\r\n\r\nI wonder how I can correct this and where I should start my analysis","comments":["Can you post your usage of the `AuthenticationInterceptor`, including how you're providing the `Credential`? Without that there's no real way to investigate this."],"labels":["awaiting response"]},{"title":"Crash CompositeEventMonitor","body":"> \u2139 Please fill out this template when filing an issue.\r\n> All lines beginning with an \u2139 symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.\r\n>\r\n> Per our [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md), we use GitHub for\r\n> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.\r\n>\r\n> Please remove this line and everything above it before submitting.\r\n\r\n* [ ] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\nWe update using alamofire 5.4.4 or version 5.6.1\r\n\r\n## What did you expect to happen?\r\n\r\nNot crash\r\n\r\n## What happened instead?\r\n\r\nto many crash in CompositeEventMonitor\r\n\r\n<img width=\"1156\" alt=\"Screen Shot 2\r\n![image (1)](https:\/\/user-images.githubusercontent.com\/12388348\/181690632-d0f41ead-2911-4102-8c66-0f6834a8eef6.png)\r\n022-07-29 at 09 58 28\" src=\"https:\/\/user-images.githubusercontent.com\/12388348\/181690315-874caf40-fefa-4c26-bd09-f60ff9095f8e.png\">\r\n\r\n![image (1)](https:\/\/user-images.githubusercontent.com\/12388348\/181690674-3a82be52-64dd-4b7a-974a-b962330c5900.png)\r\n\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire Version: 5.4.4 or version 5.6.1\r\n**Dependency Manager:**\r\n**Xcode Version:13.4.1\r\n**Swift Version:**\r\n**Platform(s) Running Alamofire:**\r\n**macOS Version Running Xcode:**\r\n\r\n","comments":["I'm getting the same thing but I'm unable to recreate it. Were you able to figure this one out?","It really seems like some sort of underlying Swift issue. Building with the latest Xcode may make it go away, or, if you aren't using the `Notification`s that are enabled by default, you can disable `EventMonitor`s entirely by passing an empty array when you create your `Session`. \r\n\r\n```swift\r\nSession(..., eventMonitors: [])\r\n```\r\n\r\nThis will ensure that the `CompositeEventMonitor` doesn't end up doing anything at runtime and should hopefully avoid the crash.","> It really seems like some sort of underlying Swift issue. Building with the latest Xcode may make it go away, or, if you aren't using the `Notification`s that are enabled by default, you can disable `EventMonitor`s entirely by passing an empty array when you create your `Session`.\r\n> \r\n> ```swift\r\n> Session(..., eventMonitors: [])\r\n> ```\r\n> \r\n> This will ensure that the `CompositeEventMonitor` doesn't end up doing anything at runtime and should hopefully avoid the crash.\r\n\r\n@jshier I'm witnessing a similar crash in the `CompositeEventMonitor`'s iteration of monitors. The app is specifying an empty event monitors array (`Session(..., eventMonitors: [])`) yet an a [`CompositeEventMonitor` is still created with the `defaultEventMonitors` (`AlamofireNotifications`)](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/Source\/Session.swift#L134). There currently is no way to avoid making the `CompositeEventMonitor` and `AlamofireNotifications` in order to avoid the crash. Would it be possible to make the default `eventMonitors` parameter value be `defaultEventMonitors` instead of always prepending the `defaultEventMonitors` to the supplied `eventMonitors` array? That would allow callers to prevent initializing event monitors they do not intend on using.\r\n\r\n<img width=\"949\" alt=\"EventMonitor CallStack\" src=\"https:\/\/user-images.githubusercontent.com\/915431\/216847660-316eb11b-2664-43a9-a813-a8afc6b21ae5.png\">","@ejensen Can you post the textual crash log that Crashlytics has? At least the call stack of the crashing thread would be helpful.\r\n\r\nBut you're right, I misremembered the `eventMonitors` workaround. I've pushed a branch, `bug\/eventmonitor-default-value`, which deprecates the instance `defaultEventMonitors` and creates a static version that can be used as the default in the init. Give it a look.","> @ejensen Can you post the textual crash log that Crashlytics has? At least the call stack of the crashing thread would be helpful.\r\n\r\n<details>\r\n  <summary>Stack Trace<\/summary>\r\n\r\n```\r\nCrashed: com.apple.main-thread\r\n0  libswiftCore.dylib             0x39c40c _swift_release_dealloc + 32\r\n1  Frame.io                       0x943f60 protocol witness for EventMonitor.request<A>(_:didParseResponse:) in conformance AlamofireNotifications + 4308598624 (<compiler-generated>:4308598624)\r\n2  libswiftCore.dylib             0x39c424 _swift_release_dealloc + 56\r\n3  Frame.io                       0x944f38 outlined init with copy of EventMonitor + 4308602680 (<compiler-generated>:4308602680)\r\n4  libswiftCore.dylib             0x39c424 _swift_release_dealloc + 56\r\n5  libsystem_blocks.dylib         0x1804 _Block_release + 192\r\n6  libdispatch.dylib              0x3a30 _dispatch_client_callout + 20\r\n7  libdispatch.dylib              0x11f48 _dispatch_main_queue_drain + 928\r\n8  libdispatch.dylib              0x11b98 _dispatch_main_queue_callback_4CF + 44\r\n9  CoreFoundation                 0x51800 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 16\r\n10 CoreFoundation                 0xb704 __CFRunLoopRun + 2532\r\n11 CoreFoundation                 0x1ebc8 CFRunLoopRunSpecific + 600\r\n12 GraphicsServices               0x1374 GSEventRunModal + 164\r\n13 UIKitCore                      0x514b58 -[UIApplication _run] + 1100\r\n14 UIKitCore                      0x296090 UIApplicationMain + 364\r\n15 Frame.io                       0x77c0 main + 18 (AppDelegate.swift:18)\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\ncom.apple.uikit.eventfetch-thread\r\n0  libsystem_kernel.dylib         0x14a0 mach_msg_trap + 8\r\n1  libsystem_kernel.dylib         0x1ae4 mach_msg + 76\r\n2  CoreFoundation                 0x6d30 __CFRunLoopServiceMachPort + 372\r\n3  CoreFoundation                 0xb1bc __CFRunLoopRun + 1180\r\n4  CoreFoundation                 0x1ebc8 CFRunLoopRunSpecific + 600\r\n5  Foundation                     0x19444 -[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 236\r\n6  Foundation                     0x5ae0c -[NSRunLoop(NSRunLoop) runUntilDate:] + 92\r\n7  UIKitCore                      0x48ecc4 -[UIEventFetcher threadMain] + 524\r\n8  Foundation                     0x6941c __NSThread__start__ + 808\r\n9  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n10 libsystem_pthread.dylib        0xe68 thread_start + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\nThread\r\n0  libsystem_kernel.dylib         0x1a74 __workq_kernreturn + 8\r\n1  libsystem_pthread.dylib        0x1108 _pthread_wqthread + 364\r\n2  libsystem_pthread.dylib        0xe5c start_wqthread + 8\r\n\r\ncom.google.firebase.crashlytics.MachExceptionServer\r\n0  Frame.io                       0xb61c1c FIRCLSProcessRecordAllThreads + 393 (FIRCLSProcess.c:393)\r\n1  Frame.io                       0xb61ffc FIRCLSProcessRecordAllThreads + 424 (FIRCLSProcess.c:424)\r\n2  Frame.io                       0xb6f4e8 FIRCLSHandler + 34 (FIRCLSHandler.m:34)\r\n3  Frame.io                       0xb6fce4 FIRCLSMachExceptionServer + 521 (FIRCLSMachException.c:521)\r\n4  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n5  libsystem_pthread.dylib        0xe68 thread_start + 8\r\n\r\nAVAudioSession Notify Thread\r\n0  libsystem_kernel.dylib         0x14a0 mach_msg_trap + 8\r\n1  libsystem_kernel.dylib         0x1ae4 mach_msg + 76\r\n2  CoreFoundation                 0x6d30 __CFRunLoopServiceMachPort + 372\r\n3  CoreFoundation                 0xb1bc __CFRunLoopRun + 1180\r\n4  CoreFoundation                 0x1ebc8 CFRunLoopRunSpecific + 600\r\n5  AudioSession                   0x6f04 CADeprecated::GenericRunLoopThread::Entry(void*) + 164\r\n6  AudioSession                   0x108f0 CADeprecated::CAPThread::Entry(CADeprecated::CAPThread*) + 92\r\n7  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n8  libsystem_pthread.dylib        0xe68 thread_start + 8\r\n\r\ncom.apple.NSURLConnectionLoader\r\n0  libsystem_kernel.dylib         0x14a0 mach_msg_trap + 8\r\n1  libsystem_kernel.dylib         0x1ae4 mach_msg + 76\r\n2  CoreFoundation                 0x6d30 __CFRunLoopServiceMachPort + 372\r\n3  CoreFoundation                 0xb1bc __CFRunLoopRun + 1180\r\n4  CoreFoundation                 0x1ebc8 CFRunLoopRunSpecific + 600\r\n5  CFNetwork                      0x2781dc _CFURLStorageSessionDisableCache + 60032\r\n6  Foundation                     0x6941c __NSThread__start__ + 808\r\n7  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n8  libsystem_pthread.dylib        0xe68 thread_start + 8\r\n\r\ncom.apple.coremedia.rootQueue.47\r\n0  libsystem_kernel.dylib         0x14f4 semaphore_timedwait_trap + 8\r\n1  libdispatch.dylib              0x4048 _dispatch_sema4_timedwait + 64\r\n2  libdispatch.dylib              0x463c _dispatch_semaphore_wait_slow + 76\r\n3  libdispatch.dylib              0x14f38 _dispatch_worker_thread + 312\r\n4  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n5  libsystem_pthread.dylib        0xe68 thread_start + 8\r\n\r\ncom.apple.coremedia.rootQueue.47\r\n0  libsystem_kernel.dylib         0x14f4 semaphore_timedwait_trap + 8\r\n1  libdispatch.dylib              0x4048 _dispatch_sema4_timedwait + 64\r\n2  libdispatch.dylib              0x463c _dispatch_semaphore_wait_slow + 76\r\n3  libdispatch.dylib              0x14f38 _dispatch_worker_thread + 312\r\n4  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n5  libsystem_pthread.dylib        0xe68 thread_start + 8\r\n\r\ncom.apple.coremedia.rootQueue.47\r\n0  libsystem_kernel.dylib         0x14f4 semaphore_timedwait_trap + 8\r\n1  libdispatch.dylib              0x4048 _dispatch_sema4_timedwait + 64\r\n2  libdispatch.dylib              0x463c _dispatch_semaphore_wait_slow + 76\r\n3  libdispatch.dylib              0x14f38 _dispatch_worker_thread + 312\r\n4  libsystem_pthread.dylib        0x19ac _pthread_start + 148\r\n5  libsystem_pthread.dylib        0xe68 thread_start + 8\r\n```\r\n<\/details>\r\n\r\n> But you're right, I misremembered the `eventMonitors` workaround. I've pushed a branch, `bug\/eventmonitor-default-value`, which deprecates the instance `defaultEventMonitors` and creates a static version that can be used as the default in the init. Give it a look.\r\n\r\nThe `bug\/eventmonitor-default-value` looks good to me. It would require some upgrade notes though since it does change the default behavior for integrators that do supply a non-default value for the `eventMonitors` parameter.","Yeah, I'm not sure I can ship such a change. Ultimately the issue is I don't understand the cause of the crash. Iteration of a constant array should't cause any issues, even from multiple queues, as there's no mutation. All I can think is that the values passed into the `EventMonitor` don't like be dispatched between queues. I'll have to take another look.","I have another problem that also needs to avoid the `AlamofireNotifications` event monitor:\r\n\r\nI'm using Alamofire in a little corner of a larger Vapor project (using AsyncHTTPClient in most cases...). Since Vapor blocks the main thread I try to avoid Alamofire scheduling\/dispatching anything on it. Currently, there is no way to disable the `AlamofireNotifications` event monitor, which results in dispatching blocks on the main queue. It seems that it is not possible to set the queue in this situation.\r\n\r\n`AlamofireNotifications` uses the default queue provided by the `EventMonitor` protocol:\r\n\r\nhttps:\/\/github.com\/Alamofire\/Alamofire\/blob\/81a29729e7dbfe7b976723843d0280926587a532\/Source\/EventMonitor.swift#L223-L225\r\n\r\nIt would be helpful if the `AlamofireNotifications` event monitor could be disabled or not be added at all.","We also encountered this crash, but the stack information is indeed limited.\r\n\r\n<img width=\"797\" alt=\"image\" src=\"https:\/\/github.com\/Alamofire\/Alamofire\/assets\/5411840\/99c437d5-8481-4617-aeb1-f6a7bde06881\">\r\n\r\n\r\nCrashed: com.apple.main-thread\r\n0  libobjc.A.dylib                0x9898 lookUpImpOrForward + 88\r\n1  libobjc.A.dylib                0x4cc4 _objc_msgSend_uncached + 68\r\n2  libobjc.A.dylib                0x7bbc objc_object::sidetable_release(bool, bool) + 292\r\n3  CFNetwork                      0x2080e0 _CFHTTPServerResponseEnqueue + 22976\r\n4  CoreFoundation                 0xc310 _CFRelease + 292\r\n5  CFNetwork                      0xde1e4 _CFStreamErrorFromCFError + 5000\r\n6  CoreFoundation                 0xc310 _CFRelease + 292\r\n7  CFNetwork                      0xc016c CFURLConnectionInvalidateConnectionCache + 7276\r\n8  libobjc.A.dylib                0x5354 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n9  libobjc.A.dylib                0x5090 objc_destructInstance + 80\r\n10 libobjc.A.dylib                0x503c _objc_rootDealloc + 80\r\n11 CFNetwork                      0x1eca6c CFHTTPCookieStorageUnscheduleFromRunLoop + 237876\r\n12 CFNetwork                      0x1ed9f0 CFHTTPCookieStorageUnscheduleFromRunLoop + 241848\r\n13 CFNetwork                      0x55878 CFURLCredentialStorageSetDefaultCredentialForProtectionSpace + 27892\r\n14 libobjc.A.dylib                0x5354 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n15 libobjc.A.dylib                0x5090 objc_destructInstance + 80\r\n16 libobjc.A.dylib                0x503c _objc_rootDealloc + 80\r\n17 CoreFoundation                 0xbec0 __RELEASE_OBJECTS_IN_THE_ARRAY__ + 116\r\n18 CoreFoundation                 0xbdfc -[__NSArrayM dealloc] + 148\r\n19 CFNetwork                      0x183c54 _CFStreamErrorFromCFError + 683512\r\n20 libobjc.A.dylib                0x5354 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n21 libobjc.A.dylib                0x5090 objc_destructInstance + 80\r\n22 libobjc.A.dylib                0x503c _objc_rootDealloc + 80\r\n23 libobjc.A.dylib                0x5354 object_cxxDestructFromClass(objc_object*, objc_class*) + 116\r\n24 libobjc.A.dylib                0x5090 objc_destructInstance + 80\r\n25 libobjc.A.dylib                0x503c _objc_rootDealloc + 80\r\n26 Grow                           0xc64860 CompositeEventMonitor.request<A>(_:didParseResponse:) + 4355475552\r\n27 libswiftCore.dylib             0x3a6d88 _swift_release_dealloc + 56\r\n28 libswiftCore.dylib             0x3a8424 bool swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1> >::doDecrementSlow<(swift::PerformDeinit)1>(swift::RefCountBitsT<(swift::RefCountInlinedness)1>, unsigned int) + 136\r\n29 Grow                           0xc6e620 outlined init with copy of EventMonitor + 4355515936 (<compiler-generated>:4355515936)\r\n30 libswiftCore.dylib             0x3a6d88 _swift_release_dealloc + 56\r\n31 libswiftCore.dylib             0x3a8424 bool swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1> >::doDecrementSlow<(swift::PerformDeinit)1>(swift::RefCountBitsT<(swift::RefCountInlinedness)1>, unsigned int) + 136\r\n32 libsystem_blocks.dylib         0x2438 _call_dispose_helpers_excp + 48\r\n33 libsystem_blocks.dylib         0x23ec _Block_release + 252\r\n34 libdispatch.dylib              0x4300 _dispatch_client_callout + 20\r\n35 libdispatch.dylib              0x12998 _dispatch_main_queue_drain + 984\r\n36 libdispatch.dylib              0x125b0 _dispatch_main_queue_callback_4CF + 44\r\n37 CoreFoundation                 0x3720c __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 16\r\n38 CoreFoundation                 0x33f18 __CFRunLoopRun + 1996\r\n39 CoreFoundation                 0x33668 CFRunLoopRunSpecific + 608\r\n40 GraphicsServices               0x35ec GSEventRunModal + 164\r\n41 UIKitCore                      0x22c2b4 -[UIApplication _run] + 888\r\n42 UIKitCore                      0x22b8f0 UIApplicationMain + 340\r\n43 UIKitCore                      0x4559c8 __swift_destroy_boxed_opaque_existential_1Tm + 12220\r\n"],"labels":["needs investigation"]},{"title":"Swift Concurrency - Docs Unclear - Upload Request Progress","body":"* [X ] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## Problem\r\n\r\nThe current docs around swift concurrency are unclear. How do you get the progress from AF.upload(file, to: url)\r\n\r\n## Feature Request\r\n\r\nPlease update the docs with an upload example.\r\n\r\n## Value to Alamofire\r\n\r\nThis will make the new concurrency more accessible to new developers like myself!\r\n","comments":["`UploadRequest` has the same progress as `DataRequest`, as it's a subclass. I don't tend to give `UploadRequest` specific examples because it has exactly the same interface as `DataRequest` aside from some upload specific functionality. I guess I can make most references to `DataRequest` read `DataRequest` and `UploadRequest` though.","Looking at the docs I coded this:\r\n\r\n```\r\nfunc upload(file: URL) async throws -> String {\r\n        let putURL = try await self.getPutURL(key: file.lastPathComponent, expiration: 30)\r\n        \r\n        let request = AF.upload(file,to: putURL, method: .put)\r\n        \r\n        for await progress in request.uploadProgress() {\r\n            debugPrint(\"Progress: \\(progress.fractionCompleted * 100)\")\r\n        }\r\n        \r\n        guard let etag = await request.validate()\r\n                .serializingData().response.response?.headers[\"Etag\"] else {\r\n                    throw S3Error.unableToDecodeResponse\r\n                }\r\n        \r\n        return etag\r\n    }\r\n```\r\n\r\nBut this does not work. It works without the progress block.. but not with. I would post on StackOverflow but this is still pretty new....","It's working correctly, which is why many of my progress examples include throwing the `uploadProgress()` into its own `Task`. `for await` suspends awaiting new values and only completes the loop when progress is complete. Unfortunately, since you suspend before actually starting the request, no progress values are ever received and the code is suspended forever. For progress I recommend still using the older closure APIs."],"labels":["feature request","documentation"]},{"title":"Enable Manual Response Caching","body":"> \u2139 Please fill out this template when filing a feature request.\r\n> All lines beginning with an \u2139 symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.\r\n>\r\n> Feature requests should code examples whenever possible.\r\n>\r\n> Per our [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md), we use GitHub for\r\n> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.\r\n>\r\n> Please remove this line and everything above it before submitting.\r\n\r\n* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## Problem\r\n\r\nI would like to retrieve the response returned by the webservice and modify its header before it is interpreted by the Alamofire library such as a Response Interceptor. This functionality seems to be present using a `ResponseCacher` to modify a response before caching it.\r\nHowever, if you want to modify the headers to allow the response to be cached, there is currently no solution.\r\n\r\n## Feature Request\r\n\r\nHave the ability to intercept the response and modify any header. This feature is available with the OkHttp library on Android https:\/\/square.github.io\/okhttp\/interceptors\/#rewriting-responses.\r\n\r\n## Value to Alamofire\r\n\r\nAs mentioned above, this would allow the behavior of the response to be changed on the client side and, for example, to be able to cache the response.\r\n","comments":["This is actually a feature we recently discussed adding. Can I ask what your use case would be? On first glance this doesn't seem to be a very useful capability. The use case you mention, caching, is already possible with the `CachedResponseHandler` protocol: simply modify the response to have the relevant caching headers and tell the system to cache it. The added headers should then be used by the system to determine whether future requests should use the cache.\r\n\r\nWe discussed adding a general `ResponseInterceptor` and decided against it, as there's no way to integrate such modified responses with the rest of `URLSession`'s response pipeline. We'd have to maintain our own, separate caching pipeline, since we'd lose access to the cache maintained by `URLSession`. That level of complexity just didn't seem worth it without extremely motivating use cases, which we couldn't find.","I thought the same thing @Alexandredenis35. It's just a very complex feature to support. I'm with @jshier, do you have any actual use cases? I myself didn't which made it difficult to try to justify.","I would like to cache a response that the server does not allow, by removing the `no-store` header from the `Cache-Control` header.\r\nThe `ResponseCacher` is only usable if the response can be cached. Except in my case, the header prevents me from caching the response.","@Alexandredenis35 As I said, you should already be able to do that with the `CacheResponseHandler` protocol or `ResponseCacher` type. Have you tried implementing what you need?","Yes, indeed I have already implemented a `responseCacher` to remove some headers from cached requests.\r\nHowever, in this case, the `responseCacher` with the modify `behavior` is never called because the response cannot be cached (`Cache-Control: no-store`). As the documentation mentioned,  \r\n\r\n> The conditions under which a response will be considered for caching are extensive, so it\u2019s best to review the documentation of the URLSessionDataDelegate method urlSession(_:dataTask:willCacheResponse:completionHandler:). Once a response is considered for caching, there are variety of valuable manipulations that can be made\r\n\r\nThe response has to be considered for caching before manipulate it.\r\nIf you have a solution, I'm interested.","Ah yes, sorry. Unfortunately there's no other way to hook into `URLSession`'s caching process, at least automatically. You could try manually caching the response in the `URLCache` associated with your request. It's likely the only place you could really do it is in or after your response handler. Something like this may work:\r\n\r\n```swift\r\n\/\/ Assuming Session is in scope somewhere.\r\nsession.request(...).responseDecodable(of: Type.self) { response in\r\n  \/\/ Unwrap urlRequest, httpResponse, data, and check for success.\r\n  \/\/ Modify the httpResponse to remove the caching attributes.\r\n  let cachedResponse = CachedURLResponse(response: httpResponse, data: data)\r\n  session.configuration.urlCache.storeCachedResponse(cachedResponse, for: urlRequest)\r\n}\r\n```\r\nThat should allow future requests using the same `URLRequest` to come from the cache automatically, depending on the cache settings you add to the response. One issue here may be the `URLRequest` used for caching here, as it's unclear how precise you need to be. The `URLRequest` returned by Alamofire's response values are the `URLRequest`s that Alamofire sees, not necessarily the `URLRequest`s performed by the underlying `URLSession`. If it doesn't work with this `URLRequest`, you may need to access your underlying `URLSessionTask`'s `currentRequest` to get the proper one. You can do that by capturing the Alamofire `Request` you created and accessing the `currentTask` to find the latest `URLRequest` that was performed.\r\n\r\nGiven this limitation of `URLSession`'s caching delegation, it may be appropriate to build a feature that performs the above steps for you more easily. Something like a `ManuallyCaching` protocol and associated types. We'd have to work out the details of where and when this method would fire and how you might connect it to the result of attached response handlers, but it's much more possible than a general `ResponseInterceptor` protocol.","Thinking about this more, proper integration of manual caching into Alamofire is deeply impacted by our response serializer APIs and the fact that `Request` may have multiple attached response handlers. We'd want to perform manual caching only after the success of the response serializer, but we'd also want to avoid multiply caching responses from multiple handlers. \r\n\r\nMy current thinking is that we'd create a wrapper protocol for our serializers which would allow manual caching after running the serializer. It would look to the rest of the system that's it's just a response serializer with additional parameters injected. Perhaps something like:\r\n\r\n```swift\r\nManuallyCaching(DecodableResponseSerializer())\r\n```\r\n\r\nwith a convenience method:\r\n\r\n```swift\r\nrequest.manuallyCachingResponse(.decodable(of: Type.self)) { response in }\r\n```\r\nBut this requires further investigation."],"labels":["feature request"]},{"title":"Super slow uploads (10x time) on 1% packet loss connection","body":"I'm running two different network connections. One is over WIFI with 25MBit\/s upload at 1% packet loss. One is over mobile with 24MBit\/s upload at 0% packet loss. The first connection takes 10x as long to upload files to a Django server, while the mobile connection is a lot faster. This app is the only place where I'm experiencing slowdowns. I use this connection every day for everything else. As far as I can tell, Alamofire is the only part of the chain that could cause these slowdowns.\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire Version:** 5.4.3 \r\n**Dependency Manager:** SPM \r\n**Xcode Version:** 12.5.1 \r\n**Swift Version:** 5 \r\n**Platform(s) Running Alamofire:** iOS 14.6\r\n**macOS Version Running Xcode:** 11.4\r\n\r\n## Demo Project\r\n\r\n\u2139 Please link to or upload a project we can download that reproduces the issue.\r\n\r\n```\r\n  public static func uploadVideo(\r\n    from url: URL, progress: ((Double) -> Void)? = nil, completion: ((String?) -> Void)?\r\n  ) -> UploadRequest {\r\n    let ext = url.absoluteString.split(separator: \".\").last ?? \".binary\"\r\n    return AF.upload(multipartFormData: {\r\n      $0.append(url, withName: \"video\", fileName: \"video.\\(ext)\", mimeType: \"application\/octet-stream\")\r\n    }, to: \"\\(server)file_upload\/\")\r\n    .uploadProgress {\r\n      progress?($0.fractionCompleted)\r\n    }\r\n    .response {\r\n      let data = $0.data ?? Data()\r\n      let string = String(data: data, encoding: .utf8) ?? \"\"\r\n      let json = JSON(parseJSON: string)\r\n      completion?(json[\"url\"].array?.compactMap { $0.string }.first)\r\n    }\r\n  }\r\n```","comments":["Alamofire is built on top of `URLSession` and so isn't responsible for any of its own networking. Uploads are handled by `URLSession` and the raw network connection, as well as the logic dealing with packet loss, are at an even lower level. So there's not much Alamofire can do to impact, or fix, raw network speed. I suggest you investigate further and try to find the bottleneck in your upload operation. One thing to investigate is whether moving away from multipart form uploads and directly uploading the file would improve performance."],"labels":["needs investigation"]},{"title":"Expose response data in `Authenticator.refresh(_:for:completion:)`","body":"* [X] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## Problem\r\n\r\nOur API doesn't use an additional HTTP header to indicate authentication failure, but instead has error codes in the JSON response body. Therefore we must decode and evaluate the `DataRequest.data` in `Authenticator.refresh(_:for:completion:)`.\r\n\r\n## Feature Request\r\n\r\nThe simplest solution would be to change\r\n\r\n```\r\nAuthenticator.didRequest(_ urlRequest: URLRequest, with response: HTTPURLResponse, failDueToAuthenticationError error: Error) -> Bool\r\n```\r\n\r\nto \r\n\r\n```\r\nAuthenticator.didRequest(_ request: Request, failDueToAuthenticationError error: Error) -> Bool\r\n```\r\n\r\nThere is probably a better\/non-breaking approach.\r\n\r\n## Value to Alamofire\r\n\r\nAccommodate a broader variety of API authentication implementations.","comments":["Probably a good idea. We likely don't want to expose the `Request` directly, as there are types which won't have available `Data`, but some method of making it visible would be a good idea."],"labels":["feature request"]},{"title":"Support URLSessionDataTask to URLSessionDownloadTask Upgrades","body":"> \u2139 Please fill out this template when filing a feature request.\r\n> All lines beginning with an \u2139 symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.\r\n>\r\n> Feature requests should code examples whenever possible.\r\n>\r\n> Per our [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md), we use GitHub for\r\n> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.\r\n>\r\n> Please remove this line and everything above it before submitting.\r\n\r\n* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## Problem\r\n\r\nCurrently when I download a file using `AF.download`, if the request fails the error response is downloaded. I'm only interested in the status code and don't want to download the error content, or at least I don't want to download the error content as the file.\r\n\r\n## Feature Request\r\n\r\nProvide a way to either not download the error content, or download it in memory and not to a file.\r\n\r\n## Value to Alamofire\r\n\r\nThis seems like a reasonable way to handle download errors in general, but it seems like Alamofire doesn't provide a way to do it.\r\n","comments":["This could be a useful general feature, not just for downloads but for all request types. We can implement `urlSession(_:dataTask:didReceive:completionHandler:)` and call back to the request to allow for customization. However, `URLSession` only allows for cancellation here, which isn't the greatest experience in the response, so we would probably need to map it into a better value or error.","Further investigation shows that properly supporting this sort of flow (check initial response for a successful code or other success state, download data if it's an error, but download a file to disk if it's a success) is only possible if Alamofire supports turning `URLSessionDataTask`s into `URLSessionDownloadTask`s, which isn't possible given the current architecture. This would be a very challenging design task, as Alamofire would not only need internal changes to support it, but would then need to design an API surface for a `Request` type that provides a mix of `DataRequest` and `DownloadRequest` functionality. A tall order but an interesting challenge. \r\n\r\nGiven that complexity and how easy it is create a custom `ResponseSerializer` that reads the failure `Data` from disk, it's unlikely Alamofire will ever support this functionality. I'll leave this issue open for now, pending further investigation."],"labels":["feature request"]},{"title":"Alamofire should more gracefully handle system interference","body":"At the moment, Alamofire doesn't deal well when system frameworks or the Obj-C runtime interfere with `URLSession` or `URLSessionTask` identity.\r\n\r\nThese include:\r\n* Use of `URLProtocol`, as seen in Wormholy, #3373 \r\n* `URLSession` swizzling, as seen in Splunk MINT and Crittercism, #3238. \r\n* Others.\r\n\r\nThese sort of issues may explain reports of crashes within `RequestTaskMap` where the task identity is changed under the hood.","comments":["Hi, is this problem solved or it is actual bug?","It's an ongoing issue. Not really a bug, more of something Alamofire could detect and either workaround or warn about so users aren't surprised. "],"labels":["needs investigation"]},{"title":"DataStreamRequest should produce the initial response before the stream","body":"As mentioned in #3210, `DataStreamRequest` isn't as useful as it could be right now since it doesn't return the initial response info until after the stream is completed. If we implement [`urlSession(_:dataTask:didReceive:completionHandler:)`](https:\/\/developer.apple.com\/documentation\/foundation\/urlsessiondatadelegate\/1410027-urlsession) we may gain more visibility into the initial responses, as well as the separate boundary responses parsed for us by `URLSession`.\r\n","comments":["For the future person looking at this issue, the flow appears to be:\r\n\r\n- didReceiveResponse (overall)\r\n- didReceiveResponse (chunk)\r\n- data (n times)\r\n- didReceiveResponse (chunk)\r\n- data (n times)\r\n\r\n(etc)\r\n\r\nYou can also find an example server-side implementation in Home Assistant:\r\n\r\nhttps:\/\/github.com\/home-assistant\/core\/blob\/ac3a6aaa8cdb005b3c900f9d9671e5a859351060\/homeassistant\/components\/camera\/__init__.py#L183-L223"],"labels":["feature request"]},{"title":"AF5: sometimes a request just disappears after internal createTask event","body":"* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n**NOTE:** this is almost the same issue as https:\/\/github.com\/Alamofire\/Alamofire\/issues\/3392, but using plain HTTP and only one concurrent request, and we are not creating sessions per request -- just the one Session for all the requests now.\r\n\r\n## What did you do?\r\n\r\nOur iOS app was using Alamofire 4 successfully; as part of upgrading to iOS14, we moved to Alamofire 5. Our application connects to a backend from iPad on wifi. Connection goes over local network to a locally hosted apache webserver.\r\n\r\nOur application isn't doing anything very complicated. It now makes plain HTTP requests, and only one at time (that is limited by an NSOperationQueue with a concurrency limit of 1), using a single Session object which we keep as long as we want to make those requests.\r\n\r\nPseudocode for making our requests in AF5:\r\n\r\n```\r\n\/\/ executed just once\r\nsession = Alamofire.Session([...])\r\n\r\n\/\/ then later, executed many times, only one active at once:\r\nsession.request(url, method: method, parameters: parameters, encoding: encoding, headers: httpHeaders)\r\n        .debug()\r\n        .validate()\r\n        .responseData(emptyResponseCodes: emptyBodyAllowedForCodes) { response in\r\n                   \/\/ handle result\r\n        }\r\n```\r\n\r\n\r\n## What did you expect to happen?\r\n\r\nWe expect all HTTP requests to result in the completion block being called.\r\n\r\n## What happened instead?\r\n\r\nVery occasionally (like, once in thousands of requests), the completion block isn't called, and as far as I can tell, the request is never made to the server (since the logs are missing a corresponding entry around that time).\r\n\r\nI attached an AF Logger and logged everything I could. From that I can see the following in the log for one of the 'dropped' HTTP requests:\r\n\r\n```\r\nHTTPAlamofireRequester.request called...\r\nin AlamoFireRequester: url = http:\/\/redacted\/indexedDocument\/64317069, method = HTTPMethod(rawValue: \"GET\"), headers = [\"Date\": \"Wed, 13 Jan 2021 23:02:47 GMT\", \r\nAHAFLogger session became invalid  = <__NSURLSessionLocal: 0x121110f60>\r\nAHAFLogger requestDidResume: GET http:\/\/redacted\/indexedDocument\/64317069\r\nAHAFLogger didCreateInitialURLRequest: http:\/\/redacted\/indexedDocument\/64317069\r\nAHAFLogger didAdaptInitialRequest: req = http:\/\/redacted\/indexedDocument\/64317069 adapted req =http:\/\/redacted\/indexedDocument\/64317069\r\nAHAFLogger didCreateURLRequest: http:\/\/redacted\/indexedDocument\/64317069\r\nAHAFLogger didCreateTask: task = LocalDataTask <5F05B7E2-C6C0-4F4B-9F42-DBC9C3CEF521>.<1> orig req = Optional(http:\/\/redacted\/indexedDocument\/64317069)\r\n```\r\n\r\nThe `AHAFlogger` lines are reporting Alamofire.Logger callbacks, so are a good sign of progress inside AF.\r\n\r\nAfter the above log lines, there are no more lines mentioning the URL `indexedDocument\/64317069`, and the completion block for that request is never called. So `didCreateTask: task = ` is the last we hear about the request from AF.\r\n\r\nWhen I check the server logs for recent requests, I can't find any trace of the request that seemed to disappear.\r\n\r\nFor comparison, here's the same verbose logging output for an HTTPS request that completed as expected:\r\n\r\n```\r\nNMNM alamoFireRequester: url = http:\/\/redacted\/indexedDocument\/64950467, method = HTTPMethod(rawValue: \"GET\"), headers = [\"Date\": \"Wed, 13 Jan 2021 23:02:41 GMT\", \"X-Nonce\": \"(redacted)\"]\r\nAHAFLogger requestDidResume: GET http:\/\/redacted\/indexedDocument\/64950467\r\nAHAFLogger session became invalid  = <__NSURLSessionLocal: 0x12101bd80>\r\nAHAFLogger didCreateInitialURLRequest: http:\/\/redacted\/indexedDocument\/64950467\r\nAHAFLogger didAdaptInitialRequest: req = http:\/\/redacted\/indexedDocument\/64950467 adapted req =http:\/\/redacted\/indexedDocument\/64950467\r\nAHAFLogger didCreateURLRequest: http:\/\/redacted\/indexedDocument\/64950467\r\nAHAFLogger didCreateTask: task = LocalDataTask <C30B71C0-5EFF-4DC5-9666-476B43B05B58>.<1> orig req = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\nAHAFLogger didResumeTask: LocalDataTask <C30B71C0-5EFF-4DC5-9666-476B43B05B58>.<1>\r\n[connection] nw_resolver_start_query_timer_block_invoke [C810] Query fired: did not receive all answers in time for redacted:443\r\nAHAFLogger didReceiveChallenge: task = LocalDataTask <C30B71C0-5EFF-4DC5-9666-476B43B05B58>.<1>, orig req = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\n[connection] nw_resolver_start_query_timer_block_invoke [C811] Query fired: did not receive all answers in time for redacted:443\r\nAHAFLogger dataTask: didReceive data: origReq = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\nAHAFLogger dataTask: didReceive data: origReq = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\n    [ ... multiple didReceive data lines removed for brevity...]\r\nAHAFLogger dataTask: didReceive data: origReq = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\nAHAFLogger dataTask: willCacheResponse: origReq = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\n[Request]: GET http:\/\/redacted\/indexedDocument\/64950467\r\n    [Headers]:\r\n        Authorization: Basic (redacted)\r\n        Date: Wed, 13 Jan 2021 23:02:41 GMT\r\n        X-Nonce: (redacted)\r\n    [Body]: None\r\n[Response]:\r\n    [Status Code]: 200\r\n    [Headers]:\r\n        Content-Length: 121529\r\n        Content-Type: application\/octet-stream\r\n        Date: Wed, 13 Jan 2021 23:02:40 GMT\r\n        Server: (redacted)\r\n        X-Powered-By: (redacted)\r\n    [Body]: 121529 bytes\r\n[Network Duration]: 0.7587810754776001s\r\n[Serialization Duration]: 2.0541716367006302e-05s\r\n[Result]: success(121529 bytes)\r\n2021-01-13 23:02:41.855298+0000 CMIC PP[9284:9086514] url = http:\/\/redacted\/indexedDocument\/64950467, response code = 200 headers = Optional([AnyHashable(\"Server\"): (redacted), AnyHashable(\"Content-Type\"): application\/octet-stream, AnyHashable(\"Content-Length\"): 121529, AnyHashable(\"X-Powered-By\"): (redacted), AnyHashable(\"Date\"): Wed, 13 Jan 2021 23:02:40 GMT])\r\nSGSG response headers: Optional([AnyHashable(\"Server\"): (redacted), AnyHashable(\"Content-Type\"): application\/octet-stream, AnyHashable(\"Content-Length\"): 121529, AnyHashable(\"X-Powered-By\"): (redacted), AnyHashable(\"Date\"): Wed, 13 Jan 2021 23:02:40 GMT])\r\nSGSG response error: nil\r\nSGSG underlying error: nil\r\n QOQO req done for http:\/\/redacted\/indexedDocument\/64950467, status = 200\r\nAHAFLogger didGatherMetrics: req = GET http:\/\/redacted\/indexedDocument\/64950467 (200)\r\n NMNM caseFileDocumentOperation:didFinishForCaseFile: id = 64950467\r\nAHAFLogger didValidateRequest: req: Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\nAHAFLogger didValidateRequest: req: Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\nNo request created yet.\r\nAHAFLogger didCompleteTask: LocalDataTask <C30B71C0-5EFF-4DC5-9666-476B43B05B58>.<1> orig req = Optional(http:\/\/redacted\/indexedDocument\/64950467)\r\nAHAFLogger requestDidFinish: GET http:\/\/redacted\/indexedDocument\/64950467 (200)\r\nAHAFLogger request(Value): req: GET http:\/\/redacted\/indexedDocument\/64950467 (200) didParseResp: success(121529 bytes)\r\n```\r\n\r\nOf note this is that we get more AF events after the `AHAFLogger didCreateTask:`. And of course the web server log shows these successful requests as 200 OK codes.\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire version: 5.4.1**\r\n**Xcode version: 12.3**\r\n**Swift version: Swift 5 (as per Xcode build settings)**\r\n**Platform(s) running Alamofire: iOS 14.2 on iPad**\r\n**macOS version running Xcode: 11.1**\r\n**Alamofire integration method: Carthage**\r\n**Project language: mixed ObjC + Swift**\r\n\r\n## Demo Project\r\n\r\nApologies, I don't have a demo project at the current time, but wondering if the above info is useful in seeing what the issue could be.\r\n","comments":["Thanks for the detailed report. How many requests are we talking about before a failure occurs? And your server logs show that the request is actually made, it just never calls back to the `Session`?\r\n\r\nI would suggest adding more logging, in addition to what's available through `EventMonitor`, so you can track requests more closely, especially for the `state` of the `Request`. It's odd that you never get additional callbacks for requests that are actually made, since `didCreateTask` is only a few lines away from `didResumeTask`.","Failure to call the completion can happen relatively quickly - in the first 500 requests -- or it can take 10,000 or more. It's really unpredictable. It failed after 8,560 requests just now in a test.\r\n\r\nServer log shows request doesn't reach it. It almost looks like after createTask is logged, AF isn't auto-calling resume internally. I actually disabled auto-resume and manually called resume myself on each request after making it, just to explore that idea, but the problem still occurred. \r\n\r\nI've clarified the issue description to make it clear that the request doesn't seem to hit the server.\r\n\r\nSo it look like the HTTP request isn't even leaving the iPad, but I'd need to use Wireshark or similar to make absolutely sure of that.\r\n\r\nThanks for the state logging idea, I'll do some logging on that and update.","Can you share the code you're using to enqueue requests onto the `OperationQueue`? I set up a simple test and repeatedly ran 100,000 requests to a local test server without issue.","Hi, unfortunately I've run out of time with the client for investigating AF side, and they want to see what the app will do if we just use the usual iOS comms APIs directly.\r\nI'll certainly update you here with the results as it might be useful. It could well be an iOS level comms thing, regardless of Alamofire.\r\n","Hi again, we're still looking at AF. \r\n\r\nI've found that if I run our app in the profiler (using Allocations instrument), we get the issue really fast - within hundreds of attempts, not thousands. Does your example run ok in the profiler?\r\n\r\nProfiler shows the issue quickly for both Debug and Release modes.\r\n","It would be useful if you posted your enqueueing code, otherwise I'm just guessing at how you're enqueueing all of those requests. I'll give it a try in Instruments.","I've created a simple app which runs 10,000 requests in an `OperationQueue` one at a time and haven't been able to replicate a failure. It would be great if you could create a test project which replicates the issue (I can provide my own request URL).","I'll do it if I have time, but client has other ideas. They're asking me to submit a ticket to Apple support about this, against my advice. We all know the result of a TSI will be \"Not our API, not our problem!\"","Have you solved it? I also have the same result. very occasionally and randomly. Do you use Alamofire 4 instead of 5?","Hi, I forgot to provide a information that, I cancel  a request everytime before session request( Base on our app).  I don't know if this will help."," Mark. I also have this question. ","Hi Team, Any update for this issue, we are commonly facing the same issue on iPhone 13 so please let us know how we can deal with and resolve it from our side. \r\nWhen we checked and debugged Alamofire task session **LocalDataTask** did not execute. Our API and Server both are working properly.\r\n\r\n```\r\n [LocalDataTask\r\n<5127CF78-4526-4AE5-9A23-1C2F6C3BDA09>. <70\u203a, LocalDataTask\r\n<6784E32E-4FF1-49E5-A77F-CA43906F5C64>.<71>,\r\nLocalDataTask\r\n<7CA70A66-0B44-434C-9AC9-E7B6897DCBDD>. <72\u203a, LocalDataTask\r\n<2099A752-4499-4524-B144-DC4BBE6DCDF5>. <74>, LocalDataTask\r\n<D10BAEED-CE41-423C-AE1C-01F7D7E50CB8>.<77>, LocalDataTask\r\n<2BD6AE21-DFE9-4F2C-931A-48CD3BEC6511>. <78>, LocalDataTask\r\n<AEF68696-7385-4545-90EA-8EAE62214A92>.<79>,\r\nLocalDataTask\r\n<79E98006-D02E-42DB-BA08-D706EC30CE33>. <80>,\r\nLocalDataTask\r\n<9568184D-8658-4971-82C6-9D7E6C8F1280>.<81>,\r\nLocalDataTask\r\n<7212BADF-C4DF-4E31-A5D3-80F60883D584>. <82>,\r\nLocalDataTask\r\n<A23108C1-E527-460F-9FB1-CDC6AF7FE37A>. <83>, LocalDataTask\r\n<B0C30D69-36A0-4906-A7CE-549A259B014B>. <84>, LocalDataTask\r\n<B706454C-A4A7-4D61-859E-48A12EFAD736>.<85\u203a, LocalDataTask\r\n<014E64D4-2571-4875-9BC4-6FDABF@CAC15>. <86>, LocalDataTask\r\n<BOD&CADE-D88E-4D99-B915-36092524A185>.<87>, LocalDataTask\r\n<AD3B5D9D-4B3C-448A-A944-C90D6AB1D8F1>) <88>,\r\nLocalDataTask\r\n<34900E16-187-4A85-AE27-ABAE801E5D0B>.<89>,\r\nLocalDataTask\r\n<5E81D5EF-F18F-4CE7-BCFE-281597C68EC1>, <90> ]\r\n\r\n```"],"labels":["needs investigation"]},{"title":"Network Error Logging Support","body":"\r\n* [* ] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\n[NEL (network error logging)](https:\/\/www.w3.org\/TR\/network-error-logging\/) is not supported in AlamoFire.\r\n\r\n## What did you expect to happen?\r\n\r\nClients using AlamoFire should be able to submit NEL reports using the Report-To header in HTTP.  This means understanding network failures on the device such as TCP timeouts, resets, aborts, TLS certificate failures, DNS failures, and protocol failures.   \r\n\r\n## What happened instead?\r\n\r\nMobile clients that want to use Network Error Logging cannot upload network error reports to targeted endpoints.\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire version:** all\r\n**Xcode version:** all\r\n**Swift version:** all\r\n**Platform(s) running Alamofire:** all\r\n**macOS version running Xcode:** all\r\n\r\n## Demo Project\r\n\r\nAs this is a new feature, any project will reproduce the issue.\r\n","comments":["While it's unlikely we'd actually support the NEL standard (it's complex and seems to be of rather limited utility), an analysis of what would be need for support outside Alamofire itself would be a good idea to guide future development.","Hey jon, thanks for responding.  If someone were to build support for this, would it be something you would be willing to accept upstream?","Probably not. Enabling it as an external library would be our goal.","So as a library that you can load into Alamofire?  Makes sense."],"labels":["feature request"]},{"title":"AuthenticationInterceptor 'refresh' delegate called many times for multiple requests","body":"> \u2139 Please fill out this template when filing an issue.\r\n> All lines beginning with an \u2139 symbol instruct you with what info we expect. You can delete those lines once you've filled in the info.\r\n>\r\n> Per our [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md), we use GitHub for\r\n> bugs and feature requests, not general support. Other issues should be opened on Stack Overflow with the tag `alamofire`.\r\n>\r\n> Please remove this line and everything above it before submitting.\r\n\r\n* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\n```\r\nimport Alamofire\r\nimport SwiftyJSON\r\n\r\nstruct OAuthCredential: AuthenticationCredential {\r\n    let accessToken: String\r\n    let refreshToken: String\r\n    let expiration: Date\r\n\r\n    \/\/ Require refresh if within 5 minutes of expiration\r\n    var requiresRefresh: Bool { Date(timeIntervalSinceNow: 60 * 5) > expiration }\r\n}\r\n\r\nclass OAuthAuthenticator: Authenticator {\r\n    func apply(_ credential: OAuthCredential, to urlRequest: inout URLRequest) {\r\n        urlRequest.headers.add(.authorization(bearerToken: credential.accessToken))\r\n    }\r\n\r\n    func refresh(_ credential: OAuthCredential, for session: Session, completion: @escaping (Result<OAuthCredential, Error>) -> Void) {\r\n        \r\n        NetworkManager.shared.oauth.doRefreshToken { (jsonDict, error) in\r\n            if let jsonDict = jsonDict {\r\n                let json = JSON(jsonDict)\r\n                let accessToken = json[\"access_token\"].stringValue\r\n                let refreshToken = json[\"refresh_token\"].stringValue\r\n                let expiration = json[\"expires_in\"].doubleValue\r\n                let newCredential = OAuthCredential(accessToken: accessToken, refreshToken: refreshToken, expiration: Date(timeIntervalSinceNow: expiration))\r\n                completion(.success(newCredential))\r\n            }\r\n        }\r\n    }\r\n\r\n    func didRequest(_ urlRequest: URLRequest, with response: HTTPURLResponse, failDueToAuthenticationError error: Error) -> Bool {\r\n        return response.statusCode == 401\r\n    }\r\n\r\n    func isRequest(_ urlRequest: URLRequest, authenticatedWith credential: OAuthCredential) -> Bool {\r\n        let bearerToken = HTTPHeader.authorization(bearerToken: credential.accessToken).value\r\n        return urlRequest.headers[\"Authorization\"] == bearerToken\r\n    }\r\n}  \r\n```\r\n\r\n## What did you expect to happen?\r\n\r\n\u2139 'refresh' delegate method will be called once to refresh token and then recall all the other requests with new credentials\r\n\r\n## What happened instead?\r\n\r\n\u2139 'refresh' delegate method is called for each request when 'requiresRefresh' is set\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire version: 5.2.2**\r\n**Xcode version: 11.7**\r\n**Swift version: 4.2**\r\n**Platform(s) running Alamofire: iOS**\r\n**macOS version running Xcode: 10.15.6 (19G2021)**\r\n\r\n## Demo Project\r\n\r\n\u2139 Cannot provide demo project\r\n","comments":["@cnoon Can you take a look?","Did you find a solution for this.","Where is 'completion(.failure(error))' in 'func refresh(_ credential: OAuthCredential, for session: Session, completion: @escaping (Result<OAuthCredential, Error>) -> Void)'?\n\nAnd Are you sure you chose the correct initializer? In 'Date(timeIntervalSinceNow: expiration)' ?"],"labels":["support"]},{"title":"Support for SPKI","body":"* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\nSorry for opening a separate issue for this. I'm trying to draw attention to https:\/\/github.com\/Alamofire\/Alamofire\/issues\/2678 which has been closed but seems to have no clear resolution. The PR for it was never merged (https:\/\/github.com\/Alamofire\/Alamofire\/pull\/2680) but the issue seemed to be going in a favorable direction for adding support.\r\n\r\nIf there is no interest in adding SPKI support to alamofire perhaps we could close the PR and state so in the original issue so that future users will know not adding it was a deliberate decision.\r\n\r\nShould the maintainers believe SKPI support has value, could we perhaps reopen the original issue until the PR is merged?\r\n\r\nBest,\r\n","comments":["We've discussed adding SPKI support in the past. However, due to the complexity of the feature we decided not to merge the existing PR. Instead, we feel that the feature needs to be built by the Alamofire core team itself, both to develop the expertise necessary to implement and maintain the feature long term, as well as to mitigate the risk of the feature by developing it within the foundation. So while we think the feature would be a useful addition to Alamofire, its complexity, risk, and lower community value have prioritized it lower than our other work on the library.\r\n\r\nI'll keep this issue open to track the feature. If anyone has important services or use cases that would benefit from this feature, please let us know.","@jshier, \r\n\r\nThanks for following up on this and for keeping this open for visibility. I'll update the issue description with data from #2678 so anyone jumping in can understand what the feature is about.\r\n\r\nIt's a shame the original pull request did not make it. I understand the reservations of the maintainers even if I disagree (I think with a few changes the PR could probably reach a testable enough state to be included as an experimental feature.)\r\n\r\nSince the current decision is that this is something only the maintainers can do, could you help me understand how the team currently prioritizes feature requests? What should the community do to indicate they see value in this feature?\r\n\r\nBest,","To be clear, there wasn't necessarily anything wrong with the original PR. It's just that, given the risks involved, we decided we should build the feature ourselves. We can't really ship experimental security features in a library as widely used as Alamofire. If anyone really wants the functionality provided by the PR, `ServerTrustEvaluating` is designed to be extensible, so the functionality could live in a separate library as a separate project and it would work just fine (without the custom error integration). \r\n\r\nAs to feature prioritization, there is no formal process, but there are a few considerations that must be balanced.\r\n\r\n1. How much time do we have available? There are only two of us that work on the project and we already have full time jobs and personal lives, so our availability varies quite a bit. When it comes down to it, features that can be implemented in the time we have available are more likely to be worked on than features that may take weeks or months of free time.\r\n2. How complex is the feature? Is it easy to implement and test, or will it require a significant refactor? We have a few in flight PRs that add the ability to be notified when a `Request` creates a `URLRequest` or `URLSessionTask`. These were rather easy to build and test, so prioritizing them was pretty easy.\r\n3. Does it unlock a new capability for the library? `DataStreamRequest` is a good example here. We'd removed the ability to stream a `DataRequest` in Alamofire 5, so I thought it was important to bring the functionality back despite the rather complex and time consuming (it took two months to design and implement, and still had underlying bugs) nature of the feature. \r\n4. Does it need to live in the library? Again, `DataStreamRequest` is a good example here. We don't yet have the ability for users to create custom `Request` types, so if we wanted the functionality it had to live in Alamofire itself, not an external library.\r\n5. How important or popular is the feature in the community? Is it something that people need to do all the time, or is it something that's only done rarely? A good example here is the recently added `AuthenticationInterceptor`. It helps users integrate with common authentication flows in a way that helps reduce bugs and eliminate boilerplate from many codebases. Despite its higher difficultly we thought it was important to include due to the common need and how difficult it can be for users to implement themselves.\r\n6. How risky is the feature for the library? This concern largely applies to features with a security impact but also applies to features that can be easily used improperly. For a library as popular as Alamofire, bugs can hit thousands of apps. Security bugs that have that sort of impact *must* be avoided. \r\n\r\nEvery choice to work on a feature is done balancing those concerns. For this SPKI functionality, the time it would take to become comfortable with the standard and implement a solution, the complexity of the solution and testing, the ability for users to build it outside of Alamofire, it's relative unpopularity (it's not even an accepted IETF standard), and riskiness of the feature are all considered in making it a lower priority feature. ","Hi @jshier did you get any solution for SSL pinning without certificate or certificate data? I want to do SSL pinning using alamofire but by using jus public key.","@rohitdhawan As someone who previously asked for this feature, here are some points:\r\n\r\nCertificate Pinning has recently fallen out of favour quite drastically amongst Info Sec specialists. I would advise reviewing the following article prior to doing it: https:\/\/www.digicert.com\/blog\/certificate-pinning-what-is-certificate-pinning \r\n\r\nShould you choose to pin anyways then I would advise the following alternatives to accomplish SPKI pinning:\r\n1. Leverage NSAppTransportSecurity to configure globally for your app. https:\/\/developer.apple.com\/news\/?id=g9ejcf8y has a great tutorial on this. I would advise this if you are building an app as it means even if users leverage URLSession or the default AF session pinning would still apply.\r\n2. Use [TrustKit](https:\/\/github.com\/datatheorem\/TrustKit) to pin the keys and wrap it in an `ServerTrustEvaluating` implementation such as below, which you can then use just like any other evaluator. I would advise this if you are building a framework as you won't be in control of the Info.plist and so would not be able to do the above.\r\n\r\n```swift\r\nstruct TrustKitServerTrustEvaluator: ServerTrustEvaluating {\r\n    let trustKit: TrustKit\r\n\r\n    func evaluate(_ trust: SecTrust, forHost host: String) throws {\r\n        let result = trustKit.pinningValidator.evaluateTrust(trust, forHostname: host)\r\n        switch result {\r\n        case .shouldBlockConnection:\r\n            throw AFError.serverTrustEvaluationFailed(reason: .publicKeyPinningFailed(host: host, trust: trust, pinnedKeys: [], serverKeys: []))\r\n        case .domainNotPinned, .shouldAllowConnection:\r\n            return\r\n        @unknown default:\r\n            return\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBest!","@CaioSym a Big Thank you for your reply :). "],"labels":["feature request"]},{"title":"Support custom packet size and delay in MultipartForm uploads","body":"In AFNetworking we can  upload a file  custom packet size and delay time like this\r\n`throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes\r\n                                  delay:(NSTimeInterval)delay;`\r\nbut  how can i do with Alamofire?thanks!","comments":["There is no equivalent in Alamofire, as it does not use streams for uploads. It's unlikely we'd ever add support for this, but what's your use case?","hi jishier\uff0cthanks for response\u3002Our server needs to limit the form data packet to 2kb when uploading files, and the time interval for each write is 100ms. In AFNetworking, I can set up like this\uff1a\r\n```\r\n    AFHTTPSessionManager *up = [AFHTTPSessionManager manager];\r\n    NSString *url = \"\";\r\n    [up POST:url parameters:nil headers: nil constructingBodyWithBlock:^(id<AFMultipartFormData>  _Nonnull formData) {\r\n        [formData appendPartWithFileURL:path name:path.absoluteString error:&errors];\r\n        \/\/write stream 2kb each 100ms\r\n        [formData throttleBandwidthWithPacketSize:2048 delay:0.1];\r\n    } progress:^(NSProgress * _Nonnull uploadProgress) {\r\n        \/\/do something\r\n    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\r\n        \/\/do something\r\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\r\n        \/\/do something\r\n    }];\r\n```","You can get the same functionality by creating your own `OutputStream` with the appropriate settings, which you then use with `upload` directly. If you need multipart encoding, you'd have to do that manually as well. Since Alamofire doesn't use streams most of the time, it's unlikely we'll add native support.","hey @jshier \uff0ci find source code in `MultipartFormData.swift`, in `BodyPart` class i find InputStream,so i think that i can subclass MultipartFormData ,then custom  InputStream write progress and delay time?\r\n![image](https:\/\/user-images.githubusercontent.com\/25734166\/84334629-646d1980-abc5-11ea-9afa-d5ee464a6453.png)\r\n","Good point. This needs a bit more investigation."],"labels":["feature request"]},{"title":"DataPreprocessor doesn't have it's own failure reason","body":"Alamofire 5 added a `DataPreprocessor` protocol to enable the easy filtering of `Data` before processing, mainly to strip various headers in front of JSON. Unfortunately, when the protocol was added, no corresponding `ResponseSerializationFailureReason` was added, meaning the failure of a `DataPreprocessor` will be encapsulated in a `.customSerializationFailed` reason. Luckily, none of the current `DataPreprocessor`s produce errors, so we may never see this issue. \r\n\r\nFixing this will require a major version change due to the addition of an enum case.","comments":[],"labels":["bug"]},{"title":"Path Encoding support","body":"Hello !\r\nI was going through Alamofire's documentation to find support for Path Encoding support but after searching I found out that it currently does not support this by default, since I supervise both Android \/ iOS development this is a key feature that I've found in a library called Retrofit (which is the counterpart for Alamofire in android) and it's missing here.\r\n\r\n## What did you do?\r\n\r\nTried to use path encoding\r\n\r\n## What did you expect to happen?\r\n\r\nTo find support for path encoding\r\n\r\n## What happened instead?\r\n\r\nI didn't find path encoding support\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire version: Any\r\n**Xcode version: Any\r\n**Swift version: Any\r\n**Platform(s) running Alamofire: iOS\r\n**macOS version running Xcode: Any\r\n\r\nI've rolled my own PathEncoding which is basically this short 16-line struct that implements ParameterEncoding.\r\n\r\n```Swift\r\nstruct PathEncoding: ParameterEncoding {\r\n    \r\n    public static var `default`: PathEncoding { return PathEncoding() }\r\n    \r\n    func encode(_ urlRequest: Alamofire.URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {\r\n        guard let parameters = parameters else { return try urlRequest.asURLRequest() }\r\n        var urlRequest = try urlRequest.asURLRequest()\r\n        if var url = urlRequest.url?.absoluteString.removingPercentEncoding {\r\n            for parameter in parameters {\r\n                url = url.replacingOccurrences(of: \"{\\(parameter.key)}\", with: \"\\(parameter.value)\")\r\n            }\r\n            guard let url = URL(string: url) else { return try urlRequest.asURLRequest() }\r\n            urlRequest.url = url\r\n        }\r\n        return urlRequest\r\n    }\r\n\r\n}\r\n```\r\n\r\nThe idea is that the url has to contain the parameters in curly braces I.E:\r\n\r\n```\r\nhttps:\/\/google.com\/{someId}\r\n```\r\n\r\nThen parameters dictionary will need to be filled with the same exact keys from the URL.\r\n\r\n```Swift\r\nrequest(\"https:\/\/www.google.com\/{someId}\".addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!, method: .get, parameters: [\"someId\": \"123\"], encoding: PathEncoding.default, headers: nil)\r\n```\r\n\r\nThe path encoder will then decode the encoded url (since Alamofire will encode it automatically if URLRequestConveritble is used or the user will have to specifically do .addingPercentEncoding or Alamofire will fail to create the curl command)\r\n\r\nAnd finally it's going to replace each parameter with its correspondent value from the parameters dictionary and the result request will be something like this\r\n\r\n<img width=\"470\" alt=\"Screen Shot 2019-12-16 at 11 52 11\" src=\"https:\/\/user-images.githubusercontent.com\/45688300\/70897036-8876e600-1ffa-11ea-9ffc-0423af140d1f.png\">\r\n  \r\nThanks !","comments":["Path encoding is something we've been trying to find an elegant solution for for years now, without success. The solution you've outlined has been considered, but it's fragile, inflexible, and incompatible with the `Encodable` parameter types adopted in Alamofire 5 (barring a custom `Encoder`).\r\n\r\nWithout a new approach to parameters that can encompass query, body, and path parameter types from a single value, I've used a few approaches over the years, all revolving around the router pattern outlined in our [Advanced Usage docs](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/Documentation\/AdvancedUsage.md#routing-requests). In my most recent usage, which will make it into the Advanced Usage documentation eventually, I pair `Encodable` parameters with a router that contains any path-specific values. For instance, to get some object from a particular user:\r\n\r\n```swift\r\nstruct MessagesRequest: Encodable {\r\n    let count: Int\r\n    let sorted: Bool\r\n}\r\n\r\n\/\/ Router is usually abstracted behind a protocol.\r\nenum UserRouter {\r\n    case messages(userID: String)\r\n}\r\n\r\nstruct Request<Parameters: Encodable>: URLRequestConvertible {\r\n    let parameters: Parameters\r\n    let router: UserRouter\r\n\r\n    func asURLRequest() throws -> URLRequest { ... }\r\n}\r\n\r\n...\r\n\r\nfunc fetchMessages(forUser userID: String, count: Int = 10, sorted: Bool = true) {\r\n    let parameters = MessageRequest(count: count, sorted: sorted)\r\n    let route = UserRouter.message(userID: userID)\r\n    AF.request(Request(parameters: parameters, router: route)).response { ... }\r\n}\r\n```\r\n\r\nThis pattern can be extended to any number of routers and parameter combinations. \r\n\r\nIf an actual path encoder is desired, then I think something beyond simple pattern replacement needs to be created. Perhaps something using custom string interpolation, or some sort of type-safe URL definition that requires particular types as particular parameters.\r\n\r\nI'll leave this issue open, as this requires more discussion.","I've recently started using Vapor for some backend work and they have a [`PathComponents`](https:\/\/github.com\/vapor\/routing-kit\/blob\/master\/Sources\/RoutingKit\/PathComponent.swift) type which may be a useful approach here, though it would be a rather significant addition to Alamofire.","Their approach seems very elegant, if implemented properly it could prove very beneficial, since the approach I implemented above had some hiccups when I had to mix query parameters \/ body parameters with path parameters, so I had to fall back to string manipulation essentially without specifying an entire \"encoding\".\r\n\r\nBasically I created my own URLRequestConveritble which looks like the following\r\n\r\n```Swift\r\nimport Alamofire\r\n\r\nprotocol URLRequestConvertible: Alamofire.URLRequestConvertible {\r\n    \r\n    var method: HTTPMethod { get }\r\n    var parameters: [String: Any]? { get }\r\n    var pathParameters: [String: Any]? { get }\r\n    var url: URL { get }\r\n    var encoding: ParameterEncoding { get }\r\n    \r\n}\r\n\r\nextension URLRequestConvertible {\r\n    \r\n    func asURLRequest() throws -> URLRequest {\r\n        let url = self.url.withPathParameters(pathParameters)\r\n        var urlRequest = URLRequest(url: url)\r\n        urlRequest.httpMethod = method.rawValue\r\n        return try encoding.encode(urlRequest, with: parameters)\r\n    }\r\n    \r\n}\r\n```\r\n\r\nAnd the \"withPathParameters\" is an extension for URL\r\n\r\n```Swift\r\nextension URL {\r\n    \r\n    func withPathParameters(_ parameters: [String: Any]?) -> URL {\r\n        guard var urlString = self.absoluteString.removingPercentEncoding, let parameters = parameters else { return self }\r\n        \r\n        for parameter in parameters {\r\n            urlString = urlString.replacingOccurrences(of: \"{\\(parameter.key)}\", with: \"\\(parameter.value)\")\r\n        }\r\n        \r\n        guard let url = URL(string: urlString) else { return self }\r\n        return url\r\n    }\r\n    \r\n}\r\n```\r\n\r\nThis allowed me to add mix path parameters with query parameters \/ body parameters.","+1 for a better way to support parameters in body and query"],"labels":["feature request","needs investigation","needs feedback"]},{"title":"[Alamofire 5] Upload API Access Control ","body":"```\r\nfunc upload(_ uploadable: UploadRequest.Uploadable,\r\n                with convertible: URLRequestConvertible,\r\n                interceptor: RequestInterceptor?,\r\n                fileManager: FileManager) -> UploadRequest {\r\n        let uploadable = Upload(request: convertible, uploadable: uploadable)\r\n\r\n        return upload(uploadable, interceptor: interceptor, fileManager: fileManager)\r\n    }\r\n```\r\nwhy this method access Control is `internal`, I need `open`  access Control to when i using Alamofire to custom design my business network, i don't know why ? ","comments":["Why do you need this method to be public? It's internal because it's an implementation detail of our upload handling.","```\r\nWhy do you need this method to be public? \r\n```\r\nBecauese i want to encapsulate a universal method for upload instead of call several APIs.\r\n\r\n```\r\n\/\/\/ Type describing the origin of the upload, whether `Data`, file, or stream.\r\n    public enum Uploadable {\r\n        \/\/\/ Upload from the provided `Data` value.\r\n        case data(Data)\r\n        \/\/\/ Upload from the provided file `URL`, as well as a `Bool` determining whether the source file should be\r\n        \/\/\/ automatically removed once uploaded.\r\n        case file(URL, shouldRemove: Bool)\r\n        \/\/\/ Upload from the provided `InputStream`.\r\n        case stream(InputStream)\r\n    }\r\n```\r\nIf as you said, the code above make me confused\uff0cwhy you make the  `Uploadable` enum to be public, i think it useless for me.","`Uploadable` being `public` is a byproduct of the `UploadRequest` initializer previously being `public`. It's not really well designed for public consumption, but we'll consider it."],"labels":["needs feedback"]},{"title":"Feature Request: Support URLSessionWebSocketTask","body":"iOS 13 adds direct support for web sockets into URLSession https:\/\/developer.apple.com\/documentation\/foundation\/urlsession\/3181172-websockettask?changes=latest_minor\r\n\r\nAre there any plans to support it?\r\n\r\n\r\n* [X] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).","comments":["It depends on the functionality people would want and what Alamofire can offer. Our expertise with WebSockets is limited, and there's not currently much documentation, so we'd need input from the community about what the experience should look like.","You can read here:\r\nhttps:\/\/github.com\/daltoniam\/Starscream","I've been exploring `URLSessionWebSocketTask` more and a wrapper should be doable, but it's a strange beast, so it's going to be a while to get a really great wrapper out of it. We could have a similar to API to the [`DataStreamRequest`](https:\/\/github.com\/Alamofire\/Alamofire\/pull\/3074) type that will be added soon, but we'll have to also make allowances for sending `Data` as well as receiving.","@jshier Hey! Do you have any references regarding this `URLSessionWebSocketTask ` beast? \nI\u2019d love to contribute to it or at least help you finish the `DataStreamRequest` :)","For `URLSessionWebSocketTask` I'm still in the exploration phase of figuring out how it really works. So far I've found that if you don't set a receive closure, it doesn't disconnect correctly, which is not documented. Also, if the server sends the close message, you always get an error in the receive closure despite also getting the didClose delegate callback, which isn't documented either. So more information about how it behaves will help inform building the wrapper. Additionally, real world uses of websockets at this level would be nice, as I've never used them. \r\n\r\nAs for `DataStreamRequest`, it's pretty much done, so I think the most helpful thing there is to try it out and validate its use in real world scenarios.","@jshier, so is it a viable option for me to start exploring & experimenting with `URLSessionWebSocketTask`?\r\n\r\nI mean how feasible is it that it will end up being a feature and is it worth looking into?","Feel free to start your own exploration of `URLSessionWebSocketTask`, the more information gathered the better. We would definitely like to add support, so I think the only blocker would be some sort of requirement that's incompatible with Alamofire's core architecture. I don't anticipate this coming soon, as we still need to finish 5.1 and 5.2 will likely be the Combine release, but soonish.","@jshier, \ud83d\udc4c\r\nI'll update this thread as I will gather more info and ping you correspondingly","I've started a prototype implementation on the `feature\/websocket-request` branch. "],"labels":["feature request","needs investigation"]},{"title":"Support Request Subclasses","body":"Currently, `Session` uses type-specific `perform` methods to start the different types of `Request`s it supports, due to different requirements in lifecycles of the `Request` subclasses:\r\n```swift\r\nfunc perform(_ request: Request) {\r\n    switch request {\r\n    case let r as DataRequest: perform(r)\r\n    case let r as UploadRequest: perform(r)\r\n    case let r as DownloadRequest: perform(r)\r\n    default: fatalError(\"Attempted to perform unsupported Request subclass: \\(type(of: request))\")\r\n    }\r\n}\r\n```\r\nThis limitations means no new subclasses of `Request` can be created without updating the core library, making it impossible for users to create types to support, say, stream, or `AVAssetDownloadTask`. It also means that added new `Request` types internally is unnecessarily complex. We should come up with a solution for this issue. Most likely we'll need to abstract and formalize the various lifecycle methods required for `Session` to `Request` communication. However, this is complicated by queueing concerns and the differences between the `Request` types and requires more thought.","comments":["Deferring this until later in the 5 development cycle.","Worth noting that deferring this blocks fixing the loss of streaming in v5 [DataRequest.stream gone in AF5](https:\/\/github.com\/Alamofire\/Alamofire\/issues\/2843)","It doesn\u2019t really, as we could add new subclasses at any time. This issues tracks public subclassability. PRs are welcome for streaming and WebSocket request types.  "],"labels":["enhancement"]},{"title":"Download task file system permissions","body":"Hey hey! \ud83d\udc4b\r\n\r\nAlamofire is using `URLSessionDownloadTask` for download tasks and the file created under the temporary directory by `URLSessionDownloadTask` has file system permissions set to `-rw-------`. (To be honest, I'm not sure why that is.) Alamofire then moves this file to the location provided by the user, keeping the permissions intact.\r\n\r\nThese default permissions are unlike most use cases, where they're set to `-rw-r--r--`:\r\n- Downloading the file through the browser\r\n- Downloading the file using a tool like `wget`, `curl`\r\n- Downloading the file using AFNetworking\r\n- Using Alamofire, requesting the file as a data object then writing to file\r\n\r\nEither by default or when an option is provided, Alamofire could set the permissions up after moving the file from the temporary directory. I wanted to reach out and gather some feedback on this.\r\n\r\n---\r\n\r\n* [x] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\nUsed `DownloadTask` to download a file to a url, on macOS.\r\n\r\n## What did you expect to happen?\r\n\r\nThe downloaded file to have the same file system permissions (by default), as downloading the same file through a browser, using a tool like `wget` or another networking library like AFNetworking: `-rw-r--r--`.\r\n\r\n## What happened instead?\r\n\r\nThe downloaded file has a file system permission of `-rw-------`, not letting other users to access the file.\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire version:** 4.7.2\r\n**Xcode version:** 9.3.1\r\n**Swift version:** 4.1\r\n**Platform(s) running Alamofire:** macOS\r\n**macOS version running Xcode:** 10.13.4 (17E202)","comments":["Thanks for the report! This is an interesting difference that doesn't make much sense. AFNetworking moves it's file like this:\r\n```objc\r\n[[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&fileManagerError]\r\n```\r\nAlamofire moves it like this: \r\n```swift\r\ntry FileManager.default.moveItem(at: url, to: destinationURL)\r\n```\r\nAs far as I can tell, there shouldn't be any difference there. And neither library set any additional properties on the file, like special POSIX permissions. \r\n\r\nWe could easily add said permissions, but I'd rather figure out why this is happening first, and if it's something that does need to change, integrate a way for users to control the behavior rather than just having Alamofire set the permissions directly.\r\n\r\nAlso, you wouldn't happen to have a quick demo app to replicate this, would you? It's been a while since I've built a Mac app.","Right, moving doesn't cause the issue actually. Basically the temporary file created by `URLSessionDownloadTask` has these permissions by default.\r\n\r\nI just realized that AFNetworking uses `URLSessionDownloadTask` as well. So the results are the same for Alamofire and AFNetworking indeed\u2014sorry for the confusion there.\r\n\r\nHonestly, I'm not sure why the file created by `URLSessionDownloadTask` has these permissions though. Instead of using a download task, if I make a request to the same url and write the response data to file manually, permissions are set to `-rw-r--r--`.\r\n\r\nI've demonstrated that in the sample project here: https:\/\/github.com\/berkcebi\/down\r\n\r\n","I'm guessing this happens because it's the safe default for file downloads, plus most users never need to make files available to other users. \r\n\r\nThat being said, since the file URL is available in the `DownloadResponse`, what would there be for Alamofire to do here? Users can easily change permissions in their response handlers, so I'm not sure there's a better solution here. I'm reluctant to do anything automatically since Apple's behavior seems to be the safe default. So what would you want here?","I definitely see your point on sticking with Apple's behaviour, if it is indeed a safe default for downloads. In that case, wouldn't you expect to have the same permissions for files downloaded through say, Safari though?\r\n\r\nAs mentioned on [`URLSessionDownloadTask` documentation](https:\/\/developer.apple.com\/documentation\/foundation\/urlsessiondownloadtask), the file created is placed in a temporary directory and should be moved or consumed right away when the task is complete. The fact that it's a temporary file might also be the reason why the permissions are set this way actually.\r\n\r\nAlamofire offers a quick way to move the temporary file via `DownloadFileDestination`. While moving the file, if a common practice is to update the file permissions, this might be added as an option to `DownloadFileDestination` as well. Does this make sense?","I'll add this as a feature request, though it's unlikely we'll get to it for the initial Alamofire 5 release.","Thanks @jshier! I'd be happy to contribute actually. If this makes sense to you as well, I can start working on it.","Same issue on iOS, Alamofire 4.8.x\r\n\r\nFor those of you who cannot wait for an Alamofire fix and need to set the perms to `644`(or `\r\n-rw-r--r-` as cited by @berkcebi above):\r\n\r\n```\r\n    do {\r\n        \/\/ need to manually set 644 perms: https:\/\/github.com\/Alamofire\/Alamofire\/issues\/2527\r\n        try FileManager.default.setAttributes([FileAttributeKey.posixPermissions: NSNumber(value: 0o644)], ofItemAtPath: file.path)\r\n    } catch {\r\n        \/\/ catch your error\r\n    }\r\n```"],"labels":["feature request"]},{"title":"cookies not shown in cURLRepresentation","body":"* [\u2713] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).\r\n\r\n## What did you do?\r\n\r\nWhen disabled cookies in session manager config like:\r\n```\r\nlet configuration = URLSessionConfiguration.default\r\nconfiguration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders\r\nconfiguration.httpShouldSetCookies = false\r\n```\r\nThen set a cookies use request header like:\r\n```\r\nlet header = HTTPCookie.requestHeaderFields(with: cookies)\r\nrequest(url, method: method, parameters: parameters, encoding: encoding, headers: header)\r\n```\r\nThen the cookies will not shown in Request.cURLRepresentation function.\r\n\r\n## What did you expect to happen?\r\n\r\nShow cookies when  called cURLRepresentation().\r\n\r\n## What happened instead?\r\n\r\nThe cookies witch set in header will not shown in Request.cURLRepresentation function.\r\n\r\n## Alamofire Environment\r\n\r\n**Alamofire version:** ~> 4.5\r\n**Xcode version:** 9.2\r\n**Swift version:** 4.0\r\n**Platform(s) running Alamofire:** iOS\r\n**macOS version running Xcode:** 10.13.2\r\n\r\n","comments":["I created a pull request for fix this\r\nhttps:\/\/github.com\/Alamofire\/Alamofire\/pull\/2436"],"labels":["bug"]},{"title":"Feature Request: CRUD Router protocol oriented approach","body":"Before submitting a PR, I wanted to ask if the following `Routable` pattern would fit within the scope of Alamofire and if so, could it be added?  \r\n\r\nBelow you will find a link to the blog post explaining it, along with the example project. \r\n\r\n- Blog post: [Rethinking Routers in Swift using Protocol Oriented Programming](https:\/\/chaione.com\/blog\/routers-swift-protocol-oriented-1\/)\r\n- Example: [Routable](https:\/\/github.com\/chaione\/RoutableApp)\r\n\r\nIn summary, the blog post uses a different approach to achieve the same goal as the `enum Router`.\r\n\r\nUsing `Routable`, we are able to reduce the example found in [Crud & Authorization](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/Documentation\/AdvancedUsage.md#crud--authorization) to the following:\r\n\r\n```swift\r\nstruct Router: URLRouter {\r\n    static var basePath: String {\r\n        return \"https:\/\/example.com\"\r\n    }\r\n\r\n    struct User: Readable, Creatable, Updatable, Deletable {\r\n        var route: String = \"users\"\r\n        var urlParams: String!\r\n    }\r\n}\r\n```\r\n\r\n* [X] I've read, understood, and done my best to follow the [*CONTRIBUTING guidelines](https:\/\/github.com\/Alamofire\/Alamofire\/blob\/master\/CONTRIBUTING.md).","comments":["An interesting approach. We've discussed different solutions to the huge router problem for a while and haven't yet formalized a solution. I'm currently using this protocol to break the different aspects of the router into types:\r\n\r\n```swift\r\npublic protocol RequestConvertible: URLRequestConvertible {\r\n    var parameters: Parameters? { get }\r\n    var route: Router { get }\r\n}\r\n```\r\n\r\nThis allows me to combine a simplified `Router` (really could just be a separate protocol), which describes the base URL, path, HTTP method, and parameter encoding, from the parameters of a request. `RequestConvertible` also has a default implementation of `asURLRequest()`:\r\n\r\n```swift\r\nextension RequestConvertible {\r\n    public func asURLRequest() throws -> URLRequest {\r\n        var url = route.baseURL\r\n        url.appendPathComponent(route.path)\r\n        var request = URLRequest(url: url)\r\n        request.httpMethod = route.method.rawValue\r\n        \r\n        return try route.parameterEncoding.encode(request, with: parameters)\r\n    }\r\n}\r\n```\r\n\r\nThis allows me a very simple pattern:\r\n```swift\r\nstruct LoginRequest {\r\n    let username: String\r\n    let password: String\r\n}\r\n\r\nextension LoginRequest: RequestConvertible {\r\n    var parameters: Parameters? {\r\n        return [\"username\": username,\r\n                \"password\": password]\r\n    }\r\n\r\n   var route: Router {\r\n        return .login\r\n    }\r\n}\r\n```\r\nTo me, this separation of how to make a request vs. what should be in the request allows for a cleaner set of responsibilities than every request type having to implement those values itself. What would be even better here is something to automatically (at least in some cases) generate the parameters to be encoded by the request.\r\n\r\nThe protocols you've described make a lot of assumptions about how an API works, so I'm not sure they offer the flexibility needed by a library like Alamofire. There isn't always a 1:1 mapping between the action being taken by a call and the HTTP method used to make it (unfortunately), so it doesn't seem like a good idea to encode such ideas into the protocols.","@initFabian I have created a library on top of Alamofire [Restofire](https:\/\/github.com\/Restofire\/Restofire) in which every api request is a separate file which makes it very easy to maintain and expand. Though it doesn't solve the router issue but solves the vertical growing of code issue."],"labels":["needs investigation"]},{"title":"Refactor cURL generation","body":"Currently `Request`'s `cURLDescription` doesn't cover all credential and possibly other cases. We should refactor to provide these capabilities. ","comments":["Hello, I am an experienced iOS developer with a bit a free time on my hands at the moment, and I was interested to see if I could make some contributions to the AlamoFire project. I would be interested in taking on this task or something else if someone was willing to give me some information on what needs to be done.","@tronthomas Currently the `cURLDescription` method is rather ad hoc, as it has evolved alongside the library over the years. It would be great if it we could better define exactly which features of cURL we're supporting and formalize how we produce the data. This includes enhancing how we handle cookies and other elements (see #2435)."],"labels":["enhancement"]},{"title":"Request Deduplication","body":"Some ability to deduplicate requests for the same resource would be quite powerful and could lead to some nice abilities. AlamofireImage currently does this, as well as Moya. We should be able to adapt the feature to something more general to be included with the base library.","comments":[],"labels":["feature request"]},{"title":"URLComponents API Support","body":"Adding URLComponents support to some of Alamofire's APIs could result in more elegant request creation, especially in `URLEncoding`.","comments":["Hello, @jshier  \ud83d\udc4b\ud83c\udffd\r\n\r\nI've been doing some investigation\/experimentation around this issue. I've been able to use the `URLComponents` API, but I faced some problems related to percent encoding. For some reason, the `URLQueryItem` doesn't correctly encode some of the reserved characters described in `RFC 3986` (they are ```:@!`()*+,;```). There's even a description in the documentation regarding part of this limitation: https:\/\/developer.apple.com\/documentation\/foundation\/nsurlcomponents\/1407752-queryitems (the note describes it). The unit tests helped me catching those errors and fixing them (I had to do some post percent encoding). \r\n\r\n"],"labels":["enhancement"]},{"title":"Use URLSessionTask Progress Reporting","body":"In the new OS versions, `URLSessionTask` supports `Progress` reporting directly, which may make it easier to support progress reporting on those OSes. However, integrating it into the existing progress reporting functionality is another question. ","comments":["It didn't work for me!","It didn't worked for me!","We'll reevaluate this after AF5 is released."],"labels":["enhancement"]},{"title":"Task Scheduling Support","body":"We should investigate how Alamofire can support the new task scheduling APIs in the latest OSes. ","comments":["Investigating this a bit further, the documentation states: `This property has no effect for tasks created from nonbackground sessions.` Since this is background-only API, we'll likely need to integrate it into #2233 for real background support."],"labels":["feature request"]}]